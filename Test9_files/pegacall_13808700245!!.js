/****************************************************************************
 * Author:	Jagannadham Parupudi
 * Date:		25-July-2017
 * Description:	Funcitons in this file will be used to interact with CTI toolbar
 *---------------------------------
 * Bugfix history
 *---------------------------------
 * BUG-358174: Simple transfer after V+D transfer behave as V+D transfer
 ****************************************************************************/
if (!pega.cti) pega.cti = {};
pega.cti.WSCloseMsg = "WebSocket subscription lost because of network disruption.";
pega.cti.WSErrorMsg = "WebSocket failed to reconnect. Please refresh your browser, if issue still persists reach out to Admin.";
//Added the pega call queue processor 
pega.cti.pegaCallRequestProcessor = {
    requestQueue: [],
    paused: false,
	resumetimer:null,
    addRequestToQueue: function(method, safeUrl, callback, postData, asyncConfigOptions) {
        var entry = new Object();
        entry.method = method;
        entry.safeUrl = safeUrl;
        entry.callback = callback;
        entry.postData = postData;
        entry.asyncConfigOptions = asyncConfigOptions;
        this.requestQueue.push(entry);
        console.log("Present status of pega call Post Request Queue" + this.requestQueue);
        //start execution of queue
        this.executeNextRequest();

    },
    executeNextRequest: function() {
        var firstElementInQueue;
        if (!this.paused) {
            //Check if the request made to process for first elemet in queue if empty log and return
            if (this.requestQueue.length == 0) {
                console.log("All the post request made are successfully completed.Queue is empty");
                return;
            } else {
				firstElementInQueue = this.requestQueue.shift(); //dequeue
                this.paused = true;
				this.resumetimer = setTimeout(function (){
					console.log("Request timed out, Processing next request");
					pega.cti.pegaCallRequestProcessor.resume();},5000);
                this.processRequest(firstElementInQueue);
            }
        }
    },
    processRequest: function(requestItem) {
        var tempCallBack = new Object();
        if (requestItem != null) {
            //Start of changes for bug, BUG-674407
            var conslog = requestItem.safeUrl;
            if(conslog.hashtable!==undefined){
            if(conslog.hashtable.AgentPwd!==undefined)
              conslog.hashtable.AgentPwd = "**********";
            if(conslog.hashtable.pyUserPassword!==undefined)
              conslog.hashtable.pyUserPassword = "**********";
            }
            console.log("Request made" + requestItem.method + conslog);
           //end of changes for bug, BUG-674407

            tempCallBack.success = function(response) { // Create sucess call back
                console.log("Recieved sucess response" + response)
                try {
                    if (requestItem.callback && requestItem.callback.success)
                        requestItem.callback.success(response);
                } catch (err) {
                    console.log("Failed to process success response" + err.message);
                }
                pega.cti.pegaCallRequestProcessor.resume();
            }

            tempCallBack.failure = function(response) { //create failure call back
                console.log("Recieved failed response" +  JSON.stringify(response));
                try {

                      if (pega.cti.networkErrorMessage != null && pega.cti.networkErrorMessage!= undefined && pega.cti.networkErrorMessage != "")
                  showAlertNotification(pega.cti.networkErrorMessage  + " :HTTP_"+response.status + " "+ response.statusText );    
                      else
                         showAlertNotification("There has been a network error, if the issue persists please contact your system administrator :HTTP_"+response.status + " "+ response.statusText );     

                } catch (err) {
                    console.log("Failed to process failure response" + err.message);
                }
                pega.cti.pegaCallRequestProcessor.resume();
            }
            if (requestItem.callback && requestItem.callback.scope)
                tempCallBack.scope = requestItem.callback.scope;
            try {
                pega.u.d.asyncRequest(requestItem.method, requestItem.safeUrl, tempCallBack, requestItem.postData, requestItem.asyncConfigOptions); // Make Async http request
            } catch (err) {
                this.resume();
                console.log("Failed to process async Request" + err.message);
            }
        }

    },
    resume: function() {
        this.paused = false;
		clearTimeout(this.resumetimer);
        this.executeNextRequest();
    }
}


var oCurrentPhoneState = null;
var currentClientHandle = '';

function registerForEvents() {
    try {
        /*Write all the reg*/
        registerEventListener('PhoneSnapshotEvent', handleSnapshotEvents, '', null); /* Snapshot events */
        registerEventListener('PhoneAgentStateEvent', handlePhoneAgentStateEvents, '', null); /* Agent State change events */
        registerEventListener('PhoneCallStateEvent', handlePhoneCallStateEvents, '', null); /* Call State change events */
        registerEventListener('PhonePartyInfoEvent', handlePhonePartyInfoEvents, '', null); /* Party info change events */
        registerEventListener('PhoneCallInfoEvent', handlePhoneCallInfoEvents, '', null); /* Call info change events */
        registerEventListener('SoftphoneResponse', handleSoftphoneResponse, '', null); /*Softphone response events*/
        registerEventListener('PhoneErrorEvent', handleErrorEvents, "", null); //Error event        
    } catch (e) {
            var errResponse = new pega.cti.desktopApi.errorObject();
            errResponse.errMessage = "FailedToRegisterEvents";
            translateErrorMessage(errResponse,function(response){
                 showAlertNotification(response.responseText+'\n' + e);
            },false);
    }
}

function formatPhoneNumber(filedID) {
    $('#' + filedID)[0].value = ($('#' + filedID)[0].value).replace(/[^\d\#\+\*]/g, '');
}

/*Fixed by RamReddy Boddireddy as part of BUG-614789*/
function autoCompleteOff(testId) {
  var target = $("."+testId).find("input")[0];
  if(target!==null && target!==undefined){
    target.autocomplete="off";
  }
}

function setAgentStateMenu(menuitem1,menuitem2,menuitem3,menuitem4){
   var target = document.querySelector("li[data-test-id='"+menuitem2+"']");
  if(target!==null){
      target.style.pointerEvents="none";
  }
  target = document.querySelector("li[data-test-id='"+menuitem1+"']");
  if(target!==null){
      target.style.pointerEvents="none";
  }
  target = document.querySelector("li[data-test-id='"+menuitem3+"']");
  if(target!==null){
      target.style.pointerEvents="none";
  }
}

function showhtml(str)
{
   if (str.indexOf("<html") > -1){
                        var myWindow = window.open('','','width=700,height=600');
                             var doc = myWindow.document;
                             doc.open();
                             doc.write(str); 
                             return true;
          } 
  else{
      return false;
      }
}

function handleErrorEvents(oData) {
    logCTIPhoneEvent("[Received Error event] " + oData);
    try {
        showhtml(oData);
        var oEvent = JSON.parse(oData);
        var sErrorMessage = oEvent.pyErrorMessage;
        if ((sErrorMessage) && (sErrorMessage != null) && (sErrorMessage != "")) {
            showAlertNotification(sErrorMessage);
        }
    } catch (e) {
        console.log("EXCEPTION Handling Error event.  Error: " + e + " Event: " + oData);
    }
}

function logCTIPhoneEvent(message){
   var presenttime = new Date();
  console.log("timestamp : " + (new Date()).toGMTString() + " " +message);
  
}

function handleSnapshotEvents(oData) {
  try{
    logCTIPhoneEvent('Received Snapshot event: \n' + oData);
    if( pega.cti.API.Logger != null && typeof(pega.cti.API.Logger) != "undefined" ){
    if(oData == null || oData == '' || typeof(oData) == "undefined"){
      pega.cti.API.Logger.Error((new Error('The Received snapshot event is empty')).stack);
    }
   }
    showhtml(oData);
    var oEvent = JSON.parse(oData);
    if(oEvent.pyEventReason != null || typeof(oEvent.pyEventReason) != "undefined")
    showAlertNotification(oEvent.pyEventReason);
    oData.pyLines = null;
    var requestObj = new Object();
    requestObj.requestURL = 'ChannelServices-Device-Phone-UI.UpdateFromSnapshotEvent';
    requestObj.requestData = oData;
    sendEventDataToUser(requestObj);
  }
    catch (e) {
      console.log('Error while handling snapshot event');
    }
}

function handlePhoneAgentStateEvents(oData) {
  try{
    logCTIPhoneEvent('Received Agent event: \n' + oData);
    var requestObj = new Object();
    requestObj.requestURL = 'ChannelServices-Device-Phone-UI.UpdateAgentFromEvent';
    requestObj.requestData = oData;
    sendEventDataToUser(requestObj);
    } catch (e) {
      console.log('Error while handling agent state event');
    }
}

function updateAgentConfig(oData) {
    logCTIPhoneEvent('updateAgentConfig \n' + oData);
    var requestObj = new Object();
    requestObj.requestURL = 'ChannelServices-Device-Phone-UI.UpdateAgentConfig';
    requestObj.requestData = oData;
    sendEventDataToUser(requestObj);
}

function handlePhoneCallStateEvents(oData) {
    try {
       logCTIPhoneEvent('Received CallInfo event: \n' + oData);
        try {
            showhtml(oData);
            var oEvent = JSON.parse(oData);
        } catch (ex) {
            console.log("Unable to parse responce from Pega server. " + ex.message)
        }
        //Handle CallFailed event seperately 
        if (oEvent.pyEventName === 'CallFailed') _handleCallFailedEvent(oEvent.pyCallId, oEvent.pyThisDN);
        var requestObj = {};
        requestObj.requestURL = 'ChannelServices-Device-Phone-UI.UpdateCallFromEvent';
        requestObj.requestData = oData;
        sendEventDataToUser(requestObj);
    } catch (e) {
        console.log('error handling call state event');
    }
}

function handlePhoneCallInfoEvents(oData) {
    try {
        logCTIPhoneEvent('Received CallInfo event: \n' + oData);
        try {
            showhtml(oData);
            var oEvent = JSON.parse(oData);
        } catch (ex) {
            console.log("Unable to parse responce from Pega server. " + ex.message)
        }
        //Handle CallFailed event seperately 
        for (var i = 0; i < oEvent.pyParties.length; i++)
            if (oEvent.pyParties[i].pyDN === oEvent.pyThisDN && oEvent.pyParties[i].pyDNState === 'CallFailed')
                _handleCallFailedEvent(oEvent.pyCallId, oEvent.pyOtherDN);
        var requestObj = {};
        requestObj.requestURL = 'ChannelServices-Device-Phone-UI.UpdateCallInfoFromEvent';
        requestObj.requestData = oData;
        sendEventDataToUser(requestObj);
    } catch (e) {
        console.log('error handling call info event');
    }
}

function _handleCallFailedEvent(CallId, otherDN) {
    var disconnectCall;
      var errResponse = new pega.cti.desktopApi.errorObject();
            errResponse.errMessage = "HangUpFailedCallConfirmation";
            translateErrorMessage(errResponse,function(response){
                 disconnectCall = confirm(response.responseText);
                 if (disconnectCall) {
                        if ((CallId) && (CallId != null)) hangUpCall(CallId);
                        else Console.log('Failed to hang up the failed call.  The call id is not included on the event.');
                      }
            },false);
    
}

function handlePhonePartyInfoEvents(oData) {
    try {
        logCTIPhoneEvent('Received PartyInfo event: \n' + oData);
        var requestObj = {};
        requestObj.requestURL = 'ChannelServices-Device-Phone-UI.UpdateFromPartyInfoEvent';
        requestObj.requestData = oData;
        sendEventDataToUser(requestObj);
    } catch (e) {
        console.log('error handling call info event');
    }
}

function ccpSelectLine(SelectedCallId, SelectedCallState, ActiveCallId, ActiveCallState) {
    // If switching lines (calls) and the active line is connected
    // we need to hold it first
      if (ActiveCallState == "CallFailed")
  {
	   var errResponse = new pega.cti.desktopApi.errorObject();
            errResponse.errMessage = "DropFailedCallToProceed";
            translateErrorMessage(errResponse,function(response){
                 showAlertNotification(response.responseText);
            },false);
   
      return;
  }
    if (SelectedCallState.toUpperCase() !== "IDLE") {
        if (SelectedCallId !== ActiveCallId && (ActiveCallState.toUpperCase() === "CONNECTED" || ActiveCallState.toUpperCase() === "RETRIEVED" || ActiveCallState.toUpperCase() === "INITIATED")) {
            if (typeof(pega.cti.API.alternateCall) == "function" && SelectedCallState.toUpperCase() !== "ALERTING") {
                alternateCall(SelectedCallId, ActiveCallId)
            } else {
                pega.cti.API.holdCall(ActiveCallId, null, function() {
                    _ccpHandleSelectedLine(SelectedCallId, SelectedCallState)
                }, onFailure);
            }
        } else {
            _ccpHandleSelectedLine(SelectedCallId, SelectedCallState);
        }
    }
}

function _ccpHandleSelectedLine(SelectedCallId, SelectedCallState) {
    try {
        switch (SelectedCallState.toUpperCase()) {
            case 'ALERTING':
                answerCall(SelectedCallId, null);
                break;
            case 'HELD':
                retrieveCall(SelectedCallId, null);
                break;
            case 'CONNECTED':
            case 'RETRIEVED':
            case 'INITIATED':
                holdCall(SelectedCallId, null);
                break;
            default:
                break;
        }
    } catch (e) {
        console.log("error handled:" + e.message);
    }
}



 function ApplyCcpCalls(CallId, Destination, Options,ActionParam){
   
   switch(ActionParam){
     case 'Blind':
        ccpBlindTransfer(CallId, Destination, Options)
       break;
     case 'Warm':
       ccpTransferInitiate(CallId, Destination, Options)
         break;
     case 'Conference':
       ccpConferenceInitiate(CallId, Destination, Options)
         break;
     case  'Consult':
       ccpConsultationCall(CallId, Destination, Options)
         break;
     case 'MakeCall' :
        ccpMakeCall(Destination,Options)
         break;
       default:
         break;
  
   }
 }
     

function ccpMakeCall(Destination, Options) {
    makeCall(Destination, Options);
}

function ccpHold(CallId) {
    holdCall(CallId);
}

function ccpRetrieve(CallId) {
    retrieveCall(CallId);
}

function ccpMuteCall(CallId) {
    muteCall(CallId);
}

function ccpUnmuteCall(CallId) {
    unmuteCall(CallId);
}

function ccpDrop(ActiveCallId, Party, PartyCount) {
    if (PartyCount > 1) {
      dropparty(ActiveCallId, Party);
    }
    else { 
      hangUpCall(ActiveCallId);
      keypressOff();
     }
}

function ccpSendDTMF(CallId, DTMFString) {
    sendDTMF(CallId, DTMFString);
}

function ccpConsultationCall(CallId, Destination, Options) {
    consulationCall(CallId, Destination, Options);
}

function ccpBlindTransfer(CallId, Destination, Options) {
    blindTransfer(CallId, Destination, Options);
}

function ccpMergeCalls(HeldCallId, CallId) {
    conferenceComplete(HeldCallId, CallId);
}

function ccpHandOff(HeldCallId, CallId) {
    transferComplete(HeldCallId, CallId);
}

function ccpConferenceInitiate(CallId, Destination, Options) {
    conferenceInitiate(CallId, Destination, Options);
}

function ccpTransferInitiate(CallId, Destination, Options) {
    transferInitiate(CallId, Destination, Options);
}

//start of changes for BUG-674407
function displayConsoleLogs(message,oData){
    var respData = JSON.parse(oData);
    if(respData.pyTempText!==undefined){
      var embedData = JSON.parse(respData.pyTempText);
      if(embedData.AdminPassword!==undefined)
        embedData.AdminPassword = "********";
      if(embedData.pyCCTMonitorPassword!==undefined)
       embedData.pyCCTMonitorPassword = "********";
      respData.pyTempText = JSON.stringify(embedData);
    }
   if(respData.pyOptions!==undefined){
     var options = JSON.parse(respData.pyOptions);
     if(options.pyUserPassword!==undefined)
       options.pyUserPassword = "********";
     respData.pyOptions = options;
   }
    if(respData.pyAgentPwd!==undefined)
    respData.pyAgentPwd = "********";
    console.log(message + JSON.stringify(respData)); 
}
  //end of changes for BUG-674407

function handleSoftphoneResponse(oData) {
    displayConsoleLogs('[Received Soft phone response event] ',oData);
    try {
        /*Commented ChangeTrackerData and replaced with Stream data*/
        //var oEvent = JSON.parse(oData.split('ChangeTrackerData')[0]);
        showhtml(oData);
        var oEvent = JSON.parse(oData.split('StreamData')[0]);
        if (oEvent.Error && oEvent.Error === true) {
            if (oEvent.pyAutoLogin === 'true') {
                var errResponse = new pega.cti.desktopApi.errorObject();
                errResponse.errCode = eventData.pyErrorCode;
                errResponse.errMessage = eventData.pyErrorMessage;
                translateErrorMessage(errResponse, _refreshTelephonyLoginSection, false, eventData);
            } else {
                if ((oEvent.RequestType) && (oEvent.RequestType !== 'Heartbeat')) {
                    showAlertNotification(oEvent.Message);
                    return;
                } 
            }
        }
        
    } catch (e) {
        console.log('EXCEPTION Handling softphone response: ' + e + ' ' + oData);
    }
}

function telephonyLogin(agentId, agendPwd, extension, linkDefinition, options, event) {
    try {
        var opts;
        var linkDef;
        if (options != null) opts = jsonParseOptions(options);
        if (linkDefinition != null) {
            linkDef = jsonParseLinkDefinition(linkDefinition);
        }
     
     if(opts.pyPegaCTIError == ""){ 
      if (eval(pega.cti.API)) {
            pega.cti.API.login(agentId, agendPwd, extension, linkDef, opts, function(response) {
                onSuccess(response);
                //Close overlay on success
                pega.u.d.getPopOver().close();
                if(pega.cti.globalProperties.closeCCPOnLogin==="true")
                  hideUIPanel();
                //Get AgentConfig
                if (typeof pega.cti.API.queryAgentConfig == 'function') {
                    pega.cti.API.queryAgentConfig(function(agentConfigdata) {
                        this.updateAgentConfig(JSON.stringify(agentConfigdata));
                    }, onFailure);
                }
            }, function(errResponse) {
                translateErrorMessage(errResponse, function() {
                    _refreshTelephonyLoginSection('AgentAvailability');
                }, true);
            }, asyncResponse);
    
        } else {
            sendError('Please review and include ' + linkDef.pyJavascriptObject + ' in the PegaCallBundle');
        }
     }
    } catch (err) {
        sendError(err.message);
    }
}

function sendEventDataToUser(requestObj) {
    var postData = new SafeURL();
    //var activityUrl = new SafeURL(requestObj.requestURL);
    var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIEvents");
    postData.put('RequestType', requestObj.requestURL);
    postData.put('Event', requestObj.requestData);
    activityUrl.put('pzPrimaryPageName', 'CTIPhone');
    console.log("timestamp : " + (new Date()).toGMTString() + " " + "Request to " + requestObj.requestURL + " with data " + requestObj.requestData);
    pega.cti.pegaCallRequestProcessor.addRequestToQueue('POST', activityUrl, {
        success: function(oResponse) {
            var request = oResponse;
            if (request.status === 200) {
                var response = request.responseText;
                try {
                    /*Commented ChangeTrackerData and replaced with Stream data*/
                    //responseObj = JSON.parse(response.split('ChangeTrackerData')[0]);
                    responseObj = JSON.parse(response.split('StreamData')[0]);
                    if (responseObj.pyPegaCTIError != "Good" && responseObj.pyPegaCTIError != "" )
                    {sendError(responseObj.pyPegaCTIError); }
                    showhtml(response);
                    pega.cti.globalProperties.agentIsOnCall = responseObj.AgentIsOnCall;
                     var embeddedPanel = $("#EmbeddedCCP");
        			       embeddedPanel[0].className = "cti-embedded-div-embeddedui";
                     alignCTIPosition();
                     //embeddedPanel[0].style = "width:auto;height:auto;overflow:hidden";
                     if($("div[data-node-id='AgentAvailability']")[0]!==undefined){
                         $("div[data-node-id='AgentAvailability']")[0].remove();
                         
                     }
                      embeddedPanel.append(response.split('StreamData')[1]);
                     setTimeout(function(){
                        if((requestObj.requestURL == "ChannelServices-Device-Phone-UI.UpdateAgentFromEvent" 
                            || requestObj.requestURL == "ChannelServices-Device-Phone-UI.UpdateFromSnapshotEvent")
                            && $("button[name*='AgentStateMenu_CTIPhone_']")[0]!==undefined){
                            $("button[name*='AgentStateMenu_CTIPhone_']")[0].focus();
                         } 
                      },2000)
                  
                    if (responseObj.pyRefreshPage != null && responseObj.pyRefreshPage != undefined) {
                        if (responseObj.pyRefreshPage == "true" || responseObj.pyRefreshPage == true)
                            if (responseObj.pyDeviceState == "OPENED") {
                                telephonyLogin(responseObj.pyAgentId, responseObj.pyAgentPwd, responseObj.pyExtension, responseObj.pyTempText, responseObj.pyOptions);
                            }
                    }
                    if (responseObj.ChanServInsName != null && responseObj.ChanServInsName != undefined) {
                        reassociateChannel(responseObj);
                    }

                    if (responseObj.pyCallTreatment != null && responseObj.pyCallTreatment != undefined) {
                        if (window.ScreenPopEventHandler)
                            ScreenPopEventHandler(responseObj.pyCallTreatment);
                        else
                            sendEvent("PegaCallScreenPopRequest", responseObj.pyCallTreatment, 'SYNC');
                    }
                     pega.api.ui.actions.refreshSection({'section':'PhoneIconSection'});
                } catch (ex) {
                    console.log("Unable to parse responce from Pega server. " + ex.message)
                }
                console.log("timestamp : " + (new Date()).toGMTString() + " " + "Successfully sent data to user with response " + response);
            } else {
                console.log("timestamp : " + (new Date()).toGMTString() + " " + "HTTP Error: " + request.statusText + "in sendEventDataToUser")
                sendError("HTTP Error: " + request.statusText + "in sendEventDataToUser");
            }
        },
        failure: function(oResponse) {
            console.log("timestamp : " + (new Date()).toGMTString() + " " + "HTTP Error: " + oResponse.statusText + "in sendEventDataToUser");
            sendError("HTTP Error: " + oResponse.statusText + "in sendEventDataToUser");
        },
        scope: this
    }, postData);
}

function _refreshTelephonyLoginSection(response) {
    var sectionNodes = pega.u.d.getSectionsByName("AgentAvailability", document);
    if (sectionNodes) {
        refreshSection("AgentAvailability", event);
    } else if (typeof telephoneclick !== 'undefined') {
        var actionURL = new SafeURL();
        actionURL.put("IgnoreSectionSubmit", true);
        actionURL.put("bInvokedFromControl", true);
        actionURL.put("pzPrimaryPageName", "CTIPhone");
        pega.u.d.processAction('AgentAvailabilityFlow', '', 'Rule-HTML-Section', '', '', 'overlay', telephoneclick,
            'pzModalTemplate', actionURL, '', '', '');
    } else {
        if (typeof $('i[title="Phone"]')[0] !== 'undefined') $('i[title="Phone"]')[0].click();
    }
}
var telephoneclick;

function quickCallLogin(event) {
    telephoneclick = event;
    var responseObj = new Object();
    var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.SetStatefulOptions");
    activityUrl.put("pzPrimaryPageName", "CTIPhone");
   pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
        success: function(oResponse) {
            var request = oResponse;
            var response = request.responseText;
            var linkDefinition;
            try {
                showhtml(response);
                responseObj = JSON.parse(response);
            } catch (err) {
                console.log("Error while parsing the SetStatefulOptions response: " + err.message);
            }
            try {
                linkDefinition = jsonParseLinkDefinition(responseObj.pyTempText);
            } catch (err) {
                console.log("Error while parsing the linkDefinition: " + err.message);
            }
              var loglevel;
            if(linkDefinition.pyLogging != undefined){
              loglevel = linkDefinition.pyLogging.pyLogLevel
            }
            if (typeof linkDefinition.pyJavascriptObject !== 'undefined') {
              loadApi(linkDefinition.pyJavascriptObject,loglevel);
            }
             if(linkDefinition.IsEmbeddedUI != undefined && linkDefinition.IsEmbeddedUI == "true") {
                loadEmbeddedApi(responseObj.pyTempText, responseObj.pyOptions);
             }else {
                telephonyLogin(responseObj.pyAgentId, responseObj.pyAgentPwd, responseObj.pyExtension,responseObj.pyTempText, responseObj.pyOptions, event);
             }
        },
        failure: function() {
            var errResponse = new pega.cti.desktopApi.errorObject();
            errResponse.errMessage = "RequestfromServerfailed";
            translateErrorMessage(errResponse,function(response){
                 showAlertNotification(response.responseText+'\n' + e);
            },false);
        },
        scope: this
    }, "");
}
$(document).ready(function() {
    try {
        registerForEvents();
        initializeSoftPhone();
    } catch (e) {}
});

function showAlertNotification(message) {
    if(pega.cti.globalProperties.enableAlertNotification==="true"){
    var x = document.getElementById("ctiNotificationDiv");
    x.className = "show";
    var y = document.getElementById("ctiNotificationMessage"); 
    y.innerHTML = message;
     if(pega.cti.globalProperties.timeOutDuration>0){
        setTimeout(function(){ 
          x.className = x.className.replace("show", ""); 
        }, pega.cti.globalProperties.timeOutDuration);
      }
    }
  else{
      alert(message);
  }
};

function alignCTIPosition(){ 
    var embeddedPanel = $("#EmbeddedCCP");
  switch(pega.cti.globalProperties.ctiPosition){
    case "topleft": embeddedPanel[0].className = embeddedPanel[0].className+" "+pega.cti.globalProperties.ctiPosition;
                    break;
    case "topright": embeddedPanel[0].className = embeddedPanel[0].className+" "+pega.cti.globalProperties.ctiPosition;
                    break;
    case "bottomleft" : embeddedPanel[0].className = embeddedPanel[0].className+" "+pega.cti.globalProperties.ctiPosition;
                    break;
    default: embeddedPanel[0].className = embeddedPanel[0].className+" default";
      
  }
};
  
function hideUIPanel(){ 
    $('#EmbeddedCCP').slideUp(300);
};

function triggerResize(){
  $(window).trigger("resize");
}

//Added as part of bug, BUG-606110 to handle resize of draggable div
$(window).resize(function(){
   if(draggingtype === undefined || draggingtype === null || draggingtype === "empty" || draggingtype === ''){
      console.log("Dragging type is not set");
    }
  else{
     try{
        var windowheight = $( window ).height();
        var windowwidth = $( window ).width();
        var offsettop = $('#EmbeddedCCP').offset().top;
        var offsetleft = $('#EmbeddedCCP').offset().left;
        var ccpheight = $('#EmbeddedCCP').height();
        var ccpwidth = $('#EmbeddedCCP').width();
        if(parseFloat(offsettop) > (parseFloat(windowheight)-(parseFloat(ccpheight))))
          {
             var x = (parseFloat(windowheight)-(parseFloat(ccpheight)));
             if(x<0) x=0;
             if($("#EmbeddedCCP")[0]!==undefined)
             $("#EmbeddedCCP")[0].style.top=x+"px";
             $("#EmbeddedCCP")[0].style.bottom="auto";
          }
        if(parseFloat(offsetleft) > (parseFloat(windowwidth)-(parseFloat(ccpwidth)+10)))
          {
             var x = (parseFloat(windowwidth)-(parseFloat(ccpwidth)+10));
             if(x<0) x=0;
             if($("#EmbeddedCCP")[0]!==undefined)
             $("#EmbeddedCCP")[0].style.left=x+"px";
             $("#EmbeddedCCP")[0].style.right="auto";
          }
        }
        catch(ex){
          //Exception while setting transfer overlay size
        }   
  }
});

//Code to set the focus on phone records.
function setFocusToDestinationDNElement() {
    $('div.destinationDNClass').find("input").focus();
}

function createFocusPhoneRecords() { if (pega.cti.setfocus == false || pega.cti.setfocus== "false") 
	{ $('div.destinationDNClass').find("input").focus();
	return;}
var longpress = 25;
var phoneBookRecords = $("div.phoneBookRecord");
  pega.cti.phoneBook = []; 
	
phoneBookRecords.each(function(index, element) {
  pega.cti.phoneBook[index]=
   $(phoneBookRecords[index]).find('[data-click]').keydown(function(e) {
						
        if (e.keyCode == 40 && index < phoneBookRecords.length) {

            pega.cti.phoneBookForceExecute = function() {
                $(phoneBookRecords[index + 1]).find('[data-click]').focus()
            };

            pega.cti.phoneBookDelay = setTimeout(pega.cti.phoneBookForceExecute, longpress);

        } else if (e.keyCode == 38) {

            if (index != 0) {
                pega.cti.phoneBookForceExecute = function() {
                    $(phoneBookRecords[index - 1]).find('[data-click]').focus()
                };
                pega.cti.phoneBookDelay = setTimeout(pega.cti.phoneBookForceExecute, longpress);
            } else
                $('div.destinationDNClass').find("input").focus();
        }

    });

   $(pega.cti.phoneBook[index]).attr("tabIndex", index);
  
    $(phoneBookRecords[index]).find('[data-click]').keyup(function() {	
		pega.cti.phoneBookForceExecute();
        clearTimeout(pega.cti.phoneBookDelay);
    });

}); 

 if (phoneBookRecords.length == 0)
	 $('div.destinationDNClass').find("input"  ).focus();
			else 
		                $(pega.cti.phoneBook[0]).focus();	
			

  
}


function refreshPhoneBookRecords(refreshPhoneRecord) {
pega.cti.setfocus = refreshPhoneRecord;
}



//static-content-hash-trigger-YUI


function loadEmbeddedApi(linkdef,options){  
  var opts;
  var linkDefinition;
     pega.u.d.getPopOver().close();
     if(pega.cti.API != null)
     { if (pega.cti.API.load != undefined) {
       linkDefinition = jsonParseLinkDefinition(linkdef);
        if (options != null) opts = jsonParseOptions(options);
      
       try{
         //Added below code to remove content from embedded ui
         if($("div[data-node-id='AgentAvailability']")[0]!==undefined){
                         $("div[data-node-id='AgentAvailability']")[0].remove();
                          
              }          
          pega.cti.API.load(linkDefinition,opts,function(){    
            pega.cti.embeddedEventHandler.setUIPanelActive("true");        
         },function(){
            sendError('Unable to load Embedded API.');            
          });
       }
       catch(e){sendError('Failed to load Embedded API.');}
          
        }
      else
        {
            sendError('Unable to load Embedded API.');
        }
     }
  else
    {
      sendError('API not loaded.Please select the link.');
    }
 }

/****************
 * Author:	Phani Kavuri
 * Date:		21-Jan-2019
 *****************/
if (!pega.cti) pega.cti = {};
pega.cti.embeddedEventHandler = {
  agentInfo(userName,userId,extension,state){
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
    
        postData.put("RequestType","SetEmbeddedApiAgentInfo");
        postData.put("ActivityClass","ChannelServices-Device-Phone-UI");
        postData.put("pzPrimaryPageName", "CTIPhone");
    
        activityUrl.put("UserName", userName);
        activityUrl.put("UserId", userId);
        activityUrl.put("State", state);
        activityUrl.put("Extension", extension);
    
        pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
            success: function(oResponse) {
                console.log("Agent informatin is populated to CTIPhone page successfully ");
                var options = {      
                          section: "EmbeddedCcpHeader",
                          submitOnRefresh: "true"
                      }; 
                pega.api.ui.actions.refreshSection(options);
            },
            failure: function(oResponse) {
                console.log("Failed to populate agent information");
            },
            scope: this
        }, postData);
  },
   enableClickToCall: function() {
        this.setClicktoCall(true);
    },

    disableClickToCall: function() {
        this.setClicktoCall(false);
    },

    setClicktoCall: function(isClicktoCallEnabled) {
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
       postData.put("RequestType","SetClickToCall");
       postData.put("ActivityClass","ChannelServices-Device-Phone-UI");
        activityUrl.put("ClickToCall", isClicktoCallEnabled);
        postData.put("pzPrimaryPageName", "CTIPhone");
        pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
            success: function(oResponse) {
                console.log("Click to Call flag sucesfully set to true");
            },
            failure: function(oResponse) {
                console.log("Failed to set click to call flag");
            },
            scope: this
        }, postData);
    },

    applyCallTreatment: function(event) {
        // Create Interaction and Apply Call Treatment 
        var responseObj = new Object();
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Event-CTILink.CreateInteractionFromEvent");
        //postData.put("pzPrimaryPageName", "CTIEvent");
        postData.put("Event", event);
        pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
            success: function(oResponse) {
                var request = oResponse;
                if (request.status === 200) {
                    var response = request.responseText;
                    showhtml(response);
                    responseObj = JSON.parse(response);
                    if (responseObj.pyPopType !== "NONE") {
                        responseObj.pyOPENCTI = true;
                        response = JSON.stringify(responseObj);
                        if (window.ScreenPopEventHandler)
                            ScreenPopEventHandler(response);
                        else
                               sendEvent("PegaCallScreenPopRequest", response,'SYNC');
                    } else
                        console.log("Call treatment is set to NONE");
                } else {
                    sendError("HTTP Error: " + request.statusText); // Check if it exists or not
                }
            },
            failure: function(oResponse) {
                sendError("HTTP Error: " + oResponse.statusText); // Check if it exists or not
            },
            scope: this
        }, postData);
    },


    showUIPanel: function() {
       $('#EmbeddedCCP').slideDown(300);
      /* var responseObj = new Object();
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.ShowUIPanel");
        postData.put("pzPrimaryPageName", "CTIPhone");
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {
                document.getElementById('EmbeddedCCP').style.display = 'block';
                console.log("Click to Call flag sucesfully set to true");
            },
            failure: function(oResponse) {
                console.log("Failed to set click to call flag");
            },
            scope: this
        }, postData);*/
    },

    hideUIPanel: function() {
       $('#EmbeddedCCP').slideUp(300);
      /*
        var responseObj = new Object();
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.HideUIPanel");
        postData.put("pzPrimaryPageName", "CTIPhone");
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {

                console.log("Click to Call flag sucesfully set to true");
            },
            failure: function(oResponse) {
                console.log("Failed to set click to call flag");
            },
            scope: this
        }, postData);
      */
     },
  
    setUIPanelActive: function(uiPanelActive){
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
        postData.put("RequestType", "SetUIPanel");
        postData.put("ActivityClass","ChannelServices-Device-Phone-UI");
        postData.put("pzPrimaryPageName", "CTIPhone");
        postData.put("UIPanelActive", uiPanelActive);
        pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
            success: function(oResponse) {
                var embpanel = document.getElementById('EmbeddedCCP');
                embpanel.removeAttribute("draggable");
                var dragtype=oResponse.responseText;
                draggingtype = dragtype;
                if(dragtype==="jquery")
                   jquerydrag();
                if(dragtype==="html")
                   htmldrag();
                console.log("UIPanelActive is set to"+uiPanelActive);
            },
            failure: function(oResponse) {
                console.log("Failed to set UIPanelActive flag");
            },
            scope: this
        }, postData);
    },
    expandCCP: function(){
         var embeddedPanel = $("#EmbeddedCCP");
         embeddedPanel[0].className = "cti-embedded-div-embeddedui";
         alignCTIPosition();
        },
    collapseCCP: function(){
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-embeddedui-collapsed"; 
            alignCTIPosition();
        },
    setTransferFramesize: function(){
         //To set iframe size for embedded links
        },
    resetTransferFramesize: function(){ 
        //To set iframe size for embedded links
        }

};

function sendDtmfOnKeyPress(activeCallId, dtmfFlag) {

    if (dtmfFlag == "true") {
        $(document).on('keypress', function(event) {
            if ((document.querySelector("div[data-node-id='CTIDialpad']") == undefined) || document.querySelector("div[data-node-id='CTIDialpad']") == '') {
                keypressOff();
            } else if (document.querySelector("div[data-node-id='CTIDialpad']").parentElement.style.display != '') {
                keypressOff();
            } else {

                var ev = event || window.event;
                if (ev.target.tagName == "INPUT") {
                    return;
                }

                var key = ev.keyCode || ev.which;
                ev.stopImmediatePropagation();

                if (event.which === 35 && event.shiftKey) {
                    ccpSendDTMF(activeCallId, "#")
                  return;
                }
              
              if (event.which === 42 && event.shiftKey) {
                    ccpSendDTMF(activeCallId, "*")
                  return;
                }

                switch (key) {
                    case 48:
                        ccpSendDTMF(activeCallId, "0")
                        break;

                    case 49:
                        ccpSendDTMF(activeCallId, "1")
                        break;

                    case 50:
                        ccpSendDTMF(activeCallId, "2")
                        break;

                    case 51:
                        ccpSendDTMF(activeCallId, "3")
                        break;

                    case 52:
                        ccpSendDTMF(activeCallId, "4")

                        break;
                    case 53:

                        ccpSendDTMF(activeCallId, "5")
                        break;

                    case 54:
                        ccpSendDTMF(activeCallId, "6")
                        break;

                    case 55:
                        ccpSendDTMF(activeCallId, "7")
                        break;

                    case 56:
                        ccpSendDTMF(activeCallId, "8")
                        break;

                    case 57:
                        ccpSendDTMF(activeCallId, "9")
                        break;

                    case 106:
                        ccpSendDTMF(activeCallId, "*")
                        break;

                    default:
                        break;

                }
            }
        });
    } else {
        keypressOff();
    }
}

function keypressOff() {
    $(document).off('keypress')

}


//Function to togglePhoneUI
  function togglePhoneUI(dragtype) { 
    draggingtype = dragtype;
    var embeddedPanel = $("#EmbeddedCCP");
    var embpanel = document.getElementById('EmbeddedCCP');
    //embpanel.setAttribute("tabindex","0");
    embpanel.removeAttribute("draggable");
    var count1 = document.getElementById('EmbeddedCCP').getElementsByTagName('iframe').length;
    if(document.getElementById('EmbeddedCCP').innerHTML.indexOf("The operation completed successfully") !== -1 || embeddedPanel[0].innerHTML===" " || 
       ($("div[data-node-id='AgentAvailability']")[0]===undefined && count1===0)){
                    
        embeddedPanel[0].className = "cti-embedded-div-embeddedui";
        alignCTIPosition();
        var postData = new SafeURL();
        postData.put("RequestType","GenerateHTML");
        postData.put("ActivityClass","@baseclass");
        postData.put("pzPrimaryPageName", "CTIPhone");
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {
                console.log("UIPanelActive is set to"+oResponse.responseText);
              if($("div[data-node-id='AgentAvailability']")[0]!==undefined){
                         $("div[data-node-id='AgentAvailability']")[0].remove();
              }
              embeddedPanel.append(oResponse.responseText);         
            $('#EmbeddedCCP').slideToggle(300);  
            if(dragtype==="jquery")
                jquerydrag();
            if(dragtype==="html")
                htmldrag();
              try{
                  $("button[name='EmbeddedCcpHeader_CTIPhone_15']")[0].focus();
                }
                catch(e){
                  console.log("Unable to find focus button");
                }
            },
            failure: function(oResponse) {
                console.log("Failed to set UIPanelActive flag");
            },
            scope: this
        }, postData);
      }
    else   {
            alignCTIPosition();
            $('#EmbeddedCCP').slideToggle(300); 
             if(dragtype==="jquery")
                jquerydrag();
             if(dragtype==="html")
                htmldrag();
             try{
                 $("button[name='EmbeddedCcpHeader_CTIPhone_15']")[0].focus();
               }
               catch(e){
                  console.log("Unable to find focus button");
                }
    }
  }

  function jquerydrag(){
    console.log("Dragging type has been set to JQuery");
    $("#EmbeddedCCP").draggable({containment:'window',
        start: function () {
            $(this).css("bottom", "auto");
        }, 
        stop: function () {
            var l = ( 100 * parseFloat($(this).position().left / parseFloat($(window).width())) );
            var t = ( 100 * parseFloat($(this).position().top / parseFloat($(window).height())) );
            if(l<0){ l = 0+"%";}else{l = l + "%";}
            if(t<0){ t = 0 + "%";}else {t = t + "%";}
            $(this).css("left", l);
            $(this).css("top", t);
        }
     });
  }
  function htmldrag(){  
      console.log("Dragging type has been set to HTML5 draggable");
      var elem = $("div[data-node-id='EmbeddedCcpHeader']");
      elem.attr('draggable','true');
      //setDragOverContext();  
      elem.bind('dragstart', handleDragStart);
      elem.bind('dragend', handleDragEnd);
      elem.bind('mousedown', handleMouseDown);
  }
  function setDragOverContext(){
    if(document.getElementsByTagName('body')[0]!==null && document.getElementsByTagName('body')[0]!==undefined){
       document.getElementsByTagName('body')[0].setAttribute("ondragover","allowDrop(event)"); 
       var iframe = document.getElementsByTagName("iframe");
       for(i=0;i<iframe.length;i++){
         try{
         var elmnt = iframe[i].contentWindow.document.getElementsByTagName("body")[0];
         if(elmnt!==null && elmnt!==undefined)
           elmnt.addEventListener('dragover',allowDrop,false); 
         }
         catch(ex){}
        }
    }
  }

  function handleDragStart(e){
    try{
    if(window.navigator.userAgent.indexOf("Firefox") !== -1){
    setDragOverContext();
    }
    }catch(ex){}
  }
  var mouseposX = 0;
  var mouseposY = 0;
  var mousedownX = 0;
  var mousedownY = 0;
  var draggingtype;
  function allowDrop(e) {
    e.preventDefault();
    mouseposX = e.clientX;
    mouseposY = e.clientY;
  }
  function handleMouseDown(e){
    var offsettop = $('#EmbeddedCCP').offset().top;
    var offsetleft = $('#EmbeddedCCP').offset().left;
    var mouseX = e.clientX;
    var mouseY = e.clientY;
    mousedownX = mouseX - offsetleft;
    mousedownY = mouseY - offsettop;
  }
  function handleDragEnd(e){
    var clientx = e.clientX;
    var clienty = e.clientY;
    try{
    if(window.navigator.userAgent.indexOf("Firefox") !== -1){
      clientx = mouseposX;
      clienty = mouseposY;
    }
    }catch(ex){}
    if(clientx<0)clientx=0;
    if(clienty<0)clienty=0; else clienty=clienty + 45;
    var posleft = document.getElementById("EmbeddedCCP").offsetWidth;
    var postop = document.getElementById("EmbeddedCCP").offsetHeight;
    var winwidth = parseFloat($(window).width());
    var winheight = parseFloat($(window).height());
    var l = parseFloat(winwidth) - parseFloat(clientx);
    var l1 = l - parseFloat(posleft) + parseFloat(mousedownX);
    var t = parseFloat(winheight) - parseFloat(clienty);
    var t1 = t - parseFloat(postop) + parseFloat(mousedownY);
    var xpos = parseFloat(clientx) - parseFloat(mousedownX) - 10;
    var ypos = parseFloat(clienty) - parseFloat(mousedownY) + 20; 
    if(l1<0){ l1 = parseFloat(winwidth) - parseFloat(posleft) +"px";}else{l1 = clientx===0?clientx:xpos<=0?0:xpos + "px";}
    if(t1<0){ t1 = parseFloat(winheight) - parseFloat(postop) + "px";}else {t1 = clienty===0?clienty:ypos<=0?0:ypos + "px";}
    $("#EmbeddedCCP").css("left", l1);
    $("#EmbeddedCCP").css("top", t1);        
    $("#EmbeddedCCP").css("bottom", "auto");
  }
       
  function showUIPanel(){ 
    $('#EmbeddedCCP').slideDown(300);
  }
      
 function setTransferOverlayHeight(){
   try{
      var windowheight = $( window ).height();
      var offsettop = $('#EmbeddedCCP').offset().top;
      var ccpheight = document.getElementsByClassName("cti-embedded-transferpanel")[0].offsetHeight;
      if(parseFloat(offsettop) > (parseFloat(windowheight)-(parseFloat(ccpheight)+35)))
        {
          var x = (parseFloat(windowheight)-(parseFloat(ccpheight)+40));
          if(x<0) x=0;
          if($("#EmbeddedCCP")[0]!==undefined)
            $("#EmbeddedCCP")[0].style.top=x+"px";
          $("#EmbeddedCCP")[0].style.bottom="auto";
        }
    }
   catch(ex){
          //Exception while setting transfer overlay size
    }
      }
  function expandCCP(){
    try{  
         try{
              //$(".202009110519400367846").find("button")[0].tabIndex = 1;
              $("button[name='EmbeddedCcpHeader_CTIPhone_15']")[0].focus();
            }
            catch(e){
               console.log("Unable to find focus button");
            }
        var windowheight = $( window ).height();
        var offsettop = $('#EmbeddedCCP').offset().top;
        var ccpheight = $('#EmbeddedCCP').height();
        if(parseFloat(offsettop) > (parseFloat(windowheight)-parseFloat(ccpheight)))
          {
           var x = (parseFloat(windowheight)-parseFloat(ccpheight));
           if(x<0) x=0;
           if($("#EmbeddedCCP")[0]!==undefined)
             $("#EmbeddedCCP")[0].style.top=x+"px";
          }
     }
     catch(ex)
      {
            //Exception while expanding ccp
      }
     pega.cti.API.expandCCP();     
  }

  function collapseCCP(){ 
        try{
              //$(".202009110534430352384").find("button")[0].tabIndex = 1;
              $("button[name='EmbeddedCcpHeader_CTIPhone_14']")[0].focus();
           }
           catch(e){
              console.log("Unable to find focus button");
           }
         pega.cti.API.collapseCCP();        
        }


  function reassociateChannel(responseObj){  
    var postData = new SafeURL();
    var activityUrl = new SafeURL("@baseclass.RedirectAndRun");
    if((responseObj.WorkThread != null && responseObj.WorkThread != undefined) && (responseObj.ChanServInsName != null && responseObj.ChanServInsName != undefined)) {
    postData.put('ThreadName', responseObj.WorkThread);
    postData.put('Location', "pyActivity=ChannelServices-Device-Phone-UI.ReassociateChannel&ChanServInsName=" + responseObj.ChanServInsName);
    pega.cti.pegaCallRequestProcessor.addRequestToQueue('POST', activityUrl,{
            success: function(oResponse) {
              console.log("Reassociate channel successfull");
              },
            failure: function(oResponse) {
                 console.log("Reassociate channel request failed");
            },
            scope: this
                     
    },postData);
   }
  }


/* Functions to programatically refresh PhoneIconSection*/
if (!pega.cti) pega.cti = {};
pega.cti.refreshPhoneIconSection = function(){
  pega.api.ui.actions.refreshSection({'section':'PhoneIconSection'});
}


/* Functions to programatically open the phone panel */
if (!pega.cti) pega.cti = {};
pega.cti.showCallControlPanel = function(){ 
  var phoneIcons = pega.ctx.dom.querySelectorAll("[Name^=PhoneIconSection_CTIPhone]");  
  for(var count=0;count < phoneIcons.length; count++){
    var icon = phoneIcons[count];
    //pega.control.actionSequencer.fireTopPriorityEvent(icon,"click");  
   }
}

pega.cti.globalProperties = {
  
  enableAlertNotification :false,
  timeOutDuration : 5000,
  ctiPosition: "",
  closeCCPOnReady: false,
  closeCCPOnNotReady: false,
  closeCCPOnLogout: false,
  closeCCPOnLogin: false,
  closeCCPPendingStateOnCall: false,
  agentIsOnCall: false
  
};
/* Functions to fetch the user configuration */
function getUserConfig(agentID, linkDefinition,options) {
    var linkDef;
    if (linkDefinition != null) {
        linkDef = jsonParseLinkDefinition(linkDefinition);
    }
       if (options != null) opts = jsonParseOptions(options);
 if(opts.pyPegaCTIError != "") return;
  
    if (typeof pega.cti.API.getUserConfig == 'function')
        pega.cti.API.getUserConfig(agentID, linkDef, (oData) => {
            try {
                logCTIPhoneEvent('Received user SSO config event: \n' + oData);
                var requestObj = new Object();
                requestObj.requestURL = 'ChannelServices-Device-Phone-UI.UpdateUserConfig';
                requestObj.requestData = oData;
                sendEventDataToUser(requestObj);
            } catch (e) {
                console.log('Error while agent SSO Config event');
            }
        }, (oData) => {
            onFailure(oData);
            var SSOLogin = new Object();
            SSOLogin.pyEventName = 'UserConfig';
            SSOLogin.pyMedia = "Phone";
            SSOLogin.pyEventType = 'UserConfig';
            SSOLogin.pyAuthMode = "NON_SSO";
            logCTIPhoneEvent('Received user SSO config failed event: \n' + oData);
            var requestObj = new Object();
            requestObj.requestURL = 'ChannelServices-Device-Phone-UI.UpdateUserConfig';
            requestObj.requestData = JSON.stringify(SSOLogin);
            sendEventDataToUser(requestObj);
        })

}


function SendSSOInformation(oData) {
    if (typeof pega.cti.API.setTokenForSSO == 'function') {
        typeof pega.cti.API.setTokenForSSO(oData);
    }
}

function refreshSSOToken(oldToken) {
    var postData = new SafeURL();
    var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
    activityUrl.put("pzPrimaryPageName", "CTIPhone");
    postData.put("RequestType", "RefreshToken");
    postData.put("ActivityClass", "ChannelServices-Device-Phone-UI");
    activityUrl.put("accessToken", oldToken);
    pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
        success: function(oResponse) {
            var request = oResponse;
            
            console.log(request);
          if (request.status ==200)
{
          pega.cti.API.updateTokenForSSO(request.responseText);
}
        },
        failure: function(oResponse) {
            sendError("HTTP Error: " + oResponse.statusText + "in refresh SSO Token");
        },
        scope: this
    }, postData);

}
//static-content-hash-trigger-GCC
/*
@public - Prototype definition for pega.cti.desktopApi
*/
pega.cti.desktopApi = function() {
  
};


/*
@public - Error object definition supported by Pega Call
*/
pega.cti.desktopApi.errorObject = function() {
    var errCode = null;
    var errMessage = null;
}


pega.cti.desktopApi.prototype = {
  
/*
@api - Initalize the object from link definition
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	initialize: function () {
	
	},

/*
@api - Log agent into the ACD.
@param $String$agentId – The Agent's ACD ID.
@Param $String$agentPwd - The Agent's ACD Password
@Param $String$agentPwd - The Agent's ACD Password
@Param $String$extension - The Agent's ACD extension/Position
@Param $String$linkDefinition - The CTILink definition as configured
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
@param $Function$forwardEvent – Callback function for forwarding asyncronus events from server

*/
	login: function(agentId, agentPwd, extension, linkDefinition, options, success, failure, forwardEvent) {

	},


/*
@api - Log agent out of the ACD.
@param $String$agentId – The Agent's ID
@param $String$reasonCode – The logout reason code
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	logout: function (agentId,reasonCode, options,success,failure) {

	},



/*
@api - Make the agent ready at the ACD
@param $String$agentId – The Agent's ID
@param $String$workMode – The ready work mode
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	agentReady : function (agentId, workMode, options,success,failure)  {

	},

/*
@api - Make the agent not ready at the ACD
@param $String$agentId – The Agent's ID
@param $String$workMode – The not ready work mode
@param $String$reasonCode – The logout reason code
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	agentNotReady: function (agentId,workMode,reasonCode, options,success,failure) {

	},


/*
@api - Send DTMF Tones
@param $String$callId – The callId of the call to send tones to
@param $String$Digits – The String of tones to be sent
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	sendDTMF: function (callId, digits, options,success,failure)  {


	},



/*
@api - Place a new call
@param $String$destination – The digits to dial
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	makeCall:function (destination, options,success,failure)  {

	},


/*
@api - Answer a ringing call
@param $String$callId – The callId of the call answer
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	answerCall: function (callId, options,success,failure) {

      
   },



/*
@api - Retrieve a held call
@param $String$callId – The callId of the held call
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	retrieveCall: function (callId, options,success,failure)  {


	},
  
    /*
  @api - Place a call on mute.
@param $String$CallId – The Call Id of the call to place on mute.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
 */
		muteCall: function(CallId, Options, onSuccess, onFailure) {
      
    },
    /*
  @api - Unmute the Call.
@param $String$CallId – The Call Id of the call to place on mute.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
 */
		unmuteCall: function(CallId, Options, onSuccess, onFailure) {
      
    },

/*
@api - Place a call on hold
@param $String$callId – The Call Id of the call to place on hold
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
 	holdCall: function (callId, options,success,failure)  {
 

  },

/*
@api - Hang up a call
@param $String$callId – parameter description goes here
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	hangUpCall: function (callId, options,success,failure)  {
  
	},


/*
@api - Blind Transfer the call
@param $String$callId – The Active Call Id
@param $String$destination – The dialed digits of the destination party
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	blindTransfer: function (callId, destination, options,success,failure)  {
  
	},


/*
@api - Initiate a (warm/attended) Transfer
@param $String$callId – The Call Id of the call
@param $String$destination – The dialed digits of the transfer destination
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	transferInitiate: function (callId, destination, options,success,failure) {
  

	},

/*
@api - Transfer the call
@param $String$heldcallId – The Call Id of the held party
@param $String$activecallId – The call Id of the active (consulted/destination) call
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	transferComplete: function (heldcallId, activecallId, options,success,failure) {
 
	},


/*
@api - Place a consultation call
@param $String$callId – The callId of the active call
@param $String$destination – The dialed digits of the party to be consulted
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	consulationCall: function (callId, destination, options,success,failure) {
 

	},


/*
@api - Initiate a conference cal
@param $String$callId – The callId of the active call
@param $String$destination – The dialed digits of the party to be conferenced
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	conferenceInitiate: function (callId, destination, options,success,failure)  {

    },


/*
@api - Complete a conference
@param $String$heldcallId – The Call Id of the held call
@param $String$activecallId – The Call Id of the active call
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	conferenceComplete: function (heldcallId, activecallId, options,success,failure)  {


	},



/*
@api - Drop party from a Conference
@param $String$callId – The callId of the call from which party is to be dropped
@param $String$party – The party to be dropped
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	dropparty: function (callId, party, options,success,failure)  {
      

	},
  
/*
@api - Complete a Alternate Call
@param $String$heldcallId – The Call Id of the held call
@param $String$activecallId – The Call Id of the active call
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	alternateCall: function (heldcallId, activecallId, options,success,failure)  {


	},
	
  /*
  @api - Get the logger attached to this object
  */
  getLogger: function(){
    
  },

}
//static-content-hash-trigger-GCC
registerEventListener('OfferingCallEvent', handleOfferingCallEvent, null, null);
registerEventListener("SoftphoneRequest", SoftphoneRequest, null, null);
registerEventListener("PhoneLineStateEvent", PhoneUpdateEvent, null, null);
registerEventListener("PhoneAgentStateUpdateEvent", PhoneUpdateAgentStateEvent, null, null);

if (!pega) var pega = {};
if (!pega.cpm) pega.cpm = {};
/* Constants needed for the APP */
pega.cpm.UNITS = "px";

//Start : To restore the logger methods back as it is getting acquired by Five9
var consoleDebug = window.console.debug;
var consoleInfo = window.console.info;
var consoleWarn = window.console.warn;
var consoleError = window.console.error;
var consoleLog = window.console.log;
//End  : To restore the logger methods back as it is getting acquired by Five9

/* End constants needed for the App */

function showhtml(str)
{ 
   if((str != null) && (str != '') && (str != undefined)){
   if (str.indexOf("<html") > -1){
                        var myWindow = window.open('','','width=700,height=600');
                             var doc = myWindow.document;
                             doc.open();
                             doc.write(str); 
                             return true;
          } 
   else {
     return false;
   }
}
  else{
      return false;
      }
}

function refreshSection(sectionName, event) {
    var preDataTransform = ",";
    var oDataTransform = [];
    var sectionNodes = pega.u.d.getSectionsByName(sectionName, document);
    if (sectionNodes) {
        var sectionsLen = sectionNodes.length;
        for (i = 0; i < sectionsLen; i++) {
            var sectionNode = sectionNodes[0];
            var baseRef = "";
            if (sectionNode) {
                baseRef = pega.u.d.getBaseRef(sectionNode);
            }
            if (preDataTransform && preDataTransform != "") {
                oDataTransform.push(preDataTransform + "<||>" + baseRef);
            }
        }
        var oArgs = {
            reloadElement: sectionNodes,
            bFormSubmit: false,
            bSectionSubmit: false,
            bDoNotSetAll: true,
            event: event,
            strReloadType: 'MultipleSections',
            rwPreActivities: "",
            oDataTransform: oDataTransform,
            sourceString: ''
        }
        pega.u.d.useHashDP = true;
        pega.u.d.reload(oArgs);
        pega.u.d.useHashDP = false;
    }
}

function PhoneUpdateEvent(eventJson) {
    console.log("SoftphoneUpdateEvent " + eventJson);
    var objState;
    try {
        showhtml(eventJson); 
        objState = JSON.parse(eventJson);
    } catch (err) {
        console.log("PhoneUpdateEvent: Error deserializing JSON Event");
        return;
    }
    try {
        var modLine = -1;
        if (objState.hasOwnProperty('ModifiedLine')) modLine = objState.ModifiedLine;
        for (var i = 0; i < objState.lines.length; i++) {
            if (modLine == -1 | modLine == i) {
                var strLineState = buildLinePage(objState.lines[i]);
                SS_DeviceUpdate(strLineState);
            }
        }
    } catch (err) {
        console.log("PhoneUpdateEvent: Error Updating clipboard phone state");
    }
}

function PhoneUpdateAgentStateEvent(eventJson) {
    console.log("SoftphoneUpdateAgentStateEvent " + eventJson);
    var objState;
    try {
        showhtml(eventJson);
        objState = JSON.parse(eventJson);
    } catch (err) {
        console.log("SoftphoneUpdateAgentStateEvent : Error deserializing JSON Event");
        return;
    }
    try {
        //If DeviceState is not passed, it will be null
        SS_AgentStateUpdate(objState.AgentState, objState.DeviceState);
    } catch (err) {
        console.log("SoftphoneUpdateAgentStateEvent : Error updating clipboard agent state");
    }
}

function invokeRequest(url) {
    var request;
    var requestReturnCopy;
    console.log("Invoke " + url);
    if (window.XMLHttpRequest) {
        request = new XMLHttpRequest();
    } else if (window.ActiveXObject) {
        request = new ActiveXObject("Microsoft.XMLHTTP");
    }
    if (request != null) {
        request.onreadystatechange = function() {
            if (request.readyState == 4) {
                requestReturnCopy = request;
            }
        };
        request.open("POST", url, false);
        request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        request.send(null);
    }
    console.log("Response " + requestReturnCopy.responseText);
    return requestReturnCopy;
}

function buildLinePage(objLine) {
    var line = objLine.line;
    line = line + 1;
    var rString = "<pagedata>";
    rString += "<pyLineNumber>" + line + "</pyLineNumber>";
    var callId = objLine.callId;
    if (callId == -1) callId = 0;
    rString += "<pyCallId>" + callId + "</pyCallId>";
    if (objLine.otherDN) rString += "<pyOtherDN>" + objLine.otherDN + "</pyOtherDN>";
    var strState = objLine.eventName;
    if (strState == "Disconnected" || strState == "") strState = "Idle";
    if (strState == "Established") strState = "Connected";
    if (strState == "Retrieved") strState = "Connected";
    if (objLine.thisPartyHeld) strState = "Held";
    rString += "<pyLineState>" + strState + "</pyLineState>";
    if (objLine.callType) rString += "<pyCallType>" + objLine.callType + "</pyCallType>";
    if (objLine.oldCallId) rString += "<pyOldCallId>" + objLine.oldCallId + "</pyOldCallId>";
    rString += "<pyHasCallData>" + objLine.hasCallData + "</pyHasCallData>";
    rString += "<pyParties REPEATINGTYPE=\"PageList\">";
    if (objLine.oParties != null && objLine.oParties.length != 0) {
        for (var i = 0; i < objLine.oParties.length; i++) {
            rString += "<rowdata REPEATINGINDEX=\"" + i + 1 + "\">";
            rString += "<pxObjClass>ChannelServices-Embed-Party</pxObjClass>";
            if (typeof(objLine.oParties[i]) == 'object') {
                rString += "<pyDN>" + objLine.oParties[i].pyDN + "</pyDN>";
                rString += "<pyDNState>" + objLine.oParties[i].pyDNState + "</pyDNState>";
            } else { //String - only DN available
                rString += "<pyDN>" + objLine.oParties[i] + "</pyDN>";
            }
            /* rString += "<pyDNName>" + + "</pyDNName>"; */
            rString += "</rowdata>";
        }
    } else {
        rString += "<rowdata REPEATINGINDEX=\"1\"><pxObjClass>ChannelServices-Embed-Party</pxObjClass></rowdata>";
    }
    rString += "</pyParties>";
    rString += "</pagedata>";
    return rString;
}

function SoftphoneResponse(objResponse) {
    var sJSON = JSON.stringify(objResponse);
    sendEvent("SoftphoneResponse", sJSON);
}
//  New SoftPhone requester Handler  
pega.cti.API = null;
var options = new Object();
//Remove the function below
function loadApi(objectName,logLevel) {
  if (objectName) try {
    
    //Start : To restore the logger methods back as it is getting acquired by Five9
    
    if(!objectName.includes("Five9")){
      window.console.debug = consoleDebug;
      window.console.info = consoleInfo;
      window.console.warn = consoleWarn;
      window.console.error = consoleError;
      window.console.log = consoleLog;
    }
    //End   : To restore the logger methods back as it is getting acquired by Five9
    if (!(pega.cti.API instanceof eval(objectName)))
        pega.cti.API = eval('new ' + objectName + '()');
  if(pega.cti.API != null && pega.cti.API.name && pega.cti.API.implementationVersion ){
    console.log("Loaded Pegasystems " + pega.cti.API.name + " Adapter Version " + pega.cti.API.implementationVersion);
    }
  if ( pega.cti.API != null &&  pega.cti.API.Logger && logLevel && logLevel != "")    
    {    
 //     pega.cti.API.Logger =new pega.cti.Logger();
      pega.cti.API.Logger.setLevel(logLevel);
    }
    }
    catch (err) {
        sendError('Unable to load object ' + objectName + '\nPlease review the PegaCall Bundle');
    } else {
      if(objectName === undefined)
        sendError('\n Save CTILink Definition,if system was upgraded recently');
      else //BUG-356492 - Default javascript object to HTTP if blank
        loadApi('pega.cti.desktopApi.PegaHttp');
    }
   //US-225417
   if(!pega.cti.API.version){
        pega.cti.API.version = 1;
      }
}
//This function is temporarly overwritten which is already in 
function SoftphoneRequest(objRequest) {
    try {
        showhtml(objRequest);
        var request = JSON.parse(objRequest);
        switch (request.RequestType) {
            case "Logout":
            case "Close":
                options.Queue = request.Queue;
                logout(request.AgentId, request.ReasonCode, options);
                break;
            case "Ready":
                options.Queue = request.Queue;
                agentReady(request.AgentId, request.WorkMode, options);
                break;
            case "NotReady":
                options.Queue = request.Queue;
                agentNotReady(request.AgentId, request.WorkMode, request.ReasonCode, options);
                break;
            case "SendDTMF":
                sendDTMF(request.CallId, request.Digits, null);
                break;
            case "MakeCall":
                makeCall(request.Destination, null);
                break;
            case "AnswerCall":
                answerCall(request.CallId, null);
                break;
            case "RetrieveCall":
                retrieveCall(request.CallId, null);
                break;
            case "HoldCall":
                holdCall(request.CallId, null);
                break;
            case "HangUpCall":
                hangUpCall(request.CallId, null);
                break;
            case "BlindTransfer":
                blindTransfer(request.CallId, request.Destination, null);
                break;
            case "TransferInitiate":
                transferInitiate(request.CallId, request.Destination, null);
                break;
            case "TransferComplete":
                transferComplete(request.HeldCallId, request.CallId, null);
                break;
            case "ConsultationCall":
                consulationCall(request.CallId, request.Destination, null);
                break;
            case "ConferenceInitiate":
                conferenceInitiate(request.CallId, request.Destination, null);
                break;
            case "ConferenceComplete":
                conferenceComplete(request.HeldCallId, request.CallId, null);
                break;
            case "DropParty":
                dropparty(request.CallId, request.Party, null);
                break;
        }
    } catch (err) {
        sendError(err.message);
    }
}
// Wrapper login
function login(agentId, agendPwd, extension, linkDefinition, options) {
    try {
        var linkDef = jsonParseLinkDefinition(linkDefinition);
        var opts = jsonParseOptions(options);
        if (pega.cti.API == null) {
            var err = new Object();
            err.message = "Link is not selected or link reference is removed.";
            throw err;
        }
        pega.cti.API.login(agentId, agendPwd, extension, linkDef, opts, function(response) {
            pega.u.d.hideModalWindow();
            onSuccess(response);
        }, function(errResponse) {
            translateErrorMessage(errResponse, _refreshLoginSection, true);
        }, asyncResponse);
    } catch (err) {
        sendError(err.message);
    }
}

function _refreshLoginSection(response) {
    var sectionNodes = pega.u.d.getSectionsByName("LoginScreen", document);
    if (sectionNodes) {
        refreshSection("LoginScreen", event);
    } else {
        var actionURL = new SafeURL();
        actionURL.put("IgnoreSectionSubmit", true);
        actionURL.put("bInvokedFromControl", true);
        actionURL.put("pzPrimaryPageName", "CTIPhone");
        pega.u.d.processAction('AutoLoginFlow', '', 'Rule-HTML-Section', '', '', 'true', event, 'pyLogInModalTemplate',
            actionURL, '', '', '');
    }
}
//Wrapper logout
function logout(agentId, reasonCode, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.logout(agentId, reasonCode, opts, function(response){
          if((pega.cti.globalProperties.agentIsOnCall ==="true" 
             && pega.cti.globalProperties.closeCCPPendingStateOnCall ==="true") ||
             (pega.cti.globalProperties.agentIsOnCall !=="true" && 
              pega.cti.globalProperties.closeCCPOnLogout==="true"))
             hideUIPanel();
            onSuccess(response);
        }, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper agentReady 
function agentReady(agentId, workMode, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.agentReady(agentId, workMode, opts, function(response){
          if((pega.cti.globalProperties.agentIsOnCall ==="true" 
             && pega.cti.globalProperties.closeCCPPendingStateOnCall ==="true") ||
             (pega.cti.globalProperties.agentIsOnCall !=="true" && 
              pega.cti.globalProperties.closeCCPOnReady==="true"))
             hideUIPanel();
            onSuccess(response);
        }, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper agentNotReady
function agentNotReady(agentId, workMode, reasonCode, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.agentNotReady(agentId, workMode, reasonCode, opts, function(response){
          if((pega.cti.globalProperties.agentIsOnCall ==="true" 
             && pega.cti.globalProperties.closeCCPPendingStateOnCall ==="true") ||
             (pega.cti.globalProperties.agentIsOnCall !=="true" && 
              pega.cti.globalProperties.closeCCPOnNotReady==="true"))
             hideUIPanel();
            onSuccess(response);
        }, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper sendDTMF
function sendDTMF(callId, digits, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.sendDTMF(callId, digits, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper makeCall
function makeCall(destination, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.makeCall(destination, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper answerCall
function answerCall(callId, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.answerCall(callId, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper holdCall 
function holdCall(callId, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.holdCall(callId, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}

//Wrapper retrieveCall
function retrieveCall(callId, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.retrieveCall(callId, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}

//Wrapper muteCall 
function muteCall(callId, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.muteCall(callId, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}

//Wrapper muteCall 
function unmuteCall(callId, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.unmuteCall(callId, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}

//Wrapper hangUpCall
function hangUpCall(callId, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.hangUpCall(callId, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper blindTransfer
function blindTransfer(callId, destination, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.blindTransfer(callId, destination, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper transferInitiate
function transferInitiate(callId, destination, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.transferInitiate(callId, destination, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper transferComplete
function transferComplete(heldcallId, activecallId, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.transferComplete(heldcallId, activecallId, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper consulationCall
function consulationCall(callId, destination, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.consulationCall(callId, destination, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper conferenceInitiate
function conferenceInitiate(callId, destination, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.conferenceInitiate(callId, destination, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper conferenceComplete
function conferenceComplete(heldcallId, activecallId, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.conferenceComplete(heldcallId, activecallId, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper dropparty
function dropparty(callId, party, options) {
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.dropparty(callId, party, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}

//Wrapper alternateCall
function alternateCall(heldcallId, activecallId){
    try {
        var opts = jsonParseOptions(options);
        pega.cti.API.alternateCall(heldcallId, activecallId, opts, onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}


//JSON Parser for options
function jsonParseOptions(options) {
    var opts;
    try {
        if (options != null && options != "") {
          showhtml(options);
          opts = JSON.parse(options.replace(/\s/g, ""));
        }
    } catch (err) {
        console.log("Error while parsing the Options: " + err.message);
    }
    return opts;
}
//JSON Parser for linkDefinition
function jsonParseLinkDefinition(linkDefinition) {
    var linkDef;
    try {
        showhtml(linkDefinition);
        if (linkDefinition != null && linkDefinition != "") linkDef = JSON.parse(linkDefinition.replace(/\s/g, ""));
    } catch (err) {
        console.log("Error while parsing the linkDefinition: " + err.message);
    }
    return linkDef;
}
//Wrapper reset page
function resetpage() {
    try {
        pega.cti.API.resetpage(onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}
//Wrapper heartbeat page
function heartbeat() {
    try {
        pega.cti.API.heartbeat(onSuccess, onFailure);
    } catch (err) {
        sendError(err.message);
    }
}

function asyncResponse(response) {
    var eventData;
    try {
        if(typeof response != 'undefined')
        if (typeof response == 'string') {
          showhtml(response);
          eventData = JSON.parse(response);
        } 
        else if (typeof response == 'object') {
            eventData = response;
            response = JSON.stringify(eventData);
        }
    } catch (err) {
        sendError("Error handling Async Response" + err.message);
        return;
    }
    console.log("Event received from adapter "+response);
    switch (eventData.pyEventType) {
        case "Event":
            var customEvent = eventData.pyEvent;
            sendEvent(eventData.pyApplication + eventData.pyTopic, JSON.stringify(customEvent));
            break;
        case "SnapshotEvent":
            sendEvent(eventData.pyMedia + "SnapshotEvent", response);
            break;
        case "AgentStateEvent":
            sendEvent(eventData.pyMedia + "AgentStateEvent", response);
            break;
        case "CallStateEvent":
            sendEvent(eventData.pyMedia + "CallStateEvent", response);
            sendEvent("PublicPhoneCallStateEvent",response);
            if (eventData.pyEventString.toUpperCase() == 'OFFERING' || eventData.pyEventString.toUpperCase() == 'ALERTING') {
                eventData.pyEventName = "Offering";
                eventData.pyEventString = "Offering";
                handleOfferingCallEvent(JSON.stringify(eventData));
            }
            else if (eventData.pyEventString.toUpperCase() =="INITIATED") {
                        eventData.pyEventName = "Initiated";
                        handleInitiatedCallEvent(JSON.stringify(eventData));
             }
            break;
        case "CallInfoEvent":
            for (var i = 0, len = eventData.pyParties.length; i < len; i++) {
                if (eventData.pyParties[i].pyDN == pega.cti.API.dn) {
                    if (eventData.pyParties[i].pyDNState.toUpperCase() == "OFFERING") {
                        eventData.pyEventName = "Offering";
                        eventData.pyEventString = "Offering";
                        handleOfferingCallEvent(JSON.stringify(eventData));
                    }
                    else if (eventData.pyParties[i].pyDNState.toUpperCase() =="INITIATED") {
                        eventData.pyEventName = "Initiated";
                        handleInitiatedCallEvent(JSON.stringify(eventData));
                    }
                    break;
                }
            }
            sendEvent(eventData.pyMedia + "CallInfoEvent", response);
             PublishCallInfoEvent (eventData);
            break;
        case "PartyInfoEvent":
            sendEvent(eventData.pyMedia + "PartyInfoEvent", response);
            break;
        case "PopURL":
            var mySafeURL = new SafeURL(eventData.URL.replace("?pyActivity=", ""));
            var tempURL = mySafeURL.toURL(true, true);
            var myPopWindow = window.open(mySafeURL.toURL(true, true), eventData.TARGET, eventData.WINDOW, true);
            myPopWindow.focus();
            break;
        case "ErrorEvent":
            var errResponse = new pega.cti.desktopApi.errorObject();
            errResponse.errCode = eventData.pyErrorCode;
            errResponse.errMessage = eventData.pyErrorMessage;
            translateErrorMessage(errResponse, function(translatedError, eventData) {
                eventData.pyErrorMessage = translatedError.Message;
                var sJSON = JSON.stringify(eventData);
                sendEvent(eventData.pyMedia + "ErrorEvent", JSON.stringify(eventData));
            }, false, eventData);
            break;
        default:
            break;
    }
}

function openCTI_WriteLog(msg) {
    console.log(msg)
}

function sendError(errMessage) {
    var response = new pega.cti.desktopApi.errorObject();
    response.errCode = 'OPENCTI_ERR_PASS';
    response.errMessage = errMessage;
    onFailure(response);
}

function onSuccess(response) {
    var sJSON;
    if (response != null) {
        sJSON = JSON.stringify(response);
        sendEvent("SoftphoneResponse", sJSON);
    }
}

function onFailure(errResponse) {
    translateErrorMessage(errResponse, function(response) {
        var sJSON = JSON.stringify(response);
        sendEvent("SoftphoneResponse", sJSON);
    }, false);
}

function translateErrorMessage(errResponse, translatedResponse, setInPhonePage, data) {
    var response = new Object();
    response.Error = true;
    response.RequestType = "OPENCTIError";
    var activityUrl = new SafeURL("ChannelServices-Embed-Exception.TranslateOpenCTIErrorCodes");
    activityUrl.put("setInPhonePage", setInPhonePage);
    if (errResponse.errCode != undefined){
      if(errResponse.errCode.toUpperCase() == 'OPENCTI_ERR_PASS' || errResponse.errCode.toUpperCase() == 'ERR_PASS')
      {
        activityUrl.put("ErrorCode", 'OPENCTI_ERR_PASS');
      } else{
        activityUrl.put("ErrorCode", 'OPENCTI_' + errResponse.errCode.toUpperCase());
      }
    }
    activityUrl.put("ErrorMessage", errResponse.errMessage);
    pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
        success: function(oResponse) {
            var request = oResponse;
            if (request.status == 200) {
                response.Message = $('<div>').html(request.responseText).text();
            } else {
                response.Message = $('<div>').html(errResponse.errCode + errResponse.errMessage).text();
            }
            response.responseText = request.responseText;
            translatedResponse(response, data);
        },
        failure: function(oResponse) {
            response.Message = "Ajax Request failed for error code " + errResponse.errCode;
            translatedResponse(response, data);
        },
        scope: this
    }, "");
}
// Wrapper funciton for offering event
function handleOfferingCallEvent(JSONEvent) {
 try{ 
  createInteractionFromEvent(JSONEvent);
 }catch(e){
   console.log("Error handling offering event :"+e.message);
 }
}
// Wrapper funciton for initiated event
function handleInitiatedCallEvent(JSONEvent) {
 try{
  createInteractionFromEvent(JSONEvent);
 }catch(e){
   console.log("Error handling initiated callevent :"+e.message);
 }
}

function createInteractionFromEvent(JSONEvent) {
    var responseObj = new Object();
    var postData = new SafeURL();
    var activityUrl = new SafeURL("ChannelServices-Event-CTILink.CreateInteractionFromEvent");
  //BUG-560745--Changes start
    //postData.put("pzPrimaryPageName", "CTIEvent");
    //BUG-560745--Changes End
    postData.put("Event", JSONEvent);
    pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
        success: function(oResponse) {
            var request = oResponse;
            if (request.status == 200) {
                var response = request.responseText;
              	if(response !== 'false') {//'false' represents ignoring of event
                  responseObj = JSON.parse(response);
                  if(responseObj.pyPopType !== 'NONE') {
                    responseObj.pyOPENCTI = true;
                	response = JSON.stringify(responseObj);
                	sendEvent("PegaCallScreenPopRequest", response);
                  }
                }
            } else {
                sendError("HTTP Error: " + request.statusText);
            }
        },
        failure: function(oResponse) {
            sendError("HTTP Error: " + oResponse.statusText);
        },
        scope: this
    }, postData);
}
// This is a temp fix. Please remove after the blocker gets resolved.
function sendEvent(strEventName, objEventData, mode, delay) {
    if (strEventName == 'SoftphoneRequest') SoftphoneRequest(objEventData);
    else return pega.desktop.sendEvent(strEventName, objEventData, mode, delay);
}
//Initialize softphone
function initializeSoftPhone() {
    //Start :BUG-693075 To restore the logger methods back as it is getting acquired by Five9
      window.console.debug = consoleDebug;
      window.console.info = consoleInfo;
      window.console.warn = consoleWarn;
      window.console.error = consoleError;
      window.console.log = consoleLog;
    //End :BUG-693075 To restore the logger methods back as it is getting acquired by Five9
    var responseObj = new Object();
    var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.Initialize");
    activityUrl.put("pzPrimaryPageName", "CTIPhone");
    pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
        success: function(oResponse) {
            var request = oResponse;
            if (request.status == 200) {
                var response = request.responseText;
                showhtml(response);
                responseObj = JSON.parse(response);
              pega.cti.networkErrorMessage = responseObj.NetworkErrorMessage;
              pega.cti.WSCloseMsg =responseObj.WSCloseMsg;
              pega.cti.WSErrorMsg = responseObj.WSErrorMsg ;
                setGlobalPropertiesOnInitialize(responseObj);
                responseObj.Error = false;
                if (responseObj.pyPegaCTIError != "Good") {
                    responseObj.Error = true;
                    responseObj.Message = responseObj.pyPegaCTIError;
                }
            } else {
                responseObj.Error = true;
                responseObj.Message = "HTTP Error: " + request.statusText;
            }
          
                    if (responseObj  == true )
            setTimeout(initializeSoftPhone,5000); 

            responseObj.RequestType = "Initialize";
            if (responseObj.Error == false && responseObj.pyTempText != null) {
                var linkDefinition = jsonParseLinkDefinition(responseObj.pyTempText);
                var loglevel;
                if(linkDefinition.pyLogging != undefined){
                  loglevel = linkDefinition.pyLogging.pyLogLevel
                }
                if (typeof linkDefinition.pyJavascriptObject !== 'undefined') loadApi(linkDefinition.pyJavascriptObject,loglevel);
                //Coment beloe line after testing
                //responseObj.pyDeviceState = "OPENED";
                if (pega.cti.API != undefined && (typeof responseObj.pyDeviceState !== 'undefined' ||responseObj.pyAutoLogin === 'true' || typeof responseObj.UIPanelActive !== 'undefined')) 
                {
                    if (responseObj.pyDeviceState == "OPENED"  || responseObj.pyDeviceState ==  "RECONNECTING" || responseObj.pyAutoLogin === 'true' || responseObj.UIPanelActive == 'true') 
                    {
                        var opts = jsonParseOptions(responseObj.pyOptions);
                        if (opts  != undefined )  
                        {
                          if(linkDefinition.IsEmbeddedUI != undefined && linkDefinition.IsEmbeddedUI == "true")
                           {
                             if(linkDefinition.CTIConfigWizard !== undefined && linkDefinition.CTIConfigWizard === "true")
                               console.log("Event initialized from Wizard");
                             else
                                loadEmbeddedApi(responseObj.pyTempText,responseObj.pyOptions);
                           }
                           else if (opts.HasTelephonyPriv === 'true')
                            {
                              telephonyLogin(responseObj.pyAgentId,responseObj.pyAgentPwd, responseObj.pyExtension, responseObj.pyTempText,responseObj.pyOptions);
                            }else {
                                 login(responseObj.pyAgentId, responseObj.pyAgentPwd, responseObj.pyExtension,responseObj.pyTempText, responseObj.pyOptions);
                             }

                        }
                      }
                  }
            }
            SoftphoneResponse(responseObj);
        },
        failure: function(oResponse) {
            responseObj.Error = true;
            responseObj.Message = "HTTP Error: " + oResponse.statusText;
            SoftphoneResponse(responseObj);
        },
        scope: this
    }, "");
    return responseObj;
}

function setGlobalPropertiesOnInitialize(responseObj){
 
  pega.cti.globalProperties.enableAlertNotification=responseObj.EnableAlertNotification;
  pega.cti.globalProperties.timeOutDuration = responseObj.TimeOutDuration;
  pega.cti.globalProperties.ctiPosition = responseObj.CCPPosition;
  pega.cti.globalProperties.closeCCPOnReady = responseObj.CloseCCPOnReady;
  pega.cti.globalProperties.closeCCPOnNotReady = responseObj.CloseCCPOnNotReady;
  pega.cti.globalProperties.closeCCPOnLogout = responseObj.CloseCCPOnLogout;
  pega.cti.globalProperties.closeCCPPendingStateOnCall = responseObj.CloseCCPPendingStateOnCall;
  pega.cti.globalProperties.closeCCPOnLogin = responseObj.CloseCCPOnLogin; 
  pega.cti.globalProperties.agentIsOnCall = responseObj.AgentIsOnCall;
  
}

function SS_DeviceUpdate(xmlText) {
    var request = new Object();
    request.RequestType = "UpdateClipboard";
    request.LinesXML = xmlText;
    var response = pega.cti.API.SS_Request(request, null, onSuccess, onFailure);
    return response
}
//Added new param deviceState
function SS_AgentStateUpdate(newAgentState, deviceState) {
    var request = new Object();
    request.RequestType = "UpdateAgentState";
    request.AgentState = newAgentState;
    request.DeviceState = deviceState
    var response = pega.cti.API.SS_Request(request, null, onSuccess, onFailure);
    return response
}

//publish call info events farword.
function PublishCallInfoEvent (event) {
    event.pyEventName = "UNKNOWN";
    for (var i = 0, len = event.pyParties.length; i < len; i++) {
        if (event.pyParties[i].pyDN == event.pyThisDN) {
            switch (event.pyParties[i].pyDNState.toUpperCase()) {
                case "OFFERING":
                case "ALERTING": {
                    event.pyEventName = "Offering";

                    break;
                }
              case "CONNECTED":
                case "ESTABLISHED": {
                    event.pyEventName = "Established";
                    break;
                }
                case "INITIATING":
                case "INITIATED": {
                    event.pyEventName = "Initiated";
                    break;
                }
                case "ABANDONED": {
                    event.pyEventName = "Abandoned";
                    break;
                }
                case "DISCONNECTED": {
                    event.pyEventName = "Disconnected";
                    break;
                }
                case "RETRIEVED": {
                    event.pyEventName = "Retrieved";
                    break;
                }
                   case 'HELD': {
                    event.pyEventName = "Held";
                    break;
                }
                default:
                    event.pyEventName = "UNKNOWN";
            }
            break;
        }
    }


    if (event.pyEventName != "UNKNOWN") {
      var response = JSON.stringify(event);
      console.log("Fowarding public call state event" +response);
         sendEvent("PublicPhoneCallStateEvent", response);
    }
}




//static-content-hash-trigger-GCC
/****************************************************************************
* Author:	Phani Kavuri
* Date:		27-June-2018
* Description:	Logjs for pega call contain Level, Logger, Appender and Format
*---------------------------------
* Bugfix history
*---------------------------------
    
****************************************************************************/
if (!pega) var pega = {};
if (!pega.cti) pega.cti = {};

// Log Level for Pega Call 
pega.cti.Level = {
    ALL: -2147483648,
    DEBUG: 10000,
    INFO: 20000,
    WARN: 30000,
    ERROR: 40000,
    FATAL: 50000,
    OFF: 2147483647
};

pega.cti.Logger = function() {
    this.appenders = [];
    this.level = pega.cti.Level.OFF;
    this.addAppender(new pega.cti.ConsoleAppender("console"));
}

pega.cti.Logger.prototype = {
    /**
      add additional appender.
    */
addAppender: function(appender) {
    for (var i = 0; i < this.appenders.length; i++) {
        appenderObject = this.appenders[i];
        if (appenderObject.getName() == appender.getName()) return;
    };
    this.appenders.push(appender);
},
    /**
     *get the Loglevel
     */
    getLevel: function() {
        return this.level;
    },
    /**
     *Set the Loglevel, default is LogLEvel.OFF
     */
    setLevel: function(level) {
        this.level = level;
    },
    /** checks if Level Debug is enabled */
    isDebugEnabled: function() {
        if (this.level <= pega.cti.Level.DEBUG) {
            return true;
        }
        return false;
    },
    /**
     * Debug messages 
     */
    debug: function(message) {
        if (this.isDebugEnabled()) {
            this.log("Debug", message);
        }
    },
    /** checks if Level Info is enabled */
    isInfoEnabled: function() {
        if (this.level <= pega.cti.Level.INFO) {
            return true;
        }
        return false;
    },
    /** 
     * logging info messages 
     * @param {message}  message to be logged
     */
    info: function(message) {
        if (this.isInfoEnabled()) {
            this.log("Info", message);
        }
    },

    /** checks if Level Warn is enabled */
    isWarnEnabled: function() {
        if (this.level <= pega.cti.Level.WARN) {
            return true;
        }
        return false;
    },
    /** logging warn messages
     * @param {message}  message to be logged
     */
    warn: function(message) {
        if (this.isWarnEnabled()) {
            this.log("WARN", message);
        }
    },

    /** checks if Level Error is enabled */
    isErrorEnabled: function() {
        if (this.level <= pega.cti.Level.ERROR) {
            return true;
        }
        return false;
    },
    /** logging Error messages
     * @param {message}  message to be logged
     */
    Error: function(message) {
        if (this.isErrorEnabled()) {
            this.log("ERROR", message);
        }
    },

    /** checks if Level Fatal is enabled */
    isFatalEnabled: function() {
        if (this.level <= pega.cti.Level.FATAL) {
            return true;
        }
        return false;
    },
    /** logging Fatal messages 
     * @param {message}  message to be logged
     */
    fatal: function(message) {
        if (this.isFatalEnabled()) {
            this.log("FATAL", message);
        }
    },

    /** 
     * main log method logging to all available appenders 
      * @param {logLevel}  logLevel to be logged
     * @param {message}  message to be logged
     
     */
    log: function(logLevel, message) {
        for (var i = 0; i < this.appenders.length; i++)

            this.appenders[i].log(logLevel + " " + message);
    },

    /**
     * Return all the appenders associated with logger.
     */
    getAppenders: function() {
        return this.appenders;

    },

    /**
     * Return all the appenders by appender name associated with logger.
     * @param {appenderName}  appenderName of the appender to be retrived.
     */
    getAppender: function(appenderName) {
        for (var i = 0; i < this.appenders.length; i++) {
            if (this.appenders[i].getName() == appenderName)
                return this.appenders[i];
        }
    },

    /** 
     * main log method logging to all available appenders 
      * @param {logLevel}  logLevel to be logged
     * @param {message}  message to be logged
     
     */
    log: function(logLevel, message) {
        for (var i = 0; i < this.appenders.length; i++)

            this.appenders[i].log(logLevel, message);
    },


}



pega.cti.ConsoleAppender = function(appenderName) {
    this.name = appenderName;
    this.layout = new pega.cti.Layout();
}

pega.cti.PegaSystemAppender = function(appenderName) {
    this.name = appenderName;
    this.publishingMessages = false;
    this.layout = new pega.cti.Layout();
    this.publishMessages(this);
}


pega.cti.ConsoleAppender.prototype = {

    /**
     *get the name of the appender
     */
    getName: function() {
        return this.name;
    },

    /** 
     * main log method 
     * @param {message}  message to be logged.
     */
    log: function(logLevel , message) {
        console.log(this.layout.format(logLevel + " "+ message));
    },
}


pega.cti.PegaSystemAppender.prototype = {

    /**
     *get the name of the appender
     */
    getName: function() {
        return this.name;
    },

    /** 
     * main log method 
     * @param {logLevel}  Log level of the message.
     * @param {message}  message to be logged.
     */
    log: function(logLevel, message) {
        if (logLevel == "ERROR") {
            this.sendMessage(pega.cti.Level.ERROR, message);
        }
    },

    /** 
     * main log method 
     * @param {logLevel}  Log level of the message.
     * @param {message}  message to be logged.
     */
    addMessage: function(logLevel, message) {
        console.log(this.layout.format("Adding event with Log Level:")+logLevel + ":"+message );
        var messageObject = new Object();
        messageObject.logLevel = logLevel;
        messageObject.message = message;
        var retrievedMessages = localStorage.getItem("pegaCTIMessages");
        var MessagesList = [];
        if (retrievedMessages) MessagesList = JSON.parse(retrievedMessages);
        MessagesList.push(messageObject);
        localStorage.setItem("pegaCTIMessages", JSON.stringify(MessagesList));
       if (this.publishingMessages == false || this.publishingMessages == undefined)
       {clearTimeout(pega.cti.publishIntervalId);
                pega.cti.publishIntervalId = setTimeout( this.publishMessages, 10000, this);}
    },


    sendMessage: function(logLevel, message) {
       console.log(this.layout.format("Recieved event with Log Level:")+logLevel + ":"+message );
      _this =this;
        var responseObj = new Object();
        var callbackAlreadyCalled = false;
         var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
        postData.put("RequestType","WriteLog");
        postData.put("ActivityClass","ChannelServices-Device-Phone-UI");
        postData.put("pzPrimaryPageName", "CTIPhone");
        activityUrl.put("LogLevel", logLevel);
        activityUrl.put("Message", message);
        pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
            success: _this.filterDuplicateCalls(function(oResponse) {
                var request = oResponse;
                if (request.status != 200) {
                    console.log("setting message on sucess fail " + message);
                    _this.addMessage(logLevel, message);
                }
            }),
            failure: _this.filterDuplicateCalls( function(oResponse, messageObject) {
                console.log("setting message on failure fail " + message);
                _this.addMessage(logLevel, message);
            }),
            scope: this
        }, postData);

        return responseObj;
    },
	 filterDuplicateCalls :function(fn){
     var hasBeenCalled = false;    
     return function(){
          if (hasBeenCalled){
               console.log("Filtering dupicate events");
               return;
          }
          hasBeenCalled = true;
          return fn.apply(this, arguments)
     }
   },

    publishMessages: function(objectContext) {
        _this = objectContext;
        _this.publishingMessages = true;
        var retrievedMessages = localStorage.getItem("pegaCTIMessages");
         console.log(_this.layout.format("Publishing Evnets:")+retrievedMessages);
        var MessagesList = [];      
        if (retrievedMessages) MessagesList = JSON.parse(retrievedMessages);
      localStorage.removeItem("pegaCTIMessages");
        if (MessagesList.length > 0)  { 
            for (var i = 0; i < MessagesList.length; i++) {
                _this.sendMessage(MessagesList[i].logLevel, MessagesList[i].message);
            }
        }
        _this.publishingMessages = false;
    }

}




pega.cti.Layout = function() {};

pega.cti.Layout.prototype = {

    /** 
     *main format method.
     * @param {message}  message to be formatted.
     */
    format: function(message) {
        var presenttime = new Date();
        var content = "timestamp : " + presenttime.toGMTString() + " ";

        return content + message;
    }

};
//static-content-hash-trigger-GCC
/****************************************************************************
* Author:	Jagannadham Parupudi
* Date:		12-May-2017
* Description:	Finesse desktop implementation using XMPP (Strophe.js)
*---------------------------------
* Bugfix history
*---------------------------------
* BUG-346393: UCCX-Internal call at CSR2 is treated as Outbound call
* BUG-353892: State changes after finesse service restarts
* BUG-357685: Internal call does not have caller extension(agent extension)
* BUG-358174: Simple transfer after V+D transfer behave as V+D transfer
****************************************************************************/


//Global function for event registry 
function onFinesseXMPPMessage(message) {
  try {
  	//forward event to onMessage
  	pega.cti.API.onMessage(message);  
  } catch (e) {
    pega.cti.API.Error('Exception while forwarding event to event handler: '+ e.toString());
  }finally {
    return true;
  }
}

function onFinessePresenceMessage(message) {  
  try {
    console.log("Presence event received");
    console.log(message);
    var presenceData = XmlToJson(message);
    if (presenceData['@attributes'].type === 'unavailable' && presenceData["@attributes"].from.split('@')[0].toLowerCase() == 'finesse'
        && pega.cti.API.hostURL.includes(presenceData["@attributes"].to.split('@')[1].split('/')[0])) {
		pega.cti.API.Logger.info('Finesse Presence is unavailable. Starting Failover process'); 
        pega.cti.API.failoverManager.failoverHandler('PRESENCE_FAILOVER');
    }
  } catch (e) {
    pega.cti.API.Logger.Error('Exception while forwarding event to event handler: ' + e.toString());
  } finally {
    return true;
  }
}

function XmlToJson(xml) {
  // Create the return object
  var obj = {};
  if (xml.nodeType == 1) { // element
  	// do attributes
  	if (xml.attributes.length > 0) {
  	obj["@attributes"] = {};
  	  for (var j = 0; j < xml.attributes.length; j++) {
  	  	var attribute = xml.attributes.item(j);
  	  	obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
  	  }
  	}
  } else if (xml.nodeType == 3) { // text
  	obj = xml.nodeValue;
  }
  // do children
  // If just one text node inside
  if(xml.hasChildNodes() && xml.childNodes.length === 1 && xml.childNodes[0].nodeType === 3) {
    obj = xml.childNodes[0].nodeValue;
  }
  else if (xml.hasChildNodes()) {
	for(var i = 0; i < xml.childNodes.length; i++) {
	  var item = xml.childNodes.item(i);
	  var nodeName = item.nodeName;
	  if (typeof(obj[nodeName]) == "undefined") {
	  	obj[nodeName] = XmlToJson(item);
	  } else {
	  if (typeof(obj[nodeName].push) == "undefined") {
	    var old = obj[nodeName];
	    obj[nodeName] = [];
	    obj[nodeName].push(old);
	  }
	  obj[nodeName].push(XmlToJson(item));
	  }
	}
  }
  return obj;
}

pega.cti.desktopApi.Finesse = function() {
  	
  this.name = "Finesse";
  this.BOSH_SERVICE = null;
  this.hostURL = null;
  this.connection = null;
  this.authString = null;
  this.agentId = null;
  this.agentPwd = null;
  this.dn = null;
  this.currentAgentState = null;
  this.pyClientHandle = '';
  this.pyLinkState = '';
  this.pySessionId = '';
  this.pyUserIdentifier = '';
  this.pyWorkMode = '';
  this.LinkDefinition = null;
  this.deploymentType = null;
  this.systemStatus = null;
  this.forwardEvent = null;
  //US-225417 adding version number
  this.version = 1;
  this.isPrimaryActive = true;
  this.connectionState = '';
  this.FailoverManager = null;
  this.Logger = new pega.cti.Logger();
  this.notReadyReasoncodes = [];
  this.defaultNotReadyReasonCode = null;
  this.defaultLogoutReasonCode =null;
  this.subscriptionRetryIntervel =null;
  this.subscriptionRetryAttempts =null;
  //US-268810 adding adapter implementation Version
  this.implementationVersion="8.3.1.10";
  this.subscriptionStarted = false;
  this.isConnAcquired = false;
  this.isLogoutReqested = false;
  this.isConnTimedout = false;
    this.isConnFail =  false;
  this.uriReasonCodeMap = new Map();
  this.failoverRetryInterval  = 20;
  this.enableStropheLogs = false;
  this.HTTPBindInterval = 60;
  this.tokenRefreshAttempts =5;
  this.tokenRefreshTries =0;
  this.notificationConnectionType = "bosh";
  this.pingID = null;
  this.pingInterval =10000;
  this.pingRequestMaxRetry =3;
  this.pingCounter =0 ;
  this.pingTimeout = 10000;
}

pega.cti.desktopApi.Finesse.FailoverManager = function() {
  this.failoverReason = ''; //'SYSTEM_FAILOVER','PRESENCE_FAILOVER' are acceptable values. Empty - system not in failover state
  this.agentLogoutReceived = true; //Default value is 'true' unless SYSTEM_FAILOVER occurs 
    this.failoverEnabled = false;
  this.pollingSystem =null;
}

pega.cti.desktopApi.Finesse.prototype = {
  initialize: function(LinkDefinition, Options,onSuccess,onFailure) {
    this.LinkDefinition = LinkDefinition;
    this.pyClientHandle = Options.pyClientHandle;
    this.pyHeartbeatInterval = 0;
    this.pySessionId = 'OpenDesktopCTI';
    this.pyUserIdentifier = Options.pyUserIdentifier;
    this.pyWorkMode = Options.pyWorkMode;
    this.pyNumberOfLines = Options.pyNumberOfLines;
    this.isPrimaryActive = sessionStorage.getItem('isPrimaryActive') === null ? 
      true : (sessionStorage.getItem('isPrimaryActive') === 'true' ? true : false); //SessionStorage will store in strings
    //Initialize failover manager
    this.failoverManager = new pega.cti.desktopApi.Finesse.FailoverManager();
    this.failoverManager.initialize(this.LinkDefinition);
    this.getLinkStatus(onSuccess, onFailure);
    this.defaultNotReadyReasonCode = this.getValueFromLinkDefinition("defaultNotReadyReasonCode");
    this.defaultLogoutReasonCode =this.getValueFromLinkDefinition("defaultLogoutReasonCode");
    this.subscriptionRetryIntervel = this.getValueFromLinkDefinition("subscriptionRetryIntervel");
    this.subscriptionRetryAttempts = this.getValueFromLinkDefinition("subscriptionRetryAttempts");
         var pegaSystemAppender = this.getValueFromLinkDefinition("PegaSystemAppender");
    var failoverRetryInterval =  this.getValueFromLinkDefinition("FailoverRetryInterval");
    if ( failoverRetryInterval != null && !isNaN(failoverRetryInterval) ) this.failoverRetryInterval = failoverRetryInterval;
    if (pegaSystemAppender != null)
    if ( pegaSystemAppender.toLowerCase() == "true")
{
  this.Logger.addAppender(new pega.cti.PegaSystemAppender ("PegaSystemAppender"));
}   
    this.enableStropheLogs =  this.getValueFromLinkDefinition("enableStropheLogs");
    if ( this.enableStropheLogs!= null  && (this.enableStropheLogs == true || this.enableStropheLogs.toLowerCase() == "true")) Strophe.enableLogging = true;
    var HTTPBindInterval =  this.getValueFromLinkDefinition("HTTPBindInterval");
    if ( HTTPBindInterval != null && !isNaN(HTTPBindInterval) ) this.HTTPBindInterval = HTTPBindInterval;
    
      var pingInterval =this.getValueFromLinkDefinition("PingInterval");
      if ( pingInterval != null && !isNaN(pingInterval) ) this.pingInterval =pingInterval;
     var pingRequestMaxRetry =this.getValueFromLinkDefinition("PingRequestMaxRetry");
      if ( pingRequestMaxRetry != null && !isNaN(pingRequestMaxRetry) ) this.pingRequestMaxRetry =pingRequestMaxRetry;
     var pingTimeout =this.getValueFromLinkDefinition("PingTimeout");
      if ( pingTimeout != null && !isNaN(pingTimeout) ) this.pingTimeout =pingTimeout;
    
  },
  
  getLinkStatus: function(onSuccess, onFailure) {
    //If failover reason is SYSTEM_FAILOVER - It might recovering - So don't change link
    if (this.failoverManager.isSystemFailover()) {
      //Set current active link details
      if (this.isPrimaryActive || !this.failoverManager.failoverEnabled) 
        this.populateActiveLinkInfo('PRIMARY', 'OUT_OF_SERVICE');
      else 
        this.populateActiveLinkInfo('FAILOVER', 'OUT_OF_SERVICE');
    } else {
      if(pega.cti.API.isConnAcquired === true  && this.failoverManager.failoverReason ==='') { //Connection is already requested - So this might be a browser refresh
        if (this.isPrimaryActive || !this.failoverManager.failoverEnabled) 
          this.populateActiveLinkInfo('PRIMARY', 'IN_SERVICE');
        else 
          this.populateActiveLinkInfo('FAILOVER', 'IN_SERVICE');
      } else {
        //Check Primary server
        this.getSystemInfo(this.LinkDefinition.pyPrimaryHost, function(systemStatus) {
          if (systemStatus === 'IN_SERVICE' || !pega.cti.API.failoverManager.failoverEnabled) 
            pega.cti.API.populateActiveLinkInfo('PRIMARY', systemStatus);
          else {
            //Check Failoer server
            pega.cti.API.getSystemInfo(pega.cti.API.LinkDefinition.pyFailoverHost, 
              function(systemStatus) {
                if (systemStatus === 'IN_SERVICE') 
                  pega.cti.API.populateActiveLinkInfo('FAILOVER', systemStatus);
                else { //Failover is also down - mark primary active
                    pega.cti.API.populateActiveLinkInfo('PRIMARY', 'OUT_OF_SERVICE');
                }
              }, onFailure);
          }
        }, function(error) {
            pega.cti.API.Logger.debug('Error while trying to connect to primary server');
            //Check Failoer server
            if(pega.cti.API.failoverManager.failoverEnabled) {
              pega.cti.API.getSystemInfo(pega.cti.API.LinkDefinition.pyFailoverHost, function(systemStatus) {
                  if (systemStatus === 'IN_SERVICE') 
                    pega.cti.API.populateActiveLinkInfo('FAILOVER', systemStatus);
                  else //Failover is also down - mark primary active
                    pega.cti.API.populateActiveLinkInfo('PRIMARY', 'OUT_OF_SERVICE');
              }, onFailure);
            } else {
              pega.cti.API.populateActiveLinkInfo('PRIMARY', 'OUT_OF_SERVICE');
            }
          });
        }
      }
    },
    populateActiveLinkInfo: function(link, systemStatus) {
      this.systemStatus = systemStatus;
      this.pyLinkState = (systemStatus === 'IN_SERVICE') ? 'CONNECTED' : 'DISCONNECTED';
      if (link === 'PRIMARY') {
        sessionStorage.setItem('isPrimaryActive', true);
        this.isPrimaryActive = true;
        
        this.BOSH_SERVICE = this.getSubfolder(this.getValueFromLinkDefinition('PRIMARY_BOSHURL'));
        
        
        this.hostURL = this.LinkDefinition.pyPrimaryHost;
      } else {
        sessionStorage.setItem('isPrimaryActive', false);
        this.isPrimaryActive = false;
        this.BOSH_SERVICE = this.getSubfolder(this.getValueFromLinkDefinition('FAILOVER_BOSHURL'));
        
        
        this.hostURL = this.LinkDefinition.pyFailoverHost;
      }
    },  
  
    
   getSubfolder: function (boshurl){
     
          //Checking and updating notification connection      
     if(boshurl.toLowerCase().startsWith("ws"))
        this.notificationConnectionType ="websocket" ;
     else
       this.notificationConnectionType ="bosh" ;
     
     // if URL starts with http and does not contain /http-bind/ or /http-bind appending /http-bind
     if (boshurl.startsWith("http") && !(boshurl.endsWith("/http-bind/") || boshurl.endsWith("/http-bind")) ){
       return boshurl + "/http-bind/";
       
     // if URL starts with ws and does not ends with /ws/ or /ws appending /ws
     } else if(boshurl.startsWith("ws") && !(boshurl.endsWith("/ws/") || boshurl.endsWith("/ws")) ){ 
        return boshurl + "/ws";
     } else {
       return boshurl;
     }
  },
  
  
  getSystemInfo: function(link, onSuccess, onFailure) {
    this.sendRESTRequest('GET', null, link + '/finesse/api/SystemInfo', function(data) {
      //populate properties to API object      
      pega.cti.API.deploymentType = data.SystemInfo.deploymentType;
      onSuccess(data.SystemInfo.status);
      }, function(data) {
        onFailure(data);
    });
  },
  
  //returns property value from custom property list for mapping property name
  getValueFromLinkDefinition: function(property) {
    var value = null;
    //First read bosh urls from properties if not available read from Customeproperties
    //US-232904
    if(property=='PRIMARY_BOSHURL'){
        value = this.LinkDefinition.primaryBoshUrl;
    } else if(property=='FAILOVER_BOSHURL')
             {
             value = this.LinkDefinition.failoverBoshUrl; 
              }
    if(value == null && this.LinkDefinition.CustomProperties != null && this.LinkDefinition.CustomProperties != undefined){
    for (var k = 0; k < this.LinkDefinition.CustomProperties.length; k++) {
      if (this.LinkDefinition.CustomProperties[k].pyPropertyName.toUpperCase() == property.toUpperCase()) 
        value = this.LinkDefinition.CustomProperties[k].pyPropertyValue;
    }
    }
    return value;
  },
  
  //return Base64 encoded value for agentid and password
  getAuthString: function() {
      return "Basic " + window.btoa(this.agentId + ":" + this.agentPwd);
  },
  
  sendRESTRequest: function(method, payload, requestUrl, onSuccess, onFailure) {
    pega.cti.API.Logger.debug('Sending REST request to URL[ '+ requestUrl + '], method ['+ method + '] & payload ['+ payload +']');
    var operation = this.getOperationfromRequestUrl(requestUrl);
    
    $.ajax({
      type: method,
      url: requestUrl,
      headers: {
        //'Origin': window.location.origin, //For CORS
        'Authorization': this.authString,
        'Content-Type': payload == null ? undefined : 'application/xml'
      },
      data: payload,
      success: function(data) {
        if (data != null) {
         pega.cti.API.Logger.debug('REST request successful. Response: ');
         pega.cti.API.Logger.debug(data.xml);
          data = XmlToJson(data);
        } else
         pega.cti.API.Logger.info('REST request successful.');
        onSuccess(data);
      },
      error: function(jqXHR, exception) {
        var errObject = new Object();
        //If API errors exists, retreive error
        if(jqXHR.responseText && (jqXHR.responseText).indexOf('<ApiErrors>') > -1) {
             var error = XmlToJson($.parseXML(jqXHR.responseText));
             errObject.errCode = pega.cti.API.getMappingErrorCode(error.ApiErrors.ApiError.ErrorData, operation);
             errObject.errMessage = error.ApiErrors.ApiError.ErrorMessage;
        } else {
          switch(jqXHR.status) {
            case 0:
              errObject.errCode = 'HTTP_ERROR_0';
              errObject.errMessage = 'Unable to connect.Verify network';
              break;
            case 400:
              errObject.errCode = 'HTTP_ERROR_400';
              errObject.errMessage ='HTTP error 400: Bad request';
              break;
            case 401:
              errObject.errCode = 'HTTP_ERROR_401';
           	errObject.errMessage = 'HTTP error 401: Authentication failed/not provided';
              break;
            case 404:
              errObject.errCode = 'HTTP_ERROR_404';
          	errObject.errMessage = 'HTTP error 404: Requested resource not found';
              break;
            case 405:
          	errObject.errCode = 'HTTP_ERROR_405';
          	errObject.errMessage = 'HTTP error 405: Method not supported';
              break;
            case 408:
              errObject.errCode = 'HTTP_ERROR_408';
          	errObject.errMessage = 'HTTP error 408: Request timedout';
              break;
            case 500:
          	errObject.errCode = 'HTTP_ERROR_500';
          	errObject.errMessage = 'HTTP error 500: Internal Server Error';
              break;
            default: 
              errObject.errCode = true;
          	errObject.errMessage = 'Uncaught Error.' + jqXHR.responseText;
        	} 
        }
        pega.cti.API.Logger.Error('Error on REST request: '+ errObject.errMessage);
        onFailure(errObject);
      }
    });
  },
  
  getOperationfromRequestUrl: function (url){
    if(url.includes("User"))
      return "User";
    else
      return "Dialog";
  },
  
  changeAgentState: function(payload, onSuccess, onFailure) {
    
    pega.cti.API.Logger.debug('Sending agent state change request with payload [' + payload + ']');
    this.sendRESTRequest('PUT', payload, this.hostURL + '/finesse/api/User/' + this.agentId, onSuccess,onFailure);
  },
  
  changeCallState: function(dialogId, payload, onSuccess, onFailure) {
        if (dialogId == "" || dialogId == null || typeof(dialogId) == "undefined")
  {
       var errorEvent =  pega.cti.API.buildPegaEvent('ErrorEvent');
            errorEvent.errCode = 'CTI_INVALID_CALLID';
            errorEvent.errMessage = 'Call ID recieved in request is empty.';
    console.log((new Error('Call ID recieved in request is empty.')).stack);        
    onFailure(errorEvent);
  return;
  }

    
    pega.cti.API.Logger.debug('Sending call state change request for callId ['+ dialogId +'] with payload ['+ payload +']');
    this.sendRESTRequest('PUT', payload, this.hostURL + '/finesse/api/Dialog/' + dialogId, onSuccess,onFailure);
  },
  
  getMappingAgentState: function(agentState) {
    var pegaAgentState = null;
    switch (agentState) {
      case "LOGIN":
        pegaAgentState = "Login";
        break;
      case "LOGOUT":
        pegaAgentState = "Logout";
        break;
      case "READY":
        pegaAgentState = "Ready";
        break;
      case "NOT_READY":
      case "WORK_READY":
      case "WORK":
        pegaAgentState = "NotReady";
        break;
      case "BUSY":
      case "TALKING":
      case "RESERVED":
      case "HOLD":
      case "RESERVED_OUTBOUND":
      case "RESERVED_OUTBOUND_PREVIEW":
	  case "BUSY_OTHER":
        pegaAgentState = "Busy";
        break;
      default:
        pegaAgentState = "Unknown";
    }
    return pegaAgentState;
  },
  
  getMappingCallStateForSnapshot: function(callState) {
    var pegaCallState = null;
    switch (callState) {
      case "Idle":
        pegaCallState = "NONE";
        break;
      case "ACTIVE":
        pegaCallState = "CONNECTED";
        break;
      case "HELD":
        pegaCallState = "HOLDING";
        break;
      case "DROPPED":
        pegaCallState = "NONE";
        break;
      case "ALERTING":
        pegaCallState = "Alerting";
        break;
      case "INITIATING":
      case "INITIATED":
        pegaCallState = "INITIATING";
        break;
      default:
        pegaCallState = "";
    }
    return pegaCallState;
  },
  
  getEventNameForCall:function(callState) {
    var eventName;
    switch(callState) {
      case 'Abandoned':
        eventName = 'Abandoned';
        break;
      case 'Released':
        eventName = 'Released';
        break;
      case 'Ringing':
      case 'INITIATING':
      case 'INITIATED':
        eventName = 'Initiated';
        break;
      case 'FAILED':
        eventName = 'CallFailed';
        break;
      case 'HELD':
        eventName = 'Held';
        break;
      case 'ALERTING':
        eventName = 'Offering';
        break;
      case 'Established':
        eventName = 'Established';
        break;
      case 'ACTIVE':
      case 'Retrieved':
        eventName = 'Retrieved';
        break;
      case 'DROPPED':
      case 'WRAP_UP':
        eventName = 'Disconnected';
        break;
      default:
        eventName = '';
    }
    return eventName;
  }, 
  
  getCallType:function(ciscoCallType, pyNamedVariables) {
    var pegaCallType;
    switch(ciscoCallType) {
      case 'ACD_IN':
      case 'PREROUTE_ACD_IN':
      case 'PREROUTE_DIRECT_AGENT':
      case 'OVERFLOW_IN':
      case 'OTHER_IN':
      case 'OFFERED':
        pegaCallType = 'INBOUND';
        break;
      case 'AUTO_OUT':
      case 'AGENT_OUT':
      case 'OUT':
        pegaCallType = 'OUTBOUND';
        break;
      case 'AGENT_INSIDE':
        pegaCallType = 'INTERNAL';
        break;
      case 'CONSULT':
      case 'CONSULT_OFFERED':
      case 'CONSULT_CONFERENCE':
        pegaCallType = 'CONSULT';
        break;
      case 'TRANSFER':
        if(this.deploymentType == 'UCCX'){
          pegaCallType = 'CONSULT';
        }else{
          pegaCallType = 'FINESSE-TRANSFER';
        }
        break;
      case 'CONFERENCE':
      case 'RESERVATION':
      case 'ASSIST':
      case 'EMERGENCY':
      case 'SUPERVISOR_MONITOR':
      case 'SUPERVISOR_WHISPER':
      case 'SUPERVISOR_BARGEIN':
      case 'TASK_ROUTED_BY_ICM':
      case 'TASK_ROUTED_BY_APPLICATION':
      default:
        pegaCallType = 'UNKNOWN';
    }
       
    if(pegaCallType == 'INBOUND' || pegaCallType == 'INTERNAL' || pegaCallType == 'UNKNOWN'){
        if(typeof pyNamedVariables !== "undefined")
          if(typeof pyNamedVariables.userOldCallId !== "undefined")
            pegaCallType = 'CONSULT';
    }
    
    return pegaCallType;
  },
  
  getMappingErrorCode: function(finesseCode, operation) {
    var pegaCode = null;
    switch(finesseCode) {
      case 'CF_INVALID_LOGON_DEVICE_SPECIFIED':
        pegaCode = 'INV_LOGON_DEVICE';
        break;
      case 'CF_INVALID_OBJECT_STATE':
        pegaCode = 'INV_AGENT_STATE';
        break;
      case 'CF_GENERIC_UNSPECIFIED_REJECTION': 
         pegaCode = 'GENERIC_UNSPECIFIED_REJECTION';
        break;
      case "CF_RESOURCE_BUSY": 
          pegaCode = 'RESOURCE_BUSY';
        break;
      case 'finesse.api.reasoncode.require_reasoncode':
        pegaCode = 'REASON_CODE_REQUIRED';
        break;
      case 'finesse.api.reasoncode.not_valid':
      case 'finesse.api.not_found':
        if(operation === undefined)
          pegaCode = 'CF_GENERIC_OPERATION';
        else if(operation === 'User')
          pegaCode = 'INV_REASON_CODE';
        else if(operation === 'Dialog')
          pegaCode = 'INV_CALL_ID';
        else
          pegaCode ='ERR_PASS';
        break;
      case 'CF_GENERIC_OPERATION':
        pegaCode = 'CF_GENERIC_OPERATION';
        break;
      case 'CF_INVALID_DESTINATION':
        pegaCode = 'CF_INVALID_DESTINATION';
        break;
      default:
        pegaCode ='ERR_PASS';
    }
    return pegaCode;
  },
  
  _getParticipantRole: function(mediaAddressType) {
    return ((mediaAddressType === 'AGENT_DEVICE') ? 'true' : 'false');
  },
  
  // Adding the ping logic.
  	
pingSuccess: function(data) {
    pega.cti.API.pingCounter = 0;

    clearTimeout(pega.cti.API.pingID);
    pega.cti.API.pingID = setTimeout(
        pega.cti.API.ping
    , pega.cti.API.pingInterval);

pega.cti.API.Logger.debug( 'ping was successful.');
},


    
pingError: function(error) {
    if (pega.cti.API.pingCounter < pega.cti.API.pingRequestMaxRetry) {
        pega.cti.API.pingCounter++;
        clearTimeout(pega.cti.API.pingID);
        pega.cti.API.pingID = setTimeout(
            pega.cti.API.ping, pega.cti.API.pingInterval);
    }
    pega.cti.API.Logger.Error( 'Ping response was unsuccessful.' + JSON.stringify(error));
},

ping: function(){
var pingJID = pega.cti.API.hostURL.split('//')[1];
if(pingJID.includes(":")){
   pingJID = pingJID.split(":")[0];
}
pega.cti.API.connection.ping.ping(pingJID,pega.cti.API.pingSuccess,pega.cti.API.pingError, pega.cti.API.pingTimeout );
},

  
  onStatusChange: function(status,reason, requestType, onSuccess, onFailure) {
    switch (status) {
      case Strophe.Status.CONNECTING:
        pega.cti.API.isConnTimedout = false;
                pega.cti.API.isConnFail = false;
        this.connectionState = 'CONNECTING';
        pega.cti.API.Logger.info('Received XMPP Connection state: CONNECTING');
        break;
      case Strophe.Status.AUTHFAIL:
	    pega.cti.API.subscriptionStarted = false;
        this.connectionState = 'AUTHFAIL';
        pega.cti.API.Logger.info('Received XMPP Connection state: AUTHFAIL');
        if (requestType == 'subscribe') {
          var errObject = new Object();
        	errObject.errCode = 'INV_AGENTID_OR_PASSWORD';
          errObject.errMessage = 'Unable to establish event connection stream. Authentication Failure';
          onFailure(errObject);
        }
        break;
      case Strophe.Status.CONNFAIL:
              pega.cti.API.isConnFail = true; 
	    pega.cti.API.subscriptionStarted = false;
        this.connectionState = 'CONNFAIL';
        pega.cti.API.Logger.info("Received XMPP Connection state: CONNFAIL");
        if (requestType == 'subscribe') {
          var errObject = new Object();
          errObject.errCode = 'XMPP_CONNFAIL';
          errObject.errMessage = 'Unable to establish event connection stream. Connection failed';
          pega.cti.API.Logger.Error(  errObject.errMessage );
          onFailure(errObject);
        }
          
        break;
      case Strophe.Status.CONNTIMEOUT:
        pega.cti.API.isConnTimedout = true;
	    pega.cti.API.subscriptionStarted = false;
        this.connectionState = 'CONNTIMEOUT';
        pega.cti.API.Logger.info('Received XMPP Connection state: CONNTIMEOUT');
        if (requestType == 'subscribe') {
          var errObject = new Object();
          errObject.errCode = 'XMPP_CONNTIMEOUT';
          errObject.errMessage = 'Unable to establish event connection stream. Connection Timedout';
          onFailure(errObject);
        }
        break;
      case Strophe.Status.DISCONNECTING:
	    pega.cti.API.subscriptionStarted = false;
        this.connectionState = 'DISCONNECTING';
        pega.cti.API.Logger.info("Received XMPP Connection state: DISCONNECTING");
        break;
      case Strophe.Status.DISCONNECTED:
	      pega.cti.API.subscriptionStarted = false;
        pega.cti.API.connectionState = 'DISCONNECTED';
        pega.cti.API.Logger.info("Received XMPP Connection state: DISCONNECTED");
        if (pega.cti.API.systemStatus === 'IN_SERVICE' && pega.cti.API.currentAgentState != 'Logout' && pega.cti.API.failoverManager.failoverReason!= "SYSTEM_FAILOVER" 
                                                                                && pega.cti.API.isConnAcquired == true && pega.cti.API.failoverManager.failoverReason!= "PRESENCE_FAILOVER")
        {
        if(reason != "conflict" ){
            pega.cti.API.isConnAcquired = false;
            pega.cti.API.failoverManager.failoverHandler('XMPP_FAILOVER');
            //pega.cti.API._resubscribe();
            
          }else{
            pega.cti.API.isConnAcquired = false;
            var deviceClosedSnapshot =  pega.cti.API._buildDeviceClosedSnapshot();
            pega.cti.API.forwardEvent(deviceClosedSnapshot);
            var errorEvent =  pega.cti.API.buildPegaEvent('ErrorEvent');
            errorEvent.pyErrorCode = 'OPENCTI_ERR_PASS';
            errorEvent.pyErrorMessage = 'XMPP disconnected. Event connection disconnected unexpectedly; this can be caused by an agent login from another session.';
            pega.cti.API.Logger.Error(errorEvent.pyErrorMessage);
            pega.cti.API.forwardEvent(JSON.stringify(errorEvent));
          }
        }
        this.connection.reset();
        sessionStorage.clear('isPrimaryActive');
        sessionStorage.clear('FAILOVER_STATUS')
        break;
      case Strophe.Status.CONNECTED:
        this.connectionState = 'CONNECTED';
         if (this.notificationConnectionType.toLowerCase() === "websocket") {	       
	        this.ping();
            }
        pega.cti.API.subscriptionRetryAttempts = pega.cti.API.getValueFromLinkDefinition("subscriptionRetryAttempts");
        pega.cti.API.Logger.info("Received XMPP Connection state: CONNECTED");
        //Add a listener to receive 'message'
        this.connection.addHandler(onFinesseXMPPMessage, null, 'message', null, null, null);
        this.connection.addHandler(onFinessePresenceMessage, null, 'presence', null, null, null);
        // We send online presense to the server. (pub sub concept)
        this.connection.send($pres().tree());
        pega.cti.API.isConnAcquired = true;
        if (requestType === 'subscribe' || requestType === 'failover')
          onSuccess();
        break;
      case Strophe.Status.ATTACHED:
        this.connectionState = 'ATTACHED';
        pega.cti.API.Logger.info("Received XMPP Connection state: ATTACHED");
        pega.cti.API.connection.addHandler(onFinesseXMPPMessage, null, 'message', null, null, null);
        pega.cti.API.connection.addHandler(onFinessePresenceMessage, null, 'presence', null, null, null);
        pega.cti.API.connection.send($pres().tree());
        break;
      default:
        pega.cti.API.Logger.info("Received unknown XMPP Connection Status:" + status);
    }
  },
  
  buildPegaEvent: function(eventType) {
    var eventObj = new Object();
    eventObj.pyMedia = "Phone";
    eventObj.pyAgentID = this.agentId;
    eventObj.pyThisDN = this.dn;
    eventObj.pyEventType = eventType;
    eventObj.pyClientHandle = this.pyClientHandle;
    eventObj.pyEventTimeStamp = $.now();
    eventObj.pyLinkName = this.LinkDefinition.pyLinkDefinitionName;
    eventObj.pyLinkInsHandle = this.LinkDefinition.pzInsKey;
    return eventObj;
  },
  
  handleDialogsEvent: function(evtJSON) {
    if(evtJSON.Dialog.length != null) {
      for(var i=0; i< evtJSON.Dialog.length; i++)
        this.handleDialogEvent(evtJSON.Dialog[i]);
    } else {
      this.handleDialogEvent(evtJSON.Dialog);
    }
  },
  
  createCallVariables: function(evtJSON) {
    var callData = new Object();
    for(var i=0; i< evtJSON.CallVariable.length; i++) {
      //replace '.','[' charecters with '_' and ']' with blank in call variable name
      var cvName = evtJSON.CallVariable[i].name.replace(/\s+/g, '').replace(/[\[\]&\/\\#, +()$~%.'":*?<>{}]/g, '_'); 
      callData[cvName] = typeof(evtJSON.CallVariable[i].value) == 'string' ? evtJSON.CallVariable[i].value : '';
    }
    return callData; 
  },
  
  handleDialogEvent: function(evtJSON) {
    pega.cti.API.Logger.info('Parsing call state event from Finesse');
    if(evtJSON.mediaType == 'Voice') {
        if (evtJSON.mediaProperties.callType == "SUPERVISOR_MONITOR") {
            pega.cti.API.Logger.debug('Ignoring silent monitoring dialog event');
       } else {
      
      
      var callEvent = this.buildPegaEvent('CallInfoEvent');
      
      //getCallVariables
      callEvent.pyNamedVariables = this.createCallVariables(evtJSON.mediaProperties.callvariables);
      callEvent.pyCallId  = evtJSON.id;
      callEvent.pyCallType = this.getCallType(evtJSON.mediaProperties.callType, callEvent.pyNamedVariables);
      
      callEvent.pyCTICallType = evtJSON.mediaProperties.callType;
      callEvent.pyDNIS = evtJSON.mediaProperties.DNIS;
      callEvent.pyDialedNumber  =   evtJSON.mediaProperties.dialedNumber;
      callEvent.pyANI = evtJSON.fromAddress;
      callEvent.pyQueue = evtJSON.mediaProperties.queueNumber;
      callEvent.pyThisQueue = evtJSON.mediaProperties.queueName;
      //Fix for bug-357685
      callEvent.pyOtherDN = evtJSON.fromAddress;
            
     if (evtJSON.state  == "INITIATING")
       callEvent.pyLineState = "Initiated";
      else if (evtJSON.state  == "DROPPED")
       callEvent.pyLineState = "Idle";
      else if (evtJSON.state  == "ALERTING") 
        callEvent.pyLineState = "Offering";
      
      callEvent.pyParties = [];
      //If one participant - lenght will be undefined
      if(evtJSON.participants.Participant != null && evtJSON.participants.Participant.length == null) {
        var partyObj = new Object();
        partyObj.pyDN = evtJSON.participants.Participant.mediaAddress;
        partyObj.pyDNState = this.getEventNameForCall(evtJSON.participants.Participant.state);
        partyObj.pyOnSwitch = this._getParticipantRole(evtJSON.participants.Participant.mediaAddressType);
        partyObj.pyActions = evtJSON.participants.Participant.actions.action;
        callEvent.pyParties.push(partyObj);
        
      } else {
        for(var i=0;i<evtJSON.participants.Participant.length;i++) {
          var partyObj = new Object();
          partyObj.pyDN = evtJSON.participants.Participant[i].mediaAddress;
          partyObj.pyDNState = this.getEventNameForCall(evtJSON.participants.Participant[i].state);
          partyObj.pyOnSwitch = this._getParticipantRole(evtJSON.participants.Participant[i].mediaAddressType);
          //BUG-346393 - Special handling of Internal calls for UCCX implementations
          if(partyObj.pyDN != this.dn && partyObj.pyOnSwitch == 'true' && partyObj.pyDNState == 'Initiated' && callEvent.pyCallType == 'OUTBOUND' && this.deploymentType == 'UCCX')
            callEvent.pyCallType = 'INTERNAL';
          partyObj.pyActions = evtJSON.participants.Participant[i].actions.action;
          
        	 callEvent.pyParties.push(partyObj);
        }
      }
      console.log(JSON.stringify(callEvent));
      this.forwardEvent(JSON.stringify(callEvent));
       }
    }else {
      pega.cti.API.Logger.info('Ignoring non-Voice dialog event');
    }
  },
  
	handleUserEvent: function(evtJSON) {    
    if(this.systemStatus === 'OUT_OF_SERVICE') {
       pega.cti.API.Logger.info("Ignoring agent event as system status is OUT_OF_SERVICE");
      //Since we received an event - make logout flag to true
      this.failoverManager.agentLogoutReceived = true;
    } else {
      if(!this.failoverManager.agentLogoutReceived) {
        this.failoverManager.agentLogoutReceived = true;
        if(evtJSON.state === 'LOGOUT') {
          pega.cti.API.Logger.info('Received agent logout event. Ignoring since this is due to failvoer');
          return;
        }
      }
      
	      if(evtJSON.state === 'LOGOUT') { 
         if (this.isLogoutReqested != true){
              var errorEvent = this.buildPegaEvent('ErrorEvent');
              var logErrorMessage = "Agent was logged out from Pega call due to log out from external device";
              errorEvent.pyErrorCode =  "FINESSE_EXTERNAL_LOGOUT";
              errorEvent.pyErrorMessage = "FINESSE_EXTERNAL_LOGOUT"; 
              if (evtJSON.reasonCode != null) 
              if (evtJSON.reasonCode.systemCode == "true") {
                errorEvent.pyErrorCode =  "Finesse_"+ evtJSON.reasonCode.code;
                errorEvent.pyErrorMessage = "Finesse_"+ evtJSON.reasonCode.label;
                logErrorMessage =  logErrorMessage+ " with error code " +  evtJSON.reasonCode.code;
               }
           pega.cti.API.Logger.Error(logErrorMessage);
              pega.cti.API.Logger.debug('Forwarding Error Event with error code [' + errorEvent.pyErrorCode + '] for agent [' + this.agentId + ']');
                        this.forwardEvent(JSON.stringify(errorEvent));
          }
        this.isLogoutReqested = false;
        }
      
      pega.cti.API.Logger.info('Parsing agent state event from Finesse');
      var agentEvent = this.buildPegaEvent('AgentStateEvent');
      if(evtJSON.state == 'WORK' || evtJSON.state == 'WORK_READY')
        agentEvent.pyWorkMode = 'AFTER_CALL_WORK';
      this.currentAgentState = this.getMappingAgentState(evtJSON.state);
      if(this.currentAgentState == 'Busy') {
        agentEvent.pyEventName = agentEvent.pyAgentState = 'NotReady';
        agentEvent.pyWorkMode = 'Busy';
      }else {
      	agentEvent.pyEventName = agentEvent.pyAgentState = this.currentAgentState;  
      }
      if(evtJSON.reasonCodeId)
        // reasonCodeId (DBId) will be -1 on initial login or after a failover
      {agentEvent.pyReasonCode =  evtJSON.reasonCodeId == '-1' ? '0' : (evtJSON.reasonCode != undefined ) ? (evtJSON.reasonCode.code): '0'; //Reason code is '-1' - set it to 0
        if (evtJSON.reasonCode  != undefined && evtJSON.reasonCode  != null )
       if (evtJSON.reasonCode.systemCode == "true")
      agentEvent.pyReasonCodeLabel = evtJSON.reasonCode.label;
      }
      
      pega.cti.API.Logger.debug('Forwarding Agent State ['+ agentEvent.pyAgentState +'] for agent ['+ this.agentId +']');
      this.forwardEvent(JSON.stringify(agentEvent));
      //If we receive logout event, unsubscribe from event stream and send a snapshot  for logout 
	    if(agentEvent.pyAgentState === 'Logout') {
        if (pega.cti.API.SSORefreshTimeout != undefined && pega.cti.API.SSORefreshTimeout != null ) clearTimeout(pega.cti.API.SSORefreshTimeout);  
        this.unsubscribe(
          'Logout', 
		      function() {
		  	    pega.cti.API.Logger.debug('Unsubscription successful for agent['+this.agentId+']'); 
		      }
		    );
        var snapshotEvent = this.getAgentSnapshotJson('Logout');
        pega.cti.API.pyLinkState = null; 
        pega.cti.API.isConnAcquired = false;
        this.forwardEvent(snapshotEvent);
      }
    }
  },
  	 
  handleErrorEvent: function(evtJSON) {
    pega.cti.API.Logger.debug('Parsing error event from Finesse');
    var errorEvent = this.buildPegaEvent('ErrorEvent');
    errorEvent.pyErrorCode = this.getMappingErrorCode(evtJSON.apiError.errorMessage);
    //Changed by Ram Reddy Boddireddy, as part of bug, BUG-624737 to show the error message instead of error type. Commented below line.
    //errorEvent.pyErrorMessage = evtJSON.apiError.errorType;
    errorEvent.pyErrorMessage = evtJSON.apiError.errorMessage;
    pega.cti.API.Logger.debug('Forwarding Error Event ['+ errorEvent.pyErrorMessage +'] for agent ['+ this.agentId +']'); 
    this.forwardEvent(JSON.stringify(errorEvent));
    
    if(errorEvent.pyErrorCode == 'INV_LOGON_DEVICE' || 
       ((errorEvent.pyErrorCode == 'GENERIC_UNSPECIFIED_REJECTION' || errorEvent.pyErrorCode == "CF_RESOURCE_BUSY") && ( this.currentAgentState == 'Logout' || this.currentAgentState == null)))
       { // Invalid login device specified - unsubscribe from events
       if (pega.cti.API.SSORefreshTimeout != undefined && pega.cti.API.SSORefreshTimeout != null ) clearTimeout(pega.cti.API.SSORefreshTimeout);
         pega.cti.API.Logger.Error('Unsubscribing from event stream due to invalid login device provided for agent ['+this.agentId+']');
      this.isValidDevice = false;
      this.unsubscribe(
        'INV_LOGON_DEVICE',
        function() { pega.cti.API.Logger.debug('Unsubscription successful for agent['+this.agentId+']'); }
      );
    }
  },
  
  handleSystemInfoEvent: function(evtJSON) {
    //If System status is not same as new status from event - send it to FailoverManager
    if (evtJSON.status !== this.systemStatus && evtJSON.status === 'OUT_OF_SERVICE') 
      this.failoverManager.failoverHandler('SYSTEM_FAILOVER');
    else if (evtJSON.status !== this.systemStatus && evtJSON.status === 'IN_SERVICE') {
      //We need to wait for logout event of the agent before attempting to re establish the connection
      var sysFailover = setInterval(function() {
        if(pega.cti.API.failoverManager.agentLogoutReceived) {
          clearInterval(sysFailover); 
          pega.cti.API.failoverManager.resetFailvoer();
          pega.cti.API.systemStatus = evtJSON.status;
          pega.cti.API.pyLinkState = 'CONNECTED';
          pega.cti.API.changeAgentState('<User><state>LOGIN</state><extension>' + pega.cti.API.dn +'</extension></User>',
            function() {  
              pega.cti.API.generateSnapshot(function() {
                pega.cti.API.Logger.debug('Error while generating snapshot from SystemInfo event');
              }); 
            }, 
          onFailure);
        }
      },1000);
    }
  },
  
    //Incoming events handler
  onMessage: function(message) {
    try {
      //Parse incoming event
 	    pega.cti.API.Logger.info('Received new event: ' + message.text);
      var evtJSON = XmlToJson($.parseXML(message.text)); //retrun XML data from notification
      if(evtJSON.Update.data.user != null) { //Agent State Event
        this.handleUserEvent(evtJSON.Update.data.user);
      } else if(evtJSON.Update.data.dialogs != null) { //Multiple Dialogs(calls) Event
        this.handleDialogsEvent(evtJSON.Update.data.dialogs);
      } else if(evtJSON.Update.data.dialog != null) { //Single call State Event
        this.handleDialogEvent(evtJSON.Update.data.dialog);
      } else if(evtJSON.Update.data.apiErrors != null) { //Async Error Event
        this.handleErrorEvent(evtJSON.Update.data.apiErrors);
      } else if(evtJSON.Update.data.systemInfo!= null) {
        this.handleSystemInfoEvent(evtJSON.Update.data.systemInfo);
      } else { //Unknown event
        pega.cti.API.Logger.info('Received unhandled event:'+ message);
      }
    } catch(e) {
      pega.cti.API.Logger.Error('Error while parsing async event '+ e.toString());
    }finally {
      return true;
    }
  },
  
  subscribe: function(deviceState, onSuccess, onFailure) {
    pega.cti.API.Logger.debug('Subscribing to event stream for agent ['+ this.agentId +']');
    if(deviceState === 'OPENED') {
     
      this.subscribe("CLOSED", onSuccess, onFailure);
      if(this.pyLinkState === 'DISCONNECTED') {
        //Send reconnecting snapshot
        var snapshotEvent = this.getAgentSnapshotJson('Busy');
        this.forwardEvent(snapshotEvent);
      } else {
        pega.cti.API.Logger.debug('Waiting for snapshot for Agent ['+ pega.cti.API.agentId +'] with extension ['+ pega.cti.API.dn +']');
	      onSuccess();
        //this.generateSnapshot(onFailure);
      }
    } else if (deviceState === 'FAILOVER') {
      try {
        this.connection.connect(this.agentId.toLowerCase() + '@' + this.LinkDefinition.hostURL+"/pegacall", this.agentPwd,
          function(status,reason) {
            pega.cti.API.onStatusChange(status, reason,'failover', function() {
              if(pega.cti.API.deploymentType == 'UCCE')
                pega.cti.API.generateSnapshot(onFailure);
              else {
                pega.cti.API._checkStateAndLogin(onSuccess, onFailure);
              }
            }, onFailure);
        }, pega.cti.API.HTTPBindInterval);
      } catch (e) {
        pega.cti.API.Logger.Error("Error while while establishing XMPP session. Encountered error - " + e.message);
        onFailure("Error while while establishing XMPP session. Encountered error - " + e.message)
      }
    }else {
      try {
        this.connection.connect(this.agentId.toLowerCase() + '@' + this.LinkDefinition.hostURL+"/pegacall", this.agentPwd, 
          function(status,reason) {
            pega.cti.API.onStatusChange(status,reason,'subscribe',function() {
              if(pega.cti.API.pyLinkState === 'DISCONNECTED') {
                var snapshotEvent = pega.cti.API.getAgentSnapshotJson('Busy');
                pega.cti.API.forwardEvent(snapshotEvent);
              } else {
				pega.cti.API._checkStateAndLogin(onSuccess, onFailure);
              }
            }, onFailure);
        }, pega.cti.API.HTTPBindInterval);
      } catch (e) {
        pega.cti.API.Logger.Error("Error while while establishing XMPP session. Encountered error - "+e.message);
        onFailure("Error while while establishing XMPP session. Encountered error - "+e.message)
    	}
    }
  },
  _checkStateAndLogin: function(onSuccess, onFailure) {
    pega.cti.API.getAgentState(function(agentState, reasonCode,reasonCodeLabel) {
        if (agentState.toUpperCase() == "LOGOUT") {
            pega.cti.API.Logger.debug('Attempting to login agent ['+ pega.cti.API.agentId +'] with extension ['+ pega.cti.API.dn +']');
            pega.cti.API.changeAgentState('<User><state>LOGIN</state><extension>' + pega.cti.API.dn + '</extension></User>',
                function() {
                    pega.cti.API._waitForLogin(10, 1000, onSuccess, onFailure);
                }, onFailure);
        } else {
            onSuccess();
            pega.cti.API.buildSnapshotWithLines(agentState, reasonCode, function(snapshotEvent) {
                    pega.cti.API.forwardEvent(snapshotEvent);
            }, onFailure,reasonCodeLabel);}

    }, function(response){
       this.currentAgentState = 'Logout' ;
       if (this.connection != undefined)
       this.connection.disconnect('INV_LOGON_DEVICE');
       onFailure(response);});
},
  unsubscribe: function(reason, onSuccess, onFailure) {
    pega.cti.API.Logger.debug('Unsubscribing to event stream for agent ['+ pega.cti.API.agentId +']')
    this.connection.disconnect(reason);
    onSuccess(); 
  },
  
  /*
  @api - Log agent into the ACD.
  @param $String$AgentId – The Agent's ACD ID.
  $String$AgentPwd - The Agent's ACD Password
  $String$AgentPwd - The Agent's ACD Password
  $String$Extension - The Agent's ACD Extension/Position
  $String$LinkName - The CTILink Name as configured
  $Object$Options – Array of Optional Parameters.
  @return $undefined$ - TBD.
  */
login: function(AgentId, AgentPwd, Extension, LinkDefinition, Options, onSuccess, onFailure, forwardEvent) {
    this.agentId = AgentId;
    this.agentPwd = AgentPwd;
    this.dn = Extension;
    this.isValidDevice = true;
    this.forwardEvent = forwardEvent;
    if (Options.SSOLogin == true || Options.SSOLogin == "true") {
        this._SSOLogin(LinkDefinition, Options, onSuccess, onFailure);
    } else {
        this.authString = this.getAuthString();
        if (typeof(LinkDefinition.DeploymentType) != "undefined" && typeof(LinkDefinition.LookUpLoginID) != "undefined") // check for the old links
            if (LinkDefinition.DeploymentType == "UCCE" && LinkDefinition.LookUpLoginID == "true") {
                pega.cti.API.Logger.debug('looking up for login id with user id [' + AgentId + ']');
                this._replaceAgentIDWithLoginID(LinkDefinition.AdminUserID, LinkDefinition.AdminPassword, LinkDefinition, Options, function(data) {
                    pega.cti.API.authString = pega.cti.API.getAuthString();
                    pega.cti.API._login(Options, onSuccess, onFailure);
                });
                return;
            }

        //Initialize data  
        this.initialize(LinkDefinition, Options, onSuccess, onFailure);

        //Subscribe for events once we have pyLinkState
        var intv = setInterval(function() {
            if (pega.cti.API.pyLinkState) {
                clearInterval(intv);
                pega.cti.API._login(Options, onSuccess, onFailure);
            }
        }, 100);

    }
},
  
_SSOLogin: function(LinkDefinition, Options, onSuccess, onFailure) {
    this.initialize(LinkDefinition, Options, onSuccess, onFailure);
    this.loginOnSuccess = onSuccess;
    this.loginOnFailure = onFailure;
   
    if (sessionStorage.getItem("SSOtoken") != null) {
        this.authString = "Bearer " + sessionStorage.getItem("SSOtoken");
        this.agentPwd = sessionStorage.getItem("SSOtoken");
        this._replaceUserIDWithLoginID(Options, function(data) {
            pega.cti.API._login(Options, onSuccess, onFailure);
        });
        this._checkandrefreshtoken();
    } else {
        var SSODetails = this.LinkDefinition.pySSOLogin;
        this.tokenRefreshAttempts =SSODetails.pyTokenRefreshAttempts;
        var popupURL = SSODetails.pyIDSURL + "/ids/v1/oauth/authorize" + "?redirect_uri=" + SSODetails.pyRedirectURL + "&client_id=" + SSODetails.pyClientID + "&state=pegacall&response_type=code";
        console.log("popupurl is", popupURL);

        var height = 600;
        var width = 350;
        var top = (window.screenLeft !==  undefined ? window.screenLeft : window.screenX)+ ((window.innerHeight - height) / 2);
        var left = (window.screenTop !==  undefined   ? window.screenTop  : window.screenY)+((window.innerWidth - width) / 2);
        window.open(popupURL, 'Finesse SSO', 'resizable=yes,height=' + height + ',width=' + width + ',left=' + left + ',top=' + top);
    }

},

    setTokenForSSO: function(SSOData) {

        if (typeof SSOData == "string") {
            var SSOTokenData = JSON.parse(SSOData.replace(/&quot;/g, '"'));
            sessionStorage.setItem("SSOtoken", SSOTokenData.access_token);
            this.authString = "Bearer " + sessionStorage.getItem("SSOtoken");
            this.agentPwd = sessionStorage.getItem("SSOtoken");
            var Options = new Object();
            this._replaceUserIDWithLoginID(Options, function(data) {
                pega.cti.API._login(Options, pega.cti.API.loginOnSuccess, pega.cti.API.loginOnFailure);
            });
            var todayDate = new Date();
            var presentTime = todayDate.getTime();
            var expireTime = SSOTokenData.expires_in * this.LinkDefinition.pySSOLogin.pyTokenRefreshTimer*10;

            sessionStorage.setItem("SSOTokenExpireTime", presentTime + expireTime);
            if (pega.cti.API.SSORefreshTimeout != undefined && pega.cti.API.SSORefreshTimeout != null ) clearTimeout(pega.cti.API.SSORefreshTimeout);
            pega.cti.API.SSORefreshTimeout = setTimeout(this._checkandrefreshtoken, expireTime);
        }
    },

    _checkandrefreshtoken: function() {
        if (sessionStorage.getItem("SSOTokenExpireTime") <= (new Date()).getTime())
          if (sessionStorage.getItem("SSOtoken") == null || sessionStorage.getItem("SSOtoken") == undefined)  
             sendError("Unable to find existing token. Please logout and login again");
          else
            refreshSSOToken(sessionStorage.getItem("SSOtoken"));
    },

    updateTokenForSSO: function(SSOData) {
       var SSOTokenData = JSON.parse(SSOData.replace(/&quot;/g, '"'));
        if (SSOTokenData.error != "" && SSOTokenData.error != undefined) {
          if (this.tokenRefreshAttempts< this.tokenRefreshTries )
            {
              sendError(SSOTokenData.error_description);       
              sessionStorage.removeItem("SSOtoken");
              this.tokenRefreshTries = 0;
            }
          else
            {
              this.tokenRefreshTries ++;
              if (pega.cti.API.SSORefreshTimeout != undefined && pega.cti.API.SSORefreshTimeout != null ) clearTimeout(pega.cti.API.SSORefreshTimeout);
              pega.cti.API.SSORefreshTimeout = setTimeout(this._checkandrefreshtoken, expireTime);
             }
        }
        else {
            sessionStorage.setItem("SSOtoken", SSOTokenData.access_token);
            this.authString = "Bearer " + sessionStorage.getItem("SSOtoken");
            this.agentPwd = sessionStorage.getItem("SSOtoken");
            var todayDate = new Date();
            var presentTime = todayDate.getTime();
            var expireTime = SSOTokenData.expires_in * this.LinkDefinition.pySSOLogin.pyTokenRefreshTimer *10;
            sessionStorage.setItem("SSOTokenExpireTime", presentTime + expireTime);
             if (pega.cti.API.SSORefreshTimeout != undefined && pega.cti.API.SSORefreshTimeout != null ) clearTimeout(pega.cti.API.SSORefreshTimeout);
              pega.cti.API.SSORefreshTimeout = setTimeout(this._checkandrefreshtoken, expireTime);
            this.tokenRefreshTries = 0;

        }
    },
  
  _login: function(Options,onSuccess, onFailure) {
		if (Options.isSnapshotOnly == true || Options.isSnapshotOnly == "true") {
			this.generateSnapshot(onFailure);
		} else {
      if (this.subscriptionStarted == false)
      {this.connection = new Strophe.Connection(pega.cti.API.BOSH_SERVICE, {'keepalive': true});
       this.subscriptionStarted = true;
       this.subscribe(Options.pyDeviceState, onSuccess, onFailure);
      }
		}
    },


  _replaceUserIDWithLoginID: function(Options,Callback) {
    var intv = setInterval(function() {
        if (pega.cti.API.pyLinkState) {
            clearInterval(intv);
            pega.cti.API.sendRESTRequest('GET',null , pega.cti.API.hostURL + '/finesse/api/User/' + pega.cti.API.agentId, function(data) {
              if (data.User.loginId != null)
                  {  pega.cti.API.agentId = data.User.loginId;
                 //  pega.cti.API.agentPwd =   data.User.loginId;
                  }
                Callback();
            },  Callback);
        }
    }, 100);
},
  
	
	
_replaceAgentIDWithLoginID: function(AdminUserID, AdminPassword,LinkDefinition, Options,Callback) {
    this.authString = "Basic " + window.btoa(AdminUserID + ":" + atob(AdminPassword)); //over writting the auth string
    this.initialize(LinkDefinition, Options, onSuccess, onFailure);
    var intv = setInterval(function() {
        if (pega.cti.API.pyLinkState) {
            clearInterval(intv);
            pega.cti.API.sendRESTRequest('GET',null , pega.cti.API.hostURL + '/finesse/api/User/' + pega.cti.API.agentId, function(data) {
              if (data.User.loginId != null)
                    pega.cti.API.agentId = data.User.loginId;
                Callback();
            },  Callback);
        }
    }, 100);
},
  
  getAgentReasonCodes: function(reasonCode, onSuccess, onFailure)
  {
    var _this = this;
    if(this.systemStatus === 'OUT_OF_SERVICE') {
      pega.cti.API.Logger.info('System in OUT_OF_SERVICE state. Unable to send request for reason codes');
      return;
    } 
    pega.cti.API.Logger.debug('Sending request for getting list of codes for  Reason Code catagory ['+ reasonCode +']');
    this.sendRESTRequest('GET',null,this.hostURL + '/finesse/api/User/' + this.agentId + '/ReasonCodes?category='+ reasonCode, 
      function(data) {
        var reasonCodeList = [];
        if(data.ReasonCodes.ReasonCode != null) {// Check if Reasoncodes not defined in Finesse
          //only 1 reason code exists - Lenght of reasonCode arrary will be null
          if(data.ReasonCodes.ReasonCode.length == null) {
            var reasonCodeObj = new Object();
            //US-393746 Change Reason Code handling for Finesse Adapter
            reasonCodeObj.pyCode = data.ReasonCodes.ReasonCode.code;
            var uriCode = _this.getReasonCodeFromURI(data.ReasonCodes.ReasonCode.uri);
           _this.updateUriReasonCodeMap(data.ReasonCodes["@attributes"].category +  reasonCodeObj.pyCode,uriCode);
           
            reasonCodeObj.pyDisplayName = data.ReasonCodes.ReasonCode.label;
            reasonCodeList.push(reasonCodeObj);
          } else {
            for(var i = 0; i < data.ReasonCodes.ReasonCode.length; i++) {
              var reasonCodeObj = new Object();
               //US-393746 Change Reason Code handling for Finesse Adapter
              reasonCodeObj.pyCode = data.ReasonCodes.ReasonCode[i].code;
              var uriCode = _this.getReasonCodeFromURI(data.ReasonCodes.ReasonCode[i].uri);
              _this.updateUriReasonCodeMap(data.ReasonCodes["@attributes"].category + reasonCodeObj.pyCode,uriCode);
              
              reasonCodeObj.pyDisplayName = data.ReasonCodes.ReasonCode[i].label;
              reasonCodeList.push(reasonCodeObj);
            }
          }
        }
        onSuccess(reasonCodeList);
      },
      onFailure);
  },
  
  //HFIX-52839 Considering DB Id instead of Code - Fetching DB Id, the last element from uri
  getReasonCodeFromURI: function(uri){
    var uriElements = uri.split("/");
    return uriElements[uriElements.length - 1];
  },

  updateUriReasonCodeMap : function(code, UriCode){ 
    this.uriReasonCodeMap.set(code,UriCode);
  },
  
  queryAgentConfig: function(onSuccess, onFailure) {
    
    //Global variable
    agentConfigEvent = new Object();
    
    //Get Notready reasoncodes
    this.getAgentReasonCodes('NOT_READY',
      function(data) {
        agentConfigEvent.pyNotReadyReasonCodes = data;  
        pega.cti.API.notReadyReasoncodes =data;
        //Get logout reasoncodes
        pega.cti.API.getAgentReasonCodes('LOGOUT',
          function(data) {
            agentConfigEvent.pyLogoutReasonCodes = data;
            onSuccess(agentConfigEvent);
          },
        onFailure);
      },
    onFailure);
  },
  
  getAgentSnapshotJson: function(agentState, reasonCode,reasonCodeLabel) {
    var snapshotObj = this.buildPegaEvent('SnapshotEvent');
    snapshotObj.pyEventName = 'Snapshot';
    if(reasonCode != null)
    	snapshotObj.pyReasonCode = reasonCode;
    snapshotObj.pyEventString = 'DeviceSnapshot';
    snapshotObj.pyLinkState = this.pyLinkState;
    snapshotObj.pySessionId = this.pySessionId;
    snapshotObj.pyUserIdentifier = this.pyUserIdentifier;
    snapshotObj.pyReasonCodeLabel =  reasonCodeLabel;
    if(agentState !== 'Logout')
    	snapshotObj.pyDeviceState = 'OPENED';
    else
      snapshotObj.pyDeviceState = 'CLOSED';
    if(agentState ==='Busy') {
      snapshotObj.pyAgentState = 'NotReady';
      snapshotObj.pyWorkMode = 'Busy';
    }else {
    	snapshotObj.pyAgentState = agentState;  
    }
    return (JSON.stringify(snapshotObj));
  },
  
  getAgentState: function(onSuccess, onFailure) {
    //BUG-353892: Retain agent's current state
    var pendingAgentState = null, extension = null, reasonCode = 0, reasonCodeLabel =null;
    //request for snapshot for Agent state
    this.sendRESTRequest('GET',null, this.hostURL + '/finesse/api/User/' + this.agentId, 
      function(data) {
        pega.cti.API.currentAgentState = pega.cti.API.getMappingAgentState(data.User.state);
        pendingAgentState = typeof(data.User.pendingState) == 'string' ? data.User.pendingState : null;
        extension = data.User.extension;
        // reasonCodeId (DBId) will be -1 on initial login or after a failover Get reason code - If '-1' - set it to 0
        reasonCode = data.User.reasonCodeId == -1 ? 0 : (data.User.reasonCode != undefined ) ? (data.User.reasonCode.code) : 0;
      if (data.User.reasonCode != undefined && data.User.reasonCode != undefined )  
      if (data.User.reasonCode.systemCode == "true")
              reasonCodeLabel = data.User.reasonCode.label; 
      if(typeof(extension) !== 'string' && pendingAgentState !== 'LOGIN') {
          pega.cti.API.Logger.info('Invalid device or out of service');
		  onSuccess(pega.cti.API.currentAgentState,reasonCode);
        } else if(pendingAgentState === 'LOGIN') {
          //Retry if LOGIN is pending
          pega.cti.API.getAgentState(onSuccess, onFailure);
        }else if (pega.cti.API.currentAgentState == null || extension!= pega.cti.API.dn || (pega.cti.API.currentAgentState == 'Logout' && pendingAgentState != 'LOGIN')) { 
         
          pega.cti.API.Logger.info('Agent not in proper state. Operation failed');
          var errObject = new Object();
          errObject.errCode = 'LOGIN_FAIL';
          errObject.errMessage = 'Agent not in proper state. Operation failed';
          onFailure(errObject);
        } else {
          onSuccess(pega.cti.API.currentAgentState, reasonCode,reasonCodeLabel);
        }
      }, 
    onFailure);
  },
  
  getCallDialogs: function(onSuccess, onFailure) {
    //request dialogs for call dialogs
    this.sendRESTRequest(
      'GET', 
      null, 
      this.hostURL + '/finesse/api/User/' + this.agentId + '/Dialogs',
      onSuccess, 
      onFailure
    );
  },
  
  buildSnapshotWithLines: function(agentState, reasonCode, onSuccess, onFailure,reasonCodeLabel) {
    
    this.getCallDialogs(
      function(data) {
        var snapshotEvent = pega.cti.API.getAgentSnapshotJson(agentState, reasonCode,reasonCodeLabel);
        var linesArray = [];
        for (var k = pega.cti.API.pyNumberOfLines; k > 0; k--) {
          var lineObject = new Object();
          lineObject.pyLineNumber = pega.cti.API.pyNumberOfLines - k + 1;
          lineObject.pyCallId = '0';
          lineObject.pyLineState = 'idle';
          linesArray.push(lineObject);
        }
        if(data.Dialogs.Dialog) {
          var tempDialogs = [];
          if(data.Dialogs.Dialog.length == null)
            tempDialogs.push(data.Dialogs.Dialog);
          else {
            for(var i=0; i < data.Dialogs.Dialog.length; i++)
              tempDialogs.push(data.Dialogs.Dialog[i]);
          } 
          for (var i = 0; i < tempDialogs.length; i++) {
            if (tempDialogs[i].mediaType == 'Voice') {
              if(i  < pega.cti.API.pyNumberOfLines){
                linesArray[i].pyCallId = tempDialogs[i].id;
                var participantsArray = tempDialogs[i].participants.Participant;
                linesArray[i].pyParties = [];
                //Loop through Participant arrya and build line
                //start of changes for bug, BUG-678561
                if(participantsArray.length===undefined ||  participantsArray.length=== 0){
                  if(participantsArray.state==="WRAP_UP"){
                      var tempSnapshotEvent = JSON.parse(snapshotEvent);
                      tempSnapshotEvent.pyWorkMode = "AFTER_CALL_WORK";
                      snapshotEvent = JSON.stringify(tempSnapshotEvent);
                  }
                }
                //end of changes for bug, BUG-678561
                for (var j = 0; j < participantsArray.length; j++) {
                  //current DN - copy Line state
                  if (participantsArray[j].mediaAddress == pega.cti.API.dn) 
                    linesArray[i].pyLineState = pega.cti.API.getMappingCallStateForSnapshot(participantsArray[j].state);
                  else {
                  //Parties array
                  var tempParties = new Object();
                  tempParties.pyDN = participantsArray[j].mediaAddress;
                  tempParties.pyOnSwitch = pega.cti.API._getParticipantRole(participantsArray[j].mediaAddressType);
                  tempParties.pyActions = participantsArray[j].actions.action;
                  //Push party details into pyParties
                  linesArray[i].pyParties.push(tempParties);
                }
              }
            }else{
              pega.cti.API.Logger.Error('Number of phone lines configured in PegaCall should match with Physical Phone');
            }
          }
          }
        }
        snapshotEvent = snapshotEvent.substring(0, snapshotEvent.length - 1) + ',"pyLines":' + JSON.stringify(linesArray) + "}";
        onSuccess(snapshotEvent);
        
    	},
      
      onFailure
    );
  },
  
  //Snapshot will be built in two parts - General Snapshot event data with agent state, Lines data built from Dialogs
  generateSnapshot: function(onFailure) {
    //Retrieve Agent state
    this.getAgentState(function(agentState, reasonCode,reasonCodeLabel) {
      //Get lines & build Snapshot - on Success, send the event to forwardEvent function
      pega.cti.API.buildSnapshotWithLines(agentState, reasonCode, function(snapshotEvent) {
        pega.cti.API.forwardEvent(snapshotEvent);
        //BUG-353892 - Request agent state change to Ready (For failover scenario)
        if (typeof(setAgentReady) !== 'undefined' && setAgentReady === true) {
           pega.cti.API.Logger.info('Resetting agent to Ready state');
            pega.cti.API.agentReady(pega.cti.API.agentId, '', '', 
              function() {
                delete setAgentReady;
              }, function() {
              pega.cti.API.Logger.info('Error while setting agent to Ready');
            });
          }
        }, onFailure,reasonCodeLabel);
    }, onFailure);
  },
  
    /*
@api - Log agent out of the ACD.
@param $String$AgentId – The Agent's ID.
@param $String$ReasonCode – The logout reason code.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - TBD.
*/
logout: function(AgentId, ReasonCode, Options, onSuccess, onFailure) {
        var forcedLogout = false;
  this.isLogoutReqested = true;
        if (typeof Options != 'undefined')
          if (typeof Options.pyForcedLogout != 'undefined')
			forcedLogout =Options.pyForcedLogout;
		if ((typeof ReasonCode == "undefined" || ReasonCode == null)  && forcedLogout == true)
			ReasonCode = this.defaultLogoutReasonCode;
        if (this.currentAgentState === 'Ready' && forcedLogout == true) {
            var notReadyReasonCode ;
            if  (this.defaultNotReadyReasonCode != null)
				notReadyReasonCode = this.defaultNotReadyReasonCode ;
            else if ( this.notReadyReasonCodes.length>0)
              notReadyReasonCode= this.notReadyReasonCodes[0].pyCode;
            this.agentNotReady(AgentId, "NOT_READY",notReadyReasonCode, null, function() {
                pega.cti.API._logout(AgentId, ReasonCode, Options, onSuccess, onFailure);
            }, onFailure);
        } else {
            this._logout(AgentId, ReasonCode, Options, onSuccess, onFailure);
        }

    },


    _logout: function(AgentId, ReasonCode, Options, onSuccess, onFailure) {
        var payload = null;
        ReasonCode = this.uriReasonCodeMap.get("LOGOUT"+ReasonCode);
        if (ReasonCode)
            payload = '<User><state>LOGOUT</state><reasonCodeId>' + ReasonCode + '</reasonCodeId></User>';
        else
            payload = '<User><state>LOGOUT</state></User>';

        console.log('Attempting to LOGOUT agent [' + pega.cti.API.agentId + '] with extension [' + pega.cti.API.dn + ']');
        this.changeAgentState(
            payload,
            function() {
                onSuccess();
                console.log("Logout request successful");
            },
            onFailure
        );
    },

  
    /*
@api - Make the agent ready at the ACD.
@param $String$AgentId – The Agent's ID.
@param $String$WorkMode – The ready work mode.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - TBD.
*/
  agentReady: function(AgentId, WorkMode, Options, onSuccess, onFailure) {
    pega.cti.API.Logger.debug('Attempting to change state to READY for agent ['+ pega.cti.API.agentId +'] with extension ['+ pega.cti.API.dn +']');
    this.changeAgentState(
      '<User><state>READY</state></User>', 
      onSuccess,
      onFailure
    );
  },
  
    /*
@api - Make the agent not ready at the ACD.
@param $String$AgentId – The Agent's ID.
@param $String$WorkMode – The not ready work mode.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - TBD.
*/
  agentNotReady: function(AgentId, WorkMode, ReasonCode, Options, onSuccess, onFailure) {
    //Identify agent state based on workmode
    ReasonCode= this.uriReasonCodeMap.get('NOT_READY'+ReasonCode);
    var state = (WorkMode == 'AFTER_CALL_WORK' ? 'WORK' : 'NOT_READY');
    var payload = null;
    if(ReasonCode)
      payload = '<User><state>'+state+'</state><reasonCodeId>'+ReasonCode+'</reasonCodeId></User>';
    else
      payload = '<User><state>'+state+'</state></User>';
    
    pega.cti.API.Logger.debug('Attempting to change state to '+state+' for agent ['+ pega.cti.API.agentId +'] with extension ['+ pega.cti.API.dn +']');
    this.changeAgentState(
      payload, 
      onSuccess,
      onFailure
    );
  },
  
    /*
@api - Send DTMF Tones.
@param $String$CallId – The CallId of the call to send tones to.
@param $String$Digits – The String of tones to be sent.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - TBD.
*/
  sendDTMF: function(CallId, Digits, Options, onSuccess, onFailure) {
     this.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><requestedAction>SEND_DTMF</requestedAction>'+
       '<actionParams><ActionParam><name>dtmfString</name><value>'+Digits+'</value></ActionParam></actionParams></Dialog>',
      onSuccess, 
      onFailure
    );
  },
  
  updateCallData: function(CallId, CallVariables, onSuccess, onFailure) {
    //Build payload
    var payload = '<Dialog><requestedAction>UPDATE_CALL_DATA</requestedAction><mediaProperties><callvariables>';
    var callVar;
    for(callVar in CallVariables)
      payload += '<CallVariable><name>' + CallVariables[callVar].pyKey + '</name><value>' + CallVariables[callVar].pyValue + '</value></CallVariable>';
    payload += '</callvariables></mediaProperties></Dialog>';
    //Send reuqest
    this.changeCallState(CallId, payload, onSuccess, onFailure);
  },
  
  /*
	@api - Place a new call.
	@param $String$Destination – The digits to dial.
	@param $String$Options – Array of Optional Parameters.
	@return $undefined$ - TDB.
  */
  makeCall: function(Destination, Options, onSuccess, onFailure) {
    pega.cti.API.Logger.info('Sending MAKE_CALL request for DN ['+this.dn+'] to DN ['+Destination+']');
    var payload;
    var CallVariables =Options.pyCallVariables;
    if (typeof(CallVariables) != "undefined")
    if (Object.keys(CallVariables).length>0)
      {
        payload =  '<mediaProperties><callvariables>'; 
        for(callVar in CallVariables)
          payload += '<CallVariable><name>' + CallVariables[callVar].pyKey + '</name><value>' + CallVariables[callVar].pyValue + '</value></CallVariable>';
        payload += '</callvariables></mediaProperties>';
      }
  
    this.sendRESTRequest(
      'POST',
      '<Dialog><fromAddress>' + this.dn + '</fromAddress><toAddress>' + Destination + '</toAddress><requestedAction>MAKE_CALL</requestedAction>'+payload+'</Dialog>',
      this.hostURL + '/finesse/api/User/' + this.agentId + '/Dialogs',
      onSuccess, 
      onFailure
    );
  },
  
    /*
@api - Answer a ringing call.
@param $String$CallId – The CallId of the call answer.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  answerCall: function(CallId, Options, onSuccess, onFailure) {
      if (CallId == -1)
          this.getCallDialogs(
              function(data) {
                  var localCallId = -1;
                  if (data.Dialogs.Dialog) {
                      var tempDialogs = [];
                      if (data.Dialogs.Dialog.length == null)
                          tempDialogs.push(data.Dialogs.Dialog);
                      else {
                          for (var i = 0; i < data.Dialogs.Dialog.length; i++)
                              tempDialogs.push(data.Dialogs.Dialog[i]);
                      }

                      for (var i = 0; i < tempDialogs.length; i++) {
                          if (tempDialogs[i].mediaType == 'Voice') {
                              var participantsArray = tempDialogs[i].participants.Participant;
                              //Loop through Participant array 
                              for (var j = 0; j < participantsArray.length; j++)
                                  //current DN - copy Line state
                                  if (participantsArray[j].mediaAddress == pega.cti.API.dn) {
                                      if (pega.cti.API.getMappingCallStateForSnapshot(participantsArray[j].state) == "Alerting") {
                                          localCallId = tempDialogs[i].id;
                                          pega.cti.API.changeCallState(
                                              localCallId,
                                              '<Dialog><targetMediaAddress>' + pega.cti.API.dn + '</targetMediaAddress><requestedAction>ANSWER</requestedAction></Dialog>',
                                              onSuccess,
                                              onFailure);
                                        break;
                                      }
                                  }
                          }
                      }

                  }
                  if (localCallId == -1) {
                      pega.cti.API.Logger.Error("Failed to identify the Call ID in Alerting State ");
                      var errObject = new Object();
                      errObject.errCode = "OPENCTI_ERR_PASS";
                      errObject.errMessage = "Failed to identify the Call ID in Alerting State";
                      onFailure(errObject);
                  }
              },
              onFailure
          );
      else
          this.changeCallState(
              CallId,
              '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><requestedAction>ANSWER</requestedAction></Dialog>',
              onSuccess,
              onFailure
          );
  },
  
    /*
@api - Retrieve a held call.
@param $String$CallId – The CallId of the held call.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  retrieveCall: function(CallId, Options, onSuccess, onFailure) {
    this.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><requestedAction>RETRIEVE</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
  },
  
      /*
@api - Retrieve a held call.Swapping the calls.
@param $String$CallId – The CallId of the held call.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/ 
  
  alternateCall: function(CallId, Options, onSuccess, onFailure) {
    this.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><requestedAction>RETRIEVE</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
  },

    /*
@api - Place a call on hold.
@param $String$CallId – The Call Id of the call to place on hold.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  holdCall: function(CallId, Options, onSuccess, onFailure) {
    this.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><requestedAction>HOLD</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
  },
  
    /*
@api - Hang up a call.
@param $String$CallId – parameter description goes here.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  hangUpCall: function(CallId, Options, onSuccess, onFailure) {
    this.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><requestedAction>DROP</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
  },
     /*
@api - Blind Transfer the call.
@param $String$CallId – The Active Call Id.
@param $String$Destination – The dialed digits of the destination party.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  blindTransfer: function(CallId, Destination, Options, onSuccess, failure) {  

    if (Options  != undefined && Options.pyCallVariables != undefined ) {
      this.updateCallData(
        CallId,Options.pyCallVariables,
        function() {
          pega.cti.API.changeCallState(
            CallId, 
            '<Dialog><targetMediaAddress>' + pega.cti.API.dn + '</targetMediaAddress><toAddress>' + Destination + '</toAddress><requestedAction>TRANSFER_SST</requestedAction></Dialog>',
            onSuccess, 
            onFailure
          );
        },
        failure
      );
    } else {
      this.changeCallState(
        CallId, 
        '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><toAddress>' + Destination + '</toAddress><requestedAction>TRANSFER_SST</requestedAction></Dialog>',
        onSuccess, 
        onFailure
      );
    }
  },
  
    /*
@api - Initiate a (warm/attended) Transfer.
@param $String$CallId – The Call Id of the call.
@param $String$Destination – The dialed digits of the transfer destination.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  transferInitiate: function(CallId, Destination, Options, onSuccess, failure) {
    if (Options  != undefined && Options.pyCallVariables != undefined )
    this.updateCallData(CallId,Options.pyCallVariables,function(){pega.cti.API.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + pega.cti.API.dn + '</targetMediaAddress><toAddress>' + Destination + '</toAddress><requestedAction>CONSULT_CALL</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    )},failure);
    
    else
    this.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><toAddress>' + Destination + '</toAddress><requestedAction>CONSULT_CALL</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
      
  },

/*
@api - Transfer the call.
@param $String$HeldCallId – The Call Id of the held party.
@param $String$ActiveCallId – The call Id of the active (consulted/destination) call.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  transferComplete: function(HeldCallId, ActiveCallId, Options, onSuccess, onFailure) {
	this.changeCallState(
      HeldCallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><requestedAction>TRANSFER</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
  },
  
/*
@api - Place a consultation call.
@param $String$CallId – The CallId of the active call.
@param $String$Destination – The dialed digits of the party to be consulted.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  consulationCall: function(CallId, Destination, Options, onSuccess, onFailure) {
    //Added if block to fix BUG-358174: Simple transfer after V+D transfer behave as V+D transfer
      if (Options  != undefined && Options.pyCallVariables != undefined )
    this.updateCallData(CallId,Options.pyCallVariables,function(){pega.cti.API.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + pega.cti.API.dn + '</targetMediaAddress><toAddress>' + Destination + '</toAddress><requestedAction>CONSULT_CALL</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    )},onFailure);
    
    else
    this.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><toAddress>' + Destination + '</toAddress><requestedAction>CONSULT_CALL</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
  },
/*
@api - Function description goes here.
@param $String$CallId – The CallId of the active call.
@param $String$Destination – The dialed digits of the party to be conferenced.
@param $Oject$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  conferenceInitiate: function(CallId, Destination, Options, onSuccess, onFailure) {
    //Added if block to fix BUG-358174: Simple transfer after V+D transfer behave as V+D transfer
    if (Options  != undefined && Options.pyCallVariables != undefined )
    this.updateCallData(CallId,Options.pyCallVariables,function(){pega.cti.API.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + pega.cti.API.dn + '</targetMediaAddress><toAddress>' + Destination + '</toAddress><requestedAction>CONSULT_CALL</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    )},onFailure);
    
    else
    this.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><toAddress>' + Destination + '</toAddress><requestedAction>CONSULT_CALL</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
  },
    /*
@api - Complete a conference.
@param $String$HeldCallId – The Call Id of the held call.
@param $String$ActiveCallId – The Call Id of the active call.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  conferenceComplete: function(HeldCallId, ActiveCallId, Options, success, failure) {
    this.changeCallState(
      HeldCallId, 
      '<Dialog><targetMediaAddress>' + this.dn + '</targetMediaAddress><requestedAction>CONFERENCE</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
  },
    /*
@api - Drop party from a Conference.
@param $String$CallId – The CallID of the call from which party is to be dropped.
@param $String$Party – The Party to be dropped.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  dropparty: function(CallId, Party, Options, onSuccess, onFailure) {
     this.changeCallState(
      CallId, 
      '<Dialog><targetMediaAddress>' + Party + '</targetMediaAddress><requestedAction>PARTICIPANT_DROP</requestedAction></Dialog>',
      onSuccess, 
      onFailure
    );
  },
/*
@api - retrun the logger 
*/
   getLogger: function(){
    return this.Logger;
  },

    /*** Private function that waits for the login to complete**/

  _waitForLogin: function (retries, delay, successCallback, failureCallback) {
    
    var _this = this; 
    if (this.isValidDevice == false) return;
    if (retries <= 0){
          var errObject = new Object();
          errObject.errCode = 'OPENCTI_ERR_PASS';
          errObject.errMessage = 'Timeout waiting for Login';
          failureCallback(errObject);
    }
    else {
      this._getAgentState (function (agentState, reasonCode, extension,reasonCodeLabel) {
            if (agentState === "LOGOUT" || typeof (extension) !== "string")
            setTimeout(function(){_this._waitForLogin(retries - 1, delay, successCallback, failureCallback);}, delay);
            else  {
            successCallback();
             pega.cti.API.buildSnapshotWithLines(agentState, reasonCode, function(snapshotEvent) {
                         pega.cti.API.forwardEvent(snapshotEvent);
             }, failureCallback,reasonCodeLabel);
          } 
        },
        function (error) {
          failureCallback(error);
        });
    }
    
  },
  
  /**** Private get agent state only used while Login/Subscribe ***/

_getAgentState: function(onSuccess, onFailure) {
    this.sendRESTRequest(
      'GET',
      null, 
      this.hostURL + '/finesse/api/User/' + this.agentId, 
      function(data) {
      var reasonCodeLabel = null;
        pega.cti.API.currentAgentState = pega.cti.API.getMappingAgentState(data.User.state);
        extension = data.User.extension;
        // reasonCodeId (DBId) will be -1 on initial login or after a failover Get reason code - If '-1' - set it to 0
         reasonCode = data.User.reasonCodeId == -1 ? 0 : (data.User.reasonCode != undefined ) ? (data.User.reasonCode.code) : 0 ;
        if (data.User.reasonCode != undefined && data.User.reasonCode != null )
                 if (data.User.reasonCode.systemCode == "true")
              reasonCodeLabel = data.User.reasonCode.label;
          onSuccess(pega.cti.API.currentAgentState, reasonCode, extension,reasonCodeLabel);
      }, 
      onFailure
    );
  },
  
  /*** Private resubscribe funciton in case of XMPP disconnect ***/
  _resubscribe: function() {
          var _this = this;
          if (this.subscriptionRetryAttempts == null) this.subscriptionRetryAttempts = 4;
          if (this.subscriptionRetryIntervel==null) this.subscriptionRetryIntervel=1000;
          pega.cti.API.failoverManager.sendReconnectEvent();
          if (this.subscriptionRetryAttempts <= 0) {
                pega.cti.API.isConnAcquired = false;
                if (this.failoverManager.failoverEnabled) {
                    this.failoverManager.handlePresenceUnavailability(false);
                } else {
                    var deviceClosedSnapshot = _this._buildDeviceClosedSnapshot();
                    this.forwardEvent(deviceClosedSnapshot);
                    var errorEvent = this.buildPegaEvent('ErrorEvent');
                    errorEvent.pyErrorCode = 'OPENCTI_ERR_PASS';
                    errorEvent.pyErrorMessage = 'XMPP Disconnected. Resubscription failed.';
                     pega.cti.API.Logger.Error(  errObject.errMessage );
                    this.forwardEvent(JSON.stringify(errorEvent));
                }
          } else {
              this.subscriptionRetryAttempts--;
              setTimeout(function() {
                      _this.subscribe("CLOSED", function(Response) {
                          console.log("Resubscription request successful.")
                      }, function(Response) {
                          console.log("Resubscription request failed.");
                      })
                  },
                  _this.subscriptionRetryIntervel);
          }
      },


      /** Build Dummy device closed event **/
      _buildDeviceClosedSnapshot: function() {
          var snapshotEvent = this.getAgentSnapshotJson('Logout', null);
          var linesArray = [];
          for (var k = this.pyNumberOfLines; k > 0; k--) {
              var lineObject = new Object();
              lineObject.pyLineNumber = pega.cti.API.pyNumberOfLines - k + 1;
              lineObject.pyCallId = '0';
              lineObject.pyLineState = 'idle';
              linesArray.push(lineObject);
          }
          snapshotEvent = snapshotEvent.substring(0, snapshotEvent.length - 1) + ',"pyLines":' + JSON.stringify(linesArray) + "}";
          return snapshotEvent;
      },
  
getUserConfig: function(agentId, linkDefinition, onSuccess, onFailure) {
    var options = new Object();
    this.initialize(linkDefinition, options, onSuccess, onFailure);
    pega.cti.API.agentId = agentId;

    var intervalIntialize = setInterval(function() {
        if (pega.cti.API.pyLinkState) {
            clearInterval(intervalIntialize);
            pega.cti.API.sendRESTRequest('GET', null, pega.cti.API.hostURL + '/finesse/api/UserAuthMode/' + pega.cti.API.agentId, function(data) {
                var SSOLogin = new Object();
                SSOLogin.pyEventName = 'UserConfig';
                SSOLogin.pyMedia = "Phone";
                SSOLogin.pyEventType = 'UserConfig';
                SSOLogin.pyAuthMode = "NON_SSO";

                if (data.UserAuthMode != null) {
                    SSOLogin.pyAuthMode = data.UserAuthMode.authMode;
                }
                onSuccess(JSON.stringify(SSOLogin));
            }, onFailure);
        }
    }, 100);
}

}

//Failover Manager
pega.cti.desktopApi.Finesse.FailoverManager.prototype = {
  initialize: function(linkDefinition) {
    this.failoverReason = sessionStorage.getItem('FAILOVER_STATUS') === null ? '' : sessionStorage.getItem('FAILOVER_STATUS');
        this.failoverEnabled = (linkDefinition.pyFailoverHost === null || linkDefinition.pyFailoverHost == undefined  || linkDefinition.pyFailoverHost === '') ? false : true;
  },
  isSystemFailover: function() {
    if (this.failoverReason === 'SYSTEM_FAILOVER') return true;
    else return false;
  },
  isPresenceFailover: function() {
    if (this.failoverReason === 'PRESENCE_FAILOVER') return true;
    else return false;
  },
      isXMPPFailover: function() {
    if (this.failoverReason === 'XMPP_FAILOVER') return true;
    else return false;
  },
  
  failoverHandler: function(reason) {
    //Check if system is already in failover state before changing any flags
    if(this.failoverReason === '' || pega.cti.API.deploymentType === 'UCCX') {
      this.failoverReason = reason;
      sessionStorage.setItem('FAILOVER_STATUS', this.failoverReason);
      if (this.failoverReason === '') 
        return;
      else {
        pega.cti.API.systemStatus = 'OUT_OF_SERVICE';
        this.sendReconnectEvent();
      }
      //System will send a logout event for agent. Initate the failover process when logout event is received.
      if(this.isSystemFailover())
        this.agentLogoutReceived = false;
       
      //If presence unavailable event is received & failover enabled try to connect to failover link
      if (this.isPresenceFailover() && this.failoverEnabled)
        this.handlePresenceUnavailability();
      
       if (this.isXMPPFailover())
        this.handleXMPPDisconnected();
        
      
    } else if(this.failoverReason === 'SYSTEM_FAILOVER' && reason === 'PRESENCE_FAILOVER' && pega.cti.API.deploymentType !=='UCCX') {
      //System is currently in failover state & received presence failvoer. Wait for the system to back up
      //Since this is a system failover - Presence need to be re-established with the same system
       pega.cti.API.Logger.info('Waiting for system to back up before attempting reconnection')
       var sysStatus = setInterval(function() {
         if (pega.cti.API.systemStatus === 'IN_SERVICE') {
           clearInterval(sysStatus);
           //Presence lost -  we may not get agent logout
           this.agentLogoutReceived = true;
           pega.cti.API.failoverManager.reconnectAndSubscribe();
         }
       }, 1000);
    }
  },
  sendReconnectEvent: function() {
    pega.cti.API.pyLinkState = 'DISCONNECTED';
    //BUG-353892 - Create a global variable to request agent state change once system back to IN_SERVICE
    if (pega.cti.API.currentAgentState === 'Ready') setAgentReady = true;
    var snapshotEvent = pega.cti.API.getAgentSnapshotJson('Busy');
    pega.cti.API.forwardEvent(snapshotEvent);
  },
  
    
handleXMPPDisconnected: function() {
    var link = '';
    if (pega.cti.API.failoverManager.pollingSystem == null)
        if (pega.cti.API.isPrimaryActive) pega.cti.API.failoverManager.pollingSystem = "PRIMARY";
        else pega.cti.API.failoverManager.pollingSystem = "FAILOVER";
    //Get backup link based on current active link
    if (pega.cti.API.failoverManager.pollingSystem == "PRIMARY") {
        link = pega.cti.API.LinkDefinition.pyPrimaryHost;
    } else {
        link = pega.cti.API.LinkDefinition.pyFailoverHost;
    }
    pega.cti.API.failoverManager.pollSystemInformation(link, false);
},

  
  handlePresenceUnavailability: function(disconnectConnection) {
    var link = '';
    if (pega.cti.API.failoverManager.pollingSystem == null)
        if (pega.cti.API.isPrimaryActive) pega.cti.API.failoverManager.pollingSystem = "PRIMARY";
        else pega.cti.API.failoverManager.pollingSystem = "FAILOVER";
    
    //Get backup link based on current active link
    if (pega.cti.API.failoverManager.pollingSystem == "PRIMARY" && pega.cti.API.failoverManager.failoverEnabled ){
      pega.cti.API.failoverManager.pollingSystem = "FAILOVER";
      link = pega.cti.API.LinkDefinition.pyFailoverHost;
    } 
    else{
          pega.cti.API.failoverManager.pollingSystem = "PRIMARY";
      link = pega.cti.API.LinkDefinition.pyPrimaryHost;
    } 
    pega.cti.API.failoverManager.pollSystemInformation(link,disconnectConnection);
  },
  
  pollSystemInformation: function(link,disconnectConnection){
    pega.cti.API.getSystemInfo(link, function(status) { //Success call back
      if (status === 'IN_SERVICE') {
          pega.cti.API.systemStatus = status;
          pega.cti.API.pyLinkState = 'CONNECTED';
          if (  pega.cti.API.failoverManager.pollingSystem ==  "FAILOVER") {
              pega.cti.API.isPrimaryActive = false;
              
              pega.cti.API.BOSH_SERVICE = pega.cti.API.getSubfolder(pega.cti.API.getValueFromLinkDefinition('FAILOVER_BOSHURL'));
              pega.cti.API.hostURL = pega.cti.API.LinkDefinition.pyFailoverHost;
          } else {
              pega.cti.API.isPrimaryActive = true;
              
              pega.cti.API.BOSH_SERVICE = pega.cti.API.getSubfolder(pega.cti.API.getValueFromLinkDefinition('PRIMARY_BOSHURL'));
              pega.cti.API.hostURL = pega.cti.API.LinkDefinition.pyPrimaryHost;
          }
          sessionStorage.setItem('isPrimaryActive', pega.cti.API.isPrimaryActive);
        pega.cti.API.failoverManager.pollingSystem = null;
         if ( pega.cti.API.failoverManager.failoverReason == 'XMPP_FAILOVER')
                   pega.cti.API.failoverManager.failoverReason = null;
            pega.cti.API.failoverManager.reconnectAndSubscribe(disconnectConnection);
      } else { //Still out of service  - Retru after some delay
        setTimeout(function(){pega.cti.API.failoverManager.handlePresenceUnavailability(disconnectConnection)} ,pega.cti.API.failoverRetryInterval *1000);
      }
    }, function(message) { //Failure call back
      //Error while trying to connect to alternative server
      pega.cti.API.Logger.debug("failed to fallback to alternative node. Error: " + message);
        setTimeout(function(){pega.cti.API.failoverManager.handlePresenceUnavailability(disconnectConnection)} ,pega.cti.API.failoverRetryInterval *1000);
    });
  },
  
  
  reconnectAndSubscribe: function(disconnectConnection) {
    
    //Disconnect from current event stream
    if (disconnectConnection!=false)
        pega.cti.API.connection.disconnect('failover');  
    
    //Create new connection object & re-subscribe
    var intvFailover = setInterval(function() {
      if (pega.cti.API.connectionState === 'DISCONNECTED') {
        clearInterval(intvFailover);
		if (pega.cti.API.subscriptionStarted == false)       
	   {pega.cti.API.connection = new Strophe.Connection(pega.cti.API.BOSH_SERVICE, {'keepalive': true});
        pega.cti.API.subscribe("FAILOVER", function() {
           pega.cti.API.Logger.info('Failover recovery successful. Initialized agent on other node');
        }, function() {
           pega.cti.API.Logger.info('Failover recovery unsuccessful. Encountered error while initalizing agent on other node');
        });
        pega.cti.API.failoverManager.resetFailvoer();
      }}
    }, 100);
    
  },
  
  resetFailvoer: function() {
     this.failoverReason = '';
     sessionStorage.removeItem('FAILOVER_STATUS');
  }

}
//static-content-hash-trigger-GCC
$().ready( function() {
  pega.u.clientEvents.unsubscribe(pega.u.clientEvents.WS_ON_OPEN,websocketOpenEvent, "", null);
  pega.u.clientEvents.subscribe(pega.u.clientEvents.WS_ON_OPEN, websocketOpenEvent, "", null); /* Handle websocket open event */
});

function forwardWSEvent(oData) //event from Web-Sockets 
{
    var eventData = oData.detail.response.pyFormattedEvent;
    var eventType = oData.detail.response.pyEventType;
    pega.cti.API.forwardEvent(eventData);
}
pega.cti.desktopApi.PegaHttpRest = function() {
    this.heartbeatIntervalId = '';
    this.heartbeatHTTPFailures = 0;
    this.LinkDefinition = null;
    this.pyClientHandle = null;
    this.pySessionId = null;
    //Moving maxHeartbeatHTTPFailures initialization to login function to fix bug#425213
    this.maxHeartbeatHTTPFailures = 0;
  	this.sQuiesceActivationDelay = 5;
  	this.sStartActivationRequests = 0;
    this.name = "PegaHttpRest";
    this.implementationVersion="8.7";
    this.pyAgentID = null;
    this.pyThisDN = null;
    this.options = null;
    this.pyDeviceState = null;
        try{  
     pega.u.clientEvents.unsubscribe(pega.u.clientEvents.WS_ON_CLOSE, this.handleWebSocketClose, "", null);
     pega.u.clientEvents.subscribe(pega.u.clientEvents.WS_ON_CLOSE, this.handleWebSocketClose, "", null); /* Handle websocket close event */
      }
  catch(e){
    console.log("Failed to subscribe for websocket close event.");
  }
};
pega.cti.desktopApi.PegaHttpRest.prototype = {
    initialize: function(LinkDefinition,success, failure) {
      this.LinkDefinition = LinkDefinition;
        var responseObj;
        var request = new Object();
        request.RequestType = "SnapshotDevice";
        responseObj = this.SS_Request(request, null, success, failure);
        if (responseObj != null)
            if (responseObj.pyLoggingEnabled == "true") loggingMode = 'LOCAL';
            else loggingMode = 'NONE';
        return responseObj;
    },
    deviceSnapshot: function(success, failure) {
        var request = new Object();
        if(this.pySessionId===null || this.pySessionId===undefined){
          if(sessionStorage.getItem("pySessionId")!==null)
            this.pySessionId = sessionStorage.getItem("pySessionId");
        }
        request.RequestType = "SNAPSHOT";
        request.Destination = this.pyThisDN;
        request.CallId = ''
        var responseObj = this.snapshotRequest(request, pega.cti.API.options, success, failure);
        return responseObj;
    },
    /*
    @api - Log agent into the ACD.
    @param $String$agentId – The Agent's ACD ID
    @Param $String$agentPwd - The Agent's ACD Password
    @Param $String$agentPwd - The Agent's ACD Password
    @Param $String$extension - The Agent's ACD extension/Position
    @Param $String$linkName - The CTILink Name as configured
    @param $String$queue – The optional ACD queue
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
	@param $Function$forwardEvent – Callback function for forwarding asyncronus events from server
    */
    login: function(agentId, agentPwd, extension, linkDefinition, options, success, failure, forwardEvent) {
    this.pyAgentID = agentId;
    this.pyThisDN = extension;    
    this.LinkDefinition = linkDefinition;
    this.options = options;
        //BUG-425213 calculate retries based on timeout/interval and ceil the value
        this.maxHeartbeatHTTPFailures = Math.ceil(linkDefinition.pyHeartbeatTimeout/linkDefinition.pyHeartbeatInterval)*2; 
       //Create a local variable for sending async event from websocket
        this.forwardEvent = function(oData) {
            try {
                var oEvent = JSON.parse(oData);
                var sEventName = oEvent.pyEventName;
                if (typeof sEventName != 'undefined')
                    if (sEventName.toUpperCase() === "SNAPSHOT") {
                        this._handleHeartBeat(oData, forwardEvent);
                        return;
                    }
            } catch (e) {
                console.log('Error while parsing forward event ' + e.toString());
            }
            forwardEvent(oData);
        };
        if ((typeof options.pyDeviceState == "string" && options.pyDeviceState == "OPENED") || (options.pyAutoLogin ==='true' && (options.pyPegaCTIError=="" || options.pyPegaCTIError=="Good")) ) {
          var wait = setInterval(function() {
                     var webSocketSubscriber = $("div[node_name='PegaCallControlPanelWrapper'] div[node_name='WebSocketSubscriber'] div[data-subscription-id]");
                     var subscriptionId;
                     if(webSocketSubscriber != undefined){
                       subscriptionId = webSocketSubscriber.attr('data-subscription-id');
                       if(subscriptionId != null ||  subscriptionId != undefined) {
                        clearInterval(wait);
                        pega.cti.API.deviceSnapshot(success, failure);
                      }
                     }
                }, 200);  
        }
        else {
            var request = new Object();
            request.RequestType = "Login";
            request.AgentId = agentId;
            request.AgentPwd = agentPwd;
            request.Extension = extension;
            var response = this.LoginRequest(request, options, success, failure);
        }
    },
    /*
    @api - Log agent out of the ACD
    @param $String$agentId – The Agent's ID
    @param $String$queue – The optional ACD queue
    @param $String$reasonCode – The logout reason code
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    logout: function(agentId, reasonCode, options, success, failure) {
        var request = new Object();
        request.RequestType = "Logout";
        request.AgentId = agentId;
        request.ReasonCode = reasonCode;
        if (typeof options != 'undefined')
          request.Queue = options.queue;
        var response = this.agentRequest(request, options, success, failure);
    },
    /*
    @api - Make the agent ready at the ACD
    @param $String$agentId – The Agent's ID
    @param $String$queue – The optional ACD queue
    @param $String$workMode – The ready work mode
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    agentReady: function(agentId, workMode, options, success, failure) {
        var request = new Object();
        request.RequestType = "Ready";
        request.AgentId = agentId;
        request.WorkMode = workMode;
        if (typeof options != 'undefined')
          request.Queue = options.queue;
        var response = this.agentRequest(request, options, success, failure);
    },
    /*
    @api - Make the agent not ready at the ACD
    @param $String$agentId – The Agent's ID
    @param $String$queue – The optional ACD queue
    @param $String$workMode – The not ready work mode
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    agentNotReady: function(agentId, workMode, reasonCode, options, success, failure) {
        var request = new Object();
        request.RequestType = "Not_Ready";
        request.AgentId = agentId;
        request.ReasonCode = reasonCode;
        request.WorkMode = workMode;
        if (typeof options != 'undefined')
          request.Queue = options.queue;
        var response = this.agentRequest(request, options, success, failure);
    },
    /*
    @api - Send DTMF Tones
    @param $String$callId – The callId of the call to send tones to
    @param $String$digits – The String of tones to be sent
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    sendDTMF: function(callId, digits, options, success, failure) {
        var request = new Object();
        request.RequestType = "SendDTMF";
        request.CallId = callId;
        request.Digits = digits;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Place a new call
    @param $String$destination – The digits to dial
    @param $String$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    makeCall: function(destination, options, success, failure) {
        var request = new Object();
        request.CallOperation = "MAKECALL";
        request.DestinationAddress = destination;
        request.CallOptions = JSON.stringify(options);
        var response = this.callControlRequest(request, options, success, failure);
    },
    /*
    @api - Answer a ringing call
    @param $String$callId – The callId of the call answer
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    answerCall: function(callId, options, success, failure) {
        var request = new Object();
        request.CallOperation = "ANSWERCALL";
        request.CallId = callId;
        var response = this.callControlRequest (request, options, success, failure);
    },
    /*
    @api - Retrieve a held call
    @param $String$callId – The callId of the held call
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    retrieveCall: function(callId, options, success, failure) {
        var request = new Object();
        request.CallOperation = "RETRIEVECALL";
        request.CallId = callId;
        var response = this.callControlRequest(request, options, success, failure);
    },
    /*
    @api - Place a call on hold
    @param $String$callId – The Call Id of the call to place on hold
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    holdCall: function(callId, options, success, failure) {
        var request = new Object();
        request.CallOperation = "HOLDCALL";
        request.CallId = callId;
        var response = this.callControlRequest(request, options, success, failure);
    },
    /*
    @api - Hang up a call
    @param $String$callId – parameter description goes here
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    hangUpCall: function(callId, options, success, failure) {
        var request = new Object();
        request.CallOperation = "HANGUPCALL";
        request.CallId = callId;
        var response = this.callControlRequest(request, options, success, failure);
    },
    /*
    @api - Blind Transfer the call
    @param $String$callId – The Active Call Id
    @param $String$destination – The dialed digits of the destination party
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    blindTransfer: function(callId, destination, options, success, failure) {
        var request = new Object();
        request.RequestType = "BlindTransfer";
        request.CallId = callId;
        request.Destination = destination;
        var opts = new Object();
        opts.Options=JSON.stringify(options);
        var response = this.SS_Request(request, opts, success, failure);
    },
    /*
    @api - Initiate a (warm/attended) Transfer
    @param $String$callId – The Call Id of the call
    @param $String$destination – The dialed digits of the transfer destination
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    transferInitiate: function(callId, destination, options, success, failure) {
        var request = new Object();
        request.RequestType = "TransferInitiate";
        request.CallId = callId;
        request.Destination = destination;
        var opts = new Object();
        opts.Options=JSON.stringify(options);
        var response = this.SS_Request(request, opts, success, failure);
    },
    /*
    @api - Transfer the call
    @param $String$heldcallId – The Call Id of the held party
    @param $String$activecallId – The call Id of the active (consulted/destination) call
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    transferComplete: function(heldcallId, activecallId, options, success, failure) {
        var request = new Object();
        request.RequestType = "TransferComplete";
        request.CallId = activecallId;
        request.HeldCallId = heldcallId;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Place a consultation call
    @param $String$callId – The callId of the active call
    @param $String$destination – The dialed digits of the party to be consulted
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    consulationCall: function(callId, destination, options, success, failure) {
        var request = new Object();
        request.RequestType = "ConsultationCall";
        request.CallId = callId;
        request.Destination = destination;
        var opts = new Object();
        opts.Options=JSON.stringify(options);
        var response = this.SS_Request(request, opts, success, failure);
    },
    /*
    @api - Function description goes here
    @param $String$callId – The callId of the active call
    @param $String$destination – The dialed digits of the party to be conferenced
    @param $Oject$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    conferenceInitiate: function(callId, destination, options, success, failure) {
        var request = new Object();
        request.RequestType = "ConferenceInitiate";
        request.CallId = callId;
        request.Destination = destination;
        var opts = new Object();
        opts.Options=JSON.stringify(options);
        var response = this.SS_Request(request, opts, success, failure);
    },
    /*
    @api - Complete a conference
    @param $String$heldcallId – The Call Id of the held call
    @param $String$activecallId – The Call Id of the active call
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    conferenceComplete: function(heldcallId, activecallId, options, success, failure) {
        var request = new Object();
        request.Line = 2;
        request.RequestType = "ConferenceComplete";
        request.CallId = activecallId;
        request.HeldCallId = heldcallId;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Drop party from a Conference
    @param $String$callId – The callId of the call from which party is to be dropped
    @param $String$party – The party to be dropped
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    dropparty: function(callId, party, options, success, failure) {
        var request = new Object();
        request.RequestType = "Dropparty";
        request.CallId = callId;
        request.Party = party;
        var response = this.SS_Request(request, options, success, failure);
    },
	/*  
    @api - Complete a Alternate Call
    @param $String$heldcallId – The Call Id of the held call
    @param $String$activecallId – The Call Id of the active call
    @param $String$options – String format of JSON object of optional Parameters
    @param $Function$success – Callback function for success with message object
    @param $Function$failure – Callback function for failure with message object
    */
    alternateCall: function(heldcallId, activecallId, options, success, failure) {
        var request = new Object();
        request.CallOperation = "ALTERNATECALL";
        request.HeldCallId = heldcallId;
        request.ActiveCallId = activecallId;
        var response = this.callControlRequest(request, options, success, failure);
    },
  
    _handleQuiesceEvent: function(oEvent) {
       if ((oEvent.pyQuiesceActivationTime) && (oEvent.pyQuiesceActivationTime != null)) {
            this.sQuiesceActivationDelay = oEvent.pyQuiesceActivationTime * 1000;
            console.log('Quiesce activation timer set to :' + this.sQuiesceActivationDelay);
        }
        this.sStartActivationRequests = 1;      
        // Delay and then send a server request to start the activation process for the user.
        setTimeout(this._sendQuiesceRequest, this.sQuiesceActivationDelay);
      
    },
  
  	_sendQuiesceRequest: function() {
  		// Send a server request to start the activation process for the user. 
        var request = new Object();
        request.RequestType = "StartActivation";
      	console.log('Sending Quiesce Activation request - ' + pega.cti.API.sStartActivationRequests);
      	pega.cti.API.SS_Request(request, null, pega.cti.API._handleQuiesceActivationResponse, 
                        function(oResponse) { console.log("Error in StartActivation activity - " + oResponse.errMessage); } );
        
    },
  	_handleQuiesceActivationResponse: function(oResponse) {
       if (oResponse.pyActivationCompleted && oResponse.pyActivationCompleted == "false") {
         if (pega.cti.API.sStartActivationRequests < 10) {
           pega.cti.API.sStartActivationRequests = pega.cti.API.sStartActivationRequests +1;
           setTimeout(pega.cti.API._sendQuiesceRequest, pega.cti.API.sQuiesceActivationDelay);
         }
       }
    },
  
    _handleHeartBeat: function(oData, eventForwarder) {
        try {
            var oEvent = JSON.parse(oData);
          this.pyDeviceState =oEvent.pyDeviceState;
        } catch (e) {
            console.log('Error while parsing snapshot event ' + e.toString());
            return;
        }
        var bSetHeartbeatInterval = false;
        if ((oEvent.pyDeviceState) && (oEvent.pyDeviceState != null))
            if (oEvent.pyDeviceState == 'CLOSED' || oEvent.pyDeviceState == 'QUIESCED') {
                // pyDeviceState CLOSED means that we should handle user logout
                this._handleUserLogOut();
            }
        if (oEvent.pyLinkState == null || typeof(oEvent.pyLinkState) == 'undefined') oEvent.pyLinkState =
            'Connected';
        switch (oEvent.pyLinkState) {
            case 'CONNECTED':
            case 'Connected':
            case 'connected':
                if (oEvent.pyDeviceState != 'CLOSED' && oEvent.pyDeviceState != 'QUIESCED') {
                    if (this.heartbeatIntervalId === '') bSetHeartbeatInterval = true;
                    if (bSetHeartbeatInterval) {
                        var sHeartbeatInterval = oEvent.pyHeartbeatInterval;
                        var nHeartbeatInterval = 0;
                        if (sHeartbeatInterval) {
                            nHeartbeatInterval = parseInt(sHeartbeatInterval);
                            if ((nHeartbeatInterval > 0) && (this.heartbeatIntervalId === '')) {
                                this.heartbeatIntervalId = setInterval('pega.cti.API._heartbeat()',nHeartbeatInterval);
                                this._heartbeat();
                            }
                        }
                        sHeartbeatInterval = null;
                    }
                }
                break;
            case 'DISCONNECTED':
            case 'Disconnected':
            case 'disconnected':
                console.log('Disconnecting');
                if ((oEvent.pyDeviceState === 'CLOSED') && (this.heartbeatIntervalId !== '')) {
                     // Physical link is down, disable heart beat
                     // Don't disable if the middleware has gone down.  Device and session can still be valid. */
                     this._handleUserLogOut();
                }
        }
        eventForwarder(oData);
        //If QUEIESCED - Start polling
      	if(oEvent.pyDeviceState == 'QUIESCED')
        	this._handleQuiesceEvent(oEvent);
    },
    _handleUserLogOut: function() {
        console.log("[Heartbeat requests terminated]");
        clearInterval(this.heartbeatIntervalId);
        this.heartbeatIntervalId = '';
    },
   _heartbeatfailure : function(responseObj){
      responseObj.Error = true;
      responseObj.Message = responseObj.errMessage;
      pega.cti.API._handleHeartbeatResponse(responseObj);
    },
    _heartbeat: function(success,_heartbeatfailure)  {
        var request = new Object();
        request.RequestType = "Heartbeat";
        request.Destination = this.pyThisDN;
        request.CallId = ''
        var response = this.SS_Request(request, pega.cti.API.options, this._handleHeartbeatResponse, this._heartbeatfailure);
        return response;
    },
    _handleHeartbeatResponse: function(oEvent) {
        var oData;
        oData = JSON.stringify(oEvent);
        console.log('[Received Soft phone response event] ' + oData);
        try {
            if (oEvent.Error && oEvent.Error === true) {
                if ((oEvent.Message) && (!oEvent.pyHeartBeatStatus)) {
                        // If the heartbeat status is not on the event that means that it is an HTTP error 
                        // If there are a number of HTTP errors in a row then close the softphone
                        pega.cti.API.heartbeatHTTPFailures = pega.cti.API.heartbeatHTTPFailures + 1;
                        if (pega.cti.API.maxHeartbeatHTTPFailures <= pega.cti.API.heartbeatHTTPFailures) {
                            pega.cti.API._handleUserLogOut();
                       var _this = this;
                       pega.cpm.localization.getLocalizedValue("CPM-Portal", "pyMessageLabel", "Heartbeat terminated due to errors. If you are not logged out automatically, please log out of CTI.",
				           function (sMessage) {
				     	        showAlertNotification(sMessage);				
				    	        }, _this );
                          
                        }
                        return;
                    
                }
            }
            if ((oEvent.RequestType) && (oEvent.RequestType != '' && oEvent.RequestType === 'Heartbeat')) {
                if ((oEvent.pyHeartBeatStatus) && (oEvent.pyHeartBeatStatus == 'Terminate')) {
                    pega.cti.API._handleUserLogOut();
                } else {
                    pega.cti.API.heartbeatHTTPFailures = 0;
                }
            }
        } catch (e) {
            console.log('EXCEPTION Handling heartbeat response: ' + e + ' ' + oData);
        }
    },
    LoginRequest: function(request, options, Success, Failure){
         
        //XML data for request. Separated into lines for readability
        var data='<xml><AgentId>'+request.AgentId+'</AgentId><AgentPassword>'+request.AgentPwd+'</AgentPassword>';
        data = data + '<Endpoint>'+this.LinkDefinition.EndPoint.substr(0, this.LinkDefinition.EndPoint.indexOf('|'))+' ';
        data = data + this.LinkDefinition.EndPoint.substr(this.LinkDefinition.EndPoint.indexOf('|')+1)+'</Endpoint><DN>'+request.Extension+'</DN>';
        data = data + '<WorkstationID>'+window.location.origin.toUpperCase()+'/H-GET?ChannelName=PegaCALL|ChannelParam='+options.pyClientHandle;
        data = data + '</WorkstationID><NumberOfLines>'+options.pyNumberOfLines+'</NumberOfLines><AgentEvents>true</AgentEvents>';
        data = data + '<CallEvents>true</CallEvents></xml>';
        //End of XML data                                                       
                                                   
        request.url = this.LinkDefinition.pyPrimaryHost+'api/OpenCTI/PegaApi10/Subscribe/'+request.Extension;
        request.data = data;
        request.type = "POST";
        var responseObj = this.SS_Request(request,options,function(response){
             var responseText = response.responseText;
             var responseXML=XmlToJson($.parseXML(responseText));
             if(responseXML.SubscribeResponse!==undefined && responseXML.SubscribeResponse.SubscriptionId!==undefined && responseXML.SubscribeResponse.SubscriptionId!==''){
                response.pyPegaCTIError = 'Good';
                if(response.pyPegaCTIError !== "Good") {
                    response.errCode = 'OPENCTI_ERR_PASS';
                response.errMessage = response.pyPegaCTIError;
                Failure(response);
          } 
        else 
          {
           pega.cti.API.pyClientHandle = options.pyClientHandle;
           pega.cti.API.pyLinkState = "CONNECTED";
           pega.cti.API.pySessionId = responseXML.SubscribeResponse.SubscriptionId;
           sessionStorage.setItem("pySessionId",pega.cti.API.pySessionId);
           Success(response);
         }
       }
       if(responseXML.SubscribeResponse!==undefined && responseXML.SubscribeResponse.Status!==undefined && responseXML.SubscribeResponse.Status==="Fail"){
             response.pyPegaCTIError = 'Fail';
             response.errCode = 'OPENCTI_ERR_PASS';
             response.errMessage = responseXML.SubscribeResponse.Message;
             Failure(response);
          }
        },Failure);      
    },
    agentRequest: function(request, options, Success, Failure){
        
        //XML data for request. Separated into lines for readability
        var data='<xml><SubscriptionId>'+this.pySessionId+'</SubscriptionId><AgentState>'+request.RequestType.toUpperCase()+'</AgentState>';
        if(request.WorkMode!==undefined && request.WorkMode!=='')
          data = data+'<WorkMode>'+request.WorkMode+'</WorkMode>';
        if(request.ReasonCode!==undefined && request.ReasonCode!=='')
          data = data+'<ReasonCode>'+request.ReasonCode+'</ReasonCode>';
        data = data+'</xml>';
        //End of XML data
                                                               
        request.url = this.LinkDefinition.pyPrimaryHost+'api/OpenCTI/PegaApi10/Agent/'+request.AgentId+'/Device/'+this.pyThisDN;
        request.data = data;
        request.type = "POST";
        var responseObj = this.SS_Request(request,options,function(response){
          var responseText = response.responseText;
          var responseXML=XmlToJson($.parseXML(responseText));
          if(responseXML.RequestStatus!==undefined && responseXML.RequestStatus.Status!==undefined && responseXML.RequestStatus.Status==="Fail"){
             response.pyPegaCTIError = 'Fail';
             response.errCode = 'OPENCTI_ERR_PASS';
             response.errMessage = responseXML.RequestStatus.Message;
             Failure(response);
          }
          else{
            if(request.RequestType==="Logout"){
                request.url = pega.cti.API.LinkDefinition.pyPrimaryHost+'api/OpenCTI/PegaApi10/Subscribe/'+pega.cti.API.pyThisDN;
                request.url = request.url + '?SubscriptionId='+pega.cti.API.pySessionId;
                request.data = '';
                request.type = "DELETE";
                var responseObj = pega.cti.API.SS_Request(request,options,function(response){
                var responseText = response.responseText;
                var responseXML=XmlToJson($.parseXML(responseText));
                if(responseXML.SubscribeResponse!==undefined && responseXML.SubscribeResponse.Status!==undefined && responseXML.SubscribeResponse.Status==="Fail"){
                   response.pyPegaCTIError = 'Fail';
                   response.errCode = 'OPENCTI_ERR_PASS';
                   response.errMessage = responseXML.SubscribeResponse.Message;
                   Failure(response);
                  return;
                }
               else{
                pega.cti.API.pySessionId = null;
                pega.cti.API.pyDeviceState = "CLOSED";
                sessionStorage.clear();
               }
                },Failure);
            }  
              Success(response);
          }
        },Failure);  
    },
  

  
  callControlRequest:function(request, options, Success, Failure){
         var data='<xml><SubscriptionId>'+this.pySessionId+'</SubscriptionId>';

         for (property in request)
           data = data+'<'+property+'>'+request[property]+ '</'+property+'>';     
    
          data = data+'</xml>';
      
        console.log("Pay load for call state Request" +data);
        if(request.CallId == undefined) request.CallId=-1;
        request.url = this.LinkDefinition.pyPrimaryHost+'api/OpenCTI/PegaApi10/Device/'+this.pyThisDN+'/CallId/'+request.CallId ;
        request.data = data;
        request.type = "POST";
        var response = this.SS_Request(request,options,function(response){
               var responseText = response.responseText;
             var responseXML=XmlToJson($.parseXML(responseText));
             if(responseXML.RequestStatus!==undefined && responseXML.RequestStatus.Status =="Fail" ){
                response.pyPegaCTIError = responseXML.RequestStatus.pyPegaCTIError;
                response.errCode  = 'OPENCTI_ERR_PASS';
                response.errMessage = responseXML.RequestStatus.Message;
                Failure(response);
          } 
        },Failure);  
  },
  snapshotRequest: function(request, options, Success, Failure){
         var data='<xml><SubscriptionId>'+this.pySessionId+'</SubscriptionId><CallOperation>'+request.RequestType.toUpperCase()+'</CallOperation>';
          if (  request.Destination !==undefined && request.Destination!=='')
                 data = data+'<DestinationAddress>'+request.Destination+'</DestinationAddress>';
          data = data+'</xml>';
    
        request.url = this.LinkDefinition.pyPrimaryHost+'api/OpenCTI/PegaApi10/Device/'+this.pyThisDN+'/CallId/'+request.CallId ;
        request.data = data;
        request.type = "POST";
        var responseObj = this.SS_Request(request,options,function(response){
          var responseText = response.responseText;
          var responseXML=XmlToJson($.parseXML(responseText));
          if(responseXML.RequestStatus!==undefined && responseXML.RequestStatus.Status!==undefined && responseXML.RequestStatus.Status==="Fail"){
             response.pyPegaCTIError = 'Fail';
             response.errCode = 'OPENCTI_ERR_PASS';
             response.errMessage = responseXML.RequestStatus.Message;
             Failure(response);
             return;
          }
          Success(response);
        },Failure);  
  },
  
    SS_Request: function(requestObj, options, onRequestSuccess, onRequestFailure) {
      
      var responseObj = new Object();
      responseObj.Error = false;
      responseObj.RequestId = requestObj.RequestId;
      responseObj.RequestType = requestObj.RequestType;
      var request = new XMLHttpRequest();                                                                          
      request.open(requestObj.type,requestObj.url);
      request.setRequestHeader("Content-Type", "application/xml");
      try{
        request.send(requestObj.data);
      }
      catch(e){
        console.log('Error while sending event ' + e.toString());
      }
      request.onload = () => {
               try{
                if (request.status === 200) {
                      responseObj.pyPegaCTIError = 'Good';
                      responseObj.RequestId = requestObj.RequestId;
                      responseObj.RequestType = requestObj.RequestType;
                      responseObj.Error = false;
                      responseObj.responseText = request.responseText;
                      onRequestSuccess(responseObj);
                  } else {
                    responseObj.errCode = 'OPENCTI_ERR_PASS';
                    responseObj.errMessage = "HTTP Error: " + request.statusText;
                    responseObj.Error = true;
                    onRequestFailure(responseObj);
                }
             }
            catch (e) {
             console.log('Error while sending event ' + e.toString());
            }
            }
    },
    Addoptions: function(objUrl, options) {
        var key;
        var val;
        for (key in options) {
            val = options[key];
            if (key != "requestType")
                if (val != null) objUrl.put(key, val);
        }
    },
  handleWebSocketClose: function() {
    if (pega.cti.API.pyDeviceState != null &&  pega.cti.API.pyDeviceState  != 'CLOSED' && pega.cti.API.pyDeviceState != 'QUIESCED') {
        if (!window.navigator.onLine) {
            showAlertNotification("Subscription lost because of network disruption.");
        } else {
            // Build fake reconnecting snapshot event.
            var eventObj = new Object();
            eventObj.pyMedia = "Phone";
            eventObj.pyAgentID = pega.cti.API.pyAgentID;
            eventObj.pyThisDN = pega.cti.API.pyThisDN;
            eventObj.pyEventType = "SnapshotEvent";
            eventObj.pyEventTimeStamp = $.now();
            eventObj.pyEventName = 'Snapshot';
            eventObj.pyEventString = 'DeviceSnapshot';
            eventObj.pyLinkState = "DISCONNECTED";
            eventObj.pyDeviceState = 'RECONNECTING';
            eventObj.pyAgentState = 'Unknown';
            pega.cti.API.forwardEvent(JSON.stringify(eventObj));
        }
    }
  }
}

 function XmlToJson(xml) {
  // Create the return object
  var obj = {};
  if (xml.nodeType == 1) { // element
  	// do attributes
  	if (xml.attributes.length > 0) {
  	obj["@attributes"] = {};
  	  for (var j = 0; j < xml.attributes.length; j++) {
  	  	var attribute = xml.attributes.item(j);
  	  	obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
  	  }
  	}
  } else if (xml.nodeType == 3) { // text
  	obj = xml.nodeValue;
  }
  // do children
  // If just one text node inside
  if(xml.hasChildNodes() && xml.childNodes.length === 1 && xml.childNodes[0].nodeType === 3) {
    obj = xml.childNodes[0].nodeValue;
  }
  else if (xml.hasChildNodes()) {
	for(var i = 0; i < xml.childNodes.length; i++) {
	  var item = xml.childNodes.item(i);
	  var nodeName = item.nodeName;
	  if (typeof(obj[nodeName]) == "undefined") {
	  	obj[nodeName] = XmlToJson(item);
	  } else {
	  if (typeof(obj[nodeName].push) == "undefined") {
	    var old = obj[nodeName];
	    obj[nodeName] = [];
	    obj[nodeName].push(old);
	  }
	  obj[nodeName].push(XmlToJson(item));
	  }
	}
  }
  return obj;
}
function websocketOpenEvent(message) {
 try{ 
  console.log('Websocket opened. Message - ' + message);
   var wait = setInterval(function() {
                     var webSocketSubscriber = $("div[node_name='PegaCallControlPanelWrapper'] div[node_name='WebSocketSubscriber'] div[data-subscription-id]");
                     var subscriptionId;
                     if(webSocketSubscriber != undefined){
                       subscriptionId = webSocketSubscriber.attr('data-subscription-id');
                       if(subscriptionId != null ||  subscriptionId != undefined) {
                        clearInterval(wait);
                        if (pega.cti.API != null && pega.cti.API.name == 'PegaHttpRest') 
                        pega.cti.API.deviceSnapshot(onSuccess, onFailure);
                      }
                     }
                }, 200); 
 }catch(e){
   console.log("Websocket openevent :"+e.message);
 }

   }

//static-content-hash-trigger-GCC
$().ready( function() {
  pega.u.clientEvents.unsubscribe(pega.u.clientEvents.WS_ON_OPEN,websocketOpenEvent, "", null);
  pega.u.clientEvents.unsubscribe(pega.u.clientEvents.WS_ON_REOPEN,websocketOpenEvent, "", null);
  pega.u.clientEvents.subscribe(pega.u.clientEvents.WS_ON_OPEN, websocketOpenEvent, "", null); /* Handle websocket open event */
  pega.u.clientEvents.subscribe(pega.u.clientEvents.WS_ON_REOPEN, websocketOpenEvent, "", null); /* Handle websocket reopen event */
});

function forwardWSEvent(oData) //event from Web-Sockets 
{
    var eventData = oData.detail.response.pyFormattedEvent;
    var eventType = oData.detail.response.pyEventType;
    pega.cti.API.forwardEvent(eventData);
}
pega.cti.desktopApi.PegaHttp = function() {
    this.heartbeatIntervalId = '';
    this.heartbeatHTTPFailures = 0;
    //Moving maxHeartbeatHTTPFailures initialization to login function to fix bug#425213
    this.maxHeartbeatHTTPFailures = 0;
  	this.sQuiesceActivationDelay = 5;
  	this.sStartActivationRequests = 0;
    this.name = "PegaHttp";
    this.implementationVersion="8.4.1.10";
    this.pyAgentID = null;
    this.pyThisDN = null;
    this.pyDeviceState = null;
    this.resetSuccess = false;
      this.WSClose = false;
        try{  
  pega.u.clientEvents.unsubscribe(pega.u.clientEvents.WS_ON_CLOSE, this.handleWebSocketClose, "", null);
  pega.u.clientEvents.subscribe(pega.u.clientEvents.WS_ON_CLOSE, this.handleWebSocketClose, "", null); /* Handle websocket close event */
  pega.u.clientEvents.unsubscribe(pega.u.clientEvents.WS_ON_ERROR, this.handleWebSocketError, "", null);
  pega.u.clientEvents.subscribe(pega.u.clientEvents.WS_ON_ERROR, this.handleWebSocketError, "", null); /* Handle websocket error event */
      }
  catch(e){
    console.log("Failed to subscribe for websocket close event.");
  }
};
pega.cti.desktopApi.PegaHttp.prototype = {
    initialize: function(success, failure) {
        var responseObj;
        var request = new Object();
        request.RequestType = "Initialize";
        responseObj = this.SS_Request(request, null, success, failure);
        if (responseObj != null)
            if (responseObj.pyLoggingEnabled == "true") loggingMode = 'LOCAL';
            else loggingMode = 'NONE';
        return responseObj;
    },
    resetpage: function(success, failure) {
        var responseObj;
        var request = new Object();
        request.RequestType = "Reset";
        request.ActivityClass = "ChannelServices-Device-Phone-UI";
        responseObj = this.SS_Request(request, null, success, failure);
        return responseObj;
    },
    /*
    @api - Log agent into the ACD.
    @param $String$agentId – The Agent's ACD ID
    @Param $String$agentPwd - The Agent's ACD Password
    @Param $String$agentPwd - The Agent's ACD Password
    @Param $String$extension - The Agent's ACD extension/Position
    @Param $String$linkName - The CTILink Name as configured
    @param $String$queue – The optional ACD queue
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
	@param $Function$forwardEvent – Callback function for forwarding asyncronus events from server
    */
    login: function(agentId, agentPwd, extension, linkDefinition, options, success, failure, forwardEvent) {
    this.pyAgentID = agentId;
    this.pyThisDN = extension;    
        //BUG-425213 calculate retries based on timeout/interval and ceil the value
        this.maxHeartbeatHTTPFailures = Math.ceil(linkDefinition.pyHeartbeatTimeout/linkDefinition.pyHeartbeatInterval)*2; 
       //Create a local variable for sending async event from websocket
        this.forwardEvent = function(oData) {
            try {
                var oEvent = JSON.parse(oData);
                var sEventName = oEvent.pyEventName;
                if (typeof sEventName != 'undefined')
                    if (sEventName.toUpperCase() === "SNAPSHOT") {
                        this._handleHeartBeat(oData, forwardEvent);
                        return;
                    }
            } catch (e) {
                console.log('Error while parsing forward event ' + e.toString());
            }
            forwardEvent(oData);
        };
        if ((typeof options.pyDeviceState == "string" && options.pyDeviceState == "OPENED") || (options.pyAutoLogin ==='true' && (options.pyPegaCTIError=="" || options.pyPegaCTIError=="Good")) ) {
          var wait = setInterval(function() {
                     var webSocketSubscriber = $("div[node_name='PegaCallControlPanelWrapper'] div[node_name='WebSocketSubscriber'] div[data-subscription-id]");
                     var subscriptionId;
                     if(webSocketSubscriber != undefined){
                       subscriptionId = webSocketSubscriber.attr('data-subscription-id');
                       if((subscriptionId != null ||  subscriptionId != undefined) && pega.cti.API.resetSuccess) {
                        pega.cti.API.resetSuccess = false;
                        clearInterval(wait);
                        this.resetpage(success, failure);
                      }
                     }
                }, 200);  
        }
        else {
            var request = new Object();
            request.RequestType = "LoginDirect";
            request.AgentId = agentId;
            request.AgentPwd = agentPwd;
            request.Extension = extension;
            var response = this.SS_Request(request, options, success, failure);
        }
    },
    /*
    @api - Log agent out of the ACD
    @param $String$agentId – The Agent's ID
    @param $String$queue – The optional ACD queue
    @param $String$reasonCode – The logout reason code
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    logout: function(agentId, reasonCode, options, success, failure) {
        var request = new Object();
        request.RequestType = "Logout";
        request.AgentId = agentId;
        request.ReasonCode = reasonCode;
        if (typeof options != 'undefined')
          request.Queue = options.queue;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Make the agent ready at the ACD
    @param $String$agentId – The Agent's ID
    @param $String$queue – The optional ACD queue
    @param $String$workMode – The ready work mode
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    agentReady: function(agentId, workMode, options, success, failure) {
        var request = new Object();
        request.RequestType = "Ready";
        request.AgentId = agentId;
        request.WorkMode = workMode;
        if (typeof options != 'undefined')
          request.Queue = options.queue;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Make the agent not ready at the ACD
    @param $String$agentId – The Agent's ID
    @param $String$queue – The optional ACD queue
    @param $String$workMode – The not ready work mode
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    agentNotReady: function(agentId, workMode, reasonCode, options, success, failure) {
        var request = new Object();
        request.RequestType = "NotReady";
        request.AgentId = agentId;
        request.ReasonCode = reasonCode;
        request.WorkMode = workMode;
        if (typeof options != 'undefined')
          request.Queue = options.queue;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Send DTMF Tones
    @param $String$callId – The callId of the call to send tones to
    @param $String$digits – The String of tones to be sent
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    sendDTMF: function(callId, digits, options, success, failure) {
        var request = new Object();
        request.RequestType = "SendDTMF";
        request.CallId = callId;
        request.Digits = digits;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Place a new call
    @param $String$destination – The digits to dial
    @param $String$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    makeCall: function(destination, options, success, failure) {
        var request = new Object();
        request.RequestType = "MakeCall";
        request.Destination = destination;
        var opts = new Object();
        opts.Options=JSON.stringify(options);
        var response = this.SS_Request(request, opts, success, failure);
    },
    /*
    @api - Answer a ringing call
    @param $String$callId – The callId of the call answer
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    answerCall: function(callId, options, success, failure) {
        var request = new Object();
        request.RequestType = "AnswerCall";
        request.CallId = callId;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Retrieve a held call
    @param $String$callId – The callId of the held call
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    retrieveCall: function(callId, options, success, failure) {
        var request = new Object();
        request.RequestType = "RetrieveCall";
        request.CallId = callId;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Place a call on hold
    @param $String$callId – The Call Id of the call to place on hold
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    holdCall: function(callId, options, success, failure) {
        var request = new Object();
        request.RequestType = "HoldCall";
        request.CallId = callId;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Hang up a call
    @param $String$callId – parameter description goes here
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    hangUpCall: function(callId, options, success, failure) {
        var request = new Object();
        request.RequestType = "HangUpCall";
        request.CallId = callId;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Blind Transfer the call
    @param $String$callId – The Active Call Id
    @param $String$destination – The dialed digits of the destination party
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    blindTransfer: function(callId, destination, options, success, failure) {
        var request = new Object();
        request.RequestType = "BlindTransfer";
        request.CallId = callId;
        request.Destination = destination;
        var opts = new Object();
        opts.Options=JSON.stringify(options);
        var response = this.SS_Request(request, opts, success, failure);
    },
    /*
    @api - Initiate a (warm/attended) Transfer
    @param $String$callId – The Call Id of the call
    @param $String$destination – The dialed digits of the transfer destination
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    transferInitiate: function(callId, destination, options, success, failure) {
        var request = new Object();
        request.RequestType = "TransferInitiate";
        request.CallId = callId;
        request.Destination = destination;
        var opts = new Object();
        opts.Options=JSON.stringify(options);
        var response = this.SS_Request(request, opts, success, failure);
    },
    /*
    @api - Transfer the call
    @param $String$heldcallId – The Call Id of the held party
    @param $String$activecallId – The call Id of the active (consulted/destination) call
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    transferComplete: function(heldcallId, activecallId, options, success, failure) {
        var request = new Object();
        request.RequestType = "TransferComplete";
        request.CallId = activecallId;
        request.HeldCallId = heldcallId;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Place a consultation call
    @param $String$callId – The callId of the active call
    @param $String$destination – The dialed digits of the party to be consulted
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    consulationCall: function(callId, destination, options, success, failure) {
        var request = new Object();
        request.RequestType = "ConsultationCall";
        request.CallId = callId;
        request.Destination = destination;
        var opts = new Object();
        opts.Options=JSON.stringify(options);
        var response = this.SS_Request(request, opts, success, failure);
    },
    /*
    @api - Function description goes here
    @param $String$callId – The callId of the active call
    @param $String$destination – The dialed digits of the party to be conferenced
    @param $Oject$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    conferenceInitiate: function(callId, destination, options, success, failure) {
        var request = new Object();
        request.RequestType = "ConferenceInitiate";
        request.CallId = callId;
        request.Destination = destination;
        var opts = new Object();
        opts.Options=JSON.stringify(options);
        var response = this.SS_Request(request, opts, success, failure);
    },
    /*
    @api - Complete a conference
    @param $String$heldcallId – The Call Id of the held call
    @param $String$activecallId – The Call Id of the active call
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    conferenceComplete: function(heldcallId, activecallId, options, success, failure) {
        var request = new Object();
        request.Line = 2;
        request.RequestType = "ConferenceComplete";
        request.CallId = activecallId;
        request.HeldCallId = heldcallId;
        var response = this.SS_Request(request, options, success, failure);
    },
    /*
    @api - Drop party from a Conference
    @param $String$callId – The callId of the call from which party is to be dropped
    @param $String$party – The party to be dropped
    @param $Object$options – Array of Optional Parameters
    @param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
    */
    dropparty: function(callId, party, options, success, failure) {
        var request = new Object();
        request.RequestType = "Dropparty";
        request.CallId = callId;
        request.Party = party;
        var response = this.SS_Request(request, options, success, failure);
    },
	/*  
    @api - Complete a Alternate Call
    @param $String$heldcallId – The Call Id of the held call
    @param $String$activecallId – The Call Id of the active call
    @param $String$options – String format of JSON object of optional Parameters
    @param $Function$success – Callback function for success with message object
    @param $Function$failure – Callback function for failure with message object
    */
    alternateCall: function(heldcallId, activecallId, options, success, failure) {
        var request = new Object();
        request.RequestType = "AlternateCall";
        request.HeldCallId = heldcallId;
        request.ActiveCallId = activecallId;
        var response = this.SS_Request(request, options, success, failure);
    },
  
    _handleQuiesceEvent: function(oEvent) {
       if ((oEvent.pyQuiesceActivationTime) && (oEvent.pyQuiesceActivationTime != null)) {
            this.sQuiesceActivationDelay = oEvent.pyQuiesceActivationTime * 1000;
            console.log('Quiesce activation timer set to :' + this.sQuiesceActivationDelay);
        }
        this.sStartActivationRequests = 1;      
        // Delay and then send a server request to start the activation process for the user.
        setTimeout(this._sendQuiesceRequest, this.sQuiesceActivationDelay);
      
    },
  
  	_sendQuiesceRequest: function() {
  		// Send a server request to start the activation process for the user. 
        var request = new Object();
        request.RequestType = "StartActivation";
      	console.log('Sending Quiesce Activation request - ' + pega.cti.API.sStartActivationRequests);
      	pega.cti.API.SS_Request(request, null, pega.cti.API._handleQuiesceActivationResponse, 
                        function(oResponse) { console.log("Error in StartActivation activity - " + oResponse.errMessage); } );
        
    },
  	_handleQuiesceActivationResponse: function(oResponse) {
       if (oResponse.pyActivationCompleted && oResponse.pyActivationCompleted == "false") {
         if (pega.cti.API.sStartActivationRequests < 10) {
           pega.cti.API.sStartActivationRequests = pega.cti.API.sStartActivationRequests +1;
           setTimeout(pega.cti.API._sendQuiesceRequest, pega.cti.API.sQuiesceActivationDelay);
         }
       }
    },
  
    _handleHeartBeat: function(oData, eventForwarder) {
        try {
            var oEvent = JSON.parse(oData);
          this.pyDeviceState =oEvent.pyDeviceState;
        } catch (e) {
            console.log('Error while parsing snapshot event ' + e.toString());
            return;
        }
        var bSetHeartbeatInterval = false;
        if ((oEvent.pyDeviceState) && (oEvent.pyDeviceState != null))
            if (oEvent.pyDeviceState == 'CLOSED' || oEvent.pyDeviceState == 'QUIESCED') {
                // pyDeviceState CLOSED means that we should handle user logout
                this._handleUserLogOut();
            }
        if (oEvent.pyLinkState == null || typeof(oEvent.pyLinkState) == 'undefined') oEvent.pyLinkState =
            'Connected';
        switch (oEvent.pyLinkState) {
            case 'CONNECTED':
            case 'Connected':
            case 'connected':
                if (oEvent.pyDeviceState != 'CLOSED' && oEvent.pyDeviceState != 'QUIESCED') {
                    if (this.heartbeatIntervalId === '') bSetHeartbeatInterval = true;
                    if (bSetHeartbeatInterval) {
                        var sHeartbeatInterval = oEvent.pyHeartbeatInterval;
                        var nHeartbeatInterval = 0;
                        if (sHeartbeatInterval) {
                            nHeartbeatInterval = parseInt(sHeartbeatInterval);
                            if ((nHeartbeatInterval > 0) && (this.heartbeatIntervalId === '')) {
                                this.heartbeatIntervalId = setInterval('pega.cti.API._heartbeat()',nHeartbeatInterval);
                                this._heartbeat();
                            }
                        }
                        sHeartbeatInterval = null;
                    }
                }
                break;
            case 'DISCONNECTED':
            case 'Disconnected':
            case 'disconnected':
                console.log('Disconnecting');
                if ((oEvent.pyDeviceState === 'CLOSED') && (this.heartbeatIntervalId !== '')) {
                     // Physical link is down, disable heart beat
                     // Don't disable if the middleware has gone down.  Device and session can still be valid. */
                     this._handleUserLogOut();
                }
        }
        eventForwarder(oData);
        //If QUEIESCED - Start polling
      	if(oEvent.pyDeviceState == 'QUIESCED')
        	this._handleQuiesceEvent(oEvent);
    },
    _handleUserLogOut: function() {
        console.log("[Heartbeat requests terminated]");
        clearInterval(this.heartbeatIntervalId);
        this.heartbeatIntervalId = '';
    },
   _heartbeatfailure : function(responseObj){
      responseObj.Error = true;
      responseObj.Message = responseObj.errMessage;
      pega.cti.API._handleHeartbeatResponse(responseObj);
    },
    _heartbeat: function(success,_heartbeatfailure)  {
        var request = new Object();
        request.RequestType = "Heartbeat";
        var response = this.SS_Request(request, null, this._handleHeartbeatResponse, this._heartbeatfailure);
        return response
    },
    _handleHeartbeatResponse: function(oEvent) {
        var oData;
        oData = JSON.stringify(oEvent);
        console.log('[Received Soft phone response event] ' + oData);
        try {
            if (oEvent.Error && oEvent.Error === true) {
                if ((oEvent.Message) && (!oEvent.pyHeartBeatStatus)) {
                        // If the heartbeat status is not on the event that means that it is an HTTP error 
                        // If there are a number of HTTP errors in a row then close the softphone
                        pega.cti.API.heartbeatHTTPFailures = pega.cti.API.heartbeatHTTPFailures + 1;
                        if (pega.cti.API.maxHeartbeatHTTPFailures <= pega.cti.API.heartbeatHTTPFailures) {
                            pega.cti.API._handleUserLogOut();
                       var _this = this;
                       pega.cpm.localization.getLocalizedValue("CPM-Portal", "pyMessageLabel", "Heartbeat terminated due to errors. If you are not logged out automatically, please log out of CTI.",
				           function (sMessage) {
				     	        showAlertNotification(sMessage);				
				    	        }, _this );
                          
                        }
                        return;
                    
                }
            }
            if ((oEvent.RequestType) && (oEvent.RequestType != '' && oEvent.RequestType === 'Heartbeat')) {
                if ((oEvent.pyHeartBeatStatus) && (oEvent.pyHeartBeatStatus == 'Terminate')) {
                    pega.cti.API._handleUserLogOut();
                } else {
                    pega.cti.API.heartbeatHTTPFailures = 0;
                }
            }
        } catch (e) {
            console.log('EXCEPTION Handling heartbeat response: ' + e + ' ' + oData);
        }
    },
    SS_Request: function(requestObj, options, onRequestSuccess, onRequestFailure) {
    
        var responseObj = new Object();
       var postData = new SafeURL();
      var activityUrl=new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
       activityUrl.put("pzPrimaryPageName", "CTIPhone");
        postData.put("RequestType", requestObj.RequestType);
        if(requestObj.ActivityClass!==undefined && requestObj.ActivityClass!=="")
          postData.put("ActivityClass",requestObj.ActivityClass);
        else
          postData.put("ActivityClass","ChannelServices-Device-Phone-UI");
            //var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI." + requestObj.RequestType);
       // activityUrl.put("pzPrimaryPageName", "CTIPhone");
        this.Addoptions(activityUrl, requestObj);
        this.Addoptions(activityUrl, options);
        responseObj.Error = false;
        responseObj.RequestId = requestObj.RequestId;
        responseObj.RequestType = requestObj.RequestType;
        pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
            success: function(oResponse) {
              var request = oResponse;
              console.log(request);
                var statusMessage = request.responseText;
                if (request.status == 200) {
                    var response = request.responseText;
                    try {
                        responseObj = JSON.parse(response);
                        responseObj.RequestId = requestObj.RequestId;
                        responseObj.RequestType = requestObj.RequestType;
                        responseObj.Error = false;
                        if (responseObj.pyPegaCTIError != "Good") {
                            responseObj.errCode = 'OPENCTI_ERR_PASS';
                            responseObj.errMessage = responseObj.pyPegaCTIError;
                            onRequestFailure(responseObj);
                        } else onRequestSuccess(responseObj);
                    } catch (e) {
                        console.log('Error while parsing async response event ' + e.toString());
                    }
                } else {
                    responseObj.errCode = 'OPENCTI_ERR_PASS';
                    responseObj.errMessage = "HTTP Error: " + request.statusText;
                    onRequestFailure(responseObj);
                }
            },
            failure: function(oResponse) {
                responseObj.errCode = 'OPENCTI_ERR_PASS';
                responseObj.errMessage = "HTTP Error: " + oResponse.statusText;
                onRequestFailure(responseObj);
            },
            scope: this
        }, postData);
        return responseObj;
    },
    Addoptions: function(objUrl, options) {
        var key;
        var val;
        for (key in options) {
            val = options[key];
            if (key != "requestType")
                if (val != null) objUrl.put(key, val);
        }
    },
handleWebSocketClose: function() {
   if ( pega.cti.API.WSClose == true) return ;
  pega.cti.API.WSClose = true;
    if (pega.cti.API.pyDeviceState != null &&  pega.cti.API.pyDeviceState  != 'CLOSED' && pega.cti.API.pyDeviceState != 'QUIESCED') {
        showAlertNotification(pega.cti.WSCloseMsg );
        if (window.navigator.onLine) {
            // Build fake reconnecting snapshot event.
            var eventObj = new Object();
            eventObj.pyMedia = "Phone";
            eventObj.pyAgentID = pega.cti.API.pyAgentID;
            eventObj.pyThisDN = pega.cti.API.pyThisDN;
            eventObj.pyEventType = "SnapshotEvent";
            eventObj.pyEventTimeStamp = $.now();
            eventObj.pyEventName = 'Snapshot';
            eventObj.pyEventString = 'DeviceSnapshot';
            eventObj.pyLinkState = "DISCONNECTED";
            eventObj.pyDeviceState = 'Unknown';
            eventObj.pyAgentState = 'Unknown';
            eventObj.pyErrorMessage   = pega.cti.WSCloseMsg;
            pega.cti.API.forwardEvent(JSON.stringify(eventObj));
        }
    }
},
  
handleWebSocketError: function() {
    if (pega.cti.API.heartbeatIntervalId != '' && pega.cti.API.maxHeartbeatHTTPFailures > pega.cti.API.heartbeatHTTPFailures && typeof pega.u.MessagingManager.forceReconnect == 'function' )
        pega.u.MessagingManager.forceReconnect();
    else {
        if (pega.cti.API.pyDeviceState != null && pega.cti.API.pyDeviceState != 'CLOSED' && pega.cti.API.pyDeviceState != 'QUIESCED') {
            showAlertNotification(pega.cti.WSErrorMsg);
        }
    }
}
  
}

function websocketOpenEvent(message) {
 try{ 
    if (pega.cti.API != null && pega.cti.API.name == 'PegaHttp') 
     pega.cti.API.WSClose = false;
  console.log('Websocket opened. Message - ' + message);
   var wait = setInterval(function() {
                     var webSocketSubscriber = $("div[node_name='PegaCallControlPanelWrapper'] div[node_name='WebSocketSubscriber'] div[data-subscription-id]");
                     var subscriptionId;
                     if(webSocketSubscriber != undefined){
                       subscriptionId = webSocketSubscriber.attr('data-subscription-id');
                       if(subscriptionId != null ||  subscriptionId != undefined) {
                        clearInterval(wait);
                        if (pega.cti.API != null && pega.cti.API.name == 'PegaHttp') 
                        pega.cti.API.resetpage(function (){
                          try{
                          onSuccess();
                          }catch(e){}
                          pega.cti.API.resetSuccess = true;
                        }, onFailure);
                      }
                     }
                }, 200); 
 }catch(e){
   console.log("Websocket openevent :"+e.message);
 }

   }

//static-content-hash-trigger-GCC
/****************************************************************************************
*
* Communicate with embedded AWS Connect client.
*
****************************************************************************************/
/*
@public - Prototype definition for pega.cti.desktopApi.AWSConnect
*/
function showhtml(str)
{
   if (str.indexOf("<html") > -1){
                        var myWindow = window.open('','','width=700,height=600');
                             var doc = myWindow.document;
                             doc.open();
                             doc.write(str); 
                             return true;
          } 
  else{
      return false;
      }
}

pega.cti.desktopApi.AWSConnect = function() {
  this.ccpUrl = null;
  this.eventCallback = null;
  // Added lastCallState to fix BUG-425647
  this.lastCallState = null;
}



pega.cti.desktopApi.AWSConnect.prototype = {
  
/*
@api - Initalize the object from link definition
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	initialize: function () {
    
	},

/*
@api - Log agent into the ACD.
@param $String$agentId – The Agent's ACD ID.
@Param $String$agentPwd - The Agent's ACD Password
@Param $String$agentPwd - The Agent's ACD Password
@Param $String$extension - The Agent's ACD extension/Position
@Param $String$linkDefinition - The CTILink definition as configured
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
@param $Function$forwardEvent – Callback function for forwarding asyncronus events from server

*/
	login: function(agentId, agentPwd, extension, linkDefinition, options, onSuccess, onFailure, forwardEvent) {
   
    this.LinkDefinition = linkDefinition;
    this.ccpUrl = linkDefinition.contactCenterInstanceURL;
    this.eventCallback = forwardEvent;
    var ccp = document.getElementById('CCPDiv');
      if(ccp)
      {
        loadAWSConnect(this.ccpUrl, options,onSuccess, onFailure); 
      } else
        {
        setTimeout(function(){loadAWSConnect(linkDefinition.contactCenterInstanceURL, options,onSuccess, onFailure);}, 500);
        }
       
	},
 
    
 

/*
@api - Log agent out of the ACD.
@param $String$agentId – The Agent's ID
@param $String$reasonCode – The logout reason code
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	logout: function (agentId,reasonCode, options,onSuccess,onFailure) {

      var width = 500;
      var height = 600;
      var left = (screen.width / 2) - (width / 2);
      var top = (screen.height / 2) - (height / 2);
      connect.core.getEventBus().unsubscribeAll();
      connect.core.terminate();
      var logoutWindow = window.open(this.ccpUrl+"/logout", true, "width=" + width + ",height=" + height + ",menubar=no,status=no,toolbar=no,left=" + left + ",top=" + top);
      logoutWindow.close();
      this._sendSnapshot(options,"CLOSED", "CLOSED");
      onSuccess();
	},



/*
@api - Make the agent ready at the ACD
@param $String$agentId – The Agent's ID
@param $String$workMode – The ready work mode
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	agentReady : function (agentId, workMode, options,onSuccess,onFailure)  {

   var availableState = theAgent.getAgentStates().filter(function (state) {
            return state.type === connect.AgentStateType.ROUTABLE;
    })[0];
    theAgent.setState(availableState, {
      success: function () {
        console.log("Set agent status to Available via Streams")
        onSuccess();
      },
      failure: function (err, data) {
        showhtml(err);
        var errObj = JSON.parse(err);
        console.log("Failed to set agent to available : " + errObj.message);
        onFailure({errCode:"ERR_PASS", errMessage:errObj.message});
      }
    });
    
	},

/*
@api - Make the agent not ready at the ACD
@param $String$agentId – The Agent's ID
@param $String$workMode – The not ready work mode
@param $String$reasonCode – The logout reason code
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	agentNotReady: function (agentId,workMode,reasonCode, options,onSuccess,onFailure) {

    
    var offlineState = theAgent.getAgentStates().filter(function (state) {
            console.log("this is state: " + state);
            return state.type === connect.AgentStateType.OFFLINE;
    })[0];
    theAgent.setState(offlineState, {
      success: function () {
        console.log("Set agent status to Offline via Streams");
        onSuccess();
      },
      failure: function (err, data) {
        showhtml(err); 
        var errObj = JSON.parse(err);
        console.log("Failed to set agent to unavailable : " + errObj.message);
        onFailure({errCode:"ERR_PASS", errMessage:errObj.message});
       }
    });
	},


/*
@api - Send DTMF Tones
@param $String$callId – The callId of the call to send tones to
@param $String$Digits – The String of tones to be sent
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	sendDTMF: function (callId, digits, options,success,failure)  {
    
    var theContact = findContact(callId);
    var conn = theContact.getAgentConnection(); 
    conn.sendDigits(digits, {
       success: function() {
         onSuccess();
       },
       failure: function(err, data) {
        showhtml(err); 
         var errObj = JSON.parse(err);
         onFailure({errCode:"ERR_PASS", errMessage:errObj.message});
       }
    });


	},



/*
@api - Place a new call
@param $String$destination – The digits to dial
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	makeCall:function (destination, options,onSuccess,onFailure)  {

    var endpoint = connect.Endpoint.byPhoneNumber(destination);
    theAgent.connect(endpoint, {
        queueARN: theAgent.getConfiguration().routingProfile.defaultOutboundQueue.queueARN,
        success: function () {
          console.log('makeCall SUCCESS');
          onSuccess();
        },
        failure: function (err, data) {
          showhtml(err);
          var errObj = JSON.parse(err);
          console.log("Failed to make call : " + errObj.message);
          onFailure({errCode:"ERR_PASS", errMessage:errObj.message});    
        }
    });   
      
	},


/*
@api - Answer a ringing call
@param $String$callId – The callId of the call answer
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	answerCall: function (callId, options,onSuccess, onFailure) {

      var theContact = findContact(callId);
      if (theContact) {
        theContact.accept({
           success: function() {
             console.log("answered call " + callId);
             onSuccess();
           },
           failure: function(err, data) {
            showhtml(err);
             var errObj = JSON.parse(err);
             console.log("Failed to answer call : " + errObj.message);
             onFailure({errCode:"ERR_PASS", errMessage:errObj.message});

           }
        });
      }
      else
        onFailure({errCode:"ERR_PASS", errMessage:"Unable to locate contact for ringing call"});   
   },



/*
@api - Retrieve a held call
@param $String$callId – The callId of the held call
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	retrieveCall: function (callId, options,onSuccess,onFailure)  {

    var theContact = findContact(callId);
    var conn = theContact.getAgentConnection();  
    if (conn) {
      conn.resume({
        success: function () {
          console.log("Retrieve Call succeeded");
          onSucess();
        },
        failure: function (err, data) {
          showhtml(err);
          var errObj = JSON.parse(err);
          console.log("Failed to retrieve call : " + errObj.message);
          onFailure({errCode:"ERR_PASS", errMessage:errObj.message});
        }
      });
    }
    else
        onFailure({errCode:"ERR_PASS", errMessage:"Unable to locate contact to retrieve call"});   
      
	},


/*
@api - Place a call on hold
@param $String$callId – The Call Id of the call to place on hold
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
 	holdCall: function (callId, options,onSuccess,onFailure)  {
 
    var theContact = findContact(callId);
    var conn = theContact.getActiveInitialConnection();  
    if (conn) {
      conn.hold({
        success: function () {
          console.log("Hold Call succeeded");
          onSuccess();
        },
        failure: function (err, data) {
         showhtml(err);
          var errObj = JSON.parse(err);
          console.log("Failed to hold call : " + errObj.message);
          onFailure({errCode:"ERR_PASS", errMessage:errObj.message});
        }
      });
    }
    else
      onFailure({errCode:"ERR_PASS", errMessage:"Unable to locate contact to hold call"});   
    
  },

/*
@api - Hang up a call
@param $String$callId – parameter description goes here
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	hangUpCall: function (callId, options,onSuccess,onFailure)  {

      var theContact = findContact(callId);
      var theConnection = theContact.getAgentConnection();
      if (theConnection) {
        theConnection.destroy({
          success: function() {
            console.log("ended call " + callId); 
            onSuccess()
          },
          failure: function(err, data) {
            showhtml(err);
            var errObj = JSON.parse(err);
            console.log("Failed to hangup call : " + errObj.message);
            onFailure({errCode:"ERR_PASS", errMessage:errObj.message});
          }
        });
      }
      else
        onFailure({errCode:"ERR_PASS", errMessage:"Unable to locate contact to hangup call"});   
	},


/*
@api - Blind Transfer the call
@param $String$callId – The Active Call Id
@param $String$destination – The dialed digits of the destination party
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	blindTransfer: function (callId, destination, options,onSuccess,onFailure)  {
  
    onFailure({errCode:"ERR_PASS", errMessage:"blindTransfer not implemented"});   

	},


/*
@api - Initiate a (warm/attended) Transfer
@param $String$callId – The Call Id of the call
@param $String$destination – The dialed digits of the transfer destination
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	transferInitiate: function (callId, destination, options, onSuccess, onFailure) {
  
    onFailure({errCode:"ERR_PASS", errMessage:"transferInitiate not implemented"});   

	},

/*
@api - Transfer the call
@param $String$heldcallId – The Call Id of the held party
@param $String$activecallId – The call Id of the active (consulted/destination) call
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	transferComplete: function (heldcallId, activecallId, options, onSuccess, onFailure) {
 
    onFailure({errCode:"ERR_PASS", errMessage:"transferComplete not implemented"});   

  },


/*
@api - Place a consultation call
@param $String$callId – The callId of the active call
@param $String$destination – The dialed digits of the party to be consulted
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	consulationCall: function (callId, destination, options, onSuccess, onFailure) {

    onFailure({errCode:"ERR_PASS", errMessage:"consulationCall not implemented"});
	
  },

/*
@api - Initiate a conference cal
@param $String$callId – The callId of the active call
@param $String$destination – The dialed digits of the party to be conferenced
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
  conferenceInitiate: function (callId, destination, options, onSuccess, onFailure)  {
    
    onFailure({errCode:"ERR_PASS", errMessage:"conferenceInitiate not implemented"});
    
  },


/*
@api - Complete a conference
@param $String$heldcallId – The Call Id of the held call
@param $String$activecallId – The Call Id of the active call
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	conferenceComplete: function (heldcallId, activecallId, options, onSuccess, onFailure)  {
    
    onFailure({errCode:"ERR_PASS", errMessage:"conferenceComplete not implemented"});

	},



/*
@api - Drop party from a Conference
@param $String$callId – The callId of the call from which party is to be dropped
@param $String$party – The party to be dropped
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	dropparty: function (callId, party, options, onSuccess, onFailure)  {
      
    onFailure({errCode:"ERR_PASS", errMessage:"dropParty not implemented"});
    
	},

	dispatchEvent: function (event)  {
      
    try {
      var serializedEvent = JSON.stringify(event);
      console.log ("Dispatching event : " + serializedEvent);
      this.eventCallback(serializedEvent);
    }
    catch (e)  {
      console.log ("Error dispatching event : " + e);
    }
    
	},
  
  
  _sendSnapshot: function (options,linkState, deviceState) {
  

    var event = {};
    event.pyMedia = "Phone";
    event.pyAgentId = theAgent.getName();
    event.pyThisDN = theAgent.getExtension();
    event.pyEventType = "SnapshotEvent";
    event.pyEventName = "Snapshot";
    event.pyReasonCode = 0;
    event.pyEventString = "DeviceSnapshot";
    event.pyLinkState = linkState;
    event.pySessionId = "AmazonConnect";
    event.pyDeviceState = deviceState;
    event.pyAgentState = theAgent.getState().type === "routable" ? "Ready" : "NotReady";
    if (this.LinkDefinition) {
      event.pyLinkName = this.LinkDefinition.pyLinkDefinitionName;
      event.pyLinkInsHandle = this.LinkDefinition.pzInsKey;
    }

    var linesArray = [];
        for (var k = options.pyNumberOfLines; k > 0; k--) {
          var lineObject = new Object();
          lineObject.pyLineNumber = options.pyNumberOfLines - k + 1;
          lineObject.pyCallId = '0';
          lineObject.pyLineState = 'idle';
          linesArray.push(lineObject);
        }
    event.pyLines = linesArray;
  
    // todo: replace dummy calls with real calls at device
    //event.pyLines[0] = {"pyLineNumber":1,"pyCallId":"0","pyLineState":"idle"};
    //event.pyLines[1] = {"pyLineNumber":2,"pyCallId":"0","pyLineState":"idle"};
    //event.pyLines[2] = {"pyLineNumber":3,"pyCallId":"0","pyLineState":"idle"};
    var contacts = theAgent.getContacts ();
    if (contacts != null) {
      for (var i=0; i < contacts.length; i++) {
        var ac = contacts[i].getAgentConnection();
        var cs = ac.getStatus().type;
        if (cs !== connect.ConnectionStateType.DISCONNECTED) {
    	    event.pyLines[i].pyCallId = contacts[i].getContactId();
          switch (cs) {
            case connect.ConnectionStateType.CONNECTING:
              event.pyLines[i].pyLineState = contacts[i].isInbound() ? "alerting" : "initiating"; 
              break;
            case connect.ConnectionStateType.CONNECTED:
              event.pyLines[i].pyLineState = "connected"; 
              break;
            case connect.ConnectionStateType.HOLD:
              event.pyLines[i].pyLineState = "held"; 
              break;
          }
        }
      }
    }
      this.dispatchEvent(event);
  }
}


var theAgent = null;

// Enable events to Pega Call Control Panel
var AWSEnableEvents = true;


// Call Control Functions

function consultationCall(activeCallId, Destination) {
  
  var activeContact = findContact(activeCallId);
  var endpoint = connect.Endpoint.byPhoneNumber(Destination);
  activeContact.addConnection(endpoint);
 
}

function completeConference(heldCallId, activeCallId) {
 
  var activeConnection = findConnection(activeCallId);
  var heldContact = findContact(heldCallId);
  heldContact.addConnection(activeConnection);
  heldContact.conferenceConnections();
}


function normalizeDN(dn) {

  var nDn = dn.split("@")[0]; 
  nDn = nDn.replace("sip:", "");
  return nDn;
}

function findContact(ContactId) {
  
  var theContact = null;
  var contacts = theAgent.getContacts ();
  if (contacts != null) {
    for (var i=0; i < contacts.length; i++) {
      if (contacts[i].getContactId() === ContactId)
    	  return contacts[i];
      }
  }
  
  return theContact;
}

// Find Contact for Call
function findConnectionContact (CallId) {
  
  var theContact = null;
  var contacts = theAgent.getContacts ();
  if (contacts != null)
    for (var i=0; i < contacts.length; i++) {
        var ic = contacts[i].getInitialConnection(); 
    	if (ic && ic.getConnectionId() === CallId)
          return contacts[i];
    }
     
  return theContact;
}

// Find Connection for Call
function findConnection (ConnId) {
  
  var theConnection = null;
  var contacts = theAgent.getContacts ();
  if (contacts != null)
    for (var i=0; i < contacts.length; i++) {
        var ic = contacts[i].getInitialConnection(); 
    	if (ic && ic.getConnectionId() === ConnId)
        	return ic
    }
     
  return theConnection;
}

// Create Interaction and Apply Call Treatment
function _handleAlertingEvent(oEvent) {
  
    var responseObj = new Object();
    var postData = new SafeURL();
    var activityUrl = new SafeURL("ChannelServices-Event-CTILink.CreateInteractionFromEvent");
    //postData.put("pzPrimaryPageName", "CTIEvent");
    postData.put("Event", oEvent);
    pega.cti.pegaCallRequestProcessor.addRequestToQueue("POST", activityUrl, {
        success: function(oResponse) {
            var request = oResponse;
            if (request.status === 200) {
                var response = request.responseText;
            showhtml(response);
              responseObj = JSON.parse(response);
                if (responseObj.pyPopType !== "NONE") {
                    responseObj.pyOPENCTI = true;
                    response = JSON.stringify(responseObj);
                    if (window.ScreenPopEventHandler)
					            ScreenPopEventHandler(response);
              	    else
                      sendEvent("PegaCallScreenPopRequest", response);
                }
                else 
                  console.log ("Call treatment is set to NONE");
            } else {
                sendError("HTTP Error: " + request.statusText);
            }
        },
        failure: function(oResponse) {
            sendError("HTTP Error: " + oResponse.statusText);
        },
        scope: this
    }, postData);
}

function _handleNotRoutable(agent) {

    if (!AWSEnableEvents) return;
    var event = {};
    event.pyAgentID = 
    event.pyEventName = "NotReady";
    event.pyEventType = "AgentStateEvent";
    event.pyMedia = "Phone";
    event.pyReasonCode = 0;
    event.pyWorkMode = "AuxWork";
//    sendEvent("PhoneAgentStateEvent", JSON.stringify(event));
    pega.cti.API.dispatchEvent(event);
}

function _handleRoutable(agent) {
   
    if (!AWSEnableEvents) return;
    var event = {};
    event.pyAgentId = theAgent.getName();
    event.pyEventName = "Ready";
    event.pyEventType = "AgentStateEvent";
    event.pyMedia = "Phone";
    event.pyReasonCode = 0;
    pega.cti.API.dispatchEvent(event);
}

function _handleOffline (agent) {
    
    if (!AWSEnableEvents) return;
    var event = {};
    event.pyAgentID = theAgent.getName(); 
    event.pyEventName = "NotReady";
    event.pyEventType = "AgentStateEvent";
    event.pyMedia = "Phone";
    event.pyReasonCode = 0;
    pega.cti.API.dispatchEvent(event);
}

function _handleAfterCallWork (agent) {
      
    if (!AWSEnableEvents) return;
    var event = {};
    event.pyAgentID = theAgent.getName(); 
    event.pyEventName = "NotReady";
    event.pyEventType = "AgentStateEvent";
    event.pyMedia = "Phone";
    event.pyReasonCode = 0;
    event.pyWorkMode = "AfterCallWork";
    pega.cti.API.dispatchEvent(event);
   
}

function newContact (contact) {
   

    console.log ("Handle New Contact Event : " + JSON.stringify(contact));
    var otherConn = contact.getActiveInitialConnection();
    if (otherConn.getStatus().type === connect.ConnectionStateType.DISCONNECTED) return;
    if (contact.getAgentConnection().getStatus().type=== connect.ConnectionStateType.DISCONNECTED) return;
  	var event = {};
    event.pyCallId = contact.getContactId();
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = contact.isInbound() ? "Alerting" : "Initiated";
    event.pyEventString = contact.isInbound() ? "Offering" : "Initiated";
  	event.pyOtherDN = normalizeDN(otherConn.getAddress().phoneNumber);
    event.pyANI = event.pyOtherDN;
	  event.pyCallType = "INBOUND";
    if (!contact.isInbound())
      event.pyCallType = "OUTBOUND";
    var queue = contact.getQueue();
    event.pyQueue = contact.getQueue().name;
    event.pyQueueARN = contact.getQueue().ARN;
    event.pyNamedVariables = {};
    var attributes = contact.getAttributes();
    AWS.util.each(attributes, function (key, value) {
    	event.pyNamedVariables[key] = value.value;
      if (key.toUpperCase() === "CALLTYPE")
        event.pyCallType = value.value;
	})
    
  
    if (AWSEnableEvents)    
      sendEvent("PhoneCallStateEvent", JSON.stringify(event));
 
    event.pyEventName = "Offering";
    
    // For now limit pops to Inbound && !contact.isConnected()
    if (contact.isInbound() && !contact.isConnected())
      _handleAlertingEvent(JSON.stringify(event));
 }  

function _handleIncoming (contact) {
    pega.cti.API.lastCallState = "connecting";
    console.log ("Handle Incoming Event : " + JSON.stringify(contact));
  
}

function _handleEnded (contact) {
  pega.cti.API.lastCallState = "disconnected";
  try {
    console.log ("Handle Ended Event : " + JSON.stringify(contact));
    if (!AWSEnableEvents) return;
  	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = contact.getContactId();
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Disconnected";
    event.pyEventString = "Disconnected";
    pega.cti.API.dispatchEvent(event);
  }
  catch (e) {
    console.log ("Error handling Ended event: " + e);
  }
 
}

function _handleConnected (contact) {
    pega.cti.API.lastCallState = "connected";
    console.log ("Handle Connected Event : " + JSON.stringify(contact));
    if (!AWSEnableEvents) return;
    var otherConn = contact.getActiveInitialConnection();
  	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = contact.getContactId();
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Established";
    event.pyEventString = "Established";
  	event.pyOtherDN = normalizeDN(otherConn.getAddress().phoneNumber);
    pega.cti.API.dispatchEvent(event);
}

function _handleAccepted (contact) {
    pega.cti.API.lastCallState = "accepted";
    console.log ("Handle Accepted Event : " + JSON.stringify(contact));   
    if (!AWSEnableEvents) return;
    if (!contact) return;
    var otherConn = contact.getActiveInitialConnection();
  	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = contact.getContactId();
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Established";
    event.pyEventString = "Established";
  	event.pyOtherDN = normalizeDN(otherConn.getAddress().phoneNumber);
    pega.cti.API.dispatchEvent(event);
}

function _handleHeld (contact) {

    pega.cti.API.lastCallState = "held";
    if (!AWSEnableEvents) return;
   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = contact.getContactId();
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Held";
    event.pyEventString = "Held";
    pega.cti.API.dispatchEvent(event);
}

function _handleRetrieved (contact) {

    pega.cti.API.lastCallState = "retrieved";
    if (!AWSEnableEvents) return;
  	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = contact.getContactId();
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Retrieved";
    event.pyEventString = "Retrieved";
    pega.cti.API.dispatchEvent(event);
}


function _handleAgentRefresh(agent) {
   if(agent.getState() != null && agent.getState().name == "MissedCallAgent")
    _handleNotRoutable(agent);
 }

function _handleContactRefresh(contact) {
  console.log ("Received Contact Refresh : " + JSON.stringify(contact));
  var conn = contact.getAgentConnection();
  var otherConn = contact.getActiveInitialConnection();
  console.log ("Agent Connection=" + JSON.stringify(conn));
  console.log ("Connection State=" + conn.getStatus().type);
    
  if(conn.isOnHold() && pega.cti.API.lastCallState !== "disconnected")
    _handleHeld(contact);
  else if(conn.isConnected() && pega.cti.API.lastCallState !== "disconnected") {
    _handleRetrieved(contact);
  } else if ((conn != null && conn.getStatus().type === connect.ConnectionStateType.DISCONNECTED) 
         && pega.cti.API.lastCallState !== "disconnected"){
    _handleEnded(contact);     
  } 
}
  
function loadAWSConnect (url, options,onSuccess, onFailure) {
   var ccp = document.getElementById('CCPDiv');
    if (ccp) {
        if (window.connect) {
          window.ccp = window.ccp || {};
          connect.core.initCCP(ccp, {
                ccpUrl: url+"/ccp#",
                loginPopup: false,
                softphone: {
                allowFramedSoftphone: true,
                disableRingtone: false
              }
          });
          connect.core.getEventBus().subscribe(connect.EventType.ACK_TIMEOUT, function () {
            try {
              connect.getLog().warn("ACK_TIMEOUT occurred, attempting to pop the login page.");
              var width = 500;
              var height = 600;
              var left = (screen.width / 2) - (width / 2);
              var top = (screen.height / 2) - (height / 2);

              var loginURL = url + "/login";
              loginWindow = window.open(loginURL, true, "width=" + width + ",height=" + height + ",menubar=no,status=no,toolbar=no,left=" + left + ",top=" + top);
            } 
            catch (e) {
              onFailure({errCode:"ERR_PASS", errMessage:"ACK_TIMEOUT occurred but we are unable to open the login popup." + e});
            }

            connect.core.getEventBus().subscribe(connect.EventType.ACKNOWLEDGE, function () {
              pega.cti.API._sendSnapshot (options,"CONNECTED", "OPENED");
              loginWindow.close();
            });

          });
          
          onSuccess();
          connect.agent ( function (myAgent) {
          theAgent = myAgent;
         
          theAgent.onRoutable(_handleRoutable);
          theAgent.onNotRoutable(_handleNotRoutable);
          theAgent.onOffline(_handleOffline);
          theAgent.onAfterCallWork(_handleAfterCallWork);
          theAgent.onRefresh(_handleAgentRefresh);
          });
		      connect.contact (function (myContact) {
              newContact(myContact);
              myContact.onIncoming(_handleIncoming);
              myContact.onEnded (_handleEnded);
              myContact.onConnected (_handleConnected);
              myContact.onAccepted(_handleAccepted);
              myContact.onRefresh(_handleContactRefresh);
          });

        }
        else 
          onFailure ({errCode:"ERR_PASS", errMessage:"amazon connect JS not included"});
    }
    else
      onFailure ({errCode:"ERR_PASS", errMessage:"Unable to inject Amazon CCP. Unable to locate CCPDiv in current document."})
}
var int;
function findCCP(){
  int=setInterval('check()', 50000);
  
 
} 

function check()
{  if (chkObject('CCPDiv')==true )
   {
      int=window.clearInterval(int);
      
   }
  
}
function chkObject(elemId)
{
   return (document.getElementById(elemId))? true : false;
}
//static-content-hash-trigger-GCC
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2014-06-30",
    "endpointPrefix": "cognito-identity",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Cognito Identity",
    "signatureVersion": "v4",
    "targetPrefix": "AWSCognitoIdentityService"
  },
  "operations": {
    "CreateIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolName",
          "AllowUnauthenticatedIdentities"
        ],
        "members": {
          "IdentityPoolName": {},
          "AllowUnauthenticatedIdentities": {
            "type": "boolean"
          },
          "SupportedLoginProviders": {
            "shape": "S4"
          },
          "DeveloperProviderName": {},
          "OpenIdConnectProviderARNs": {
            "shape": "S8"
          },
          "CognitoIdentityProviders": {
            "shape": "Sa"
          },
          "SamlProviderARNs": {
            "shape": "Se"
          }
        }
      },
      "output": {
        "shape": "Sf"
      }
    },
    "DeleteIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityIdsToDelete"
        ],
        "members": {
          "IdentityIdsToDelete": {
            "type": "list",
            "member": {}
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "UnprocessedIdentityIds": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "IdentityId": {},
                "ErrorCode": {}
              }
            }
          }
        }
      }
    },
    "DeleteIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      }
    },
    "DescribeIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {}
        }
      },
      "output": {
        "shape": "Sq"
      }
    },
    "DescribeIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      },
      "output": {
        "shape": "Sf"
      }
    },
    "GetCredentialsForIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "Sv"
          },
          "CustomRoleArn": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Credentials": {
            "type": "structure",
            "members": {
              "AccessKeyId": {},
              "SecretKey": {},
              "SessionToken": {},
              "Expiration": {
                "type": "timestamp"
              }
            }
          }
        }
      }
    },
    "GetId": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "AccountId": {},
          "IdentityPoolId": {},
          "Logins": {
            "shape": "Sv"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {}
        }
      }
    },
    "GetIdentityPoolRoles": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "Roles": {
            "shape": "S17"
          }
        }
      }
    },
    "GetOpenIdToken": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "Sv"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Token": {}
        }
      }
    },
    "GetOpenIdTokenForDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "Logins"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityId": {},
          "Logins": {
            "shape": "Sv"
          },
          "TokenDuration": {
            "type": "long"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Token": {}
        }
      }
    },
    "ListIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "MaxResults"
        ],
        "members": {
          "IdentityPoolId": {},
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {},
          "HideDisabled": {
            "type": "boolean"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "Identities": {
            "type": "list",
            "member": {
              "shape": "Sq"
            }
          },
          "NextToken": {}
        }
      }
    },
    "ListIdentityPools": {
      "input": {
        "type": "structure",
        "required": [
          "MaxResults"
        ],
        "members": {
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPools": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "IdentityPoolId": {},
                "IdentityPoolName": {}
              }
            }
          },
          "NextToken": {}
        }
      }
    },
    "LookupDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityId": {},
          "DeveloperUserIdentifier": {},
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "DeveloperUserIdentifierList": {
            "type": "list",
            "member": {}
          },
          "NextToken": {}
        }
      }
    },
    "MergeDeveloperIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "SourceUserIdentifier",
          "DestinationUserIdentifier",
          "DeveloperProviderName",
          "IdentityPoolId"
        ],
        "members": {
          "SourceUserIdentifier": {},
          "DestinationUserIdentifier": {},
          "DeveloperProviderName": {},
          "IdentityPoolId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {}
        }
      }
    },
    "SetIdentityPoolRoles": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "Roles"
        ],
        "members": {
          "IdentityPoolId": {},
          "Roles": {
            "shape": "S17"
          }
        }
      }
    },
    "UnlinkDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId",
          "IdentityPoolId",
          "DeveloperProviderName",
          "DeveloperUserIdentifier"
        ],
        "members": {
          "IdentityId": {},
          "IdentityPoolId": {},
          "DeveloperProviderName": {},
          "DeveloperUserIdentifier": {}
        }
      }
    },
    "UnlinkIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId",
          "Logins",
          "LoginsToRemove"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "Sv"
          },
          "LoginsToRemove": {
            "shape": "Sr"
          }
        }
      }
    },
    "UpdateIdentityPool": {
      "input": {
        "shape": "Sf"
      },
      "output": {
        "shape": "Sf"
      }
    }
  },
  "shapes": {
    "S4": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S8": {
      "type": "list",
      "member": {}
    },
    "Sa": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "ProviderName": {},
          "ClientId": {}
        }
      }
    },
    "Se": {
      "type": "list",
      "member": {}
    },
    "Sf": {
      "type": "structure",
      "required": [
        "IdentityPoolId",
        "IdentityPoolName",
        "AllowUnauthenticatedIdentities"
      ],
      "members": {
        "IdentityPoolId": {},
        "IdentityPoolName": {},
        "AllowUnauthenticatedIdentities": {
          "type": "boolean"
        },
        "SupportedLoginProviders": {
          "shape": "S4"
        },
        "DeveloperProviderName": {},
        "OpenIdConnectProviderARNs": {
          "shape": "S8"
        },
        "CognitoIdentityProviders": {
          "shape": "Sa"
        },
        "SamlProviderARNs": {
          "shape": "Se"
        }
      }
    },
    "Sq": {
      "type": "structure",
      "members": {
        "IdentityId": {},
        "Logins": {
          "shape": "Sr"
        },
        "CreationDate": {
          "type": "timestamp"
        },
        "LastModifiedDate": {
          "type": "timestamp"
        }
      }
    },
    "Sr": {
      "type": "list",
      "member": {}
    },
    "Sv": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S17": {
      "type": "map",
      "key": {},
      "value": {}
    }
  }
}
},{}],2:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2017-02-15",
    "endpointPrefix": "connect",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "Connect",
    "serviceFullName": "AmazonConnectCTIService",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonConnectCTIService",
    "uid": "connect-2017-02-15"
  },
  "operations": {
    "AcceptContact": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "ConferenceConnections": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "CreateAdditionalConnection": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId",
          "endpoint"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "endpoint": {
            "shape": "Sa"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "CreateOutboundContact": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "endpoint"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "endpoint": {
            "shape": "Sa"
          },
          "queueARN": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "DestroyConnection": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId",
          "connectionId"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "connectionId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "GetAgentConfiguration": {
      "input": {
        "type": "structure",
        "required": [
          "authentication"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "configuration"
        ],
        "members": {
          "configuration": {
            "shape": "Sr"
          }
        }
      }
    },
    "GetAgentPermissions": {
      "input": {
        "type": "structure",
        "required": [
          "authentication"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "nextToken": {},
          "maxResults": {
            "type": "integer"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "permissions"
        ],
        "members": {
          "permissions": {
            "type": "list",
            "member": {}
          },
          "nextToken": {}
        }
      }
    },
    "GetAgentSnapshot": {
      "input": {
        "type": "structure",
        "required": [
          "authentication"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "nextToken": {},
          "timeout": {
            "type": "long"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "snapshot",
          "nextToken"
        ],
        "members": {
          "snapshot": {
            "type": "structure",
            "required": [
              "state",
              "contacts",
              "snapshotTimestamp"
            ],
            "members": {
              "state": {
                "shape": "S17"
              },
              "contacts": {
                "type": "list",
                "member": {
                  "type": "structure",
                  "required": [
                    "contactId",
                    "type",
                    "state",
                    "queueTimestamp",
                    "connections",
                    "attributes"
                  ],
                  "members": {
                    "contactId": {},
                    "initialContactId": {},
                    "type": {},
                    "state": {
                      "type": "structure",
                      "required": [
                        "type",
                        "timestamp"
                      ],
                      "members": {
                        "type": {},
                        "timestamp": {
                          "type": "timestamp"
                        }
                      }
                    },
                    "queue": {
                      "shape": "Sg"
                    },
                    "queueTimestamp": {
                      "type": "timestamp"
                    },
                    "connections": {
                      "type": "list",
                      "member": {
                        "type": "structure",
                        "required": [
                          "connectionId",
                          "state",
                          "type",
                          "initial"
                        ],
                        "members": {
                          "connectionId": {},
                          "endpoint": {
                            "shape": "Sa"
                          },
                          "state": {
                            "type": "structure",
                            "required": [
                              "type",
                              "timestamp"
                            ],
                            "members": {
                              "type": {},
                              "timestamp": {
                                "type": "timestamp"
                              }
                            }
                          },
                          "type": {},
                          "initial": {
                            "type": "boolean"
                          },
                          "softphoneMediaInfo": {
                            "type": "structure",
                            "members": {
                              "callType": {},
                              "autoAccept": {
                                "type": "boolean"
                              },
                              "mediaLegContextToken": {},
                              "callContextToken": {},
                              "callConfigJson": {}
                            }
                          }
                        }
                      }
                    },
                    "attributes": {
                      "shape": "S1o"
                    }
                  }
                }
              },
              "snapshotTimestamp": {
                "type": "timestamp"
              }
            }
          },
          "nextToken": {}
        }
      }
    },
    "GetAgentStates": {
      "input": {
        "type": "structure",
        "required": [
          "authentication"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "nextToken": {},
          "maxResults": {
            "type": "integer"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "states"
        ],
        "members": {
          "states": {
            "type": "list",
            "member": {
              "shape": "S17"
            }
          },
          "nextToken": {}
        }
      }
    },
    "GetDialableCountryCodes": {
      "input": {
        "type": "structure",
        "required": [
          "authentication"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "nextToken": {},
          "maxResults": {
            "type": "integer"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "countryCodes"
        ],
        "members": {
          "countryCodes": {
            "type": "list",
            "member": {}
          },
          "nextToken": {}
        }
      }
    },
    "GetEndpoints": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "queueARNs"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "queueARNs": {
            "type": "list",
            "member": {}
          },
          "nextToken": {},
          "maxResults": {
            "type": "integer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "endpoints": {
            "type": "list",
            "member": {
              "shape": "Sa"
            }
          },
          "nextToken": {}
        }
      }
    },
    "GetNewAuthToken": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "refreshToken"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "refreshToken": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "newAuthToken": {},
          "expirationDateTime": {
            "type": "timestamp"
          }
        }
      }
    },
    "GetRoutingProfileQueues": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "routingProfileARN"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "routingProfileARN": {},
          "nextToken": {},
          "maxResults": {
            "type": "integer"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "queues"
        ],
        "members": {
          "queues": {
            "type": "list",
            "member": {
              "shape": "Sg"
            }
          },
          "nextToken": {}
        }
      }
    },
    "HoldConnection": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId",
          "connectionId"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "connectionId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "NotifyContactIssue": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "issueCode": {},
          "description": {},
          "clientLogs": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "PutAgentState": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "state"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "state": {
            "shape": "S17"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "ResumeConnection": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId",
          "connectionId"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "connectionId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "SendClientLogs": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "logEvents"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "logEvents": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "timestamp": {
                  "type": "timestamp"
                },
                "component": {},
                "message": {}
              }
            }
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "SendDigits": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId",
          "connectionId",
          "digits"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "connectionId": {},
          "digits": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "SendSoftphoneCallMetrics": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId",
          "softphoneStreamStatistics"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "softphoneStreamStatistics": {
            "shape": "S2n"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "SendSoftphoneCallReport": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId",
          "report"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "report": {
            "type": "structure",
            "members": {
              "callStartTime": {
                "type": "timestamp"
              },
              "callEndTime": {
                "type": "timestamp"
              },
              "softphoneStreamStatistics": {
                "shape": "S2n"
              },
              "gumTimeMillis": {
                "type": "long"
              },
              "initializationTimeMillis": {
                "type": "long"
              },
              "iceCollectionTimeMillis": {
                "type": "long"
              },
              "signallingConnectTimeMillis": {
                "type": "long"
              },
              "handshakeTimeMillis": {
                "type": "long"
              },
              "preTalkTimeMillis": {
                "type": "long"
              },
              "talkTimeMillis": {
                "type": "long"
              },
              "cleanupTimeMillis": {
                "type": "long"
              },
              "iceCollectionFailure": {
                "type": "boolean"
              },
              "signallingConnectionFailure": {
                "type": "boolean"
              },
              "handshakeFailure": {
                "type": "boolean"
              },
              "gumOtherFailure": {
                "type": "boolean"
              },
              "gumTimeoutFailure": {
                "type": "boolean"
              },
              "createOfferFailure": {
                "type": "boolean"
              },
              "setLocalDescriptionFailure": {
                "type": "boolean"
              },
              "userBusyFailure": {
                "type": "boolean"
              },
              "invalidRemoteSDPFailure": {
                "type": "boolean"
              },
              "noRemoteIceCandidateFailure": {
                "type": "boolean"
              },
              "setRemoteDescriptionFailure": {
                "type": "boolean"
              }
            }
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "ToggleActiveConnections": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId",
          "connectionId"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "connectionId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "UpdateAgentConfiguration": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "configuration"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "configuration": {
            "shape": "Sr"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "UpdateContactAttributes": {
      "input": {
        "type": "structure",
        "required": [
          "authentication",
          "contactId",
          "attributes"
        ],
        "members": {
          "authentication": {
            "shape": "S2"
          },
          "contactId": {},
          "attributes": {
            "shape": "S1o"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    }
  },
  "shapes": {
    "S2": {
      "type": "structure",
      "members": {
        "agentARN": {},
        "authToken": {}
      }
    },
    "Sa": {
      "type": "structure",
      "required": [
        "type"
      ],
      "members": {
        "endpointARN": {},
        "type": {},
        "name": {},
        "phoneNumber": {},
        "agentLogin": {},
        "queue": {
          "shape": "Sg"
        }
      }
    },
    "Sg": {
      "type": "structure",
      "members": {
        "queueARN": {},
        "name": {}
      }
    },
    "Sr": {
      "type": "structure",
      "required": [
        "name",
        "softphoneEnabled",
        "softphoneAutoAccept",
        "extension",
        "routingProfile"
      ],
      "members": {
        "name": {},
        "softphoneEnabled": {
          "type": "boolean"
        },
        "softphoneAutoAccept": {
          "type": "boolean"
        },
        "extension": {},
        "routingProfile": {
          "type": "structure",
          "members": {
            "name": {},
            "routingProfileARN": {},
            "defaultOutboundQueue": {
              "shape": "Sg"
            }
          }
        },
        "agentPreferences": {
          "type": "map",
          "key": {},
          "value": {}
        }
      }
    },
    "S17": {
      "type": "structure",
      "required": [
        "type",
        "name"
      ],
      "members": {
        "agentStateARN": {},
        "type": {},
        "name": {},
        "startTimestamp": {
          "type": "timestamp"
        }
      }
    },
    "S1o": {
      "type": "map",
      "key": {},
      "value": {
        "type": "structure",
        "required": [
          "name"
        ],
        "members": {
          "name": {},
          "value": {}
        }
      }
    },
    "S2n": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "timestamp": {
            "type": "timestamp"
          },
          "softphoneStreamType": {},
          "packetCount": {
            "type": "long"
          },
          "packetsLost": {
            "type": "long"
          },
          "audioLevel": {
            "type": "double"
          },
          "jitterBufferMillis": {
            "type": "long"
          },
          "roundTripTimeMillis": {
            "type": "long"
          }
        }
      }
    }
  }
}
},{}],3:[function(require,module,exports){
module.exports={
  "acm": {
    "name": "ACM",
    "cors": true
  },
  "apigateway": {
    "name": "APIGateway",
    "cors": true
  },
  "applicationautoscaling": {
    "prefix": "application-autoscaling",
    "name": "ApplicationAutoScaling",
    "cors": true
  },
  "autoscaling": {
    "name": "AutoScaling",
    "cors": true
  },
  "budgets": {
    "name": "Budgets"
  },
  "cloudformation": {
    "name": "CloudFormation",
    "cors": true
  },
  "cloudfront": {
    "name": "CloudFront",
    "versions": [
      "2013-05-12*",
      "2013-11-11*",
      "2014-05-31*",
      "2014-10-21*",
      "2014-11-06*",
      "2015-04-17*",
      "2015-07-27*",
      "2015-09-17*",
      "2016-01-13*",
      "2016-01-28*",
      "2016-08-01*",
      "2016-08-20*",
      "2016-09-07*"
    ],
    "cors": true
  },
  "cloudhsm": {
    "name": "CloudHSM",
    "cors": true
  },
  "cloudsearch": {
    "name": "CloudSearch"
  },
  "cloudsearchdomain": {
    "name": "CloudSearchDomain"
  },
  "cloudtrail": {
    "name": "CloudTrail",
    "cors": true
  },
  "cloudwatch": {
    "prefix": "monitoring",
    "name": "CloudWatch",
    "cors": true
  },
  "cloudwatchevents": {
    "prefix": "events",
    "name": "CloudWatchEvents",
    "versions": [
      "2014-02-03*"
    ],
    "cors": true
  },
  "cloudwatchlogs": {
    "prefix": "logs",
    "name": "CloudWatchLogs",
    "cors": true
  },
  "codecommit": {
    "name": "CodeCommit",
    "cors": true
  },
  "codedeploy": {
    "name": "CodeDeploy",
    "cors": true
  },
  "codepipeline": {
    "name": "CodePipeline",
    "cors": true
  },
  "cognitoidentity": {
    "prefix": "cognito-identity",
    "name": "CognitoIdentity",
    "cors": true
  },
  "cognitoidentityserviceprovider": {
    "prefix": "cognito-idp",
    "name": "CognitoIdentityServiceProvider",
    "cors": true
  },
  "cognitosync": {
    "prefix": "cognito-sync",
    "name": "CognitoSync",
    "cors": true
  },
  "configservice": {
    "prefix": "config",
    "name": "ConfigService",
    "cors": true
  },
  "connect": {
    "name":  "Connect",
    "cors":  true
  },
  "datapipeline": {
    "name": "DataPipeline"
  },
  "devicefarm": {
    "name": "DeviceFarm",
    "cors": true
  },
  "directconnect": {
    "name": "DirectConnect",
    "cors": true
  },
  "directoryservice": {
    "prefix": "ds",
    "name": "DirectoryService"
  },
  "discovery": {
    "name": "Discovery"
  },
  "dms": {
    "name": "DMS"
  },
  "dynamodb": {
    "name": "DynamoDB",
    "cors": true
  },
  "dynamodbstreams": {
    "prefix": "streams.dynamodb",
    "name": "DynamoDBStreams",
    "cors": true
  },
  "ec2": {
    "name": "EC2",
    "versions": [
      "2013-06-15*",
      "2013-10-15*",
      "2014-02-01*",
      "2014-05-01*",
      "2014-06-15*",
      "2014-09-01*",
      "2014-10-01*",
      "2015-03-01*",
      "2015-04-15*",
      "2015-10-01*",
      "2016-04-01*"
    ],
    "cors": true
  },
  "ecr": {
    "name": "ECR",
    "cors": true
  },
  "ecs": {
    "name": "ECS",
    "cors": true
  },
  "efs": {
    "prefix": "elasticfilesystem",
    "name": "EFS"
  },
  "elasticache": {
    "name": "ElastiCache",
    "versions": [
      "2012-11-15*",
      "2014-03-24*",
      "2014-07-15*",
      "2014-09-30*"
    ],
    "cors": true
  },
  "elasticbeanstalk": {
    "name": "ElasticBeanstalk",
    "cors": true
  },
  "elb": {
    "prefix": "elasticloadbalancing",
    "name": "ELB",
    "cors": true
  },
  "elbv2": {
    "prefix": "elasticloadbalancingv2",
    "name": "ELBv2",
    "cors": true
  },
  "emr": {
    "prefix": "elasticmapreduce",
    "name": "EMR",
    "cors": true
  },
  "es": {
    "name": "ES"
  },
  "elastictranscoder": {
    "name": "ElasticTranscoder",
    "cors": true
  },
  "firehose": {
    "name": "Firehose",
    "cors": true
  },
  "gamelift": {
    "name": "GameLift",
    "cors": true
  },
  "glacier": {
    "name": "Glacier"
  },
  "iam": {
    "name": "IAM"
  },
  "importexport": {
    "name": "ImportExport"
  },
  "inspector": {
    "name": "Inspector",
    "versions": [
      "2015-08-18*"
    ],
    "cors": true
  },
  "iot": {
    "name": "Iot",
    "cors": true
  },
  "iotdata": {
    "prefix": "iot-data",
    "name": "IotData",
    "cors": true
  },
  "kinesis": {
    "name": "Kinesis",
    "cors": true
  },
  "kinesisanalytics": {
    "name": "KinesisAnalytics"
  },
  "kms": {
    "name": "KMS",
    "cors": true
  },
  "lambda": {
    "name": "Lambda",
    "cors": true
  },
  "machinelearning": {
    "name": "MachineLearning",
    "cors": true
  },
  "marketplacecommerceanalytics": {
    "name": "MarketplaceCommerceAnalytics",
    "cors": true
  },
  "marketplacemetering": {
    "prefix": "meteringmarketplace",
    "name": "MarketplaceMetering"
  },
  "mobileanalytics": {
    "name": "MobileAnalytics",
    "cors": true
  },
  "opsworks": {
    "name": "OpsWorks",
    "cors": true
  },
  "rds": {
    "name": "RDS",
    "versions": [
      "2014-09-01*"
    ],
    "cors": true
  },
  "redshift": {
    "name": "Redshift",
    "cors": true
  },
  "route53": {
    "name": "Route53",
    "cors": true
  },
  "route53domains": {
    "name": "Route53Domains",
    "cors": true
  },
  "s3": {
    "name": "S3",
    "dualstackAvailable": true,
    "cors": true
  },
  "servicecatalog": {
    "name": "ServiceCatalog",
    "cors": true
  },
  "ses": {
    "prefix": "email",
    "name": "SES",
    "cors": true
  },
  "simpledb": {
    "prefix": "sdb",
    "name": "SimpleDB"
  },
  "sms": {
    "name": "SMS"
  },
  "snowball": {
    "name": "Snowball"
  },
  "sns": {
    "name": "SNS",
    "cors": true
  },
  "sqs": {
    "name": "SQS",
    "cors": true
  },
  "ssm": {
    "name": "SSM",
    "cors": true
  },
  "storagegateway": {
    "name": "StorageGateway",
    "cors": true
  },
  "sts": {
    "name": "STS",
    "cors": true
  },
  "support": {
    "name": "Support"
  },
  "swf": {
    "name": "SWF"
  },
  "waf": {
    "name": "WAF",
    "cors": true
  },
  "workspaces": {
    "name": "WorkSpaces"
  }
}

},{}],4:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2011-06-15",
    "endpointPrefix": "sts",
    "globalEndpoint": "sts.amazonaws.com",
    "protocol": "query",
    "serviceAbbreviation": "AWS STS",
    "serviceFullName": "AWS Security Token Service",
    "signatureVersion": "v4",
    "xmlNamespace": "https://sts.amazonaws.com/doc/2011-06-15/"
  },
  "operations": {
    "AssumeRole": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "RoleSessionName"
        ],
        "members": {
          "RoleArn": {},
          "RoleSessionName": {},
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          },
          "ExternalId": {},
          "SerialNumber": {},
          "TokenCode": {}
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sa"
          },
          "AssumedRoleUser": {
            "shape": "Sf"
          },
          "PackedPolicySize": {
            "type": "integer"
          }
        }
      }
    },
    "AssumeRoleWithSAML": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "PrincipalArn",
          "SAMLAssertion"
        ],
        "members": {
          "RoleArn": {},
          "PrincipalArn": {},
          "SAMLAssertion": {},
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          }
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleWithSAMLResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sa"
          },
          "AssumedRoleUser": {
            "shape": "Sf"
          },
          "PackedPolicySize": {
            "type": "integer"
          },
          "Subject": {},
          "SubjectType": {},
          "Issuer": {},
          "Audience": {},
          "NameQualifier": {}
        }
      }
    },
    "AssumeRoleWithWebIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "RoleSessionName",
          "WebIdentityToken"
        ],
        "members": {
          "RoleArn": {},
          "RoleSessionName": {},
          "WebIdentityToken": {},
          "ProviderId": {},
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          }
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleWithWebIdentityResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sa"
          },
          "SubjectFromWebIdentityToken": {},
          "AssumedRoleUser": {
            "shape": "Sf"
          },
          "PackedPolicySize": {
            "type": "integer"
          },
          "Provider": {},
          "Audience": {}
        }
      }
    },
    "DecodeAuthorizationMessage": {
      "input": {
        "type": "structure",
        "required": [
          "EncodedMessage"
        ],
        "members": {
          "EncodedMessage": {}
        }
      },
      "output": {
        "resultWrapper": "DecodeAuthorizationMessageResult",
        "type": "structure",
        "members": {
          "DecodedMessage": {}
        }
      }
    },
    "GetCallerIdentity": {
      "input": {
        "type": "structure",
        "members": {}
      },
      "output": {
        "resultWrapper": "GetCallerIdentityResult",
        "type": "structure",
        "members": {
          "UserId": {},
          "Account": {},
          "Arn": {}
        }
      }
    },
    "GetFederationToken": {
      "input": {
        "type": "structure",
        "required": [
          "Name"
        ],
        "members": {
          "Name": {},
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          }
        }
      },
      "output": {
        "resultWrapper": "GetFederationTokenResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sa"
          },
          "FederatedUser": {
            "type": "structure",
            "required": [
              "FederatedUserId",
              "Arn"
            ],
            "members": {
              "FederatedUserId": {},
              "Arn": {}
            }
          },
          "PackedPolicySize": {
            "type": "integer"
          }
        }
      }
    },
    "GetSessionToken": {
      "input": {
        "type": "structure",
        "members": {
          "DurationSeconds": {
            "type": "integer"
          },
          "SerialNumber": {},
          "TokenCode": {}
        }
      },
      "output": {
        "resultWrapper": "GetSessionTokenResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sa"
          }
        }
      }
    }
  },
  "shapes": {
    "Sa": {
      "type": "structure",
      "required": [
        "AccessKeyId",
        "SecretAccessKey",
        "SessionToken",
        "Expiration"
      ],
      "members": {
        "AccessKeyId": {},
        "SecretAccessKey": {},
        "SessionToken": {},
        "Expiration": {
          "type": "timestamp"
        }
      }
    },
    "Sf": {
      "type": "structure",
      "required": [
        "AssumedRoleId",
        "Arn"
      ],
      "members": {
        "AssumedRoleId": {},
        "Arn": {}
      }
    }
  }
}
},{}],5:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = require('../lib/service');
var apiLoader = require('../lib/api_loader');

apiLoader.services['cognitoidentity'] = {};
AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
require('../lib/services/cognitoidentity');
Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
  get: function get() {
    var model = require('../apis/cognito-identity-2014-06-30.min.json');
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.CognitoIdentity;

},{"../apis/cognito-identity-2014-06-30.min.json":1,"../lib/api_loader":7,"../lib/core":10,"../lib/node_loader":8,"../lib/service":41,"../lib/services/cognitoidentity":42}],6:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = require('../lib/service');
var apiLoader = require('../lib/api_loader');

apiLoader.services['sts'] = {};
AWS.STS = Service.defineService('sts', ['2011-06-15']);
require('../lib/services/sts');
Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
  get: function get() {
    var model = require('../apis/sts-2011-06-15.min.json');
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.STS;

},{"../apis/sts-2011-06-15.min.json":4,"../lib/api_loader":7,"../lib/core":10,"../lib/node_loader":8,"../lib/service":41,"../lib/services/sts":43}],7:[function(require,module,exports){
var AWS = require('./core');

AWS.apiLoader = function(svc, version) {
  if (!AWS.apiLoader.services.hasOwnProperty(svc)) {
    throw new Error('InvalidService: Failed to load api for ' + svc);
  }
  return AWS.apiLoader.services[svc][version];
};

AWS.apiLoader.services = {};

module.exports = AWS.apiLoader;
},{"./core":10}],8:[function(require,module,exports){
(function (process){
var util = require('./util');

util.crypto.lib = require('crypto-browserify');
util.Buffer = require('buffer/').Buffer;
util.url = require('url/');
util.querystring = require('querystring/');

var AWS = require('./core');

require('./api_loader');

AWS.XML.Parser = require('./xml/browser_parser');

require('./http/xhr');

if (typeof process === 'undefined') {
  process = {
    browser: true
  };
}
}).call(this,require('_process'))
},{"./api_loader":7,"./core":10,"./http/xhr":19,"./util":52,"./xml/browser_parser":53,"_process":117,"buffer/":58,"crypto-browserify":60,"querystring/":124,"url/":125}],9:[function(require,module,exports){
var AWS = require('./core');
require('./credentials');
require('./credentials/credential_provider_chain');
var PromisesDependency;


AWS.Config = AWS.util.inherit({



  constructor: function Config(options) {
    if (options === undefined) options = {};
    options = this.extractCredentials(options);

    AWS.util.each.call(this, this.keys, function (key, value) {
      this.set(key, options[key], value);
    });
  },




  getCredentials: function getCredentials(callback) {
    var self = this;

    function finish(err) {
      callback(err, err ? null : self.credentials);
    }

    function credError(msg, err) {
      return new AWS.util.error(err || new Error(), {
        code: 'CredentialsError', message: msg
      });
    }

    function getAsyncCredentials() {
      self.credentials.get(function(err) {
        if (err) {
          var msg = 'Could not load credentials from ' +
            self.credentials.constructor.name;
          err = credError(msg, err);
        }
        finish(err);
      });
    }

    function getStaticCredentials() {
      var err = null;
      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
        err = credError('Missing credentials');
      }
      finish(err);
    }

    if (self.credentials) {
      if (typeof self.credentials.get === 'function') {
        getAsyncCredentials();
      } else { // static credentials
        getStaticCredentials();
      }
    } else if (self.credentialProvider) {
      self.credentialProvider.resolve(function(err, creds) {
        if (err) {
          err = credError('Could not load credentials from any providers', err);
        }
        self.credentials = creds;
        finish(err);
      });
    } else {
      finish(credError('No credentials to load'));
    }
  },




  update: function update(options, allowUnknownKeys) {
    allowUnknownKeys = allowUnknownKeys || false;
    options = this.extractCredentials(options);
    AWS.util.each.call(this, options, function (key, value) {
      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
          AWS.Service.hasService(key)) {
        this.set(key, value);
      }
    });
  },


  loadFromPath: function loadFromPath(path) {
    this.clear();

    var options = JSON.parse(AWS.util.readFileSync(path));
    var fileSystemCreds = new AWS.FileSystemCredentials(path);
    var chain = new AWS.CredentialProviderChain();
    chain.providers.unshift(fileSystemCreds);
    chain.resolve(function (err, creds) {
      if (err) throw err;
      else options.credentials = creds;
    });

    this.constructor(options);

    return this;
  },


  clear: function clear() {

    AWS.util.each.call(this, this.keys, function (key) {
      delete this[key];
    });

    this.set('credentials', undefined);
    this.set('credentialProvider', undefined);
  },


  set: function set(property, value, defaultValue) {
    if (value === undefined) {
      if (defaultValue === undefined) {
        defaultValue = this.keys[property];
      }
      if (typeof defaultValue === 'function') {
        this[property] = defaultValue.call(this);
      } else {
        this[property] = defaultValue;
      }
    } else if (property === 'httpOptions' && this[property]) {
      this[property] = AWS.util.merge(this[property], value);
    } else {
      this[property] = value;
    }
  },


  keys: {
    credentials: null,
    credentialProvider: null,
    region: null,
    logger: null,
    apiVersions: {},
    apiVersion: null,
    endpoint: undefined,
    httpOptions: {
      timeout: 120000
    },
    maxRetries: undefined,
    maxRedirects: 10,
    paramValidation: true,
    sslEnabled: true,
    s3ForcePathStyle: false,
    s3BucketEndpoint: false,
    s3DisableBodySigning: true,
    computeChecksums: true,
    convertResponseTypes: true,
    correctClockSkew: false,
    customUserAgent: null,
    dynamoDbCrc32: true,
    systemClockOffset: 0,
    signatureVersion: null,
    signatureCache: true,
    retryDelayOptions: {
      base: 100
    },
    useAccelerateEndpoint: false
  },


  extractCredentials: function extractCredentials(options) {
    if (options.accessKeyId && options.secretAccessKey) {
      options = AWS.util.copy(options);
      options.credentials = new AWS.Credentials(options);
    }
    return options;
  },


  setPromisesDependency: function setPromisesDependency(dep) {
    PromisesDependency = dep;
    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
    if (AWS.S3 && AWS.S3.ManagedUpload) constructors.push(AWS.S3.ManagedUpload);
    AWS.util.addPromises(constructors, dep);
  },


  getPromisesDependency: function getPromisesDependency() {
    return PromisesDependency;
  }
});


AWS.config = new AWS.Config();

},{"./core":10,"./credentials":11,"./credentials/credential_provider_chain":13}],10:[function(require,module,exports){

var AWS = { util: require('./util') };


var _hidden = {}; _hidden.toString(); // hack to parse macro

module.exports = AWS;

AWS.util.update(AWS, {


  VERSION: '2.7.0',


  Signers: {},


  Protocol: {
    Json: require('./protocol/json'),
    Query: require('./protocol/query'),
    Rest: require('./protocol/rest'),
    RestJson: require('./protocol/rest_json'),
    RestXml: require('./protocol/rest_xml')
  },


  XML: {
    Builder: require('./xml/builder'),
    Parser: null // conditionally set based on environment
  },


  JSON: {
    Builder: require('./json/builder'),
    Parser: require('./json/parser')
  },


  Model: {
    Api: require('./model/api'),
    Operation: require('./model/operation'),
    Shape: require('./model/shape'),
    Paginator: require('./model/paginator'),
    ResourceWaiter: require('./model/resource_waiter')
  },

  util: require('./util'),


  apiLoader: function() { throw new Error('No API loader set'); }
});

require('./service');

require('./credentials');
require('./credentials/credential_provider_chain');
require('./credentials/temporary_credentials');
require('./credentials/web_identity_credentials');
require('./credentials/cognito_identity_credentials');
require('./credentials/saml_credentials');

require('./config');
require('./http');
require('./sequential_executor');
require('./event_listeners');
require('./request');
require('./response');
require('./resource_waiter');
require('./signers/request_signer');
require('./param_validator');


AWS.events = new AWS.SequentialExecutor();

},{"./config":9,"./credentials":11,"./credentials/cognito_identity_credentials":12,"./credentials/credential_provider_chain":13,"./credentials/saml_credentials":14,"./credentials/temporary_credentials":15,"./credentials/web_identity_credentials":16,"./event_listeners":17,"./http":18,"./json/builder":20,"./json/parser":21,"./model/api":22,"./model/operation":24,"./model/paginator":25,"./model/resource_waiter":26,"./model/shape":27,"./param_validator":28,"./protocol/json":29,"./protocol/query":30,"./protocol/rest":31,"./protocol/rest_json":32,"./protocol/rest_xml":33,"./request":37,"./resource_waiter":38,"./response":39,"./sequential_executor":40,"./service":41,"./signers/request_signer":45,"./util":52,"./xml/builder":54}],11:[function(require,module,exports){
var AWS = require('./core');


AWS.Credentials = AWS.util.inherit({

  constructor: function Credentials() {
    AWS.util.hideProperties(this, ['secretAccessKey']);

    this.expired = false;
    this.expireTime = null;
    if (arguments.length === 1 && typeof arguments[0] === 'object') {
      var creds = arguments[0].credentials || arguments[0];
      this.accessKeyId = creds.accessKeyId;
      this.secretAccessKey = creds.secretAccessKey;
      this.sessionToken = creds.sessionToken;
    } else {
      this.accessKeyId = arguments[0];
      this.secretAccessKey = arguments[1];
      this.sessionToken = arguments[2];
    }
  },


  expiryWindow: 15,


  needsRefresh: function needsRefresh() {
    var currentTime = AWS.util.date.getDate().getTime();
    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

    if (this.expireTime && adjustedTime > this.expireTime) {
      return true;
    } else {
      return this.expired || !this.accessKeyId || !this.secretAccessKey;
    }
  },


  get: function get(callback) {
    var self = this;
    if (this.needsRefresh()) {
      this.refresh(function(err) {
        if (!err) self.expired = false; // reset expired flag
        if (callback) callback(err);
      });
    } else if (callback) {
      callback();
    }
  },






  refresh: function refresh(callback) {
    this.expired = false;
    callback();
  }
});


AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
};


AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getPromise;
  delete this.prototype.refreshPromise;
};

AWS.util.addPromises(AWS.Credentials);

},{"./core":10}],12:[function(require,module,exports){
var AWS = require('../core');
var CognitoIdentity = require('../../clients/cognitoidentity');
var STS = require('../../clients/sts');


AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {

  localStorageKey: {
    id: 'aws.cognito.identity-id.',
    providers: 'aws.cognito.identity-providers.'
  },


  constructor: function CognitoIdentityCredentials(params) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.data = null;
    this.identityId = null;
    this.loadCachedId();
  },


  refresh: function refresh(callback) {
    var self = this;
    self.createClients();
    self.data = null;
    self.identityId = null;
    self.getId(function(err) {
      if (!err) {
        if (!self.params.RoleArn) {
          self.getCredentialsForIdentity(callback);
        } else {
          self.getCredentialsFromSTS(callback);
        }
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },


  clearCachedId: function clearCache() {
    this.identityId = null;
    delete this.params.IdentityId;

    var poolId = this.params.IdentityPoolId;
    var loginId = this.params.LoginId || '';
    delete this.storage[this.localStorageKey.id + poolId + loginId];
    delete this.storage[this.localStorageKey.providers + poolId + loginId];
  },


  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
    var self = this;
    if (err.code == 'NotAuthorizedException') {
      self.clearCachedId();
    }
  },


  getId: function getId(callback) {
    var self = this;
    if (typeof self.params.IdentityId === 'string') {
      return callback(null, self.params.IdentityId);
    }

    self.cognito.getId(function(err, data) {
      if (!err && data.IdentityId) {
        self.params.IdentityId = data.IdentityId;
        callback(null, data.IdentityId);
      } else {
        callback(err);
      }
    });
  },



  loadCredentials: function loadCredentials(data, credentials) {
    if (!data || !credentials) return;
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
  },


  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
    var self = this;
    self.cognito.getCredentialsForIdentity(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.data = data;
        self.loadCredentials(self.data, self);
      } else {
        self.clearIdOnNotAuthorized(err);
      }
      callback(err);
    });
  },


  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
    var self = this;
    self.cognito.getOpenIdToken(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.params.WebIdentityToken = data.Token;
        self.webIdentityCredentials.refresh(function(webErr) {
          if (!webErr) {
            self.data = self.webIdentityCredentials.data;
            self.sts.credentialsFrom(self.data, self);
          }
          callback(webErr);
        });
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },


  loadCachedId: function loadCachedId() {
    var self = this;

    if (AWS.util.isBrowser() && !self.params.IdentityId) {
      var id = self.getStorage('id');
      if (id && self.params.Logins) {
        var actualProviders = Object.keys(self.params.Logins);
        var cachedProviders =
          (self.getStorage('providers') || '').split(',');

        var intersect = cachedProviders.filter(function(n) {
          return actualProviders.indexOf(n) !== -1;
        });
        if (intersect.length !== 0) {
          self.params.IdentityId = id;
        }
      } else if (id) {
        self.params.IdentityId = id;
      }
    }
  },


  createClients: function() {
    this.webIdentityCredentials = this.webIdentityCredentials ||
      new AWS.WebIdentityCredentials(this.params);
    this.cognito = this.cognito ||
      new CognitoIdentity({params: this.params});
    this.sts = this.sts || new STS();
  },


  cacheId: function cacheId(data) {
    this.identityId = data.IdentityId;
    this.params.IdentityId = this.identityId;

    if (AWS.util.isBrowser()) {
      this.setStorage('id', data.IdentityId);

      if (this.params.Logins) {
        this.setStorage('providers', Object.keys(this.params.Logins).join(','));
      }
    }
  },


  getStorage: function getStorage(key) {
    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
  },


  setStorage: function setStorage(key, val) {
    try {
      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
    } catch (_) {}
  },


  storage: (function() {
    try {
      return AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ?
             window.localStorage : {};
    } catch (_) {
      return {};
    }
  })()
});

},{"../../clients/cognitoidentity":5,"../../clients/sts":6,"../core":10}],13:[function(require,module,exports){
var AWS = require('../core');


AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {


  constructor: function CredentialProviderChain(providers) {
    if (providers) {
      this.providers = providers;
    } else {
      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
    }
  },




  resolve: function resolve(callback) {
    if (this.providers.length === 0) {
      callback(new Error('No providers'));
      return this;
    }

    var index = 0;
    var providers = this.providers.slice(0);

    function resolveNext(err, creds) {
      if ((!err && creds) || index === providers.length) {
        callback(err, creds);
        return;
      }

      var provider = providers[index++];
      if (typeof provider === 'function') {
        creds = provider.call();
      } else {
        creds = provider;
      }

      if (creds.get) {
        creds.get(function(getErr) {
          resolveNext(getErr, getErr ? null : creds);
        });
      } else {
        resolveNext(null, creds);
      }
    }

    resolveNext();
    return this;
  }
});


AWS.CredentialProviderChain.defaultProviders = [];


AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
};


AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.resolvePromise;
};

AWS.util.addPromises(AWS.CredentialProviderChain);

},{"../core":10}],14:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');


AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {

  constructor: function SAMLCredentials(params) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
  },


  refresh: function refresh(callback) {
    var self = this;
    self.createClients();
    if (!callback) callback = function(err) { if (err) throw err; };

    self.service.assumeRoleWithSAML(function (err, data) {
      if (!err) {
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },


  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});

},{"../../clients/sts":6,"../core":10}],15:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');


AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {

  constructor: function TemporaryCredentials(params) {
    AWS.Credentials.call(this);
    this.loadMasterCredentials();
    this.expired = true;

    this.params = params || {};
    if (this.params.RoleArn) {
      this.params.RoleSessionName =
        this.params.RoleSessionName || 'temporary-credentials';
    }
  },


  refresh: function refresh(callback) {
    var self = this;
    self.createClients();
    if (!callback) callback = function(err) { if (err) throw err; };

    self.service.config.credentials = self.masterCredentials;
    var operation = self.params.RoleArn ?
      self.service.assumeRole : self.service.getSessionToken;
    operation.call(self.service, function (err, data) {
      if (!err) {
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },


  loadMasterCredentials: function loadMasterCredentials() {
    this.masterCredentials = AWS.config.credentials;
    while (this.masterCredentials.masterCredentials) {
      this.masterCredentials = this.masterCredentials.masterCredentials;
    }
  },


  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});

},{"../../clients/sts":6,"../core":10}],16:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');


AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {

  constructor: function WebIdentityCredentials(params) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
    this.data = null;
  },


  refresh: function refresh(callback) {
    var self = this;
    self.createClients();
    if (!callback) callback = function(err) { if (err) throw err; };

    self.service.assumeRoleWithWebIdentity(function (err, data) {
      self.data = null;
      if (!err) {
        self.data = data;
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },


  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});

},{"../../clients/sts":6,"../core":10}],17:[function(require,module,exports){
var AWS = require('./core');
var SequentialExecutor = require('./sequential_executor');


AWS.EventListeners = {

  Core: {} /* doc hack */
};

AWS.EventListeners = {
  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
    addAsync('VALIDATE_CREDENTIALS', 'validate',
        function VALIDATE_CREDENTIALS(req, done) {
      if (!req.service.api.signatureVersion) return done(); // none
      req.service.config.getCredentials(function(err) {
        if (err) {
          req.response.error = AWS.util.error(err,
            {code: 'CredentialsError', message: 'Missing credentials in config'});
        }
        done();
      });
    });

    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
      if (!req.service.config.region && !req.service.isGlobalEndpoint) {
        req.response.error = AWS.util.error(new Error(),
          {code: 'ConfigError', message: 'Missing region in config'});
      }
    });

    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
      var rules = req.service.api.operations[req.operation].input;
      var validation = req.service.config.paramValidation;
      new AWS.ParamValidator(validation).validate(rules, req.params);
    });

    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
      req.haltHandlersOnError();
      if (!req.service.api.signatureVersion) return done(); // none
      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
        var body = req.httpRequest.body || '';
        AWS.util.computeSha256(body, function(err, sha) {
          if (err) {
            done(err);
          }
          else {
            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
            done();
          }
        });
      } else {
        done();
      }
    });

    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
      if (req.httpRequest.headers['Content-Length'] === undefined) {
        var length = AWS.util.string.byteLength(req.httpRequest.body);
        req.httpRequest.headers['Content-Length'] = length;
      }
    });

    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
    });

    add('RESTART', 'restart', function RESTART() {
      var err = this.response.error;
      if (!err || !err.retryable) return;

      this.httpRequest = new AWS.HttpRequest(
        this.service.endpoint,
        this.service.region
      );

      if (this.response.retryCount < this.service.config.maxRetries) {
        this.response.retryCount++;
      } else {
        this.response.error = null;
      }
    });

    addAsync('SIGN', 'sign', function SIGN(req, done) {
      var service = req.service;
      if (!service.api.signatureVersion) return done(); // none

      service.config.getCredentials(function (err, credentials) {
        if (err) {
          req.response.error = err;
          return done();
        }

        try {
          var date = AWS.util.date.getDate();
          var SignerClass = service.getSignerClass(req);
          var signer = new SignerClass(req.httpRequest,
            service.api.signingName || service.api.endpointPrefix,
           service.config.signatureCache);
          signer.setServiceClientId(service._clientId);

          delete req.httpRequest.headers['Authorization'];
          delete req.httpRequest.headers['Date'];
          delete req.httpRequest.headers['X-Amz-Date'];

          signer.addAuthorization(credentials, date);
          req.signedAt = date;
        } catch (e) {
          req.response.error = e;
        }
        done();
      });
    });

    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
      if (this.service.successfulResponse(resp, this)) {
        resp.data = {};
        resp.error = null;
      } else {
        resp.data = null;
        resp.error = AWS.util.error(new Error(),
          {code: 'UnknownError', message: 'An unknown error occurred.'});
      }
    });

    addAsync('SEND', 'send', function SEND(resp, done) {
      resp.httpResponse._abortCallback = done;
      resp.error = null;
      resp.data = null;

      function callback(httpResp) {
        resp.httpResponse.stream = httpResp;

        httpResp.on('headers', function onHeaders(statusCode, headers) {
          resp.request.emit('httpHeaders', [statusCode, headers, resp]);

          if (!resp.httpResponse.streaming) {
            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
              httpResp.on('readable', function onReadable() {
                var data = httpResp.read();
                if (data !== null) {
                  resp.request.emit('httpData', [data, resp]);
                }
              });
            } else { // legacy streams API
              httpResp.on('data', function onData(data) {
                resp.request.emit('httpData', [data, resp]);
              });
            }
          }
        });

        httpResp.on('end', function onEnd() {
          resp.request.emit('httpDone');
          done();
        });
      }

      function progress(httpResp) {
        httpResp.on('sendProgress', function onSendProgress(value) {
          resp.request.emit('httpUploadProgress', [value, resp]);
        });

        httpResp.on('receiveProgress', function onReceiveProgress(value) {
          resp.request.emit('httpDownloadProgress', [value, resp]);
        });
      }

      function error(err) {
        resp.error = AWS.util.error(err, {
          code: 'NetworkingError',
          region: resp.request.httpRequest.region,
          hostname: resp.request.httpRequest.endpoint.hostname,
          retryable: true
        });
        resp.request.emit('httpError', [resp.error, resp], function() {
          done();
        });
      }

      function executeSend() {
        var http = AWS.HttpClient.getInstance();
        var httpOptions = resp.request.service.config.httpOptions || {};
        try {
          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
                                          callback, error);
          progress(stream);
        } catch (err) {
          error(err);
        }
      }

      var timeDiff = (AWS.util.date.getDate() - this.signedAt) / 1000;
      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
        this.emit('sign', [this], function(err) {
          if (err) done(err);
          else executeSend();
        });
      } else {
        executeSend();
      }
    });

    add('HTTP_HEADERS', 'httpHeaders',
        function HTTP_HEADERS(statusCode, headers, resp) {
      resp.httpResponse.statusCode = statusCode;
      resp.httpResponse.headers = headers;
      resp.httpResponse.body = new AWS.util.Buffer('');
      resp.httpResponse.buffers = [];
      resp.httpResponse.numBytes = 0;
      var dateHeader = headers.date || headers.Date;
      if (dateHeader) {
        var serverTime = Date.parse(dateHeader);
        if (resp.request.service.config.correctClockSkew
            && AWS.util.isClockSkewed(serverTime)) {
          AWS.util.applyClockOffset(serverTime);
        }
      }
    });

    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
      if (chunk) {
        if (AWS.util.isNode()) {
          resp.httpResponse.numBytes += chunk.length;

          var total = resp.httpResponse.headers['content-length'];
          var progress = { loaded: resp.httpResponse.numBytes, total: total };
          resp.request.emit('httpDownloadProgress', [progress, resp]);
        }

        resp.httpResponse.buffers.push(new AWS.util.Buffer(chunk));
      }
    });

    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
        resp.httpResponse.body = body;
      }
      delete resp.httpResponse.numBytes;
      delete resp.httpResponse.buffers;
    });

    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
      if (resp.httpResponse.statusCode) {
        resp.error.statusCode = resp.httpResponse.statusCode;
        if (resp.error.retryable === undefined) {
          resp.error.retryable = this.service.retryableError(resp.error, this);
        }
      }
    });

    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
      if (!resp.error) return;
      switch (resp.error.code) {
        case 'RequestExpired': // EC2 only
        case 'ExpiredTokenException':
        case 'ExpiredToken':
          resp.error.retryable = true;
          resp.request.service.config.credentials.expired = true;
      }
    });

    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
      var err = resp.error;
      if (!err) return;
      if (typeof err.code === 'string' && typeof err.message === 'string') {
        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
          resp.error.retryable = true;
        }
      }
    });

    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
      if (!resp.error) return;
      if (this.service.clockSkewError(resp.error)
          && this.service.config.correctClockSkew
          && AWS.config.isClockSkewed) {
        resp.error.retryable = true;
      }
    });

    add('REDIRECT', 'retry', function REDIRECT(resp) {
      if (resp.error && resp.error.statusCode >= 300 &&
          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
        this.httpRequest.endpoint =
          new AWS.Endpoint(resp.httpResponse.headers['location']);
        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
        resp.error.redirect = true;
        resp.error.retryable = true;
      }
    });

    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
      if (resp.error) {
        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.error.retryDelay = 0;
        } else if (resp.retryCount < resp.maxRetries) {
          resp.error.retryDelay = this.service.retryDelays(resp.retryCount) || 0;
        }
      }
    });

    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
      var delay, willRetry = false;

      if (resp.error) {
        delay = resp.error.retryDelay || 0;
        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
          resp.retryCount++;
          willRetry = true;
        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.redirectCount++;
          willRetry = true;
        }
      }

      if (willRetry) {
        resp.error = null;
        setTimeout(done, delay);
      } else {
        done();
      }
    });
  }),

  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
      if (err.code === 'NetworkingError' && err.errno === 'ENOTFOUND') {
        var message = 'Inaccessible host: `' + err.hostname +
          '\'. This service may not be available in the `' + err.region +
          '\' region.';
        this.response.error = AWS.util.error(new Error(message), {
          code: 'UnknownEndpoint',
          region: err.region,
          hostname: err.hostname,
          retryable: true,
          originalError: err
        });
      }
    });
  }),

  Logger: new SequentialExecutor().addNamedListeners(function(add) {
    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
      var req = resp.request;
      var logger = req.service.config.logger;
      if (!logger) return;

      function buildMessage() {
        var time = AWS.util.date.getDate().getTime();
        var delta = (time - req.startTime.getTime()) / 1000;
        var ansi = logger.isTTY ? true : false;
        var status = resp.httpResponse.statusCode;
        var params = require('util').inspect(req.params, true, null);

        var message = '';
        if (ansi) message += '\x1B[33m';
        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
        if (ansi) message += '\x1B[0;1m';
        message += ' ' + AWS.util.string.lowerFirst(req.operation);
        message += '(' + params + ')';
        if (ansi) message += '\x1B[0m';
        return message;
      }

      var line = buildMessage();
      if (typeof logger.log === 'function') {
        logger.log(line);
      } else if (typeof logger.write === 'function') {
        logger.write(line + '\n');
      }
    });
  }),

  Json: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/json');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Rest: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest_json');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest_xml');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Query: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/query');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  })
};

},{"./core":10,"./protocol/json":29,"./protocol/query":30,"./protocol/rest":31,"./protocol/rest_json":32,"./protocol/rest_xml":33,"./sequential_executor":40,"util":128}],18:[function(require,module,exports){
var AWS = require('./core');
var inherit = AWS.util.inherit;


AWS.Endpoint = inherit({


  constructor: function Endpoint(endpoint, config) {
    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

    if (typeof endpoint === 'undefined' || endpoint === null) {
      throw new Error('Invalid endpoint: ' + endpoint);
    } else if (typeof endpoint !== 'string') {
      return AWS.util.copy(endpoint);
    }

    if (!endpoint.match(/^http/)) {
      var useSSL = config && config.sslEnabled !== undefined ?
        config.sslEnabled : AWS.config.sslEnabled;
      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
    }

    AWS.util.update(this, AWS.util.urlParse(endpoint));

    if (this.port) {
      this.port = parseInt(this.port, 10);
    } else {
      this.port = this.protocol === 'https:' ? 443 : 80;
    }
  }

});


AWS.HttpRequest = inherit({


  constructor: function HttpRequest(endpoint, region, customUserAgent) {
    endpoint = new AWS.Endpoint(endpoint);
    this.method = 'POST';
    this.path = endpoint.path || '/';
    this.headers = {};
    this.body = '';
    this.endpoint = endpoint;
    this.region = region;
    this.setUserAgent(customUserAgent);
  },


  setUserAgent: function setUserAgent(customUserAgent) {
    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
    var customSuffix = '';
    if (typeof customUserAgent === 'string' && customUserAgent) {
      customSuffix += ' ' + customUserAgent;
    }
    this.headers[prefix + 'User-Agent'] = AWS.util.userAgent() + customSuffix;
  },


  pathname: function pathname() {
    return this.path.split('?', 1)[0];
  },


  search: function search() {
    var query = this.path.split('?', 2)[1];
    if (query) {
      query = AWS.util.queryStringParse(query);
      return AWS.util.queryParamsToString(query);
    }
    return '';
  }

});


AWS.HttpResponse = inherit({


  constructor: function HttpResponse() {
    this.statusCode = undefined;
    this.headers = {};
    this.body = undefined;
    this.streaming = false;
    this.stream = null;
  },


  createUnbufferedStream: function createUnbufferedStream() {
    this.streaming = true;
    return this.stream;
  }
});


AWS.HttpClient = inherit({});


AWS.HttpClient.getInstance = function getInstance() {
  if (this.singleton === undefined) {
    this.singleton = new this();
  }
  return this.singleton;
};

},{"./core":10}],19:[function(require,module,exports){
var AWS = require('../core');
var EventEmitter = require('events').EventEmitter;
require('../http');


AWS.XHRClient = AWS.util.inherit({
  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
    var self = this;
    var endpoint = httpRequest.endpoint;
    var emitter = new EventEmitter();
    var href = endpoint.protocol + '//' + endpoint.hostname;
    if (endpoint.port !== 80 && endpoint.port !== 443) {
      href += ':' + endpoint.port;
    }
    href += httpRequest.path;

    var xhr = new XMLHttpRequest(), headersEmitted = false;
    httpRequest.stream = xhr;

    xhr.addEventListener('readystatechange', function() {
      try {
        if (xhr.status === 0) return; // 0 code is invalid
      } catch (e) { return; }

      if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {
        try { xhr.responseType = 'arraybuffer'; } catch (e) {}
        emitter.statusCode = xhr.status;
        emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());
        emitter.emit('headers', emitter.statusCode, emitter.headers);
        headersEmitted = true;
      }
      if (this.readyState === this.DONE) {
        self.finishRequest(xhr, emitter);
      }
    }, false);
    xhr.upload.addEventListener('progress', function (evt) {
      emitter.emit('sendProgress', evt);
    });
    xhr.addEventListener('progress', function (evt) {
      emitter.emit('receiveProgress', evt);
    }, false);
    xhr.addEventListener('timeout', function () {
      errCallback(AWS.util.error(new Error('Timeout'), {code: 'TimeoutError'}));
    }, false);
    xhr.addEventListener('error', function () {
      errCallback(AWS.util.error(new Error('Network Failure'), {
        code: 'NetworkingError'
      }));
    }, false);
    /** BEGIN HOT-FIX: DO NOT REMOVE https://issues.amazon.com/issues/JS-358 */
    xhr.addEventListener('abort', function () {
      errCallback(AWS.util.error(new Error('Connection aborted'), {
        code: 'RequestAborted'
      }));
    }, false);
    /** END */

    callback(emitter);
    xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);
    AWS.util.each(httpRequest.headers, function (key, value) {
      if (key !== 'Content-Length' && key !== 'User-Agent' && key !== 'Host') {
        xhr.setRequestHeader(key, value);
      }
    });

    if (httpOptions.timeout && httpOptions.xhrAsync !== false) {
      xhr.timeout = httpOptions.timeout;
    }

    if (httpOptions.xhrWithCredentials) {
      xhr.withCredentials = true;
    }

    try {
      xhr.send(httpRequest.body);
    } catch (err) {
      if (httpRequest.body && typeof httpRequest.body.buffer === 'object') {
        xhr.send(httpRequest.body.buffer); // send ArrayBuffer directly
      } else {
        throw err;
      }
    }

    return emitter;
  },

  parseHeaders: function parseHeaders(rawHeaders) {
    var headers = {};
    AWS.util.arrayEach(rawHeaders.split(/\r?\n/), function (line) {
      var key = line.split(':', 1)[0];
      var value = line.substring(key.length + 2);
      if (key.length > 0) headers[key.toLowerCase()] = value;
    });
    return headers;
  },

  finishRequest: function finishRequest(xhr, emitter) {
    var buffer;
    if (xhr.responseType === 'arraybuffer' && xhr.response) {
      var ab = xhr.response;
      buffer = new AWS.util.Buffer(ab.byteLength);
      var view = new Uint8Array(ab);
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
      }
    }

    try {
      if (!buffer && typeof xhr.responseText === 'string') {
        buffer = new AWS.util.Buffer(xhr.responseText);
      }
    } catch (e) {}

    if (buffer) emitter.emit('data', buffer);
    emitter.emit('end');
  }
});


AWS.HttpClient.prototype = AWS.XHRClient.prototype;


AWS.HttpClient.streamsApiVersion = 1;

},{"../core":10,"../http":18,"events":65}],20:[function(require,module,exports){
var util = require('../util');

function JsonBuilder() { }

JsonBuilder.prototype.build = function(value, shape) {
  return JSON.stringify(translate(value, shape));
};

function translate(value, shape) {
  if (!shape || value === undefined || value === null) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  var struct = {};
  util.each(structure, function(name, value) {
    var memberShape = shape.members[name];
    if (memberShape) {
      if (memberShape.location !== 'body') return;
      var locationName = memberShape.isLocationName ? memberShape.name : name;
      var result = translate(value, memberShape);
      if (result !== undefined) struct[locationName] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result !== undefined) out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result !== undefined) out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toWireFormat(value);
}

module.exports = JsonBuilder;

},{"../util":52}],21:[function(require,module,exports){
var util = require('../util');

function JsonParser() { }

JsonParser.prototype.parse = function(value, shape) {
  return translate(JSON.parse(value), shape);
};

function translate(value, shape) {
  if (!shape || value === undefined) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (structure == null) return undefined;

  var struct = {};
  var shapeMembers = shape.members;
  util.each(shapeMembers, function(name, memberShape) {
    var locationName = memberShape.isLocationName ? memberShape.name : name;
    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
      var value = structure[locationName];
      var result = translate(value, memberShape);
      if (result !== undefined) struct[name] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  if (list == null) return undefined;

  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result === undefined) out.push(null);
    else out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  if (map == null) return undefined;

  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result === undefined) out[key] = null;
    else out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toType(value);
}

module.exports = JsonParser;

},{"../util":52}],22:[function(require,module,exports){
var Collection = require('./collection');
var Operation = require('./operation');
var Shape = require('./shape');
var Paginator = require('./paginator');
var ResourceWaiter = require('./resource_waiter');

var util = require('../util');
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Api(api, options) {
  api = api || {};
  options = options || {};
  options.api = this;

  api.metadata = api.metadata || {};

  property(this, 'isApi', true, false);
  property(this, 'apiVersion', api.metadata.apiVersion);
  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
  property(this, 'signingName', api.metadata.signingName);
  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
  property(this, 'signatureVersion', api.metadata.signatureVersion);
  property(this, 'jsonVersion', api.metadata.jsonVersion);
  property(this, 'targetPrefix', api.metadata.targetPrefix);
  property(this, 'protocol', api.metadata.protocol);
  property(this, 'timestampFormat', api.metadata.timestampFormat);
  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
  property(this, 'fullName', api.metadata.serviceFullName);

  memoizedProperty(this, 'className', function() {
    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
    if (!name) return null;

    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
    if (name === 'ElasticLoadBalancing') name = 'ELB';
    return name;
  });

  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
    return new Operation(name, operation, options);
  }, util.string.lowerFirst));

  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
    return Shape.create(shape, options);
  }));

  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
    return new Paginator(name, paginator, options);
  }));

  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
    return new ResourceWaiter(name, waiter, options);
  }, util.string.lowerFirst));

  if (options.documentation) {
    property(this, 'documentation', api.documentation);
    property(this, 'documentationUrl', api.documentationUrl);
  }
}

module.exports = Api;

},{"../util":52,"./collection":23,"./operation":24,"./paginator":25,"./resource_waiter":26,"./shape":27}],23:[function(require,module,exports){
var memoizedProperty = require('../util').memoizedProperty;

function memoize(name, value, fn, nameTr) {
  memoizedProperty(this, nameTr(name), function() {
    return fn(name, value);
  });
}

function Collection(iterable, options, fn, nameTr) {
  nameTr = nameTr || String;
  var self = this;

  for (var id in iterable) {
    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
      memoize.call(self, id, iterable[id], fn, nameTr);
    }
  }
}

module.exports = Collection;

},{"../util":52}],24:[function(require,module,exports){
var Shape = require('./shape');

var util = require('../util');
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Operation(name, operation, options) {
  options = options || {};

  property(this, 'name', operation.name || name);
  property(this, 'api', options.api, false);

  operation.http = operation.http || {};
  property(this, 'httpMethod', operation.http.method || 'POST');
  property(this, 'httpPath', operation.http.requestUri || '/');
  property(this, 'authtype', operation.authtype || '');

  memoizedProperty(this, 'input', function() {
    if (!operation.input) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.input, options);
  });

  memoizedProperty(this, 'output', function() {
    if (!operation.output) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.output, options);
  });

  memoizedProperty(this, 'errors', function() {
    var list = [];
    if (!operation.errors) return null;

    for (var i = 0; i < operation.errors.length; i++) {
      list.push(Shape.create(operation.errors[i], options));
    }

    return list;
  });

  memoizedProperty(this, 'paginator', function() {
    return options.api.paginators[name];
  });

  if (options.documentation) {
    property(this, 'documentation', operation.documentation);
    property(this, 'documentationUrl', operation.documentationUrl);
  }
}

module.exports = Operation;

},{"../util":52,"./shape":27}],25:[function(require,module,exports){
var property = require('../util').property;

function Paginator(name, paginator) {
  property(this, 'inputToken', paginator.input_token);
  property(this, 'limitKey', paginator.limit_key);
  property(this, 'moreResults', paginator.more_results);
  property(this, 'outputToken', paginator.output_token);
  property(this, 'resultKey', paginator.result_key);
}

module.exports = Paginator;

},{"../util":52}],26:[function(require,module,exports){
var util = require('../util');
var property = util.property;

function ResourceWaiter(name, waiter, options) {
  options = options || {};
  property(this, 'name', name);
  property(this, 'api', options.api, false);

  if (waiter.operation) {
    property(this, 'operation', util.string.lowerFirst(waiter.operation));
  }

  var self = this;
  var keys = [
    'type',
    'description',
    'delay',
    'maxAttempts',
    'acceptors'
  ];

  keys.forEach(function(key) {
    var value = waiter[key];
    if (value) {
      property(self, key, value);
    }
  });
}

module.exports = ResourceWaiter;

},{"../util":52}],27:[function(require,module,exports){
var Collection = require('./collection');

var util = require('../util');

function property(obj, name, value) {
  if (value !== null && value !== undefined) {
    util.property.apply(this, arguments);
  }
}

function memoizedProperty(obj, name) {
  if (!obj.constructor.prototype[name]) {
    util.memoizedProperty.apply(this, arguments);
  }
}

function Shape(shape, options, memberName) {
  options = options || {};

  property(this, 'shape', shape.shape);
  property(this, 'api', options.api, false);
  property(this, 'type', shape.type);
  property(this, 'enum', shape.enum);
  property(this, 'min', shape.min);
  property(this, 'max', shape.max);
  property(this, 'pattern', shape.pattern);
  property(this, 'location', shape.location || this.location || 'body');
  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
    shape.locationName || memberName);
  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
  property(this, 'isComposite', shape.isComposite || false);
  property(this, 'isShape', true, false);
  property(this, 'isQueryName', shape.queryName ? true : false, false);
  property(this, 'isLocationName', shape.locationName ? true : false, false);

  if (options.documentation) {
    property(this, 'documentation', shape.documentation);
    property(this, 'documentationUrl', shape.documentationUrl);
  }

  if (shape.xmlAttribute) {
    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
  }

  property(this, 'defaultValue', null);
  this.toWireFormat = function(value) {
    if (value === null || value === undefined) return '';
    return value;
  };
  this.toType = function(value) { return value; };
}


Shape.normalizedTypes = {
  character: 'string',
  double: 'float',
  long: 'integer',
  short: 'integer',
  biginteger: 'integer',
  bigdecimal: 'float',
  blob: 'binary'
};


Shape.types = {
  'structure': StructureShape,
  'list': ListShape,
  'map': MapShape,
  'boolean': BooleanShape,
  'timestamp': TimestampShape,
  'float': FloatShape,
  'integer': IntegerShape,
  'string': StringShape,
  'base64': Base64Shape,
  'binary': BinaryShape
};

Shape.resolve = function resolve(shape, options) {
  if (shape.shape) {
    var refShape = options.api.shapes[shape.shape];
    if (!refShape) {
      throw new Error('Cannot find shape reference: ' + shape.shape);
    }

    return refShape;
  } else {
    return null;
  }
};

Shape.create = function create(shape, options, memberName) {
  if (shape.isShape) return shape;

  var refShape = Shape.resolve(shape, options);
  if (refShape) {
    var filteredKeys = Object.keys(shape);
    if (!options.documentation) {
      filteredKeys = filteredKeys.filter(function(name) {
        return !name.match(/documentation/);
      });
    }
    if (filteredKeys === ['shape']) { // no inline customizations
      return refShape;
    }

    var InlineShape = function() {
      refShape.constructor.call(this, shape, options, memberName);
    };
    InlineShape.prototype = refShape;
    return new InlineShape();
  } else {
    if (!shape.type) {
      if (shape.members) shape.type = 'structure';
      else if (shape.member) shape.type = 'list';
      else if (shape.key) shape.type = 'map';
      else shape.type = 'string';
    }

    var origType = shape.type;
    if (Shape.normalizedTypes[shape.type]) {
      shape.type = Shape.normalizedTypes[shape.type];
    }

    if (Shape.types[shape.type]) {
      return new Shape.types[shape.type](shape, options, memberName);
    } else {
      throw new Error('Unrecognized shape type: ' + origType);
    }
  }
};

function CompositeShape(shape) {
  Shape.apply(this, arguments);
  property(this, 'isComposite', true);

  if (shape.flattened) {
    property(this, 'flattened', shape.flattened || false);
  }
}

function StructureShape(shape, options) {
  var requiredMap = null, firstInit = !this.isShape;

  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'members', {});
    property(this, 'memberNames', []);
    property(this, 'required', []);
    property(this, 'isRequired', function() { return false; });
  }

  if (shape.members) {
    property(this, 'members', new Collection(shape.members, options, function(name, member) {
      return Shape.create(member, options, name);
    }));
    memoizedProperty(this, 'memberNames', function() {
      return shape.xmlOrder || Object.keys(shape.members);
    });
  }

  if (shape.required) {
    property(this, 'required', shape.required);
    property(this, 'isRequired', function(name) {
      if (!requiredMap) {
        requiredMap = {};
        for (var i = 0; i < shape.required.length; i++) {
          requiredMap[shape.required[i]] = true;
        }
      }

      return requiredMap[name];
    }, false, true);
  }

  property(this, 'resultWrapper', shape.resultWrapper || null);

  if (shape.payload) {
    property(this, 'payload', shape.payload);
  }

  if (typeof shape.xmlNamespace === 'string') {
    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
  } else if (typeof shape.xmlNamespace === 'object') {
    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
  }
}

function ListShape(shape, options) {
  var self = this, firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return []; });
  }

  if (shape.member) {
    memoizedProperty(this, 'member', function() {
      return Shape.create(shape.member, options);
    });
  }

  if (this.flattened) {
    var oldName = this.name;
    memoizedProperty(this, 'name', function() {
      return self.member.name || oldName;
    });
  }
}

function MapShape(shape, options) {
  var firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'key', Shape.create({type: 'string'}, options));
    property(this, 'value', Shape.create({type: 'string'}, options));
  }

  if (shape.key) {
    memoizedProperty(this, 'key', function() {
      return Shape.create(shape.key, options);
    });
  }
  if (shape.value) {
    memoizedProperty(this, 'value', function() {
      return Shape.create(shape.value, options);
    });
  }
}

function TimestampShape(shape) {
  var self = this;
  Shape.apply(this, arguments);

  if (this.location === 'header') {
    property(this, 'timestampFormat', 'rfc822');
  } else if (shape.timestampFormat) {
    property(this, 'timestampFormat', shape.timestampFormat);
  } else if (this.api) {
    if (this.api.timestampFormat) {
      property(this, 'timestampFormat', this.api.timestampFormat);
    } else {
      switch (this.api.protocol) {
        case 'json':
        case 'rest-json':
          property(this, 'timestampFormat', 'unixTimestamp');
          break;
        case 'rest-xml':
        case 'query':
        case 'ec2':
          property(this, 'timestampFormat', 'iso8601');
          break;
      }
    }
  }

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    if (typeof value.toUTCString === 'function') return value;
    return typeof value === 'string' || typeof value === 'number' ?
           util.date.parseTimestamp(value) : null;
  };

  this.toWireFormat = function(value) {
    return util.date.format(value, self.timestampFormat);
  };
}

function StringShape() {
  Shape.apply(this, arguments);

  if (this.api) {
    switch (this.api.protocol) {
      case 'rest-xml':
      case 'query':
      case 'ec2':
        this.toType = function(value) { return value || ''; };
    }
  }
}

function FloatShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseFloat(value);
  };
  this.toWireFormat = this.toType;
}

function IntegerShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseInt(value, 10);
  };
  this.toWireFormat = this.toType;
}

function BinaryShape() {
  Shape.apply(this, arguments);
  this.toType = util.base64.decode;
  this.toWireFormat = util.base64.encode;
}

function Base64Shape() {
  BinaryShape.apply(this, arguments);
}

function BooleanShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (typeof value === 'boolean') return value;
    if (value === null || value === undefined) return null;
    return value === 'true';
  };
}


Shape.shapes = {
  StructureShape: StructureShape,
  ListShape: ListShape,
  MapShape: MapShape,
  StringShape: StringShape,
  BooleanShape: BooleanShape,
  Base64Shape: Base64Shape
};

module.exports = Shape;

},{"../util":52,"./collection":23}],28:[function(require,module,exports){
var AWS = require('./core');


AWS.ParamValidator = AWS.util.inherit({

  constructor: function ParamValidator(validation) {
    if (validation === true || validation === undefined) {
      validation = {'min': true};
    }
    this.validation = validation;
  },

  validate: function validate(shape, params, context) {
    this.errors = [];
    this.validateMember(shape, params || {}, context || 'params');

    if (this.errors.length > 1) {
      var msg = this.errors.join('\n* ');
      msg = 'There were ' + this.errors.length +
        ' validation errors:\n* ' + msg;
      throw AWS.util.error(new Error(msg),
        {code: 'MultipleValidationErrors', errors: this.errors});
    } else if (this.errors.length === 1) {
      throw this.errors[0];
    } else {
      return true;
    }
  },

  fail: function fail(code, message) {
    this.errors.push(AWS.util.error(new Error(message), {code: code}));
  },

  validateStructure: function validateStructure(shape, params, context) {
    this.validateType(params, context, ['object'], 'structure');

    var paramName;
    for (var i = 0; shape.required && i < shape.required.length; i++) {
      paramName = shape.required[i];
      var value = params[paramName];
      if (value === undefined || value === null) {
        this.fail('MissingRequiredParameter',
          'Missing required key \'' + paramName + '\' in ' + context);
      }
    }

    for (paramName in params) {
      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;

      var paramValue = params[paramName],
          memberShape = shape.members[paramName];

      if (memberShape !== undefined) {
        var memberContext = [context, paramName].join('.');
        this.validateMember(memberShape, paramValue, memberContext);
      } else {
        this.fail('UnexpectedParameter',
          'Unexpected key \'' + paramName + '\' found in ' + context);
      }
    }

    return true;
  },

  validateMember: function validateMember(shape, param, context) {
    switch (shape.type) {
      case 'structure':
        return this.validateStructure(shape, param, context);
      case 'list':
        return this.validateList(shape, param, context);
      case 'map':
        return this.validateMap(shape, param, context);
      default:
        return this.validateScalar(shape, param, context);
    }
  },

  validateList: function validateList(shape, params, context) {
    if (this.validateType(params, context, [Array])) {
      this.validateRange(shape, params.length, context, 'list member count');
      for (var i = 0; i < params.length; i++) {
        this.validateMember(shape.member, params[i], context + '[' + i + ']');
      }
    }
  },

  validateMap: function validateMap(shape, params, context) {
    if (this.validateType(params, context, ['object'], 'map')) {
      var mapCount = 0;
      for (var param in params) {
        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
        this.validateMember(shape.key, param,
                            context + '[key=\'' + param + '\']')
        this.validateMember(shape.value, params[param],
                            context + '[\'' + param + '\']');
        mapCount++;
      }
      this.validateRange(shape, mapCount, context, 'map member count');
    }
  },

  validateScalar: function validateScalar(shape, value, context) {
    switch (shape.type) {
      case null:
      case undefined:
      case 'string':
        return this.validateString(shape, value, context);
      case 'base64':
      case 'binary':
        return this.validatePayload(value, context);
      case 'integer':
      case 'float':
        return this.validateNumber(shape, value, context);
      case 'boolean':
        return this.validateType(value, context, ['boolean']);
      case 'timestamp':
        return this.validateType(value, context, [Date,
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
          'Date object, ISO-8601 string, or a UNIX timestamp');
      default:
        return this.fail('UnkownType', 'Unhandled type ' +
                         shape.type + ' for ' + context);
    }
  },

  validateString: function validateString(shape, value, context) {
    if (this.validateType(value, context, ['string'])) {
      this.validateEnum(shape, value, context);
      this.validateRange(shape, value.length, context, 'string length');
      this.validatePattern(shape, value, context);
    }
  },

  validatePattern: function validatePattern(shape, value, context) {
    if (this.validation['pattern'] && shape['pattern'] !== undefined) {
      if (!(new RegExp(shape['pattern'])).test(value)) {
        this.fail('PatternMatchError', 'Provided value "' + value + '" '
          + 'does not match regex pattern /' + shape['pattern'] + '/ for '
          + context);
      }
    }
  },

  validateRange: function validateRange(shape, value, context, descriptor) {
    if (this.validation['min']) {
      if (shape['min'] !== undefined && value < shape['min']) {
        this.fail('MinRangeError', 'Expected ' + descriptor + ' >= '
          + shape['min'] + ', but found ' + value + ' for ' + context);
      }
    }
    if (this.validation['max']) {
      if (shape['max'] !== undefined && value > shape['max']) {
        this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= '
          + shape['max'] + ', but found ' + value + ' for ' + context);
      }
    }
  },

  validateEnum: function validateRange(shape, value, context) {
    if (this.validation['enum'] && shape['enum'] !== undefined) {
      if (shape['enum'].indexOf(value) === -1) {
        this.fail('EnumError', 'Found string value of ' + value + ', but '
          + 'expected ' + shape['enum'].join('|') + ' for ' + context);
      }
    }
  },

  validateType: function validateType(value, context, acceptedTypes, type) {
    if (value === null || value === undefined) return false;

    var foundInvalidType = false;
    for (var i = 0; i < acceptedTypes.length; i++) {
      if (typeof acceptedTypes[i] === 'string') {
        if (typeof value === acceptedTypes[i]) return true;
      } else if (acceptedTypes[i] instanceof RegExp) {
        if ((value || '').toString().match(acceptedTypes[i])) return true;
      } else {
        if (value instanceof acceptedTypes[i]) return true;
        if (AWS.util.isType(value, acceptedTypes[i])) return true;
        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
      }
      foundInvalidType = true;
    }

    var acceptedType = type;
    if (!acceptedType) {
      acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
    }

    var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +
              vowel + ' ' + acceptedType);
    return false;
  },

  validateNumber: function validateNumber(shape, value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') {
      var castedValue = parseFloat(value);
      if (castedValue.toString() === value) value = castedValue;
    }
    if (this.validateType(value, context, ['number'])) {
      this.validateRange(shape, value, context, 'numeric value');
    }
  },

  validatePayload: function validatePayload(value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') return;
    if (value && typeof value.byteLength === 'number') return; // typed arrays
    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js
      var Stream = AWS.util.stream.Stream;
      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
    }

    var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
    if (value) {
      for (var i = 0; i < types.length; i++) {
        if (AWS.util.isType(value, types[i])) return;
        if (AWS.util.typeName(value.constructor) === types[i]) return;
      }
    }

    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +
      'string, Buffer, Stream, Blob, or typed array object');
  }
});

},{"./core":10}],29:[function(require,module,exports){
var util = require('../util');
var JsonBuilder = require('../json/builder');
var JsonParser = require('../json/parser');

function buildRequest(req) {
  var httpRequest = req.httpRequest;
  var api = req.service.api;
  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
  var version = api.jsonVersion || '1.0';
  var input = api.operations[req.operation].input;
  var builder = new JsonBuilder();

  if (version === 1) version = '1.0';
  httpRequest.body = builder.build(req.params || {}, input);
  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
  httpRequest.headers['X-Amz-Target'] = target;
}

function extractError(resp) {
  var error = {};
  var httpResponse = resp.httpResponse;

  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
  if (typeof error.code === 'string') {
    error.code = error.code.split(':')[0];
  }

  if (httpResponse.body.length > 0) {
    var e = JSON.parse(httpResponse.body.toString());
    if (e.__type || e.code) {
      error.code = (e.__type || e.code).split('#').pop();
    }
    if (error.code === 'RequestEntityTooLarge') {
      error.message = 'Request body must be less than 1 MB';
    } else {
      error.message = (e.message || e.Message || null);
    }
  } else {
    error.statusCode = httpResponse.statusCode;
    error.message = httpResponse.statusCode.toString();
  }

  resp.error = util.error(new Error(), error);
}

function extractData(resp) {
  var body = resp.httpResponse.body.toString() || '{}';
  if (resp.request.service.config.convertResponseTypes === false) {
    resp.data = JSON.parse(body);
  } else {
    var operation = resp.request.service.api.operations[resp.request.operation];
    var shape = operation.output || {};
    var parser = new JsonParser();
    resp.data = parser.parse(body, shape);
  }
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../json/builder":20,"../json/parser":21,"../util":52}],30:[function(require,module,exports){
var AWS = require('../core');
var util = require('../util');
var QueryParamSerializer = require('../query/query_param_serializer');
var Shape = require('../model/shape');

function buildRequest(req) {
  var operation = req.service.api.operations[req.operation];
  var httpRequest = req.httpRequest;
  httpRequest.headers['Content-Type'] =
    'application/x-www-form-urlencoded; charset=utf-8';
  httpRequest.params = {
    Version: req.service.api.apiVersion,
    Action: operation.name
  };

  var builder = new QueryParamSerializer();
  builder.serialize(req.params, operation.input, function(name, value) {
    httpRequest.params[name] = value;
  });
  httpRequest.body = util.queryParamsToString(httpRequest.params);
}

function extractError(resp) {
  var data, body = resp.httpResponse.body.toString();
  if (body.match('<UnknownOperationException')) {
    data = {
      Code: 'UnknownOperation',
      Message: 'Unknown operation ' + resp.request.operation
    };
  } else {
    data = new AWS.XML.Parser().parse(body);
  }

  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var shape = operation.output || {};
  var origRules = shape;

  if (origRules.resultWrapper) {
    var tmp = Shape.create({type: 'structure'});
    tmp.members[origRules.resultWrapper] = shape;
    tmp.memberNames = [origRules.resultWrapper];
    util.property(shape, 'name', shape.resultWrapper);
    shape = tmp;
  }

  var parser = new AWS.XML.Parser();

  if (shape && shape.members && !shape.members._XAMZRequestId) {
    var requestIdShape = Shape.create(
      { type: 'string' },
      { api: { protocol: 'query' } },
      'requestId'
    );
    shape.members._XAMZRequestId = requestIdShape;
  }

  var data = parser.parse(resp.httpResponse.body.toString(), shape);
  resp.requestId = data._XAMZRequestId || data.requestId;

  if (data._XAMZRequestId) delete data._XAMZRequestId;

  if (origRules.resultWrapper) {
    if (data[origRules.resultWrapper]) {
      util.update(data, data[origRules.resultWrapper]);
      delete data[origRules.resultWrapper];
    }
  }

  resp.data = data;
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../core":10,"../model/shape":27,"../query/query_param_serializer":34,"../util":52}],31:[function(require,module,exports){
var util = require('../util');

function populateMethod(req) {
  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
}

function populateURI(req) {
  var operation = req.service.api.operations[req.operation];
  var input = operation.input;
  var uri = [req.httpRequest.endpoint.path, operation.httpPath].join('/');
  uri = uri.replace(/\/+/g, '/');

  var queryString = {}, queryStringSet = false;
  util.each(input.members, function (name, member) {
    var paramValue = req.params[name];
    if (paramValue === null || paramValue === undefined) return;
    if (member.location === 'uri') {
      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
      uri = uri.replace(regex, function(_, plus) {
        var fn = plus ? util.uriEscapePath : util.uriEscape;
        return fn(String(paramValue));
      });
    } else if (member.location === 'querystring') {
      queryStringSet = true;

      if (member.type === 'list') {
        queryString[member.name] = paramValue.map(function(val) {
          return util.uriEscape(String(val));
        });
      } else if (member.type === 'map') {
        util.each(paramValue, function(key, value) {
          if (Array.isArray(value)) {
            queryString[key] = value.map(function(val) {
              return util.uriEscape(String(val));
            });
          } else {
            queryString[key] = util.uriEscape(String(value));
          }
        });
      } else {
        queryString[member.name] = util.uriEscape(String(paramValue));
      }
    }
  });

  if (queryStringSet) {
    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
    var parts = [];
    util.arrayEach(Object.keys(queryString).sort(), function(key) {
      if (!Array.isArray(queryString[key])) {
        queryString[key] = [queryString[key]];
      }
      for (var i = 0; i < queryString[key].length; i++) {
        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
      }
    });
    uri += parts.join('&');
  }

  req.httpRequest.path = uri;
}

function populateHeaders(req) {
  var operation = req.service.api.operations[req.operation];
  util.each(operation.input.members, function (name, member) {
    var value = req.params[name];
    if (value === null || value === undefined) return;

    if (member.location === 'headers' && member.type === 'map') {
      util.each(value, function(key, memberValue) {
        req.httpRequest.headers[member.name + key] = memberValue;
      });
    } else if (member.location === 'header') {
      value = member.toWireFormat(value).toString();
      req.httpRequest.headers[member.name] = value;
    }
  });
}

function buildRequest(req) {
  populateMethod(req);
  populateURI(req);
  populateHeaders(req);
}

function extractError() {
}

function extractData(resp) {
  var req = resp.request;
  var data = {};
  var r = resp.httpResponse;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  var headers = {};
  util.each(r.headers, function (k, v) {
    headers[k.toLowerCase()] = v;
  });

  util.each(output.members, function(name, member) {
    var header = (member.name || name).toLowerCase();
    if (member.location === 'headers' && member.type === 'map') {
      data[name] = {};
      var location = member.isLocationName ? member.name : '';
      var pattern = new RegExp('^' + location + '(.+)', 'i');
      util.each(r.headers, function (k, v) {
        var result = k.match(pattern);
        if (result !== null) {
          data[name][result[1]] = v;
        }
      });
    } else if (member.location === 'header') {
      if (headers[header] !== undefined) {
        data[name] = headers[header];
      }
    } else if (member.location === 'statusCode') {
      data[name] = parseInt(r.statusCode, 10);
    }
  });

  resp.data = data;
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../util":52}],32:[function(require,module,exports){
var util = require('../util');
var Rest = require('./rest');
var Json = require('./json');
var JsonBuilder = require('../json/builder');
var JsonParser = require('../json/parser');

function populateBody(req) {
  var builder = new JsonBuilder();
  var input = req.service.api.operations[req.operation].input;

  if (input.payload) {
    var params = {};
    var payloadShape = input.members[input.payload];
    params = req.params[input.payload];
    if (params === undefined) return;

    if (payloadShape.type === 'structure') {
      req.httpRequest.body = builder.build(params, payloadShape);
    } else { // non-JSON payload
      req.httpRequest.body = params;
    }
  } else {
    req.httpRequest.body = builder.build(req.params, input);
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  if (['GET', 'HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Json.extractError(resp);
}

function extractData(resp) {
  Rest.extractData(resp);

  var req = resp.request;
  var rules = req.service.api.operations[req.operation].output || {};
  if (rules.payload) {
    var payloadMember = rules.members[rules.payload];
    var body = resp.httpResponse.body;
    if (payloadMember.isStreaming) {
      resp.data[rules.payload] = body;
    } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
      var parser = new JsonParser();
      resp.data[rules.payload] = parser.parse(body, payloadMember);
    } else {
      resp.data[rules.payload] = body.toString();
    }
  } else {
    var data = resp.data;
    Json.extractData(resp);
    resp.data = util.merge(data, resp.data);
  }
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../json/builder":20,"../json/parser":21,"../util":52,"./json":29,"./rest":31}],33:[function(require,module,exports){
var AWS = require('../core');
var util = require('../util');
var Rest = require('./rest');

function populateBody(req) {
  var input = req.service.api.operations[req.operation].input;
  var builder = new AWS.XML.Builder();
  var params = req.params;

  var payload = input.payload;
  if (payload) {
    var payloadMember = input.members[payload];
    params = params[payload];
    if (params === undefined) return;

    if (payloadMember.type === 'structure') {
      var rootElement = payloadMember.name;
      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
    } else { // non-xml payload
      req.httpRequest.body = params;
    }
  } else {
    req.httpRequest.body = builder.toXML(params, input, input.name ||
      input.shape || util.string.upperFirst(req.operation) + 'Request');
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Rest.extractError(resp);

  var data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  Rest.extractData(resp);

  var parser;
  var req = resp.request;
  var body = resp.httpResponse.body;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  var payload = output.payload;
  if (payload) {
    var payloadMember = output.members[payload];
    if (payloadMember.isStreaming) {
      resp.data[payload] = body;
    } else if (payloadMember.type === 'structure') {
      parser = new AWS.XML.Parser();
      resp.data[payload] = parser.parse(body.toString(), payloadMember);
    } else {
      resp.data[payload] = body.toString();
    }
  } else if (body.length > 0) {
    parser = new AWS.XML.Parser();
    var data = parser.parse(body.toString(), output);
    util.update(resp.data, data);
  }
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../core":10,"../util":52,"./rest":31}],34:[function(require,module,exports){
var util = require('../util');

function QueryParamSerializer() {
}

QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
  serializeStructure('', params, shape, fn);
};

function ucfirst(shape) {
  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
    return shape.name;
  } else {
    return shape.name[0].toUpperCase() + shape.name.substr(1);
  }
}

function serializeStructure(prefix, struct, rules, fn) {
  util.each(rules.members, function(name, member) {
    var value = struct[name];
    if (value === null || value === undefined) return;

    var memberName = ucfirst(member);
    memberName = prefix ? prefix + '.' + memberName : memberName;
    serializeMember(memberName, value, member, fn);
  });
}

function serializeMap(name, map, rules, fn) {
  var i = 1;
  util.each(map, function (key, value) {
    var prefix = rules.flattened ? '.' : '.entry.';
    var position = prefix + (i++) + '.';
    var keyName = position + (rules.key.name || 'key');
    var valueName = position + (rules.value.name || 'value');
    serializeMember(name + keyName, key, rules.key, fn);
    serializeMember(name + valueName, value, rules.value, fn);
  });
}

function serializeList(name, list, rules, fn) {
  var memberRules = rules.member || {};

  if (list.length === 0) {
    fn.call(this, name, null);
    return;
  }

  util.arrayEach(list, function (v, n) {
    var suffix = '.' + (n + 1);
    if (rules.api.protocol === 'ec2') {
      suffix = suffix + ''; // make linter happy
    } else if (rules.flattened) {
      if (memberRules.name) {
        var parts = name.split('.');
        parts.pop();
        parts.push(ucfirst(memberRules));
        name = parts.join('.');
      }
    } else {
      suffix = '.member' + suffix;
    }
    serializeMember(name + suffix, v, memberRules, fn);
  });
}

function serializeMember(name, value, rules, fn) {
  if (value === null || value === undefined) return;
  if (rules.type === 'structure') {
    serializeStructure(name, value, rules, fn);
  } else if (rules.type === 'list') {
    serializeList(name, value, rules, fn);
  } else if (rules.type === 'map') {
    serializeMap(name, value, rules, fn);
  } else {
    fn(name, rules.toWireFormat(value).toString());
  }
}

module.exports = QueryParamSerializer;

},{"../util":52}],35:[function(require,module,exports){
module.exports={
  "rules": {
    "*/*": {
      "endpoint": "{service}.{region}.amazonaws.com"
    },
    "cn-*/*": {
      "endpoint": "{service}.{region}.amazonaws.com.cn"
    },
    "*/budgets": "globalSSL",
    "*/cloudfront": "globalSSL",
    "*/iam": "globalSSL",
    "*/sts": "globalSSL",
    "*/importexport": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "v2",
      "globalEndpoint": true
    },
    "*/route53": {
      "endpoint": "https://{service}.amazonaws.com",
      "signatureVersion": "v3https",
      "globalEndpoint": true
    },
    "*/waf": "globalSSL",
    "us-gov-*/iam": "globalGovCloud",
    "us-gov-*/sts": {
      "endpoint": "{service}.{region}.amazonaws.com"
    },
    "us-gov-west-1/s3": "s3dash",
    "us-west-1/s3": "s3dash",
    "us-west-2/s3": "s3dash",
    "eu-west-1/s3": "s3dash",
    "ap-southeast-1/s3": "s3dash",
    "ap-southeast-2/s3": "s3dash",
    "ap-northeast-1/s3": "s3dash",
    "sa-east-1/s3": "s3dash",
    "us-east-1/s3": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "s3"
    },
    "us-east-1/sdb": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "v2"
    },
    "*/sdb": {
      "endpoint": "{service}.{region}.amazonaws.com",
      "signatureVersion": "v2"
    }
  },

  "patterns": {
    "globalSSL": {
      "endpoint": "https://{service}.amazonaws.com",
      "globalEndpoint": true
    },
    "globalGovCloud": {
      "endpoint": "{service}.us-gov.amazonaws.com"
    },
    "s3dash": {
      "endpoint": "{service}-{region}.amazonaws.com",
      "signatureVersion": "s3"
    }
  }
}

},{}],36:[function(require,module,exports){
var util = require('./util');
var regionConfig = require('./region_config.json');

function generateRegionPrefix(region) {
  if (!region) return null;

  var parts = region.split('-');
  if (parts.length < 3) return null;
  return parts.slice(0, parts.length - 2).join('-') + '-*';
}

function derivedKeys(service) {
  var region = service.config.region;
  var regionPrefix = generateRegionPrefix(region);
  var endpointPrefix = service.api.endpointPrefix;

  return [
    [region, endpointPrefix],
    [regionPrefix, endpointPrefix],
    [region, '*'],
    [regionPrefix, '*'],
    ['*', endpointPrefix],
    ['*', '*']
  ].map(function(item) {
    return item[0] && item[1] ? item.join('/') : null;
  });
}

function applyConfig(service, config) {
  util.each(config, function(key, value) {
    if (key === 'globalEndpoint') return;
    if (service.config[key] === undefined || service.config[key] === null) {
      service.config[key] = value;
    }
  });
}

function configureEndpoint(service) {
  var keys = derivedKeys(service);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!key) continue;

    if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {
      var config = regionConfig.rules[key];
      if (typeof config === 'string') {
        config = regionConfig.patterns[config];
      }

      if (service.config.useDualstack && util.isDualstackAvailable(service)) {
        config = util.copy(config);
        config.endpoint = '{service}.dualstack.{region}.amazonaws.com';
      }

      service.isGlobalEndpoint = !!config.globalEndpoint;

      if (!config.signatureVersion) config.signatureVersion = 'v4';

      applyConfig(service, config);
      return;
    }
  }
}

module.exports = configureEndpoint;

},{"./region_config.json":35,"./util":52}],37:[function(require,module,exports){
(function (process){
var AWS = require('./core');
var AcceptorStateMachine = require('./state_machine');
var inherit = AWS.util.inherit;
var domain = AWS.util.domain;
var jmespath = require('jmespath');


var hardErrorStates = {success: 1, error: 1, complete: 1};

function isTerminalState(machine) {
  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
}

var fsm = new AcceptorStateMachine();
fsm.setupStates = function() {
  var transition = function(_, done) {
    var self = this;
    self._haltHandlersOnError = false;

    self.emit(self._asm.currentState, function(err) {
      if (err) {
        if (isTerminalState(self)) {
          if (domain && self.domain instanceof domain.Domain) {
            err.domainEmitter = self;
            err.domain = self.domain;
            err.domainThrown = false;
            self.domain.emit('error', err);
          } else {
            throw err;
          }
        } else {
          self.response.error = err;
          done(err);
        }
      } else {
        done(self.response.error);
      }
    });

  };

  this.addState('validate', 'build', 'error', transition);
  this.addState('build', 'afterBuild', 'restart', transition);
  this.addState('afterBuild', 'sign', 'restart', transition);
  this.addState('sign', 'send', 'retry', transition);
  this.addState('retry', 'afterRetry', 'afterRetry', transition);
  this.addState('afterRetry', 'sign', 'error', transition);
  this.addState('send', 'validateResponse', 'retry', transition);
  this.addState('validateResponse', 'extractData', 'extractError', transition);
  this.addState('extractError', 'extractData', 'retry', transition);
  this.addState('extractData', 'success', 'retry', transition);
  this.addState('restart', 'build', 'error', transition);
  this.addState('success', 'complete', 'complete', transition);
  this.addState('error', 'complete', 'complete', transition);
  this.addState('complete', null, null, transition);
};
fsm.setupStates();


AWS.Request = inherit({


  constructor: function Request(service, operation, params) {
    var endpoint = service.endpoint;
    var region = service.config.region;
    var customUserAgent = service.config.customUserAgent;

    if (service.isGlobalEndpoint) region = 'us-east-1';

    this.domain = domain && domain.active;
    this.service = service;
    this.operation = operation;
    this.params = params || {};
    this.httpRequest = new AWS.HttpRequest(endpoint, region, customUserAgent);
    this.startTime = AWS.util.date.getDate();

    this.response = new AWS.Response(this);
    this._asm = new AcceptorStateMachine(fsm.states, 'validate');
    this._haltHandlersOnError = false;

    AWS.SequentialExecutor.call(this);
    this.emit = this.emitEvent;
  },




  send: function send(callback) {
    if (callback) {
      this.on('complete', function (resp) {
        callback.call(resp, resp.error, resp.data);
      });
    }
    this.runTo();

    return this.response;
  },




  build: function build(callback) {
    return this.runTo('send', callback);
  },


  runTo: function runTo(state, done) {
    this._asm.runTo(state, done, this);
    return this;
  },


  abort: function abort() {
    this.removeAllListeners('validateResponse');
    this.removeAllListeners('extractError');
    this.on('validateResponse', function addAbortedError(resp) {
      resp.error = AWS.util.error(new Error('Request aborted by user'), {
         code: 'RequestAbortedError', retryable: false
      });
    });

    if (this.httpRequest.stream) { // abort HTTP stream
      this.httpRequest.stream.abort();
      if (this.httpRequest._abortCallback) {
         this.httpRequest._abortCallback();
      } else {
        this.removeAllListeners('send'); // haven't sent yet, so let's not
      }
    }

    return this;
  },


  eachPage: function eachPage(callback) {
    callback = AWS.util.fn.makeAsync(callback, 3);

    function wrappedCallback(response) {
      callback.call(response, response.error, response.data, function (result) {
        if (result === false) return;

        if (response.hasNextPage()) {
          response.nextPage().on('complete', wrappedCallback).send();
        } else {
          callback.call(response, null, null, AWS.util.fn.noop);
        }
      });
    }

    this.on('complete', wrappedCallback).send();
  },


  eachItem: function eachItem(callback) {
    var self = this;
    function wrappedCallback(err, data) {
      if (err) return callback(err, null);
      if (data === null) return callback(null, null);

      var config = self.service.paginationConfig(self.operation);
      var resultKey = config.resultKey;
      if (Array.isArray(resultKey)) resultKey = resultKey[0];
      var items = jmespath.search(data, resultKey);
      var continueIteration = true;
      AWS.util.arrayEach(items, function(item) {
        continueIteration = callback(null, item);
        if (continueIteration === false) {
          return AWS.util.abort;
        }
      });
      return continueIteration;
    }

    this.eachPage(wrappedCallback);
  },


  isPageable: function isPageable() {
    return this.service.paginationConfig(this.operation) ? true : false;
  },


  createReadStream: function createReadStream() {
    var streams = AWS.util.stream;
    var req = this;
    var stream = null;

    if (AWS.HttpClient.streamsApiVersion === 2) {
      stream = new streams.PassThrough();
      req.send();
    } else {
      stream = new streams.Stream();
      stream.readable = true;

      stream.sent = false;
      stream.on('newListener', function(event) {
        if (!stream.sent && event === 'data') {
          stream.sent = true;
          process.nextTick(function() { req.send(); });
        }
      });
    }

    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
      if (statusCode < 300) {
        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
        req.on('httpError', function streamHttpError(error) {
          resp.error = error;
          resp.error.retryable = false;
        });

        var shouldCheckContentLength = false;
        var expectedLen;
        if (req.httpRequest.method !== 'HEAD') {
          expectedLen = parseInt(headers['content-length'], 10);
        }
        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
          shouldCheckContentLength = true;
          var receivedLen = 0;
        }

        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
          if (shouldCheckContentLength && receivedLen !== expectedLen) {
            stream.emit('error', AWS.util.error(
              new Error('Stream content length mismatch. Received ' +
                receivedLen + ' of ' + expectedLen + ' bytes.'),
              { code: 'StreamContentLengthMismatch' }
            ));
          } else if (AWS.HttpClient.streamsApiVersion === 2) {
            stream.end();
          } else {
            stream.emit('end')
          }
        }

        var httpStream = resp.httpResponse.createUnbufferedStream();

        if (AWS.HttpClient.streamsApiVersion === 2) {
          if (shouldCheckContentLength) {
            var lengthAccumulator = new streams.PassThrough();
            lengthAccumulator._write = function(chunk) {
              if (chunk && chunk.length) {
                receivedLen += chunk.length;
              }
              return streams.PassThrough.prototype._write.apply(this, arguments);
            };

            lengthAccumulator.on('end', checkContentLengthAndEmit);
            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
          } else {
            httpStream.pipe(stream);
          }
        } else {

          if (shouldCheckContentLength) {
            httpStream.on('data', function(arg) {
              if (arg && arg.length) {
                receivedLen += arg.length;
              }
            });
          }

          httpStream.on('data', function(arg) {
            stream.emit('data', arg);
          });
          httpStream.on('end', checkContentLengthAndEmit);
        }

        httpStream.on('error', function(err) {
          shouldCheckContentLength = false;
          stream.emit('error', err);
        });
      }
    });

    this.on('error', function(err) {
      stream.emit('error', err);
    });

    return stream;
  },


  emitEvent: function emit(eventName, args, done) {
    if (typeof args === 'function') { done = args; args = null; }
    if (!done) done = function() { };
    if (!args) args = this.eventParameters(eventName, this.response);

    var origEmit = AWS.SequentialExecutor.prototype.emit;
    origEmit.call(this, eventName, args, function (err) {
      if (err) this.response.error = err;
      done.call(this, err);
    });
  },


  eventParameters: function eventParameters(eventName) {
    switch (eventName) {
      case 'restart':
      case 'validate':
      case 'sign':
      case 'build':
      case 'afterValidate':
      case 'afterBuild':
        return [this];
      case 'error':
        return [this.response.error, this.response];
      default:
        return [this.response];
    }
  },


  presign: function presign(expires, callback) {
    if (!callback && typeof expires === 'function') {
      callback = expires;
      expires = null;
    }
    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
  },


  isPresigned: function isPresigned() {
    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
  },


  toUnauthenticated: function toUnauthenticated() {
    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
    this.removeListener('sign', AWS.EventListeners.Core.SIGN);
    return this;
  },


  toGet: function toGet() {
    if (this.service.api.protocol === 'query' ||
        this.service.api.protocol === 'ec2') {
      this.removeListener('build', this.buildAsGet);
      this.addListener('build', this.buildAsGet);
    }
    return this;
  },


  buildAsGet: function buildAsGet(request) {
    request.httpRequest.method = 'GET';
    request.httpRequest.path = request.service.endpoint.path +
                               '?' + request.httpRequest.body;
    request.httpRequest.body = '';

    delete request.httpRequest.headers['Content-Length'];
    delete request.httpRequest.headers['Content-Type'];
  },


  haltHandlersOnError: function haltHandlersOnError() {
    this._haltHandlersOnError = true;
  }
});


AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = function promise() {
    var self = this;
    return new PromiseDependency(function(resolve, reject) {
      self.on('complete', function(resp) {
        if (resp.error) {
          reject(resp.error);
        } else {
          resolve(resp.data);
        }
      });
      self.runTo();
    });
  };
};


AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.Request);

AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);

}).call(this,require('_process'))
},{"./core":10,"./state_machine":51,"_process":117,"jmespath":68}],38:[function(require,module,exports){


var AWS = require('./core');
var inherit = AWS.util.inherit;
var jmespath = require('jmespath');


function CHECK_ACCEPTORS(resp) {
  var waiter = resp.request._waiter;
  var acceptors = waiter.config.acceptors;
  var acceptorMatched = false;
  var state = 'retry';

  acceptors.forEach(function(acceptor) {
    if (!acceptorMatched) {
      var matcher = waiter.matchers[acceptor.matcher];
      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
        acceptorMatched = true;
        state = acceptor.state;
      }
    }
  });

  if (!acceptorMatched && resp.error) state = 'failure';

  if (state === 'success') {
    waiter.setSuccess(resp);
  } else {
    waiter.setError(resp, state === 'retry');
  }
}


AWS.ResourceWaiter = inherit({

  constructor: function constructor(service, state) {
    this.service = service;
    this.state = state;
    this.loadWaiterConfig(this.state);
  },

  service: null,

  state: null,

  config: null,

  matchers: {
    path: function(resp, expected, argument) {
      var result = jmespath.search(resp.data, argument);
      return jmespath.strictDeepEqual(result,expected);
    },

    pathAll: function(resp, expected, argument) {
      var results = jmespath.search(resp.data, argument);
      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      if (!numResults) return false;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (!jmespath.strictDeepEqual(results[ind], expected)) {
          return false;
        }
      }
      return true;
    },

    pathAny: function(resp, expected, argument) {
      var results = jmespath.search(resp.data, argument);
      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (jmespath.strictDeepEqual(results[ind], expected)) {
          return true;
        }
      }
      return false;
    },

    status: function(resp, expected) {
      var statusCode = resp.httpResponse.statusCode;
      return (typeof statusCode === 'number') && (statusCode === expected);
    },

    error: function(resp, expected) {
      if (typeof expected === 'string' && resp.error) {
        return expected === resp.error.code;
      }
      return expected === !!resp.error;
    }
  },

  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {
    add('RETRY_CHECK', 'retry', function(resp) {
      var waiter = resp.request._waiter;
      if (resp.error && resp.error.code === 'ResourceNotReady') {
        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
      }
    });

    add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);

    add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
  }),


  wait: function wait(params, callback) {
    if (typeof params === 'function') {
      callback = params; params = undefined;
    }

    var request = this.service.makeRequest(this.config.operation, params);
    request._waiter = this;
    request.response.maxRetries = this.config.maxAttempts;
    request.addListeners(this.listeners);

    if (callback) request.send(callback);
    return request;
  },

  setSuccess: function setSuccess(resp) {
    resp.error = null;
    resp.data = resp.data || {};
    resp.request.removeAllListeners('extractData');
  },

  setError: function setError(resp, retryable) {
    resp.data = null;
    resp.error = AWS.util.error(resp.error || new Error(), {
      code: 'ResourceNotReady',
      message: 'Resource is not in the state ' + this.state,
      retryable: retryable
    });
  },


  loadWaiterConfig: function loadWaiterConfig(state) {
    if (!this.service.api.waiters[state]) {
      throw new AWS.util.error(new Error(), {
        code: 'StateNotFoundError',
        message: 'State ' + state + ' not found.'
      });
    }

    this.config = this.service.api.waiters[state];
  }
});

},{"./core":10,"jmespath":68}],39:[function(require,module,exports){
var AWS = require('./core');
var inherit = AWS.util.inherit;
var jmespath = require('jmespath');


AWS.Response = inherit({


  constructor: function Response(request) {
    this.request = request;
    this.data = null;
    this.error = null;
    this.retryCount = 0;
    this.redirectCount = 0;
    this.httpResponse = new AWS.HttpResponse();
    if (request) {
      this.maxRetries = request.service.numRetries();
      this.maxRedirects = request.service.config.maxRedirects;
    }
  },


  nextPage: function nextPage(callback) {
    var config;
    var service = this.request.service;
    var operation = this.request.operation;
    try {
      config = service.paginationConfig(operation, true);
    } catch (e) { this.error = e; }

    if (!this.hasNextPage()) {
      if (callback) callback(this.error, null);
      else if (this.error) throw this.error;
      return null;
    }

    var params = AWS.util.copy(this.request.params);
    if (!this.nextPageTokens) {
      return callback ? callback(null, null) : null;
    } else {
      var inputTokens = config.inputToken;
      if (typeof inputTokens === 'string') inputTokens = [inputTokens];
      for (var i = 0; i < inputTokens.length; i++) {
        params[inputTokens[i]] = this.nextPageTokens[i];
      }
      return service.makeRequest(this.request.operation, params, callback);
    }
  },


  hasNextPage: function hasNextPage() {
    this.cacheNextPageTokens();
    if (this.nextPageTokens) return true;
    if (this.nextPageTokens === undefined) return undefined;
    else return false;
  },


  cacheNextPageTokens: function cacheNextPageTokens() {
    if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
    this.nextPageTokens = undefined;

    var config = this.request.service.paginationConfig(this.request.operation);
    if (!config) return this.nextPageTokens;

    this.nextPageTokens = null;
    if (config.moreResults) {
      if (!jmespath.search(this.data, config.moreResults)) {
        return this.nextPageTokens;
      }
    }

    var exprs = config.outputToken;
    if (typeof exprs === 'string') exprs = [exprs];
    AWS.util.arrayEach.call(this, exprs, function (expr) {
      var output = jmespath.search(this.data, expr);
      if (output) {
        this.nextPageTokens = this.nextPageTokens || [];
        this.nextPageTokens.push(output);
      }
    });

    return this.nextPageTokens;
  }

});

},{"./core":10,"jmespath":68}],40:[function(require,module,exports){
var AWS = require('./core');


AWS.SequentialExecutor = AWS.util.inherit({

  constructor: function SequentialExecutor() {
    this._events = {};
  },


  listeners: function listeners(eventName) {
    return this._events[eventName] ? this._events[eventName].slice(0) : [];
  },

  on: function on(eventName, listener) {
    if (this._events[eventName]) {
      this._events[eventName].push(listener);
    } else {
      this._events[eventName] = [listener];
    }
    return this;
  },


  onAsync: function onAsync(eventName, listener) {
    listener._isAsync = true;
    return this.on(eventName, listener);
  },

  removeListener: function removeListener(eventName, listener) {
    var listeners = this._events[eventName];
    if (listeners) {
      var length = listeners.length;
      var position = -1;
      for (var i = 0; i < length; ++i) {
        if (listeners[i] === listener) {
          position = i;
        }
      }
      if (position > -1) {
        listeners.splice(position, 1);
      }
    }
    return this;
  },

  removeAllListeners: function removeAllListeners(eventName) {
    if (eventName) {
      delete this._events[eventName];
    } else {
      this._events = {};
    }
    return this;
  },


  emit: function emit(eventName, eventArgs, doneCallback) {
    if (!doneCallback) doneCallback = function() { };
    var listeners = this.listeners(eventName);
    var count = listeners.length;
    this.callListeners(listeners, eventArgs, doneCallback);
    return count > 0;
  },


  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
    var self = this;
    var error = prevError || null;

    function callNextListener(err) {
      if (err) {
        error = AWS.util.error(error || new Error(), err);
        if (self._haltHandlersOnError) {
          return doneCallback.call(self, error);
        }
      }
      self.callListeners(listeners, args, doneCallback, error);
    }

    while (listeners.length > 0) {
      var listener = listeners.shift();
      if (listener._isAsync) { // asynchronous listener
        listener.apply(self, args.concat([callNextListener]));
        return; // stop here, callNextListener will continue
      } else { // synchronous listener
        try {
          listener.apply(self, args);
        } catch (err) {
          error = AWS.util.error(error || new Error(), err);
        }
        if (error && self._haltHandlersOnError) {
          doneCallback.call(self, error);
          return;
        }
      }
    }
    doneCallback.call(self, error);
  },


  addListeners: function addListeners(listeners) {
    var self = this;

    if (listeners._events) listeners = listeners._events;

    AWS.util.each(listeners, function(event, callbacks) {
      if (typeof callbacks === 'function') callbacks = [callbacks];
      AWS.util.arrayEach(callbacks, function(callback) {
        self.on(event, callback);
      });
    });

    return self;
  },


  addNamedListener: function addNamedListener(name, eventName, callback) {
    this[name] = callback;
    this.addListener(eventName, callback);
    return this;
  },


  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback) {
    callback._isAsync = true;
    return this.addNamedListener(name, eventName, callback);
  },


  addNamedListeners: function addNamedListeners(callback) {
    var self = this;
    callback(
      function() {
        self.addNamedListener.apply(self, arguments);
      },
      function() {
        self.addNamedAsyncListener.apply(self, arguments);
      }
    );
    return this;
  }
});


AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

module.exports = AWS.SequentialExecutor;

},{"./core":10}],41:[function(require,module,exports){
var AWS = require('./core');
var Api = require('./model/api');
var regionConfig = require('./region_config');
var inherit = AWS.util.inherit;
var clientCount = 0;


AWS.Service = inherit({

  constructor: function Service(config) {
    if (!this.loadServiceClass) {
      throw AWS.util.error(new Error(),
        'Service must be constructed with `new\' operator');
    }
    var ServiceClass = this.loadServiceClass(config || {});
    if (ServiceClass) {
      var originalConfig = AWS.util.copy(config);
      var svc = new ServiceClass(config);
      Object.defineProperty(svc, '_originalConfig', {
        get: function() { return originalConfig; },
        enumerable: false,
        configurable: true
      });
      svc._clientId = ++clientCount;
      return svc;
    }
    this.initialize(config);
  },


  initialize: function initialize(config) {
    var svcConfig = AWS.config[this.serviceIdentifier];

    this.config = new AWS.Config(AWS.config);
    if (svcConfig) this.config.update(svcConfig, true);
    if (config) this.config.update(config, true);

    this.validateService();
    if (!this.config.endpoint) regionConfig(this);

    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
    this.setEndpoint(this.config.endpoint);
  },


  validateService: function validateService() {
  },


  loadServiceClass: function loadServiceClass(serviceConfig) {
    var config = serviceConfig;
    if (!AWS.util.isEmpty(this.api)) {
      return null;
    } else if (config.apiConfig) {
      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
    } else if (!this.constructor.services) {
      return null;
    } else {
      config = new AWS.Config(AWS.config);
      config.update(serviceConfig, true);
      var version = config.apiVersions[this.constructor.serviceIdentifier];
      version = version || config.apiVersion;
      return this.getLatestServiceClass(version);
    }
  },


  getLatestServiceClass: function getLatestServiceClass(version) {
    version = this.getLatestServiceVersion(version);
    if (this.constructor.services[version] === null) {
      AWS.Service.defineServiceApi(this.constructor, version);
    }

    return this.constructor.services[version];
  },


  getLatestServiceVersion: function getLatestServiceVersion(version) {
    if (!this.constructor.services || this.constructor.services.length === 0) {
      throw new Error('No services defined on ' +
                      this.constructor.serviceIdentifier);
    }

    if (!version) {
      version = 'latest';
    } else if (AWS.util.isType(version, Date)) {
      version = AWS.util.date.iso8601(version).split('T')[0];
    }

    if (Object.hasOwnProperty(this.constructor.services, version)) {
      return version;
    }

    var keys = Object.keys(this.constructor.services).sort();
    var selectedVersion = null;
    for (var i = keys.length - 1; i >= 0; i--) {
      if (keys[i][keys[i].length - 1] !== '*') {
        selectedVersion = keys[i];
      }
      if (keys[i].substr(0, 10) <= version) {
        return selectedVersion;
      }
    }

    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
                    ' API to satisfy version constraint `' + version + '\'');
  },


  api: {},


  defaultRetryCount: 3,


  makeRequest: function makeRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = null;
    }

    params = params || {};
    if (this.config.params) { // copy only toplevel bound params
      var rules = this.api.operations[operation];
      if (rules) {
        params = AWS.util.copy(params);
        AWS.util.each(this.config.params, function(key, value) {
          if (rules.input.members[key]) {
            if (params[key] === undefined || params[key] === null) {
              params[key] = value;
            }
          }
        });
      }
    }

    var request = new AWS.Request(this, operation, params);
    this.addAllRequestListeners(request);

    if (callback) request.send(callback);
    return request;
  },


  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = {};
    }

    var request = this.makeRequest(operation, params).toUnauthenticated();
    return callback ? request.send(callback) : request;
  },


  waitFor: function waitFor(state, params, callback) {
    var waiter = new AWS.ResourceWaiter(this, state);
    return waiter.wait(params, callback);
  },


  addAllRequestListeners: function addAllRequestListeners(request) {
    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
                AWS.EventListeners.CorePost];
    for (var i = 0; i < list.length; i++) {
      if (list[i]) request.addListeners(list[i]);
    }

    if (!this.config.paramValidation) {
      request.removeListener('validate',
        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    }

    if (this.config.logger) { // add logging events
      request.addListeners(AWS.EventListeners.Logger);
    }

    this.setupRequestListeners(request);
  },


  setupRequestListeners: function setupRequestListeners() {
  },


  getSignerClass: function getSignerClass() {
    var version;
    if (this.config.signatureVersion) {
      version = this.config.signatureVersion;
    } else {
      version = this.api.signatureVersion;
    }
    return AWS.Signers.RequestSigner.getVersion(version);
  },


  serviceInterface: function serviceInterface() {
    switch (this.api.protocol) {
      case 'ec2': return AWS.EventListeners.Query;
      case 'query': return AWS.EventListeners.Query;
      case 'json': return AWS.EventListeners.Json;
      case 'rest-json': return AWS.EventListeners.RestJson;
      case 'rest-xml': return AWS.EventListeners.RestXml;
    }
    if (this.api.protocol) {
      throw new Error('Invalid service `protocol\' ' +
        this.api.protocol + ' in API config');
    }
  },


  successfulResponse: function successfulResponse(resp) {
    return resp.httpResponse.statusCode < 300;
  },


  numRetries: function numRetries() {
    if (this.config.maxRetries !== undefined) {
      return this.config.maxRetries;
    } else {
      return this.defaultRetryCount;
    }
  },


  retryDelays: function retryDelays(retryCount) {
    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions);
  },


  retryableError: function retryableError(error) {
    if (this.networkingError(error)) return true;
    if (this.expiredCredentialsError(error)) return true;
    if (this.throttledError(error)) return true;
    if (error.statusCode >= 500) return true;
    return false;
  },


  networkingError: function networkingError(error) {
    return error.code === 'NetworkingError';
  },


  expiredCredentialsError: function expiredCredentialsError(error) {
    return (error.code === 'ExpiredTokenException');
  },


  clockSkewError: function clockSkewError(error) {
    switch (error.code) {
      case 'RequestTimeTooSkewed':
      case 'RequestExpired':
      case 'InvalidSignatureException':
      case 'SignatureDoesNotMatch':
      case 'AuthFailure':
      case 'RequestInTheFuture':
        return true;
      default: return false;
    }
  },


  throttledError: function throttledError(error) {
    switch (error.code) {
      case 'ProvisionedThroughputExceededException':
      case 'Throttling':
      case 'ThrottlingException':
      case 'RequestLimitExceeded':
      case 'RequestThrottled':
        return true;
      default:
        return false;
    }
  },


  endpointFromTemplate: function endpointFromTemplate(endpoint) {
    if (typeof endpoint !== 'string') return endpoint;

    var e = endpoint;
    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
    e = e.replace(/\{region\}/g, this.config.region);
    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
    return e;
  },


  setEndpoint: function setEndpoint(endpoint) {
    this.endpoint = new AWS.Endpoint(endpoint, this.config);
  },


  paginationConfig: function paginationConfig(operation, throwException) {
    var paginator = this.api.operations[operation].paginator;
    if (!paginator) {
      if (throwException) {
        var e = new Error();
        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
      }
      return null;
    }

    return paginator;
  }
});

AWS.util.update(AWS.Service, {


  defineMethods: function defineMethods(svc) {
    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
      if (svc.prototype[method]) return;
      var operation = svc.prototype.api.operations[method];
      if (operation.authtype === 'none') {
        svc.prototype[method] = function (params, callback) {
          return this.makeUnauthenticatedRequest(method, params, callback);
        };
      } else {
        svc.prototype[method] = function (params, callback) {
          return this.makeRequest(method, params, callback);
        };
      }
    });
  },


  defineService: function defineService(serviceIdentifier, versions, features) {
    AWS.Service._serviceMap[serviceIdentifier] = true;
    if (!Array.isArray(versions)) {
      features = versions;
      versions = [];
    }

    var svc = inherit(AWS.Service, features || {});

    if (typeof serviceIdentifier === 'string') {
      AWS.Service.addVersions(svc, versions);

      var identifier = svc.serviceIdentifier || serviceIdentifier;
      svc.serviceIdentifier = identifier;
    } else { // defineService called with an API
      svc.prototype.api = serviceIdentifier;
      AWS.Service.defineMethods(svc);
    }

    return svc;
  },


  addVersions: function addVersions(svc, versions) {
    if (!Array.isArray(versions)) versions = [versions];

    svc.services = svc.services || {};
    for (var i = 0; i < versions.length; i++) {
      if (svc.services[versions[i]] === undefined) {
        svc.services[versions[i]] = null;
      }
    }

    svc.apiVersions = Object.keys(svc.services).sort();
  },


  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
    var svc = inherit(superclass, {
      serviceIdentifier: superclass.serviceIdentifier
    });

    function setApi(api) {
      if (api.isApi) {
        svc.prototype.api = api;
      } else {
        svc.prototype.api = new Api(api);
      }
    }

    if (typeof version === 'string') {
      if (apiConfig) {
        setApi(apiConfig);
      } else {
        try {
          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
        } catch (err) {
          throw AWS.util.error(err, {
            message: 'Could not find API configuration ' +
              superclass.serviceIdentifier + '-' + version
          });
        }
      }
      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
      }
      superclass.services[version] = svc;
    } else {
      setApi(version);
    }

    AWS.Service.defineMethods(svc);
    return svc;
  },


  hasService: function(identifier) {
    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
  },


  _serviceMap: {}
});

module.exports = AWS.Service;
},{"./core":10,"./model/api":22,"./region_config":36}],42:[function(require,module,exports){
var AWS = require('../core');

AWS.util.update(AWS.CognitoIdentity.prototype, {
  getOpenIdToken: function getOpenIdToken(params, callback) {
    return this.makeUnauthenticatedRequest('getOpenIdToken', params, callback);
  },

  getId: function getId(params, callback) {
    return this.makeUnauthenticatedRequest('getId', params, callback);
  },

  getCredentialsForIdentity: function getCredentialsForIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('getCredentialsForIdentity', params, callback);
  }
});

},{"../core":10}],43:[function(require,module,exports){
var AWS = require('../core');

AWS.util.update(AWS.STS.prototype, {

  credentialsFrom: function credentialsFrom(data, credentials) {
    if (!data) return null;
    if (!credentials) credentials = new AWS.TemporaryCredentials();
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretAccessKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
    return credentials;
  },

  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
  },

  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
  }
});

},{"../core":10}],44:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;


var expiresHeader = 'presigned-expires';


function signedUrlBuilder(request) {
  var expires = request.httpRequest.headers[expiresHeader];
  var signerClass = request.service.getSignerClass(request);

  delete request.httpRequest.headers['User-Agent'];
  delete request.httpRequest.headers['X-Amz-User-Agent'];

  if (signerClass === AWS.Signers.V4) {
    if (expires > 604800) { // one week expiry is invalid
      var message = 'Presigning does not support expiry time greater ' +
                    'than a week with SigV4 signing.';
      throw AWS.util.error(new Error(), {
        code: 'InvalidExpiryTime', message: message, retryable: false
      });
    }
    request.httpRequest.headers[expiresHeader] = expires;
  } else if (signerClass === AWS.Signers.S3) {
    request.httpRequest.headers[expiresHeader] = parseInt(
      AWS.util.date.unixTimestamp() + expires, 10).toString();
  } else {
    throw AWS.util.error(new Error(), {
      message: 'Presigning only supports S3 or SigV4 signing.',
      code: 'UnsupportedSigner', retryable: false
    });
  }
}


function signedUrlSigner(request) {
  var endpoint = request.httpRequest.endpoint;
  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
  var queryParams = {};

  if (parsedUrl.search) {
    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
  }

  AWS.util.each(request.httpRequest.headers, function (key, value) {
    if (key === expiresHeader) key = 'Expires';
    if (key.indexOf('x-amz-meta-') === 0) {
      delete queryParams[key];
      key = key.toLowerCase();
    }
    queryParams[key] = value;
  });
  delete request.httpRequest.headers[expiresHeader];

  var auth = queryParams['Authorization'].split(' ');
  if (auth[0] === 'AWS') {
    auth = auth[1].split(':');
    queryParams['AWSAccessKeyId'] = auth[0];
    queryParams['Signature'] = auth[1];
  } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing
    auth.shift();
    var rest = auth.join(' ');
    var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
    queryParams['X-Amz-Signature'] = signature;
    delete queryParams['Expires'];
  }
  delete queryParams['Authorization'];
  delete queryParams['Host'];

  endpoint.pathname = parsedUrl.pathname;
  endpoint.search = AWS.util.queryParamsToString(queryParams);
}


AWS.Signers.Presign = inherit({

  sign: function sign(request, expireTime, callback) {
    request.httpRequest.headers[expiresHeader] = expireTime || 3600;
    request.on('build', signedUrlBuilder);
    request.on('sign', signedUrlSigner);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.SET_CONTENT_LENGTH);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.COMPUTE_SHA256);

    request.emit('beforePresign', [request]);

    if (callback) {
      request.build(function() {
        if (this.response.error) callback(this.response.error);
        else {
          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
        }
      });
    } else {
      request.build();
      if (request.response.error) throw request.response.error;
      return AWS.util.urlFormat(request.httpRequest.endpoint);
    }
  }
});

module.exports = AWS.Signers.Presign;

},{"../core":10}],45:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;


AWS.Signers.RequestSigner = inherit({
  constructor: function RequestSigner(request) {
    this.request = request;
  },

  setServiceClientId: function setServiceClientId(id) {
    this.serviceClientId = id;
  },

  getServiceClientId: function getServiceClientId() {
    return this.serviceClientId;
  }
});

AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
  switch (version) {
    case 'v2': return AWS.Signers.V2;
    case 'v3': return AWS.Signers.V3;
    case 'v4': return AWS.Signers.V4;
    case 's3': return AWS.Signers.S3;
    case 'v3https': return AWS.Signers.V3Https;
  }
  throw new Error('Unknown signing version ' + version);
};

require('./v2');
require('./v3');
require('./v3https');
require('./v4');
require('./s3');
require('./presign');

},{"../core":10,"./presign":44,"./s3":46,"./v2":47,"./v3":48,"./v3https":49,"./v4":50}],46:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;


AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {

  subResources: {
    'acl': 1,
    'accelerate': 1,
    'cors': 1,
    'lifecycle': 1,
    'delete': 1,
    'location': 1,
    'logging': 1,
    'notification': 1,
    'partNumber': 1,
    'policy': 1,
    'requestPayment': 1,
    'replication': 1,
    'restore': 1,
    'tagging': 1,
    'torrent': 1,
    'uploadId': 1,
    'uploads': 1,
    'versionId': 1,
    'versioning': 1,
    'versions': 1,
    'website': 1
  },

  responseHeaders: {
    'response-content-type': 1,
    'response-content-language': 1,
    'response-expires': 1,
    'response-cache-control': 1,
    'response-content-disposition': 1,
    'response-content-encoding': 1
  },

  addAuthorization: function addAuthorization(credentials, date) {
    if (!this.request.headers['presigned-expires']) {
      this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
    }

    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
    var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;

    this.request.headers['Authorization'] = auth;
  },

  stringToSign: function stringToSign() {
    var r = this.request;

    var parts = [];
    parts.push(r.method);
    parts.push(r.headers['Content-MD5'] || '');
    parts.push(r.headers['Content-Type'] || '');

    parts.push(r.headers['presigned-expires'] || '');

    var headers = this.canonicalizedAmzHeaders();
    if (headers) parts.push(headers);
    parts.push(this.canonicalizedResource());

    return parts.join('\n');

  },

  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {

    var amzHeaders = [];

    AWS.util.each(this.request.headers, function (name) {
      if (name.match(/^x-amz-/i))
        amzHeaders.push(name);
    });

    amzHeaders.sort(function (a, b) {
      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    });

    var parts = [];
    AWS.util.arrayEach.call(this, amzHeaders, function (name) {
      parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
    });

    return parts.join('\n');

  },

  canonicalizedResource: function canonicalizedResource() {

    var r = this.request;

    var parts = r.path.split('?');
    var path = parts[0];
    var querystring = parts[1];

    var resource = '';

    if (r.virtualHostedBucket)
      resource += '/' + r.virtualHostedBucket;

    resource += path;

    if (querystring) {

      var resources = [];

      AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
        var name = param.split('=')[0];
        var value = param.split('=')[1];
        if (this.subResources[name] || this.responseHeaders[name]) {
          var subresource = { name: name };
          if (value !== undefined) {
            if (this.subResources[name]) {
              subresource.value = value;
            } else {
              subresource.value = decodeURIComponent(value);
            }
          }
          resources.push(subresource);
        }
      });

      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });

      if (resources.length) {

        querystring = [];
        AWS.util.arrayEach(resources, function (res) {
          if (res.value === undefined) {
            querystring.push(res.name);
          } else {
            querystring.push(res.name + '=' + res.value);
          }
        });

        resource += '?' + querystring.join('&');
      }

    }

    return resource;

  },

  sign: function sign(secret, string) {
    return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
  }
});

module.exports = AWS.Signers.S3;

},{"../core":10}],47:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;


AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    if (!date) date = AWS.util.date.getDate();

    var r = this.request;

    r.params.Timestamp = AWS.util.date.iso8601(date);
    r.params.SignatureVersion = '2';
    r.params.SignatureMethod = 'HmacSHA256';
    r.params.AWSAccessKeyId = credentials.accessKeyId;

    if (credentials.sessionToken) {
      r.params.SecurityToken = credentials.sessionToken;
    }

    delete r.params.Signature; // delete old Signature for re-signing
    r.params.Signature = this.signature(credentials);

    r.body = AWS.util.queryParamsToString(r.params);
    r.headers['Content-Length'] = r.body.length;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push(this.request.endpoint.host.toLowerCase());
    parts.push(this.request.pathname());
    parts.push(AWS.util.queryParamsToString(this.request.params));
    return parts.join('\n');
  }

});

module.exports = AWS.Signers.V2;

},{"../core":10}],48:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;


AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    var datetime = AWS.util.date.rfc822(date);

    this.request.headers['X-Amz-Date'] = datetime;

    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    this.request.headers['X-Amzn-Authorization'] =
      this.authorization(credentials, datetime);

  },

  authorization: function authorization(credentials) {
    return 'AWS3 ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'SignedHeaders=' + this.signedHeaders() + ',' +
      'Signature=' + this.signature(credentials);
  },

  signedHeaders: function signedHeaders() {
    var headers = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      headers.push(h.toLowerCase());
    });
    return headers.sort().join(';');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = this.request.headers;
    var parts = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
    });
    return parts.sort().join('\n') + '\n';
  },

  headersToSign: function headersToSign() {
    var headers = [];
    AWS.util.each(this.request.headers, function iterator(k) {
      if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
        headers.push(k);
      }
    });
    return headers;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push('/');
    parts.push('');
    parts.push(this.canonicalHeaders());
    parts.push(this.request.body);
    return AWS.util.crypto.sha256(parts.join('\n'));
  }

});

module.exports = AWS.Signers.V3;

},{"../core":10}],49:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

require('./v3');


AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
  authorization: function authorization(credentials) {
    return 'AWS3-HTTPS ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'Signature=' + this.signature(credentials);
  },

  stringToSign: function stringToSign() {
    return this.request.headers['X-Amz-Date'];
  }
});

module.exports = AWS.Signers.V3Https;

},{"../core":10,"./v3":48}],50:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;


var cachedSecret = {};


var cacheQueue = [];


var maxCacheEntries = 50;


var expiresHeader = 'presigned-expires';


AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
  constructor: function V4(request, serviceName, signatureCache) {
    AWS.Signers.RequestSigner.call(this, request);
    this.serviceName = serviceName;
    this.signatureCache = signatureCache;
  },

  algorithm: 'AWS4-HMAC-SHA256',

  addAuthorization: function addAuthorization(credentials, date) {
    var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

    if (this.isPresigned()) {
      this.updateForPresigned(credentials, datetime);
    } else {
      this.addHeaders(credentials, datetime);
    }

    this.request.headers['Authorization'] =
      this.authorization(credentials, datetime);
  },

  addHeaders: function addHeaders(credentials, datetime) {
    this.request.headers['X-Amz-Date'] = datetime;
    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }
  },

  updateForPresigned: function updateForPresigned(credentials, datetime) {
    var credString = this.credentialString(datetime);
    var qs = {
      'X-Amz-Date': datetime,
      'X-Amz-Algorithm': this.algorithm,
      'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
      'X-Amz-Expires': this.request.headers[expiresHeader],
      'X-Amz-SignedHeaders': this.signedHeaders()
    };

    if (credentials.sessionToken) {
      qs['X-Amz-Security-Token'] = credentials.sessionToken;
    }

    if (this.request.headers['Content-Type']) {
      qs['Content-Type'] = this.request.headers['Content-Type'];
    }
    if (this.request.headers['Content-MD5']) {
      qs['Content-MD5'] = this.request.headers['Content-MD5'];
    }
    if (this.request.headers['Cache-Control']) {
      qs['Cache-Control'] = this.request.headers['Cache-Control'];
    }

    AWS.util.each.call(this, this.request.headers, function(key, value) {
      if (key === expiresHeader) return;
      if (this.isSignableHeader(key)) {
        var lowerKey = key.toLowerCase();
        if (lowerKey.indexOf('x-amz-meta-') === 0) {
          qs[lowerKey] = value;
        } else if (lowerKey.indexOf('x-amz-') === 0) {
          qs[key] = value;
        }
      }
    });

    var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
    this.request.path += sep + AWS.util.queryParamsToString(qs);
  },

  authorization: function authorization(credentials, datetime) {
    var parts = [];
    var credString = this.credentialString(datetime);
    parts.push(this.algorithm + ' Credential=' +
      credentials.accessKeyId + '/' + credString);
    parts.push('SignedHeaders=' + this.signedHeaders());
    parts.push('Signature=' + this.signature(credentials, datetime));
    return parts.join(', ');
  },

  signature: function signature(credentials, datetime) {
    var cache = null;
    var cacheIdentifier = this.serviceName + (this.getServiceClientId() ? '_' + this.getServiceClientId() : '');
    if (this.signatureCache) {
      var cache = cachedSecret[cacheIdentifier];
      if (!cache) {
        cacheQueue.push(cacheIdentifier);
        if (cacheQueue.length > maxCacheEntries) {
          delete cachedSecret[cacheQueue.shift()];
        }
      }

    }
    var date = datetime.substr(0, 8);

    if (!cache ||
        cache.akid !== credentials.accessKeyId ||
        cache.region !== this.request.region ||
        cache.date !== date) {

      var kSecret = credentials.secretAccessKey;
      var kDate = AWS.util.crypto.hmac('AWS4' + kSecret, date, 'buffer');
      var kRegion = AWS.util.crypto.hmac(kDate, this.request.region, 'buffer');
      var kService = AWS.util.crypto.hmac(kRegion, this.serviceName, 'buffer');
      var kCredentials = AWS.util.crypto.hmac(kService, 'aws4_request', 'buffer');

      if (!this.signatureCache) {
        return AWS.util.crypto.hmac(kCredentials, this.stringToSign(datetime), 'hex');
      }

      cachedSecret[cacheIdentifier] = {
        region: this.request.region, date: date,
        key: kCredentials, akid: credentials.accessKeyId
      };
    }

    var key = cachedSecret[cacheIdentifier].key;
    return AWS.util.crypto.hmac(key, this.stringToSign(datetime), 'hex');
  },

  stringToSign: function stringToSign(datetime) {
    var parts = [];
    parts.push('AWS4-HMAC-SHA256');
    parts.push(datetime);
    parts.push(this.credentialString(datetime));
    parts.push(this.hexEncodedHash(this.canonicalString()));
    return parts.join('\n');
  },

  canonicalString: function canonicalString() {
    var parts = [], pathname = this.request.pathname();
    if (this.serviceName !== 's3') pathname = AWS.util.uriEscapePath(pathname);

    parts.push(this.request.method);
    parts.push(pathname);
    parts.push(this.request.search());
    parts.push(this.canonicalHeaders() + '\n');
    parts.push(this.signedHeaders());
    parts.push(this.hexEncodedBodyHash());
    return parts.join('\n');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = [];
    AWS.util.each.call(this, this.request.headers, function (key, item) {
      headers.push([key, item]);
    });
    headers.sort(function (a, b) {
      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
    });
    var parts = [];
    AWS.util.arrayEach.call(this, headers, function (item) {
      var key = item[0].toLowerCase();
      if (this.isSignableHeader(key)) {
        parts.push(key + ':' +
          this.canonicalHeaderValues(item[1].toString()));
      }
    });
    return parts.join('\n');
  },

  canonicalHeaderValues: function canonicalHeaderValues(values) {
    return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
  },

  signedHeaders: function signedHeaders() {
    var keys = [];
    AWS.util.each.call(this, this.request.headers, function (key) {
      key = key.toLowerCase();
      if (this.isSignableHeader(key)) keys.push(key);
    });
    return keys.sort().join(';');
  },

  credentialString: function credentialString(datetime) {
    var parts = [];
    parts.push(datetime.substr(0, 8));
    parts.push(this.request.region);
    parts.push(this.serviceName);
    parts.push('aws4_request');
    return parts.join('/');
  },

  hexEncodedHash: function hash(string) {
    return AWS.util.crypto.sha256(string, 'hex');
  },

  hexEncodedBodyHash: function hexEncodedBodyHash() {
    if (this.isPresigned() && this.serviceName === 's3' && !this.request.body) {
      return 'UNSIGNED-PAYLOAD';
    } else if (this.request.headers['X-Amz-Content-Sha256']) {
      return this.request.headers['X-Amz-Content-Sha256'];
    } else {
      return this.hexEncodedHash(this.request.body || '');
    }
  },

  unsignableHeaders: ['authorization', 'content-type', 'content-length',
                      'user-agent', expiresHeader, 'expect'],

  isSignableHeader: function isSignableHeader(key) {
    if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
    return this.unsignableHeaders.indexOf(key) < 0;
  },

  isPresigned: function isPresigned() {
    return this.request.headers[expiresHeader] ? true : false;
  }

});

module.exports = AWS.Signers.V4;

},{"../core":10}],51:[function(require,module,exports){
function AcceptorStateMachine(states, state) {
  this.currentState = state || null;
  this.states = states || {};
}

AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
  if (typeof finalState === 'function') {
    inputError = bindObject; bindObject = done;
    done = finalState; finalState = null;
  }

  var self = this;
  var state = self.states[self.currentState];
  state.fn.call(bindObject || self, inputError, function(err) {
    if (err) {
      if (state.fail) self.currentState = state.fail;
      else return done ? done.call(bindObject, err) : null;
    } else {
      if (state.accept) self.currentState = state.accept;
      else return done ? done.call(bindObject) : null;
    }
    if (self.currentState === finalState) {
      return done ? done.call(bindObject, err) : null;
    }

    self.runTo(finalState, done, bindObject, err);
  });
};

AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
  if (typeof acceptState === 'function') {
    fn = acceptState; acceptState = null; failState = null;
  } else if (typeof failState === 'function') {
    fn = failState; failState = null;
  }

  if (!this.currentState) this.currentState = name;
  this.states[name] = { accept: acceptState, fail: failState, fn: fn };
  return this;
};

module.exports = AcceptorStateMachine;

},{}],52:[function(require,module,exports){
(function (process){

var AWS;


var util = {
  engine: function engine() {
    if (util.isBrowser() && typeof navigator !== 'undefined') {
      return navigator.userAgent;
    } else {
      return process.platform + '/' + process.version;
    }
  },

  userAgent: function userAgent() {
    var name = util.isBrowser() ? 'js' : 'nodejs';
    var agent = 'aws-sdk-' + name + '/' + require('./core').VERSION;
    if (name === 'nodejs') agent += ' ' + util.engine();
    return agent;
  },

  isBrowser: function isBrowser() { return process && process.browser; },
  isNode: function isNode() { return !util.isBrowser(); },
  uriEscape: function uriEscape(string) {
    var output = encodeURIComponent(string);
    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

    output = output.replace(/[*]/g, function(ch) {
      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    });

    return output;
  },

  uriEscapePath: function uriEscapePath(string) {
    var parts = [];
    util.arrayEach(string.split('/'), function (part) {
      parts.push(util.uriEscape(part));
    });
    return parts.join('/');
  },

  urlParse: function urlParse(url) {
    return util.url.parse(url);
  },

  urlFormat: function urlFormat(url) {
    return util.url.format(url);
  },

  queryStringParse: function queryStringParse(qs) {
    return util.querystring.parse(qs);
  },

  queryParamsToString: function queryParamsToString(params) {
    var items = [];
    var escape = util.uriEscape;
    var sortedKeys = Object.keys(params).sort();

    util.arrayEach(sortedKeys, function(name) {
      var value = params[name];
      var ename = escape(name);
      var result = ename + '=';
      if (Array.isArray(value)) {
        var vals = [];
        util.arrayEach(value, function(item) { vals.push(escape(item)); });
        result = ename + '=' + vals.sort().join('&' + ename + '=');
      } else if (value !== undefined && value !== null) {
        result = ename + '=' + escape(value);
      }
      items.push(result);
    });

    return items.join('&');
  },

  readFileSync: function readFileSync(path) {
    if (util.isBrowser()) return null;
    return require('fs').readFileSync(path, 'utf-8');
  },

  base64: {

    encode: function encode64(string) {
      return new util.Buffer(string).toString('base64');
    },

    decode: function decode64(string) {
      return new util.Buffer(string, 'base64');
    }

  },

  buffer: {
    toStream: function toStream(buffer) {
      if (!util.Buffer.isBuffer(buffer)) buffer = new util.Buffer(buffer);

      var readable = new (util.stream.Readable)();
      var pos = 0;
      readable._read = function(size) {
        if (pos >= buffer.length) return readable.push(null);

        var end = pos + size;
        if (end > buffer.length) end = buffer.length;
        readable.push(buffer.slice(pos, end));
        pos = end;
      };

      return readable;
    },


    concat: function(buffers) {
      var length = 0,
          offset = 0,
          buffer = null, i;

      for (i = 0; i < buffers.length; i++) {
        length += buffers[i].length;
      }

      buffer = new util.Buffer(length);

      for (i = 0; i < buffers.length; i++) {
        buffers[i].copy(buffer, offset);
        offset += buffers[i].length;
      }

      return buffer;
    }
  },

  string: {
    byteLength: function byteLength(string) {
      if (string === null || string === undefined) return 0;
      if (typeof string === 'string') string = new util.Buffer(string);

      if (typeof string.byteLength === 'number') {
        return string.byteLength;
      } else if (typeof string.length === 'number') {
        return string.length;
      } else if (typeof string.size === 'number') {
        return string.size;
      } else if (typeof string.path === 'string') {
        return require('fs').lstatSync(string.path).size;
      } else {
        throw util.error(new Error('Cannot determine length of ' + string),
          { object: string });
      }
    },

    upperFirst: function upperFirst(string) {
      return string[0].toUpperCase() + string.substr(1);
    },

    lowerFirst: function lowerFirst(string) {
      return string[0].toLowerCase() + string.substr(1);
    }
  },

  ini: {
    parse: function string(ini) {
      var currentSection, map = {};
      util.arrayEach(ini.split(/\r?\n/), function(line) {
        line = line.split(/(^|\s)[;#]/)[0]; // remove comments
        var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);
        if (section) {
          currentSection = section[1];
        } else if (currentSection) {
          var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
          if (item) {
            map[currentSection] = map[currentSection] || {};
            map[currentSection][item[1]] = item[2];
          }
        }
      });

      return map;
    }
  },

  fn: {
    noop: function() {},


    makeAsync: function makeAsync(fn, expectedArgs) {
      if (expectedArgs && expectedArgs <= fn.length) {
        return fn;
      }

      return function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var callback = args.pop();
        var result = fn.apply(null, args);
        callback(result);
      };
    }
  },


  date: {


    getDate: function getDate() {
      if (!AWS) AWS = require('./core');
      if (AWS.config.systemClockOffset) { // use offset when non-zero
        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
      } else {
        return new Date();
      }
    },


    iso8601: function iso8601(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
    },


    rfc822: function rfc822(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toUTCString();
    },


    unixTimestamp: function unixTimestamp(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.getTime() / 1000;
    },


    from: function format(date) {
      if (typeof date === 'number') {
        return new Date(date * 1000); // unix timestamp
      } else {
        return new Date(date);
      }
    },


    format: function format(date, formatter) {
      if (!formatter) formatter = 'iso8601';
      return util.date[formatter](util.date.from(date));
    },

    parseTimestamp: function parseTimestamp(value) {
      if (typeof value === 'number') { // unix timestamp (number)
        return new Date(value * 1000);
      } else if (value.match(/^\d+$/)) { // unix timestamp
        return new Date(value * 1000);
      } else if (value.match(/^\d{4}/)) { // iso8601
        return new Date(value);
      } else if (value.match(/^\w{3},/)) { // rfc822
        return new Date(value);
      } else {
        throw util.error(
          new Error('unhandled timestamp format: ' + value),
          {code: 'TimestampParserError'});
      }
    }

  },

  crypto: {
    crc32Table: [
     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
     0x2D02EF8D],

    crc32: function crc32(data) {
      var tbl = util.crypto.crc32Table;
      var crc = 0 ^ -1;

      if (typeof data === 'string') {
        data = new util.Buffer(data);
      }

      for (var i = 0; i < data.length; i++) {
        var code = data.readUInt8(i);
        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
      }
      return (crc ^ -1) >>> 0;
    },

    hmac: function hmac(key, string, digest, fn) {
      if (!digest) digest = 'binary';
      if (digest === 'buffer') { digest = undefined; }
      if (!fn) fn = 'sha256';
      if (typeof string === 'string') string = new util.Buffer(string);
      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
    },

    md5: function md5(data, digest, callback) {
      return util.crypto.hash('md5', data, digest, callback);
    },

    sha256: function sha256(data, digest, callback) {
      return util.crypto.hash('sha256', data, digest, callback);
    },

    hash: function(algorithm, data, digest, callback) {
      var hash = util.crypto.createHash(algorithm);
      if (!digest) { digest = 'binary'; }
      if (digest === 'buffer') { digest = undefined; }
      if (typeof data === 'string') data = new util.Buffer(data);
      var sliceFn = util.arraySliceFn(data);
      var isBuffer = util.Buffer.isBuffer(data);
      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

      if (callback && typeof data === 'object' &&
          typeof data.on === 'function' && !isBuffer) {
        data.on('data', function(chunk) { hash.update(chunk); });
        data.on('error', function(err) { callback(err); });
        data.on('end', function() { callback(null, hash.digest(digest)); });
      } else if (callback && sliceFn && !isBuffer &&
                 typeof FileReader !== 'undefined') {
        var index = 0, size = 1024 * 512;
        var reader = new FileReader();
        reader.onerror = function() {
          callback(new Error('Failed to read data.'));
        };
        reader.onload = function() {
          var buf = new util.Buffer(new Uint8Array(reader.result));
          hash.update(buf);
          index += buf.length;
          reader._continueReading();
        };
        reader._continueReading = function() {
          if (index >= data.size) {
            callback(null, hash.digest(digest));
            return;
          }

          var back = index + size;
          if (back > data.size) back = data.size;
          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
        };

        reader._continueReading();
      } else {
        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
          data = new util.Buffer(new Uint8Array(data));
        }
        var out = hash.update(data).digest(digest);
        if (callback) callback(null, out);
        return out;
      }
    },

    toHex: function toHex(data) {
      var out = [];
      for (var i = 0; i < data.length; i++) {
        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
      }
      return out.join('');
    },

    createHash: function createHash(algorithm) {
      return util.crypto.lib.createHash(algorithm);
    }

  },




  abort: {},

  each: function each(object, iterFunction) {
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        var ret = iterFunction.call(this, key, object[key]);
        if (ret === util.abort) break;
      }
    }
  },

  arrayEach: function arrayEach(array, iterFunction) {
    for (var idx in array) {
      if (Object.prototype.hasOwnProperty.call(array, idx)) {
        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
        if (ret === util.abort) break;
      }
    }
  },

  update: function update(obj1, obj2) {
    util.each(obj2, function iterator(key, item) {
      obj1[key] = item;
    });
    return obj1;
  },

  merge: function merge(obj1, obj2) {
    return util.update(util.copy(obj1), obj2);
  },

  copy: function copy(object) {
    if (object === null || object === undefined) return object;
    var dupe = {};
    for (var key in object) {
      dupe[key] = object[key];
    }
    return dupe;
  },

  isEmpty: function isEmpty(obj) {
    for (var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        return false;
      }
    }
    return true;
  },

  arraySliceFn: function arraySliceFn(obj) {
    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
    return typeof fn === 'function' ? fn : null;
  },

  isType: function isType(obj, type) {
    if (typeof type === 'function') type = util.typeName(type);
    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
  },

  typeName: function typeName(type) {
    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
    var str = type.toString();
    var match = str.match(/^\s*function (.+)\(/);
    return match ? match[1] : str;
  },

  error: function error(err, options) {
    var originalError = null;
    if (typeof err.message === 'string' && err.message !== '') {
      if (typeof options === 'string' || (options && options.message)) {
        originalError = util.copy(err);
        originalError.message = err.message;
      }
    }
    err.message = err.message || null;

    if (typeof options === 'string') {
      err.message = options;
    } else if (typeof options === 'object' && options !== null) {
      util.update(err, options);
      if (options.message)
        err.message = options.message;
      if (options.code || options.name)
        err.code = options.code || options.name;
      if (options.stack)
        err.stack = options.stack;
    }

    if (typeof Object.defineProperty === 'function') {
      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
      Object.defineProperty(err, 'message', {enumerable: true});
    }

    err.name = options && options.name || err.name || err.code || 'Error';
    err.time = new Date();

    if (originalError) err.originalError = originalError;

    return err;
  },


  inherit: function inherit(klass, features) {
    var newObject = null;
    if (features === undefined) {
      features = klass;
      klass = Object;
      newObject = {};
    } else {
      var ctor = function ConstructorWrapper() {};
      ctor.prototype = klass.prototype;
      newObject = new ctor();
    }

    if (features.constructor === Object) {
      features.constructor = function() {
        if (klass !== Object) {
          return klass.apply(this, arguments);
        }
      };
    }

    features.constructor.prototype = newObject;
    util.update(features.constructor.prototype, features);
    features.constructor.__super__ = klass;
    return features.constructor;
  },


  mixin: function mixin() {
    var klass = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      for (var prop in arguments[i].prototype) {
        var fn = arguments[i].prototype[prop];
        if (prop !== 'constructor') {
          klass.prototype[prop] = fn;
        }
      }
    }
    return klass;
  },


  hideProperties: function hideProperties(obj, props) {
    if (typeof Object.defineProperty !== 'function') return;

    util.arrayEach(props, function (key) {
      Object.defineProperty(obj, key, {
        enumerable: false, writable: true, configurable: true });
    });
  },


  property: function property(obj, name, value, enumerable, isValue) {
    var opts = {
      configurable: true,
      enumerable: enumerable !== undefined ? enumerable : true
    };
    if (typeof value === 'function' && !isValue) {
      opts.get = value;
    }
    else {
      opts.value = value; opts.writable = true;
    }

    Object.defineProperty(obj, name, opts);
  },


  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
    var cachedValue = null;

    util.property(obj, name, function() {
      if (cachedValue === null) {
        cachedValue = get();
      }
      return cachedValue;
    }, enumerable);
  },


  hoistPayloadMember: function hoistPayloadMember(resp) {
    var req = resp.request;
    var operation = req.operation;
    var output = req.service.api.operations[operation].output;
    if (output.payload) {
      var payloadMember = output.members[output.payload];
      var responsePayload = resp.data[output.payload];
      if (payloadMember.type === 'structure') {
        util.each(responsePayload, function(key, value) {
          util.property(resp.data, key, value, false);
        });
      }
    }
  },


  computeSha256: function computeSha256(body, done) {
    if (util.isNode()) {
      var Stream = util.stream.Stream;
      var fs = require('fs');
      if (body instanceof Stream) {
        if (typeof body.path === 'string') { // assume file object
          var settings = {};
          if (typeof body.start === 'number') {
            settings.start = body.start;
          }
          if (typeof body.end === 'number') {
            settings.end = body.end;
          }
          body = fs.createReadStream(body.path, settings);
        } else { // TODO support other stream types
          return done(new Error('Non-file stream objects are ' +
                                'not supported with SigV4'));
        }
      }
    }

    util.crypto.sha256(body, 'hex', function(err, sha) {
      if (err) done(err);
      else done(null, sha);
    });
  },


  isClockSkewed: function isClockSkewed(serverTime) {
    if (serverTime) {
      util.property(AWS.config, 'isClockSkewed',
        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
      return AWS.config.isClockSkewed;
    }
  },

  applyClockOffset: function applyClockOffset(serverTime) {
    if (serverTime)
      AWS.config.systemClockOffset = serverTime - new Date().getTime();
  },


  extractRequestId: function extractRequestId(resp) {
    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
                     resp.httpResponse.headers['x-amzn-requestid'];

    if (!requestId && resp.data && resp.data.ResponseMetadata) {
      requestId = resp.data.ResponseMetadata.RequestId;
    }

    if (requestId) {
      resp.requestId = requestId;
    }

    if (resp.error) {
      resp.error.requestId = requestId;
    }
  },


  addPromises: function addPromises(constructors, PromiseDependency) {
    if (PromiseDependency === undefined && AWS && AWS.config) {
      PromiseDependency = AWS.config.getPromisesDependency();
    }
    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
      PromiseDependency = Promise;
    }
    if (typeof PromiseDependency !== 'function') var deletePromises = true;
    if (!Array.isArray(constructors)) constructors = [constructors];

    for (var ind = 0; ind < constructors.length; ind++) {
      var constructor = constructors[ind];
      if (deletePromises) {
        if (constructor.deletePromisesFromClass) {
          constructor.deletePromisesFromClass();
        }
      } else if (constructor.addPromisesToClass) {
        constructor.addPromisesToClass(PromiseDependency);
      }
    }
  },


  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
    return function promise() {
      var self = this;
      return new PromiseDependency(function(resolve, reject) {
        self[methodName](function(err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
      });
    };
  },


  isDualstackAvailable: function isDualstackAvailable(service) {
    if (!service) return false;
    var metadata = require('../apis/metadata.json');
    if (typeof service !== 'string') service = service.serviceIdentifier;
    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
    return !!metadata[service].dualstackAvailable;
  },


  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions) {
    if (!retryDelayOptions) retryDelayOptions = {};
    var customBackoff = retryDelayOptions.customBackoff || null;
    if (typeof customBackoff === 'function') {
      return customBackoff(retryCount);
    }
    var base = retryDelayOptions.base || 100;
    var delay = Math.random() * (Math.pow(2, retryCount) * base);
    return delay;
  },


  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
    if (!options) options = {};
    var http = AWS.HttpClient.getInstance();
    var httpOptions = options.httpOptions || {};
    var retryCount = 0;

    var errCallback = function(err) {
      var maxRetries = options.maxRetries || 0;
      if (err && err.code === 'TimeoutError') err.retryable = true;
      if (err && err.retryable && retryCount < maxRetries) {
        retryCount++;
        var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions);
        setTimeout(sendRequest, delay + (err.retryAfter || 0));
      } else {
        cb(err);
      }
    };

    var sendRequest = function() {
      var data = '';
      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
        httpResponse.on('end', function() {
          var statusCode = httpResponse.statusCode;
          if (statusCode < 300) {
            cb(null, data);
          } else {
            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
            var err = util.error(new Error(),
              { retryable: statusCode >= 500 || statusCode === 429 }
            );
            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
            errCallback(err);
          }
        });
      }, errCallback);
    };

    process.nextTick(sendRequest);
  }

};

module.exports = util;

}).call(this,require('_process'))
},{"../apis/metadata.json":3,"./core":10,"_process":117,"fs":56}],53:[function(require,module,exports){
var util = require('../util');
var Shape = require('../model/shape');

function DomXmlParser() { }

DomXmlParser.prototype.parse = function(xml, shape) {
  if (xml.replace(/^\s+/, '') === '') return {};

  var result, error;
  try {
    if (window.DOMParser) {
      try {
        var parser = new DOMParser();
        result = parser.parseFromString(xml, 'text/xml');
      } catch (syntaxError) {
        throw util.error(new Error('Parse error in document'),
          {
            originalError: syntaxError,
            code: 'XMLParserError',
            retryable: true
          });
      }

      if (result.documentElement === null) {
        throw util.error(new Error('Cannot parse empty document.'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }

      var isError = result.getElementsByTagName('parsererror')[0];
      if (isError && (isError.parentNode === result ||
          isError.parentNode.nodeName === 'body' ||
          isError.parentNode.parentNode === result ||
          isError.parentNode.parentNode.nodeName === 'body')) {
        var errorElement = isError.getElementsByTagName('div')[0] || isError;
        throw util.error(new Error(errorElement.textContent || 'Parser error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else if (window.ActiveXObject) {
      result = new window.ActiveXObject('Microsoft.XMLDOM');
      result.async = false;

      if (!result.loadXML(xml)) {
        throw util.error(new Error('Parse error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else {
      throw new Error('Cannot load XML parser');
    }
  } catch (e) {
    error = e;
  }

  if (result && result.documentElement && !error) {
    var data = parseXml(result.documentElement, shape);
    var metadata = result.getElementsByTagName('ResponseMetadata')[0];
    if (metadata) {
      data.ResponseMetadata = parseXml(metadata, {});
    }
    return data;
  } else if (error) {
    throw util.error(error || new Error(), {code: 'XMLParserError', retryable: true});
  } else { // empty xml document
    return {};
  }
};

function parseXml(xml, shape) {
  if (!shape) shape = {};
  switch (shape.type) {
    case 'structure': return parseStructure(xml, shape);
    case 'map': return parseMap(xml, shape);
    case 'list': return parseList(xml, shape);
    case undefined: case null: return parseUnknown(xml);
    default: return parseScalar(xml, shape);
  }
}

function parseStructure(xml, shape) {
  var data = {};
  if (xml === null) return data;

  util.each(shape.members, function(memberName, memberShape) {
    if (memberShape.isXmlAttribute) {
      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {
        var value = xml.attributes[memberShape.name].value;
        data[memberName] = parseXml({textContent: value}, memberShape);
      }
    } else {
      var xmlChild = memberShape.flattened ? xml :
        xml.getElementsByTagName(memberShape.name)[0];
      if (xmlChild) {
        data[memberName] = parseXml(xmlChild, memberShape);
      } else if (!memberShape.flattened && memberShape.type === 'list') {
        data[memberName] = memberShape.defaultValue;
      }
    }
  });

  return data;
}

function parseMap(xml, shape) {
  var data = {};
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';
  var tagName = shape.flattened ? shape.name : 'entry';

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      var key = child.getElementsByTagName(xmlKey)[0].textContent;
      var value = child.getElementsByTagName(xmlValue)[0];
      data[key] = parseXml(value, shape.value);
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseList(xml, shape) {
  var data = [];
  var tagName = shape.flattened ? shape.name : (shape.member.name || 'member');

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      data.push(parseXml(child, shape.member));
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseScalar(xml, shape) {
  if (xml.getAttribute) {
    var encoding = xml.getAttribute('encoding');
    if (encoding === 'base64') {
      shape = new Shape.create({type: encoding});
    }
  }

  var text = xml.textContent;
  if (text === '') text = null;
  if (typeof shape.toType === 'function') {
    return shape.toType(text);
  } else {
    return text;
  }
}

function parseUnknown(xml) {
  if (xml === undefined || xml === null) return '';

  if (!xml.firstElementChild) {
    if (xml.parentNode.parentNode === null) return {};
    if (xml.childNodes.length === 0) return '';
    else return xml.textContent;
  }

  var shape = {type: 'structure', members: {}};
  var child = xml.firstElementChild;
  while (child) {
    var tag = child.nodeName;
    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {
      shape.members[tag].type = 'list';
    } else {
      shape.members[tag] = {name: tag};
    }
    child = child.nextElementSibling;
  }
  return parseStructure(xml, shape);
}

module.exports = DomXmlParser;

},{"../model/shape":27,"../util":52}],54:[function(require,module,exports){
var util = require('../util');
var builder = require('xmlbuilder');

function XmlBuilder() { }

XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
  var xml = builder.create(rootElement);
  applyNamespaces(xml, shape);
  serialize(xml, params, shape);
  return xml.children.length > 0 || noEmpty ? xml.root().toString() : '';
};

function serialize(xml, value, shape) {
  switch (shape.type) {
    case 'structure': return serializeStructure(xml, value, shape);
    case 'map': return serializeMap(xml, value, shape);
    case 'list': return serializeList(xml, value, shape);
    default: return serializeScalar(xml, value, shape);
  }
}

function serializeStructure(xml, params, shape) {
  util.arrayEach(shape.memberNames, function(memberName) {
    var memberShape = shape.members[memberName];
    if (memberShape.location !== 'body') return;

    var value = params[memberName];
    var name = memberShape.name;
    if (value !== undefined && value !== null) {
      if (memberShape.isXmlAttribute) {
        xml.att(name, value);
      } else if (memberShape.flattened) {
        serialize(xml, value, memberShape);
      } else {
        var element = xml.ele(name);
        applyNamespaces(element, memberShape);
        serialize(element, value, memberShape);
      }
    }
  });
}

function serializeMap(xml, map, shape) {
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';

  util.each(map, function(key, value) {
    var entry = xml.ele(shape.flattened ? shape.name : 'entry');
    serialize(entry.ele(xmlKey), key, shape.key);
    serialize(entry.ele(xmlValue), value, shape.value);
  });
}

function serializeList(xml, list, shape) {
  if (shape.flattened) {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || shape.name;
      var element = xml.ele(name);
      serialize(element, value, shape.member);
    });
  } else {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || 'member';
      var element = xml.ele(name);
      serialize(element, value, shape.member);
    });
  }
}

function serializeScalar(xml, value, shape) {
  xml.txt(shape.toWireFormat(value));
}

function applyNamespaces(xml, shape) {
  var uri, prefix = 'xmlns';
  if (shape.xmlNamespaceUri) {
    uri = shape.xmlNamespaceUri;
    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
  } else if (xml.isRoot && shape.api.xmlNamespaceUri) {
    uri = shape.api.xmlNamespaceUri;
  }

  if (uri) xml.att(prefix, uri);
}

module.exports = XmlBuilder;

},{"../util":52,"xmlbuilder":145}],55:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],56:[function(require,module,exports){

},{}],57:[function(require,module,exports){
(function (global){



'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50


Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()


exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}



function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}

Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false


  if (start === undefined || start < 0) {
    start = 0
  }
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1

  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  if (Buffer.isBuffer(val)) {
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}


function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

Buffer.prototype.fill = function fill (val, start, end, encoding) {
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  if (str.length < 2) return ''
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      if (!leadSurrogate) {
        if (codePoint > 0xDBFF) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        leadSurrogate = codePoint

        continue
      }

      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":55,"ieee754":66,"isarray":67}],58:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"base64-js":55,"dup":57,"ieee754":66,"isarray":67}],59:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":57}],60:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":61,"./rng":62,"./sha":63,"./sha256":64,"buffer":57}],61:[function(require,module,exports){


var helpers = require('./helpers');


function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}


function core_md5(x, len)
{

  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}


function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}


function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}


function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":59}],62:[function(require,module,exports){
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],63:[function(require,module,exports){


var helpers = require('./helpers');


function core_sha1(x, len)
{

  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}


function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}


function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}


function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}


function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":59}],64:[function(require,module,exports){



var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;

  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":59}],65:[function(require,module,exports){

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

EventEmitter.defaultMaxListeners = 10;

EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    this._events[type].push(listener);
  else
    this._events[type] = [this._events[type], listener];

  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],66:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],67:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],68:[function(require,module,exports){
(function(exports) {
  "use strict";

  function isArray(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } else {
      return false;
    }
  }

  function isObject(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    } else {
      return false;
    }
  }

  function strictDeepEqual(first, second) {
    if (first === second) {
      return true;
    }

    var firstType = Object.prototype.toString.call(first);
    if (firstType !== Object.prototype.toString.call(second)) {
      return false;
    }
    if (isArray(first) === true) {
      if (first.length !== second.length) {
        return false;
      }
      for (var i = 0; i < first.length; i++) {
        if (strictDeepEqual(first[i], second[i]) === false) {
          return false;
        }
      }
      return true;
    }
    if (isObject(first) === true) {
      var keysSeen = {};
      for (var key in first) {
        if (hasOwnProperty.call(first, key)) {
          if (strictDeepEqual(first[key], second[key]) === false) {
            return false;
          }
          keysSeen[key] = true;
        }
      }
      for (var key2 in second) {
        if (hasOwnProperty.call(second, key2)) {
          if (keysSeen[key2] !== true) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  function isFalse(obj) {

    if (obj === "" || obj === false || obj === null) {
        return true;
    } else if (isArray(obj) && obj.length === 0) {
        return true;
    } else if (isObject(obj)) {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              return false;
            }
        }
        return true;
    } else {
        return false;
    }
  }

  function objValues(obj) {
    var keys = Object.keys(obj);
    var values = [];
    for (var i = 0; i < keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    return values;
  }

  function merge(a, b) {
      var merged = {};
      for (var key in a) {
          merged[key] = a[key];
      }
      for (var key2 in b) {
          merged[key2] = b[key2];
      }
      return merged;
  }

  var trimLeft;
  if (typeof String.prototype.trimLeft === "function") {
    trimLeft = function(str) {
      return str.trimLeft();
    };
  } else {
    trimLeft = function(str) {
      return str.match(/^\s*(.*)/)[1];
    };
  }

  var TYPE_NUMBER = 0;
  var TYPE_ANY = 1;
  var TYPE_STRING = 2;
  var TYPE_ARRAY = 3;
  var TYPE_OBJECT = 4;
  var TYPE_BOOLEAN = 5;
  var TYPE_EXPREF = 6;
  var TYPE_NULL = 7;
  var TYPE_ARRAY_NUMBER = 8;
  var TYPE_ARRAY_STRING = 9;

  var TOK_EOF = "EOF";
  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
  var TOK_RBRACKET = "Rbracket";
  var TOK_RPAREN = "Rparen";
  var TOK_COMMA = "Comma";
  var TOK_COLON = "Colon";
  var TOK_RBRACE = "Rbrace";
  var TOK_NUMBER = "Number";
  var TOK_CURRENT = "Current";
  var TOK_EXPREF = "Expref";
  var TOK_PIPE = "Pipe";
  var TOK_OR = "Or";
  var TOK_AND = "And";
  var TOK_EQ = "EQ";
  var TOK_GT = "GT";
  var TOK_LT = "LT";
  var TOK_GTE = "GTE";
  var TOK_LTE = "LTE";
  var TOK_NE = "NE";
  var TOK_FLATTEN = "Flatten";
  var TOK_STAR = "Star";
  var TOK_FILTER = "Filter";
  var TOK_DOT = "Dot";
  var TOK_NOT = "Not";
  var TOK_LBRACE = "Lbrace";
  var TOK_LBRACKET = "Lbracket";
  var TOK_LPAREN= "Lparen";
  var TOK_LITERAL= "Literal";


  var basicTokens = {
    ".": TOK_DOT,
    "*": TOK_STAR,
    ",": TOK_COMMA,
    ":": TOK_COLON,
    "{": TOK_LBRACE,
    "}": TOK_RBRACE,
    "]": TOK_RBRACKET,
    "(": TOK_LPAREN,
    ")": TOK_RPAREN,
    "@": TOK_CURRENT
  };

  var operatorStartToken = {
      "<": true,
      ">": true,
      "=": true,
      "!": true
  };

  var skipChars = {
      " ": true,
      "\t": true,
      "\n": true
  };


  function isAlpha(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             ch === "_";
  }

  function isNum(ch) {
      return (ch >= "0" && ch <= "9") ||
             ch === "-";
  }
  function isAlphaNum(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             (ch >= "0" && ch <= "9") ||
             ch === "_";
  }

  function Lexer() {
  }
  Lexer.prototype = {
      tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
              if (isAlpha(stream[this._current])) {
                  start = this._current;
                  identifier = this._consumeUnquotedIdentifier(stream);
                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (basicTokens[stream[this._current]] !== undefined) {
                  tokens.push({type: basicTokens[stream[this._current]],
                              value: stream[this._current],
                              start: this._current});
                  this._current++;
              } else if (isNum(stream[this._current])) {
                  token = this._consumeNumber(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "[") {
                  token = this._consumeLBracket(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "\"") {
                  start = this._current;
                  identifier = this._consumeQuotedIdentifier(stream);
                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "'") {
                  start = this._current;
                  identifier = this._consumeRawStringLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "`") {
                  start = this._current;
                  var literal = this._consumeLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: literal,
                               start: start});
              } else if (operatorStartToken[stream[this._current]] !== undefined) {
                  tokens.push(this._consumeOperator(stream));
              } else if (skipChars[stream[this._current]] !== undefined) {
                  this._current++;
              } else if (stream[this._current] === "&") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({type: TOK_AND, value: "&&", start: start});
                  } else {
                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
                  }
              } else if (stream[this._current] === "|") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({type: TOK_OR, value: "||", start: start});
                  } else {
                      tokens.push({type: TOK_PIPE, value: "|", start: start});
                  }
              } else {
                  var error = new Error("Unknown character:" + stream[this._current]);
                  error.name = "LexerError";
                  throw error;
              }
          }
          return tokens;
      },

      _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
              this._current++;
          }
          return stream.slice(start, this._current);
      },

      _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "\"" && this._current < maxLength) {
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "\"")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
      },

      _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "'")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
      },

      _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
              this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {type: TOK_NUMBER, value: value, start: start};
      },

      _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
              this._current++;
              return {type: TOK_FILTER, value: "[?", start: start};
          } else if (stream[this._current] === "]") {
              this._current++;
              return {type: TOK_FLATTEN, value: "[]", start: start};
          } else {
              return {type: TOK_LBRACKET, value: "[", start: start};
          }
      },

      _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_NE, value: "!=", start: start};
              } else {
                return {type: TOK_NOT, value: "!", start: start};
              }
          } else if (startingChar === "<") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_LTE, value: "<=", start: start};
              } else {
                  return {type: TOK_LT, value: "<", start: start};
              }
          } else if (startingChar === ">") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_GTE, value: ">=", start: start};
              } else {
                  return {type: TOK_GT, value: ">", start: start};
              }
          } else if (startingChar === "=") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_EQ, value: "==", start: start};
              }
          }
      },

      _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while(stream[this._current] !== "`" && this._current < maxLength) {
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "`")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
              literal = JSON.parse(literalString);
          } else {
              literal = JSON.parse("\"" + literalString + "\"");
          }
          this._current++;
          return literal;
      },

      _looksLikeJSON: function(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
              return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
              return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
              return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
              try {
                  JSON.parse(literalString);
                  return true;
              } catch (ex) {
                  return false;
              }
          } else {
              return false;
          }
      }
  };

      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

  function Parser() {
  }

  Parser.prototype = {
      parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
              var t = this._lookaheadToken(0);
              var error = new Error(
                  "Unexpected token type: " + t.type + ", value: " + t.value);
              error.name = "ParserError";
              throw error;
          }
          return ast;
      },

      _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({type: TOK_EOF, value: "", start: expression.length});
          this.tokens = tokens;
      },

      expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
              this._advance();
              left = this.led(currentToken, left);
              currentToken = this._lookahead(0);
          }
          return left;
      },

      _lookahead: function(number) {
          return this.tokens[this.index + number].type;
      },

      _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
      },

      _advance: function() {
          this.index++;
      },

      nud: function(token) {
        var left;
        var right;
        var expression;
        switch (token.type) {
          case TOK_LITERAL:
            return {type: "Literal", value: token.value};
          case TOK_UNQUOTEDIDENTIFIER:
            return {type: "Field", name: token.value};
          case TOK_QUOTEDIDENTIFIER:
            var node = {type: "Field", name: token.value};
            if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
            } else {
                return node;
            }
            break;
          case TOK_NOT:
            right = this.expression(bindingPower.Not);
            return {type: "NotExpression", children: [right]};
          case TOK_STAR:
            left = {type: "Identity"};
            right = null;
            if (this._lookahead(0) === TOK_RBRACKET) {
                right = {type: "Identity"};
            } else {
                right = this._parseProjectionRHS(bindingPower.Star);
            }
            return {type: "ValueProjection", children: [left, right]};
          case TOK_FILTER:
            return this.led(token.type, {type: "Identity"});
          case TOK_LBRACE:
            return this._parseMultiselectHash();
          case TOK_FLATTEN:
            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
            right = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [left, right]};
          case TOK_LBRACKET:
            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({type: "Identity"}, right);
            } else if (this._lookahead(0) === TOK_STAR &&
                       this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection",
                        children: [{type: "Identity"}, right]};
            } else {
                return this._parseMultiselectList();
            }
            break;
          case TOK_CURRENT:
            return {type: TOK_CURRENT};
          case TOK_EXPREF:
            expression = this.expression(bindingPower.Expref);
            return {type: "ExpressionReference", children: [expression]};
          case TOK_LPAREN:
            var args = [];
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            return args[0];
          default:
            this._errorToken(token);
        }
      },

      led: function(tokenName, left) {
        var right;
        switch(tokenName) {
          case TOK_DOT:
            var rbp = bindingPower.Dot;
            if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {type: "Subexpression", children: [left, right]};
            } else {
                this._advance();
                right = this._parseProjectionRHS(rbp);
                return {type: "ValueProjection", children: [left, right]};
            }
            break;
          case TOK_PIPE:
            right = this.expression(bindingPower.Pipe);
            return {type: TOK_PIPE, children: [left, right]};
          case TOK_OR:
            right = this.expression(bindingPower.Or);
            return {type: "OrExpression", children: [left, right]};
          case TOK_AND:
            right = this.expression(bindingPower.And);
            return {type: "AndExpression", children: [left, right]};
          case TOK_LPAREN:
            var name = left.name;
            var args = [];
            var expression, node;
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              if (this._lookahead(0) === TOK_COMMA) {
                this._match(TOK_COMMA);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            node = {type: "Function", name: name, children: args};
            return node;
          case TOK_FILTER:
            var condition = this.expression(0);
            this._match(TOK_RBRACKET);
            if (this._lookahead(0) === TOK_FLATTEN) {
              right = {type: "Identity"};
            } else {
              right = this._parseProjectionRHS(bindingPower.Filter);
            }
            return {type: "FilterProjection", children: [left, right, condition]};
          case TOK_FLATTEN:
            var leftNode = {type: TOK_FLATTEN, children: [left]};
            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [leftNode, rightNode]};
          case TOK_EQ:
          case TOK_NE:
          case TOK_GT:
          case TOK_GTE:
          case TOK_LT:
          case TOK_LTE:
            return this._parseComparator(left, tokenName);
          case TOK_LBRACKET:
            var token = this._lookaheadToken(0);
            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
            } else {
                this._match(TOK_STAR);
                this._match(TOK_RBRACKET);
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection", children: [left, right]};
            }
            break;
          default:
            this._errorToken(this._lookaheadToken(0));
        }
      },

      _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
              this._advance();
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Expected " + tokenType + ", got: " + t.type);
              error.name = "ParserError";
              throw error;
          }
      },

      _errorToken: function(token) {
          var error = new Error("Invalid token (" +
                                token.type + "): \"" +
                                token.value + "\"");
          error.name = "ParserError";
          throw error;
      },


      _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
              return this._parseSliceExpression();
          } else {
              var node = {
                  type: "Index",
                  value: this._lookaheadToken(0).value};
              this._advance();
              this._match(TOK_RBRACKET);
              return node;
          }
      },

      _projectIfSlice: function(left, right) {
          var indexExpr = {type: "IndexExpression", children: [left, right]};
          if (right.type === "Slice") {
              return {
                  type: "Projection",
                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
              };
          } else {
              return indexExpr;
          }
      },

      _parseSliceExpression: function() {
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
              if (currentToken === TOK_COLON) {
                  index++;
                  this._advance();
              } else if (currentToken === TOK_NUMBER) {
                  parts[index] = this._lookaheadToken(0).value;
                  this._advance();
              } else {
                  var t = this._lookahead(0);
                  var error = new Error("Syntax error, unexpected token: " +
                                        t.value + "(" + t.type + ")");
                  error.name = "Parsererror";
                  throw error;
              }
              currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
              type: "Slice",
              children: parts
          };
      },

      _parseComparator: function(left, comparator) {
        var right = this.expression(bindingPower[comparator]);
        return {type: "Comparator", name: comparator, children: [left, right]};
      },

      _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
              return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
              this._match(TOK_LBRACKET);
              return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
              this._match(TOK_LBRACE);
              return this._parseMultiselectHash();
          }
      },

      _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
              right = {type: "Identity"};
          } else if (this._lookahead(0) === TOK_LBRACKET) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
              this._match(TOK_DOT);
              right = this._parseDotRHS(rbp);
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Sytanx error, unexpected token: " +
                                    t.value + "(" + t.type + ")");
              error.name = "ParserError";
              throw error;
          }
          return right;
      },

      _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
              var expression = this.expression(0);
              expressions.push(expression);
              if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                  if (this._lookahead(0) === TOK_RBRACKET) {
                    throw new Error("Unexpected token Rbracket");
                  }
              }
          }
          this._match(TOK_RBRACKET);
          return {type: "MultiSelectList", children: expressions};
      },

      _parseMultiselectHash: function() {
        var pairs = [];
        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        var keyToken, keyName, value, node;
        for (;;) {
          keyToken = this._lookaheadToken(0);
          if (identifierTypes.indexOf(keyToken.type) < 0) {
            throw new Error("Expecting an identifier token, got: " +
                            keyToken.type);
          }
          keyName = keyToken.value;
          this._advance();
          this._match(TOK_COLON);
          value = this.expression(0);
          node = {type: "KeyValuePair", name: keyName, value: value};
          pairs.push(node);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          } else if (this._lookahead(0) === TOK_RBRACE) {
            this._match(TOK_RBRACE);
            break;
          }
        }
        return {type: "MultiSelectHash", children: pairs};
      }
  };


  function TreeInterpreter(runtime) {
    this.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      search: function(node, value) {
          return this.visit(node, value);
      },

      visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value === null ) {
                  return null;
              } else if (isObject(value)) {
                  field = value[node.name];
                  if (field === undefined) {
                      return null;
                  } else {
                      return field;
                  }
              } else {
                return null;
              }
              break;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                  result = this.visit(node.children[1], result);
                  if (result === null) {
                      return null;
                  }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === undefined) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                  for (i = start; i < stop; i += step) {
                      result.push(value[i]);
                  }
              } else {
                  for (i = start; i > stop; i += step) {
                      result.push(value[i]);
                  }
              }
              return result;
            case "Projection":
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch(node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                  collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                  matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                  resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
      },

      computeSliceParams: function(arrayLength, sliceParams) {
        var start = sliceParams[0];
        var stop = sliceParams[1];
        var step = sliceParams[2];
        var computed = [null, null, null];
        if (step === null) {
          step = 1;
        } else if (step === 0) {
          var error = new Error("Invalid slice, step cannot be 0");
          error.name = "RuntimeError";
          throw error;
        }
        var stepValueNegative = step < 0 ? true : false;

        if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
        } else {
            start = this.capSliceRange(arrayLength, start, step);
        }

        if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
        } else {
            stop = this.capSliceRange(arrayLength, stop, step);
        }
        computed[0] = start;
        computed[1] = stop;
        computed[2] = step;
        return computed;
      },

      capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
              actualValue += arrayLength;
              if (actualValue < 0) {
                  actualValue = step < 0 ? -1 : 0;
              }
          } else if (actualValue >= arrayLength) {
              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
      }

  };

  function Runtime(interpreter) {
    this._interpreter = interpreter;
    this.functionTable = {
        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
        contains: {
            _func: this._functionContains,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
                        {types: [TYPE_ANY]}]},
        "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
        length: {
            _func: this._functionLength,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        map: {
            _func: this._functionMap,
            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
        max: {
            _func: this._functionMax,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "merge": {
            _func: this._functionMerge,
            _signature: [{types: [TYPE_OBJECT], variadic: true}]
        },
        "max_by": {
          _func: this._functionMaxBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        min: {
            _func: this._functionMin,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "min_by": {
          _func: this._functionMinBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        "sort_by": {
          _func: this._functionSortBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        join: {
            _func: this._functionJoin,
            _signature: [
                {types: [TYPE_STRING]},
                {types: [TYPE_ARRAY_STRING]}
            ]
        },
        reverse: {
            _func: this._functionReverse,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
        "not_null": {
            _func: this._functionNotNull,
            _signature: [{types: [TYPE_ANY], variadic: true}]
        }
    };
  }

  Runtime.prototype = {
    callFunction: function(name, resolvedArgs) {
      var functionEntry = this.functionTable[name];
      if (functionEntry === undefined) {
          throw new Error("Unknown function: " + name + "()");
      }
      this._validateArgs(name, resolvedArgs, functionEntry._signature);
      return functionEntry._func.call(this, resolvedArgs);
    },

    _validateArgs: function(name, args, signature) {
        var pluralized;
        if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " +
                                "takes at least" + signature.length + pluralized +
                                " but received " + args.length);
            }
        } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " +
                            "takes " + signature.length + pluralized +
                            " but received " + args.length);
        }
        var currentSpec;
        var actualType;
        var typeMatched;
        for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = true;
                    break;
                }
            }
            if (!typeMatched) {
                throw new Error("TypeError: " + name + "() " +
                                "expected argument " + (i + 1) +
                                " to be type " + currentSpec +
                                " but received type " + actualType +
                                " instead.");
            }
        }
    },

    _typeMatches: function(actual, expected, argValue) {
        if (expected === TYPE_ANY) {
            return true;
        }
        if (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
            if (expected === TYPE_ARRAY) {
                return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
                var subtype;
                if (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } else if (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                for (var i = 0; i < argValue.length; i++) {
                    if (!this._typeMatches(
                            this._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        return false;
                    }
                }
                return true;
            }
        } else {
            return actual === expected;
        }
    },
    _getTypeName: function(obj) {
        switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
        }
    },

    _functionStartsWith: function(resolvedArgs) {
        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
    },

    _functionEndsWith: function(resolvedArgs) {
        var searchStr = resolvedArgs[0];
        var suffix = resolvedArgs[1];
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
    },

    _functionReverse: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_STRING) {
          var originalStr = resolvedArgs[0];
          var reversedStr = "";
          for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
          }
          return reversedStr;
        } else {
          var reversedArray = resolvedArgs[0].slice(0);
          reversedArray.reverse();
          return reversedArray;
        }
    },

    _functionAbs: function(resolvedArgs) {
      return Math.abs(resolvedArgs[0]);
    },

    _functionCeil: function(resolvedArgs) {
        return Math.ceil(resolvedArgs[0]);
    },

    _functionAvg: function(resolvedArgs) {
        var sum = 0;
        var inputArray = resolvedArgs[0];
        for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
        }
        return sum / inputArray.length;
    },

    _functionContains: function(resolvedArgs) {
        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
    },

    _functionFloor: function(resolvedArgs) {
        return Math.floor(resolvedArgs[0]);
    },

    _functionLength: function(resolvedArgs) {
       if (!isObject(resolvedArgs[0])) {
         return resolvedArgs[0].length;
       } else {
         return Object.keys(resolvedArgs[0]).length;
       }
    },

    _functionMap: function(resolvedArgs) {
      var mapped = [];
      var interpreter = this._interpreter;
      var exprefNode = resolvedArgs[0];
      var elements = resolvedArgs[1];
      for (var i = 0; i < elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      return mapped;
    },

    _functionMerge: function(resolvedArgs) {
      var merged = {};
      for (var i = 0; i < resolvedArgs.length; i++) {
        var current = resolvedArgs[i];
        for (var key in current) {
          merged[key] = current[key];
        }
      }
      return merged;
    },

    _functionMax: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.max.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var maxElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
              }
          }
          return maxElement;
        }
      } else {
          return null;
      }
    },

    _functionMin: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.min.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var minElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
              }
          }
          return minElement;
        }
      } else {
        return null;
      }
    },

    _functionSum: function(resolvedArgs) {
      var sum = 0;
      var listToSum = resolvedArgs[0];
      for (var i = 0; i < listToSum.length; i++) {
        sum += listToSum[i];
      }
      return sum;
    },

    _functionType: function(resolvedArgs) {
        switch (this._getTypeName(resolvedArgs[0])) {
          case TYPE_NUMBER:
            return "number";
          case TYPE_STRING:
            return "string";
          case TYPE_ARRAY:
            return "array";
          case TYPE_OBJECT:
            return "object";
          case TYPE_BOOLEAN:
            return "boolean";
          case TYPE_EXPREF:
            return "expref";
          case TYPE_NULL:
            return "null";
        }
    },

    _functionKeys: function(resolvedArgs) {
        return Object.keys(resolvedArgs[0]);
    },

    _functionValues: function(resolvedArgs) {
        var obj = resolvedArgs[0];
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        return values;
    },

    _functionJoin: function(resolvedArgs) {
        var joinChar = resolvedArgs[0];
        var listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
    },

    _functionToArray: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
        } else {
            return [resolvedArgs[0]];
        }
    },

    _functionToString: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
        } else {
            return JSON.stringify(resolvedArgs[0]);
        }
    },

    _functionToNumber: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        var convertedValue;
        if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
        } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
                return convertedValue;
            }
        }
        return null;
    },

    _functionNotNull: function(resolvedArgs) {
        for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                return resolvedArgs[i];
            }
        }
        return null;
    },

    _functionSort: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        sortedArray.sort();
        return sortedArray;
    },

    _functionSortBy: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
            return sortedArray;
        }
        var interpreter = this._interpreter;
        var exprefNode = resolvedArgs[1];
        var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0]));
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
        }
        var that = this;
        var decorated = [];
        for (var i = 0; i < sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(function(a, b) {
          var exprA = interpreter.visit(exprefNode, a[1]);
          var exprB = interpreter.visit(exprefNode, b[1]);
          if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprA));
          } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprB));
          }
          if (exprA > exprB) {
            return 1;
          } else if (exprA < exprB) {
            return -1;
          } else {
            return a[0] - b[0];
          }
        });
        for (var j = 0; j < decorated.length; j++) {
          sortedArray[j] = decorated[j][1];
        }
        return sortedArray;
    },

    _functionMaxBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var maxNumber = -Infinity;
      var maxRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current > maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      return maxRecord;
    },

    _functionMinBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var minNumber = Infinity;
      var minRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current < minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      return minRecord;
    },

    createKeyFunction: function(exprefNode, allowedTypes) {
      var that = this;
      var interpreter = this._interpreter;
      var keyFunc = function(x) {
        var current = interpreter.visit(exprefNode, x);
        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
          var msg = "TypeError: expected one of " + allowedTypes +
                    ", received " + that._getTypeName(current);
          throw new Error(msg);
        }
        return current;
      };
      return keyFunc;
    }

  };

  function compile(stream) {
    var parser = new Parser();
    var ast = parser.parse(stream);
    return ast;
  }

  function tokenize(stream) {
      var lexer = new Lexer();
      return lexer.tokenize(stream);
  }

  function search(data, expression) {
      var parser = new Parser();
      var runtime = new Runtime();
      var interpreter = new TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      var node = parser.parse(expression);
      return interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})(typeof exports === "undefined" ? this.jmespath = {} : exports);

},{}],69:[function(require,module,exports){
var arrayEvery = require('../internal/arrayEvery'),
    baseCallback = require('../internal/baseCallback'),
    baseEvery = require('../internal/baseEvery'),
    isArray = require('../lang/isArray');


function every(collection, predicate, thisArg) {
  var func = isArray(collection) ? arrayEvery : baseEvery;
  if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
    predicate = baseCallback(predicate, thisArg, 3);
  }
  return func(collection, predicate);
}

module.exports = every;

},{"../internal/arrayEvery":70,"../internal/baseCallback":72,"../internal/baseEvery":76,"../lang/isArray":103}],70:[function(require,module,exports){

function arrayEvery(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}

module.exports = arrayEvery;

},{}],71:[function(require,module,exports){
var baseCopy = require('./baseCopy'),
    keys = require('../object/keys');


function baseAssign(object, source, customizer) {
  var props = keys(source);
  if (!customizer) {
    return baseCopy(source, object, props);
  }
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? (result !== value) : (value === value)) ||
        (typeof value == 'undefined' && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

module.exports = baseAssign;

},{"../object/keys":112,"./baseCopy":73}],72:[function(require,module,exports){
var baseMatches = require('./baseMatches'),
    baseMatchesProperty = require('./baseMatchesProperty'),
    baseProperty = require('./baseProperty'),
    bindCallback = require('./bindCallback'),
    identity = require('../utility/identity'),
    isBindable = require('./isBindable');


function baseCallback(func, thisArg, argCount) {
  var type = typeof func;
  if (type == 'function') {
    return (typeof thisArg != 'undefined' && isBindable(func))
      ? bindCallback(func, thisArg, argCount)
      : func;
  }
  if (func == null) {
    return identity;
  }
  if (type == 'object') {
    return baseMatches(func);
  }
  return typeof thisArg == 'undefined'
    ? baseProperty(func + '')
    : baseMatchesProperty(func + '', thisArg);
}

module.exports = baseCallback;

},{"../utility/identity":116,"./baseMatches":83,"./baseMatchesProperty":84,"./baseProperty":85,"./bindCallback":88,"./isBindable":93}],73:[function(require,module,exports){

function baseCopy(source, object, props) {
  if (!props) {
    props = object;
    object = {};
  }
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],74:[function(require,module,exports){
(function (global){
var isObject = require('../lang/isObject');


var baseCreate = (function() {
  function Object() {}
  return function(prototype) {
    if (isObject(prototype)) {
      Object.prototype = prototype;
      var result = new Object;
      Object.prototype = null;
    }
    return result || global.Object();
  };
}());

module.exports = baseCreate;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lang/isObject":107}],75:[function(require,module,exports){
var baseForOwn = require('./baseForOwn'),
    isLength = require('./isLength'),
    toObject = require('./toObject');


function baseEach(collection, iteratee) {
  var length = collection ? collection.length : 0;
  if (!isLength(length)) {
    return baseForOwn(collection, iteratee);
  }
  var index = -1,
      iterable = toObject(collection);

  while (++index < length) {
    if (iteratee(iterable[index], index, iterable) === false) {
      break;
    }
  }
  return collection;
}

module.exports = baseEach;

},{"./baseForOwn":78,"./isLength":96,"./toObject":101}],76:[function(require,module,exports){
var baseEach = require('./baseEach');


function baseEvery(collection, predicate) {
  var result = true;
  baseEach(collection, function(value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

module.exports = baseEvery;

},{"./baseEach":75}],77:[function(require,module,exports){
var toObject = require('./toObject');


function baseFor(object, iteratee, keysFunc) {
  var index = -1,
      iterable = toObject(object),
      props = keysFunc(object),
      length = props.length;

  while (++index < length) {
    var key = props[index];
    if (iteratee(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}

module.exports = baseFor;

},{"./toObject":101}],78:[function(require,module,exports){
var baseFor = require('./baseFor'),
    keys = require('../object/keys');


function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"../object/keys":112,"./baseFor":77}],79:[function(require,module,exports){
var baseIsEqualDeep = require('./baseIsEqualDeep');


function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
  if (value === other) {
    return value !== 0 || (1 / value == 1 / other);
  }
  var valType = typeof value,
      othType = typeof other;

  if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
      value == null || other == null) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
}

module.exports = baseIsEqual;

},{"./baseIsEqualDeep":80}],80:[function(require,module,exports){
var equalArrays = require('./equalArrays'),
    equalByTag = require('./equalByTag'),
    equalObjects = require('./equalObjects'),
    isArray = require('../lang/isArray'),
    isTypedArray = require('../lang/isTypedArray');


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';


var objectProto = Object.prototype;


var hasOwnProperty = objectProto.hasOwnProperty;


var objToString = objectProto.toString;


function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = objToString.call(object);
    if (objTag == argsTag) {
      objTag = objectTag;
    } else if (objTag != objectTag) {
      objIsArr = isTypedArray(object);
    }
  }
  if (!othIsArr) {
    othTag = objToString.call(other);
    if (othTag == argsTag) {
      othTag = objectTag;
    } else if (othTag != objectTag) {
      othIsArr = isTypedArray(other);
    }
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !(objIsArr || objIsObj)) {
    return equalByTag(object, other, objTag);
  }
  var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
      othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

  if (valWrapped || othWrapped) {
    return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
  }
  if (!isSameTag) {
    return false;
  }
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == object) {
      return stackB[length] == other;
    }
  }
  stackA.push(object);
  stackB.push(other);

  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

  stackA.pop();
  stackB.pop();

  return result;
}

module.exports = baseIsEqualDeep;

},{"../lang/isArray":103,"../lang/isTypedArray":109,"./equalArrays":90,"./equalByTag":91,"./equalObjects":92}],81:[function(require,module,exports){

function baseIsFunction(value) {
  return typeof value == 'function' || false;
}

module.exports = baseIsFunction;

},{}],82:[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual');


var objectProto = Object.prototype;


var hasOwnProperty = objectProto.hasOwnProperty;


function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
  var length = props.length;
  if (object == null) {
    return !length;
  }
  var index = -1,
      noCustomizer = !customizer;

  while (++index < length) {
    if ((noCustomizer && strictCompareFlags[index])
          ? values[index] !== object[props[index]]
          : !hasOwnProperty.call(object, props[index])
        ) {
      return false;
    }
  }
  index = -1;
  while (++index < length) {
    var key = props[index];
    if (noCustomizer && strictCompareFlags[index]) {
      var result = hasOwnProperty.call(object, key);
    } else {
      var objValue = object[key],
          srcValue = values[index];

      result = customizer ? customizer(objValue, srcValue, key) : undefined;
      if (typeof result == 'undefined') {
        result = baseIsEqual(srcValue, objValue, customizer, true);
      }
    }
    if (!result) {
      return false;
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./baseIsEqual":79}],83:[function(require,module,exports){
var baseIsMatch = require('./baseIsMatch'),
    isStrictComparable = require('./isStrictComparable'),
    keys = require('../object/keys');


var objectProto = Object.prototype;


var hasOwnProperty = objectProto.hasOwnProperty;


function baseMatches(source) {
  var props = keys(source),
      length = props.length;

  if (length == 1) {
    var key = props[0],
        value = source[key];

    if (isStrictComparable(value)) {
      return function(object) {
        return object != null && object[key] === value && hasOwnProperty.call(object, key);
      };
    }
  }
  var values = Array(length),
      strictCompareFlags = Array(length);

  while (length--) {
    value = source[props[length]];
    values[length] = value;
    strictCompareFlags[length] = isStrictComparable(value);
  }
  return function(object) {
    return baseIsMatch(object, props, values, strictCompareFlags);
  };
}

module.exports = baseMatches;

},{"../object/keys":112,"./baseIsMatch":82,"./isStrictComparable":98}],84:[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual'),
    isStrictComparable = require('./isStrictComparable');


function baseMatchesProperty(key, value) {
  if (isStrictComparable(value)) {
    return function(object) {
      return object != null && object[key] === value;
    };
  }
  return function(object) {
    return object != null && baseIsEqual(value, object[key], null, true);
  };
}

module.exports = baseMatchesProperty;

},{"./baseIsEqual":79,"./isStrictComparable":98}],85:[function(require,module,exports){

function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],86:[function(require,module,exports){
var identity = require('../utility/identity'),
    metaMap = require('./metaMap');


var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

module.exports = baseSetData;

},{"../utility/identity":116,"./metaMap":99}],87:[function(require,module,exports){

function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

module.exports = baseToString;

},{}],88:[function(require,module,exports){
var identity = require('../utility/identity');


function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (typeof thisArg == 'undefined') {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

module.exports = bindCallback;

},{"../utility/identity":116}],89:[function(require,module,exports){
var bindCallback = require('./bindCallback'),
    isIterateeCall = require('./isIterateeCall');


function createAssigner(assigner) {
  return function() {
    var args = arguments,
        length = args.length,
        object = args[0];

    if (length < 2 || object == null) {
      return object;
    }
    var customizer = args[length - 2],
        thisArg = args[length - 1],
        guard = args[3];

    if (length > 3 && typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = (length > 2 && typeof thisArg == 'function') ? thisArg : null;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(args[1], args[2], guard)) {
      customizer = length == 3 ? null : customizer;
      length = 2;
    }
    var index = 0;
    while (++index < length) {
      var source = args[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  };
}

module.exports = createAssigner;

},{"./bindCallback":88,"./isIterateeCall":95}],90:[function(require,module,exports){

function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var index = -1,
      arrLength = array.length,
      othLength = other.length,
      result = true;

  if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
    return false;
  }
  while (result && ++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    result = undefined;
    if (customizer) {
      result = isWhere
        ? customizer(othValue, arrValue, index)
        : customizer(arrValue, othValue, index);
    }
    if (typeof result == 'undefined') {
      if (isWhere) {
        var othIndex = othLength;
        while (othIndex--) {
          othValue = other[othIndex];
          result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
          if (result) {
            break;
          }
        }
      } else {
        result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
      }
    }
  }
  return !!result;
}

module.exports = equalArrays;

},{}],91:[function(require,module,exports){

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';


function equalByTag(object, other, tag) {
  switch (tag) {
    case boolTag:
    case dateTag:
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      return (object != +object)
        ? other != +other
        : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

    case regexpTag:
    case stringTag:
      return object == (other + '');
  }
  return false;
}

module.exports = equalByTag;

},{}],92:[function(require,module,exports){
var keys = require('../object/keys');


var objectProto = Object.prototype;


var hasOwnProperty = objectProto.hasOwnProperty;


function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isWhere) {
    return false;
  }
  var hasCtor,
      index = -1;

  while (++index < objLength) {
    var key = objProps[index],
        result = hasOwnProperty.call(other, key);

    if (result) {
      var objValue = object[key],
          othValue = other[key];

      result = undefined;
      if (customizer) {
        result = isWhere
          ? customizer(othValue, objValue, key)
          : customizer(objValue, othValue, key);
      }
      if (typeof result == 'undefined') {
        result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
      }
    }
    if (!result) {
      return false;
    }
    hasCtor || (hasCtor = key == 'constructor');
  }
  if (!hasCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      return false;
    }
  }
  return true;
}

module.exports = equalObjects;

},{"../object/keys":112}],93:[function(require,module,exports){
var baseSetData = require('./baseSetData'),
    isNative = require('../lang/isNative'),
    support = require('../support');


var reFuncName = /^\s*function[ \n\r\t]+\w/;


var reThis = /\bthis\b/;


var fnToString = Function.prototype.toString;


function isBindable(func) {
  var result = !(support.funcNames ? func.name : support.funcDecomp);

  if (!result) {
    var source = fnToString.call(func);
    if (!support.funcNames) {
      result = !reFuncName.test(source);
    }
    if (!result) {
      result = reThis.test(source) || isNative(func);
      baseSetData(func, result);
    }
  }
  return result;
}

module.exports = isBindable;

},{"../lang/isNative":106,"../support":115,"./baseSetData":86}],94:[function(require,module,exports){

var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;


function isIndex(value, length) {
  value = +value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

},{}],95:[function(require,module,exports){
var isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    isObject = require('../lang/isObject');


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number') {
    var length = object.length,
        prereq = isLength(length) && isIndex(index, length);
  } else {
    prereq = type == 'string' && index in object;
  }
  if (prereq) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

module.exports = isIterateeCall;

},{"../lang/isObject":107,"./isIndex":94,"./isLength":96}],96:[function(require,module,exports){

var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;


function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],97:[function(require,module,exports){

function isObjectLike(value) {
  return (value && typeof value == 'object') || false;
}

module.exports = isObjectLike;

},{}],98:[function(require,module,exports){
var isObject = require('../lang/isObject');


function isStrictComparable(value) {
  return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
}

module.exports = isStrictComparable;

},{"../lang/isObject":107}],99:[function(require,module,exports){
(function (global){
var isNative = require('../lang/isNative');


var WeakMap = isNative(WeakMap = global.WeakMap) && WeakMap;


var metaMap = WeakMap && new WeakMap;

module.exports = metaMap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lang/isNative":106}],100:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    keysIn = require('../object/keysIn'),
    support = require('../support');


var objectProto = Object.prototype;


var hasOwnProperty = objectProto.hasOwnProperty;


function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object)));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = shimKeys;

},{"../lang/isArguments":102,"../lang/isArray":103,"../object/keysIn":113,"../support":115,"./isIndex":94,"./isLength":96}],101:[function(require,module,exports){
var isObject = require('../lang/isObject');


function toObject(value) {
  return isObject(value) ? value : Object(value);
}

module.exports = toObject;

},{"../lang/isObject":107}],102:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');


var argsTag = '[object Arguments]';


var objectProto = Object.prototype;


var objToString = objectProto.toString;


function isArguments(value) {
  var length = isObjectLike(value) ? value.length : undefined;
  return (isLength(length) && objToString.call(value) == argsTag) || false;
}

module.exports = isArguments;

},{"../internal/isLength":96,"../internal/isObjectLike":97}],103:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isNative = require('./isNative'),
    isObjectLike = require('../internal/isObjectLike');


var arrayTag = '[object Array]';


var objectProto = Object.prototype;


var objToString = objectProto.toString;


var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;


var isArray = nativeIsArray || function(value) {
  return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
};

module.exports = isArray;

},{"../internal/isLength":96,"../internal/isObjectLike":97,"./isNative":106}],104:[function(require,module,exports){
var isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isFunction = require('./isFunction'),
    isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike'),
    isString = require('./isString'),
    keys = require('../object/keys');


function isEmpty(value) {
  if (value == null) {
    return true;
  }
  var length = value.length;
  if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
      (isObjectLike(value) && isFunction(value.splice)))) {
    return !length;
  }
  return !keys(value).length;
}

module.exports = isEmpty;

},{"../internal/isLength":96,"../internal/isObjectLike":97,"../object/keys":112,"./isArguments":102,"./isArray":103,"./isFunction":105,"./isString":108}],105:[function(require,module,exports){
(function (global){
var baseIsFunction = require('../internal/baseIsFunction'),
    isNative = require('./isNative');


var funcTag = '[object Function]';


var objectProto = Object.prototype;


var objToString = objectProto.toString;


var Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;


var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
  return objToString.call(value) == funcTag;
};

module.exports = isFunction;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../internal/baseIsFunction":81,"./isNative":106}],106:[function(require,module,exports){
var escapeRegExp = require('../string/escapeRegExp'),
    isObjectLike = require('../internal/isObjectLike');


var funcTag = '[object Function]';


var reHostCtor = /^\[object .+?Constructor\]$/;


var objectProto = Object.prototype;


var fnToString = Function.prototype.toString;


var objToString = objectProto.toString;


var reNative = RegExp('^' +
  escapeRegExp(objToString)
  .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);


function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reNative.test(fnToString.call(value));
  }
  return (isObjectLike(value) && reHostCtor.test(value)) || false;
}

module.exports = isNative;

},{"../internal/isObjectLike":97,"../string/escapeRegExp":114}],107:[function(require,module,exports){

function isObject(value) {
  var type = typeof value;
  return type == 'function' || (value && type == 'object') || false;
}

module.exports = isObject;

},{}],108:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');


var stringTag = '[object String]';


var objectProto = Object.prototype;


var objToString = objectProto.toString;


function isString(value) {
  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
}

module.exports = isString;

},{"../internal/isObjectLike":97}],109:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';


var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;


var objectProto = Object.prototype;


var objToString = objectProto.toString;


function isTypedArray(value) {
  return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
}

module.exports = isTypedArray;

},{"../internal/isLength":96,"../internal/isObjectLike":97}],110:[function(require,module,exports){
var baseAssign = require('../internal/baseAssign'),
    createAssigner = require('../internal/createAssigner');


var assign = createAssigner(baseAssign);

module.exports = assign;

},{"../internal/baseAssign":71,"../internal/createAssigner":89}],111:[function(require,module,exports){
var baseCopy = require('../internal/baseCopy'),
    baseCreate = require('../internal/baseCreate'),
    isIterateeCall = require('../internal/isIterateeCall'),
    keys = require('./keys');


function create(prototype, properties, guard) {
  var result = baseCreate(prototype);
  if (guard && isIterateeCall(prototype, properties, guard)) {
    properties = null;
  }
  return properties ? baseCopy(properties, result, keys(properties)) : result;
}

module.exports = create;

},{"../internal/baseCopy":73,"../internal/baseCreate":74,"../internal/isIterateeCall":95,"./keys":112}],112:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isNative = require('../lang/isNative'),
    isObject = require('../lang/isObject'),
    shimKeys = require('../internal/shimKeys');


var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;


var keys = !nativeKeys ? shimKeys : function(object) {
  if (object) {
    var Ctor = object.constructor,
        length = object.length;
  }
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && (length && isLength(length)))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

module.exports = keys;

},{"../internal/isLength":96,"../internal/shimKeys":100,"../lang/isNative":106,"../lang/isObject":107}],113:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('../internal/isIndex'),
    isLength = require('../internal/isLength'),
    isObject = require('../lang/isObject'),
    support = require('../support');


var objectProto = Object.prototype;


var hasOwnProperty = objectProto.hasOwnProperty;


function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

},{"../internal/isIndex":94,"../internal/isLength":96,"../lang/isArguments":102,"../lang/isArray":103,"../lang/isObject":107,"../support":115}],114:[function(require,module,exports){
var baseToString = require('../internal/baseToString');


var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);


function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = escapeRegExp;

},{"../internal/baseToString":87}],115:[function(require,module,exports){
(function (global){
var isNative = require('./lang/isNative');


var reThis = /\bthis\b/;


var objectProto = Object.prototype;


var document = (document = global.window) && document.document;


var propertyIsEnumerable = objectProto.propertyIsEnumerable;


var support = {};

(function(x) {


  support.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });


  support.funcNames = typeof Function.name == 'string';


  try {
    support.dom = document.createDocumentFragment().nodeType === 11;
  } catch(e) {
    support.dom = false;
  }


  try {
    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
  } catch(e) {
    support.nonEnumArgs = true;
  }
}(0, 0));

module.exports = support;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lang/isNative":106}],116:[function(require,module,exports){

function identity(value) {
  return value;
}

module.exports = identity;

},{}],117:[function(require,module,exports){
var process = module.exports = {};


var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],118:[function(require,module,exports){
(function (global){

;(function(root) {


	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}


	var punycode,


	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1


	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'


	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators


	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,


	key;




	function error(type) {
		throw new RangeError(errors[type]);
	}


	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}


	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			result = parts[0] + '@';
			string = parts[1];
		}
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}


	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}


	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}


	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}


	function digitToBasic(digit, flag) {
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}


	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}


	function decode(input) {
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		    baseMinusT;


		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}


		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}


	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		    inputLength,

		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		input = ucs2decode(input);

		inputLength = input.length;

		n = initialN;
		delta = 0;
		bias = initialBias;

		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;


		if (basicLength) {
			output.push(delimiter);
		}

		while (handledCPCount < inputLength) {

			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}


	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}


	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}




	punycode = {

		'version': '1.4.1',

		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};


	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			freeModule.exports = punycode;
		} else {
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],119:[function(require,module,exports){

'use strict';

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],120:[function(require,module,exports){

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],121:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":119,"./encode":120}],122:[function(require,module,exports){

'use strict';

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

},{}],123:[function(require,module,exports){

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

},{}],124:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"./decode":122,"./encode":123,"dup":121}],125:[function(require,module,exports){

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    autoEscape = ['\''].concat(unwise),
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {



    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf('@');
    } else {
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    this.parseHost();

    this.hostname = this.hostname || '';

    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  if (!unsafeProtocol[lowerProto]) {

    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  var hash = rest.indexOf('#');
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  this.href = this.format();
  return this;
};

function urlFormat(obj) {
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  result.hash = relative.hash;

  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  if (relative.slashes && !relative.protocol) {
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":118,"querystring":121}],126:[function(require,module,exports){
if (typeof Object.create === 'function') {
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],127:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],128:[function(require,module,exports){
(function (process,global){

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


exports.deprecate = function(fn, msg) {
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};




function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    exports._extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      value.inspect !== exports.inspect &&
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};



exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":127,"_process":117,"inherits":126}],129:[function(require,module,exports){
(function() {
  var XMLAttribute, create;

  create = require('lodash/object/create');

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing attribute name of element " + parent.name);
      }
      if (value == null) {
        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
      }
      this.name = this.stringify.attName(name);
      this.value = this.stringify.attValue(value);
    }

    XMLAttribute.prototype.clone = function() {
      return create(XMLAttribute.prototype, this);
    };

    XMLAttribute.prototype.toString = function(options, level) {
      return ' ' + this.name + '="' + this.value + '"';
    };

    return XMLAttribute;

  })();

}).call(this);

},{"lodash/object/create":111}],130:[function(require,module,exports){
(function() {
  var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;

  XMLStringifier = require('./XMLStringifier');

  XMLDeclaration = require('./XMLDeclaration');

  XMLDocType = require('./XMLDocType');

  XMLElement = require('./XMLElement');

  module.exports = XMLBuilder = (function() {
    function XMLBuilder(name, options) {
      var root, temp;
      if (name == null) {
        throw new Error("Root element needs a name");
      }
      if (options == null) {
        options = {};
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
      temp = new XMLElement(this, 'doc');
      root = temp.element(name);
      root.isRoot = true;
      root.documentObject = this;
      this.rootObject = root;
      if (!options.headless) {
        root.declaration(options);
        if ((options.pubID != null) || (options.sysID != null)) {
          root.doctype(options);
        }
      }
    }

    XMLBuilder.prototype.root = function() {
      return this.rootObject;
    };

    XMLBuilder.prototype.end = function(options) {
      return this.toString(options);
    };

    XMLBuilder.prototype.toString = function(options) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      r = '';
      if (this.xmldec != null) {
        r += this.xmldec.toString(options);
      }
      if (this.doctype != null) {
        r += this.doctype.toString(options);
      }
      r += this.rootObject.toString(options);
      if (pretty && r.slice(-newline.length) === newline) {
        r = r.slice(0, -newline.length);
      }
      return r;
    };

    return XMLBuilder;

  })();

}).call(this);

},{"./XMLDeclaration":137,"./XMLDocType":138,"./XMLElement":139,"./XMLStringifier":143}],131:[function(require,module,exports){
(function() {
  var XMLCData, XMLNode, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text");
      }
      this.text = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return create(XMLCData.prototype, this);
    };

    XMLCData.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<![CDATA[' + this.text + ']]>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLCData;

  })(XMLNode);

}).call(this);

},{"./XMLNode":140,"lodash/object/create":111}],132:[function(require,module,exports){
(function() {
  var XMLComment, XMLNode, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text");
      }
      this.text = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return create(XMLComment.prototype, this);
    };

    XMLComment.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!-- ' + this.text + ' -->';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLComment;

  })(XMLNode);

}).call(this);

},{"./XMLNode":140,"lodash/object/create":111}],133:[function(require,module,exports){
(function() {
  var XMLDTDAttList, create;

  create = require('lodash/object/create');

  module.exports = XMLDTDAttList = (function() {
    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      this.stringify = parent.stringify;
      if (elementName == null) {
        throw new Error("Missing DTD element name");
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name");
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type");
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default");
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT");
      }
      this.elementName = this.stringify.eleName(elementName);
      this.attributeName = this.stringify.attName(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.clone = function() {
      return create(XMLDTDAttList.prototype, this);
    };

    XMLDTDAttList.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;
      if (this.defaultValueType !== '#DEFAULT') {
        r += ' ' + this.defaultValueType;
      }
      if (this.defaultValue) {
        r += ' "' + this.defaultValue + '"';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDAttList;

  })();

}).call(this);

},{"lodash/object/create":111}],134:[function(require,module,exports){
(function() {
  var XMLDTDElement, create, isArray;

  create = require('lodash/object/create');

  isArray = require('lodash/lang/isArray');

  module.exports = XMLDTDElement = (function() {
    function XMLDTDElement(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing DTD element name");
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.eleName(name);
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.clone = function() {
      return create(XMLDTDElement.prototype, this);
    };

    XMLDTDElement.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ELEMENT ' + this.name + ' ' + this.value + '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDElement;

  })();

}).call(this);

},{"lodash/lang/isArray":103,"lodash/object/create":111}],135:[function(require,module,exports){
(function() {
  var XMLDTDEntity, create, isObject;

  create = require('lodash/object/create');

  isObject = require('lodash/lang/isObject');

  module.exports = XMLDTDEntity = (function() {
    function XMLDTDEntity(parent, pe, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing entity name");
      }
      if (value == null) {
        throw new Error("Missing entity value");
      }
      this.pe = !!pe;
      this.name = this.stringify.eleName(name);
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity");
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity");
        }
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity");
        }
      }
    }

    XMLDTDEntity.prototype.clone = function() {
      return create(XMLDTDEntity.prototype, this);
    };

    XMLDTDEntity.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ENTITY';
      if (this.pe) {
        r += ' %';
      }
      r += ' ' + this.name;
      if (this.value) {
        r += ' "' + this.value + '"';
      } else {
        if (this.pubID && this.sysID) {
          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
        } else if (this.sysID) {
          r += ' SYSTEM "' + this.sysID + '"';
        }
        if (this.nData) {
          r += ' NDATA ' + this.nData;
        }
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDEntity;

  })();

}).call(this);

},{"lodash/lang/isObject":107,"lodash/object/create":111}],136:[function(require,module,exports){
(function() {
  var XMLDTDNotation, create;

  create = require('lodash/object/create');

  module.exports = XMLDTDNotation = (function() {
    function XMLDTDNotation(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing notation name");
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity");
      }
      this.name = this.stringify.eleName(name);
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    XMLDTDNotation.prototype.clone = function() {
      return create(XMLDTDNotation.prototype, this);
    };

    XMLDTDNotation.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!NOTATION ' + this.name;
      if (this.pubID && this.sysID) {
        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
      } else if (this.pubID) {
        r += ' PUBLIC "' + this.pubID + '"';
      } else if (this.sysID) {
        r += ' SYSTEM "' + this.sysID + '"';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDNotation;

  })();

}).call(this);

},{"lodash/object/create":111}],137:[function(require,module,exports){
(function() {
  var XMLDeclaration, XMLNode, create, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  isObject = require('lodash/lang/isObject');

  XMLNode = require('./XMLNode');

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      if (version != null) {
        this.version = this.stringify.xmlVersion(version);
      }
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.clone = function() {
      return create(XMLDeclaration.prototype, this);
    };

    XMLDeclaration.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<?xml';
      if (this.version != null) {
        r += ' version="' + this.version + '"';
      }
      if (this.encoding != null) {
        r += ' encoding="' + this.encoding + '"';
      }
      if (this.standalone != null) {
        r += ' standalone="' + this.standalone + '"';
      }
      r += '?>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);

},{"./XMLNode":140,"lodash/lang/isObject":107,"lodash/object/create":111}],138:[function(require,module,exports){
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLProcessingInstruction, create, isObject;

  create = require('lodash/object/create');

  isObject = require('lodash/lang/isObject');

  XMLCData = require('./XMLCData');

  XMLComment = require('./XMLComment');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDNotation = require('./XMLDTDNotation');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  module.exports = XMLDocType = (function() {
    function XMLDocType(parent, pubID, sysID) {
      var ref, ref1;
      this.documentObject = parent;
      this.stringify = this.documentObject.stringify;
      this.children = [];
      if (isObject(pubID)) {
        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
      }
      if (sysID == null) {
        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    XMLDocType.prototype.clone = function() {
      return create(XMLDocType.prototype, this);
    };

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.instruction = function(target, value) {
      var child;
      child = new XMLProcessingInstruction(this, target, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.root = function() {
      return this.documentObject.root();
    };

    XMLDocType.prototype.document = function() {
      return this.documentObject;
    };

    XMLDocType.prototype.toString = function(options, level) {
      var child, i, indent, len, newline, offset, pretty, r, ref, ref1, ref2, ref3, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!DOCTYPE ' + this.root().name;
      if (this.pubID && this.sysID) {
        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
      } else if (this.sysID) {
        r += ' SYSTEM "' + this.sysID + '"';
      }
      if (this.children.length > 0) {
        r += ' [';
        if (pretty) {
          r += newline;
        }
        ref3 = this.children;
        for (i = 0, len = ref3.length; i < len; i++) {
          child = ref3[i];
          r += child.toString(options, level + 1);
        }
        r += ']';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocType.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocType.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root();
    };

    XMLDocType.prototype.doc = function() {
      return this.document();
    };

    return XMLDocType;

  })();

}).call(this);

},{"./XMLCData":131,"./XMLComment":132,"./XMLDTDAttList":133,"./XMLDTDElement":134,"./XMLDTDEntity":135,"./XMLDTDNotation":136,"./XMLProcessingInstruction":141,"lodash/lang/isObject":107,"lodash/object/create":111}],139:[function(require,module,exports){
(function() {
  var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, every, isArray, isFunction, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  isObject = require('lodash/lang/isObject');

  isArray = require('lodash/lang/isArray');

  isFunction = require('lodash/lang/isFunction');

  every = require('lodash/collection/every');

  XMLNode = require('./XMLNode');

  XMLAttribute = require('./XMLAttribute');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name");
      }
      this.name = this.stringify.eleName(name);
      this.children = [];
      this.instructions = [];
      this.attributes = {};
      if (attributes != null) {
        this.attribute(attributes);
      }
    }

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, i, len, pi, ref, ref1;
      clonedSelf = create(XMLElement.prototype, this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attributes = {};
      ref = this.attributes;
      for (attName in ref) {
        if (!hasProp.call(ref, attName)) continue;
        att = ref[attName];
        clonedSelf.attributes[attName] = att.clone();
      }
      clonedSelf.instructions = [];
      ref1 = this.instructions;
      for (i = 0, len = ref1.length; i < len; i++) {
        pi = ref1[i];
        clonedSelf.instructions.push(pi.clone());
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, i, len;
      if (name == null) {
        throw new Error("Missing attribute name");
      }
      name = name.valueOf();
      if (isArray(name)) {
        for (i = 0, len = name.length; i < len; i++) {
          attName = name[i];
          delete this.attributes[attName];
        }
      } else {
        delete this.attributes[name];
      }
      return this;
    };

    XMLElement.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, instruction, len;
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.instructions.push(instruction);
      }
      return this;
    };

    XMLElement.prototype.toString = function(options, level) {
      var att, child, i, indent, instruction, j, len, len1, name, newline, offset, pretty, r, ref, ref1, ref2, ref3, ref4, ref5, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      ref3 = this.instructions;
      for (i = 0, len = ref3.length; i < len; i++) {
        instruction = ref3[i];
        r += instruction.toString(options, level + 1);
      }
      if (pretty) {
        r += space;
      }
      r += '<' + this.name;
      ref4 = this.attributes;
      for (name in ref4) {
        if (!hasProp.call(ref4, name)) continue;
        att = ref4[name];
        r += att.toString(options);
      }
      if (this.children.length === 0 || every(this.children, function(e) {
        return e.value === '';
      })) {
        r += '/>';
        if (pretty) {
          r += newline;
        }
      } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {
        r += '>';
        r += this.children[0].value;
        r += '</' + this.name + '>';
        r += newline;
      } else {
        r += '>';
        if (pretty) {
          r += newline;
        }
        ref5 = this.children;
        for (j = 0, len1 = ref5.length; j < len1; j++) {
          child = ref5[j];
          r += child.toString(options, level + 1);
        }
        if (pretty) {
          r += space;
        }
        r += '</' + this.name + '>';
        if (pretty) {
          r += newline;
        }
      }
      return r;
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    return XMLElement;

  })(XMLNode);

}).call(this);

},{"./XMLAttribute":129,"./XMLNode":140,"./XMLProcessingInstruction":141,"lodash/collection/every":69,"lodash/lang/isArray":103,"lodash/lang/isFunction":105,"lodash/lang/isObject":107,"lodash/object/create":111}],140:[function(require,module,exports){
(function() {
  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLRaw, XMLText, isArray, isEmpty, isFunction, isObject,
    hasProp = {}.hasOwnProperty;

  isObject = require('lodash/lang/isObject');

  isArray = require('lodash/lang/isArray');

  isFunction = require('lodash/lang/isFunction');

  isEmpty = require('lodash/lang/isEmpty');

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent) {
      this.parent = parent;
      this.options = this.parent.options;
      this.stringify = this.parent.stringify;
      if (XMLElement === null) {
        XMLElement = require('./XMLElement');
        XMLCData = require('./XMLCData');
        XMLComment = require('./XMLComment');
        XMLDeclaration = require('./XMLDeclaration');
        XMLDocType = require('./XMLDocType');
        XMLRaw = require('./XMLRaw');
        XMLText = require('./XMLText');
      }
    }

    XMLNode.prototype.clone = function() {
      throw new Error("Cannot clone generic XMLNode");
    };

    XMLNode.prototype.element = function(name, attributes, text) {
      var item, j, key, lastChild, len, ref, val;
      lastChild = null;
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref = [attributes, text], text = ref[0], attributes = ref[1];
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if ((isObject(val)) && (isEmpty(val))) {
            val = null;
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);
          } else if (isObject(val)) {
            if (!this.options.ignoreDecorators && this.stringify.convertListKey && key.indexOf(this.stringify.convertListKey) === 0 && isArray(val)) {
              lastChild = this.element(val);
            } else {
              lastChild = this.element(key);
              lastChild.element(val);
            }
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name);
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element");
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref;
      if (name != null) {
        name = name.valueOf();
      }
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref = [attributes, text], text = ref[0], attributes = ref[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      doc.xmldec = xmldec;
      return doc.root();
    };

    XMLNode.prototype.doctype = function(pubID, sysID) {
      var doc, doctype;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      doc.doctype = doctype;
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var child;
      if (this.isRoot) {
        return this;
      }
      child = this.parent;
      while (!child.isRoot) {
        child = child.parent;
      }
      return child;
    };

    XMLNode.prototype.document = function() {
      return this.root().documentObject;
    };

    XMLNode.prototype.end = function(options) {
      return this.document().toString(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      if (this.isRoot) {
        throw new Error("Root node has no siblings");
      }
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node");
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      if (this.isRoot) {
        throw new Error("Root node has no siblings");
      }
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node");
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {
      var clonedRoot;
      clonedRoot = xmlbuilder.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      return this.doctype(pubID, sysID);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    return XMLNode;

  })();

}).call(this);

},{"./XMLCData":131,"./XMLComment":132,"./XMLDeclaration":137,"./XMLDocType":138,"./XMLElement":139,"./XMLRaw":142,"./XMLText":144,"lodash/lang/isArray":103,"lodash/lang/isEmpty":104,"lodash/lang/isFunction":105,"lodash/lang/isObject":107}],141:[function(require,module,exports){
(function() {
  var XMLProcessingInstruction, create;

  create = require('lodash/object/create');

  module.exports = XMLProcessingInstruction = (function() {
    function XMLProcessingInstruction(parent, target, value) {
      this.stringify = parent.stringify;
      if (target == null) {
        throw new Error("Missing instruction target");
      }
      this.target = this.stringify.insTarget(target);
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return create(XMLProcessingInstruction.prototype, this);
    };

    XMLProcessingInstruction.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<?';
      r += this.target;
      if (this.value) {
        r += ' ' + this.value;
      }
      r += '?>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLProcessingInstruction;

  })();

}).call(this);

},{"lodash/object/create":111}],142:[function(require,module,exports){
(function() {
  var XMLNode, XMLRaw, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text");
      }
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return create(XMLRaw.prototype, this);
    };

    XMLRaw.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += this.value;
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);

},{"./XMLNode":140,"lodash/object/create":111}],143:[function(require,module,exports){
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;
      ref = (options != null ? options.stringify : void 0) || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.eleName = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.eleText = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(this.elEscape(val));
    };

    XMLStringifier.prototype.cdata = function(val) {
      val = '' + val || '';
      if (val.match(/]]>/)) {
        throw new Error("Invalid CDATA text: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attName = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      val = '' + val || '';
      return this.attEscape(val);
    };

    XMLStringifier.prototype.insTarget = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.insValue = function(val) {
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      val = '' + val || '';
      if (!val.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (val != null) {
        return '' + val || '';
      } else {
        return val;
      }
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.convertListKey = '#list';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var chars, chr;
      if (this.allowSurrogateChars) {
        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
      } else {
        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
      }
      chr = str.match(chars);
      if (chr) {
        throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
      }
      return str;
    };

    XMLStringifier.prototype.elEscape = function(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
    };

    return XMLStringifier;

  })();

}).call(this);

},{}],144:[function(require,module,exports){
(function() {
  var XMLNode, XMLText, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text");
      }
      this.value = this.stringify.eleText(text);
    }

    XMLText.prototype.clone = function() {
      return create(XMLText.prototype, this);
    };

    XMLText.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += this.value;
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLText;

  })(XMLNode);

}).call(this);

},{"./XMLNode":140,"lodash/object/create":111}],145:[function(require,module,exports){
(function() {
  var XMLBuilder, assign;

  assign = require('lodash/object/assign');

  XMLBuilder = require('./XMLBuilder');

  module.exports.create = function(name, xmldec, doctype, options) {
    options = assign({}, xmldec, doctype, options);
    return new XMLBuilder(name, options).root();
  };

}).call(this);

},{"./XMLBuilder":130,"lodash/object/assign":110}],146:[function(require,module,exports){
require('./browser_loader');

var AWS = require('./core');

if (typeof window !== 'undefined') window.AWS = AWS;
if (typeof module !== 'undefined') module.exports = AWS;
if (typeof self !== 'undefined') self.AWS = AWS;

if (!Object.prototype.hasOwnProperty.call(AWS, 'Connect')) {
  AWS.apiLoader.services['connect'] = {};
  AWS.Connect = AWS.Service.defineService('connect', [ '2017-02-15' ]);
}
AWS.apiLoader.services['connect']['2017-02-15'] = require('../apis/connect-2017-02-15.min');

if (!Object.prototype.hasOwnProperty.call(AWS, 'STS')) {
  AWS.apiLoader.services['sts'] = {};
  AWS.STS = AWS.Service.defineService('sts', [ '2011-06-15' ]);
  require('./services/sts');
}
AWS.apiLoader.services['sts']['2011-06-15'] = require('../apis/sts-2011-06-15.min');


},{"../apis/connect-2017-02-15.min":2,"../apis/sts-2011-06-15.min":4,"./browser_loader":8,"./core":10,"./services/sts":43}]},{},[146]);

/*! @license sprintf.js | Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro> | 3 clause BSD license */

(function() {
   var ctx = this;

	var sprintf = function() {
		if (!sprintf.cache.hasOwnProperty(arguments[0])) {
			sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);
		}
		return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);
	};

	sprintf.format = function(parse_tree, argv) {
		var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
		for (i = 0; i < tree_length; i++) {
			node_type = get_type(parse_tree[i]);
			if (node_type === 'string') {
				output.push(parse_tree[i]);
			}
			else if (node_type === 'array') {
				match = parse_tree[i]; // convenience purposes only
				if (match[2]) { // keyword argument
					arg = argv[cursor];
					for (k = 0; k < match[2].length; k++) {
						if (!arg.hasOwnProperty(match[2][k])) {
							throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
						}
						arg = arg[match[2][k]];
					}
				}
				else if (match[1]) { // positional argument (explicit)
					arg = argv[match[1]];
				}
				else { // positional argument (implicit)
					arg = argv[cursor++];
				}

				if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
					throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
				}
				switch (match[8]) {
					case 'b': arg = arg.toString(2); break;
					case 'c': arg = String.fromCharCode(arg); break;
					case 'd': arg = parseInt(arg, 10); break;
					case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
					case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
					case 'o': arg = arg.toString(8); break;
					case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
					case 'u': arg = arg >>> 0; break;
					case 'x': arg = arg.toString(16); break;
					case 'X': arg = arg.toString(16).toUpperCase(); break;
				}
				arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
				pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
				pad_length = match[6] - String(arg).length;
				pad = match[6] ? str_repeat(pad_character, pad_length) : '';
				output.push(match[5] ? arg + pad : pad + arg);
			}
		}
		return output.join('');
	};

	sprintf.cache = {};

	sprintf.parse = function(fmt) {
		var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
		while (_fmt) {
			if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
				parse_tree.push(match[0]);
			}
			else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
				parse_tree.push('%');
			}
			else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
				if (match[2]) {
					arg_names |= 1;
					var field_list = [], replacement_field = match[2], field_match = [];
					if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
						field_list.push(field_match[1]);
						while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
							if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else {
								throw('[sprintf] huh?');
							}
						}
					}
					else {
						throw('[sprintf] huh?');
					}
					match[2] = field_list;
				}
				else {
					arg_names |= 2;
				}
				if (arg_names === 3) {
					throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
				}
				parse_tree.push(match);
			}
			else {
				throw('[sprintf] huh?');
			}
			_fmt = _fmt.substring(match[0].length);
		}
		return parse_tree;
	};

	var vsprintf = function(fmt, argv, _argv) {
		_argv = argv.slice(0);
		_argv.splice(0, 0, fmt);
		return sprintf.apply(null, _argv);
	};

	/**
	 * helpers
	 */
	function get_type(variable) {
		return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
	}

	function str_repeat(input, multiplier) {
		for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
		return output.join('');
	}

	/**
	 * export to either browser or node.js
	 */
	ctx.sprintf = sprintf;
	ctx.vsprintf = vsprintf;
})();

/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   // How frequently logs should be collected and reported to shared worker.
   var LOG_REPORT_INTERVAL_MILLIS = 5000;

   // The default log roll interval (30min)
   var DEFAULT_LOG_ROLL_INTERVAL = 1800000;

   /**
    * An enumeration of common logging levels.
    */
   var LogLevel = {
      TEST:          "TEST",
      TRACE:         "TRACE",
      DEBUG:         "DEBUG",
      INFO:          "INFO",
      LOG:           "LOG",
      WARN:          "WARN",
      ERROR:         "ERROR",
      CRITICAL:      "CRITICAL"
   };

   /**
    * An enumeration of common logging components.
    */
   var LogComponent = {
      CCP:          "ccp",
      SOFTPHONE:    "softphone"
   };

   /**
    * The numeric order of the logging levels above.
    * They are spaced to allow the addition of other log
    * levels at a later time.
    */
   var LogLevelOrder = {
      TEST:          0,
      TRACE:         10,
      DEBUG:         20,
      INFO:          30,
      LOG:           40,
      WARN:          50,
      ERROR:         100,
      CRITICAL:      200

   };

   /**
    * A map from log level to console logger function.
    */
   var CONSOLE_LOGGER_MAP = {
      TRACE:         function(text) {console.info(text);},
      DEBUG:         function(text) {console.info(text);},
      INFO:          function(text) {console.info(text);},
      LOG:           function(text) {console.log(text);},
      TEST:          function(text) {console.log(text);},
      WARN:          function(text) {console.warn(text);},
      ERROR:         function(text) {console.error(text);},
      CRITICAL:      function(text) {console.error(text);}
   };

    /**
    * Checks if it is a valid log component enum
    */

    var isValidLogComponent = function(component) {
        if (component === LogComponent.CCP || component === LogComponent.SOFTPHONE) {
            return true;
        } else {
            return false;
        }
    };

    /**
    * Extract the custom arguments as required by the logger
    */
    var extractLoggerArgs = function(loggerArgs) {
          var args = Array.prototype.slice.call(loggerArgs, 0);
          var firstArg = args.shift();
          var format;
          var component;
          if (isValidLogComponent(firstArg)) {
            component = firstArg;
            format = args.shift();
          } else {
            //default to CCP component
            format= firstArg;
            component = LogComponent.CCP;
          }
          return {format: format,
                  component: component,
                  args:  args};
    };

   /**
    * A log entry.
    *
    * @param level The log level of this log entry.
    * @param text The text contained in the log entry.
    *
    * Log entries are aware of their timestamp, order,
    * and can contain objects and exception stack traces.
    */
   var LogEntry = function(component, level, text) {
      this.component = component;
      this.level = level;
      this.text = text;
      this.time = new Date();
      this.exception = null;
      this.objects = [];
      this.line = 0;
   };

   LogEntry.fromObject = function(obj) {
      var entry = new LogEntry(LogComponent.CCP, obj.level, obj.text);

      // Required to check for Date objects sent across frame boundaries
      if (Object.prototype.toString.call(obj.time) === '[object Date]') {
         entry.time = new Date(obj.time.getTime());
      } else if (typeof obj.time === 'number') {
         entry.time = new Date(obj.time);
      } else if (typeof obj.time === 'string') {
         entry.time = Date.parse(obj.time);
      } else {
         entry.time = new Date();
      }
      entry.exception = obj.exception;
      entry.objects = obj.objects;
      return entry;
   };

   /**
    * Pulls the type, message, and stack trace
    * out of the given exception for JSON serialization.
    */
   var LoggedException = function(e) {
      this.type = Object.prototype.toString.call(e);
      this.message = e.message;
      this.stack = e.stack ? e.stack.split('\n') : [];
   };

   /**
    * Minimally stringify this log entry for printing
    * to the console.
    */
   LogEntry.prototype.toString = function() {
      return connect.sprintf("[%s] [%s]: %s",
         this.getTime() && this.getTime().toISOString ? this.getTime().toISOString() : "???",
         this.getLevel(),
         this.getText());
   };

   /**
    * Get the log entry timestamp.
    */
   LogEntry.prototype.getTime = function() {
      return this.time;
   };

   /**
    * Get the level of the log entry.
    */
   LogEntry.prototype.getLevel = function() {
      return this.level;
   };

   /**
    * Get the log entry text.
    */
   LogEntry.prototype.getText = function() {
      return this.text;
   };

   /**
    * Get the log entry component.
    */
   LogEntry.prototype.getComponent = function() {
      return this.component;
   };

   /**
    * Add an exception stack trace to this log entry.
    * A log entry may contain only one exception stack trace.
    */
   LogEntry.prototype.withException = function(e) {
      this.exception = new LoggedException(e);
      return this;
   };

   /**
    * Add an arbitrary object to the log entry.  A log entry
    * may contain any number of objects.
    */
   LogEntry.prototype.withObject = function(obj) {
      this.objects.push(connect.deepcopy(obj));
      return this;
   };

   /**
    * The logger instance.
    */
   var Logger = function() {
      this._logs = [];
      this._rolledLogs = [];
      this._logsToPush = [];
      this._echoLevel = LogLevelOrder.INFO;
      this._logLevel = LogLevelOrder.INFO;
      this._lineCount = 0;
      this._logRollInterval = 0;
      this._logRollTimer = null;
      this.setLogRollInterval(DEFAULT_LOG_ROLL_INTERVAL);
   };
   
   /**
    * Sets the interval in milliseconds that the logs will be rotated.
    * Logs are rotated out completely at the end of the second roll
    * and will eventually be garbage collected.
    */
   Logger.prototype.setLogRollInterval = function(interval) {
      var self = this;

      if (! (this._logRollTimer) || interval !== this._logRollInterval) {
         if (this._logRollTimer) {
            global.clearInterval(this._logRollTimer);
         }
         this._logRollInterval = interval;
         this._logRollTimer = global.setInterval(function() {
            this._rolledLogs = this._logs;
            this._logs = [];
            self.info("Log roll interval occurred.");
         }, this._logRollInterval);
      } else {
         this.warn("Logger is already set to the given interval: %d", this._logRollInterval);
      }
   };

   /**
    * Set the log level.  This is the minimum level at which logs will
    * be kept for later archiving.
    */
   Logger.prototype.setLogLevel = function(level) {
      if (level in LogLevelOrder) {
         this._logLevel = LogLevelOrder[level];
      } else {
         throw new Error("Unknown logging level: " + level);
      }
   };

   /**
    * Set the echo level.  This is the minimum level at which logs will
    * be printed to the javascript console.
    */
   Logger.prototype.setEchoLevel = function(level) {
      if (level in LogLevelOrder) {
         this._echoLevel = LogLevelOrder[level];
      } else {
         throw new Error("Unknown logging level: " + level);
      }
   };

   /**
    * Write a particular log entry.
    *
    * @param level The logging level of the entry.
    * @param text The text contents of the entry.
    *
    * @returns The new log entry.
    */
   Logger.prototype.write = function(component, level, text) {
      var logEntry = new LogEntry(component, level, text);
      this.addLogEntry(logEntry);
      return logEntry;
   };

   Logger.prototype.addLogEntry = function(logEntry) {
      this._logs.push(logEntry);
      //For now only send softphone logs only.
      //TODO add CCP logs once we are sure that no sensitive data is being logged.
      if (LogComponent.SOFTPHONE === logEntry.component) {
         this._logsToPush.push(logEntry);
      }

      if (logEntry.level in LogLevelOrder &&
          LogLevelOrder[logEntry.level] >= this._logLevel) {

         if (LogLevelOrder[logEntry.level] >= this._echoLevel) {
            CONSOLE_LOGGER_MAP[logEntry.getLevel()](logEntry.toString());
         }

         logEntry.line = this._lineCount++;
      }
   };

   /**
    * Remove all objects from all log entries.
    */
   Logger.prototype.clearObjects = function() {
      for (var x = 0; x < this._logs.length; x++) {
         if (this._logs[x].objects) {
            delete this._logs[x].objects;
         }
      }
   };

   /**
    * Remove all exception stack traces from the log entries.
    */
   Logger.prototype.clearExceptions = function() {
      for (var x = 0; x < this._logs.length; x++) {
         if (this._logs[x].exception) {
            delete this._logs[x].exception;
         }
      }
   };

   Logger.prototype.trace = function() {
      var logArgs = extractLoggerArgs(arguments);
      return this.write(logArgs.component, LogLevel.TRACE, connect.vsprintf(logArgs.format, logArgs.args));
   };

   Logger.prototype.debug = function() {
      var logArgs = extractLoggerArgs(arguments);
      return this.write(logArgs.component, LogLevel.DEBUG, connect.vsprintf(logArgs.format, logArgs.args));
   };

   Logger.prototype.info = function() {
      var logArgs = extractLoggerArgs(arguments);
      return this.write(logArgs.component, LogLevel.INFO, connect.vsprintf(logArgs.format, logArgs.args));
   };

   Logger.prototype.log = function() {
      var logArgs = extractLoggerArgs(arguments);
      return this.write(logArgs.component, LogLevel.LOG, connect.vsprintf(logArgs.format, logArgs.args));
   };

   Logger.prototype.test = function() {
      var logArgs = extractLoggerArgs(arguments);
      return this.write(logArgs.component, LogLevel.TEST, connect.vsprintf(logArgs.format, logArgs.args));
   };

   Logger.prototype.warn = function() {
      var logArgs = extractLoggerArgs(arguments);
      return this.write(logArgs.component, LogLevel.WARN, connect.vsprintf(logArgs.format, logArgs.args));
   };

   Logger.prototype.error = function() {
      var logArgs = extractLoggerArgs(arguments);
      return this.write(logArgs.component, LogLevel.ERROR, connect.vsprintf(logArgs.format, logArgs.args));
   };

   Logger.prototype.critical = function() {
      var logArgs = extractLoggerArgs(arguments);
      return this.write(logArgs.component, LogLevel.ERROR, connect.vsprintf(logArgs.format, logArgs.args));
   };

   /**
    * Create a string representation of the logger contents.
    */
   Logger.prototype.toString = function() {
      var lines = [];
      for (var x = 0; x < this._logs.length; x++) {
         lines.push(this._logs[x].toString());
      }

      return lines.join("\n");
   };

   Logger.prototype.download = function() {
      var logBlob = new global.Blob([JSON.stringify(this._rolledLogs.concat(this._logs), undefined, 4)], ['text/plain']);
      var downloadLink = document.createElement('a');
      downloadLink.href = global.URL.createObjectURL(logBlob);
      downloadLink.download = 'agent-log.txt';
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
   };

   Logger.prototype.scheduleUpstreamLogPush = function(conduit) {
      if (!connect.upstreamLogPushScheduled) {
          connect.upstreamLogPushScheduled = true;
          /** Schedule pushing logs frequently to sharedworker upstream, sharedworker will report to LARS*/
          global.setInterval(connect.hitch(this, this.reportMasterLogsUpStream, conduit), LOG_REPORT_INTERVAL_MILLIS);
      }
   };

   Logger.prototype.reportMasterLogsUpStream = function(conduit) {
      var logsToPush = this._logsToPush.slice();
      this._logsToPush = [];
      connect.ifMaster(connect.MasterTopics.SEND_LOGS, function(){
          if (logsToPush.length > 0) {
             conduit.sendUpstream(connect.EventType.SEND_LOGS, logsToPush);
          }
      });
   };

   var DownstreamConduitLogger = function(conduit) {
      Logger.call(this);
      this.conduit = conduit;
      global.setInterval(connect.hitch(this, this._pushLogsDownstream),
            DownstreamConduitLogger.LOG_PUSH_INTERVAL);

      // Disable log rolling, we will purge our own logs once they have
      // been pushed downstream.
      global.clearInterval(this._logRollTimer);
      this._logRollTimer = null;
   };
   // How frequently logs should be collected and delivered downstream.
   DownstreamConduitLogger.LOG_PUSH_INTERVAL = 1000;
   DownstreamConduitLogger.prototype = Object.create(Logger.prototype);
   DownstreamConduitLogger.prototype.constructor = DownstreamConduitLogger;

   DownstreamConduitLogger.prototype._pushLogsDownstream = function() {
      var self = this;
      this._logs.forEach(function(log) {
         self.conduit.sendDownstream(connect.EventType.LOG, log);
      });
      this._logs = [];
   };

   /** Create the singleton logger instance. */
   connect.rootLogger = new Logger();

   /** Fetch the singleton logger instance. */
   var getLog = function() {
      return connect.rootLogger;
   };

   connect = connect || {};
   connect.getLog = getLog;
   connect.LogEntry = LogEntry;
   connect.Logger = Logger;
   connect.LogLevel = LogLevel;
   connect.LogComponent = LogComponent;
   connect.DownstreamConduitLogger = DownstreamConduitLogger;
})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   var userAgent = navigator.userAgent;
   var ONE_DAY_MILLIS = 24*60*60*1000;

   /**
    * Unpollute sprintf functions from the global namespace.
    */
   connect.sprintf = global.sprintf;
   connect.vsprintf = global.vsprintf;
   delete global.sprintf;
   delete global.vsprintf;

   /**
    * Binds the given instance object as the context for
    * the method provided.
    *
    * @param scope The instance object to be set as the scope
    *    of the function.
    * @param method The method to be encapsulated.
    *
    * All other arguments, if any, are bound to the method
    * invocation inside the closure.
    *
    * @return A closure encapsulating the invocation of the
    *    method provided in context of the given instance.
    */
   connect.hitch = function() {
      var args = Array.prototype.slice.call(arguments);
      var scope = args.shift();
      var method = args.shift();

      connect.assertNotNull(scope, 'scope');
      connect.assertNotNull(method, 'method');
      connect.assertTrue(connect.isFunction(method), 'method must be a function');

      return function() {
         var closureArgs = Array.prototype.slice.call(arguments);
         return method.apply(scope, args.concat(closureArgs));
      };
   };

   /**
    * Determine if the given value is a callable function type.
    * Borrowed from Underscore.js.
    */
   connect.isFunction = function(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
   };

   /**
    * Determine if the given value is an array.
    */
   connect.isArray = function(obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
   };

   /**
    * Get a list of keys from a Javascript object used
    * as a hash map.
    */
   connect.keys = function(map) {
      var keys = [];

      connect.assertNotNull(map, 'map');

      for (var k in map) {
         keys.push(k);
      }

      return keys;
   };

   /**
    * Get a list of values from a Javascript object used
    * as a hash map.
    */
   connect.values = function(map) {
      var values = [];

      connect.assertNotNull(map, 'map');

      for (var k in map) {
         values.push(map[k]);
      }

      return values;
   };

   /**
    * Get a list of key/value pairs from the given map.
    */
   connect.entries = function(map) {
      var entries = [];

      for (var k in map) {
         entries.push({key: k, value: map[k]});
      }

      return entries;
   };

   /**
    * Merge two or more maps together into a new map,
    * or simply copy a single map.
    */
   connect.merge = function() {
      var argMaps = Array.prototype.slice.call(arguments, 0);
      var resultMap = {};

      argMaps.forEach(function(map) {
         connect.entries(map).forEach(function(kv) {
            resultMap[kv.key] = kv.value;
         });
      });

      return resultMap;
   };

   connect.now = function() {
      return new Date().getTime();
   };

   connect.find = function(array, predicate) {
      for (var x = 0; x < array.length; x++) {
         if (predicate(array[x])) {
            return array[x];
         }
      }

      return null;
   };

   connect.contains = function(obj, value) {
      if (obj instanceof Array) {
         return connect.find(obj, function(v) { return v === value; }) != null;

      } else {
         return (value in obj);
      }
   };

   connect.containsValue = function(obj, value) {
      if (obj instanceof Array) {
         return connect.find(obj, function(v) { return v === value; }) != null;

      } else {
         return connect.find(connect.values(obj), function(v) { return v === value; }) != null;
      }
   };

   /**
    * Generate a random ID consisting of the current timestamp
    * and a random base-36 number based on Math.random().
    */
   connect.randomId = function() {
      return connect.sprintf("%s-%s", connect.now(), Math.random().toString(36).slice(2));
   };

   /**
    * Generate an enum from the given list of lower-case enum values,
    * where the enum keys will be upper case.
    *
    * Conversion from pascal case based on code from here:
    * http://stackoverflow.com/questions/30521224
    */
   connect.makeEnum = function(values) {
      var enumObj = {};

      values.forEach(function(value) {
         var key = value.replace(/\.?([a-z]+)_?/g, function (x, y) { return y.toUpperCase() + "_"; })
            .replace(/_$/, "");

         enumObj[key] = value;
      });

      return enumObj;
   };

   connect.makeNamespacedEnum = function(prefix, values) {
      var enumObj = connect.makeEnum(values);
      connect.keys(enumObj).forEach(function(key) {
         enumObj[key] = connect.sprintf("%s::%s", prefix, enumObj[key]);
      });
      return enumObj;
   };

   /**
   * Methods to determine browser type and versions, used for softphone initialization.
   */
   connect.isChromeBrowser = function() {
       return userAgent.indexOf("Chrome") !== -1;
   };

   connect.isFirefoxBrowser = function() {
       return userAgent.indexOf("Firefox") !== -1;
   };

   connect.isOperaBrowser = function() {
       return userAgent.indexOf("Opera") !== -1;
   };

   connect.getChromeBrowserVersion = function() {
       var chromeVersion = userAgent.substring(userAgent.indexOf("Chrome")+7);
       if (chromeVersion) {
           return parseFloat(chromeVersion);
       } else {
           return -1;
       }
   };

   connect.getFirefoxBrowserVersion = function() {
       var firefoxVersion = userAgent.substring(userAgent.indexOf("Firefox")+8);
       if (firefoxVersion) {
           return parseFloat(firefoxVersion);
       } else {
           return -1;
       }
   };

   connect.getOperaBrowserVersion = function() {
       var versionOffset = userAgent.indexOf("Opera");
       var operaVersion = (userAgent.indexOf("Version") !== -1) ? userAgent.substring(versionOffset+8) : userAgent.substring(versionOffset+6);
       if (operaVersion) {
           return parseFloat(operaVersion);
       } else {
           return -1;
       }
   };

   /**
    * Return a map of items in the given list indexed by
    * keys determined by the closure provided.
    *
    * @param iterable A list-like object.
    * @param closure A closure to determine the index for the
    *    items in the iterable.
    * @return A map from index to item for each item in the iterable.
    */
   connect.index = function(iterable, closure) {
      var map = {};

      iterable.forEach(function(item) {
         map[closure(item)] = item;
      });

      return map;
   };

   /**
    * Converts the given array into a map as a set,
    * where elements in the array are mapped to 1.
    */
   connect.set = function(arrayIn) {
      var setMap = {};

      arrayIn.forEach(function(key) {
         setMap[key] = 1;
      });

      return setMap;
   };

   /**
    * Returns a map for each key in mapB which
    * is NOT in mapA.
    */
   connect.relativeComplement = function(mapA, mapB) {
      var compMap = {};

      connect.keys(mapB).forEach(function(key) {
         if (! (key in mapA)) {
            compMap[key] = mapB[key];
         }
      });

      return compMap;
   };

   /**
    * Asserts that a premise is true.
    */
   connect.assertTrue = function(premise, message) {
      if (! premise) {
         throw new connect.ValueError(message);
      }
   };

   /**
    * Asserts that a value is not null or undefined.
    */
   connect.assertNotNull = function(value, name) {
      connect.assertTrue(value != null && typeof value !== undefined,
            connect.sprintf("%s must be provided", name || 'A value'));
      return value;
   };

   connect.deepcopy = function(src) {
      return JSON.parse(JSON.stringify(src));
   };

   /**
    * Get the current base url of the open page, e.g. if the page is
    * https://example.com:9494/oranges, this will be "https://example.com:9494".
    */
   connect.getBaseUrl = function() {
      var location = global.location;
      return connect.sprintf("%s//%s:%s", location.protocol, location.hostname, location.port);
   };

   /**
    * Determine if the current window is in an iframe.
    * Courtesy: http://stackoverflow.com/questions/326069/
    */
   connect.isFramed = function() {
      try {
         return window.self !== window.top;
      } catch (e) {
         return true;
      }
   };

   /**
    * A wrapper around Window.open() for managing single instance popups.
    */
   connect.PopupManager = function() {};

   connect.PopupManager.prototype.open = function(url, name) {
      var then = this._getLastOpenedTimestamp(name);
      var now = new Date().getTime();

      if (now - then > ONE_DAY_MILLIS) {
         var win = window.open('', name);
         if (win.location !== url) {
            window.open(url, name);
         }
         this._setLastOpenedTimestamp(name, now);
      }
   };

   connect.PopupManager.prototype.clear = function(name) {
      var key = this._getLocalStorageKey(name);
      global.localStorage.removeItem(key);
   };

   connect.PopupManager.prototype._getLastOpenedTimestamp = function(name) {
      var key = this._getLocalStorageKey(name);
      var value = global.localStorage.getItem(key);

      if (value) {
         return parseInt(value, 10);

      } else {
         return 0;
      }
   };

   connect.PopupManager.prototype._setLastOpenedTimestamp = function(name, ts) {
      var key = this._getLocalStorageKey(name);
      global.localStorage.setItem(key, '' + ts);
   };

   connect.PopupManager.prototype._getLocalStorageKey = function(name) {
      return "connectPopupManager::" + name;
   };

   /**
    * An enumeration of the HTML5 notification permission values.
    */
   var NotificationPermission = connect.makeEnum([
      'granted',
      'denied',
      'default'
   ]);

   /**
    * A simple engine for showing notification popups.
    */
   connect.NotificationManager = function() {
      this.queue = [];
      this.permission = NotificationPermission.DEFAULT;
   };

   connect.NotificationManager.prototype.requestPermission = function() {
      var self = this;
      if (!("Notification" in global)) {
         connect.getLog().warn("This browser doesn't support notifications.");
         this.permission = NotificationPermission.DENIED;

      } else if (global.Notification.permission === NotificationPermission.DENIED) {
         connect.getLog().warn("The user has requested to not receive notifications.");
         this.permission = NotificationPermission.DENIED;

      } else if (this.permission !== NotificationPermission.GRANTED) {
         global.Notification.requestPermission(function(permission) {
            self.permission = permission;
            if (permission === NotificationPermission.GRANTED) {
               self._showQueued();

            } else {
               self.queue = [];
            }
         });
      }
   };

   connect.NotificationManager.prototype.show = function(title, options) {
      if (this.permission === NotificationPermission.GRANTED) {
         return this._showImpl({title: title, options: options});

      } else if (this.permission === NotificationPermission.DENIED) {
         connect.getLog().warn("Unable to show notification.").withObject({
            title: title,
            options: options
         });

      } else {
         var params = {title: title, options: options};
         connect.getLog().warn("Deferring notification until user decides to allow or deny.")
            .withObject(params);
         this.queue.push(params);
      }
   };

   connect.NotificationManager.prototype._showQueued = function() {
      var self = this;
      var notifications = this.queue.map(function(params) {
         return self._showImpl(params);
      });
      this.queue = [];
      return notifications;
   };

   connect.NotificationManager.prototype._showImpl = function(params) {
      var notification = new global.Notification(params.title, params.options);
      if (params.options.clicked) {
         notification.onclick = function() {
            params.options.clicked.call(notification);
         };
      }
      return notification;
   };

   connect.BaseError = function(format, args) {
      global.Error.call(this, connect.vsprintf(format, args));
   };
   connect.BaseError.prototype = Object.create(Error.prototype);
   connect.BaseError.prototype.constructor = connect.BaseError;

   connect.ValueError = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var format = args.shift();
      connect.BaseError.call(this, format, args);
   };
   connect.ValueError.prototype = Object.create(connect.BaseError.prototype);
   connect.ValueError.prototype.constructor = connect.ValueError;

   connect.NotImplementedError = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var format = args.shift();
      connect.BaseError.call(this, format, args);
   };
   connect.NotImplementedError.prototype = Object.create(connect.BaseError.prototype);
   connect.NotImplementedError.prototype.constructor = connect.NotImplementedError;

   connect.StateError = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var format = args.shift();
      connect.BaseError.call(this, format, args);
   };
   connect.StateError.prototype = Object.create(connect.BaseError.prototype);
   connect.StateError.prototype.constructor = connect.StateError;

})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;

   var ALL_EVENTS = '<<all>>';

   /**---------------------------------------------------------------
    * enum EventType
    */
   var EventType = connect.makeEnum([
         'acknowledge',
         'ack_timeout',
         'api_request',
         'api_response',
         'auth_fail',
         'close',
         'configure',
         'log',
         'master_request',
         'master_response',
         'synchronize',
         'terminate',
         'terminated',
         'send_logs',
         'reload_agent_configuration',
         'broadcast'
   ]);

   /**---------------------------------------------------------------
    * enum MasterTopics
    */
   var MasterTopics = connect.makeNamespacedEnum('connect', [
         'loginPopup',
         'sendLogs',
         'softphone',
         'ringtone'
   ]);

   /**---------------------------------------------------------------
    * enum AgentEvents
    */
   var AgentEvents = connect.makeNamespacedEnum('agent', [
         'init',
         'update',
         'refresh',
         'routable',
         'not_routable',
         'pending',
         'contact_pending',
         'offline',
         'error',
         'softphone_error',
         'state_change',
         'acw'
   ]);

   /**---------------------------------------------------------------
    * enum ContactEvents
    */
   var ContactEvents = connect.makeNamespacedEnum('contact', [
         'init',
         'refresh',
         'destroyed',
         'incoming',
         'pending',
         'connecting',
         'connected',
         'missed',
         'acw',
         'ended',
         'error',
         'accepted'
   ]);

   /**---------------------------------------------------------------
    * class EventFactory
    */
   var EventFactory = function() {};
   EventFactory.createRequest = function(type, method, params) {
      return {
         event:      type,
         requestId:  connect.randomId(),
         method:     method,
         params:     params
      };
   };

   EventFactory.createResponse = function(type, request, data, err) {
      return {
         event:      type,
         requestId:  request.requestId,
         data:       data,
         err:        err || null
      };
   };

   /**
    * An object representing an event subscription in an EventBus.
    */
   var Subscription = function(subMap, eventName, f) {
      this.subMap = subMap;
      this.id = connect.randomId();
      this.eventName = eventName;
      this.f = f;
   };

   /**
    * Unsubscribe the handler of this subscription from the EventBus
    * from which it was created.
    */
   Subscription.prototype.unsubscribe = function() {
      this.subMap.unsubscribe(this.eventName, this.id);
   };

   /**
    * A map of event subscriptions, used by the EventBus.
    */
   var SubscriptionMap = function() {
      this.subIdMap = {};
      this.subEventNameMap = {};
   };

   /**
    * Add a subscription for the named event.  Creates a new Subscription
    * object and returns it.  This object can be used to unsubscribe.
    */
   SubscriptionMap.prototype.subscribe = function(eventName, f) {
      var sub = new Subscription(this, eventName, f);

      this.subIdMap[sub.id] = sub;
      var subList = this.subEventNameMap[eventName] || [];
      subList.push(sub);
      this.subEventNameMap[eventName] = subList;
   };

   /**
    * Unsubscribe a subscription matching the given event name and id.
    */
   SubscriptionMap.prototype.unsubscribe = function(eventName, subId) {
      if (connect.contains(this.subEventNameMap, eventName)) {
         this.subEventNameMap[eventName] = this.subEventNameMap[eventName].filter(function(s) { return s.id !== subId; });

         if (this.subEventNameMap[eventName].length < 1) {
            delete this.subEventNameMap[eventName];
         }
      }

      if (connect.contains(this.subIdMap, subId)) {
         delete this.subIdMap[subId];
      }
   };

   /**
    * Get a list of all subscriptions in the subscription map.
    */
   SubscriptionMap.prototype.getAllSubscriptions = function() {
      return connect.values(this.subEventNameMap).reduce(function(a, b) {
         return a.concat(b);
      }, []);
   };

   /**
    * Get a list of subscriptions for the given event name, or an empty
    * list if there are no subscriptions.
    */
   SubscriptionMap.prototype.getSubscriptions = function(eventName) {
      return this.subEventNameMap[eventName] || [];
   };

   /**
    * An object which maintains a map of subscriptions and serves as the
    * mechanism for triggering events to be handled by subscribers.
    */
   var EventBus = function(paramsIn) {
      var params = paramsIn || {};

      this.subMap = new SubscriptionMap();
      this.logEvents = params.logEvents || false;
   };

   /**
    * Subscribe to the named event.  Returns a new Subscription object
    * which can be used to unsubscribe.
    */
   EventBus.prototype.subscribe = function(eventName, f) {
      connect.assertNotNull(eventName, 'eventName');
      connect.assertNotNull(f, 'f');
      connect.assertTrue(connect.isFunction(f), 'f must be a function');
      return this.subMap.subscribe(eventName, f);
   };

   /**
    * Subscribe a function to be called on all events.
    */
   EventBus.prototype.subscribeAll = function(f) {
      connect.assertNotNull(f, 'f');
      connect.assertTrue(connect.isFunction(f), 'f must be a function');
      return this.subMap.subscribe(ALL_EVENTS, f);
   };

   /**
    * Get a list of subscriptions for the given event name, or an empty
    * list if there are no subscriptions.
    */
   EventBus.prototype.getSubscriptions = function(eventName) {
      return this.subMap.getSubscriptions(eventName);
   };

   /**
    * Trigger the given event with the given data.  All methods subscribed
    * to this event will be called and are provided with the given arbitrary
    * data object and the name of the event, in that order.
    */
   EventBus.prototype.trigger = function(eventName, data) {
      connect.assertNotNull(eventName, 'eventName');
      var self = this;
      var allEventSubs = this.subMap.getSubscriptions(ALL_EVENTS);
      var eventSubs = this.subMap.getSubscriptions(eventName);

      if (this.logEvents) {
         connect.getLog().trace("Publishing event: %s", eventName);
      }

      allEventSubs.concat(eventSubs).forEach(function(sub) {
         try {
            sub.f(data || null, eventName, self);

         } catch (e) {
            connect.getLog().error("'%s' event handler failed.", eventName).withException(e);
         }
      });
   };

   /**
    * Returns a closure which bridges an event from another EventBus to this bus.
    *
    * Usage:
    * conduit.onUpstream("MyEvent", bus.bridge());
    */
   EventBus.prototype.bridge = function() {
      var self = this;
      return function(data, event) {
         self.trigger(event, data);
      };
   };

   /**
    * Unsubscribe all events in the event bus.
    */
   EventBus.prototype.unsubscribeAll = function() {
      this.subMap.getAllSubscriptions().forEach(function(sub) {
         sub.unsubscribe();
      });
   };

   connect.EventBus = EventBus;
   connect.EventFactory = EventFactory;
   connect.EventType = EventType;
   connect.AgentEvents = AgentEvents;
   connect.ContactEvents = ContactEvents;
   connect.MasterTopics = MasterTopics;
})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   /**---------------------------------------------------------------
    * class Stream
    *
    * Represents an object from which messages can be read and to which
    * messages can be sent.
    */
   var Stream = function() {};

   /**
    * Send a message to the stream.  This method must be implemented by subclasses.
    */
   Stream.prototype.send = function(message) {
      throw new connect.NotImplementedError();
   };

   /**
    * Provide a method to be called when messages are received from this stream.
    * This method must be implemented by subclasses.
    */
   Stream.prototype.onMessage = function(f) {
      throw new connect.NotImplementedError();
   };

   /**---------------------------------------------------------------
    * class NullStream extends Stream
    *
    * A null stream which provides no message sending or receiving facilities.
    */
   var NullStream = function() {
      Stream.call(this);
   };
   NullStream.prototype = Object.create(Stream.prototype);
   NullStream.prototype.constructor = NullStream;

   NullStream.prototype.onMessage = function(f) {};
   NullStream.prototype.send = function(message) {};

   /**---------------------------------------------------------------
    * class WindowStream extends Stream
    *
    * A stream for communicating with a window object.  The domain provided
    * must match the allowed message domains of the downstream receiver
    * or messages will be rejected, see https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
    * for more info.
    */
   var WindowStream = function(win, domain) {
      Stream.call(this);
      this.window = win;
      this.domain = domain || '*';
   };
   WindowStream.prototype = Object.create(Stream.prototype);
   WindowStream.prototype.constructor = WindowStream;

   WindowStream.prototype.send = function(message) {
      this.window.postMessage(message, this.domain);
   };

   WindowStream.prototype.onMessage = function(f) {
      this.window.addEventListener("message", f);
   };

   /**---------------------------------------------------------------
    * class WindowIOStream extends Stream
    *
    * A stream used by IFrame/popup windows to communicate with their parents
    * and vise versa.
    *
    * This object encapsulates the fact that incoming and outgoing messages
    * arrive on different windows and allows this to be managed as a single
    * Stream object.
    */
   var WindowIOStream = function(inputwin, outputwin, domain) {
      Stream.call(this);
      this.input = inputwin;
      this.output = outputwin;
      this.domain = domain || '*';
   };
   WindowIOStream.prototype = Object.create(Stream.prototype);
   WindowIOStream.prototype.constructor = WindowIOStream;

   WindowIOStream.prototype.send = function(message) {
      this.output.postMessage(message, this.domain);
   };

   WindowIOStream.prototype.onMessage = function(f) {
      this.input.addEventListener("message", f);
   };

   /**---------------------------------------------------------------
    * class PortStream extends Stream
    *
    * A stream wrapping an HTML5 Worker port.  This could be the port
    * used to connect to a Worker or one of the multitude of ports
    * made available to a SharedWorker for communication back to
    * its connected clients.
    */
   var PortStream = function(port) {
      Stream.call(this);
      this.port = port;
      this.id = connect.randomId();
   };
   PortStream.prototype = Object.create(Stream.prototype);
   PortStream.prototype.constructor = PortStream;

   PortStream.prototype.send = function(message) {
      this.port.postMessage(message);
   };

   PortStream.prototype.onMessage = function(f) {
      this.port.addEventListener("message", f);
   };

   PortStream.prototype.getId = function() {
      return this.id;
   };

   /**---------------------------------------------------------------
    * class StreamMultiplexer extends Stream
    *
    * A wrapper for multiplexed downstream communication with
    * multiple streams at once.  Mainly useful for the SharedWorker to
    * broadcast events to many PortStream objects at once.
    */
   var StreamMultiplexer = function(streams) {
      Stream.call(this);
      this.streamMap = streams ?
         connect.index(streams, function(s) { return s.getId(); }) : {};
      this.messageListeners = [];
   };
   StreamMultiplexer.prototype = Object.create(Stream.prototype);
   StreamMultiplexer.prototype.constructor = StreamMultiplexer;

   /**
    * Send a message to all ports in the multiplexer.
    */
   StreamMultiplexer.prototype.send = function(message) {
      this.getStreams().forEach(function(stream) {
         try {
            stream.send(message);

         } catch (e) {
            // Couldn't send message to one of the downstreams for some reason...
            // No reliable logging possible without further failures,
            // no recovery, just eat it.
         }
      });
   };

   /**
    * Register a method which will be called when a message is received from
    * any of the downstreams.
    */
   StreamMultiplexer.prototype.onMessage = function(f) {
      this.messageListeners.push(f);

      // Update existing streams with the new listener.
      this.getStreams().forEach(function(stream) {
         stream.onMessage(f);
      });
   };

   /**
    * Add a stream to the multiplexer.
    */
   StreamMultiplexer.prototype.addStream = function(stream) {
      var self = this;
      this.streamMap[stream.getId()] = stream;

      // Update stream with existing listeners.
      this.messageListeners.forEach(function(messageListener) {
         stream.onMessage(messageListener);
      });
   };

   /**
    * Remove the given downstream.  This is typically used in response
    * to the SharedWorker's onclose event, indicating that a consumer
    * tab has been closed.
    */
   StreamMultiplexer.prototype.removeStream = function(stream) {
      delete this.streamMap[stream.getId()];
   };

   /**
    * Get a list of streams in the multiplexer.
    */
   StreamMultiplexer.prototype.getStreams = function(stream) {
      return connect.values(this.streamMap);
   };

   /**
    * Get the stream matching the given port.
    */
   StreamMultiplexer.prototype.getStreamForPort = function(port) {
      return connect.find(this.getStreams(), function(s) {
         return s.port === port;
      });
   };

   /**---------------------------------------------------------------
    * class Conduit
    *
    * An object which bridges an upstream and a downstream, allowing messages
    * to be passed to and from each and providing an event bus for event
    * subscriptions to be made upstream and downstream.
    */
   var Conduit = function(name, upstream, downstream) {
      this.name = name;
      this.upstream = upstream || new NullStream();
      this.downstream = downstream || new NullStream();
      this.downstreamBus = new connect.EventBus();
      this.upstreamBus = new connect.EventBus();

      this.upstream.onMessage(connect.hitch(this, this._dispatchEvent, this.upstreamBus));
      this.downstream.onMessage(connect.hitch(this, this._dispatchEvent, this.downstreamBus));
   };

   Conduit.prototype.onUpstream = function(eventName, f) {
      connect.assertNotNull(eventName, 'eventName');
      connect.assertNotNull(f, 'f');
      connect.assertTrue(connect.isFunction(f), 'f must be a function');
      return this.upstreamBus.subscribe(eventName, f);
   };

   Conduit.prototype.onAllUpstream = function(f) {
      connect.assertNotNull(f, 'f');
      connect.assertTrue(connect.isFunction(f), 'f must be a function');
      return this.upstreamBus.subscribeAll(f);
   };

   Conduit.prototype.onDownstream = function(eventName, f) {
      connect.assertNotNull(eventName, 'eventName');
      connect.assertNotNull(f, 'f');
      connect.assertTrue(connect.isFunction(f), 'f must be a function');
      return this.downstreamBus.subscribe(eventName, f);
   };

   Conduit.prototype.onAllDownstream = function(f) {
      connect.assertNotNull(f, 'f');
      connect.assertTrue(connect.isFunction(f), 'f must be a function');
      return this.downstreamBus.subscribeAll(f);
   };

   Conduit.prototype.sendUpstream = function(eventName, data) {
      connect.assertNotNull(eventName, 'eventName');
      this.upstream.send({event: eventName, data: data});
   };

   Conduit.prototype.sendDownstream = function(eventName, data) {
      connect.assertNotNull(eventName, 'eventName');
      this.downstream.send({event: eventName, data: data});
   };

   Conduit.prototype._dispatchEvent = function(bus, messageEvent) {
      var message = messageEvent.data;
      if (message.event) {
         bus.trigger(message.event, message.data);
      }
   };

   /**
    * Returns a closure which passes events upstream.
    *
    * Usage:
    * conduit.onDownstream("MyEvent", conduit.passUpstream());
    */
   Conduit.prototype.passUpstream = function() {
      var self = this;
      return function(data, eventName) {
         self.upstream.send({event: eventName, data: data});
      };
   };

   /**
    * Returns a closure which passes events downstream.
    *
    * Usage:
    * conduit.onUpstream("MyEvent", conduit.passDownstream());
    */
   Conduit.prototype.passDownstream = function() {
      var self = this;
      return function(data, eventName) {
         self.downstream.send({event: eventName, data: data});
      };
   };

   /**
    * Shutdown the conduit's event busses and remove all subscriptions.
    */
   Conduit.prototype.shutdown = function() {
      this.upstreamBus.unsubscribeAll();
      this.downstreamBus.unsubscribeAll();
   };

   /**---------------------------------------------------------------
    * class IFrameConduit extends Conduit
    *
    * Creates a conduit for the given IFrame element.
    */
   var IFrameConduit = function(name, window, iframe, domain) {
      Conduit.call(this, name, new WindowIOStream(window, iframe.contentWindow, domain || '*'), null);
   };
   IFrameConduit.prototype = Object.create(Conduit.prototype);
   IFrameConduit.prototype.constructor = IFrameConduit;

   connect.Stream = Stream;
   connect.NullStream = NullStream;
   connect.WindowStream = WindowStream;
   connect.WindowIOStream = WindowIOStream;
   connect.PortStream = PortStream;
   connect.StreamMultiplexer = StreamMultiplexer;
   connect.Conduit = Conduit;
   connect.IFrameConduit = IFrameConduit;
})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   /**---------------------------------------------------------------
    * enum ClientMethods
    */
   connect.ClientMethods = connect.makeEnum([
         'getAgentSnapshot',
         'putAgentState',
         'getAgentStates',
         'getDialableCountryCodes',
         'getRoutingProfileQueues',
         'getAgentPermissions',
         'getAgentConfiguration',
         'updateAgentConfiguration',
         'acceptContact',
         'createOutboundContact',
         'destroyContact',
         'notifyContactIssue',
         'updateContactAttributes',
         'createAdditionalConnection',
         'destroyConnection',
         'holdConnection',
         'resumeConnection',
         'toggleActiveConnections',
         'conferenceConnections',
         'sendClientLogs',
         'sendDigits',
         'sendSoftphoneCallReport',
         'sendSoftphoneCallMetrics',
         'getEndpoints',
         'getNewAuthToken'
   ]);

   /**---------------------------------------------------------------
    * enum MasterMethods
    */
   connect.MasterMethods = connect.makeEnum([
         'becomeMaster',
         'checkMaster'
   ]);

   /**---------------------------------------------------------------
    * abstract class ClientBase
    */
   var ClientBase = function() {};
   ClientBase.EMPTY_CALLBACKS = {
      success: function() { },
      failure: function() { }
   };

   ClientBase.prototype.call = function(method, paramsIn, callbacksIn) {
      connect.assertNotNull(method, 'method');
      var params = paramsIn || {};
      var callbacks = callbacksIn || ClientBase.EMPTY_CALLBACKS;
      this._callImpl(method, params, callbacks);
   };

   ClientBase.prototype._callImpl = function(method, params, callbacks) {
      throw new connect.NotImplementedError();
   };

   /**---------------------------------------------------------------
    * class NullClient extends ClientBase
    */
   var NullClient = function() {
      ClientBase.call(this);
   };
   NullClient.prototype = Object.create(ClientBase.prototype);
   NullClient.prototype.constructor = NullClient;

   NullClient.prototype._callImpl = function(method, params, callbacks) {
      if (callbacks && callbacks.failure) {
         var message = connect.sprintf('No such method exists on NULL client: %s', method);
         callbacks.failure(new connect.ValueError(message), {message: message});
      }
   };

   /**---------------------------------------------------------------
    * abstract class UpstreamConduitClientBase extends ClientBase
    */
   var UpstreamConduitClientBase = function(conduit, requestEvent, responseEvent) {
      ClientBase.call(this);
      this.conduit = conduit;
      this.requestEvent = requestEvent;
      this.responseEvent = responseEvent;
      this._requestIdCallbacksMap = {};

      this.conduit.onUpstream(responseEvent, connect.hitch(this, this._handleResponse));
   };

   UpstreamConduitClientBase.prototype = Object.create(ClientBase.prototype);
   UpstreamConduitClientBase.prototype.constructor = UpstreamConduitClientBase;

   UpstreamConduitClientBase.prototype._callImpl = function(method, params, callbacks) {
      var request = connect.EventFactory.createRequest(this.requestEvent, method, params);
      this._requestIdCallbacksMap[request.requestId] = callbacks;
      this.conduit.sendUpstream(request.event, request);
   };

   UpstreamConduitClientBase.prototype._getCallbacksForRequest = function(requestId) {
      var callbacks = this._requestIdCallbacksMap[requestId] || null;

      if (callbacks != null) {
         delete this._requestIdCallbacksMap[requestId];
      }

      return callbacks;
   };

   UpstreamConduitClientBase.prototype._handleResponse = function(data) {
      var callbacks = this._getCallbacksForRequest(data.requestId);
      if (callbacks == null) {
         return;
      }

      if (data.err && callbacks.failure) {
         callbacks.failure(data.err, data.data);

      } else if (callbacks.success) {
         callbacks.success(data.data);
      }
   };

   /**---------------------------------------------------------------
    * class UpstreamConduitClient extends ClientBase
    */
   var UpstreamConduitClient = function(conduit) {
      UpstreamConduitClientBase.call(this, conduit, connect.EventType.API_REQUEST, connect.EventType.API_RESPONSE);
   };
   UpstreamConduitClient.prototype = Object.create(UpstreamConduitClientBase.prototype);
   UpstreamConduitClient.prototype.constructor = UpstreamConduitClient;

   /**---------------------------------------------------------------
    * class UpstreamConduitMasterClient extends ClientBase
    */
   var UpstreamConduitMasterClient = function(conduit) {
      UpstreamConduitClientBase.call(this, conduit, connect.EventType.MASTER_REQUEST, connect.EventType.MASTER_RESPONSE);
   };
   UpstreamConduitMasterClient.prototype = Object.create(UpstreamConduitClientBase.prototype);
   UpstreamConduitMasterClient.prototype.constructor = UpstreamConduitMasterClient;

   /**---------------------------------------------------------------
    * class AWSClient extends ClientBase
    */
   var AWSClient = function(authToken, region, endpointIn) {
      connect.assertNotNull(authToken, 'authToken');
      connect.assertNotNull(region, 'region');
      ClientBase.call(this);
      AWS.config.credentials = new AWS.Credentials({});
      AWS.config.region = region;
      this.authToken = authToken;
      var endpointUrl = endpointIn || connect.getBaseUrl() + '/connect/api';
      var endpoint = new AWS.Endpoint(endpointUrl);
      this.client = new AWS.Connect({endpoint: endpoint});
   };
   AWSClient.prototype = Object.create(ClientBase.prototype);
   AWSClient.prototype.constructor = AWSClient;

   AWSClient.prototype._callImpl = function(method, params, callbacks) {
      var self = this;
      var log = connect.getLog();

      params.authentication = {
         authToken: this.authToken
      };

      if (! connect.contains(this.client, method)) {
         var message = connect.sprintf('No such method exists on AWS client: %s', method);
         callbacks.failure(new connect.ValueError(message), {message: message});

      } else {
         params = this._translateParams(method, params);

         log.trace("AWSClient: --> Calling operation '%s'", method);

         this.client[method](params)
            .on('build', function(request) {
               request.httpRequest.headers['X-Amz-Bearer'] = self.authToken;
            })
            .send(function(err, data) {
               try {
                  if (err) {
                     if (err.code === connect.CTIExceptions.UNAUTHORIZED_EXCEPTION) {
                        callbacks.authFailure();
                     } else {
                        // Can't pass err directly to postMessage
                        // postMessage() tries to clone the err object and failed.
                        // Refer to https://github.com/goatslacker/alt-devtool/issues/5
                        var error = {};
                        error.type = err.code;
                        error.message = err.message;
                        error.stack = err.stack ? err.stack.split('\n') : [];
                        callbacks.failure(error, data);
                     }

                     log.trace("AWSClient: <-- Operation '%s' failed: %s", method, JSON.stringify(err));

                  } else {
                     log.trace("AWSClient: <-- Operation '%s' succeeded.", method).withObject(data);
                     callbacks.success(data);
                  }
               } catch (e) {
                  connect.getLog().error("Failed to handle AWS API request for method %s", method)
                        .withException(e);
               }
            });
      }
   };

   AWSClient.prototype._translateParams = function(method, params) {
      switch (method) {
         case connect.ClientMethods.UPDATE_AGENT_CONFIGURATION:
            params.configuration = this._translateAgentConfiguration(params.configuration);
            break;

         case connect.ClientMethods.SEND_SOFTPHONE_CALL_METRICS:
            params.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(
                  params.softphoneStreamStatistics);
            break;

         case connect.ClientMethods.SEND_SOFTPHONE_CALL_REPORT:
            params.report = this._translateSoftphoneCallReport(params.report);
            break;

         default:
            break;
      }

      return params;
   };

   AWSClient.prototype._translateAgentConfiguration = function(config) {
      return {
         name: config.name,
         softphoneEnabled: config.softphoneEnabled,
         softphoneAutoAccept: config.softphoneAutoAccept,
         extension: config.extension,
         routingProfile: this._translateRoutingProfile(config.routingProfile),
         agentPreferences: config.agentPreferences
      };
   };

   AWSClient.prototype._translateRoutingProfile = function(profile) {
      return {
         name: profile.name,
         routingProfileARN: profile.routingProfileARN,
         defaultOutboundQueue: this._translateQueue(profile.defaultOutboundQueue)
      };
   };

   AWSClient.prototype._translateQueue = function(queue) {
      return {
         queueARN:   queue.queueARN,
         name:       queue.name
      };
   };

   AWSClient.prototype._translateSoftphoneStreamStatistics = function(stats) {
      stats.forEach(function(stat) {
         if ('packetsCount' in stat) {
            stat.packetCount = stat.packetsCount;
            delete stat.packetsCount;
         }
      });

      return stats;
   };

   AWSClient.prototype._translateSoftphoneCallReport = function(report) {
      if ('handshakingTimeMillis' in report) {
         report.handshakeTimeMillis = report.handshakingTimeMillis;
         delete report.handshakingTimeMillis;
      }

      if ('preTalkingTimeMillis' in report) {
         report.preTalkTimeMillis = report.preTalkingTimeMillis;
         delete report.preTalkingTimeMillis;
      }

      if ('handshakingFailure' in report) {
         report.handshakeFailure = report.handshakingFailure;
         delete report.handshakingFailure;
      }

      if ('talkingTimeMillis' in report) {
         report.talkTimeMillis = report.talkingTimeMillis;
         delete report.talkingTimeMillis;
      }

      report.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(
            report.softphoneStreamStatistics);

      return report;
   };

   connect.NullClient = NullClient;
   connect.UpstreamConduitClient = UpstreamConduitClient;
   connect.UpstreamConduitMasterClient = UpstreamConduitMasterClient;
   connect.AWSClient = AWSClient;

})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   /**-------------------------------------------------------------------------
    * GraphLink <<abstract class>>
    *
    * Represents the association of one or more attributes to a state transition.
    */
   var GraphLink = function(fromState, toState) {
      connect.assertNotNull(fromState, 'fromState');
      connect.assertNotNull(toState, 'toState');
      this.fromState = fromState;
      this.toState = toState;
   };

   GraphLink.prototype.getAssociations = function(context) {
      throw connect.NotImplementedError();
   };

   GraphLink.prototype.getFromState = function() {
      return this.fromState;
   };

   GraphLink.prototype.getToState = function() {
      return this.toState;
   };

   /**-------------------------------------------------------------------------
    * DirectGraphLink <<concrete class>> extends GraphLink
    *
    * Represents the by-value representation of one or more attributes to a
    * state transition.
    */
   var DirectGraphLink = function(fromState, toState, associations) {
      connect.assertNotNull(fromState, 'fromState');
      connect.assertNotNull(toState, 'toState');
      connect.assertNotNull(associations, 'associations');
      GraphLink.call(this, fromState, toState);
      this.associations = associations;
   };
   DirectGraphLink.prototype = Object.create(GraphLink.prototype);
   DirectGraphLink.prototype.constructor = DirectGraphLink;

   DirectGraphLink.prototype.getAssociations = function(context) {
      return this.associations;
   };

   /**
    * FunctionalGraphLink <<concrete class>> extends GraphLink
    *
    * Represents a functional association of one or more attributes to a
    * state transition.
    */
   var FunctionalGraphLink = function(fromState, toState, closure) {
      connect.assertNotNull(fromState, 'fromState');
      connect.assertNotNull(toState, 'toState');
      connect.assertNotNull(closure, 'closure');
      connect.assertTrue(connect.isFunction(closure), 'closure must be a function');
      GraphLink.call(this, fromState, toState);
      this.closure = closure;
   };
   FunctionalGraphLink.prototype = Object.create(GraphLink.prototype);
   FunctionalGraphLink.prototype.constructor = FunctionalGraphLink;

   FunctionalGraphLink.prototype.getAssociations = function(context) {
      return this.closure(context, this.getFromState(), this.getToState());
   };

   /**-------------------------------------------------------------------------
    * EventGraph <<class>>
    *
    * Builds a map of associations from one state to another in context of a
    * particular object.  The associations can be direct (one or more values)
    * or functional (a method returning one or more values), and are used to
    * provide additional contextual event hooks for the UI to consume.
    */
   var EventGraph = function() {
      this.fromMap = {};
   };
   EventGraph.ANY = "<<any>>";

   EventGraph.prototype.assoc = function(fromStateObj, toStateObj, assocObj) {
      var self = this;

      if (! fromStateObj) {
         throw new Error("fromStateObj is not defined.");
      }

      if (! toStateObj) {
         throw new Error("toStateObj is not defined.");
      }

      if (! assocObj) {
         throw new Error("assocObj is not defined.");
      }

      if (fromStateObj instanceof Array) {
         fromStateObj.forEach(function(fromState) {
            self.assoc(fromState, toStateObj, assocObj);
         });
      } else if (toStateObj instanceof Array) {
         toStateObj.forEach(function(toState) {
            self.assoc(fromStateObj, toState, assocObj);
         });
      } else {
         if (typeof assocObj === "function") {
            this._addAssociation(new FunctionalGraphLink(fromStateObj, toStateObj, assocObj));
         } else if (assocObj instanceof Array) {
            this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, assocObj));
         } else {
            this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, [assocObj]));
         }
      }
      return this;
   };

   EventGraph.prototype.getAssociations = function(context, fromState, toState) {
      connect.assertNotNull(fromState, 'fromState');
      connect.assertNotNull(toState, 'toState');
      var associations = [];

      var toMapFromAny = this.fromMap[EventGraph.ANY] || {};
      var toMap = this.fromMap[fromState] || {};

      associations = associations.concat(this._getAssociationsFromMap(
               toMapFromAny, context, fromState, toState));
      associations = associations.concat(this._getAssociationsFromMap(
               toMap, context, fromState, toState));

      return associations;
   };

   EventGraph.prototype._addAssociation = function(assoc) {
      var toMap = this.fromMap[assoc.getFromState()];

      if (! toMap) {
         toMap = this.fromMap[assoc.getFromState()] = {};
      }

      var assocList = toMap[assoc.getToState()];

      if (! assocList) {
         assocList = toMap[assoc.getToState()] = [];
      }

      assocList.push(assoc);
   };

   EventGraph.prototype._getAssociationsFromMap = function(map, context, fromState, toState) {
      var assocList = (map[EventGraph.ANY] || []).concat(map[toState] || []);
      return assocList.reduce(function(prev, assoc) {
         return prev.concat(assoc.getAssociations(context));
      }, []);
   };

   connect.EventGraph = EventGraph;

})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   /*----------------------------------------------------------------
    * enum AgentStateType
    */
   connect.AgentStateType = connect.makeEnum([
         'init',
         'routable',
         'not_routable',
         'offline'
   ]);
   connect.AgentStatusType = connect.AgentStateType;

   /**
    * enum AgentAvailStates
    */
   connect.AgentAvailStates = connect.makeEnum([
         'Init',
         'Busy',
         'AfterCallWork',
         'CallingCustomer',
         'Dialing',
         'Joining',
         'PendingAvailable',
         'PendingBusy'
   ]);

   /**
    * enum AgentErrorStates
    */
   connect.AgentErrorStates = connect.makeEnum([
         'Error',
         'AgentHungUp',
         'BadAddressAgent',
         'BadAddressCustomer',
         'Default',
         'FailedConnectAgent',
         'FailedConnectCustomer',
         'LineEngagedAgent',
         'LineEngagedCustomer',
         'MissedCallAgent',
         'MissedCallCustomer',
         'MultipleCcpWindows',
         'RealtimeCommunicationError'
   ]);

   /*----------------------------------------------------------------
    * enum AddressType
    */
   connect.EndpointType = connect.makeEnum([
         'phone_number',
         'agent',
         'queue'
   ]);
   connect.AddressType = connect.EndpointType;

   /*----------------------------------------------------------------
    * enum ConnectionType
    */
   connect.ConnectionType = connect.makeEnum([
         'agent',
         'inbound',
         'outbound',
         'monitoring'
   ]);

   /*----------------------------------------------------------------
    * enum ConnectionStateType
    */
   connect.ConnectionStateType = connect.makeEnum([
         'init',
         'connecting',
         'connected',
         'hold',
         'disconnected'
   ]);
   connect.ConnectionStatusType = connect.ConnectionStateType;

   connect.CONNECTION_ACTIVE_STATES = connect.set([
         connect.ConnectionStateType.CONNECTING,
         connect.ConnectionStateType.CONNECTED,
         connect.ConnectionStateType.HOLD
   ]);

   /*----------------------------------------------------------------
    * enum ContactStateType
    */
   connect.ContactStateType = connect.makeEnum([
         'init',
         'incoming',
         'pending',
         'connecting',
         'connected',
         'missed',
         'error',
         'ended'
   ]);
   connect.ContactStatusType = connect.ContactStateType;

   connect.CONTACT_ACTIVE_STATES = connect.makeEnum([
         'incoming',
         'connecting',
         'connected'
   ]);

   /*----------------------------------------------------------------
    * enum ContactType
    */
   connect.ContactType = connect.makeEnum([
         'voice',
         'queue_callback'
   ]);

   /*----------------------------------------------------------------
    * enum SoftphoneCallType
    */
   connect.SoftphoneCallType = connect.makeEnum([
         'audio_video',
         'video_only',
         'audio_only',
         'none'
   ]);

   /*----------------------------------------------------------------
    * enum for SoftphoneErrorTypes
    */
    connect.SoftphoneErrorTypes = connect.makeEnum([
        'unsupported_browser',
        'microphone_not_shared',
        'signalling_handshake_failure',
        'signalling_connection_failure',
        'ice_collection_timeout',
        'user_busy_error',
        'webrtc_error',
        'realtime_communication_error',
        'other'
   ]);

   /*----------------------------------------------------------------
    * enum for CTI exceptions
    */
    connect.CTIExceptions = connect.makeEnum([
        "AccessDeniedException",
        "InvalidStateException",
        "BadEndpointException",
        "InvalidAgentARNException",
        "InvalidConfigurationException",
        "InvalidContactTypeException",
        "PaginationException",
        "RefreshTokenExpiredException",
        "SendDataFailedException",
        "UnauthorizedException"
    ]);
   /*----------------------------------------------------------------
    * class Agent
    */
   var Agent = function() {
      if (! connect.agent.initialized) {
         throw new connect.StateError("The agent is not yet initialized!");
      }
   };

   Agent.prototype._getData = function() {
      return connect.core.getAgentDataProvider().getAgentData();
   };

   Agent.prototype._createContactAPI = function(contactData) {
      return new connect.Contact(contactData.contactId);
   };

   Agent.prototype.onContactPending = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.AgentEvents.CONTACT_PENDING, f);
   };

   Agent.prototype.onRefresh = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.AgentEvents.REFRESH, f);
   };

   Agent.prototype.onRoutable = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.AgentEvents.ROUTABLE, f);
   };

   Agent.prototype.onNotRoutable = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.AgentEvents.NOT_ROUTABLE, f);
   };

   Agent.prototype.onOffline = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.AgentEvents.OFFLINE, f);
   };

   Agent.prototype.onError = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.AgentEvents.ERROR, f);
   };

   Agent.prototype.onSoftphoneError = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.AgentEvents.SOFTPHONE_ERROR, f);
   };

   Agent.prototype.onAfterCallWork = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.AgentEvents.ACW, f);
   };

   Agent.prototype.onStateChange = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.AgentEvents.STATE_CHANGE, f);
   };

   Agent.prototype.getState = function() {
      return this._getData().snapshot.state;
   };

   Agent.prototype.getStatus = Agent.prototype.getState;

   Agent.prototype.getStateDuration = function() {
      return connect.now() - this._getData().snapshot.state.startTimestamp.getTime() + connect.core.getSkew();
   };

   Agent.prototype.getStatusDuration = Agent.prototype.getStateDuration;

   Agent.prototype.getPermissions = function() {
      return this.getConfiguration().permissions;
   };

   Agent.prototype.getContacts = function(contactTypeFilter) {
      var self = this;
      return this._getData().snapshot.contacts.map(function(contactData) {
         return self._createContactAPI(contactData);
      }).filter(function(contact) {
         return (! contactTypeFilter) || contact.getType() === contactTypeFilter;
      });
   };

   Agent.prototype.getConfiguration = function() {
      return this._getData().configuration;
   };

   Agent.prototype.getAgentStates = function() {
      return this.getConfiguration().agentStates;
   };

   Agent.prototype.getRoutingProfile = function() {
      return this.getConfiguration().routingProfile;
   };

   Agent.prototype.getName = function() {
      return this.getConfiguration().name;
   };

   Agent.prototype.getExtension = function() {
      return this.getConfiguration().extension;
   };

   Agent.prototype.getDialableCountries = function() {
      return this.getConfiguration().dialableCountries;
   };

   Agent.prototype.isSoftphoneEnabled = function() {
      return this.getConfiguration().softphoneEnabled;
   };

   Agent.prototype.setConfiguration = function(configuration, callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.UPDATE_AGENT_CONFIGURATION, {
         configuration: connect.assertNotNull(configuration, 'configuration')
      }, {
         success: function(data) {
            // We need to ask the shared worker to reload agent config
            // once we change it so every tab has accurate config.
            var conduit = connect.core.getUpstream();
            conduit.sendUpstream(connect.EventType.RELOAD_AGENT_CONFIGURATION);

            if (callbacks.success) {
               callbacks.success(data);
            }
         },
         failure: callbacks.failure
      });
   };

   Agent.prototype.setState = function(state, callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.PUT_AGENT_STATE, {
         state: connect.assertNotNull(state, 'state')
      }, callbacks);
   };

   Agent.prototype.setStatus = Agent.prototype.setState;

   Agent.prototype.connect = function(endpointIn, params) {
      var client = connect.core.getClient();
      var endpoint = new connect.Endpoint(endpointIn);
      // Have to remove the endpointId field or AWS JS SDK gets mad.
      delete endpoint.endpointId;

      client.call(connect.ClientMethods.CREATE_OUTBOUND_CONTACT, {
         endpoint:    connect.assertNotNull(endpoint, 'endpoint'),
         queueARN:   params.queueARN || params.queueId || this.getRoutingProfile().defaultOutboundQueue.queueARN
      }, {
         success: params.success,
         failure: params.failure
      });
   };

   Agent.prototype.getAllQueueARNs = function() {
      return this.getConfiguration().routingProfile.queues.map(function(queue) {
         return queue.queueARN;
      });
   };

   Agent.prototype.getEndpoints = function(queueARNs, callbacks, pageInfoIn) {
      var self = this;
      var client = connect.core.getClient();
      var pageInfo = pageInfoIn || {endpoints: []};

      pageInfo.maxResults = pageInfo.maxResults || connect.DEFAULT_BATCH_SIZE;

      // Backwards compatibility allowing a single queueARN to be specified
      // instead of an array.
      if (! connect.isArray(queueARNs)) {
         queueARNs = [queueARNs];
      }

      client.call(connect.ClientMethods.GET_ENDPOINTS, {
         queueARNs:   queueARNs,
         nextToken:   pageInfo.nextToken || null,
         maxResults:  pageInfo.maxResults
      }, {
         success: function(data) {
            if (data.nextToken) {
               self.getEndpoints(queueARNs, callbacks, {
                  nextToken:  data.nextToken,
                  maxResults: pageInfo.maxResults,
                  endpoints:  pageInfo.endpoints.concat(data.endpoints)
               });
            } else {
               pageInfo.endpoints = pageInfo.endpoints.concat(data.endpoints);
               var endpoints = pageInfo.endpoints.map(function(endpoint) {
                     return new connect.Endpoint(endpoint);
               });

               callbacks.success({
                  endpoints: endpoints,
                  addresses: endpoints
               });
            }
         },
         failure: callbacks.failure
      });
   };

   Agent.prototype.getAddresses = Agent.prototype.getEndpoints;

   Agent.prototype.toSnapshot = function() {
      return new connect.AgentSnapshot(this._getData());
   };

   /*----------------------------------------------------------------
    * class AgentSnapshot
    */
   var AgentSnapshot = function(agentData) {
      connect.Agent.call(this);
      this.agentData = agentData;
   };
   AgentSnapshot.prototype = Object.create(Agent.prototype);
   AgentSnapshot.prototype.constructor = AgentSnapshot;

   AgentSnapshot.prototype._getData = function() {
      return this.agentData;
   };

   AgentSnapshot.prototype._createContactAPI = function(contactData) {
      return new connect.ContactSnapshot(contactData);
   };

   /*----------------------------------------------------------------
    * class Contact
    */
   var Contact = function(contactId) {
      this.contactId = contactId;
   };

   Contact.prototype._getData = function() {
      return connect.core.getAgentDataProvider().getContactData(this.getContactId());
   };

   Contact.prototype._createConnectionAPI = function(connectionData) {
      return new connect.Connection(this.contactId, connectionData.connectionId);
   };

   Contact.prototype.getEventName = function(eventName) {
      return connect.core.getContactEventName(eventName, this.getContactId());
   };

   Contact.prototype.onRefresh = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(this.getEventName(connect.ContactEvents.REFRESH), f);
   };

   Contact.prototype.onIncoming = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(this.getEventName(connect.ContactEvents.INCOMING), f);
   };

   Contact.prototype.onConnecting = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(this.getEventName(connect.ContactEvents.CONNECTING), f);
   };

   Contact.prototype.onPending = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(this.getEventName(connect.ContactEvents.PENDING), f);
   };

   Contact.prototype.onAccepted = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(this.getEventName(connect.ContactEvents.ACCEPTED), f);
   };

   Contact.prototype.onMissed = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(this.getEventName(connect.ContactEvents.MISSED), f);
   };

   Contact.prototype.onEnded = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(this.getEventName(connect.ContactEvents.ENDED), f);
      bus.subscribe(this.getEventName(connect.ContactEvents.DESTROYED), f);
   };

   Contact.prototype.onACW = function(f) {
     var bus = connect.core.getEventBus();
     bus.subscribe(this.getEventName(connect.ContactEvents.ACW), f);
   };

   Contact.prototype.onConnected = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(this.getEventName(connect.ContactEvents.CONNECTED), f);
   };

   Contact.prototype.getContactId = function() {
      return this.contactId;
   };

   Contact.prototype.getOriginalContactId = function() {
      return this._getData().initialContactId;
   };

   Contact.prototype.getType = function() {
      return this._getData().type;
   };

   Contact.prototype.getStatus = function() {
      return this._getData().state;
   };

   Contact.prototype.getStatusDuration = function() {
      return connect.now() - this._getData().state.timestamp.getTime() + connect.core.getSkew();
   };

   Contact.prototype.getQueue = function() {
      return this._getData().queue;
   };

   Contact.prototype.getQueueTimestamp = function() {
      return this._getData().queueTimestamp;
   };

   Contact.prototype.getConnections = function() {
      var self = this;
      return this._getData().connections.map(function(connData) {
         return new connect.Connection(self.contactId, connData.connectionId);
      });
   };

   Contact.prototype.getInitialConnection = function() {
      return connect.find(this.getConnections(), function(conn) {
         return conn.isInitialConnection();
      }) || null;
   };

   Contact.prototype.getActiveInitialConnection = function() {
      var initialConn = this.getInitialConnection();
      if (initialConn != null && initialConn.isActive()) {
         return initialConn;
      } else {
         return null;
      }
   };

   Contact.prototype.getThirdPartyConnections = function() {
      return this.getConnections().filter(function(conn) {
         return ! conn.isInitialConnection() && conn.getType() !== connect.ConnectionType.AGENT;
      });
   };

   Contact.prototype.getSingleActiveThirdPartyConnection = function() {
      return this.getThirdPartyConnections().filter(function(conn) {
         return conn.isActive();
      })[0] || null;
   };

   Contact.prototype.getAgentConnection = function() {
      return connect.find(this.getConnections(), function(conn) {
         var connType =  conn.getType();
         return connType === connect.ConnectionType.AGENT || connType === connect.ConnectionType.MONITORING;
      });
   };

   Contact.prototype.getAttributes = function() {
      return this._getData().attributes;
   };

   Contact.prototype.isSoftphoneCall = function() {
      return connect.find(this.getConnections(), function(conn) {
         return conn.getSoftphoneMediaInfo() != null;
      }) != null;
   };

   Contact.prototype.isInbound = function() {
      var conn = this.getInitialConnection();
      return conn ? conn.getType() === connect.ConnectionType.INBOUND : false;
   };

   Contact.prototype.isConnected = function() {
      return this.getStatus().type === connect.ContactStateType.CONNECTED;
   };

   Contact.prototype.accept = function(callbacks) {
      var client = connect.core.getClient();
      var self = this;
      client.call(connect.ClientMethods.ACCEPT_CONTACT, {
         contactId:  this.getContactId()
      }, {
         success: function(data) {
            var conduit = connect.core.getUpstream();
            conduit.sendUpstream(connect.EventType.BROADCAST, {
               event: connect.ContactEvents.ACCEPTED
            });
            conduit.sendUpstream(connect.EventType.BROADCAST, {
               event: connect.core.getContactEventName(connect.ContactEvents.ACCEPTED,
                  self.getContactId())
            });

            if (callbacks && callbacks.success) {
               callbacks.success(data);
            }
         },
         failure: callbacks ? callbacks.failure : null
      });
   };

   Contact.prototype.destroy = function(callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.DESTROY_CONTACT, {
         contactId:  this.getContactId()
      }, callbacks);
   };

   Contact.prototype.notifyIssue = function(issueCode, description, callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.NOTIFY_CONTACT_ISSUE, {
         contactId:     this.getContactId(),
         issueCode:     issueCode,
         description:   description
      }, callbacks);
   };

   Contact.prototype.addConnection = function(endpointIn, callbacks) {
      var client = connect.core.getClient();
      var endpoint = new connect.Endpoint(endpointIn);
      // Have to remove the endpointId field or AWS JS SDK gets mad.
      delete endpoint.endpointId;

      client.call(connect.ClientMethods.CREATE_ADDITIONAL_CONNECTION, {
         contactId:     this.getContactId(),
         endpoint:      endpoint
      }, callbacks);
   };

   Contact.prototype.toggleActiveConnections = function(callbacks) {
      var client = connect.core.getClient();
      var connectionId = null;
      var holdingConn = connect.find(this.getConnections(), function(conn) {
         return conn.getStatus().type === connect.ConnectionStateType.HOLD;
      });

      if (holdingConn != null) {
         connectionId = holdingConn.getConnectionId();

      } else {
         var activeConns = this.getConnections().filter(function(conn) {
            return conn.isActive();
         });
         if (activeConns.length > 0) {
            connectionId = activeConns[0].getConnectionId();
         }
      }

      client.call(connect.ClientMethods.TOGGLE_ACTIVE_CONNECTIONS, {
         contactId:     this.getContactId(),
         connectionId:  connectionId
      }, callbacks);
   };

   Contact.prototype.sendSoftphoneMetrics = function(softphoneStreamStatistics, callbacks) {
      var client = connect.core.getClient();

      client.call(connect.ClientMethods.SEND_SOFTPHONE_CALL_METRICS, {
         contactId:     this.getContactId(),
         softphoneStreamStatistics:  softphoneStreamStatistics
      }, callbacks);
   };

   Contact.prototype.sendSoftphoneReport = function(report, callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.SEND_SOFTPHONE_CALL_REPORT, {
         contactId:     this.getContactId(),
         report:  report
      }, callbacks);
   };

   Contact.prototype.conferenceConnections = function(callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.CONFERENCE_CONNECTIONS, {
         contactId:     this.getContactId()
      }, callbacks);
   };

   Contact.prototype.toSnapshot = function() {
      return new connect.ContactSnapshot(this._getData());
   };

   /*----------------------------------------------------------------
    * class ContactSnapshot
    */
   var ContactSnapshot = function(contactData) {
      connect.Contact.call(this, contactData.contactId);
      this.contactData = contactData;
   };
   ContactSnapshot.prototype = Object.create(Contact.prototype);
   ContactSnapshot.prototype.constructor = ContactSnapshot;

   ContactSnapshot.prototype._getData = function() {
      return this.contactData;
   };

   ContactSnapshot.prototype._createConnectionAPI = function(connectionData) {
      return new connect.ConnectionSnapshot(connectionData);
   };

   /*----------------------------------------------------------------
    * class Connection
    */
   var Connection = function(contactId, connectionId) {
      this.contactId = contactId;
      this.connectionId = connectionId;
   };

   Connection.prototype._getData = function() {
      return connect.core.getAgentDataProvider().getConnectionData(
            this.getContactId(), this.getConnectionId());
   };

   Connection.prototype.getContactId = function() {
      return this.contactId;
   };

   Connection.prototype.getConnectionId = function() {
      return this.connectionId;
   };

   Connection.prototype.getEndpoint = function() {
      return new connect.Endpoint(this._getData().endpoint);
   };

   Connection.prototype.getAddress = Connection.prototype.getEndpoint;

   Connection.prototype.getStatus = function() {
      return this._getData().state;
   };

   Connection.prototype.getStatusDuration = function() {
      return connect.now() - this._getData().state.timestamp.getTime() + connect.core.getSkew();
   };

   Connection.prototype.getType = function() {
      return this._getData().type;
   };

   Connection.prototype.isInitialConnection = function() {
      return this._getData().initial;
   };

   Connection.prototype.isActive = function() {
      return connect.contains(connect.CONNECTION_ACTIVE_STATES, this.getStatus().type);
   };

   Connection.prototype.isConnected = function() {
      return this.getStatus().type === connect.ConnectionStateType.CONNECTED;
   };

   Connection.prototype.isConnecting = function() {
      return this.getStatus().type === connect.ConnectionStateType.CONNECTING;
   };

   Connection.prototype.isOnHold = function() {
      return this.getStatus().type === connect.ConnectionStateType.HOLD;
   };

   Connection.prototype.getSoftphoneMediaInfo = function() {
      return this._getData().softphoneMediaInfo;
   };

   Connection.prototype.destroy = function(callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.DESTROY_CONNECTION, {
         contactId:     this.getContactId(),
         connectionId:  this.getConnectionId()
      }, callbacks);
   };

   Connection.prototype.sendDigits = function(digits, callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.SEND_DIGITS, {
         contactId:     this.getContactId(),
         connectionId:  this.getConnectionId(),
         digits:        digits
      }, callbacks);
   };

   Connection.prototype.hold = function(callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.HOLD_CONNECTION, {
         contactId:     this.getContactId(),
         connectionId:  this.getConnectionId()
      }, callbacks);
   };

   Connection.prototype.resume = function(callbacks) {
      var client = connect.core.getClient();
      client.call(connect.ClientMethods.RESUME_CONNECTION, {
         contactId:     this.getContactId(),
         connectionId:  this.getConnectionId()
      }, callbacks);
   };

   Connection.prototype.toSnapshot = function() {
      return new connect.ConnectionSnapshot(this._getData());
   };

   /*----------------------------------------------------------------
    * class ConnectionSnapshot
    */
   var ConnectionSnapshot = function(connectionData) {
      connect.Connection.call(this, connectionData.contactId, connectionData.connectionId);
      this.connectionData = connectionData;
   };
   ConnectionSnapshot.prototype = Object.create(Connection.prototype);
   ConnectionSnapshot.prototype.constructor = ConnectionSnapshot;

   ConnectionSnapshot.prototype._getData = function() {
      return this.connectionData;
   };

   var Endpoint = function(paramsIn) {
      var params = paramsIn || {};
      this.endpointARN = params.endpointId || params.endpointARN || null;
      this.endpointId = this.endpointARN;
      this.type = params.type || null;
      this.name = params.name || null;
      this.phoneNumber = params.phoneNumber || null;
      this.agentLogin = params.agentLogin || null;
      this.queue = params.queue || null;
   };

   /**
    * Strip the SIP endpoint components from the phoneNumber field.
    */
   Endpoint.prototype.stripPhoneNumber = function() {
      return this.phoneNumber ? this.phoneNumber.replace(/sip:([^@]*)@.*/, "$1") : "";
   };

   /**
    * Create an Endpoint object from the given phone number and name.
    */
   Endpoint.byPhoneNumber = function(number, name) {
      return new Endpoint({
         type:          connect.EndpointType.PHONE_NUMBER,
         phoneNumber:   number,
         name:          name || null
      });
   };

   /*----------------------------------------------------------------
    * class SoftphoneError
    */
   var SoftphoneError =  function(errorType, errorMessage, endPointUrl) {
        this.errorType = errorType;
        this.errorMessage = errorMessage;
        this.endPointUrl = endPointUrl;
   };
   SoftphoneError.prototype.getErrorType =  function() {
        return this.errorType;
   };
   SoftphoneError.prototype.getErrorMessage =  function() {
        return this.errorMessage;
   };
   SoftphoneError.prototype.getEndPointUrl =  function() {
        return this.endPointUrl;
   };

   /*----------------------------------------------------------------
    * Root Subscription APIs.
    */
   connect.agent = function(f) {
      if (connect.agent.initialized) {
         f(new connect.Agent());

      } else {
         var bus = connect.core.getEventBus();
         bus.subscribe(connect.AgentEvents.INIT, f);
      }
   };
   connect.agent.initialized = false;

   connect.contact = function(f) {
      var bus = connect.core.getEventBus();
      bus.subscribe(connect.ContactEvents.INIT, f);
   };

   /**
    * Execute the given function asynchronously only if the shared worker
    * says we are the master for the given topic.  If there is no master for
    * the given topic, we become the master and execute the function.
    *
    * @param topic The master topic we are concerned about.
    * @param f_true The callback to be invoked if we are the master.
    * @param f_else [optional] A callback to be invoked if we are not the master.
    */
   connect.ifMaster = function(topic, f_true, f_else) {
      connect.assertNotNull(topic, "A topic must be provided.");
      connect.assertNotNull(f_true, "A true callback must be provided.");

      if (! connect.core.masterClient) {
         // We can't be the master because there is no master client!
         connect.getLog().warn("We can't be the master for topic '%s' because there is no master client!", topic);
         if (f_else) {
            f_else();
         }
         return;
      }

      var masterClient = connect.core.getMasterClient();
      masterClient.call(connect.MasterMethods.CHECK_MASTER, {
         topic: topic
      }, {
         success: function(data) {
            if (data.isMaster) {
               f_true();

            } else if (f_else) {
               f_else();
            }
         }
      });
   };

   /**
    * Notify the shared worker that we are now the master for the given topic.
    */
   connect.becomeMaster = function(topic) {
      connect.assertNotNull(topic, "A topic must be provided.");
      var masterClient = connect.core.getMasterClient();
      masterClient.call(connect.MasterMethods.BECOME_MASTER, {
         topic: topic
      });
   };

   connect.Agent = Agent;
   connect.AgentSnapshot = AgentSnapshot;
   connect.Contact = Contact;
   connect.ContactSnapshot = ContactSnapshot;
   connect.Connection = Connection;
   connect.ConnectionSnapshot = ConnectionSnapshot;
   connect.Endpoint = Endpoint;
   connect.Address = Endpoint;
   connect.SoftphoneError = SoftphoneError;

})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   connect.core = {};

   connect.core.initialized = false;

   connect.DEFAULT_BATCH_SIZE = 100;

   var CCP_SYN_TIMEOUT = 1000; // 1 sec
   var CCP_ACK_TIMEOUT = 3000; // 3 sec
   var CCP_LOAD_TIMEOUT = 3000; // 3 sec
   var CCP_IFRAME_REFRESH_INTERVAL = 5000; // 5 sec

   var LOGIN_URL_PATTERN = "https://{alias}.awsapps.com/auth/?client_id={client_id}&redirect_uri={redirect}";
   var CLIENT_ID_MAP = {
      "us-east-1":   "06919f4fd8ed324e"
   };

   /**
    * @deprecated
    * We will no longer need this function soon.
    */
   var createLoginUrl = function(params) {
      var redirect = "https://lily.us-east-1.amazonaws.com/taw/auth/code";
      connect.assertNotNull(redirect);

      if (params.alias) {
         return LOGIN_URL_PATTERN
            .replace("{alias}", params.alias)
            .replace("{client_id}", CLIENT_ID_MAP["us-east-1"])
            .replace("{redirect}", global.encodeURIComponent(
               redirect));
      } else {
         return params.ccpUrl;
      }
   };

   /**-------------------------------------------------------------------------
    * Print a warning message if the Connect core is not initialized.
    */
   connect.core.checkNotInitialized = function() {
      if (connect.core.initialized) {
         var log = connect.getLog();
         log.warn("Connect core already initialized, only needs to be initialized once.");
      }
   };

   /**-------------------------------------------------------------------------
    * Basic Connect client initialization.
    * Should be used only by the API Shared Worker.
    */
   connect.core.init = function(params) {
      connect.assertNotNull(params, 'params');

      var authToken = connect.assertNotNull(params.authToken, 'params.authToken');
      var region = connect.assertNotNull(params.region, 'params.region');
      var endpoint = params.endpoint || null;

      connect.core.eventBus = new connect.EventBus();
      connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());
      connect.core.client = new connect.AWSClient(authToken, region, endpoint);
      connect.core.initialized = true;
   };

   /**-------------------------------------------------------------------------
    * Uninitialize Connect.
    */
   connect.core.terminate = function() {
      connect.core.client = new connect.NullClient();
      connect.core.masterClient = new connect.NullClient();
      connect.core.eventBus = new connect.EventBus();
      connect.core.initialized = false;
   };

   /**-------------------------------------------------------------------------
    * Setup the SoftphoneManager to be initialized when the agent
    * is determined to have softphone enabled.
    */
   connect.core.softphoneUserMediaStream = null;

   connect.core.getSoftphoneUserMediaStream = function() {
        return connect.core.softphoneUserMediaStream;
   };

   connect.core.setSoftphoneUserMediaStream = function(stream) {
        connect.core.softphoneUserMediaStream = stream;
   };

   connect.core.initRingtoneEngines = function(params) {
      connect.assertNotNull(params, "params");

      var setupRingtoneEngines = function(ringtoneSettings) {
         connect.assertNotNull(ringtoneSettings, "ringtoneSettings");
         connect.assertNotNull(ringtoneSettings.voice, "ringtoneSettings.voice");
         connect.assertTrue(ringtoneSettings.voice.ringtoneUrl || ringtoneSettings.voice.disabled, "ringtoneSettings.voice.ringtoneUrl must be provided or ringtoneSettings.voice.disabled must be true");
         connect.assertNotNull(ringtoneSettings.queue_callback, "ringtoneSettings.queue_callback");
         connect.assertTrue(ringtoneSettings.queue_callback.ringtoneUrl || ringtoneSettings.queue_callback.disabled, "ringtoneSettings.voice.ringtoneUrl must be provided or ringtoneSettings.queue_callback.disabled must be true");

         connect.core.ringtoneEngines = {};

         connect.agent(function(agent) {
            agent.onRefresh(function() {
               connect.ifMaster(connect.MasterTopics.RINGTONE, function() {
                  if (! ringtoneSettings.voice.disabled && ! connect.core.ringtoneEngines.voice) {
                     connect.core.ringtoneEngines.voice =
                        new connect.VoiceRingtoneEngine(ringtoneSettings.voice);
                     connect.getLog().info("VoiceRingtoneEngine initialized.");
                  }

                  if (! ringtoneSettings.queue_callback.disabled && ! connect.core.ringtoneEngines.queue_callback) {
                     connect.core.ringtoneEngines.queue_callback =
                        new connect.QueueCallbackRingtoneEngine(ringtoneSettings.queue_callback);
                     connect.getLog().info("QueueCallbackRingtoneEngine initialized.");
                  }
               });
            });
         });
      };

      var mergeParams = function(params, otherParams) {
         // For backwards compatibility: support pulling disabled flag and ringtoneUrl
         // from softphone config if it exists from downstream into the ringtone config.
         params.ringtone = params.ringtone || {};
         params.ringtone.voice = params.ringtone.voice || {};
         params.ringtone.queue_callback = params.ringtone.queue_callback || {};

         if (otherParams.softphone) {
            if (otherParams.softphone.disableRingtone) {
               params.ringtone.voice.disabled = true;
               params.ringtone.queue_callback.disabled = true;
            }

            if (otherParams.softphone.ringtoneUrl) {
               params.ringtone.voice.ringtoneUrl = otherParams.softphone.ringtoneUrl;
               params.ringtone.queue_callback.ringtoneUrl = otherParams.softphone.ringtoneUrl;
            }
         }

         // Merge in ringtone settings from downstream.
         if (otherParams.ringtone) {
            params.ringtone.voice = connect.merge(params.ringtone.voice,
               otherParams.ringtone.voice || {});
            params.ringtone.queue_callback = connect.merge(params.ringtone.queue_callback,
               otherParams.ringtone.voice || {});
         }
      };
      
      // Merge params from params.softphone into params.ringtone
      // for embedded and non-embedded use cases so that defaults
      // are picked up.
      mergeParams(params, params);

      if (connect.isFramed()) {
         // If the CCP is in a frame, wait for configuration from downstream.
         var bus = connect.core.getEventBus();
         bus.subscribe(connect.EventType.CONFIGURE, function(data) {
            this.unsubscribe();
            // Merge all params from data into params for any overridden
            // values in either legacy "softphone" or "ringtone" settings.
            mergeParams(params, data);
            setupRingtoneEngines(params.ringtone);
         });

      } else {
         setupRingtoneEngines(params.ringtone);
      }
   };

   connect.core.initSoftphoneManager = function(paramsIn) {
      var params = paramsIn || {};

      var competeForMasterOnAgentUpdate = function(softphoneParamsIn) {
         var softphoneParams = connect.merge(params.softphone || {}, softphoneParamsIn);

         connect.agent(function(agent) {
            agent.onRefresh(function() {
               var sub = this;

               connect.ifMaster(connect.MasterTopics.SOFTPHONE, function() {
                  if (! connect.core.softphoneManager && agent.isSoftphoneEnabled()) {
                     // Become master to send logs, since we need logs from softphone tab.
                     connect.becomeMaster(connect.MasterTopics.SEND_LOGS);
                     connect.core.softphoneManager = new connect.SoftphoneManager(softphoneParams);
                     sub.unsubscribe();
                  }
               });
            });
         });
      };

      /**
       * If the window is framed, we need to wait for a CONFIGURE message from
       * downstream before we try to initialize, unless params.allowFramedSoftphone is true.
       */
      if (connect.isFramed() && ! params.allowFramedSoftphone) {
         var bus = connect.core.getEventBus();
         bus.subscribe(connect.EventType.CONFIGURE, function(data) {
            if (data.softphone && data.softphone.allowFramedSoftphone) {
               this.unsubscribe();
               competeForMasterOnAgentUpdate(data.softphone);
            }
         });
      } else {
         competeForMasterOnAgentUpdate(params);
      }
   };

   /**-------------------------------------------------------------------------
    * Initializes Connect by creating or connecting to the API Shared Worker.
    * Used primarily by the CCP.
    */
   connect.core.initSharedWorker = function(params) {
      connect.core.checkNotInitialized();
      if (connect.core.initialized) {
         return;
      }
      connect.assertNotNull(params, 'params');

      var sharedWorkerUrl = connect.assertNotNull(params.sharedWorkerUrl, 'params.sharedWorkerUrl');
      var authToken = connect.assertNotNull(params.authToken, 'params.authToken');
      var refreshToken = connect.assertNotNull(params.refreshToken, 'params.refreshToken');
      var authTokenExpiration = connect.assertNotNull(params.authTokenExpiration, 'params.authTokenExpiration');
      var region = connect.assertNotNull(params.region, 'params.region');
      var endpoint = params.endpoint || null;

      try {
         // Initialize the event bus and agent data providers.
         connect.core.eventBus = new connect.EventBus({logEvents: true});
         connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());

         // Create the shared worker and upstream conduit.
         var worker = new SharedWorker(sharedWorkerUrl, "ConnectSharedWorker");
         var conduit = new connect.Conduit("ConnectSharedWorkerConduit",
               new connect.PortStream(worker.port),
               new connect.WindowIOStream(window, parent));

         // Set the global upstream conduit for external use.
         connect.core.upstream = conduit;

         // Close our port to the shared worker before the window closes.
         global.onbeforeunload = function() {
            conduit.sendUpstream(connect.EventType.CLOSE);
            worker.port.close();
         };

         connect.getLog().scheduleUpstreamLogPush(conduit);
         // Bridge all upstream messages into the event bus.
         conduit.onAllUpstream(connect.core.getEventBus().bridge());
         // Bridge all downstream messages into the event bus.
         conduit.onAllDownstream(connect.core.getEventBus().bridge());
         // Pass all upstream messages (from shared worker) downstream (to CCP consumer).
         conduit.onAllUpstream(conduit.passDownstream());
         // Pass all downstream messages (from CCP consumer) upstream (to shared worker).
         conduit.onAllDownstream(conduit.passUpstream());
         // Send configuration up to the shared worker.
         conduit.sendUpstream(connect.EventType.CONFIGURE, {
            authToken:     authToken,
            authTokenExpiration: authTokenExpiration,
            refreshToken:  refreshToken,
            endpoint:      endpoint,
            region:        region
         });
         conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {
            connect.getLog().info("Acknowledged by the ConnectSharedWorker!");
            connect.core.initialized = true;
            this.unsubscribe();
         });
         // Add all upstream log entries to our own logger.
         conduit.onUpstream(connect.EventType.LOG, function(logEntry) {
            connect.getLog().addLogEntry(connect.LogEntry.fromObject(logEntry));
         });
         // Reload the page if the shared worker detects an API auth failure.
         conduit.onUpstream(connect.EventType.AUTH_FAIL, function(logEntry) {
            location.reload();
         });

         connect.core.client = new connect.UpstreamConduitClient(conduit);
         connect.core.masterClient = new connect.UpstreamConduitMasterClient(conduit);

         // Pass the TERMINATE request upstream to the shared worker.
         connect.core.getEventBus().subscribe(connect.EventType.TERMINATE,
            conduit.passUpstream());

         // Refresh the page when we receive the TERMINATED response from the
         // shared worker.
         connect.core.getEventBus().subscribe(connect.EventType.TERMINATED, function() {
            window.location.reload(true);
         });

         worker.port.start();

         // Attempt to get permission to show notifications.
         var nm = connect.core.getNotificationManager();
         nm.requestPermission();

      } catch (e) {
         connect.getLog().error("Failed to initialize the API shared worker, we're dead!")
            .withException(e);
      }
   };

   /**-------------------------------------------------------------------------
    * Initializes Connect by creating or connecting to the API Shared Worker.
    * Initializes Connect by loading the CCP in an iframe and connecting to it.
    */
   connect.core.initCCP = function(containerDiv, paramsIn) {
      connect.core.checkNotInitialized();
      if (connect.core.initialized) {
         return;
      }

      // For backwards compatibility, when instead of taking a params object
      // as input we only accepted ccpUrl.
      var params = {};
      if (typeof(paramsIn) === 'string') {
         params.ccpUrl = paramsIn;
      } else {
         params = paramsIn;
      }

      var softphoneParams = params.softphone || null;

      connect.assertNotNull(containerDiv, 'containerDiv');
      connect.assertNotNull(params.ccpUrl, 'params.ccpUrl');

      // Create the CCP iframe and append it to the container div.
      var iframe = document.createElement('iframe');
      iframe.src = params.ccpUrl;
      iframe.style = "width: 100%; height: 100%";
      iframe.allow = "microphone";
      containerDiv.appendChild(iframe);

      // Initialize the event bus and agent data providers.
      // NOTE: Setting logEvents here to FALSE in order to avoid duplicating
      // events which are logged in CCP.
      connect.core.eventBus = new connect.EventBus({logEvents: false});
      connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());

      // Build the upstream conduit communicating with the CCP iframe.
      var conduit = new connect.IFrameConduit(params.ccpUrl, window, iframe);

      // Set the global upstream conduit for external use.
      connect.core.upstream = conduit;

      conduit.onAllUpstream(connect.core.getEventBus().bridge());

      // Initialize the keepalive manager.
      connect.core.keepaliveManager = new KeepaliveManager(conduit,
                                                        connect.core.getEventBus(),
                                                        params.ccpSynTimeout || CCP_SYN_TIMEOUT,
                                                        params.ccpAckTimeout || CCP_ACK_TIMEOUT);
      connect.core.iframeRefreshInterval = null;

      // Allow 10 sec (default) before receiving the first ACK from the CCP.
      connect.core.ccpLoadTimeoutInstance = global.setTimeout(function() {
         connect.core.ccpLoadTimeoutInstance = null;
         connect.core.getEventBus().trigger(connect.EventType.ACK_TIMEOUT);
      }, params.ccpLoadTimeout || CCP_LOAD_TIMEOUT);

      // Once we receive the first ACK, setup our upstream API client and establish
      // the SYN/ACK refresh flow.
      conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {
         connect.getLog().info("Acknowledged by the CCP!");
         connect.core.client = new connect.UpstreamConduitClient(conduit);
         connect.core.masterClient = new connect.UpstreamConduitMasterClient(conduit);
         connect.core.initialized = true;

         if (softphoneParams) {
            // Send configuration up to the CCP.
            conduit.sendUpstream(connect.EventType.CONFIGURE, {
               softphone:  softphoneParams
            });
         }

         if (connect.core.ccpLoadTimeoutInstance) {
            global.clearTimeout(connect.core.ccpLoadTimeoutInstance);
            connect.core.ccpLoadTimeoutInstance = null;
         }

         connect.core.keepaliveManager.start();
         this.unsubscribe();
      });

      // Add any logs from the upstream to our own logger.
      conduit.onUpstream(connect.EventType.LOG, function(logEntry) {
         connect.getLog().addLogEntry(connect.LogEntry.fromObject(logEntry));
      });

      // Pop a login page when we encounter an ACK timeout.
      connect.core.getEventBus().subscribe(connect.EventType.ACK_TIMEOUT, function() {
         // loginPopup is true by default, only false if explicitly set to false.
         if (params.loginPopup !== false) {
            try {
               var loginUrl = createLoginUrl(params);
               connect.getLog().warn("ACK_TIMEOUT occurred, attempting to pop the login page if not already open.");
               connect.core.getPopupManager().open(loginUrl, connect.MasterTopics.LOGIN_POPUP);

            } catch (e) {
               connect.getLog().error("ACK_TIMEOUT occurred but we are unable to open the login popup.").withException(e);
            }
         }

         if (connect.core.iframeRefreshInterval == null) {
            connect.core.iframeRefreshInterval = window.setInterval(function() {
               iframe.src = params.ccpUrl;
            }, CCP_IFRAME_REFRESH_INTERVAL);

            conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {
               this.unsubscribe();
               global.clearInterval(connect.core.iframeRefreshInterval);
               connect.core.iframeRefreshInterval = null;
               connect.core.getPopupManager().clear(connect.MasterTopics.LOGIN_POPUP);
            });
         }
      });
   };

   /**-----------------------------------------------------------------------*/
   var KeepaliveManager = function(conduit, eventBus, synTimeout, ackTimeout) {
      this.conduit = conduit;
      this.eventBus = eventBus;
      this.synTimeout = synTimeout;
      this.ackTimeout = ackTimeout;
      this.ackTimer = null;
      this.synTimer = null;
      this.ackSub = null;
   };

   KeepaliveManager.prototype.start = function() {
      var self = this;

      this.conduit.sendUpstream(connect.EventType.SYNCHRONIZE);
      this.ackSub = this.conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {
         this.unsubscribe();
         global.clearTimeout(self.ackTimer);
         self.deferStart();
      });
      this.ackTimer = global.setTimeout(function() {
         self.ackSub.unsubscribe();
         self.eventBus.trigger(connect.EventType.ACK_TIMEOUT);
         self.deferStart();
      }, this.ackTimeout);
   };

   KeepaliveManager.prototype.deferStart = function() {
      if (this.synTimer == null) {
         this.synTimer = global.setTimeout(connect.hitch(this, this.start), this.synTimeout);
      }
   };

   /**-----------------------------------------------------------------------*/
   var AgentDataProvider = function(bus) {
      var agentData = null;
      this.bus = bus;
      this.bus.subscribe(connect.AgentEvents.UPDATE, connect.hitch(this, this.updateAgentData));
   };

   AgentDataProvider.prototype.updateAgentData = function(agentData) {
      var oldAgentData = this.agentData;
      this.agentData = agentData;

      if (oldAgentData == null) {
         connect.agent.initialized = true;
         this.bus.trigger(connect.AgentEvents.INIT, new connect.Agent());
      }

      this.bus.trigger(connect.AgentEvents.REFRESH, new connect.Agent());

      this._fireAgentUpdateEvents(oldAgentData);
   };

   AgentDataProvider.prototype.getAgentData = function() {
      if (this.agentData == null) {
         throw new connect.StateError('No agent data is available yet!');
      }

      return this.agentData;
   };

   AgentDataProvider.prototype.getContactData = function(contactId) {
      var agentData = this.getAgentData();
      var contactData = connect.find(agentData.snapshot.contacts, function(ctdata) {
         return ctdata.contactId === contactId;
      });

      if (contactData == null) {
         throw new connect.StateError('Contact %s no longer exists.', contactId);
      }

      return contactData;
   };

   AgentDataProvider.prototype.getConnectionData = function(contactId, connectionId) {
      var contactData = this.getContactData(contactId);
      var connectionData = connect.find(contactData.connections, function(cdata) {
         return cdata.connectionId === connectionId;
      });

      if (connectionData == null) {
         throw new connect.StateError('Connection %s for contact %s no longer exists.', connectionId, contactId);
      }

      return connectionData;
   };

   AgentDataProvider.prototype._diffContacts = function(oldAgentData) {
      var diff = {
         added:      {},
         removed:    {},
         common:     {},
         oldMap:     connect.index(oldAgentData == null ? [] : oldAgentData.snapshot.contacts, function(contact) { return contact.contactId; }),
         newMap:     connect.index(this.agentData.snapshot.contacts, function(contact) { return contact.contactId; })
      };

      connect.keys(diff.oldMap).forEach(function(contactId) {
         if (connect.contains(diff.newMap, contactId)) {
            diff.common[contactId] = diff.newMap[contactId];
         } else {
            diff.removed[contactId] = diff.oldMap[contactId];
         }
      });

      connect.keys(diff.newMap).forEach(function(contactId) {
         if (! connect.contains(diff.oldMap, contactId)) {
            diff.added[contactId] = diff.newMap[contactId];
         }
      });

      return diff;
   };

   AgentDataProvider.prototype._fireAgentUpdateEvents = function(oldAgentData) {
      var self = this;
      var diff = null;
      var oldAgentState = oldAgentData == null ? connect.AgentAvailStates.INIT : oldAgentData.snapshot.state.name;
      var newAgentState = this.agentData.snapshot.state.name;
      var oldRoutingState = oldAgentData == null ? connect.AgentStateType.INIT : oldAgentData.snapshot.state.type;
      var newRoutingState = this.agentData.snapshot.state.type;

      if (oldRoutingState !== newRoutingState) {
         connect.core.getAgentRoutingEventGraph().getAssociations(this, oldRoutingState, newRoutingState).forEach(function(event) {
            self.bus.trigger(event, new connect.Agent());
         });
      }

      if (oldAgentState !== newAgentState) {
         this.bus.trigger(connect.AgentEvents.STATE_CHANGE, {
            agent:      new connect.Agent(),
            oldState:  oldAgentState,
            newState:  newAgentState

         });
         connect.core.getAgentStateEventGraph().getAssociations(this, oldAgentState, newAgentState).forEach(function(event) {
            self.bus.trigger(event, new connect.Agent());
         });
      }

      if (oldAgentData !== null) {
         diff = this._diffContacts(oldAgentData);

      } else {
         diff =  {
            added:      connect.index(this.agentData.snapshot.contacts, function(contact) { return contact.contactId; }),
            removed:    {},
            common:     {},
            oldMap:     {},
            newMap:     connect.index(this.agentData.snapshot.contacts, function(contact) { return contact.contactId; })
         };
      }

      connect.values(diff.added).forEach(function(contactData) {
         self.bus.trigger(connect.ContactEvents.INIT, new connect.Contact(contactData.contactId));
         self._fireContactUpdateEvents(contactData.contactId, connect.ContactStateType.INIT, contactData.state.type);
      });

      connect.values(diff.removed).forEach(function(contactData) {
         self.bus.trigger(connect.ContactEvents.DESTROYED, new connect.ContactSnapshot(contactData));
         self.bus.trigger(connect.core.getContactEventName(connect.ContactEvents.DESTROYED, contactData.contactId), new connect.ContactSnapshot(contactData));
         self._unsubAllContactEventsForContact(contactData.contactId);
      });

      connect.keys(diff.common).forEach(function(contactId) {
         self._fireContactUpdateEvents(contactId, diff.oldMap[contactId].state.type, diff.newMap[contactId].state.type);
      });
   };

   AgentDataProvider.prototype._fireContactUpdateEvents = function(contactId, oldContactState, newContactState) {
      var self = this;
      if (oldContactState !== newContactState) {
         connect.core.getContactEventGraph().getAssociations(this, oldContactState, newContactState).forEach(function(event) {
            self.bus.trigger(event, new connect.Contact(contactId));
            self.bus.trigger(connect.core.getContactEventName(event, contactId), new connect.Contact(contactId));
         });
      }

      self.bus.trigger(connect.ContactEvents.REFRESH, new connect.Contact(contactId));
      self.bus.trigger(connect.core.getContactEventName(connect.ContactEvents.REFRESH, contactId), new connect.Contact(contactId));
   };

   AgentDataProvider.prototype._unsubAllContactEventsForContact = function(contactId) {
      var self = this;
      connect.values(connect.ContactEvents).forEach(function(eventName) {
         self.bus.getSubscriptions(connect.core.getContactEventName(eventName, contactId))
            .map(function(sub) { sub.unsubscribe(); });
      });
   };

   /**-----------------------------------------------------------------------*/
   connect.core.getContactEventName = function(eventName, contactId) {
      connect.assertNotNull(eventName, 'eventName');
      connect.assertNotNull(contactId, 'contactId');
      if (! connect.contains(connect.values(connect.ContactEvents), eventName)) {
         throw new connect.ValueError('%s is not a valid contact event.', eventName);
      }
      return connect.sprintf('%s::%s', eventName, contactId);
   };

   /**-----------------------------------------------------------------------*/
   connect.core.getEventBus = function() {
      return connect.core.eventBus;
   };

   /**-----------------------------------------------------------------------*/
   connect.core.getAgentDataProvider = function() {
      return connect.core.agentDataProvider;
   };

   /**-----------------------------------------------------------------------*/
   connect.core.getLocalTimestamp = function() {
      return connect.core.getAgentDataProvider().getAgentData().snapshot.localTimestamp;
   };

   /**-----------------------------------------------------------------------*/
   connect.core.getSkew = function() {
      return connect.core.getAgentDataProvider().getAgentData().snapshot.skew;
   };

   /**-----------------------------------------------------------------------*/
   connect.core.getAgentRoutingEventGraph = function() {
      return connect.core.agentRoutingEventGraph;
   };
   connect.core.agentRoutingEventGraph = new connect.EventGraph()
      .assoc(connect.EventGraph.ANY, connect.AgentStateType.ROUTABLE,
             connect.AgentEvents.ROUTABLE)
      .assoc(connect.EventGraph.ANY, connect.AgentStateType.NOT_ROUTABLE,
             connect.AgentEvents.NOT_ROUTABLE)
      .assoc(connect.EventGraph.ANY, connect.AgentStateType.OFFLINE,
             connect.AgentEvents.OFFLINE);

   /**-----------------------------------------------------------------------*/
   connect.core.getAgentStateEventGraph = function() {
      return connect.core.agentStateEventGraph;
   };
   connect.core.agentStateEventGraph = new connect.EventGraph()
      .assoc(connect.EventGraph.ANY,
             connect.values(connect.AgentErrorStates),
             connect.AgentEvents.ERROR)
      .assoc(connect.EventGraph.ANY, connect.AgentAvailStates.AFTER_CALL_WORK,
             connect.AgentEvents.ACW);

   /**-----------------------------------------------------------------------*/
   connect.core.getContactEventGraph = function() {
      return connect.core.contactEventGraph;
   };

   connect.core.contactEventGraph = new connect.EventGraph()
      .assoc(connect.EventGraph.ANY,
             connect.ContactStateType.INCOMING,
             connect.ContactEvents.INCOMING)
      .assoc(connect.EventGraph.ANY,
             connect.ContactStateType.PENDING,
             connect.ContactEvents.PENDING)
      .assoc(connect.EventGraph.ANY,
             connect.ContactStateType.CONNECTING,
             connect.ContactEvents.CONNECTING)
      .assoc(connect.EventGraph.ANY,
             connect.ContactStateType.CONNECTED,
             connect.ContactEvents.CONNECTED)
      .assoc(connect.ContactStateType.INCOMING,
             connect.ContactStateType.ERROR,
             connect.ContactEvents.MISSED)
      .assoc(connect.EventGraph.ANY,
             connect.ContactStateType.ENDED,
             connect.ContactEvents.ACW)
      .assoc(connect.values(connect.CONTACT_ACTIVE_STATES),
             connect.values(connect.relativeComplement(connect.CONTACT_ACTIVE_STATES, connect.ContactStateType)),
             connect.ContactEvents.ENDED);

   /**-----------------------------------------------------------------------*/
   connect.core.getClient = function() {
      if (! connect.core.client) {
         throw new connect.StateError('The connect core has not been initialized!');
      }
      return connect.core.client;
   };
   connect.core.client = null;

   /**-----------------------------------------------------------------------*/
   connect.core.getMasterClient = function() {
      if (! connect.core.masterClient) {
         throw new connect.StateError('The connect master client has not been initialized!');
      }
      return connect.core.masterClient;
   };
   connect.core.masterClient = null;

   /**-----------------------------------------------------------------------*/
   connect.core.getSoftphoneManager = function() {
      return connect.core.softphoneManager;
   };
   connect.core.softphoneManager = null;

   /**-----------------------------------------------------------------------*/
   connect.core.getNotificationManager = function() {
      if (! connect.core.notificationManager) {
         connect.core.notificationManager = new connect.NotificationManager();
      }
      return connect.core.notificationManager;
   };
   connect.core.notificationManager = null;

   /**-----------------------------------------------------------------------*/
   connect.core.getPopupManager = function() {
      return connect.core.popupManager;
   };
   connect.core.popupManager = new connect.PopupManager();

   /**-----------------------------------------------------------------------*/
   connect.core.getPopupManager = function() {
      return connect.core.popupManager;
   };
   connect.core.popupManager = new connect.PopupManager();

   /**-----------------------------------------------------------------------*/
   connect.core.getUpstream = function() {
      if (! connect.core.upstream) {
         throw new connect.StateError('There is no upstream conduit!');
      }
      return connect.core.upstream;
   };
   connect.core.upstream = null;

   /**-----------------------------------------------------------------------*/
   connect.core.AgentDataProvider = AgentDataProvider;

})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   var connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   var RingtoneEngineBase = function(ringtoneConfig) {
      var self = this;
      this._prevContactId = null;

      connect.assertNotNull(ringtoneConfig, "ringtoneConfig");
      if (! ringtoneConfig.ringtoneUrl) {
         throw new Error("ringtoneUrl is required!");
      }

      if (global.Audio && typeof global.Promise !== "undefined") {
         this._playableAudioPromise = new Promise(function(resolve, reject) {
            self._audio = new Audio(ringtoneConfig.ringtoneUrl);
            self._audio.loop = true;
            self._audio.addEventListener("canplay", function(){
               self._audioPlayable = true;
               resolve(self._audio);
            });
         });

      } else {
         this._audio = null;
         connect.getLog().error("Unable to provide a ringtone.");
      }

      self._driveRingtone();
   };

   RingtoneEngineBase.prototype._driveRingtone = function() {
      throw new Error("Not implemented.");
   };

   RingtoneEngineBase.prototype._startRingtone = function() {
      if (this._audio) {
         this._audio.play();
      }
   };

   RingtoneEngineBase.prototype._stopRingtone = function() {
      if (this._audio) {
         this._audio.pause();
         this._audio.currentTime = 0;
      }
   };

   /**
    * Stop ringtone.
    */
   RingtoneEngineBase.prototype.stopRingtone = function() {
      this._stopRingtone();
   };

   RingtoneEngineBase.prototype._ringtoneSetup = function(contact) {
      var self = this;
      connect.ifMaster(connect.MasterTopics.RINGTONE, function() {
         self._startRingtone();
         self._prevContactId = contact.getContactId();

         contact.onConnected(lily.hitch(self, self._stopRingtone));
         contact.onAccepted(lily.hitch(self, self._stopRingtone));
         contact.onEnded(lily.hitch(self, self._stopRingtone));
      });
   };

   /**
    * Change the audio device used to play ringtone.
    * If audio element is not fully initialized, the API will wait _audioPlayablePromise for 3 seconds and fail on timeout.
    * This API is supported only by browsers that implemented ES6 Promise and http://www.w3.org/TR/audio-output/
    * Return a Promise that indicates the result of changing output device.
    */
   RingtoneEngineBase.prototype.setOutputDevice = function(deviceId) {
      if (this._playableAudioPromise) {
         var playableAudioWithTimeout = Promise.race([
            this._playableAudioPromise,
            new Promise(function(resolve, reject){
               global.setTimeout(function(){reject("Timed out waiting for playable audio");}, 3000/*ms*/);
            })
         ]);
         return playableAudioWithTimeout.then(function(audio){
            if (audio.setSinkId) {
               return Promise.resolve(audio.setSinkId(deviceId));
            } else {
               return Promise.reject("Not supported");
            }
         });
      }

      if (global.Promise) {
         return Promise.reject("Not eligible ringtone owner");
      }
   };

   var VoiceRingtoneEngine = function(ringtoneConfig) {
      RingtoneEngineBase.call(this, ringtoneConfig);
   };
   VoiceRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);
   VoiceRingtoneEngine.prototype.constructor = VoiceRingtoneEngine;

   VoiceRingtoneEngine.prototype._driveRingtone = function() {
      var self = this;

      connect.contact(function(contact) {
         contact.onConnecting(function() {
            if (contact.getType() === lily.ContactType.VOICE &&
               contact.isSoftphoneCall() && contact.isInbound()) {
               self._ringtoneSetup(contact);
            }
         });
      });
   };

   var QueueCallbackRingtoneEngine = function(ringtoneConfig) {
      RingtoneEngineBase.call(this, ringtoneConfig);
   };
   QueueCallbackRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);
   QueueCallbackRingtoneEngine.prototype.constructor = QueueCallbackRingtoneEngine;

   QueueCallbackRingtoneEngine.prototype._driveRingtone = function() {
      var self = this;

      connect.contact(function(contact) {
         contact.onIncoming(function() {
             if (contact.getType() === lily.ContactType.QUEUE_CALLBACK) {
                self._ringtoneSetup(contact);
             }
          });
      });
   };

   /* export connect.RingtoneEngine */
   connect.VoiceRingtoneEngine = VoiceRingtoneEngine;
   connect.QueueCallbackRingtoneEngine = QueueCallbackRingtoneEngine;
})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   var RTPJobIntervalMs = 1000;
   var statsReportingJobIntervalMs = 30000;
   var streamBufferSize = 500;
   var CallTypeMap = {};
   CallTypeMap[connect.SoftphoneCallType.AUDIO_ONLY] = 'Audio';
   CallTypeMap[connect.SoftphoneCallType.VIDEO_ONLY] = 'Video';
   CallTypeMap[connect.SoftphoneCallType.AUDIO_VIDEO] = 'AudioVideo';
   CallTypeMap[connect.SoftphoneCallType.NONE] = 'None';
   var AUDIO_INPUT = 'audio_input';
   var AUDIO_OUTPUT = 'audio_output';

   var MediaTypeMap = {};
   MediaTypeMap[connect.ContactType.VOICE] = "Voice";
   var UNKNOWN_MEDIA_TYPE = "Unknown";

   var timeSeriesStreamStatsBuffer = [];
   var aggregatedUserAudioStats = null;
   var aggregatedRemoteAudioStats = null;
   var rtpStatsJob = null;
   var reportStatsJob = null;
   //Logger specific to softphone.
   var logger = null;

   var SoftphoneErrorTypes = connect.SoftphoneErrorTypes;

   var SoftphoneManager = function(softphoneParams) {
      logger = new SoftphoneLogger(connect.getLog());
      if (!isBrowserSoftPhoneSupported()) {
         publishError(SoftphoneErrorTypes.UNSUPPORTED_BROWSER,
                      "Connect does not support this browser. Some functionality may not work. ",
                      "");
      }
      var gumPromise = fetchUserMedia({
         success: function(stream) {
            if (connect.isFirefoxBrowser()) {
                connect.core.setSoftphoneUserMediaStream(stream);
            }
         },
         failure: function(err) {
            publishError(err, "Your microphone is not enabled in your browser. ", "");
         }
      });

      this.ringtoneEngine = null;

      connect.contact(function(contact) {
         var callDetected = false;

         contact.onRefresh(function() {
            if (contact.isSoftphoneCall() && !callDetected && (
                     contact.getStatus().type === connect.ContactStatusType.CONNECTING ||
                     contact.getStatus().type === connect.ContactStatusType.INCOMING)) {

               callDetected = true;
               logger.info("Softphone call detected: ", contact.getContactId());
               initializeParams();
               var softphoneInfo = contact.getAgentConnection().getSoftphoneMediaInfo();
               var callConfig = parseCallConfig(softphoneInfo.callConfigJson);

               var session = new connect.RTCSession(
                     callConfig.signalingEndpoint,
                     callConfig.iceServers,
                     softphoneInfo.callContextToken,
                     logger,
                     contact.getContactId());
               if (connect.core.getSoftphoneUserMediaStream()) {
                    session.mediaStream = connect.core.getSoftphoneUserMediaStream();
               }
               session.onSessionFailed = function(rtcSession, reason) {
                   if (reason === connect.RTCErrors.ICE_COLLECTION_TIMEOUT) {
                        var endPointUrl = "\n";
                        for (var i=0; i < rtcSession._iceServers.length; i++) {
                            for (var j=0; j < rtcSession._iceServers[i].urls.length; j++) {
                                endPointUrl = endPointUrl + rtcSession._iceServers[i].urls[j] + "\n";
                            }
                        }
                        publishError(SoftphoneErrorTypes.ICE_COLLECTION_TIMEOUT, "Ice collection timedout. " ,endPointUrl);
                   } else if (reason === connect.RTCErrors.USER_BUSY) {
                        publishError(SoftphoneErrorTypes.USER_BUSY_ERROR,
                        "Softphone call UserBusy error. ",
                        "");
                   } else if (reason === connect.RTCErrors.SIGNALLING_HANDSHAKE_FAILURE) {
                        publishError(SoftphoneErrorTypes.SIGNALLING_HANDSHAKE_FAILURE,
                        "Handshaking with Signalling Server " + rtcSession._signalingUri + " failed. ",
                        rtcSession._signalingUri);
                   } else if (reason === connect.RTCErrors.GUM_TIMEOUT_FAILURE || reason === connect.RTCErrors.GUM_OTHER_FAILURE) {
                        publishError(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED,
                        "Your microphone is not enabled in your browser. ",
                        "");
                   } else if (reason === connect.RTCErrors.SIGNALLING_CONNECTION_FAILURE) {
                        publishError(SoftphoneErrorTypes.SIGNALLING_CONNECTION_FAILURE,
                        "URL " +  rtcSession._signalingUri + " cannot be reached. ",
                        rtcSession._signalingUri);
                   } else if (reason === connect.RTCErrors.CALL_NOT_FOUND) {
                        //No need to publish any softphone error for this case. CCP UX will handle this case.
                        logger.error("Softphone call failed due to CallNotFoundException.");
                   } else {
                        publishError(SoftphoneErrorTypes.WEBRTC_ERROR,
                        "webrtc system error. ",
                        "");
                   }
                   stopJobsAndReport(contact, rtcSession.sessionReport);
               };
               session.onSessionConnected = function(rtcSession) {
                    //Become master to send logs, since we need logs from softphone tab.
                    connect.becomeMaster(connect.MasterTopics.SEND_LOGS);
                    //start stats collection and reporting jobs
                    startStatsCollectionJob(rtcSession);
                    startStatsReportingJob(contact);
               };

               session.onSessionCompleted = function(rtcSession) {
                    //stop all jobs and perform one last job
                    stopJobsAndReport(contact, rtcSession.sessionReport);
               };
               session.remoteAudioElement = document.getElementById('remote-audio');
               session.connect();
            }
         });
      });
   };

   /** Parse the JSON encoded web call config into the data it represents. */
   var parseCallConfig = function(serializedConfig) {
       // Our underscore is too old for unescape
       // https://issues.amazon.com/issues/CSWF-1467
       var decodedJSON = serializedConfig.replace(/&quot;/g, '"');
       return JSON.parse(decodedJSON);
   };

   var fetchUserMedia = function(callbacksIn) {
      var callbacks = callbacksIn || {};
      callbacks.success = callbacks.success || function() {};
      callbacks.failure = callbacks.failure || function() {};

      var CONSTRAINT = {
         audio: true
      };

      var promise = null;

      if (typeof Promise !== "function") {
         callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);
         return;
      }

      if (typeof navigator.mediaDevices === "object" && typeof navigator.mediaDevices.getUserMedia === "function") {
         promise = navigator.mediaDevices.getUserMedia(CONSTRAINT);

      } else if (typeof navigator.webkitGetUserMedia === "function") {
         promise = new Promise(function(resolve, reject) {
            navigator.webkitGetUserMedia(CONSTRAINT, resolve, reject);
         });

      } else {
         callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);
         return;
      }

      promise.then(function(stream) {
         var audioTracks = stream.getAudioTracks();
         if (audioTracks && audioTracks.length > 0) {
            callbacks.success(stream);
         } else {
            callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);
         }
      }, function(err) {
         callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);
      });
      return promise;
   };

   var publishError = function(errorType, message, endPointUrl) {
      var bus = connect.core.getEventBus();
      logger.error("Softphone error occurred : ", errorType,
            message || "");
      bus.trigger(connect.AgentEvents.SOFTPHONE_ERROR, new connect.SoftphoneError(errorType, message, endPointUrl));
   };

    var isBrowserSoftPhoneSupported = function () {
        // In Opera, the true version is after "Opera" or after "Version"
        if (connect.isOperaBrowser() && connect.getOperaBrowserVersion() > 17) {
            return true;
        }
        // In Chrome, the true version is after "Chrome"
        else if (connect.isChromeBrowser() && connect.getChromeBrowserVersion() > 22) {
            return true;
        }
        // In Firefox, the true version is after "Firefox"
        else if (connect.isFirefoxBrowser() && connect.getFirefoxBrowserVersion() > 21) {
            return true;
        } else {
            return false;
        }
    };

    var sendSoftphoneMetrics = function(contact) {
        var streamStats = timeSeriesStreamStatsBuffer.slice();
        timeSeriesStreamStatsBuffer = [];
        if (streamStats.length > 0) {
            contact.sendSoftphoneMetrics(streamStats, {
               success: function(){
                   logger.info("sendSoftphoneMetrics success");
               },
               failure: function(data){
                   logger.error("sendSoftphoneMetrics failed.")
                      .withObject(data);
               }
            });
        }
    };

    var sendSoftphoneReport = function(contact, report, userAudioStats, remoteAudioStats) {
        report.streamStats = [ addStreamTypeToStats(userAudioStats || {}, AUDIO_INPUT),
                                addStreamTypeToStats(remoteAudioStats || {}, AUDIO_OUTPUT) ];
        var callReport = {
                        callStartTime: report.sessionStartTime,
                        callEndTime: report.sessionEndTime,
                        gumTimeMillis: report.gumTimeMillis,
                        initializationTimeMillis: report.initializationTimeMillis,
                        iceCollectionTimeMillis: report.iceCollectionTimeMillis,
                        signallingConnectTimeMillis: report.signallingConnectTimeMillis,
                        handshakingTimeMillis: report.handshakingTimeMillis,
                        preTalkingTimeMillis: report.preTalkingTimeMillis,
                        talkingTimeMillis: report.talkingTimeMillis,
                        cleanupTimeMillis: report.cleanupTimeMillis,
                        iceCollectionFailure: report.iceCollectionFailure,
                        signallingConnectionFailure: report.signallingConnectionFailure,
                        handshakingFailure: report.handshakingFailure,
                        gumOtherFailure: report.gumOtherFailure,
                        gumTimeoutFailure: report.gumTimeoutFailure,
                        createOfferFailure: report.createOfferFailure,
                        setLocalDescriptionFailure: report.setLocalDescriptionFailure,
                        userBusyFailure: report.userBusyFailure,
                        invalidRemoteSDPFailure: report.invalidRemoteSDPFailure,
                        noRemoteIceCandidateFailure: report.noRemoteIceCandidateFailure,
                        setRemoteDescriptionFailure: report.setRemoteDescriptionFailure,
                        softphoneStreamStatistics: report.streamStats
                      };
        contact.sendSoftphoneReport(callReport, {
            success: function(){
                logger.info("sendSoftphoneReport success");
            },
            failure: function(data){
                logger.error("sendSoftphoneReport failed.")
                    .withObject(data);
            }
        });
    };

    var startStatsCollectionJob = function(rtcSession) {
        rtpStatsJob = window.setInterval(function() {
            rtcSession.getUserAudioStats().then(function(stats) {
                var previousUserStats = aggregatedUserAudioStats;
                aggregatedUserAudioStats = stats;
                timeSeriesStreamStatsBuffer.push(getTimeSeriesStats(aggregatedUserAudioStats, previousUserStats, AUDIO_INPUT));
            }, function(error) {
                logger.debug("Failed to get user audio stats.", error);
            });
            rtcSession.getRemoteAudioStats().then(function(stats) {
                var previousRemoteStats = aggregatedRemoteAudioStats;
                aggregatedRemoteAudioStats = stats;
                timeSeriesStreamStatsBuffer.push(getTimeSeriesStats(aggregatedRemoteAudioStats, previousRemoteStats, AUDIO_OUTPUT));
            }, function(error) {
                logger.debug("Failed to get remote audio stats.", error);
            });
        }, 1000);
    };

    var startStatsReportingJob = function(contact) {
        reportStatsJob = window.setInterval(function() {
                           sendSoftphoneMetrics(contact);
        }, statsReportingJobIntervalMs);
    };

    var initializeParams = function() {
        aggregatedUserAudioStats = null;
        aggregatedRemoteAudioStats = null;
        timeSeriesStreamStatsBuffer = [];
        rtpStatsJob = null;
        reportStatsJob = null;
    };

    var getTimeSeriesStats = function(currentStats, previousStats, streamType) {
        if (previousStats && currentStats) {
            var packetsLost = currentStats.packetsLost > previousStats.packetsLost ? currentStats.packetsLost - previousStats.packetsLost : 0;
            var packetsCount = currentStats.packetsCount > previousStats.packetsCount ? currentStats.packetsCount - previousStats.packetsCount : 0;
            return new RTPStreamStats(currentStats.timestamp,
                                      packetsLost,
                                      packetsCount,
                                      streamType,
                                      currentStats.audioLevel,
                                      currentStats.jbMilliseconds,
                                      currentStats.rttMilliseconds);
        } else {
            return new RTPStreamStats(currentStats.timestamp,
                                      currentStats.packetsLost,
                                      currentStats.packetsCount,
                                      streamType,
                                      currentStats.audioLevel,
                                      currentStats.jbMilliseconds,
                                      currentStats.rttMilliseconds);
        }
    };

    var stopJob = function(task) {
        if (task !== null){
            window.clearInterval(task);
        }
        return null;
    };

    var stopJobsAndReport = function(contact, sessionReport) {
       rtpStatsJob = stopJob(rtpStatsJob);
       reportStatsJob = stopJob(reportStatsJob);
       sendSoftphoneReport(contact, sessionReport, addStreamTypeToStats(aggregatedUserAudioStats, AUDIO_INPUT), addStreamTypeToStats(aggregatedRemoteAudioStats, AUDIO_OUTPUT));
       sendSoftphoneMetrics(contact);
    };

    /**
    *   Adding streamtype parameter on top of RTCJS RTStats object.
    */
    var RTPStreamStats = function(timestamp, packetsLost, packetsCount, streamType, audioLevel, jitterBufferMillis, roundTripTimeMillis) {
        this.softphoneStreamType = streamType;
        this.timestamp = timestamp;
        this.packetsLost = packetsLost;
        this.packetsCount = packetsCount;
        this.audioLevel = audioLevel;
        this.jitterBufferMillis = jitterBufferMillis;
        this.roundTripTimeMillis = roundTripTimeMillis;
    };

    var addStreamTypeToStats = function(stats, streamType) {
        return new RTPStreamStats(stats.timestamp, stats.packetsLost, stats.packetsCount, streamType, stats.audioLevel);
    };

    var SoftphoneLogger = function(logger) {
        this._originalLogger = logger;
        var self = this;
        this._tee = function(level, method) {
            return function() {
                // call the original logger object to output to browser
                //Connect logger follows %s format to print objects to console.
                var args = Array.prototype.slice.call(arguments[0]);
                var format = "";
                args.forEach(function(){
                    format = format + " %s";
                });
                method.apply(self._originalLogger, [connect.LogComponent.SOFTPHONE, format].concat(args));
            };
        };
    };

    SoftphoneLogger.prototype.debug =  function() {
        this._tee(1, this._originalLogger.debug)(arguments);
    };
    SoftphoneLogger.prototype.info =  function() {
        this._tee(2, this._originalLogger.info)(arguments);
    };
    SoftphoneLogger.prototype.log =  function() {
        this._tee(3, this._originalLogger.log)(arguments);
    };
    SoftphoneLogger.prototype.warn =  function() {
        this._tee(4, this._originalLogger.warn)(arguments);
    };
    SoftphoneLogger.prototype.error =  function() {
        this._tee(5, this._originalLogger.error)(arguments);
    };

    connect.SoftphoneManager = SoftphoneManager;
})();
/*
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *    http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
(function() {
   var global = this;
   connect = global.connect || {};
   global.connect = connect;
   global.lily = connect;

   connect.worker = {};

   var GET_AGENT_TIMEOUT = 30000;
   var GET_AGENT_RECOVERY_TIMEOUT = 5000;
   var GET_AGENT_SUCCESS_TIMEOUT = 100;
   var LOG_BUFFER_CAP_SIZE = 400;

   var GET_AGENT_CONFIGURATION_INTERVAL = 30000;      // 30sec

   /**-----------------------------------------------------------------------*/
   var MasterTopicCoordinator = function() {
      this.topicMasterMap = {};
   };

   MasterTopicCoordinator.prototype.getMaster = function(topic) {
      connect.assertNotNull(topic, 'topic');
      return this.topicMasterMap[topic] || null;
   };

   MasterTopicCoordinator.prototype.setMaster = function(topic, id) {
      connect.assertNotNull(topic, 'topic');
      connect.assertNotNull(id, 'id');
      this.topicMasterMap[topic] = id;
   };

   MasterTopicCoordinator.prototype.removeMaster = function(id) {
      connect.assertNotNull(id, 'id');
      var self = this;

      connect.entries(this.topicMasterMap).filter(function(entry) {
         return entry.value === id;
      }).forEach(function(entry) {
         delete self.topicMasterMap[entry.key];
      });
   };

   /**-------------------------------------------------------------------------
    * The object responsible for polling and passing data downstream to all
    * consumer ports.
    */
   var ClientEngine = function() {
      var self = this;

      this.client = null;
      this.multiplexer = new connect.StreamMultiplexer();
      this.conduit = new connect.Conduit("AmazonConnectSharedWorker", null, this.multiplexer);
      this.timeout = null;
      this.agent = null;
      this.nextToken = null;
      this.initData = {};
      this.portConduitMap = {};
      this.masterCoord = new MasterTopicCoordinator();
      this.logsBuffer = [];

      connect.rootLogger = new connect.DownstreamConduitLogger(this.conduit);

      this.conduit.onDownstream(connect.EventType.SEND_LOGS, function(logsToUpload) {
         self.logsBuffer = self.logsBuffer.concat(logsToUpload);
         //only call API to send logs if buffer reached cap
         if (self.logsBuffer.length > LOG_BUFFER_CAP_SIZE) {
            self.handleSendLogsRequest(self.logsBuffer);
         }
      });
      this.conduit.onDownstream(connect.EventType.CONFIGURE, function(data) {
         if (data.authToken && data.authToken !== self.initData.authToken) {
            self.initData = data;
            connect.core.init(data);

            // Start polling for agent data.
            self.pollForAgent();
            self.pollForAgentConfiguration({repeatForever: true});
         }
      });
      this.conduit.onDownstream(connect.EventType.TERMINATE, function() {
         //upload pending logs before terminating.
         self.handleSendLogsRequest(self.logsBuffer);
         connect.core.terminate();
         self.conduit.sendDownstream(connect.EventType.TERMINATED);
      });
      this.conduit.onDownstream(connect.EventType.SYNCHRONIZE, function() {
         self.conduit.sendDownstream(connect.EventType.ACKNOWLEDGE);
      });
      this.conduit.onDownstream(connect.EventType.BROADCAST, function(data) {
         self.conduit.sendDownstream(data.event, data.data);
      });

      /**
       * Called when a consumer port connects to this SharedWorker.
       * Let's add them to our multiplexer.
       */
      global.onconnect = function(event) {
         var port = event.ports[0];
         var stream = new connect.PortStream(port);
         self.multiplexer.addStream(stream);
         port.start();

         var portConduit = new connect.Conduit(stream.getId(), null, stream);
         portConduit.sendDownstream(connect.EventType.ACKNOWLEDGE, {id: stream.getId()});

         self.portConduitMap[stream.getId()] = portConduit;

         if (self.agent !== null) {
            portConduit.sendDownstream(connect.AgentEvents.UPDATE, self.agent);
         }

         portConduit.onDownstream(connect.EventType.API_REQUEST,
               connect.hitch(self, self.handleAPIRequest, portConduit));
         portConduit.onDownstream(connect.EventType.MASTER_REQUEST,
               connect.hitch(self, self.handleMasterRequest, portConduit, stream.getId()));
         portConduit.onDownstream(connect.EventType.RELOAD_AGENT_CONFIGURATION,
               connect.hitch(self, self.pollForAgentConfiguration));
         portConduit.onDownstream(connect.EventType.CLOSE, function() {
            self.multiplexer.removeStream(stream);
            delete self.portConduitMap[stream.getId()];
            self.masterCoord.removeMaster(stream.getId());
         });
      };
   };

   ClientEngine.prototype.pollForAgent = function() {
      var self = this;
      var client = connect.core.getClient();

      this.checkAuthToken();

      client.call(connect.ClientMethods.GET_AGENT_SNAPSHOT, {
         nextToken:     self.nextToken,
         timeout:       GET_AGENT_TIMEOUT
      }, {
         success: function(data) {
            self.agent = self.agent || {};
            self.agent.snapshot = data.snapshot;
            self.agent.snapshot.localTimestamp = connect.now();
            self.agent.snapshot.skew = self.agent.snapshot.snapshotTimestamp - self.agent.snapshot.localTimestamp;
            self.nextToken = data.nextToken;
            self.updateAgent();
            global.setTimeout(connect.hitch(self, self.pollForAgent), GET_AGENT_SUCCESS_TIMEOUT);
         },
         failure: function(err, data) {
            try {
               connect.getLog().error("Failed to get agent data.")
                  .withObject({
                     err: err,
                     data: data
                  });

            } finally {
               global.setTimeout(connect.hitch(self, self.pollForAgent), GET_AGENT_RECOVERY_TIMEOUT);
            }
         },
         authFailure: connect.hitch(self, self.handleAuthFail)
      });

   };

   ClientEngine.prototype.pollForAgentConfiguration = function(paramsIn) {
      var self = this;
      var client = connect.core.getClient();
      var params = paramsIn || {};

      client.call(connect.ClientMethods.GET_AGENT_CONFIGURATION, {}, {
         success: function(data) {
            var configuration = data.configuration;
            self.pollForAgentPermissions(configuration);
            self.pollForAgentStates(configuration);
            self.pollForDialableCountryCodes(configuration);
            self.pollForRoutingProfileQueues(configuration);
            if (params.repeatForever) {
               global.setTimeout(connect.hitch(self, self.pollForAgentConfiguration, params),
                  GET_AGENT_CONFIGURATION_INTERVAL);
            }
         },
         failure: function(err, data) {
            try {
               connect.getLog().error("Failed to fetch agent configuration data.")
                  .withObject({
                     err: err,
                     data: data
                  });
            } finally {
               if (params.repeatForever) {
                  global.setTimeout(connect.hitch(self, self.pollForAgentConfiguration),
                     GET_AGENT_CONFIGURATION_INTERVAL, params);
               }
            }
         },
         authFailure: connect.hitch(self, self.handleAuthFail)
      });
   };

   ClientEngine.prototype.pollForAgentStates = function(configuration, paramsIn) {
      var self = this;
      var client = connect.core.getClient();
      var params = paramsIn || {};
      params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;

      client.call(connect.ClientMethods.GET_AGENT_STATES, {
         nextToken: params.nextToken || null,
         maxResults: params.maxResults

      }, {
         success: function(data) {
            if (data.nextToken) {
               self.pollForAgentStates(configuration, {
                  states:   (params.states || []).concat(data.states),
                  nextToken:     data.nextToken,
                  maxResults:    params.maxResults
               });

            } else {
               configuration.agentStates = (params.states || []).concat(data.states);
               self.updateAgentConfiguration(configuration);
            }
         },
         failure: function(err, data) {
            connect.getLog().error("Failed to fetch agent states list.")
               .withObject({
                  err: err,
                  data: data
               });
         },
         authFailure: connect.hitch(self, self.handleAuthFail)
      });
   };

   ClientEngine.prototype.pollForAgentPermissions = function(configuration, paramsIn) {
      var self = this;
      var client = connect.core.getClient();
      var params = paramsIn || {};
      params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;

      client.call(connect.ClientMethods.GET_AGENT_PERMISSIONS, {
         nextToken: params.nextToken || null,
         maxResults: params.maxResults

      }, {
         success: function(data) {
            if (data.nextToken) {
               self.pollForAgentPermissions(configuration, {
                  permissions:   (params.permissions || []).concat(data.permissions),
                  nextToken:     data.nextToken,
                  maxResults:    params.maxResults
               });

            } else {
               configuration.permissions = (params.permissions || []).concat(data.permissions);
               self.updateAgentConfiguration(configuration);
            }
         },
         failure: function(err, data) {
            connect.getLog().error("Failed to fetch agent permissions list.")
               .withObject({
                  err: err,
                  data: data
               });
         },
         authFailure: connect.hitch(self, self.handleAuthFail)
      });
   };

   ClientEngine.prototype.pollForDialableCountryCodes = function(configuration, paramsIn) {
      var self = this;
      var client = connect.core.getClient();
      var params = paramsIn || {};
      params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;

      client.call(connect.ClientMethods.GET_DIALABLE_COUNTRY_CODES, {
         nextToken: params.nextToken || null,
         maxResults: params.maxResults
      }, {
         success: function(data) {
            if (data.nextToken) {
               self.pollForDialableCountryCodes(configuration, {
                  countryCodes:  (params.countryCodes || []).concat(data.countryCodes),
                  nextToken:     data.nextToken,
                  maxResults:    params.maxResults
               });

            } else {
               configuration.dialableCountries = (params.countryCodes || []).concat(data.countryCodes);
               self.updateAgentConfiguration(configuration);
            }
         },
         failure: function(err, data) {
            connect.getLog().error("Failed to fetch dialable country codes list.")
               .withObject({
                  err: err,
                  data: data
               });
         },
         authFailure: connect.hitch(self, self.handleAuthFail)
      });
   };

   ClientEngine.prototype.pollForRoutingProfileQueues = function(configuration, paramsIn) {
      var self = this;
      var client = connect.core.getClient();
      var params = paramsIn || {};
      params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;

      client.call(connect.ClientMethods.GET_ROUTING_PROFILE_QUEUES, {
         routingProfileARN: configuration.routingProfile.routingProfileARN,
         nextToken: params.nextToken || null,
         maxResults: params.maxResults
      }, {
         success: function(data) {
            if (data.nextToken) {
               self.pollForRoutingProfileQueues(configuration, {
                  countryCodes:  (params.queues || []).concat(data.queues),
                  nextToken:     data.nextToken,
                  maxResults:    params.maxResults
               });

            } else {
               configuration.routingProfile.queues = (params.queues || []).concat(data.queues);
               self.updateAgentConfiguration(configuration);
            }
         },
         failure: function(err, data) {
            connect.getLog().error("Failed to fetch routing profile queues list.")
               .withObject({
                  err: err,
                  data: data
               });
         },
         authFailure: connect.hitch(self, self.handleAuthFail)
      });
   };

   ClientEngine.prototype.handleAPIRequest = function(portConduit, request) {
      var self = this;
      var client = connect.core.getClient();
      client.call(request.method, request.params, {
         success: function(data) {
            var response = connect.EventFactory.createResponse(connect.EventType.API_RESPONSE, request, data);
            portConduit.sendDownstream(response.event, response);
         },
         failure: function(err, data) {
            var response = connect.EventFactory.createResponse(connect.EventType.API_RESPONSE, request, data, JSON.stringify(err));
            portConduit.sendDownstream(response.event, response);
            connect.getLog().error("'%s' API request failed: %s", request.method, err)
               .withObject({request: request, response: response});
         },
         authFailure: connect.hitch(self, self.handleAuthFail)
      });
   };

   /**
    * Handle incoming master query or modification requests from connected tab ports.
    */
   ClientEngine.prototype.handleMasterRequest = function(portConduit, portId, request) {
      var response = null;

      switch(request.method) {
      case connect.MasterMethods.BECOME_MASTER:
         this.masterCoord.setMaster(request.params.topic, portId);
         response = connect.EventFactory.createResponse(connect.EventType.MASTER_RESPONSE, request, {
            masterId:   portId,
            isMaster:   true,
            topic:      request.params.topic
         });

         break;

      case connect.MasterMethods.CHECK_MASTER:
         var masterId = this.masterCoord.getMaster(request.params.topic);
         if (!masterId) {
            this.masterCoord.setMaster(request.params.topic, portId);
            masterId = portId;
         }

         response = connect.EventFactory.createResponse(connect.EventType.MASTER_RESPONSE, request, {
            masterId:   masterId,
            isMaster:   portId === masterId,
            topic:      request.params.topic
         });

         break;

      default:
         throw new Error("Unknown master method: " + request.method);
      }

      portConduit.sendDownstream(response.event, response);
   };

   ClientEngine.prototype.updateAgentConfiguration = function(configuration) {
      if (configuration.permissions &&
          configuration.dialableCountries &&
          configuration.agentStates &&
          configuration.routingProfile.queues) {

         this.agent = this.agent || {};
         this.agent.configuration = configuration;
         this.updateAgent();

      } else {
         connect.getLog().trace("Waiting to update agent configuration until all config data has been fetched.");
      }
   };

   ClientEngine.prototype.updateAgent = function() {
      if (! this.agent) {
         connect.getLog().trace("Waiting to update agent until the agent has been fully constructed.");

      } else if (! this.agent.snapshot) {
         connect.getLog().trace("Waiting to update agent until the agent snapshot is available.");

      } else if (! this.agent.configuration) {
         connect.getLog().trace("Waiting to update agent until the agent configuration is available.");

      } else {
         // Alias some of the properties for backwards compatibility.
         this.agent.snapshot.status = this.agent.state;
         this.agent.snapshot.contacts.forEach(function(contact) {
            contact.status = contact.state;

            contact.connections.forEach(function(connection) {
               connection.address = connection.endpoint;
            });
         });

         this.agent.configuration.routingProfile.defaultOutboundQueue.queueId =
            this.agent.configuration.routingProfile.defaultOutboundQueue.queueARN;
         this.agent.configuration.routingProfile.queues.forEach(function(queue) {
            queue.queueId = queue.queueARN;
         });
         this.agent.snapshot.contacts.forEach(function(contact) {
            //contact.queue is null when monitoring
            if (contact.queue !== undefined) {
                contact.queue.queueId = contact.queue.queueARN;
            }
         });
         this.agent.configuration.routingProfile.routingProfileId =
            this.agent.configuration.routingProfile.routingProfileARN;

         this.conduit.sendDownstream(connect.AgentEvents.UPDATE, this.agent);
      }
   };

   /**
    * Send a message downstream to all consumers when we detect that authentication
    * against one of our APIs has failed.
    */
   ClientEngine.prototype.handleSendLogsRequest = function() {
      var self = this;
      var client = connect.core.getClient();
      var logEvents = [];
      var logsToSend = self.logsBuffer.slice();
      self.logsBuffer = [];
      logsToSend.forEach(function(log) {
         logEvents.push({
            timestamp:  log.time,
            component:  log.component,
            message: log.text
         });
      });
      client.call(connect.ClientMethods.SEND_CLIENT_LOGS, {logEvents: logEvents}, {
         success: function(data) {
            connect.getLog().info("SendLogs request succeeded.");
         },
         failure: function(err, data) {
            connect.getLog().error("SendLogs request failed. %s", err);
         },
         authFailure: connect.hitch(self, self.handleAuthFail)
      });
   };

   ClientEngine.prototype.handleAuthFail = function() {
      var self = this;
      self.conduit.sendDownstream(connect.EventType.AUTH_FAIL);
   };

   ClientEngine.prototype.checkAuthToken = function() {
      var self = this;
      var expirationDate = new Date(self.initData.authTokenExpiration);
      var currentTimeStamp = new Date().getTime();
      var fiveMins = 5 * 60 * 1000;

      // refresh token 5 minutes before expiration
      if (expirationDate.getTime() < (currentTimeStamp + fiveMins)) {
        this.refreshAuthToken();
      }
   };

   ClientEngine.prototype.refreshAuthToken = function() {
      var self = this;
      connect.assertNotNull(self.initData.refreshToken, 'initData.refreshToken');

      var client = connect.core.getClient();
      client.call(connect.ClientMethods.GET_NEW_AUTH_TOKEN, {refreshToken: self.initData.refreshToken}, {
         success: function(data) {
            connect.getLog().info("Get new auth token succeeded. New auth token expired at %s", data.expirationDateTime);
            self.initData.authToken = data.newAuthToken;
            self.initData.authTokenExpiration = new Date(data.expirationDateTime);
            connect.core.init(self.initData);
         },
         failure: function(err, data) {
            connect.getLog().error("Get new auth token failed. %s ", err);
            self.conduit.sendDownstream(connect.EventType.AUTH_FAIL);
         },
         authFailure: connect.hitch(self, self.handleAuthFail)
      });
   };

   /**-----------------------------------------------------------------------*/
   connect.worker.main = function() {
      connect.worker.clientEngine = new ClientEngine();
   };

})();
//static-content-hash-trigger-GCC
/*
@public - Prototype definition for pega.cti.embeddedApi
*/
pega.cti.embeddedApi = function() {
  
};


/*
@public - Error object definition supported by Pega Call
*/
pega.cti.embeddedApi.errorObject = function() {
    var errCode = null;
    var errMessage = null;
}


pega.cti.embeddedApi.prototype = {
  
 /*
@api - load object from link definition
@param $String$linkDefinition - link definition to load javascript Object
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object

*/
	load: function ( linkDefinition, success,failure ) {
	
	},


/*
@api - Place a new call
@param $String$destination – The digits to dial
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	makeCall:function (destination, options,success,failure)  {

	},
  
  /*
@api - Answer a ringing call
@param $String$callId – The callId of the call answer
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	answerCall: function (callId, options,success, failure) {
    
  },
  
  
  /*
@api – to set Transfer Context
@param $String$ callId – Update contact with callId
@param $String$ comment – Update contact with comment
@param $String$ reason – Update contact with reason
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
  
setTransferContext:function (callId, comment, reason, success, failure)  {
	// Set Transfer Context
},
  

 /*
@api - unload object from link definition
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object

*/
	unload: function (success,failure ) {
	
	}
	
}
//static-content-hash-trigger-YUI
/****************************************************************************************
 *
 * Communicate with embedded AWS Connect client.
 *
 ****************************************************************************************/


/*
@public - Prototype definition for pega.cti.embeddedApi.AWSConnect
*/

function showhtml(str)
{
   if (str.indexOf("<html") > -1){
                        var myWindow = window.open('','','width=700,height=600');
                             var doc = myWindow.document;
                             doc.open();
                             doc.write(str); 
                             return true;
          } 
  else{
      return false;
      }
}

pega.cti.embeddedApi.AWSConnect = function () {
	this.eventCallback = null;
	this.linkDefinition = null;
	this.theAgent = null;
	this.theContact = null;
  this.initFlag =true;
  this.loginWindow = null;
  this.interactionID= null;
  this.callingNumber = null;
  this.allowFramedSoftphone = true;
}


pega.cti.embeddedApi.AWSConnect.prototype = {

	/*
	@api - Log agent into the ACD.
	@Param $String$linkDefinition - The CTILink definition as configured
	@param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
	*/
	load: function (linkDefinition,options, onSuccess, onFailure) {
    _this = this;
		this.linkDefinition = linkDefinition;
     var allowFramedSoftphone = this.getValueFromLinkDefinition("AllowFramedSoftphone");
    if (allowFramedSoftphone != null)
      if(allowFramedSoftphone.toUpperCase()  == "FALSE" )
         this.allowFramedSoftphone = false;
   
    if (options != null || typeof options != undefined)
        if ( options.MedialessCCP.toUpperCase()  == "TRUE")
             this.allowFramedSoftphone = false;
    
		var url = linkDefinition.contactCenterInstanceURL;
    
    if(-1 == url.indexOf("ccp")){
       url += "/ccp#";
    }
		var ccp = document.getElementById('EmbeddedCCP');
		if (ccp) {

			_this.loadMe(url, onSuccess, onFailure);
		} else {
			setTimeout(function () {
				_this.loadMe(url, onSuccess, onFailure);
			}, 5000);
		}

	},

      //returns property value from custom property list for mapping property name
  getValueFromLinkDefinition: function(property) {
    var value = null;
     if(value == null && this.linkDefinition.CustomProperties != null && this.linkDefinition.CustomProperties != undefined){
    for (var k = 0; k < this.linkDefinition.CustomProperties.length; k++) {
      if (this.linkDefinition.CustomProperties[k].pyPropertyName.toUpperCase() == property.toUpperCase()) 
        value = this.linkDefinition.CustomProperties[k].pyPropertyValue;
    }
    }
    return value;
  },
	/*
@api - Place a new call
@param $String$destination – The digits to dial
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	makeCall: function (destination, options, onSuccess, onFailure) {
		var endpoint = connect.Endpoint.byPhoneNumber(destination);
    
    this.callingNumber = destination;
    if (options != null || options != undefined )
    if (options.pyCallVariables != undefined)
        if(options.pyCallVariables.length > 0)
          for (var i =0 ; i<options.pyCallVariables.length;i++ )
            if (options.pyCallVariables[i].pyKey == "userCPMInteractionID")
            this.interactionID = options.pyCallVariables[i].pyValue;
    
    
		pega.cti.API.theAgent.connect(endpoint, {
			queueARN: pega.cti.API.theAgent.getConfiguration().routingProfile.defaultOutboundQueue.queueARN,
			success: function () {
				console.log('makeCall SUCCESS');
				onSuccess();
			},
			failure: function (err, data) {
        pega.cti.API.callingNumber = null;
       showhtml(err);
				var errObj = JSON.parse(err);
				console.log("Failed to make call : " + errObj.message);
				onFailure({
					errCode: "ERR_PASS",
					errMessage: errObj.message
				});
			}
		});
	},

	/*
@api - Answer a ringing call
@param $String$callId – The callId of the call answer
@param $String$options – String format of JSON object of optional Parameters
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
	answerCall: function (callId, options, onSuccess, onFailure) {

		if (pega.cti.API.theContact) {
			pega.cti.API.theContact.accept({
				success: function () {
					console.log("answered call " + callId);
				},
				failure: function (err, data) {
          showhtml(err);
					var errObj = JSON.parse(err);
					console.log("Failed to answer call : " + errObj.message);
					onFailure({
						errCode: "ERR_PASS",
						errMessage: errObj.message
					});
				}
			});
		} else
			onFailure({
				errCode: "ERR_PASS",
				errMessage: "Unable to locate contact for ringing call"
			});
	},
  
  /*
@api – to set Transfer Context
@param $String$ callId – Update contact with callId
@param $String$ comment – Update contact with comment
@param $String$ reason – Update contact with reason
@param $Function$success – Callback function for success with message object
@param $Function$failure – Callback function for failure with message object
*/
  setTransferContext:function (callId, comment, reason, appInteractionID, success, failure)  {
    
      var originalContactId = pega.cti.API.theContact.getOriginalContactId();
      var contactId = pega.cti.API.theContact.getContactId();
        if(null == originalContactId){
          originalContactId = contactId
        }
        if (originalContactId == null)
          return;
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
         postData.put("RequestType", "EmbeddedPreTransferSetup");
         postData.put("ActivityClass","ChannelServices-Device-Phone-UI");
        postData.put("pzPrimaryPageName", "CTIPhone");
        postData.put("TransferReason", reason);
        postData.put("TransferComment", comment);
        if(typeof  appInteractionID !='undefined'){
        postData.put("AppInteractionID", appInteractionID);
        }
        postData.put("TransferType", "TransferInitiate");
        postData.put("CallId", String(originalContactId));
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {
                var request = oResponse;
                if (request.status === 200) {
                    var response = request.responseText;
                } else {
                    sendError("HTTP Error: " + request.statusText); // Check if it exists or not
                }
            },
            failure: function(oResponse) {
                sendError("HTTP Error: " + oResponse.statusText); // Check if it exists or not
            },
            scope: this
        }, postData);
  
},
 
	/*
	@api - unload object from link definition
	@param $Function$success – Callback function for success with message object
	@param $Function$failure – Callback function for failure with message object
	*/
	unload: function (onSuccess, onFailure) {
		var width = 500;
		var height = 600;
		var left = (screen.width / 2) - (width / 2);
		var top = (screen.height / 2) - (height / 2);

		var logoutWindow = window.open(this.ccpUrl + "/logout", true, "width=" + width + ",height=" + height + ",menubar=no,status=no,toolbar=no,left=" + left + ",top=" + top);
		logoutWindow.close();
		onSuccess();
	},

	handleRoutable: function (agent) {
    pega.cti.embeddedEventHandler.enableClickToCall();
	},

	handleNotRoutable: function (agent) {
     // do Nothing
	},

	handleOffline: function (agent) {
    pega.cti.embeddedEventHandler.enableClickToCall();
	},

	handleAfterCallWork: function (agent) {
    pega.cti.embeddedEventHandler.enableClickToCall();
  },
	handleAgentRefresh: function (agent) {
    if(null != agent && agent.getState() != null && (agent.getState().name == "CallingCustomer" || agent.getState().name == "PendingBusy")){
      pega.cti.embeddedEventHandler.disableClickToCall();
    }
	},
	handleIncoming: function (contact) {
    //do Nothing
	},
	handleEnded: function (contact) {
    pega.cti.embeddedEventHandler.enableClickToCall();
    var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = contact.getContactId();
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Disconnected";
    event.pyEventString = "Disconnected";
    try{
    event.pyQueue = contact.getQueue().name;
    event.pyOtherDN = contact.getActiveInitialConnection().getAddress().phoneNumber;
    event.pyANI = event.pyOtherDN;
    }catch(e){}
    event.pyCallType = "INBOUND";
		if (!contact.isInbound())
			event.pyCallType = "OUTBOUND";
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
	},
	handleConnected: function (contact) {
   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = contact.getContactId();
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Connected";
    event.pyEventString = "Connected";
    try{
    event.pyQueue = contact.getQueue().name;
    event.pyOtherDN = contact.getActiveInitialConnection().getAddress().phoneNumber;
    event.pyANI = event.pyOtherDN;
    }catch(e){}
    event.pyCallType = "INBOUND";
		if (!contact.isInbound())
			event.pyCallType = "OUTBOUND";
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
	},
	handleAccepted: function (contact) {
    //do Nothing
	},
	handleContactRefresh: function (contact) {
		  var conn = contact.getAgentConnection();
      console.log ("Connection State=" + conn.getStatus().type);
    
      if(conn.isOnHold())
            pega.cti.API.handleHeldEvent(contact);
      else if(conn.isConnected() && contact.getStatus().type.toUpperCase() !== "ENDED" )
            pega.cti.API.handleConnected(contact);            
	},
  handleAlerting : function (contact){
   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = contact.pyCallId;
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Offering";
    event.pyEventString = "Offering";
    try{
    event.pyQueue = contact.getQueue().name;
    event.pyOtherDN = contact.getActiveInitialConnection().getAddress().phoneNumber;
    event.pyANI = event.pyOtherDN;
     }catch(e){}
    event.pyCallType = "INBOUND";
		if (!contact.isInbound())
			event.pyCallType = "OUTBOUND";
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));    
  },
  
	handleAlertingEvent: function (oEvent) {
    pega.cti.embeddedEventHandler.applyCallTreatment(oEvent);
	},
  
  

  handleInitiatedEvent: function (oEvent) {
    pega.cti.API.associateCallToInteractionn(oEvent);
	},
  handleHeldEvent : function(contact) {

   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = contact.getContactId();
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Held";
    event.pyEventString = "Held";
    try{
    event.pyQueue = contact.getQueue().name;
    event.pyOtherDN = contact.getActiveInitialConnection().getAddress().phoneNumber;
    event.pyANI = event.pyOtherDN;
    }catch(e){}
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
  },
  
	newContact: function (contact) {
    console.log("Handle New Contact Event : " + JSON.stringify(contact));
    pega.cti.API.handleAlerting(contact);
		var otherConn = contact.getActiveInitialConnection();
		if (otherConn.getStatus().type === connect.ConnectionStateType.DISCONNECTED) return;
		if (contact.getAgentConnection().getStatus().type === connect.ConnectionStateType.DISCONNECTED) return;
		var event = {};
		//event.pyCallId = contact.getContactId();
		event.pyInteractionID = event.pyCallId;
		event.pyMedia = "Phone";
		event.pyEventName = contact.isInbound() ? "Alerting" : "Initiated";
		event.pyEventString = contact.isInbound() ? "Offering" : "Initiated";
		event.pyOtherDN = normalizeDN(otherConn.getAddress().phoneNumber);
		event.pyANI = event.pyOtherDN;
		event.pyCallType = "INBOUND";
		if (!contact.isInbound())
			event.pyCallType = "OUTBOUND";
		var queue = contact.getQueue();
		event.pyQueue = contact.getQueue().name;
		event.pyQueueARN = contact.getQueue().ARN;
		event.pyNamedVariables = {};
		var attributes = contact.getAttributes();
		AWS.util.each(attributes, function (key, value) {
			if(/^\d/.test(key) || key.includes("-")){
        var tempkey = "VAR_"+key.replace(/\s+/g, '').replace(/[\[\]&\/\\#, +()$~%.'":*?<>{}]/g, '_').replace(/-/g,'_');
        event.pyNamedVariables[tempkey] = value.value;
      }else{
			  event.pyNamedVariables[key] = value.value;
      }
			if (key.toUpperCase() === "CALLTYPE")
				event.pyCallType = value.value;
		})

      var originalContactId = pega.cti.API.theContact.getOriginalContactId();
      var contactId = pega.cti.API.theContact.getContactId();
      if(null == originalContactId){
          originalContactId = contactId
      }
      event.pyCallId = originalContactId;
    
		// For now limit pops to Inbound && !contact.isConnected()
		if (contact.isInbound() && !contact.isConnected()){
      event.pyEventName = "Offering";
     // var originalContactId = contact.getOriginalContactId();
      if(null != originalContactId){
            pega.cti.API.getCallObject(originalContactId, function(data){
              
            if(typeof data !== "undefined") {
              event.pyNamedVariables["userCPMInteractionID"] = data;
              event.pyNamedVariables["userOldCallId"] = originalContactId;
              event.pyCallType = "CONSULT"; 
              event.pyEventType = "CallInfoEvent";
              pega.cti.API.handleAlertingEvent(JSON.stringify(event));
            }else{
              pega.cti.API.handleAlertingEvent(JSON.stringify(event));
              }
          });
      }else{
           pega.cti.API.handleAlertingEvent(JSON.stringify(event));
      }
    }else if (event.pyCallType == "OUTBOUND"&& !contact.isConnected()){
      if (this.interactionID != null && this.callingNumber != null && event.pyOtherDN != null )
        {
          if ( event.pyOtherDN.includes(this.callingNumber))
          event.pyNamedVariables["userCPMInteractionID"] = this.interactionID;
          event.pyNamedVariables["userOldCallId"] = originalContactId;
          pega.cti.API.handleInitiatedEvent(JSON.stringify(event));      
        }
        this.callingNumber=null;
    }
			
	},
   getCallObject:function ( callId, sendInteraction)  {
        var responseObj = new Object();
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.GetInteraction");
        postData.put("pzPrimaryPageName", "CTIPhone");
        postData.put("CallId", callId);
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {
                var request = oResponse;
                if (request.status === 200) {
                    var response = request.responseText;
                   showhtml(response);
                   responseObj = JSON.parse(response);
                    sendInteraction(responseObj.pyAppInteractionID);
                } else {
                    sendError("HTTP Error: " + request.statusText); // Check if it exists or not
                }
            },
            failure: function(oResponse) {
                sendError("HTTP Error: " + oResponse.statusText); // Check if it exists or not
            },
            scope: this
        }, postData);
    },
  
  
	 associateCallToInteractionn: function(JSONEvent) {
    var responseObj = new Object();
    var postData = new SafeURL();
    var activityUrl = new SafeURL("ChannelServices-Event-CTILink.pyAssociateCallToInteraction");
    postData.put("pzPrimaryPageName", "CTIEvent");
    postData.put("Event", JSONEvent);
    pega.u.d.asyncRequest("POST", activityUrl, {
        success: function(oResponse) {
            var request = oResponse;
            if (request.status == 200) {
                var response = request.responseText;
            } else {
                sendError("HTTP Error: " + request.statusText);
            }
        },
        failure: function(oResponse) {
            sendError("HTTP Error: " + oResponse.statusText);
        },
        scope: this
    }, postData);
   },
   expandCCP : function(){
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div"; 
            if($('#EmbeddedCCP > iframe')[0]!==undefined)
              $('#EmbeddedCCP > iframe')[0].style.display="block";
            alignCTIPosition();
            try{
                var windowheight = $( window ).height();
                var offsettop = $('#EmbeddedCCP').offset().top;
                var ccpheight = $('#EmbeddedCCP').height();
                if(parseFloat(offsettop) > (parseFloat(windowheight)-parseFloat(ccpheight)))
                 {
                   var x = (parseFloat(windowheight)-parseFloat(ccpheight));
                   if(x<0) x=0;
                   if($("#EmbeddedCCP")[0]!==undefined)
                   $("#EmbeddedCCP")[0].style.top=x+"px";
                 }
              }
             catch(ex){
               //Exception while expanding ccp
             }
        },
   collapseCCP : function(){
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-collapsed"; 
            if($('#EmbeddedCCP > iframe')[0]!==undefined)
              $('#EmbeddedCCP > iframe')[0].style.display="none"; 
            alignCTIPosition();
   },
   setTransferFramesize: function(){
         //To set iframe size for embedded links  
            if($('#EmbeddedCCP > iframe')[0]!==undefined){
            $('#EmbeddedCCP > iframe')[0].style.height="82%"; 
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-transfer";
            alignCTIPosition();
            }
    },
    resetTransferFramesize: function(){ 
        //To set iframe size for embedded links
            if($('#EmbeddedCCP > iframe')[0]!==undefined){
            $('#EmbeddedCCP > iframe')[0].style.height="93.5%"; 
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div";
            alignCTIPosition();
            }
    },
  
	loadMe :function(url, onSuccess, onFailure) {
	var ccp = document.getElementById('EmbeddedCCP');
	if (ccp) {
		if (window.connect) {
			window.ccp = window.ccp || {};

			if (this.initFlag) {
        //$('#EmbeddedCCP').empty();  
          var embeddedPanel = $("#EmbeddedCCP");
          embeddedPanel[0].className = "cti-embedded-div";
          alignCTIPosition();
          if($('#EmbeddedCCP > iframe')[0]!==undefined)
          $('#EmbeddedCCP > iframe')[0].remove();
				connect.core.initCCP(ccp, {
					ccpUrl: url,
					loginPopup: false,
					softphone: {
						allowFramedSoftphone: this.allowFramedSoftphone,
						disableRingtone: false
					}
				});
			}
      pega.cti.embeddedEventHandler.hideUIPanel();
			connect.core.getEventBus().subscribe(connect.EventType.TERMINATED, function () {
        pega.cti.embeddedEventHandler.disableClickToCall();
				//$('#EmbeddedCCP').empty();
        if($('#EmbeddedCCP > iframe')[0]!==undefined){
            $('#EmbeddedCCP > iframe')[0].remove();
        }
				connect.core.getEventBus().unsubscribeAll();
				connect.core.terminate();
				pega.cti.API.initFlag = true;
				pega.cti.embeddedEventHandler.setUIPanelActive("false");
        pega.cti.embeddedEventHandler.agentInfo('','','','Logout');
				pega.cti.embeddedEventHandler.hideUIPanel();

			});


			connect.core.getEventBus().subscribe(connect.EventType.ACK_TIMEOUT, function () {
				try {
					connect.getLog().warn("ACK_TIMEOUT occurred, attempting to pop the login page.");
					var width = 500;
					var height = 600;
					var left = (screen.width / 2) - (width / 2);
					var top = (screen.height / 2) - (height / 2);
					var loginURL = url + "/login";       
					pega.cti.API.loginWindow = window.open(loginURL, true, "width=" + width + ",height=" + height + ",menubar=no,status=no,toolbar=no,left=" + left + ",top=" + top);
				} catch (e) {
					  onFailure({
						errCode: "ERR_PASS",
						errMessage: "ACK_TIMEOUT occurred but we are unable to open the login popup." + e
					});
				}

			});

			connect.core.getEventBus().subscribe(connect.EventType.ACKNOWLEDGE, function () {
        if(null != pega.cti.API.loginWindow && undefined != pega.cti.API.loginWindow)
				  pega.cti.API.loginWindow.close();
				  onSuccess();
          pega.cti.API.initFlag = false;
				  pega.cti.embeddedEventHandler.showUIPanel();
          if($("div[data-node-id='AgentAvailability']")[0]!==undefined){
                         $("div[data-node-id='AgentAvailability']")[0].remove();
          }
          if($('div[data-node-id="CallTransferDetailsForm"]')[0] === undefined || ($('div[data-node-id="CallTransferDetailsForm"] > div')[2]!==undefined &&
           $('div[data-node-id="CallTransferDetailsForm"] > div')[2].style.display==="none")){
          if($('#EmbeddedCCP > iframe')[0]!==undefined)
          $('#EmbeddedCCP > iframe')[0].style.height="93.5%";
          }
          else
            {
              if($('#EmbeddedCCP > iframe')[0]!==undefined)
              $('#EmbeddedCCP > iframe')[0].style.height="82%";              
              var embeddedPanel = $("#EmbeddedCCP");
              embeddedPanel[0].className = "cti-embedded-div-transfer";
              alignCTIPosition();
            }
         connect.agent(function (myAgent) {
				    pega.cti.API.theAgent = myAgent;
            pega.cti.embeddedEventHandler.agentInfo(myAgent.getName(),myAgent.getConfiguration().username,myAgent.getExtension(),'Login');
       	    pega.cti.API.theAgent.onRoutable(pega.cti.API.handleRoutable);
				    pega.cti.API.theAgent.onNotRoutable(pega.cti.API.handleNotRoutable);
				    pega.cti.API.theAgent.onOffline(pega.cti.API.handleOffline);
				    pega.cti.API.theAgent.onAfterCallWork(pega.cti.API.handleAfterCallWork);
				    pega.cti.API.theAgent.onRefresh(pega.cti.API.handleAgentRefresh);
			});   
        
			});

		
			connect.contact(function (myContact) {
				pega.cti.API.theContact = myContact;
				pega.cti.API.newContact(myContact);
				myContact.onIncoming(pega.cti.API.handleIncoming);
				myContact.onEnded(pega.cti.API.handleEnded);
				myContact.onConnected(pega.cti.API.handleConnected);
				myContact.onAccepted(pega.cti.API.handleAccepted);
				myContact.onRefresh(pega.cti.API.handleContactRefresh);
			});


		} else
			onFailure({
				errCode: "ERR_PASS",
				errMessage: "amazon connect JS not included"
			});
	} else
		onFailure({
			errCode: "ERR_PASS",
			errMessage: "Unable to inject Amazon CCP. Unable to locate EmbeddedCCP in current document."
		})

}

}
//static-content-hash-trigger-GCC
/****************************************************************************************
 *
 * Communicate with embedded Five9 client.
 *
 ****************************************************************************************/
/*
@public - Prototype definition for pega.cti.embeddedApi.Five9
*/
function showhtml(str)
{
   if (str.indexOf("<html") > -1){
                        var myWindow = window.open('','','width=700,height=600');
                             var doc = myWindow.document;
                             doc.open();
                             doc.write(str); 
                             return true;
          } 
  else{
      return false;
      }
}

pega.cti.embeddedApi.Five9 = function() {
    this.eventCallback = null;
    this.linkDefinition = null;
    this.subscribeForEvents = false;
    
    this.theCallModel = null;
    this.interactionID = null;
    this.callingNumber = null;
    this.agentId = null;
    this.isAgentLoggedIn = false;
}
pega.cti.embeddedApi.Five9.prototype = {
    /*
    @api - Log agent into the ACD.
    @Param $String$linkDefinition - The CTILink definition as configured
    @param $Function$success – Callback function for success with message object
    @param $Function$failure – Callback function for failure with message object
    */
    load: function(linkDefinition, options, onSuccess, onFailure) {
        _this = this;
        this.linkDefinition = linkDefinition;
        var url = linkDefinition.contactCenterInstanceURL;
        console.log("Five9Adapter |load |", url);
        var ccp = document.getElementById('EmbeddedCCP');
        if (ccp) {
            _this.loadMe(url, onSuccess, onFailure);
        } else {
            setTimeout(function() {
                _this.loadMe(url, onSuccess, onFailure);
            }, 5000);
        }
    },
    loadMe: function(url, onSuccess, onFailure) {
        var embeddedPanel = $("#EmbeddedCCP");
        embeddedPanel[0].className = "cti-embedded-div-five9";
        alignCTIPosition();
        if($("div[data-node-id='AgentAvailability']")[0]!==undefined){
                         $("div[data-node-id='AgentAvailability']")[0].remove();
        }
        var iframeurl;
        if (url.endsWith("/clients/integrations/adt.main.html")) {
           iframeurl = url;
        }
        else {
            if(url.endsWith("/"))
               url = url.substring(0,url.length-1);
            iframeurl = url + "/clients/integrations/adt.main.html";
        }
        if($('div[data-node-id="CallTransferDetailsForm"]')[0] === undefined || ($('div[data-node-id="CallTransferDetailsForm"] > div')[2]!==undefined &&
           $('div[data-node-id="CallTransferDetailsForm"] > div')[2].style.display==="none")){
        embeddedPanel.append('<iframe src="' + iframeurl +
            '" frameborder="0" scrolling="no" style="position: relative; height: 93.5%; width: 100%;"></iframe>'
        );
        }
       else
          {
            embeddedPanel.append('<iframe src="' + iframeurl +
            '" frameborder="0" scrolling="no" style="position: relative; height: 82%; width: 100%;"></iframe>'
        );
            embeddedPanel[0].className = "cti-embedded-div-five9-transfer";
            alignCTIPosition();
        }
        onSuccess();
        pega.cti.API.initRestApi();
        window.addEventListener("message", function(event) {
          if(event.isTrusted && pega.cti.API.isAgentLoggedIn){
            pega.cti.API.onModelUnload();
          }
        });
        pega.cti.embeddedEventHandler.showUIPanel();
    },
    /*
    @api to init Rest API
    */
    initRestApi: function() {
        console.log("Five9Adapter |initRestApi");
        Five9.RestApi.vent.on(Five9.RestApi.events.MODEL_LOAD, this.onModelLoad);
        Five9.RestApi.vent.on(Five9.RestApi.events.MODEL_UNLOAD, this.onModelUnload);
        Five9.RestApi.vent.on(Five9.RestApi.events.NEED_CREDENTIALS, this.onNeedCredentials);
        var baseurl;
        if (pega.cti.API.linkDefinition.contactCenterInstanceURL.indexOf("//") > -1) {
            baseurl = pega.cti.API.linkDefinition.contactCenterInstanceURL.split('/')[0] +'//'+ pega.cti.API.linkDefinition.contactCenterInstanceURL.split('/')[2];
        }
        else {
             baseurl = 'https://' + pega.cti.API.linkDefinition.contactCenterInstanceURL.split('/')[0];
        }
        var options = {
             apiBaseUrl: baseurl
        };
        try{
        Five9.RestApi.start(options);
        }
        catch(e){
          console.log("Can't start in logged in state");
        }
        Five9.RestApi.loggingEnabled = true;
    },
    /*
    @api to answerCall Rest API
    */
    answerCall: function() {},
    /*
    @api to makeCall Rest API
    */
    makeCall: function(destination, options, onSuccess, onFailure) {
        try {

            this.callingNumber = destination;
            if (options != null || options != undefined)
                if (options.pyCallVariables != undefined)
                    if (options.pyCallVariables.length > 0)
                        for (var i = 0; i < options.pyCallVariables.length; i++)
                            if (options.pyCallVariables[i].pyKey == "userCPMInteractionID")
                                this.interactionID = options.pyCallVariables[i].pyValue;

            var agent = Five9.RestApi.getAgent();
            var makeCallRequestState = agent.makeExternalCall(destination, true, null, false, 'none');
            makeCallRequestState.pipe(function(succ) {
                console.log("Five9Adapter |makeCall |", succ);
            }, function(err) {
                pega.cti.API.callingNumber = null;
                showAlertNotification(err.responseJSON.five9ExceptionDetail.message);
            });
        } catch (e) {
            showAlertNotification(e);
        }
    },
    /*
    @api - unload object from link definition
    @param $Function$success – Callback function for success with message object
    @param $Function$failure – Callback function for failure with message object
    */
    unload: function(onSuccess, onFailure) {
        onSuccess();
    },
    /*
	  @api - onModelUnload
	  */
    onModelUnload: function() {

        console.log("Five9Adapter |onModelUnload |", Five9.RestApi.getAgent());
        try {
          if(pega.cti.API.isAgentLoggedIn){
            var agent = Five9.RestApi.getAgent();
            agent.changeStatus().pipe(function(data) {}, function(err) {
                if (err.hasOwnProperty("responseJSON")) {
                    var errCode = err.responseJSON.five9ExceptionDetail.errorCode;
                    if (errCode === "401" || errCode === 401) {
                      pega.cti.embeddedEventHandler.disableClickToCall();
                        if($('#EmbeddedCCP > iframe')[0]!==undefined){
                          $('#EmbeddedCCP > iframe')[0].remove();
                        }
                        pega.cti.embeddedEventHandler.setUIPanelActive("false");
                        pega.cti.API.agentId = null;
                        pega.cti.embeddedEventHandler.agentInfo('','','','Logout');
                        pega.cti.API.isAgentLoggedIn = false;
				                pega.cti.embeddedEventHandler.hideUIPanel();
                        pega.cti.API.subscribeForEvents=false;
                    }
                }
            });
          }
        } catch (e) {
            showAlertNotification(e);
        }
    },
    /*
	  @api - onModelLoad
	  */
    onModelLoad: function() {
        console.log("Five9Adapter |onModelLoad |", Five9.RestApi.getAgent());

        try {
            if (pega.cti.API.subscribeForEvents === true) {
                console.log("Five9Adapter |onModelLoad | return on multiple onModelLoad");
                return;
            }
            var agent = Five9.RestApi.getAgent();
            agent.LoginState().fetch(function() {
                //cache: false
            }).done(function(currentState) {
                agent.LoginState().off('change:state');
                agent.LoginState().on('change:state', function(model,newState) {
                    pega.cti.API.onLoginStateChange(model);
                });
                agent.Calls().off('add change:state remove');
                agent.Calls().on('add change:state remove', function(model) {
                    pega.cti.API.theCallModel = model;
                    pega.cti.API.onCallChange(model);
                });
                agent.Presence().off('change:currentState');
                agent.Presence().on('change:currentState', function(model) {
                    pega.cti.API.onPresenceChange(model.get('currentState').notReadyReasonCodeId);
                });
                pega.cti.API.subscribeForEvents = true;
                pega.cti.API.isAgentLoggedIn = true;
            })
        } catch (e) {
            showAlertNotification(e);
        }
    },

    onPresenceChange: function(reasonCode) {
        try {
            console.log("Five9Adapter |onPresenceChange |", reasonCode);
            //pega.cti.embeddedEventHandler.enableClickToCall();
        } catch (e) {
            showAlertNotification(e);
        }
    },
    /*
	  @api - onLoginStateChange
    @param $Object$LoginModel – Login Information
	  */
    onLoginStateChange: function(model) {
        try {
            console.log("Five9Adapter |onLoginStateChange |", model.get('state'));
            var state = model.get('state');
            this.agentId = model._pending.context.userName;
            pega.cti.embeddedEventHandler.agentInfo(model._pending.context.userName,model._pending.context.userId,'','Login');
            pega.cti.API.isAgentLoggedIn = true;
            if (state === 'WORKING') {
                pega.cti.embeddedEventHandler.enableClickToCall();
            }
        } catch (e) {
            showAlertNotification(e);
        }
    },
    /*
	  @api - onCallChange
    @param $Object$callModel – Call Information
	  */
    onCallChange: function(callModel) {
        console.log("Five9Adapter |onCallChange |", callModel.get('state'));

        var state = callModel.get('state');
        switch (state) {
            case 'DIALING':
            case 'RINGING_ON_OUR_SIDE':
            case 'OFFERED':
                pega.cti.embeddedEventHandler.disableClickToCall();
                this.startScreenPop(callModel);
                break;
            case 'WRAP_UP':
                pega.cti.embeddedEventHandler.disableClickToCall();
                this.handleEnded(callModel);
                break
            case 'FINISHED':
                pega.cti.embeddedEventHandler.enableClickToCall();
                break;
            case 'RINGING_ON_OTHER_SIDE':
                pega.cti.embeddedEventHandler.disableClickToCall();
                break;
            case 'QUEUED':
            case 'PARKED':
            case 'CONFERENCE_PARTICIPANT_RINGING':
            case 'CONFERENCE_PARTICIPANT_TALKING':
            case 'CONFERENCE_PARTICIPANT_CONSULTING':
                pega.cti.embeddedEventHandler.disableClickToCall();
                break;  
            case 'TALKING':
                pega.cti.embeddedEventHandler.disableClickToCall();
                this.handleConnected(callModel);
                break;    
            case 'ON_HOLD':
                this.handleHeldEvent(callModel);
                pega.cti.embeddedEventHandler.disableClickToCall();
                break;  
            default:
                pega.cti.embeddedEventHandler.enableClickToCall();
                break;
        }
    },
   handleHeldEvent : function(callModel) {

   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = callModel.attributes.variables[41];
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Held";
    event.pyEventString = "Held";
    event.pyQueue = callModel.attributes.queueType;
    event.pyANI = callModel.attributes.variables[48];
    event.pyOtherDN = callModel.attributes.variables[49];
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
  },
  	handleConnected: function (callModel) {
   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = callModel.attributes.variables[41];
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Connected";
    event.pyEventString = "Connected";
    event.pyQueue = callModel.attributes.queueType;
    event.pyOtherDN = callModel.attributes.variables[49];
    event.pyANI = callModel.attributes.variables[48];
    event.pyCallType = callModel.attributes.variables[44];
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
	},
    handleEnded: function (callModel) {
   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = callModel.attributes.variables[41];
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Disconnected";
    event.pyEventString = "Disconnected";
    event.pyQueue = callModel.attributes.queueType;
    event.pyANI = callModel.attributes.variables[48];
    event.pyCallType = callModel.attributes.variables[44];
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
	},
    handleAlerting: function (callModel) {
   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = callModel.attributes.variables[41];
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Offering";
    event.pyEventString = "Offering";
    event.pyQueue = callModel.attributes.queueType;
    event.pyANI = callModel.attributes.variables[48];
    event.pyCallType = callModel.attributes.variables[44];
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
	},   

    /*
    @api – to set Transfer Context
    @param $String$ callId – Update contact with callId
    @param $String$ comment – Update contact with comment
    @param $String$ reason – Update contact with reason
    @param $Function$success – Callback function for success with message object
    @param $Function$failure – Callback function for failure with message object
    */
    setTransferContext: function(callId, comment, reason, appInteractionID, success, failure) {
        var callId = pega.cti.API.theCallModel.attributes.variables[41];
        console.log("Five9Adapter |setTransferContext | callId |", callId);
        var postData = new SafeURL();
       
        // Fix for Bug-605190
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
        postData.put("RequestType", "EmbeddedPreTransferSetup");
        postData.put("ActivityClass","ChannelServices-Device-Phone-UI");
        postData.put("pzPrimaryPageName", "CTIPhone");
        postData.put("TransferReason", reason);
        postData.put("TransferComment", comment);
       if(typeof  appInteractionID !='undefined'){
        postData.put("AppInteractionID", appInteractionID);
       }
        postData.put("TransferType", "TransferInitiate");
        postData.put("CallId", String(callId));
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {
                var request = oResponse;
                if (request.status === 200) {
                    var response = request.responseText;
                } else {
                    sendError("HTTP Error: " + request.statusText); // Check if it exists or not
                }
            },
            failure: function(oResponse) {
                sendError("HTTP Error: " + oResponse.statusText); // Check if it exists or not
            },
            scope: this
        }, postData);
    },

    /*
	@api - startScreenPop
  @param $Object$callModel – Call Information
	*/
    startScreenPop: function(callModel) {
        try {
            console.log("Five9Adapter |startScreenPop | callModel |", callModel);
            pega.cti.API.handleAlerting(callModel);
            var callType = callModel.attributes.variables[44];
            var callId = callModel.attributes.variables[41];
            var ANI = callModel.attributes.variables[48];

            var event = {};
            event.pyANI = ANI;
            event.pyCallId = callId;
            event.pyInteractionID = callId;
            event.pyMedia = "Phone";
            event.pyCallType = callType;
            event.pyEventString = "Offering";
            event.pyEventName = "Offering";
            event.pyOtherDN = callModel.attributes.variables[49];
            event.pyQueue = callModel.attributes.queueType;
            // Start ::: BUG-498812 No Call meta data attributes for Five9
            event.pyNamedVariables = {};
            var variables = callModel.attributes.variables;
            for (key in variables) {
                event.pyNamedVariables["VAR_" + key] = variables[key];
            }
            // End ::: BUG-498812 No Call meta data attributes for Five9

            if (callModel.attributes.transfer) {
                event.pyEventName = "Offering";
                console.log("Five9Adapter |startScreenPop | callId |", callId);
                pega.cti.API.getCallObject(String(callId), function(data) {

                    console.log("Five9Adapter |startScreenPop | INBOUND |getCallObject |", data);
                    if (typeof data !== "undefined") {
                        event.pyNamedVariables["userCPMInteractionID"] = data;
                        event.pyNamedVariables["userOldCallId"] = callModel.attributes.variables[41];
                        event.pyCallType = "CONSULT";
                        event.pyEventType = "CallInfoEvent";
                    }
                    pega.cti.embeddedEventHandler.applyCallTreatment(JSON.stringify(event));
                });
                return;
            }

            if (callType.toUpperCase() === "INBOUND") {
                event.pyEventName = "Offering";
                pega.cti.embeddedEventHandler.applyCallTreatment(JSON.stringify(event));
                
            } else if (callType.toUpperCase() === "MANUAL") {
                if (this.interactionID != null && this.callingNumber != null) {
                    event.pyNamedVariables["userCPMInteractionID"] = this.interactionID;
                    event.pyNamedVariables["userOldCallId"] = callId;
                    pega.cti.API.associateCallToInteraction(JSON.stringify(event));
                }
                this.callingNumber = null;
            }
        } catch (e) {
            console.log("Five9Adapter |startScreenPop | Exception |", e);
        }
    },

    getCallObject: function(callId, sendInteraction) {
        var responseObj = new Object();
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.GetInteraction");
        postData.put("pzPrimaryPageName", "CTIPhone");
        postData.put("CallId", callId);
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {
                var request = oResponse;
                if (request.status === 200) {
                    var response = request.responseText;
                    showhtml(response);
                    responseObj = JSON.parse(response);
                    sendInteraction(responseObj.pyAppInteractionID);
                } else {
                    sendError("HTTP Error: " + request.statusText); // Check if it exists or not
                }
            },
            failure: function(oResponse) {
                sendError("HTTP Error: " + oResponse.statusText); // Check if it exists or not
            },
            scope: this
        }, postData);
    },

    associateCallToInteraction: function(JSONEvent) {
      console.log("Five9Adapter |associateCallToInteraction |",JSONEvent);
        var responseObj = new Object();
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Event-CTILink.pyAssociateCallToInteraction");
        postData.put("pzPrimaryPageName", "CTIEvent");
        postData.put("Event", JSONEvent);
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {
                var request = oResponse;
                if (request.status == 200) {
                    var response = request.responseText;
                } else {
                    sendError("HTTP Error: " + request.statusText);
                }
            },
            failure: function(oResponse) {
                sendError("HTTP Error: " + oResponse.statusText);
            },
            scope: this
        }, postData);
    },


    /*
	  @api - onNeedCredentials
	  */
    onNeedCredentials: function() {
        console.log("Five9Adapter |onNeedCredentials");
        pega.cti.embeddedEventHandler.disableClickToCall();
        var baseurl;
        if (pega.cti.API.linkDefinition.contactCenterInstanceURL.indexOf("//") > -1) {
            baseurl = pega.cti.API.linkDefinition.contactCenterInstanceURL.split('/')[0] +'//'+ pega.cti.API.linkDefinition.contactCenterInstanceURL.split('/')[2];
        }
        else {
           baseurl = 'https://' + pega.cti.API.linkDefinition.contactCenterInstanceURL.split('/')[0];
        }
        setTimeout(function() {
            var options = {
                apiBaseUrl: baseurl
            };
            Five9.RestApi.start(options);
        }, 10000);
    },
        expandCCP : function(){
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-five9"; 
            alignCTIPosition();
            try{
                var windowheight = $( window ).height();
                var offsettop = $('#EmbeddedCCP').offset().top;
                var ccpheight = $('#EmbeddedCCP').height();
                if(parseFloat(offsettop) > (parseFloat(windowheight)-parseFloat(ccpheight)))
                 {
                   var x = (parseFloat(windowheight)-parseFloat(ccpheight));
                   if(x<0) x=0;
                   if($("#EmbeddedCCP")[0]!==undefined)
                   $("#EmbeddedCCP")[0].style.top=x+"px";
                 }
            }
            catch(ex){
              //Exception while expanding ccp
            }
        },
        collapseCCP : function(){
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-five9-collapsed";  
            alignCTIPosition();
        },
        setTransferFramesize: function(){
         //To set iframe size for embedded links  
            if($('#EmbeddedCCP > iframe')[0]!==undefined){
            $('#EmbeddedCCP > iframe')[0].style.height="82%"; 
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-five9-transfer";
            alignCTIPosition();
            }
        },
        resetTransferFramesize: function(){ 
        //To set iframe size for embedded links
            if($('#EmbeddedCCP > iframe')[0]!==undefined){
            $('#EmbeddedCCP > iframe')[0].style.height="93.5%";
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-five9";
            alignCTIPosition();
            }
        },
    /* KEEP THIS AS THE LAST FUNCTION */
    _lastFunction: function() {}
}
//static-content-hash-trigger-GCC
/****************************************************************************************
 *
 * Communicate with embedded GenesysCloud client.
 *
 ****************************************************************************************/
/*
@public - Prototype definition for pega.cti.embeddedApi.GenesysCloud
*/
pega.cti.embeddedApi.GenesysCloud = function() {
    this.eventCallback = null;
    this.linkDefinition = null;
    this.subscribeForEvents = false;
    this.callId = "-1";
    this.Logger = new pega.cti.Logger();
    this.interactionID = null;
    this.agentId = null;
    this.makecall = false;
}
pega.cti.embeddedApi.GenesysCloud.prototype = {
    /*
    @api - Log agent into the ACD.
    @Param $String$linkDefinition - The CTILink definition as configured
    @param $Function$success – Callback function for success with message object
    @param $Function$failure – Callback function for failure with message object
    */
    load: function(linkDefinition,options, onSuccess, onFailure) {
        _this = this;
        this.linkDefinition = linkDefinition;
        var url = linkDefinition.contactCenterInstanceURL;
        pega.cti.API.Logger.setLevel(20000);
        pega.cti.API.Logger.info('GenesysCloudAdapter |load | '+url);
        var ccp = document.getElementById('EmbeddedCCP');
        if (ccp) {
            _this.loadMe(url, onSuccess, onFailure);
        } else {
            setTimeout(function() {
                _this.loadMe(url, onSuccess, onFailure);
            }, 5000);
        }
    },
    loadMe: function(url, onSuccess, onFailure) {
        var embeddedPanel = $("#EmbeddedCCP");
      
     
        var urlWithParams = new URL(url);

        for (var k = 0; k < this.linkDefinition.CustomProperties.length; k++) {
         urlWithParams.searchParams.append(this.linkDefinition.CustomProperties[k].pyPropertyName, this.linkDefinition.CustomProperties[k].pyPropertyValue);
        }
      
        embeddedPanel[0].className = "cti-embedded-div-genesysCloud";
        alignCTIPosition();
        if($("div[data-node-id='AgentAvailability']")[0]!==undefined){
                         $("div[data-node-id='AgentAvailability']")[0].remove();
        }
        if($('div[data-node-id="CallTransferDetailsForm"]')[0] === undefined || ($('div[data-node-id="CallTransferDetailsForm"] > div')[2]!==undefined &&
           $('div[data-node-id="CallTransferDetailsForm"] > div')[2].style.display==="none")){
        embeddedPanel.append('<iframe id="genesysCloudSoftphone"  allow="camera *; microphone *"  src="' + urlWithParams +
            '" frameborder="0" scrolling="no" style="position: relative; height: 93.5%; width: 100%;"></iframe>'
        );
    }
    else
      {
        embeddedPanel[0].className = "cti-embedded-div-genesysCloud-transfer";
        alignCTIPosition();
        embeddedPanel.append('<iframe id="genesysCloudSoftphone"  allow="camera *; microphone *"  src="' + urlWithParams +
            '" frameborder="0" scrolling="no" style="position: relative; height: 82%; width: 100%;"></iframe>'
        );
      }
        onSuccess();
        pega.cti.API.addEventListener();
       pega.cti.embeddedEventHandler.showUIPanel();
    },
    /*
    @api to init Rest API
    */
    addEventListener: function() {
        window.addEventListener("message", function(event) {
            var message = JSON.parse(event.data);
            var state = message.type;
            pega.cti.API.Logger.info('GenesysCloudAdapter |addEventListener |message | '+ JSON.stringify(message));
            switch (state) {
              case "screenPop": 
                pega.cti.API.startScreenPop(message.data.interactionId);
                break;
              case "processCallLog":
                break;
              case "openCallLog":
                break;

              case "interactionSubscription": 
                  if(message.data.category==="change" && message.data.interaction.new.direction==="Outbound" && pega.cti.API.makecall===false)
                    {
                      pega.cti.API.callId = message.data.interaction.new.id;
                      pega.cti.API.handleInitiatedEvent();
                    }
                  else if(message.data.interaction.direction==="Outbound" && pega.cti.API.makecall===false){
                    pega.cti.API.callId = message.data.interaction.id;
                    pega.cti.API.handleInitiatedEvent();
                    }
                  if(message.data.interaction.old!=null && message.data.interaction.old.state!=null 
                          && message.data.interaction.old.state==="CONNECTED" &&
                          message.data.interaction.new!=null && message.data.interaction.new.state!=null && message.data.interaction.new.state==="HELD")
			                pega.cti.API.handleHeldEvent(message.data.interaction.new);
                  else if(message.data.interaction.old!=null && message.data.interaction.old.state!=null 
                          && message.data.interaction.old.state==="HELD" &&
                          message.data.interaction.new!=null && message.data.interaction.new.state!=null 
                          && message.data.interaction.new.state==="CONNECTED")
		                  pega.cti.API.handleRetrievedEvent(message.data.interaction.new);
                  else if(message.data.interaction.old!=null && message.data.interaction.old.state!=null 
                          && message.data.interaction.old.state==="ALERTING" &&
                          message.data.interaction.new!=null && message.data.interaction.new.state!=null 
                          && message.data.interaction.new.state==="CONNECTED")            
                      pega.cti.API.handleConnected(message.data.interaction.new);
                  else if(message.data.category==="disconnect" && message.data.interaction!=null && message.data.interaction.state!=null 
                          && message.data.interaction.state==="DISCONNECTED")      
                       pega.cti.API.handleEnded(message.data.interaction);
                  break;
              case "userActionSubscription":
                pega.cti.API.onLoginStateChange(message.data);
                 break;
              case "notificationSubscription":
                 break;
              case "contactSearch":
                break;

                }
        });
    },
    /*
    @api for LoginStateChange Rest API
    */
    handleInitiatedEvent: function(){
        var callevent = {};
        callevent.pyCallId = pega.cti.API.callId;
        callevent.pyInteractionID = pega.cti.API.callId;
        callevent.pyMedia = "Phone";
        callevent.pyCallType = "OUTBOUND";
        callevent.pyEventName = "Offering";
        callevent.pyEventString = "Offering";                  
        callevent.pyNamedVariables = {};
        if(this.interactionID!==null){ 
              callevent.pyNamedVariables["userCPMInteractionID"] = this.interactionID;
              callevent.pyNamedVariables["userOldCallId"] = pega.cti.API.callId;
        }
        pega.cti.API.associateCallToInteraction(JSON.stringify(callevent));
        pega.cti.API.makecall=true;
    },
   handleHeldEvent : function(callModel) {

   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = callModel.id
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Held";
    event.pyEventString = "Held";
    event.pyQueue = callModel.queueName;
    event.pyANI = callModel.ani;
    event.pyOtherDN = callModel.calledNumber;
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
  },
    handleConnected: function (callModel) {
   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = callModel.id
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Connected";
    event.pyEventString = "Connected";
    event.pyQueue = callModel.queueName;
    event.pyANI = callModel.ani;
    event.pyOtherDN = callModel.calledNumber;
    event.pyCallType = callModel.direction;
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
	},
    handleEnded: function (callModel) {
   	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = callModel.id;
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Disconnected";
    event.pyEventString = "Disconnected";
    event.pyQueue = callModel.queueName;
    event.pyANI = callModel.ani;
    event.pyCallType = callModel.direction;
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
	},

   handleRetrievedEvent: function(callModel) {

  	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = callModel.id;
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Retrieved";
    event.pyEventString = "Retrieved";
    event.pyQueue = callModel.queueName;
    event.pyANI = callModel.ani;
    event.pyOtherDN = callModel.calledNumber;
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
  }, 
   handleAlerting: function(callModel) {

  	var event = {};
    event.pyEventType = "CallStateEvent";
    event.pyCallId = callModel.id;
    event.pyInteractionID = event.pyCallId;
	  event.pyMedia = "Phone";
	  event.pyEventName = "Offering";
    event.pyEventString = "Offering";
    event.pyQueue = callModel.queueName;
    event.pyANI = callModel.ani;
    event.pyOtherDN = callModel.calledNumber;
    event.pyCallType = callModel.direction;
    sendEvent('PublicPhoneCallStateEvent',JSON.stringify(event));
  }, 
    onLoginStateChange: function(callModel){
      pega.cti.API.Logger.info('GenesysCloudAdapter | onLoginStateChange | '+callModel.category);
      if(callModel.category==="login"){
      pega.cti.embeddedEventHandler.enableClickToCall();
      }
      if(callModel.category==="station"){   
      this.agentId = callModel.data.name;
      pega.cti.embeddedEventHandler.agentInfo(callModel.data.name,callModel.data.userId,callModel.data.id,'Login');
       }      
      else if(callModel.category==="logout"){
        pega.cti.embeddedEventHandler.disableClickToCall();
        this.agentId = null;
        pega.cti.embeddedEventHandler.setUIPanelActive("false");
        pega.cti.embeddedEventHandler.hideUIPanel();
        if($('#EmbeddedCCP > iframe')[0]!==undefined){
            $('#EmbeddedCCP > iframe')[0].remove();
        }
        pega.cti.embeddedEventHandler.agentInfo('','','','Logout');
      }
    },
    /*
    @api to answerCall Rest API
    */
    answerCall: function(callId, options, onSuccess, onFailure) {
      pega.cti.API.Logger.info('GenesysCloudAdapter | answerCall | '+pega.cti.API.callId);
        try {
         
            document.getElementById("genesysCloudSoftphone").contentWindow.postMessage(JSON.stringify({
                type: 'updateInteractionState',
                data: {
                    action: "pickup",
                    id: pega.cti.API.callId
                }
            }), "*");

        } catch (e) {
            showAlertNotification(e);
        }
    },
    /*
    @api to makeCall Rest API
    */
    makeCall: function(destination, options, onSuccess, onFailure) {
      pega.cti.API.makecall=false;
          if (options !== null || options !== undefined )
    if (options.pyCallVariables !== undefined)
        if(options.pyCallVariables.length > 0)
          for (var i =0 ; i<options.pyCallVariables.length;i++ )
            if (options.pyCallVariables[i].pyKey === "userCPMInteractionID")
            this.interactionID = options.pyCallVariables[i].pyValue;
      pega.cti.API.Logger.info('GenesysCloudAdapter | makeCall | '+destination);
        try {
            document.getElementById("genesysCloudSoftphone").contentWindow.postMessage(JSON.stringify({
                type: 'clickToDial',
                data: {
                    number: destination,
                    autoPlace: true
                }
            }), "*");
        } catch (e) {
            showAlertNotification(e);
        }
    },
    /*
    @api - unload object from link definition
    @param $Function$success – Callback function for success with message object
    @param $Function$failure – Callback function for failure with message object
    */
    unload: function(onSuccess, onFailure) {
        onSuccess();
    },
    /*
    @api – to set Transfer Context
    @param $String$ callId – get callId from direction
    @param $String$ comment – Update contact with comment
    @param $String$ reason – Update contact with reason
    @param $Function$success – Callback function for success with message object
    @param $Function$failure – Callback function for failure with message object
    */
    setTransferContext:function (callId, comment, reason, appInteractionID, success, failure)  {
      pega.cti.API.Logger.info('GenesysCloudAdapter | setTransferContext |'+ 
                  ' ChannelServices-Device-Phone-UI.EmbeddedPreTransferSetup '+pega.cti.API.callId);
      var originalContactId = pega.cti.API.callId;
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Device-Phone-UI.DispatchCTIRequests");
        postData.put("RequestType", "EmbeddedPreTransferSetup");
        postData.put("ActivityClass","ChannelServices-Device-Phone-UI");
        postData.put("pzPrimaryPageName", "CTIPhone");
        postData.put("TransferReason", reason);
        postData.put("TransferComment", comment);
        if(typeof  appInteractionID !='undefined'){
        postData.put("AppInteractionID", appInteractionID);
        }
        postData.put("TransferType", "TransferInitiate");
        postData.put("CallId", String(originalContactId));
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {
                var request = oResponse;
                if (request.status === 200) {
                  var response = JSON.parse(request.responseText);
                  if(reason!=="" || comment!==""){
                      if(response.pyAppInteractionID!==null && response.pyAppInteractionID!==undefined){
                        document.getElementById("genesysCloudSoftphone").contentWindow.postMessage(JSON.stringify({
                              type: 'addAttribute',
                              data: {
                                    interactionId : originalContactId,
                                    attributes: { 'userCPMInteractionID':response.pyAppInteractionID,'userOldCallId': originalContactId}
                                    }
                          }), "*");
                  }
                    else if(this.interactionID!==null)
                      {
                        document.getElementById("genesysCloudSoftphone").contentWindow.postMessage(JSON.stringify({
                              type: 'addAttribute',
                              data: {
                                    interactionId : originalContactId,
                                    attributes: { 'userCPMInteractionID':this.interactionID,'userOldCallId': originalContactId}
                                    }
                          }), "*");
                      }
                  }
                  else {
                        document.getElementById("genesysCloudSoftphone").contentWindow.postMessage(JSON.stringify({
                              type: 'addAttribute',
                              data: {
                                    interactionId : originalContactId,
                                    attributes: { 'userCPMInteractionID':"",'userOldCallId': ""}
                                    }
                          }), "*");                    
                  }
              } else {
                    sendError("HTTP Error: " + request.statusText); // Check if it exists or not
                }
            },
            failure: function(oResponse) {
                sendError("HTTP Error: " + oResponse.statusText); // Check if it exists or not
            },
            scope: this
        }, postData);
  
    },

    /*
	@api - startScreenPop
  @param $Object$callModel – Call Information
	*/
    startScreenPop: function(callModel) {
        pega.cti.API.Logger.info('GenesysCloudAdapter |startScreenPop | '+ JSON.stringify(callModel));
        try {
            var callType = callModel.direction;
            if (callType.toUpperCase() === "INBOUND" || (callType.toUpperCase() === "OUTBOUND" && callModel.state.toUpperCase()=== "ALERTING")) {
                var ANI = callModel.ani;
                var event = {};
                event.pyANI = ANI;
                event.pyCallId = callModel.id;
                pega.cti.API.callId = callModel.id;
                event.pyInteractionID = callModel.id;
                event.pyMedia = "Phone";
                event.pyCallType = callType;
                event.pyEventName = "Offering";
                event.pyEventString = "Offering";
                event.pyOtherDN = callModel.calledNumber;
                event.pyQueue = callModel.queueName;
              
                event.pyNamedVariables = {}
                var variables = callModel.attributes;
                for (var key in variables) {
                       if(key==="usercpminteractionid")
                         event.pyNamedVariables['userCPMInteractionID'] = variables[key];
                       else if(key==="useroldcallid")
                         event.pyNamedVariables['userOldCallId'] = variables[key];
                       else
                         event.pyNamedVariables[key] = variables[key];
                }
                if(variables!==undefined && variables["usercpminteractionid"]!==undefined && variables["useroldcallid"]!==undefined
                  && variables["usercpminteractionid"]!=="" && variables["useroldcallid"]!=="")
                   {
                     event.pyCallType = "CONSULT"; 
                     event.pyEventType = "CallInfoEvent"; 
                    }
                pega.cti.API.Logger.info('GenesysCloudAdapter |startScreenPop |Before applyCallTreatment | '+ callModel.direction);
                pega.cti.embeddedEventHandler.applyCallTreatment(JSON.stringify(event));
                pega.cti.API.handleAlerting(callModel);
            }
        } catch (e) {
            pega.cti.API.Logger.info('GenesysCloudAdapter |startScreenPop | Exception | '+ e);
        }
    },
     associateCallToInteraction: function(JSONEvent) {
      pega.cti.API.Logger.info("GenesysCloudAdapter |associateCallToInteraction | "+ JSONEvent);
        var responseObj = new Object();
        var postData = new SafeURL();
        var activityUrl = new SafeURL("ChannelServices-Event-CTILink.pyAssociateCallToInteraction");
        postData.put("pzPrimaryPageName", "CTIEvent");
        postData.put("Event", JSONEvent);
        pega.u.d.asyncRequest("POST", activityUrl, {
            success: function(oResponse) {
                var request = oResponse;
                if (request.status == 200) {
                    var response = request.responseText;
                } else {
                    sendError("HTTP Error: " + request.statusText);
                }
            },
            failure: function(oResponse) {
                sendError("HTTP Error: " + oResponse.statusText);
            },
            scope: this
        }, postData);
    },
     expandCCP : function(){          
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-genesysCloud";  
            alignCTIPosition();
            try{
                var windowheight = $( window ).height();
                var offsettop = $('#EmbeddedCCP').offset().top;
                var ccpheight = $('#EmbeddedCCP').height();
                if(parseFloat(offsettop) > (parseFloat(windowheight)-parseFloat(ccpheight)))
                 {
                   var x = (parseFloat(windowheight)-parseFloat(ccpheight));
                   if(x<0) x=0;
                   if($("#EmbeddedCCP")[0]!==undefined)
                   $("#EmbeddedCCP")[0].style.top=x+"px";
                 }
              }
            catch(ex)
              {
                //Exception while expanding ccp
              }
           
        },
        collapseCCP : function(){
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-genesysCloud-collapsed";
            alignCTIPosition();
        },
        setTransferFramesize: function(){
         //To set iframe size for embedded links 
            if($('#EmbeddedCCP > iframe')[0]!==undefined){
            $('#EmbeddedCCP > iframe')[0].style.height="82%"; 
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-genesysCloud-transfer";
            alignCTIPosition();
            }
        },
        resetTransferFramesize: function(){ 
        //To set iframe size for embedded links
            if($('#EmbeddedCCP > iframe')[0]!==undefined){
            $('#EmbeddedCCP > iframe')[0].style.height="93.5%"; 
            var embeddedPanel = $("#EmbeddedCCP");
            embeddedPanel[0].className = "cti-embedded-div-genesysCloud";
            alignCTIPosition();
            }
        },


    /* KEEP THIS AS THE LAST FUNCTION */
    _lastFunction: function() {}
}
//static-content-hash-trigger-GCC
/**
 * Dual licensed under the Apache License 2.0 and the MIT license.
 * $Revision: 1536 $ $Date: 2010-11-09 19:30:34 +0100 (Tue, 09 Nov 2010) $
 */

if (typeof dojo !== 'undefined')
{
    dojo.provide('org.cometd');
}
else
{
    // Namespaces for the cometd implementation
    this.org = this.org || {};
    org.cometd = {};
}

org.cometd.JSON = {};
org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function(object)
{
    throw 'Abstract';
};

org.cometd.Utils = {};

org.cometd.Utils.isString = function(value)
{
    if (value === undefined || value === null)
    {
        return false;
    }
    return typeof value === 'string' ||  value instanceof String;
};

org.cometd.Utils.isArray = function(value)
{
    if (value === undefined || value === null)
    {
        return false;
    }
    return value instanceof Array;
};

/**
 * Returns whether the given element is contained into the given array.
 * @param element the element to check presence for
 * @param array the array to check for the element presence
 * @return the index of the element, if present, or a negative index if the element is not present
 */
org.cometd.Utils.inArray = function(element, array)
{
    for (var i = 0; i < array.length; ++i)
    {
        if (element == array[i])
        {
            return i;
        }
    }
    return -1;
};

org.cometd.Utils.setTimeout = function(cometd, funktion, delay)
{
    return setTimeout(function()
    {
        try
        {
            funktion();
        }
        catch (x)
        {
            cometd._debug('Exception invoking timed function', funktion, x);
        }
    }, delay);
};

/**
 * A registry for transports used by the Cometd object.
 */
org.cometd.TransportRegistry = function()
{
    var _types = [];
    var _transports = {};

    this.getTransportTypes = function()
    {
        return _types.slice(0);
    };

    this.findTransportTypes = function(version, crossDomain, url)
    {
        var result = [];
        for (var i = 0; i < _types.length; ++i)
        {
            var type = _types[i];
            if (_transports[type].accept(version, crossDomain, url) === true)
            {
                result.push(type);
            }
        }
        return result;
    };

    this.negotiateTransport = function(types, version, crossDomain, url)
    {
        for (var i = 0; i < _types.length; ++i)
        {
            var type = _types[i];
            for (var j = 0; j < types.length; ++j)
            {
                if (type == types[j])
                {
                    var transport = _transports[type];
                    if (transport.accept(version, crossDomain, url) === true)
                    {
                        return transport;
                    }
                }
            }
        }
        return null;
    };

    this.add = function(type, transport, index)
    {
        var existing = false;
        for (var i = 0; i < _types.length; ++i)
        {
            if (_types[i] == type)
            {
                existing = true;
                break;
            }
        }

        if (!existing)
        {
            if (typeof index !== 'number')
            {
                _types.push(type);
            }
            else
            {
                _types.splice(index, 0, type);
            }
            _transports[type] = transport;
        }

        return !existing;
    };

    this.find = function(type)
    {
        for (var i = 0; i < _types.length; ++i)
        {
            if (_types[i] == type)
            {
                return _transports[type];
            }
        }
        return null;
    };

    this.remove = function(type)
    {
        for (var i = 0; i < _types.length; ++i)
        {
            if (_types[i] == type)
            {
                _types.splice(i, 1);
                var transport = _transports[type];
                delete _transports[type];
                return transport;
            }
        }
        return null;
    };

    this.reset = function()
    {
        for (var i = 0; i < _types.length; ++i)
        {
            _transports[_types[i]].reset();
        }
    };
};

/**
 * Base object with the common functionality for transports.
 */
org.cometd.Transport = function()
{
    var _type;
    var _cometd;

    /**
     * Function invoked just after a transport has been successfully registered.
     * @param type the type of transport (for example 'long-polling')
     * @param cometd the cometd object this transport has been registered to
     * @see #unregistered()
     */
    this.registered = function(type, cometd)
    {
        _type = type;
        _cometd = cometd;
    };

    /**
     * Function invoked just after a transport has been successfully unregistered.
     * @see #registered(type, cometd)
     */
    this.unregistered = function()
    {
        _type = null;
        _cometd = null;
    };

    this._debug = function()
    {
        _cometd._debug.apply(_cometd, arguments);
    };

    this._mixin = function()
    {
        return _cometd._mixin.apply(_cometd, arguments);
    };

    this.getConfiguration = function()
    {
        return _cometd.getConfiguration();
    };

    this.getAdvice = function()
    {
        return _cometd.getAdvice();
    };

    this.setTimeout = function(funktion, delay)
    {
        return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
    };

    /**
     * Converts the given response into an array of bayeux messages
     * @param response the response to convert
     * @return an array of bayeux messages obtained by converting the response
     */
    this.convertToMessages = function (response)
    {
        if (org.cometd.Utils.isString(response))
        {
            try
            {
                return org.cometd.JSON.fromJSON(response);
            }
            catch(x)
            {
                this._debug('Could not convert to JSON the following string', '"' + response + '"');
                throw x;
            }
        }
        if (org.cometd.Utils.isArray(response))
        {
            return response;
        }
        if (response === undefined || response === null)
        {
            return [];
        }
        if (response instanceof Object)
        {
            return [response];
        }
        throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
    };

    /**
     * Returns whether this transport can work for the given version and cross domain communication case.
     * @param version a string indicating the transport version
     * @param crossDomain a boolean indicating whether the communication is cross domain
     * @return true if this transport can work for the given version and cross domain communication case,
     * false otherwise
     */
    this.accept = function(version, crossDomain, url)
    {
        throw 'Abstract';
    };

    /**
     * Returns the type of this transport.
     * @see #registered(type, cometd)
     */
    this.getType = function()
    {
        return _type;
    };

    this.send = function(envelope, metaConnect)
    {
        throw 'Abstract';
    };

    this.reset = function()
    {
        this._debug('Transport', _type, 'reset');
    };

    this.abort = function()
    {
        this._debug('Transport', _type, 'aborted');
    };

    this.toString = function()
    {
        return this.getType();
    };
};

org.cometd.Transport.derive = function(baseObject)
{
    function F() {}
    F.prototype = baseObject;
    return new F();
};

/**
 * Base object with the common functionality for transports based on requests.
 * The key responsibility is to allow at most 2 outstanding requests to the server,
 * to avoid that requests are sent behind a long poll.
 * To achieve this, we have one reserved request for the long poll, and all other
 * requests are serialized one after the other.
 */
org.cometd.RequestTransport = function()
{
    var _super = new org.cometd.Transport();
    var _self = org.cometd.Transport.derive(_super);
    var _requestIds = 0;
    var _metaConnectRequest = null;
    var _requests = [];
    var _envelopes = [];

    function _coalesceEnvelopes(envelope)
    {
        while (_envelopes.length > 0)
        {
            var envelopeAndRequest = _envelopes[0];
            var newEnvelope = envelopeAndRequest[0];
            var newRequest = envelopeAndRequest[1];
            if (newEnvelope.url === envelope.url &&
                    newEnvelope.sync === envelope.sync)
            {
                _envelopes.shift();
                envelope.messages = envelope.messages.concat(newEnvelope.messages);
                this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
                continue;
            }
            break;
        }
    }

    function _transportSend(envelope, request)
    {
        this.transportSend(envelope, request);
        request.expired = false;

        if (!envelope.sync)
        {
            var maxDelay = this.getConfiguration().maxNetworkDelay;
            var delay = maxDelay;
            if (request.metaConnect === true)
            {
                delay += this.getAdvice().timeout;
            }

            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);

            var self = this;
            request.timeout = this.setTimeout(function()
            {
                request.expired = true;
                if (request.xhr)
                {
                    request.xhr.abort();
                }
                var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
                self._debug(errorMessage);
                self.complete(request, false, request.metaConnect);
                envelope.onFailure(request.xhr, envelope.messages, 'timeout', errorMessage);
            }, delay);
        }
    }

    function _queueSend(envelope)
    {
        var requestId = ++_requestIds;
        var request = {
            id: requestId,
            metaConnect: false
        };

        // Consider the metaConnect requests which should always be present
        if (_requests.length < this.getConfiguration().maxConnections - 1)
        {
            _requests.push(request);
            _transportSend.call(this, envelope, request);
        }
        else
        {
            this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
            _envelopes.push([envelope, request]);
        }
    }

    function _metaConnectComplete(request)
    {
        var requestId = request.id;
        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId)
        {
            throw 'Longpoll request mismatch, completing request ' + requestId;
        }

        // Reset metaConnect request
        _metaConnectRequest = null;
    }

    function _complete(request, success)
    {
        var index = org.cometd.Utils.inArray(request, _requests);
        // The index can be negative if the request has been aborted
        if (index >= 0)
        {
            _requests.splice(index, 1);
        }

        if (_envelopes.length > 0)
        {
            var envelopeAndRequest = _envelopes.shift();
            var nextEnvelope = envelopeAndRequest[0];
            var nextRequest = envelopeAndRequest[1];
            this._debug('Transport dequeued request', nextRequest.id);
            if (success)
            {
                if (this.getConfiguration().autoBatch)
                {
                    _coalesceEnvelopes.call(this, nextEnvelope);
                }
                _queueSend.call(this, nextEnvelope);
                this._debug('Transport completed request', request.id, nextEnvelope);
            }
            else
            {
                // Keep the semantic of calling response callbacks asynchronously after the request
                var self = this;
                this.setTimeout(function()
                {
                    self.complete(nextRequest, false, nextRequest.metaConnect);
                    nextEnvelope.onFailure(nextRequest.xhr, nextEnvelope.messages, 'error', 'Previous request failed');
                }, 0);
            }
        }
    }

    _self.complete = function(request, success, metaConnect)
    {
        if (metaConnect)
        {
            _metaConnectComplete.call(this, request);
        }
        else
        {
            _complete.call(this, request, success);
        }
    };

    /**
     * Performs the actual send depending on the transport type details.
     * @param envelope the envelope to send
     * @param request the request information
     */
    _self.transportSend = function(envelope, request)
    {
        throw 'Abstract';
    };

    _self.transportSuccess = function(envelope, request, responses)
    {
        if (!request.expired)
        {
            clearTimeout(request.timeout);
            this.complete(request, true, request.metaConnect);
            if (responses && responses.length > 0)
            {
                envelope.onSuccess(responses);
            }
            else
            {
                envelope.onFailure(request.xhr, envelope.messages, 'Empty HTTP response');
            }
        }
    };

    _self.transportFailure = function(envelope, request, reason, exception)
    {
        if (!request.expired)
        {
            clearTimeout(request.timeout);
            this.complete(request, false, request.metaConnect);
            envelope.onFailure(request.xhr, envelope.messages, reason, exception);
        }
    };

    function _metaConnectSend(envelope)
    {
        if (_metaConnectRequest !== null)
        {
            throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
        }

        var requestId = ++_requestIds;
        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
        var request = {
            id: requestId,
            metaConnect: true
        };
        _transportSend.call(this, envelope, request);
        _metaConnectRequest = request;
    }

    _self.send = function(envelope, metaConnect)
    {
        if (metaConnect)
        {
            _metaConnectSend.call(this, envelope);
        }
        else
        {
            _queueSend.call(this, envelope);
        }
    };

    _self.abort = function()
    {
        _super.abort();
        for (var i = 0; i < _requests.length; ++i)
        {
            var request = _requests[i];
            this._debug('Aborting request', request);
            if (request.xhr)
            {
                request.xhr.abort();
            }
        }
        if (_metaConnectRequest)
        {
            this._debug('Aborting metaConnect request', _metaConnectRequest);
            if (_metaConnectRequest.xhr)
            {
                _metaConnectRequest.xhr.abort();
            }
        }
        this.reset();
    };

    _self.reset = function()
    {
        _super.reset();
        _metaConnectRequest = null;
        _requests = [];
        _envelopes = [];
    };

    return _self;
};

org.cometd.LongPollingTransport = function()
{
    var _super = new org.cometd.RequestTransport();
    var _self = org.cometd.Transport.derive(_super);
    // By default, support cross domain
    var _supportsCrossDomain = true;

    _self.accept = function(version, crossDomain, url)
    {
        return _supportsCrossDomain || !crossDomain;
    };

    _self.xhrSend = function(packet)
    {
        throw 'Abstract';
    };

    _self.transportSend = function(envelope, request)
    {
        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);

        var self = this;
        try
        {
            var sameStack = true;
            request.xhr = this.xhrSend({
                transport: this,
                url: envelope.url,
                sync: envelope.sync,
                headers: this.getConfiguration().requestHeaders,
                body: org.cometd.JSON.toJSON(envelope.messages),
                onSuccess: function(response)
                {
                    self._debug('Transport', self.getType(), 'received response', response);
                    var success = false;
                    try
                    {
                        var received = self.convertToMessages(response);
                        if (received.length === 0)
                        {
                            _supportsCrossDomain = false;
                            self.transportFailure(envelope, request, 'no response', null);
                        }
                        else
                        {
                            success = true;
                            self.transportSuccess(envelope, request, received);
                        }
                    }
                    catch(x)
                    {
                        self._debug(x);
                        if (!success)
                        {
                            _supportsCrossDomain = false;
                            self.transportFailure(envelope, request, 'bad response', x);
                        }
                    }
                },
                onError: function(reason, exception)
                {
                    _supportsCrossDomain = false;
                    if (sameStack)
                    {
                        // Keep the semantic of calling response callbacks asynchronously after the request
                        self.setTimeout(function()
                        {
                            self.transportFailure(envelope, request, reason, exception);
                        }, 0);
                    }
                    else
                    {
                        self.transportFailure(envelope, request, reason, exception);
                    }
                }
            });
            sameStack = false;
        }
        catch (x)
        {
            _supportsCrossDomain = false;
            // Keep the semantic of calling response callbacks asynchronously after the request
            this.setTimeout(function()
            {
                self.transportFailure(envelope, request, 'error', x);
            }, 0);
        }
    };

    _self.reset = function()
    {
        _super.reset();
        _supportsCrossDomain = true;
    };

    return _self;
};

org.cometd.CallbackPollingTransport = function()
{
    var _super = new org.cometd.RequestTransport();
    var _self = org.cometd.Transport.derive(_super);
    var _maxLength = 2000;

    _self.accept = function(version, crossDomain, url)
    {
        return true;
    };

    _self.jsonpSend = function(packet)
    {
        throw 'Abstract';
    };

    _self.transportSend = function(envelope, request)
    {
        var self = this;

        // Microsoft Internet Explorer has a 2083 URL max length
        // We must ensure that we stay within that length
        var start = 0;
        var length = envelope.messages.length;
        var lengths = [];
        while (length > 0)
        {
            // Encode the messages because all brackets, quotes, commas, colons, etc
            // present in the JSON will be URL encoded, taking many more characters
            var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length));
            var urlLength = envelope.url.length + encodeURI(json).length;

            // Let's stay on the safe side and use 2000 instead of 2083
            // also because we did not count few characters among which
            // the parameter name 'message' and the parameter 'jsonp',
            // which sum up to about 50 chars
            if (urlLength > _maxLength)
            {
                if (length == 1)
                {
                    var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + _maxLength + ') ' +
                            'for transport ' + this.getType();
                    // Keep the semantic of calling response callbacks asynchronously after the request
                    this.setTimeout(function()
                    {
                        self.transportFailure(envelope, request, 'error', x);
                    }, 0);
                    return;
                }

                --length;
                continue;
            }

            lengths.push(length);
            start += length;
            length = envelope.messages.length - start;
        }

        // Here we are sure that the messages can be sent within the URL limit

        var envelopeToSend = envelope;
        if (lengths.length > 1)
        {
            var begin = 0;
            var end = lengths[0];
            this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
            envelopeToSend = this._mixin(false, {}, envelope);
            envelopeToSend.messages = envelope.messages.slice(begin, end);
            envelopeToSend.onSuccess = envelope.onSuccess;
            envelopeToSend.onFailure = envelope.onFailure;

            for (var i = 1; i < lengths.length; ++i)
            {
                var nextEnvelope = this._mixin(false, {}, envelope);
                begin = end;
                end += lengths[i];
                nextEnvelope.messages = envelope.messages.slice(begin, end);
                nextEnvelope.onSuccess = envelope.onSuccess;
                nextEnvelope.onFailure = envelope.onFailure;
                this.send(nextEnvelope, request.metaConnect);
            }
        }

        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);

        try
        {
            var sameStack = true;
            this.jsonpSend({
                transport: this,
                url: envelopeToSend.url,
                sync: envelopeToSend.sync,
                headers: this.getConfiguration().requestHeaders,
                body: org.cometd.JSON.toJSON(envelopeToSend.messages),
                onSuccess: function(responses)
                {
                    var success = false;
                    try
                    {
                        var received = self.convertToMessages(responses);
                        if (received.length === 0)
                        {
                            self.transportFailure(envelopeToSend, request, 'no response');
                        }
                        else
                        {
                            success=true;
                            self.transportSuccess(envelopeToSend, request, received);
                        }
                    }
                    catch (x)
                    {
                        self._debug(x);
                        if (!success)
                        {
                            self.transportFailure(envelopeToSend, request, 'bad response', x);
                        }
                    }
                },
                onError: function(reason, exception)
                {
                    if (sameStack)
                    {
                        // Keep the semantic of calling response callbacks asynchronously after the request
                        self.setTimeout(function()
                        {
                            self.transportFailure(envelopeToSend, request, reason, exception);
                        }, 0);
                    }
                    else
                    {
                        self.transportFailure(envelopeToSend, request, reason, exception);
                    }
                }
            });
            sameStack = false;
        }
        catch (xx)
        {
            // Keep the semantic of calling response callbacks asynchronously after the request
            this.setTimeout(function()
            {
                self.transportFailure(envelopeToSend, request, 'error', xx);
            }, 0);
        }
    };

    return _self;
};

org.cometd.WebSocketTransport = function()
{
    var OPENED = 1;
    var CLOSED = 2;

    var _super = new org.cometd.Transport();
    var _self = org.cometd.Transport.derive(_super);
    var _cometd;
    // By default, support WebSocket
    var _supportsWebSocket = true;
    var _webSocketSupported = false;
    var _state = CLOSED;
    var _timeouts = {};
    var _envelopes = {};
    var _webSocket;
    var _successCallback;

    _self.registered = function(type, cometd)
    {
        _super.registered(type, cometd);
        _cometd = cometd;
    };

    _self.accept = function(version, crossDomain, url)
    {
        // Using !! to return a boolean (and not the WebSocket object)
        return _supportsWebSocket && !!window.WebSocket && _cometd.websocketEnabled === true;
    };

    function _websocketSend(envelope, metaConnect)
    {
        try
        {
            var json = org.cometd.JSON.toJSON(envelope.messages);
            _webSocket.send(json);
            this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);

            // Manage the timeout waiting for the response
            var maxDelay = this.getConfiguration().maxNetworkDelay;
            var delay = maxDelay;
            if (metaConnect)
            {
                delay += this.getAdvice().timeout;
            }

            var messageIds = [];
            for (var i = 0; i < envelope.messages.length; ++i)
            {
                var message = envelope.messages[i];
                if (message.id)
                {
                    messageIds.push(message.id);
                    var self = this;
                    _timeouts[message.id] = this.setTimeout(function()
                    {
                        var errorMessage = 'Message ' + message.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
                        self._debug(errorMessage);

                        delete _timeouts[message.id];

                        for (var ids in _envelopes)
                        {
                            if (_envelopes[ids] === envelope)
                            {
                                delete _envelopes[ids];
                                break;
                            }
                        }
                        envelope.onFailure(_webSocket, envelope.messages, 'timeout', errorMessage);
                    }, delay);
                }
            }

            this._debug('Transport', this.getType(), 'waiting at most', delay, ' ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', _timeouts);
        }
        catch (x)
        {
            // Keep the semantic of calling response callbacks asynchronously after the request
            this.setTimeout(function()
            {
                envelope.onFailure(_webSocket, envelope.messages, 'error', x);
            }, 0);
        }
    }

    _self.onMessage = function(wsMessage)
    {
        this._debug('Transport', this.getType(), 'received websocket message', wsMessage);

        if (_state === OPENED)
        {
            var messages = this.convertToMessages(wsMessage.data);
            var messageIds = [];
            for (var i = 0; i < messages.length; ++i)
            {
                var message = messages[i];

                // Detect if the message is a response to a request we made.
                // If it's a meta message, for sure it's a response;
                // otherwise it's a publish message and publish responses lack the data field
                if (/^\/meta\//.test(message.channel) || message.data === undefined)
                {
                    if (message.id)
                    {
                        messageIds.push(message.id);

                        var timeout = _timeouts[message.id];
                        if (timeout)
                        {
                            clearTimeout(timeout);
                            delete _timeouts[message.id];
                            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', _timeouts);
                        }
                    }
                }

                if ('/meta/disconnect' === message.channel && message.successful)
                {
                    _webSocket.close();
                }
            }

            // Remove the envelope corresponding to the messages
            var removed = false;
            for (var j = 0; j < messageIds.length; ++j)
            {
                var id = messageIds[j];
                for (var key in _envelopes)
                {
                    var ids = key.split(',');
                    var index = org.cometd.Utils.inArray(id, ids);
                    if (index >= 0)
                    {
                        removed = true;
                        ids.splice(index, 1);
                        var envelope = _envelopes[key];
                        delete _envelopes[key];
                        if (ids.length > 0)
                        {
                            _envelopes[ids.join(',')] = envelope;
                        }
                        break;
                    }
                }
            }
            if (removed)
            {
                this._debug('Transport', this.getType(), 'removed envelope, envelopes', _envelopes);
            }

            _successCallback.call(this, messages);
        }
    };

    _self.onClose = function()
    {
        this._debug('Transport', this.getType(), 'closed', _webSocket);

        // Remember if we were able to connect
        // This close event could be due to server shutdown, and if it restarts we want to try websocket again
        _supportsWebSocket = _webSocketSupported;

        for (var id in _timeouts)
        {
            clearTimeout(_timeouts[id]);
            delete _timeouts[id];
        }

        for (var ids in _envelopes)
        {
            _envelopes[ids].onFailure(_webSocket, _envelopes[ids].messages, 'closed');
            delete _envelopes[ids];
        }

        _state = CLOSED;
    };

    _self.send = function(envelope, metaConnect)
    {
        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);

        // Store the envelope in any case; if the websocket cannot be opened, we fail it in close()
        var messageIds = [];
        for (var i = 0; i < envelope.messages.length; ++i)
        {
            var message = envelope.messages[i];
            if (message.id)
            {
                messageIds.push(message.id);
            }
        }
        _envelopes[messageIds.join(',')] = envelope;
        this._debug('Transport', this.getType(), 'stored envelope, envelopes', _envelopes);

        if (_state === OPENED)
        {
            _websocketSend.call(this, envelope, metaConnect);
        }
        else
        {
            // Mangle the URL, changing the scheme from 'http' to 'ws'
            var url = envelope.url.replace(/^http/, 'ws');
            this._debug('Transport', this.getType(), 'connecting to URL', url);

            _webSocket = new window.WebSocket(url);
            var self = this;
            _webSocket.onopen = function()
            {
                self._debug('WebSocket opened', _webSocket);
                _webSocketSupported = true;
                _state = OPENED;
                // Store the success callback, which is independent from the envelope,
                // so that it can be used to notify arrival of messages.
                _successCallback = envelope.onSuccess;
                _websocketSend.call(self, envelope, metaConnect);
            };
            _webSocket.onclose = function()
            {
                self.onClose();
            };
            _webSocket.onmessage = function(message)
            {
                self.onMessage(message);
            };
        }
    };

    _self.reset = function()
    {
        _super.reset();
        if (_webSocket)
        {
            _webSocket.close();
        }
        _supportsWebSocket = true;
        _webSocketSupported = false;
        _state = CLOSED;
        _timeouts = {};
        _envelopes = {};
        _webSocket = null;
        _successCallback = null;
    };

    return _self;
};

/**
 * The constructor for a Cometd object, identified by an optional name.
 * The default name is the string 'default'.
 * In the rare case a page needs more than one Bayeux conversation,
 * a new instance can be created via:
 * <pre>
 * var bayeuxUrl2 = ...;
 *
 * // Dojo style
 * var cometd2 = new dojox.Cometd('another_optional_name');
 *
 * // jQuery style
 * var cometd2 = new $.Cometd('another_optional_name');
 *
 * cometd2.init({url: bayeuxUrl2});
 * </pre>
 * @param name the optional name of this cometd object
 */
// IMPLEMENTATION NOTES:
// Be very careful in not changing the function order and pass this file every time through JSLint (http://jslint.com)
// The only implied globals must be "dojo", "org" and "window", and check that there are no "unused" warnings
// Failing to pass JSLint may result in shrinkers/minifiers to create an unusable file.
org.cometd.Cometd = function(name)
{
    var _cometd = this;
    var _name = name || 'default';
    var _crossDomain = false;
    var _transports = new org.cometd.TransportRegistry();
    var _transport;
    var _status = 'disconnected';
    var _messageId = 0;
    var _clientId = null;
    var _batch = 0;
    var _messageQueue = [];
    var _internalBatch = false;
    var _listeners = {};
    var _backoff = 0;
    var _scheduledSend = null;
    var _extensions = [];
    var _advice = {};
    var _handshakeProps;
    var _reestablish = false;
    var _connected = false;
    var _config = {
        maxConnections: 2,
        backoffIncrement: 1000,
        maxBackoff: 60000,
        logLevel: 'info',
        reverseIncomingExtensions: true,
        maxNetworkDelay: 10000,
        requestHeaders: {},
        appendMessageTypeToURL: true,
        autoBatch: false,
        advice: {
            timeout: 60000,
            interval: 0,
            reconnect: 'retry'
        }
    };

    /**
     * Mixes in the given objects into the target object by copying the properties.
     * @param deep if the copy must be deep
     * @param target the target object
     * @param objects the objects whose properties are copied into the target
     */
    function _mixin(deep, target, objects)
    {
        var result = target || {};

        // Skip first 2 parameters (deep and target), and loop over the others
        for (var i = 2; i < arguments.length; ++i)
        {
            var object = arguments[i];

            if (object === undefined || object === null)
            {
                continue;
            }

            for (var propName in object)
            {
                var prop = object[propName];

                // Avoid infinite loops
                if (prop === target)
                {
                    continue;
                }
                // Do not mixin undefined values
                if (prop === undefined)
                {
                    continue;
                }

                if (deep && typeof prop === 'object' && prop !== null)
                {
                    if (prop instanceof Array)
                    {
                        result[propName] = _mixin(deep, [], prop);
                    }
                    else
                    {
                        result[propName] = _mixin(deep, {}, prop);
                    }
                }
                else
                {
                    result[propName] = prop;
                }
            }
        }

        return result;
    }

    /**
     * This method is exposed as facility for extensions that may need to clone messages.
     */
    this._mixin = _mixin;

    function _isString(value)
    {
        return org.cometd.Utils.isString(value);
    }

    function _isFunction(value)
    {
        if (value === undefined || value === null)
        {
            return false;
        }
        return typeof value === 'function';
    }

    function _log(level, args)
    {
        if (window.console)
        {
            var logger = window.console[level];
            if (_isFunction(logger))
            {
                logger.apply(window.console, args);
            }
        }
    }

    function _warn()
    {
        _log('warn', arguments);
    }
    this._warn = _warn;

    function _info()
    {
        if (_config.logLevel != 'warn')
        {
            _log('info', arguments);
        }
    }
    this._info = _info;

    function _debug()
    {
        if (_config.logLevel == 'debug')
        {
            _log('debug', arguments);
        }
    }
    this._debug = _debug;

    function _configure(configuration)
    {
        _debug('Configuring cometd object with', configuration);
        // Support old style param, where only the Bayeux server URL was passed
        if (_isString(configuration))
        {
            configuration = { url: configuration };
        }
        if (!configuration)
        {
            configuration = {};
        }

        _config = _mixin(false, _config, configuration);

        if (!_config.url)
        {
            throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
        }

        // Check if we're cross domain
        // [1] = protocol:, [2] = //host:port, [3] = host:port, [4] = host, [5] = :port, [6] = port, [7] = uri, [8] = rest
        var urlParts = /(^https?:)?(\/\/(([^:\/\?#]+)(:(\d+))?))?([^\?#]*)(.*)?/.exec(_config.url);
        _crossDomain = urlParts[3] && urlParts[3] != window.location.host;

        // Check if appending extra path is supported
        if (_config.appendMessageTypeToURL)
        {
            if (urlParts[8] !== undefined && urlParts[8].length > 0)
            {
                _info('Appending message type to URI ' + urlParts[7] + urlParts[8] + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
                _config.appendMessageTypeToURL = false;
            }
            else
            {
                var uriSegments = urlParts[7].split('/');
                var lastSegmentIndex = uriSegments.length - 1;
                if (urlParts[7].match(/\/$/))
                {
                    lastSegmentIndex -= 1;
                }
                if (uriSegments[lastSegmentIndex].indexOf('.') >= 0)
                {
                    // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd
                    // It will be difficult to add the extra path in this case
                    _info('Appending message type to URI ' + urlParts[7] + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
                    _config.appendMessageTypeToURL = false;
                }
            }
        }
    }

    function _clearSubscriptions()
    {
        for (var channel in _listeners)
        {
            var subscriptions = _listeners[channel];
            for (var i = 0; i < subscriptions.length; ++i)
            {
                var subscription = subscriptions[i];
                if (subscription && !subscription.listener)
                {
                    delete subscriptions[i];
                    _debug('Removed subscription', subscription, 'for channel', channel);
                }
            }
        }
    }

    function _setStatus(newStatus)
    {
        if (_status != newStatus)
        {
            _debug('Status', _status, '->', newStatus);
            _status = newStatus;
        }
    }

    function _isDisconnected()
    {
        return _status == 'disconnecting' || _status == 'disconnected';
    }

    function _nextMessageId()
    {
        return ++_messageId;
    }

    function _applyExtension(scope, callback, name, message, outgoing)
    {
        try
        {
            return callback.call(scope, message);
        }
        catch (x)
        {
            _debug('Exception during execution of extension', name, x);
            var exceptionCallback = _cometd.onExtensionException;
            if (_isFunction(exceptionCallback))
            {
                _debug('Invoking extension exception callback', name, x);
                try
                {
                    exceptionCallback.call(_cometd, x, name, outgoing, message);
                }
                catch(xx)
                {
                    _info('Exception during execution of exception callback in extension', name, xx);
                }
            }
            return message;
        }
    }

    function _applyIncomingExtensions(message)
    {
        for (var i = 0; i < _extensions.length; ++i)
        {
            if (message === undefined || message === null)
            {
                break;
            }

            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
            var extension = _extensions[index];
            var callback = extension.extension.incoming;
            if (_isFunction(callback))
            {
                var result = _applyExtension(extension.extension, callback, extension.name, message, false);
                message = result === undefined ? message : result;
            }
        }
        return message;
    }

    function _applyOutgoingExtensions(message)
    {
        for (var i = 0; i < _extensions.length; ++i)
        {
            if (message === undefined || message === null)
            {
                break;
            }

            var extension = _extensions[i];
            var callback = extension.extension.outgoing;
            if (_isFunction(callback))
            {
                var result = _applyExtension(extension.extension, callback, extension.name, message, true);
                message = result === undefined ? message : result;
            }
        }
        return message;
    }

    function _notify(channel, message)
    {
        var subscriptions = _listeners[channel];
        if (subscriptions && subscriptions.length > 0)
        {
            for (var i = 0; i < subscriptions.length; ++i)
            {
                var subscription = subscriptions[i];
                // Subscriptions may come and go, so the array may have 'holes'
                if (subscription)
                {
                    try
                    {
                        subscription.callback.call(subscription.scope, message);
                    }
                    catch (x)
                    {
                        _debug('Exception during notification', subscription, message, x);
                        var listenerCallback = _cometd.onListenerException;
                        if (_isFunction(listenerCallback))
                        {
                            _debug('Invoking listener exception callback', subscription, x);
                            try
                            {
                                listenerCallback.call(_cometd, x, subscription.handle, subscription.listener, message);
                            }
                            catch (xx)
                            {
                                _info('Exception during execution of listener callback', subscription, xx);
                            }
                        }
                    }
                }
            }
        }
    }

    function _notifyListeners(channel, message)
    {
        // Notify direct listeners
        _notify(channel, message);

        // Notify the globbing listeners
        var channelParts = channel.split('/');
        var last = channelParts.length - 1;
        for (var i = last; i > 0; --i)
        {
            var channelPart = channelParts.slice(0, i).join('/') + '/*';
            // We don't want to notify /foo/* if the channel is /foo/bar/baz,
            // so we stop at the first non recursive globbing
            if (i == last)
            {
                _notify(channelPart, message);
            }
            // Add the recursive globber and notify
            channelPart += '*';
            _notify(channelPart, message);
        }
    }

    function _cancelDelayedSend()
    {
        if (_scheduledSend !== null)
        {
            clearTimeout(_scheduledSend);
        }
        _scheduledSend = null;
    }

    function _delayedSend(operation)
    {
        _cancelDelayedSend();
        var delay = _advice.interval + _backoff;
        _debug('Function scheduled in', delay, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
        _scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
    }

    // Needed to break cyclic dependencies between function definitions
    var _handleMessages;
    var _handleFailure;

    /**
     * Delivers the messages to the CometD server
     * @param messages the array of messages to send
     * @param longpoll true if this send is a long poll
     */
    function _send(sync, messages, longpoll, extraPath)
    {
        // We must be sure that the messages have a clientId.
        // This is not guaranteed since the handshake may take time to return
        // (and hence the clientId is not known yet) and the application
        // may create other messages.
        for (var i = 0; i < messages.length; ++i)
        {
            var message = messages[i];
            message.id = '' + _nextMessageId();
            if (_clientId)
            {
                message.clientId = _clientId;
            }
            message = _applyOutgoingExtensions(message);
            if (message !== undefined && message !== null)
            {
                messages[i] = message;
            }
            else
            {
                messages.splice(i--, 1);
            }
        }
        if (messages.length === 0)
        {
            return;
        }

        var url = _config.url;
        if (_config.appendMessageTypeToURL)
        {
            // If url does not end with '/', then append it
            if (!url.match(/\/$/))
            {
                url = url + '/';
            }
            if (extraPath)
            {
                url = url + extraPath;
            }
        }

        var envelope = {
            url: url,
            sync: sync,
            messages: messages,
            onSuccess: function(rcvdMessages)
            {
                try
                {
                    _handleMessages.call(_cometd, rcvdMessages);
                }
                catch (x)
                {
                    _debug('Exception during handling of messages', x);
                }
            },
            onFailure: function(conduit, messages, reason, exception)
            {
                try
                {
                    _handleFailure.call(_cometd, conduit, messages, reason, exception);
                }
                catch (x)
                {
                    _debug('Exception during handling of failure', x);
                }
            }
        };
        _debug('Send', envelope);
        _transport.send(envelope, longpoll);
    }

    function _queueSend(message)
    {
        if (_batch > 0 || _internalBatch === true)
        {
            _messageQueue.push(message);
        }
        else
        {
            _send(false, [message], false);
        }
    }

    /**
     * Sends a complete bayeux message.
     * This method is exposed as a public so that extensions may use it
     * to send bayeux message directly, for example in case of re-sending
     * messages that have already been sent but that for some reason must
     * be resent.
     */
    this.send = _queueSend;

    function _resetBackoff()
    {
        _backoff = 0;
    }

    function _increaseBackoff()
    {
        if (_backoff < _config.maxBackoff)
        {
            _backoff += _config.backoffIncrement;
        }
    }

    /**
     * Starts a the batch of messages to be sent in a single request.
     * @see #_endBatch(sendMessages)
     */
    function _startBatch()
    {
        ++_batch;
    }

    function _flushBatch()
    {
        var messages = _messageQueue;
        _messageQueue = [];
        if (messages.length > 0)
        {
            _send(false, messages, false);
        }
    }

    /**
     * Ends the batch of messages to be sent in a single request,
     * optionally sending messages present in the message queue depending
     * on the given argument.
     * @see #_startBatch()
     */
    function _endBatch()
    {
        --_batch;
        if (_batch < 0)
        {
            throw 'Calls to startBatch() and endBatch() are not paired';
        }

        if (_batch === 0 && !_isDisconnected() && !_internalBatch)
        {
            _flushBatch();
        }
    }

    /**
     * Sends the connect message
     */
    function _connect()
    {
        if (!_isDisconnected())
        {
            var message = {
                channel: '/meta/connect',
                connectionType: _transport.getType()
            };

            // In case of reload or temporary loss of connection
            // we want the next successful connect to return immediately
            // instead of being held by the server, so that connect listeners
            // can be notified that the connection has been re-established
            if (!_connected)
            {
                message.advice = { timeout: 0 };
            }

            _setStatus('connecting');
            _debug('Connect sent', message);
            _send(false, [message], true, 'connect');
            _setStatus('connected');
        }
    }

    function _delayedConnect()
    {
        _setStatus('connecting');
        _delayedSend(function()
        {
            _connect();
        });
    }

    function _updateAdvice(newAdvice)
    {
        if (newAdvice)
        {
            _advice = _mixin(false, {}, _config.advice, newAdvice);
            _debug('New advice', _advice);
        }
    }

    function _disconnect(abort)
    {
        _cancelDelayedSend();
        if (abort)
        {
            _transport.abort();
        }
        _clientId = null;
        _setStatus('disconnected');
        _batch = 0;
        _resetBackoff();

        // Fail any existing queued message
        if (_messageQueue.length > 0)
        {
            _handleFailure.call(_cometd, undefined, _messageQueue, 'error', 'Disconnected');
            _messageQueue = [];
        }
    }

    /**
     * Sends the initial handshake message
     */
    function _handshake(handshakeProps)
    {
        _clientId = null;

        _clearSubscriptions();

        // Reset the transports if we're not retrying the handshake
        if (_isDisconnected())
        {
            _transports.reset();
            _updateAdvice(_config.advice);
        }
        else
        {
            // We are retrying the handshake, either because another handshake failed
            // and we're backing off, or because the server timed us out and asks us to
            // re-handshake: in both cases, make sure that if the handshake succeeds
            // the next action is a connect.
            _updateAdvice(_mixin(false, _advice, {reconnect: 'retry'}));
        }

        _batch = 0;

        // Mark the start of an internal batch.
        // This is needed because handshake and connect are async.
        // It may happen that the application calls init() then subscribe()
        // and the subscribe message is sent before the connect message, if
        // the subscribe message is not held until the connect message is sent.
        // So here we start a batch to hold temporarily any message until
        // the connection is fully established.
        _internalBatch = true;

        // Save the properties provided by the user, so that
        // we can reuse them during automatic re-handshake
        _handshakeProps = handshakeProps;

        var version = '1.0';

        // Figure out the transports to send to the server
        var transportTypes = _transports.findTransportTypes(version, _crossDomain, _config.url);

        var bayeuxMessage = {
            version: version,
            minimumVersion: '0.9',
            channel: '/meta/handshake',
            supportedConnectionTypes: transportTypes,
            advice: {
                timeout: _advice.timeout,
                interval: _advice.interval
            }
        };
        // Do not allow the user to mess with the required properties,
        // so merge first the user properties and *then* the bayeux message
        var message = _mixin(false, {}, _handshakeProps, bayeuxMessage);

        // Pick up the first available transport as initial transport
        // since we don't know if the server supports it
        _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, _config.url);
        _debug('Initial transport is', _transport.getType());

        // We started a batch to hold the application messages,
        // so here we must bypass it and send immediately.
        _setStatus('handshaking');
        _debug('Handshake sent', message);
        _send(false, [message], false, 'handshake');
    }

    function _delayedHandshake()
    {
        _setStatus('handshaking');

        // We will call _handshake() which will reset _clientId, but we want to avoid
        // that between the end of this method and the call to _handshake() someone may
        // call publish() (or other methods that call _queueSend()).
        _internalBatch = true;

        _delayedSend(function()
        {
            _handshake(_handshakeProps);
        });
    }

    function _failHandshake(message)
    {
        _notifyListeners('/meta/handshake', message);
        _notifyListeners('/meta/unsuccessful', message);

        // Only try again if we haven't been disconnected and
        // the advice permits us to retry the handshake
        var retry = !_isDisconnected() && _advice.reconnect != 'none';
        if (retry)
        {
            _increaseBackoff();
            _delayedHandshake();
        }
        else
        {
            _disconnect(false);
        }
    }

    function _handshakeResponse(message)
    {
        if (message.successful)
        {
            // Save clientId, figure out transport, then follow the advice to connect
            _clientId = message.clientId;

            var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, _config.url);
            if (newTransport === null)
            {
                throw 'Could not negotiate transport with server; client ' +
                      _transports.findTransportTypes(message.version, _crossDomain, _config.url) +
                      ', server ' + message.supportedConnectionTypes;
            }
            else if (_transport != newTransport)
            {
                _debug('Transport', _transport, '->', newTransport);
                _transport = newTransport;
            }

            // End the internal batch and allow held messages from the application
            // to go to the server (see _handshake() where we start the internal batch).
            _internalBatch = false;
            _flushBatch();

            // Here the new transport is in place, as well as the clientId, so
            // the listeners can perform a publish() if they want.
            // Notify the listeners before the connect below.
            message.reestablish = _reestablish;
            _reestablish = true;
            _notifyListeners('/meta/handshake', message);

            var action = _isDisconnected() ? 'none' : _advice.reconnect;
            switch (action)
            {
                case 'retry':
                    _resetBackoff();
                    _delayedConnect();
                    break;
                case 'none':
                    _disconnect(false);
                    break;
                default:
                    throw 'Unrecognized advice action ' + action;
            }
        }
        else
        {
            _failHandshake(message);
        }
    }

    function _handshakeFailure(xhr, message)
    {
        _failHandshake({
            successful: false,
            failure: true,
            channel: '/meta/handshake',
            request: message,
            xhr: xhr,
            advice: {
                reconnect: 'retry',
                interval: _backoff
            }
        });
    }

    function _failConnect(message)
    {
        // Notify the listeners after the status change but before the next action
        _notifyListeners('/meta/connect', message);
        _notifyListeners('/meta/unsuccessful', message);

        // This may happen when the server crashed, the current clientId
        // will be invalid, and the server will ask to handshake again
        // Listeners can call disconnect(), so check the state after they run
        var action = _isDisconnected() ? 'none' : _advice.reconnect;
        switch (action)
        {
            case 'retry':
                _increaseBackoff();
                _delayedConnect();
                break;
            case 'handshake':
                // The current transport may be failed (e.g. network disconnection)
                // Reset the transports so the new handshake picks up the right one
                _transports.reset();
                _resetBackoff();
                _delayedHandshake();
                break;
            case 'none':
                _disconnect(false);
                break;
            default:
                throw 'Unrecognized advice action' + action;
        }
    }

    function _connectResponse(message)
    {
        _connected = message.successful;

        if (_connected)
        {
            _notifyListeners('/meta/connect', message);

            // Normally, the advice will say "reconnect: 'retry', interval: 0"
            // and the server will hold the request, so when a response returns
            // we immediately call the server again (long polling)
            // Listeners can call disconnect(), so check the state after they run
            var action = _isDisconnected() ? 'none' : _advice.reconnect;
            switch (action)
            {
                case 'retry':
                    _resetBackoff();
                    _delayedConnect();
                    break;
                case 'none':
                    _disconnect(false);
                    break;
                default:
                    throw 'Unrecognized advice action ' + action;
            }
        }
        else
        {
            _failConnect(message);
        }
    }

    function _connectFailure(xhr, message)
    {
        _connected = false;
        _failConnect({
            successful: false,
            failure: true,
            channel: '/meta/connect',
            request: message,
            xhr: xhr,
            advice: {
                reconnect: 'retry',
                interval: _backoff
            }
        });
    }

    function _failDisconnect(message)
    {
        _disconnect(true);
        _notifyListeners('/meta/disconnect', message);
        _notifyListeners('/meta/unsuccessful', message);
    }

    function _disconnectResponse(message)
    {
        if (message.successful)
        {
            _disconnect(false);
            _notifyListeners('/meta/disconnect', message);
        }
        else
        {
            _failDisconnect(message);
        }
    }

    function _disconnectFailure(xhr, message)
    {
        _failDisconnect({
            successful: false,
            failure: true,
            channel: '/meta/disconnect',
            request: message,
            xhr: xhr,
            advice: {
                reconnect: 'none',
                interval: 0
            }
        });
    }

    function _failSubscribe(message)
    {
        _notifyListeners('/meta/subscribe', message);
        _notifyListeners('/meta/unsuccessful', message);
    }

    function _subscribeResponse(message)
    {
        if (message.successful)
        {
            _notifyListeners('/meta/subscribe', message);
        }
        else
        {
            _failSubscribe(message);
        }
    }

    function _subscribeFailure(xhr, message)
    {
        _failSubscribe({
            successful: false,
            failure: true,
            channel: '/meta/subscribe',
            request: message,
            xhr: xhr,
            advice: {
                reconnect: 'none',
                interval: 0
            }
        });
    }

    function _failUnsubscribe(message)
    {
        _notifyListeners('/meta/unsubscribe', message);
        _notifyListeners('/meta/unsuccessful', message);
    }

    function _unsubscribeResponse(message)
    {
        if (message.successful)
        {
            _notifyListeners('/meta/unsubscribe', message);
        }
        else
        {
            _failUnsubscribe(message);
        }
    }

    function _unsubscribeFailure(xhr, message)
    {
        _failUnsubscribe({
            successful: false,
            failure: true,
            channel: '/meta/unsubscribe',
            request: message,
            xhr: xhr,
            advice: {
                reconnect: 'none',
                interval: 0
            }
        });
    }

    function _failMessage(message)
    {
        _notifyListeners('/meta/publish', message);
        _notifyListeners('/meta/unsuccessful', message);
    }

    function _messageResponse(message)
    {
        if (message.successful === undefined)
        {
            if (message.data)
            {
                // It is a plain message, and not a bayeux meta message
                _notifyListeners(message.channel, message);
            }
            else
            {
                _debug('Unknown message', message);
            }
        }
        else
        {
            if (message.successful)
            {
                _notifyListeners('/meta/publish', message);
            }
            else
            {
                _failMessage(message);
            }
        }
    }

    function _messageFailure(xhr, message)
    {
        _failMessage({
            successful: false,
            failure: true,
            channel: message.channel,
            request: message,
            xhr: xhr,
            advice: {
                reconnect: 'none',
                interval: 0
            }
        });
    }

    function _receive(message)
    {
        message = _applyIncomingExtensions(message);
        if (message === undefined || message === null)
        {
            return;
        }

        _updateAdvice(message.advice);

        var channel = message.channel;
        switch (channel)
        {
            case '/meta/handshake':
                _handshakeResponse(message);
                break;
            case '/meta/connect':
                _connectResponse(message);
                break;
            case '/meta/disconnect':
                _disconnectResponse(message);
                break;
            case '/meta/subscribe':
                _subscribeResponse(message);
                break;
            case '/meta/unsubscribe':
                _unsubscribeResponse(message);
                break;
            default:
                _messageResponse(message);
                break;
        }
    }

    /**
     * Receives a message.
     * This method is exposed as a public so that extensions may inject
     * messages simulating that they had been received.
     */
    this.receive = _receive;

    _handleMessages = function _handleMessages(rcvdMessages)
    {
        _debug('Received', rcvdMessages);

        for (var i = 0; i < rcvdMessages.length; ++i)
        {
            var message = rcvdMessages[i];
            _receive(message);
        }
    };

    _handleFailure = function _handleFailure(conduit, messages, reason, exception)
    {
        _debug('handleFailure', conduit, messages, reason, exception);

        for (var i = 0; i < messages.length; ++i)
        {
            var message = messages[i];
            var channel = message.channel;
            switch (channel)
            {
                case '/meta/handshake':
                    _handshakeFailure(conduit, message);
                    break;
                case '/meta/connect':
                    _connectFailure(conduit, message);
                    break;
                case '/meta/disconnect':
                    _disconnectFailure(conduit, message);
                    break;
                case '/meta/subscribe':
                    _subscribeFailure(conduit, message);
                    break;
                case '/meta/unsubscribe':
                    _unsubscribeFailure(conduit, message);
                    break;
                default:
                    _messageFailure(conduit, message);
                    break;
            }
        }
    };

    function _hasSubscriptions(channel)
    {
        var subscriptions = _listeners[channel];
        if (subscriptions)
        {
            for (var i = 0; i < subscriptions.length; ++i)
            {
                if (subscriptions[i])
                {
                    return true;
                }
            }
        }
        return false;
    }

    function _resolveScopedCallback(scope, callback)
    {
        var delegate = {
            scope: scope,
            method: callback
        };
        if (_isFunction(scope))
        {
            delegate.scope = undefined;
            delegate.method = scope;
        }
        else
        {
            if (_isString(callback))
            {
                if (!scope)
                {
                    throw 'Invalid scope ' + scope;
                }
                delegate.method = scope[callback];
                if (!_isFunction(delegate.method))
                {
                    throw 'Invalid callback ' + callback + ' for scope ' + scope;
                }
            }
            else if (!_isFunction(callback))
            {
                throw 'Invalid callback ' + callback;
            }
        }
        return delegate;
    }

    function _addListener(channel, scope, callback, isListener)
    {
        // The data structure is a map<channel, subscription[]>, where each subscription
        // holds the callback to be called and its scope.

        var delegate = _resolveScopedCallback(scope, callback);
        _debug('Adding listener on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);

        var subscription = {
            channel: channel,
            scope: delegate.scope,
            callback: delegate.method,
            listener: isListener
        };

        var subscriptions = _listeners[channel];
        if (!subscriptions)
        {
            subscriptions = [];
            _listeners[channel] = subscriptions;
        }

        // Pushing onto an array appends at the end and returns the id associated with the element increased by 1.
        // Note that if:
        // a.push('a'); var hb=a.push('b'); delete a[hb-1]; var hc=a.push('c');
        // then:
        // hc==3, a.join()=='a',,'c', a.length==3
        var subscriptionID = subscriptions.push(subscription) - 1;
        subscription.id = subscriptionID;
        subscription.handle = [channel, subscriptionID];

        _debug('Added listener', subscription, 'for channel', channel, 'having id =', subscriptionID);

        // The subscription to allow removal of the listener is made of the channel and the index
        return subscription.handle;
    }

    function _removeListener(subscription)
    {
        var subscriptions = _listeners[subscription[0]];
        if (subscriptions)
        {
            delete subscriptions[subscription[1]];
            _debug('Removed listener', subscription);
        }
    }

    //
    // PUBLIC API
    //

    /**
     * Registers the given transport under the given transport type.
     * The optional index parameter specifies the "priority" at which the
     * transport is registered (where 0 is the max priority).
     * If a transport with the same type is already registered, this function
     * does nothing and returns false.
     * @param type the transport type
     * @param transport the transport object
     * @param index the index at which this transport is to be registered
     * @return true if the transport has been registered, false otherwise
     * @see #unregisterTransport(type)
     */
    this.registerTransport = function(type, transport, index)
    {
        var result = _transports.add(type, transport, index);
        if (result)
        {
            _debug('Registered transport', type);

            if (_isFunction(transport.registered))
            {
                transport.registered(type, this);
            }
        }
        return result;
    };

    /**
     * @return an array of all registered transport types
     */
    this.getTransportTypes = function()
    {
        return _transports.getTransportTypes();
    };

    /**
     * Unregisters the transport with the given transport type.
     * @param type the transport type to unregister
     * @return the transport that has been unregistered,
     * or null if no transport was previously registered under the given transport type
     */
    this.unregisterTransport = function(type)
    {
        var transport = _transports.remove(type);
        if (transport !== null)
        {
            _debug('Unregistered transport', type);

            if (_isFunction(transport.unregistered))
            {
                transport.unregistered();
            }
        }
        return transport;
    };

    this.findTransport = function(name)
    {
        return _transports.find(name);
    };

    /**
     * Configures the initial Bayeux communication with the Bayeux server.
     * Configuration is passed via an object that must contain a mandatory field <code>url</code>
     * of type string containing the URL of the Bayeux server.
     * @param configuration the configuration object
     */
    this.configure = function(configuration)
    {
        _configure.call(this, configuration);
    };

    /**
     * Configures and establishes the Bayeux communication with the Bayeux server
     * via a handshake and a subsequent connect.
     * @param configuration the configuration object
     * @param handshakeProps an object to be merged with the handshake message
     * @see #configure(configuration)
     * @see #handshake(handshakeProps)
     */
    this.init = function(configuration, handshakeProps)
    {
        this.configure(configuration);
        this.handshake(handshakeProps);
    };

    /**
     * Establishes the Bayeux communication with the Bayeux server
     * via a handshake and a subsequent connect.
     * @param handshakeProps an object to be merged with the handshake message
     */
    this.handshake = function(handshakeProps)
    {
        _setStatus('disconnected');
        _reestablish = false;
        _handshake(handshakeProps);
    };

    /**
     * Disconnects from the Bayeux server.
     * It is possible to suggest to attempt a synchronous disconnect, but this feature
     * may only be available in certain transports (for example, long-polling may support
     * it, callback-polling certainly does not).
     * @param sync whether attempt to perform a synchronous disconnect
     * @param disconnectProps an object to be merged with the disconnect message
     */
    this.disconnect = function(sync, disconnectProps)
    {
        if (_isDisconnected())
        {
            return;
        }

        if (disconnectProps === undefined)
        {
            if (typeof sync !== 'boolean')
            {
                disconnectProps = sync;
                sync = false;
            }
        }

        var bayeuxMessage = {
            channel: '/meta/disconnect'
        };
        var message = _mixin(false, {}, disconnectProps, bayeuxMessage);
        _setStatus('disconnecting');
        _send(sync === true, [message], false, 'disconnect');
    };

    /**
     * Marks the start of a batch of application messages to be sent to the server
     * in a single request, obtaining a single response containing (possibly) many
     * application reply messages.
     * Messages are held in a queue and not sent until {@link #endBatch()} is called.
     * If startBatch() is called multiple times, then an equal number of endBatch()
     * calls must be made to close and send the batch of messages.
     * @see #endBatch()
     */
    this.startBatch = function()
    {
        _startBatch();
    };

    /**
     * Marks the end of a batch of application messages to be sent to the server
     * in a single request.
     * @see #startBatch()
     */
    this.endBatch = function()
    {
        _endBatch();
    };

    /**
     * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}
     * and {@link #endBatch()} calls.
     * @param scope the scope of the callback, may be omitted
     * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls
     */
    this.batch = function(scope, callback)
    {
        var delegate = _resolveScopedCallback(scope, callback);
        this.startBatch();
        try
        {
            delegate.method.call(delegate.scope);
            this.endBatch();
        }
        catch (x)
        {
            _debug('Exception during execution of batch', x);
            this.endBatch();
            throw x;
        }
    };

    /**
     * Adds a listener for bayeux messages, performing the given callback in the given scope
     * when a message for the given channel arrives.
     * @param channel the channel the listener is interested to
     * @param scope the scope of the callback, may be omitted
     * @param callback the callback to call when a message is sent to the channel
     * @returns the subscription handle to be passed to {@link #removeListener(object)}
     * @see #removeListener(subscription)
     */
    this.addListener = function(channel, scope, callback)
    {
        if (arguments.length < 2)
        {
            throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(channel))
        {
            throw 'Illegal argument type: channel must be a string';
        }

        return _addListener(channel, scope, callback, true);
    };

    /**
     * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.
     * @param subscription the subscription to unsubscribe.
     * @see #addListener(channel, scope, callback)
     */
    this.removeListener = function(subscription)
    {
        if (!org.cometd.Utils.isArray(subscription))
        {
            throw 'Invalid argument: expected subscription, not ' + subscription;
        }

        _removeListener(subscription);
    };

    /**
     * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or
     * {@link #subscribe(channel, scope, callback)}.
     */
    this.clearListeners = function()
    {
        _listeners = {};
    };

    /**
     * Subscribes to the given channel, performing the given callback in the given scope
     * when a message for the channel arrives.
     * @param channel the channel to subscribe to
     * @param scope the scope of the callback, may be omitted
     * @param callback the callback to call when a message is sent to the channel
     * @param subscribeProps an object to be merged with the subscribe message
     * @return the subscription handle to be passed to {@link #unsubscribe(object)}
     */
    this.subscribe = function(channel, scope, callback, subscribeProps)
    {
        if (arguments.length < 2)
        {
            throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(channel))
        {
            throw 'Illegal argument type: channel must be a string';
        }
        if (_isDisconnected())
        {
            throw 'Illegal state: already disconnected';
        }

        // Normalize arguments
        if (_isFunction(scope))
        {
            subscribeProps = callback;
            callback = scope;
            scope = undefined;
        }

        // Only send the message to the server if this clientId has not yet subscribed to the channel
        var send = !_hasSubscriptions(channel);

        var subscription = _addListener(channel, scope, callback, false);

        if (send)
        {
            // Send the subscription message after the subscription registration to avoid
            // races where the server would send a message to the subscribers, but here
            // on the client the subscription has not been added yet to the data structures
            var bayeuxMessage = {
                channel: '/meta/subscribe',
                subscription: channel
            };
            var message = _mixin(false, {}, subscribeProps, bayeuxMessage);
            _queueSend(message);
        }

        return subscription;
    };

    /**
     * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.
     * @param subscription the subscription to unsubscribe.
     */
    this.unsubscribe = function(subscription, unsubscribeProps)
    {
        if (arguments.length < 1)
        {
            throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (_isDisconnected())
        {
            throw 'Illegal state: already disconnected';
        }

        // Remove the local listener before sending the message
        // This ensures that if the server fails, this client does not get notifications
        this.removeListener(subscription);

        var channel = subscription[0];
        // Only send the message to the server if this clientId unsubscribes the last subscription
        if (!_hasSubscriptions(channel))
        {
            var bayeuxMessage = {
                channel: '/meta/unsubscribe',
                subscription: channel
            };
            var message = _mixin(false, {}, unsubscribeProps, bayeuxMessage);
            _queueSend(message);
        }
    };

    /**
     * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},
     * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.
     */
    this.clearSubscriptions = function()
    {
        _clearSubscriptions();
    };

    /**
     * Publishes a message on the given channel, containing the given content.
     * @param channel the channel to publish the message to
     * @param content the content of the message
     * @param publishProps an object to be merged with the publish message
     */
    this.publish = function(channel, content, publishProps)
    {
        if (arguments.length < 1)
        {
            throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (!_isString(channel))
        {
            throw 'Illegal argument type: channel must be a string';
        }
        if (_isDisconnected())
        {
            throw 'Illegal state: already disconnected';
        }

        var bayeuxMessage = {
            channel: channel,
            data: content
        };
        var message = _mixin(false, {}, publishProps, bayeuxMessage);
        _queueSend(message);
    };

    /**
     * Returns a string representing the status of the bayeux communication with the Bayeux server.
     */
    this.getStatus = function()
    {
        return _status;
    };

    /**
     * Returns whether this instance has been disconnected.
     */
    this.isDisconnected = _isDisconnected;

    /**
     * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
     * Default value is 1 second, which means if there is a persistent failure the retries will happen
     * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of
     * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).
     * @param period the backoff period to set
     * @see #getBackoffIncrement()
     */
    this.setBackoffIncrement = function(period)
    {
        _config.backoffIncrement = period;
    };

    /**
     * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
     * @see #setBackoffIncrement(period)
     */
    this.getBackoffIncrement = function()
    {
        return _config.backoffIncrement;
    };

    /**
     * Returns the backoff period to wait before retrying an unsuccessful or failed message.
     */
    this.getBackoffPeriod = function()
    {
        return _backoff;
    };

    /**
     * Sets the log level for console logging.
     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
     * less verbose to more verbose.
     * @param level the log level string
     */
    this.setLogLevel = function(level)
    {
        _config.logLevel = level;
    };

    /**
     * Registers an extension whose callbacks are called for every incoming message
     * (that comes from the server to this client implementation) and for every
     * outgoing message (that originates from this client implementation for the
     * server).
     * The format of the extension object is the following:
     * <pre>
     * {
     *     incoming: function(message) { ... },
     *     outgoing: function(message) { ... }
     * }
     * </pre>
     * Both properties are optional, but if they are present they will be called
     * respectively for each incoming message and for each outgoing message.
     * @param name the name of the extension
     * @param extension the extension to register
     * @return true if the extension was registered, false otherwise
     * @see #unregisterExtension(name)
     */
    this.registerExtension = function(name, extension)
    {
        if (arguments.length < 2)
        {
            throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(name))
        {
            throw 'Illegal argument type: extension name must be a string';
        }

        var existing = false;
        for (var i = 0; i < _extensions.length; ++i)
        {
            var existingExtension = _extensions[i];
            if (existingExtension.name == name)
            {
                existing = true;
                break;
            }
        }
        if (!existing)
        {
            _extensions.push({
                name: name,
                extension: extension
            });
            _debug('Registered extension', name);

            // Callback for extensions
            if (_isFunction(extension.registered))
            {
                extension.registered(name, this);
            }

            return true;
        }
        else
        {
            _info('Could not register extension with name', name, 'since another extension with the same name already exists');
            return false;
        }
    };

    /**
     * Unregister an extension previously registered with
     * {@link #registerExtension(name, extension)}.
     * @param name the name of the extension to unregister.
     * @return true if the extension was unregistered, false otherwise
     */
    this.unregisterExtension = function(name)
    {
        if (!_isString(name))
        {
            throw 'Illegal argument type: extension name must be a string';
        }

        var unregistered = false;
        for (var i = 0; i < _extensions.length; ++i)
        {
            var extension = _extensions[i];
            if (extension.name == name)
            {
                _extensions.splice(i, 1);
                unregistered = true;
                _debug('Unregistered extension', name);

                // Callback for extensions
                var ext = extension.extension;
                if (_isFunction(ext.unregistered))
                {
                    ext.unregistered();
                }

                break;
            }
        }
        return unregistered;
    };

    /**
     * Find the extension registered with the given name.
     * @param name the name of the extension to find
     * @return the extension found or null if no extension with the given name has been registered
     */
    this.getExtension = function(name)
    {
        for (var i = 0; i < _extensions.length; ++i)
        {
            var extension = _extensions[i];
            if (extension.name == name)
            {
                return extension.extension;
            }
        }
        return null;
    };

    /**
     * Returns the name assigned to this Cometd object, or the string 'default'
     * if no name has been explicitly passed as parameter to the constructor.
     */
    this.getName = function()
    {
        return _name;
    };

    /**
     * Returns the clientId assigned by the Bayeux server during handshake.
     */
    this.getClientId = function()
    {
        return _clientId;
    };

    /**
     * Returns the URL of the Bayeux server.
     */
    this.getURL = function()
    {
        return _config.url;
    };

    this.getTransport = function()
    {
        return _transport;
    };

    this.getConfiguration = function()
    {
        return _mixin(true, {}, _config);
    };

    this.getAdvice = function()
    {
        return _mixin(true, {}, _advice);
    };
};
//static-content-hash-trigger-GCC
/**
 * Dual licensed under the Apache License 2.0 and the MIT license.
 */
(function($)
{
    // Remap cometd JSON functions to jquery JSON functions
    org.cometd.JSON.toJSON = JSON.stringify;
    org.cometd.JSON.fromJSON = JSON.parse;

    function _setHeaders(xhr, headers)
    {
        if (headers)
        {
            for (var headerName in headers)
            {
                if (headerName.toLowerCase() === 'content-type')
                {
                    continue;
                }
                xhr.setRequestHeader(headerName, headers[headerName]);
            }
        }
    }

    // Remap toolkit-specific transport calls
    function LongPollingTransport()
    {
        var _super = new org.cometd.LongPollingTransport();
        var that = org.cometd.Transport.derive(_super);

        that.xhrSend = function(packet)
        {
            return $.ajax({
                url: packet.url,
                async: packet.sync !== true,
                type: 'POST',
                contentType: 'application/json;charset=UTF-8',
                data: packet.body,
                beforeSend: function(xhr)
                {
                    _setHeaders(xhr, packet.headers);
                    // Returning false will abort the XHR send
                    return true;
                },
                success: packet.onSuccess,
                error: function(xhr, reason, exception)
                {
                    packet.onError(reason, exception);
                }
            });
        };

        return that;
    }

    function CallbackPollingTransport()
    {
        var _super = new org.cometd.CallbackPollingTransport();
        var that = org.cometd.Transport.derive(_super);

        that.jsonpSend = function(packet)
        {
            $.ajax({
                url: packet.url,
                async: packet.sync !== true,
                type: 'GET',
                dataType: 'jsonp',
                jsonp: 'jsonp',
                data: {
                    // In callback-polling, the content must be sent via the 'message' parameter
                    message: packet.body
                },
                beforeSend: function(xhr)
                {
                    _setHeaders(xhr, packet.headers);
                    // Returning false will abort the XHR send
                    return true;
                },
                success: packet.onSuccess,
                error: function(xhr, reason, exception)
                {
                    packet.onError(reason, exception);
                }
            });
        };

        return that;
    }

    $.Cometd = function(name)
    {
        var cometd = new org.cometd.Cometd(name);

        //if (window.WebSocket)
        //{
            cometd.registerTransport('websocket', new org.cometd.WebSocketTransport());
        //}
        cometd.registerTransport('long-polling', new LongPollingTransport());
        cometd.registerTransport('callback-polling', new CallbackPollingTransport());

        return cometd;
    };

    // The default cometd instance
    $.cometd = new $.Cometd();

})(jQuery);
//static-content-hash-trigger-GCC
/****************************************************************************
 * Author:	Sneha Surisetty
 * Date:		22-Mar-2019
 * Description:	Genesys desktop implementation using CometD.js
 *****************************************************************************/
pega.cti.desktopApi.Genesys = function() {

    this.name = "Genesys";
    this.hostURL = null;
    this.authString = null;
    this.agentId = null;
    this.agentPwd = null;
    this.pyClientHandle = '';
    this.LinkDefinition = null;
    this.eventCallback = null;
    this.cometd = null;
    this.onSuccess = null;
    this.deviceSubscription = null;
    this.callsSubscription = null;
    this.serviceSubscription = null;
    this.implementationVersion = "8.3.1.10";
    this.dn = null;
    this.telephonyMode = null;
    this.handShakeListener = null;
    this.connectListener = null;
    this.disconnectListener = null;
    this.subscribeListener = null;
    this.unsubscribeListener = null;
    this.place = null;
    this.Logger = new pega.cti.Logger();
    this.userName = null;
    this.userPassword = null;
    this.pyWorkMode = null;
    this.notReadyReasonCodes = null;
    this.logoutReasonCodes = null;
    this.currentAgentState = null;
    this.requestedLogOut = false;
    this.deviceID=null;
    this.options=null;
    this.isConnAquired = false;
    this.pyNumberOfLines = null;
    this.reconnecting = false;
}

pega.cti.desktopApi.Genesys.prototype = {
    initialize: function(LinkDefinition, Options, onSuccess, onFailure) {
        this.LinkDefinition = LinkDefinition;
        this.pyClientHandle = Options.pyClientHandle;
        this.hostURL = LinkDefinition.pyPrimaryHost;
        this.deviceSubscription = null;
        this.callsSubscription = null;
        this.onSuccess = onSuccess;
        this.serviceSubscription = null;
        this.options = Options;
        this.pyNumberOfLines = Options.pyNumberOfLines;
        this.cometd = $.cometd;
        this.addListeners();
        this.requestedLogOut = false;
        if (Options !== undefined && Options.pyNumberOfLines !== undefined) {
            this.pyNumberOfLines = Options.pyNumberOfLines;
        }

        if (Options !== undefined && Options.pyTelephonyMode !== undefined) {
            this.telephonyMode = Options.pyTelephonyMode;
        }

        if (Options !== undefined && Options.pyUserName !== undefined) {
            this.userName = Options.pyUserName;
        }

        if (Options !== undefined && Options.pyUserPassword !== undefined) {
            this.userPassword = Options.pyUserPassword;
        }

        if (Options !== undefined && Options.pyWorkMode !== undefined) {
            this.pyWorkMode = Options.pyWorkMode;
        }


    },

    sendRESTRequest: function(method, payload, requestUrl, onSuccess, onFailure) {
        pega.cti.API.Logger.debug('Sending request to URL[ ' + requestUrl + '], method [' + method + '] & payload [' + JSON.stringify(payload) + ']');
        var payloadData = JSON.stringify(payload, undefined, 2);
        var reqheaders = {};
        reqheaders['Authorization'] = this.authString;
        reqheaders['Content-Type'] = payloadData == null ? undefined : 'application/json';
        $.ajax({
            type: method,
            url: requestUrl,
            headers: reqheaders,
            data: payloadData,
            success: function(data, textStatus, response) {
                if (data != null) {
                    pega.cti.API.Logger.info('Request successful. Response:');
                    pega.cti.API.Logger.debug('Response:' + JSON.stringify(data, null, 2));
                    pega.cti.API.reconnect(data,onSuccess, onFailure);
                } else
                    pega.cti.API.Logger.info('Request successful.');
                onSuccess(data, textStatus, response);
            },
            error: function(jqXHR, exception) {
                var errObject = new Object();
                if (jqXHR.responseJSON && jqXHR.responseJSON.statusCode != undefined) {
                    var error = jqXHR.responseJSON;
                    errObject.errCode = pega.cti.API.getMappingErrorCode(error.statusCode);  
                    errObject.errMessage = error.statusMessage;
                } else {
                    switch (jqXHR.status) {
                        case 0:
                            errObject.errCode = 'HTTP_ERROR_0';
                            errObject.errMessage = 'Unable to connect.Verify network';
                            break;
                        case 400:
                            errObject.errCode = 'HTTP_ERROR_400';
                            errObject.errMessage = 'HTTP error 400: Bad request';
                            break;
                        case 401:
                            errObject.errCode = 'HTTP_ERROR_401';
                            errObject.errMessage = 'HTTP error 401: Authentication failed/not provided';
                            break;
                        case 403:
                            errObject.errCode = 'HTTP_ERROR_403';
                            errObject.errMessage = 'HTTP error 403: The operation is forbidden';
                            break;
                        case 404:
                            errObject.errCode = 'HTTP_ERROR_404';
                            errObject.errMessage = 'HTTP error 404: Requested resource not found';
                            break;
                        case 405:
                            errObject.errCode = 'HTTP_ERROR_405';
                            errObject.errMessage = 'HTTP error 405: Method not supported';
                            break;
                        case 408:
                            errObject.errCode = 'HTTP_ERROR_408';
                            errObject.errMessage = 'HTTP error 408: Request timedout';
                            break;
                        case 500:
                            errObject.errCode = 'HTTP_ERROR_500';
                            errObject.errMessage = 'HTTP error 500: Internal Server Error';
                            break;
                        case 502:
                            errObject.errCode = 'HTTP_ERROR_502';
                            errObject.errMessage = 'HTTP error 502: Bad Gateway';
                            break;
                        case 503:
                            errObject.errCode = 'HTTP_ERROR_503';
                            errObject.errMessage = 'HTTP error 500: Service Unavailable';
                            break;
                        default:
                            errObject.errCode = true;
                            errObject.errMessage = 'Uncaught Error.' + jqXHR.responseText;
                    }
                }

                pega.cti.API.Logger.Error('Error on request: ' + errObject.errMessage);
                
              onFailure(errObject);
            }
        });
    },


    login: function(AgentId, AgentPwd, Extension, LinkDefinition, Options, onSuccess, onFailure, forwardEvent) {
     
        this.eventCallback = forwardEvent;
        this.agentId = AgentId;
        this.agentPwd = AgentPwd;
        this.place = Extension;
        //Initialize data 
       var sectionNodes = pega.u.d.getSectionsByName("EmbeddedCcpHeader", document);
       if (sectionNodes) {
          refreshSection("EmbeddedCcpHeader", event);
       }
        this.initialize(LinkDefinition, Options, onSuccess, onFailure);
        this.authString = this.getAuthString();
        //authenticate user
        this.authenticate(onSuccess, onFailure);

    },
    reconnect: function(data,onSuccess, onFailure){
      pega.cti.API.Logger.info('Validating network failure/errors');
      if(this.requestedLogOut===false && data.user!==undefined && data.user.devices!==undefined && data.user.devices.length>0 &&
         data.user.devices[0]!==undefined && data.user.devices[0].userState!==undefined && 
        data.user.devices[0].userState.state!==undefined && data.user.devices[0].userState.state==="LoggedOut"){
        
        pega.cti.API.Logger.info('Network disconneted. Trying to reconnect for login');
        this.authString = this.getAuthString();
        //authenticate user
        this.authenticate(onSuccess, onFailure);
        var sectionNodes = pega.u.d.getSectionsByName("EmbeddedCcpHeader", document);
       if (sectionNodes) {
          refreshSection("EmbeddedCcpHeader", event);
       }
        pega.cti.API.Logger.info('Reconnection successful.');
      }
    },


    //return Base64 encoded value for agentid and password
    getAuthString: function() {
        return "Basic " + window.btoa(this.userName + ":" + this.userPassword);
    },


    addListeners: function() {
        //Remove Listeners if already exists
        this.removeListeners();
        this.handShakeListener = this.cometd.addListener('/meta/handshake', this.onHandshake);
        this.connectListener = this.cometd.addListener('/meta/connect', this.onConnect);
        this.disconnectListener = this.cometd.addListener('/meta/disconnect', this.onDisconnect);
        this.subscribeListener = this.cometd.addListener("/meta/subscribe", this.onsubscribe);
        this.unsubscribeListener = this.cometd.addListener("/meta/unsubscribe", this.onunsubscribe);
    },

    removeListeners: function() {

        if (this.handShakeListener != null) {
            this.cometd.removeListener(this.handShakeListener);
        }

        if (this.connectListener != null) {
            this.cometd.removeListener(this.connectListener);
        }

        if (this.disconnectListener != null) {
            this.cometd.removeListener(this.disconnectListener);
        }

        if (this.subscribeListener != null) {
            this.cometd.removeListener(this.subscribeListener);
        }

        if (this.unsubscribeListener != null) {
            this.cometd.removeListener(this.unsubscribeListener);
        }
    },

    /*
     authentcates user 
     onsuccess configures cometd connection
    */

    authenticate: function(onSuccess, onFailure) {
        this.sendRESTRequest('GET', null, this.hostURL + '/api/v2/me',
            function(data, textStatus, response) {
                pega.cti.API.startContactCenterSession();
            },
            function(message) {
                onFailure(message);
            }
        );
    },

    /*
      Configure cometd and request for handshake with server
     */

    configurecometd: function() {
        var reqHeaders = {};
        reqHeaders['Authorization'] = this.authString;
        this.cometd.configure({
            url: this.hostURL + '/api/v2/notifications',
            logLevel: "info",
            requestHeaders: reqHeaders
        });
        this.cometd.handshake();
    },

    /*
     on handshake success starts contactcentersession
    */
    onHandshake: function(handshake) {
        if (handshake.successful === true) {
            pega.cti.API.Logger.info('Starting contactcenter session...');
            pega.cti.API.subscribe();

        } else {
            pega.cti.API.Logger.Error("Handshake failed...");
            var errObject = new Object();
            errObject.errMessage = "Handshake failed";
            onFailure(errObject);
            pega.cti.API.endContactCenterSession();
            pega.cti.API.cometd.disconnect(true);
        }
    },

    /*
     Incoming events handler
    */
    onMessage: function(message) {
        pega.cti.API.Logger.debug('Cmetd message received:\n' + JSON.stringify(message, null, 2));
        try {
            if (message.data.messageType != null && message.data.messageType === 'DeviceStateChangeMessage') { //Agent State Event               
                pega.cti.API.handleUserEvent(message.data);
              
            } else if (message.data.messageType != null && message.data.messageType === 'CallStateChangeMessage') { //calls Event
                if (message.data != undefined && message.data.notificationType != undefined && message.data.notificationType != "AttachedDataChanged")
                    if (message.data.notificationType  ==  "ParticipantsUpdated")
                      pega.cti.API.handlePartyInfoEvent(message.data.call,message.data.previousCallId);
                    else
                      pega.cti.API.handleCallsEvent(message.data.call);
                else
                    pega.cti.API.Logger.info("Filtering call events as the notification type is AttachedDataChanged");
            } else if (message.data.messageType != null && message.data.messageType === 'ErrorMessage') { //Error Event
                pega.cti.API.handleErrorEvent(message.data);
            } else { //Unknown event
                pega.cti.API.Logger.debug('Received unhandled event:');
                pega.cti.API.Logger.debug(message);
            }
        } catch (e) {
            pega.cti.API.Logger.Error('Error while parsing async event ' + e.toString());
        }
    },


    startContactCenterSession: function() {
        var _this = this;
        var payload = new Object();
        payload.operationName = 'StartContactCenterSession';
        payload.channels = ['voice'];
        if (this.place != null) {
            payload.place = this.place;
        }
        if (this.agentId != null) {
            payload.loginCode = this.agentId;
        }
        if (this.agentPwd != null) {
            payload.agentLoginPassword = this.agentPwd;
        }
        if (this.pyWorkMode != null) {
            if (this.pyWorkMode == "AUTO_IN") {
                payload.workmode = "AutoIn";
            } else if (this.pyWorkMode == "MANUAL_IN") {
                payload.workmode = "ManualIn";
            }
        }

        this.sendRESTRequest('POST', payload, pega.cti.API.hostURL + '/api/v2/me',
            function() {
                _this.configurecometd();
                onSuccess();
            },
            function(error) {
                pega.cti.API.Logger.Error("StartContactCenterSession failed...");
                onFailure(error);
            }
        );
    },

    endContactCenterSession: function() {
        this.sendRESTRequest('POST', {
            operationName: 'EndContactCenterSession'
        }, pega.cti.API.hostURL + '/api/v2/me', pega.cti.API.onEndContactCenterSessionComplete, function(error) {
            pega.cti.API.Logger.Error("Contact center end session request failed");
            onFailure(error);
        });

    },

    /*
     subscribes for device,call,service notifications
    */
    subscribe: function() {
        pega.cti.API.Logger.info("subscribing to channels...");
        pega.cti.API.deviceSubscription = pega.cti.API.cometd.subscribe('/v2/me/devices', pega.cti.API.onMessage);
        pega.cti.API.callsSubscription = pega.cti.API.cometd.subscribe('/v2/me/calls', pega.cti.API.onMessage);
        pega.cti.API.serviceSubscription = pega.cti.API.cometd.subscribe('/notification/services', pega.cti.API.onMessage);

    },

    /*
      unsubscribes the channels
    */
    unsubscribe: function() {

        pega.cti.API.Logger.info("unsubscribing to channels...");

        if (pega.cti.API.deviceSubscription != null) {
            pega.cti.API.cometd.unsubscribe(pega.cti.API.deviceSubscription);
        }

        if (pega.cti.API.callsSubscription != null) {
            pega.cti.API.cometd.unsubscribe(pega.cti.API.callsSubscription);
        }

        if (pega.cti.API.serviceSubscription != null) {
            pega.cti.API.cometd.unsubscribe(pega.cti.API.serviceSubscription);
        }

    },

    onsubscribe: function(e) {
        if (e.successful) {
            this.isConnAquired = true;
            pega.cti.API.Logger.debug("subscribed channel.." + ((e !== undefined && e.subscription !== undefined) ? e.subscription : ""));
            if (e.subscription === '/v2/me/devices') {
                pega.cti.API.getDeviceSnapshot();
            }
            if (e.subscription == '/v2/me/calls') {
               pega.cti.API.getCallSnapshot();
            }
        } else {
            pega.cti.API.Logger.Error("subscription to channel" + ((e !== undefined && e.subscription !== undefined) ? e.subscription : " ") + "failed");
            var errorObject = new Object();
            errorEvent.pyErrorCode = 'OPENCTI_ERR_PASS';
            errorObject.pyErrorMessage = "Subscribe request failed " + e.error;
            onFailure(errorObject);
        }
    },

    getDeviceSnapshot: function() {
        pega.cti.API.Logger.info("sending request for devicesnapshot");
        this.sendRESTRequest('GET', null, this.hostURL + '/api/v2/me?subresources=calls,devices',
            function(data, textStatus, response) {
               /* if (data.devices[0].userState.state == "LoggedOut" && pega.cti.API.telephonyMode != 2) {
                    pega.cti.API.Logger.debug('Attempting to login agent [' + pega.cti.API.agentId + '] with extension [' + pega.cti.API.dn + ']');
                    var payload = new Object();
                    payload.operationName = 'Ready';
                    pega.cti.API.changeAgentState(payload,
                        function() {
                            pega.cti.API._waitForLogin(10, 1000, function(deviceData) {
                                pega.cti.API.onSuccess();
                                pega.cti.API.buildSnapshotWithLines(deviceData);
                            }, function(error) {
                                 onFailure(error);
                                 pega.cti.API.endContactCenterSession();
                            });
                        },function(error) {
                            error.errMessage = "Agent login failed";
                            onFailure(error);
                            pega.cti.API.endContactCenterSession();
                          }
                    
                        );
                } else {*/
                    pega.cti.API.onSuccess();
                    pega.cti.API.buildSnapshotWithLines(data.user);
                //}

            },
            function(error) {
                pega.cti.API.Logger.Error("Device snapshot request failed");
                pega.cti.API.this.endContactCenterSession();
                onFailure(error);
            }
        );
    },

    getCallSnapshot: function() {
        pega.cti.API.Logger.info("sending request for call snapshot");
        var _this = this;
        this.sendRESTRequest('GET', null, this.hostURL + '/api/v2/me/calls?fields=*',
            function(data, textStatus, response) {
                pega.cti.API.Logger.info("Call snapshot response received");
                if (data.calls != null) {
                    for (var i = 0; i < data.calls.length; i++)
                        _this.handleCallsEvent(data.calls[i]);
                }
            },
            function(message) {
                pega.cti.API.error("Call snapshot request failed");
                onFailure(message);
            }
        );
    },

    handleCallsEvent: function(call) {

        pega.cti.API.Logger.debug('Parsing call state event from Genesys'+JSON.stringify(call));

        var callEvent = this.buildPegaEvent('CallStateEvent');
        callEvent.pyCallId = call.callUuid;
        callEvent.pyCallType = this.getCallType(call.callType);
        callEvent.pyANI = call.ani;
        callEvent.pyEventString = this.getEventNameForCall(call.state);
        callEvent.pyEventName = this.getEventNameForCall(call.state);
        callEvent.pyClientHandle = this.pyClientHandle;
        callEvent.pyEventType = "CallStateEvent";
        callEvent.pyLine = 0;
        callEvent.pyMedia = "Phone";
        //getCallVariables
        if (call.userData !== null && call.userData !== undefined )
        {
         callEvent.pyNamedVariables = this.createCallVariables(call.userData);
         if(("userCallRequestType" in callEvent.pyNamedVariables) && callEvent.pyNamedVariables['userCallRequestType']==='OUTBOUND'){
           callEvent.pyCallType = "OUTBOUND";
         }
          else if("userOldCallId" in callEvent.pyNamedVariables)
           callEvent.pyCallType = "CONSULT";
        }
        callEvent.pyParties = [];
        for (var i = 0; i < call.participants.length; i++) {
            var partyObj = new Object();
            partyObj.pyDN = call.participants[i].phoneNumber;
            callEvent.pyParties.push(partyObj);
        }
        this.eventCallback(JSON.stringify(callEvent));
    },
  
  
   handlePartyInfoEvent: function(call,previousCallId){
      //pega.cti.API.Logger.debug('Creating party info event from Genesys Call'+JSON.stringify(call));
      var callEvent = this.buildPegaEvent('PartyInfoEvent');
        callEvent.pyCallId = call.callUuid;
        callEvent.pyCallType = this.getCallType(call.callType);
        callEvent.pyANI = call.ani;
        callEvent.pyEventString = "PartyInfo";
        callEvent.pyEventName = "PartyInfo";
        callEvent.pyClientHandle = this.pyClientHandle;
        callEvent.pyEventType = "PartyInfoEvent";
        callEvent.pyMedia = "Phone";
        callEvent.pyPreviousCallId  =previousCallId;
        callEvent.pyParties = [];
        for (var i = 0; i < call.participants.length; i++) {
            var partyObj = new Object();
            partyObj.pyDN = call.participants[i].phoneNumber;
            partyObj.pyCallID = call.callUuid;
            callEvent.pyParties.push(partyObj);
        }
      this.eventCallback(JSON.stringify(callEvent));
   }, 
  sendReconnectEvent: function() {
        pega.cti.API.Logger.info('setting snapshot event for reconnection');
        var pyLinkState = 'DISCONNECTED';
        var snapshotEvent = pega.cti.API.getAgentSnapshotJson('Busy',pyLinkState);
        pega.cti.API.Logger.info('Returning snapshot event to called function.');
        return snapshotEvent;
  },
  
  getAgentSnapshotJson: function(agentState, linkState) {
        pega.cti.API.Logger.info('Building snapshot event.');
        var snapshotObj = this.buildPegaEvent('SnapshotEvent');
        snapshotObj.pyEventName = 'Snapshot'; 
        snapshotObj.pyEventString = 'DeviceSnapshot';
        snapshotObj.pyLinkState = linkState;
        snapshotObj.pySessionId = this.pySessionId;
        snapshotObj.pyUserIdentifier = this.pyUserIdentifier;
        if(agentState !== 'Logout')
    	    snapshotObj.pyDeviceState = 'OPENED';
        else
          snapshotObj.pyDeviceState = 'CLOSED';
        if(agentState ==='Busy') {
          snapshotObj.pyAgentState = 'NotReady';
          snapshotObj.pyWorkMode = 'Busy';
        }else {
    	    snapshotObj.pyAgentState = agentState;  
        }
        pega.cti.API.Logger.info('snapshot event build completed.');
        return (JSON.stringify(snapshotObj));
  },
  
  createCallVariables: function(userData) {
    var callData = new Object();
    for(var i=0; i< Object.getOwnPropertyNames(userData).length; i++) {
      //replace '.','[' charecters with '_' and ']' with blank in call variable name
      var cvName = Object.getOwnPropertyNames(userData)[i].replace(/\s+/g, '').replace(/[\[\]&\/\\#, +()$~%.'":*?<>{}]/g, '_'); 
      if ( typeof(Object.values(userData)[i]) == 'string' )
        if (Object.values(userData)[i] != '' && Object.values(userData)[i] != undefined)
          callData[cvName] =Object.values(userData)[i] ;
    }
    return callData; 
  },

    buildSnapshotWithLines: function(data) {
        try {
            var snapshotObj = pega.cti.API.buildPegaEvent('SnapshotEvent');
            snapshotObj.pyEventName = 'Snapshot';
            snapshotObj.pyEventType = 'SnapshotEvent';
            snapshotObj.pyEventString = 'DeviceSnapshot';
            snapshotObj.pyLinkState = this.pyLinkState;
            snapshotObj.pySessionId = this.pySessionId;
            snapshotObj.pyUserIdentifier = this.pyUserIdentifier;
            var device = null;
            if (data.devices != undefined && data.devices != null &&
                data.devices[0] != undefined && data.devices[0] != null) {
                device = data.devices[0];
            }

            if (device != null && device.deviceState == "Active") {                        
                snapshotObj.pyDeviceState = 'OPENED';
                this.deviceID= device.id;

            } else if (device != null && device.deviceState == "Inactive") {
                snapshotObj.pyDeviceState = 'CLOSED';
            }

            var userState;
            if (device.userState != undefined && device.userState != null) {
                this.currentAgentState = this.getMappingAgentState(device.userState.state);
                userState = device.userState;
            }

            if (this.telephonyMode == 2) {
                snapshotObj.pyAgentState = 'Unknown';
            } else {
                if (userState != null) {
                    if (userState.workMode != null && userState.workMode != undefined) {
                        if (userState.workMode == 'AfterCallWork') {
                            snapshotObj.pyWorkMode = 'AfterCallWork';
                        }
                        if (userState.workMode == 'LegalGuard') {
                            snapshotObj.pyWorkMode = 'AUTO_IN';
                        }
                        if (userState.workMode == 'ManualIn') {
                            snapshotObj.pyWorkMode = 'MANUAL_IN';
                        }
                    }
                    snapshotObj.pyAgentState = this.getMappingAgentState(userState.state);
                    if (device.deviceState == "Active" && snapshotObj.pyAgentState == "Logout") {
                      if(this.requestedLogOut===false && data.devices!==undefined && data.devices.length>0
                           && data.devices[0]!==undefined && data.devices[0].userState!==undefined && 
                            data.devices[0].userState.state!==undefined && data.devices[0].userState.state==="LoggedOut"){
                              snapshotObj.pyLinkState = 'DISCONNECTED';
                              snapshotObj.pyAgentState = 'NotReady';
                              snapshotObj.pyWorkMode = 'Busy';
                              pega.cti.API.Logger.info('Set the status to reconnecting on network or node failure');
                      }
                      else{
                        snapshotObj.pyAgentState = 'Unknown';
                      }
                    }

                    if (userState.reason != undefined && userState.reason != null) {
                        if (userState.state == 'NotReady') {
                            snapshotObj.pyReasonCode = userState.reason;
                        } else if (userState.state == 'LoggedOut') {
                            snapshotObj.pyReasonCode = userState.reason;
                        }
                    }
                } else {
                    snapshotObj.pyAgentState = 'Unknown';
                }
            }
            var linesArray = [];
            for (var k = pega.cti.API.pyNumberOfLines; k > 0; k--) {
                var lineObject = new Object();
                lineObject.pyLineNumber = pega.cti.API.pyNumberOfLines - k + 1;
                lineObject.pyCallId = '0';
                lineObject.pyLineState = 'idle';
                if (data.calls != undefined && data.calls != null)
                  if (data.calls[lineObject.pyLineNumber-1] != undefined && data.calls[lineObject.pyLineNumber-1] != null)
                  {lineObject.pyCallId = data.calls[lineObject.pyLineNumber-1].callUuid;
                    lineObject.pyLineState = data.calls[lineObject.pyLineNumber-1].state;}
                
                linesArray.push(lineObject);
            }
            snapshotObj = JSON.stringify(snapshotObj);
            snapshotObj = snapshotObj.substring(0, snapshotObj.length - 1) + ',"pyLines":' + JSON.stringify(linesArray) + "}";
            pega.cti.API.eventCallback(snapshotObj);

        } catch (e) {
            pega.cti.API.Logger.Error("Error while building snapshot" + e);
        }

    },

    buildPegaEvent: function(eventType) {
        var eventObj = new Object();
        eventObj.pyMedia = "Phone";
        eventObj.pyEventType = eventType;
        eventObj.pyClientHandle = this.pyClientHandle;
        eventObj.pyAgentID = this.agentId;
        eventObj.pyEventTimeStamp = $.now();
        eventObj.pyLinkName = this.LinkDefinition.pyLinkDefinitionName;
        eventObj.pyLinkInsHandle = this.LinkDefinition.pzInsKey;
        return eventObj;
    },

    onunsubscribe: function(e) {
        if (e.successful) {
            pega.cti.API.Logger.debug("unsubscribed the channel" + ((e !== undefined && e.subscription !== undefined) ? e.subscription : ""));
        } else {
            var errorObject = new Object();
            errorObject.errorMessage = "unsubscribe request failed " + e.error;
            onFailure(errorObject);
        }
    },

    onEndContactCenterSessionComplete: function() {
        pega.cti.API.Logger.debug("session end successfull..");
    },

    onConnect: function(message) {
        if (message.successful) {
            pega.cti.API.Logger.info('Cometd connected...');
            this.reconnecting = false;
        }
        else
          {
            pega.cti.API.Logger.info("Network retry requested");
            if(this.requestedLogOut!==true && !message.successful && message.advice!==undefined 
               && message.advice.reconnect!==undefined && message.advice.reconnect==="retry" && this.reconnecting === false){
              this.reconnecting = true;
              /*if(message.xhr!==undefined && message.xhr.status!==undefined && message.xhr.status===0)
                {
                  alert("Unable to connect to network because of internet disruption.");
                }
              else{*/
              var reconnectionevent = pega.cti.API.sendReconnectEvent();
              pega.cti.API.Logger.info('Sending reconnection event for network or node failure');
              pega.cti.API.eventCallback(reconnectionevent);
              //}
            }
          }
    },

    onDisconnect: function(message) {
        if (message.successful) {
            pega.cti.API.Logger.debug('Cometd disconnected.');
        }
    },

    handleErrorEvent: function(data) {
        var errorEvent = this.buildPegaEvent('ErrorEvent');
       if(data.errorMessage != null) {
        errorEvent.pyErrorCode = this.getMappingErrorCode(data.errorMessage);
        errorEvent.pyErrorMessage = data.errorMessage != null ? data.errorMessage : " ";
        pega.cti.API.Logger.debug('Forwarding Error Event [' + errorEvent.pyErrorMessage + '] for user [' + this.userName + ']');
        this.eventCallback(JSON.stringify(errorEvent));
       }
    },

    getCallType: function(ciscoCallType) {
        var pegaCallType;
        switch (ciscoCallType) {
            case 'Inbound':
                pegaCallType = 'INBOUND';
                break;
            case 'Internal':
                pegaCallType = 'INTERNAL';
                break;
            case 'CONSULT':
                pegaCallType = 'CONSULT';
                break;
            case 'Outbound':
                pegaCallType = 'OUTBOUND';
                break;
            default:
                pegaCallType = 'UNKNOWN';
        }
        return pegaCallType;
    },

    getEventNameForCall: function(callState) {
        var eventName;
        switch (callState) {
            case 'Abandoned':
                eventName = 'Abandoned';
                break;
            case 'Dialing':
                eventName = 'Initiated';
                break;
            case 'Held':
                eventName = 'Held';
                break;
            case 'Ringing':
                eventName = 'Alerting';
                break;
            case 'Established':
                eventName = 'Established';
                break;
            case 'Released':
                eventName = 'Disconnected';
                break;
            default:
                eventName = '';
        }
        return eventName;
    },


    handleUserEvent: function(data) {
        var logoutrequested = "false";
        if (data.devices !== undefined && data.devices.length > 0) {
            var agentEvent = null;
            var device = data.devices[0];
            if (device.userState != undefined && device.userState != null) {
                this.currentAgentState = this.getMappingAgentState(device.userState.state);
            }
            if (this.currentAgentState == 'Logout' && device.deviceState == 'Active' && this.requestedLogOut == true) {
                this.requestedLog = false;
                this.endContactCenterSession();
                logoutrequested = "true";
            }
            //if the device state is "Inactive" send device close snapshot
            if (device.deviceState === "Inactive" || logoutrequested === "true") {
                this.cometd.disconnect(true);
                data.devices[0].deviceState="Inactive";
                agentEvent = this.buildSnapshotWithLines(data);
                this.eventCallback(agentEvent);
            } else if (this.telephonyMode != 2) {
                //Fulltelephony or simpletelephony with agent states need to parse userstates
                agentEvent = this.buildPegaEvent('AgentStateEvent');
                var userState = null;
                if (device != null && device.deviceState == "Active") {
                    agentEvent.pyDeviceState = 'OPENED';

                } else if (device != null && device.deviceState == "Inactive") {
                    agentEvent.pyDeviceState = 'CLOSED';
                }
                if (device.userState != undefined && device.userState != null) {
                    userState = device.userState;
                    if (userState.reason != undefined && userState.reason != null) {
                        if (userState.state == 'NotReady') {
                            agentEvent.pyReasonCode = userState.reason;
                        } else if (userState.state == 'LoggedOut') {
                            agentEvent.pyReasonCode = userState.reason;
                        }
                    }
                    if (userState.workMode != null && userState.workMode != undefined) {
                        if (userState.workMode == 'AfterCallWork') {
                            agentEvent.pyWorkMode = 'AfterCallWork';
                        }
                        if (userState.workMode == 'LegalGuard') {
                            agentEvent.pyWorkMode = 'AUTO_IN';
                        }
                        if (userState.workMode == 'ManualIn') {
                            agentEvent.pyWorkMode = 'MANUAL_IN';
                        }
                    }
                    agentEvent.pyAgentState = this.getMappingAgentState(userState.state);
                    if (device.deviceState == "Active" && agentEvent.pyAgentState == "Logout") {
                      if(this.requestedLogOut===false && data.devices!==undefined && data.devices.length>0
                           && data.devices[0]!==undefined && data.devices[0].userState!==undefined && 
                            data.devices[0].userState.state!==undefined && data.devices[0].userState.state==="LoggedOut"){
                              agentEvent.pyLinkState = 'DISCONNECTED';
                              agentEvent.pyAgentState = 'NotReady';
                              agentEvent.pyWorkMode = 'Busy';
                              pega.cti.API.Logger.info('Reconnection snapshot event for network or node failure');
                      }
                      else{
                        agentEvent.pyAgentState = 'Unknown';
                      }
                    }

                } else {
                    agentEvent.pyAgentState = 'Unknown';
                }
                agentEvent.pyEventName = agentEvent.pyAgentState;
                this.eventCallback(agentEvent);

            }
        }

    },


    logout: function(AgentId, ReasonCode, Options, onSuccess, onFailure) {
        pega.cti.API.Logger.debug('Attempting to change state to logout for agent [' + pega.cti.API.agentId + '] with extension [' + pega.cti.API.dn + ']');
      var sectionNodes = pega.u.d.getSectionsByName("EmbeddedCcpHeader", document);
       if (sectionNodes) {
          refreshSection("EmbeddedCcpHeader", event);
       }
        var payload = new Object();
        this.isConnAquired = false;
        payload.operationName = 'Offline';
        if (ReasonCode != undefined && ReasonCode != null && ReasonCode != "") {
            payload.operationName = this.getOperationNameFromList(this.logoutReasonCodes, ReasonCode);
            if(payload.operationName===null || payload.operationName===undefined)
              payload.operationName = 'Offline';
           }
          
            this.changeAgentState(
                payload,
                onSuccess,
                onFailure
            );
            this.requestedLogOut = true;
        
    },

    answerCall: function(CallId, Options, onSuccess, onFailure) {
      var payload = {
		  operationName: 'Answer'
		}	;

      
        if (CallId != -1) {
          this._callControlRequest(CallId,payload,onSuccess,onFailure);
        } else {
            var _this = this;
            this.sendRESTRequest('GET', null, this.hostURL + '/api/v2/me/calls?fields=*',
                function(data, textStatus, response) {
                    pega.cti.API.Logger.info("Get calls");
                    if (data.calls != null) {
                        for (var i = 0; i < data.calls.length; i++) {
                            var callState = _this.getEventNameForCall(data.calls[i].state);
                            if (callState == "Alerting") {
                                _this._callControlRequest(data.calls[i].callUuid, payload, onSuccess, onFailure);
                                break;
                            }
                        }
                    }
                }, onFailure
            );
        }
    },
   /*
@api - Retrieve a held call.
@param $String$CallId – The CallId of the held call.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
		retrieveCall: function(CallId, Options, onSuccess, onFailure) {
			var payload = {
				operationName: 'Retrieve'
			};
			this._callControlRequest(CallId, payload, onSuccess, onFailure);
		},
       /*
@api - Place a call on hold.
@param $String$CallId – The Call Id of the call to place on hold.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
 */
		holdCall: function(CallId, Options, onSuccess, onFailure) {
			var payload = {
				operationName: 'Hold'
			};
			this._callControlRequest(CallId, payload, onSuccess, onFailure);
		},
       /*
@api - Hang up a call.
@param $String$CallId – parameter description goes here.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
		hangUpCall: function(CallId, Options, onSuccess, onFailure) {
			var payload = {
				operationName: 'Hangup'
			};
			this._callControlRequest(CallId, payload, onSuccess, onFailure);
		},
/*	   
@api - Blind Transfer the call.
@param $String$CallId – The Active Call Id.
@param $String$Destination – The dialed digits of the destination party.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  blindTransfer: function(CallId, Destination, Options, onSuccess, failure) {  
	var payload = {
		operationName: "SingleStepTransfer",
		destination: {
			phoneNumber: Destination
		},
		userData:{}
	};	

	if (Options != undefined && Options.pyCallVariables != undefined)
    for(callVar in Options.pyCallVariables)
      payload.userData[Options.pyCallVariables[callVar].pyKey]= Options.pyCallVariables[callVar].pyValue;
		
	this._callControlRequest(
		CallId,
		payload,
		onSuccess,
		onFailure
	);
    
  },
      /*
@api - Initiate a (warm/attended) Transfer.
@param $String$CallId – The Call Id of the call.
@param $String$Destination – The dialed digits of the transfer destination.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  transferInitiate: function(CallId, Destination, Options, onSuccess, failure) {
	var payload = {
		operationName: "InitiateTransfer",
		destination: {
			phoneNumber: Destination
		},
    userData:{}
	};
	if (Options != undefined && Options.pyCallVariables != undefined)
    for(callVar in Options.pyCallVariables)
      payload.userData[Options.pyCallVariables[callVar].pyKey]= Options.pyCallVariables[callVar].pyValue;
	this._callControlRequest(
		CallId,
		payload,
		onSuccess,
		onFailure
	);
      
  },
  /*
@api - Transfer the call.
@param $String$HeldCallId – The Call Id of the held party.
@param $String$ActiveCallId – The call Id of the active (consulted/destination) call.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
transferComplete: function(HeldCallId, ActiveCallId, Options, onSuccess, onFailure) {
    var payload = {
        operationName: 'CompleteTransfer',
    };

    this.sendRESTRequest('GET', payload, pega.cti.API.hostURL + '/api/v2/me/calls/'+ActiveCallId , function(response) {
        var callObj = response.call;
		var transferCallID = ActiveCallId;
    if (callObj.callType !=  "Consult")
      transferCallID = HeldCallId;
        pega.cti.API._callControlRequest(
            transferCallID,
            payload,
            onSuccess,
            onFailure
        );
    }, function(error) {
        pega.cti.API._callControlRequest(
            HeldCallId,
            payload,
            onSuccess,
            onFailure
        );
    });

},
  
 /*
@api - Place a consultation call.
@param $String$CallId – The CallId of the active call.
@param $String$Destination – The dialed digits of the party to be consulted.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  consulationCall: function(CallId, Destination, Options, onSuccess, onFailure) {
    var opts = new Object();
    opts =JSON.stringify(Options);
    transferInitiate(CallId, Destination, opts, onSuccess, onFailure);
  },
  
  /*
@api - Function description goes here.
@param $String$CallId – The CallId of the active call.
@param $String$Destination – The dialed digits of the party to be conferenced.
@param $Oject$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  conferenceInitiate: function(CallId, Destination, Options, onSuccess, onFailure) {
	var payload = {
		operationName: "InitiateConference",
		destination: {
			phoneNumber: Destination
		},
		userData:{}
	};    
	if (Options != undefined && Options.pyCallVariables != undefined)
    for(callVar in Options.pyCallVariables)
      payload.userData[Options.pyCallVariables[callVar].pyKey]= Options.pyCallVariables[callVar].pyValue;
	this._callControlRequest(
		CallId,
		payload,
		onSuccess,
		onFailure
	);
  },
   /*
@api - Complete a conference.
@param $String$HeldCallId – The Call Id of the held call.
@param $String$ActiveCallId – The Call Id of the active call.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  //Changed payload from completeConference to MergeWithOtherCall using bug, BUG-689427
  conferenceComplete: function(HeldCallId, ActiveCallId, Options, success, failure) {
	var payload = {
		operationName: 'MergeWithOtherCall',
    otherCallUri: pega.cti.API.hostURL + '/api/v2/me/calls/'+ActiveCallId
	};
 this.sendRESTRequest('POST', payload, pega.cti.API.hostURL + '/api/v2/me/calls/' , function(response) {
        var callObj = response.call;
		var transferCallID = ActiveCallId;
    if (callObj.callType !=  "Consult")
      transferCallID = HeldCallId;
        pega.cti.API._callControlRequest(
            transferCallID,
            payload,
            onSuccess,
            onFailure
        );
    }, function(error) {
        pega.cti.API._callControlRequest(
            HeldCallId,
            payload,
            onSuccess,
            onFailure
        );
    });
  },
      /*
@api - Drop party from a Conference.
@param $String$CallId – The CallID of the call from which party is to be dropped.
@param $String$Party – The Party to be dropped.
@param $Object$Options – Array of Optional Parameters.
@return $undefined$ - return description goes here.
*/
  dropparty: function(CallId, Party, Options, onSuccess, onFailure) {
	var payload = {
		operationName: 'RemoveParticipantFromConference',
		participant: Party 
	};
     this._callControlRequest(
      CallId, 
      payload,
      onSuccess, 
      onFailure
    );
  },
  /*
	@api - Place a new call.
	@param $String$Destination – The digits to dial.
	@param $String$Options – Array of Optional Parameters.
	@return $undefined$ - TDB.
  */
  makeCall: function(Destination, Options, onSuccess, onFailure) {
      //Added below code as part of bug BUG-609314 by Ram Reddy,Boddireddy//
      var payload = {
		    operationName: "Dial",
		    destination: {
			  phoneNumber: Destination
		  },
      userData:{}
	   };
	  if (Options !== undefined && Options.pyCallVariables !== undefined)
      for(callVar in Options.pyCallVariables)
        payload.userData[Options.pyCallVariables[callVar].pyKey]= Options.pyCallVariables[callVar].pyValue;
	    
    this.sendRESTRequest('POST', payload, pega.cti.API.hostURL + '/api/v2/me/devices/' + this.deviceID + '/calls', function(response) {
          pega.cti.API.Logger.debug("Make call request success");
      }, function(error) {
          pega.cti.API.Logger.Error("Make call request failed");
          onFailure(error);
      });
  
     //Commented code as part of bug BUG-609314 by Ram Reddy,Boddireddy//
      /*this.sendRESTRequest('POST', {
          operationName: 'Dial',
          destination: {
              phoneNumber: Destination
          }

      }, pega.cti.API.hostURL + '/api/v2/me/devices/' + this.deviceID + '/calls', function(response) {
          pega.cti.API.Logger.debug("Make call request success");
      }, function(error) {
          pega.cti.API.Logger.Error("Make call request failed");
          onFailure(error);
      });*/
  },
  
 
	_callControlRequest: function(CallId, payload, onSuccess, onFailure) {
		this.sendRESTRequest('POST',payload , pega.cti.API.hostURL + '/api/v2/me/calls/' + CallId, function(response) {
      onSuccess();
		  pega.cti.API.Logger.debug(payload.operationName + " request success");
		}, function(error) {
		  pega.cti.API.Logger.Error(payload.operationName + " call request failed");
		  onFailure(error);
		});
	  },
				  
    getMappingAgentState: function(agentState) {
        var pegaAgentState = null;
        switch (agentState) {
            case "LoggedIn":
                pegaAgentState = "Login";
                break;
            case "LoggedOut":
                pegaAgentState = "Logout";
                break;
            case "Ready":
                pegaAgentState = "Ready";
                break;
            case "NotReady":
                pegaAgentState = "NotReady";
                break;
            default:
                pegaAgentState = "";
        }
        return pegaAgentState;
    },

    agentReady: function(AgentId, WorkMode, Options, onSuccess, onFailure) {
        pega.cti.API.Logger.debug('Attempting to change state to READY for agent [' + pega.cti.API.agentId + '] with extension [' + pega.cti.API.dn + ']');
        var payload = new Object();
        payload.operationName = 'Ready';
        if (WorkMode != undefined && WorkMode != null && WorkMode != "") {
            if (WorkMode == "AUTO_IN") {
                payload.workmode = "AutoIn";
            } else if (WorkMode == "MANUAL_IN") {
                payload.workmode = "ManualIn";
            }
        }
        this.changeAgentState(
            payload,
            onSuccess,
            onFailure
        );
    },

    changeAgentState: function(payload, onSuccess, onFailure) {
        pega.cti.API.Logger.debug('Sending agent state change request with payload [' + payload + ']');
        this.sendRESTRequest('POST', payload, this.hostURL + '/api/v2/me/channels/voice', onSuccess, onFailure);
    },

    queryAgentConfig: function(onSuccess, onFailure) {
        pega.cti.API.Logger.debug('Sending request for getting list of reasoncodes');
        var agentConfigEvent = new Object();
        var _this = this;
        this.sendRESTRequest('GET', null, this.hostURL + '/api/v2/settings/agent-states',
            function(data) {
                var notReasonCodeList = [];
                var logoutReasonCodeList = [];
                if (data.settings != null) {
                    for (var i = 0; i < data.settings.length; i++) {
                        var reasonCodeObj = new Object();
                        if (data.settings[i].state == 'NotReady' && data.settings[i].reason != undefined && data.settings[i].reason != null) {
                            reasonCodeObj.pyCode = data.settings[i].reason;
                            reasonCodeObj.pyDisplayName = data.settings[i].displayName;
                            reasonCodeObj.operationName = data.settings[i].operationName;
                            notReasonCodeList.push(reasonCodeObj);
                        } else if (data.settings[i].state == 'Logout' && data.settings[i].reason != undefined && data.settings[i].reason != null) {
                            reasonCodeObj.pyCode = data.settings[i].reason;
                            reasonCodeObj.pyDisplayName = data.settings[i].displayName;
                            reasonCodeObj.operationName = data.settings[i].operationName;
                            logoutReasonCodeList.push(reasonCodeObj);
                        }
                    }
                    _this.notReadyReasonCodes = notReasonCodeList;
                    _this.logoutReasonCodes = logoutReasonCodeList;
                    agentConfigEvent.pyNotReadyReasonCodes = notReasonCodeList;
                    agentConfigEvent.pyLogoutReasonCodes = logoutReasonCodeList;
                }
                onSuccess(agentConfigEvent);
            },
            onFailure);
    },

    agentNotReady: function(AgentId, WorkMode, ReasonCode, Options, onSuccess, onFailure) {
        //Identify agent state based on workmode
        var state = (WorkMode == 'AFTER_CALL_WORK' ? 'AfterCallWork' : 'NotReady');
        var payload = new Object();
        if (ReasonCode != undefined && ReasonCode != null && ReasonCode != "") {
            payload.operationName = this.getOperationNameFromList(this.notReadyReasonCodes, ReasonCode);
        } else {
            payload.operationName = state;
        }
        pega.cti.API.Logger.debug('Attempting to change state to ' + state + ' for agent [' + pega.cti.API.agentId + '] with extension [' + pega.cti.API.dn + ']');
        this.changeAgentState(
            payload,
            onSuccess,
            onFailure
        );
    },

    getOperationNameFromList: function(list, reasonCode) {
        if(list!==null && list!==undefined){
          for (var i = 0; i < list.length; i++) {
              if (list[i].pyCode == reasonCode) {
                  return list[i].operationName;
              }
          }
        }
    },

   /* _waitForLogin: function(retries, delay, successCallback, failureCallback) {
        var _this = this;
        if (retries <= 0) {
            var errObject = new Object();
            errObject.errCode = 'OPENCTI_ERR_PASS';
            errObject.errMessage = 'Timeout waiting for Login';
            failureCallback(errObject);
        } else {
            this._getAgentState(function(data) {
                    if (data.devices[0].userState.state === "LoggedOut") {
                        setTimeout(function() {
                            _this._waitForLogin(retries - 1, delay, successCallback, failureCallback);
                        }, delay);
                    } else {
                        successCallback(data);
                    }
                },
                function(error) {
                    //failureCallback(error);
                });
        }

    },

    _getAgentState: function(onSuccess, onFailure) {
        this.sendRESTRequest(
            'GET',
            null,
            this.hostURL + '/api/v2/me/devices?fields=*',
            function(data) {
                onSuccess(data);
            },
            function(error){
             // onFailure(error);
            }
        );
    }, */
  
        getMappingErrorCode: function(genesysErrorCode) {
    var pegaCode = null;
    switch(genesysErrorCode) {
      case 1:
        pegaCode = 'PARAM_MISSING';
        break;
      case 2:
        pegaCode = 'INV_PARAM';
        break;
      case 3:
        pegaCode = 'HTTP_ERROR_403';
        break;
      case 4:
        pegaCode = 'HTTP_ERROR_500';
        break;
      case 5:
        pegaCode = 'NO_USER _PERM';
        break;
      case 6:
        pegaCode = 'HTTP_ERROR_404';
        break;
      case 7:
        pegaCode = 'OPR_PARTIAL_SUCCESS';
        break;
      case 8:
        pegaCode = 'CHANGE_PWD_DEMANDED';
        break;
      case 9:
        pegaCode = 'PROCESS_INCOMPLETE';
        break;
      case 10:
        pegaCode = 'PARAM_NOT_IN_RANGE';
        break;
      case 11:
        pegaCode = 'CHANGE_READ_ONLY_PROP_ERROR';
        break;
      case 12:
        pegaCode = 'RETRIEVE_RESOURCE_ERROR';
        break;
      case 13:
        pegaCode = 'CREATE_RESOURCE_ERROR';
        break;
      case 14:
        pegaCode = 'DELETE_RESOURCE_ERROR';
        break;
      case 15:
        pegaCode = 'UPDATE_RESOURCE_ERROR';
        break;
      case 16:
        pegaCode = 'ASSIGN_RESOURCE_ERROR';
        break;
      case 17:
        pegaCode = 'UNASSIGN_RESOURCE_ERROR';
        break;
      case 18:
        pegaCode = 'RESOURCE_ALREADY_EXISTS';
        break;
      case 19:
        pegaCode = 'RESOURCE_IN_USE';
        break;
      case 20:
        pegaCode = 'NOT_AUTHENTICATED';
        break;
      default:
        pegaCode ='ERR_PASS';
    }
    return pegaCode;
  },
}
//static-content-hash-trigger-GCC
/********************Added for load toaster pop US-377858**************/
  
   loadToasterPop = function(url, cb) { 
      var safeURL = SafeURL_createFromURL(url);
        pega.u.d.asyncRequest("POST", safeURL, {
            success: function(oResponse) {
                var toasterpop = $("#toasterpop");
                toasterpop.addClass("alerting").html(oResponse.responseText);
                /* toasterpop.attr("tabindex", -1).focus().css("outline", "none");*/
                cb && cb(true);
            },
            failure: function() {
                alert("Request from server failed.");
                cb && cb(false);
            }
        }, null);
    }
    /********************End of toasterpop**************/
   
   /***************** Start interaction implementation US-377858 Stand alone implementation **************/
   function startInteraction(SiteID, InteractionID, AnswerOnAccept) {
/*
 * Start the standard interaction in a new developer tab
*/
    var strUrl =  "pyActivity=ChannelServices-Interaction-Call.StartInteraction&pySiteID="
    strUrl = strUrl + SiteID;
    strUrl = strUrl + "&pyInteractionID=";
    strUrl = strUrl + InteractionID;
    strUrl = strUrl + "&AutoAnswer=";
    strUrl = strUrl + AnswerOnAccept;
   openWorkByURL(strUrl);
     // Code to close the toaster pop after clicking accept
  hideToasterPop();
  
}
   
   /***************End of start interaction implementation US-377858 Stand alone implementation************/
//static-content-hash-trigger-GCC

/****************Hide toaster pop **********************/

hideToasterPop = function() {
        if ($("#toasterpop").length > 0) {
            $("#toasterpop").removeClass("alerting");
        }
    }

/****************End of hide toaster pop **********************/
//static-content-hash-trigger-GCC
(function (root, factory) {
  if (typeof define === 'function') {
    define(factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.Five9 = root.Five9 || {};
    root.Five9.RestApi = factory();
  }
}(this, function () {
/**
 * almond 0.1.1 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var defined = {},
        waiting = {},
        config = {},
        defining = {},
        aps = [].slice,
        main, req;

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {},
            nameParts, nameSegment, mapValue, foundMap, i, j, part;

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; (part = name[i]); i++) {
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            return true;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                break;
                            }
                        }
                    }
                }

                foundMap = foundMap || starMap[nameSegment];

                if (foundMap) {
                    nameParts.splice(0, i, foundMap);
                    name = nameParts.join('/');
                    break;
                }
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (waiting.hasOwnProperty(name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!defined.hasOwnProperty(name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    function makeMap(name, relName) {
        var prefix, plugin,
            index = name.indexOf('!');

        if (index !== -1) {
            prefix = normalize(name.slice(0, index), relName);
            name = name.slice(index + 1);
            plugin = callDep(prefix);

            //Normalize according
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            p: plugin
        };
    }

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    main = function (name, deps, callback, relName) {
        var args = [],
            usingExports,
            cjsModule, depName, ret, map, i;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i++) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = makeRequire(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = defined[name] = {};
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = {
                        id: name,
                        uri: '',
                        exports: defined[name],
                        config: makeConfig(name)
                    };
                } else if (defined.hasOwnProperty(depName) || waiting.hasOwnProperty(depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else if (!defining[depName]) {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                    cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync) {
        if (typeof deps === "string") {
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 15);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        waiting[name] = [name, deps, callback];
    };

    define.amd = {
        jQuery: true
    };
}());

define("almondlib", function(){});

/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.3",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (A)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

/**
 * Common utility function and methods
 * @module Core
 * @submodule Utils
 */
define('utils',[
  // this module is optimized for fast loading.  don't add modules without evaluating performance cost
  'underscore',
  'jquery'
],
function(_, $) {
  /**
    misc util functions.  if this grows, methods may be split into libs
    underscore / jquery util functions should be preferred over Utils

    @class Utils
    @static
  */

  var INTERNATIONAL_PREFIX = '011';
  // The shortest possible telephone number after the international prefix and a two digit country code.
  var INTERNATIONAL_MIN_NUMBER_LEN = INTERNATIONAL_PREFIX.length + 2 + 5;
  var INTERNATIONAL_MAX_NUMBER_LEN = 20;

  var Utils = {
    // string methods

    /**
     * String trim spaces left and right
     *@method string_trim_lr
     *@param {String} [s]
     *@return string
     */
    string_trim_lr: function(s) {
      return s.replace(/^\s+|\s+$/g,"");
    },

    /**
     * trim whitespace on the left
     *@method string_trim_l
     *@param {String} [s]
     *@return {String}
     */
    string_trim_l: function (s) {
      return s.replace(/^\s+/,"");
    },

    /**
     * trim whitespace on the right
     *@method string_trim_r
     *@param {String} [s]
     *@return {String}
     */
    string_trim_r: function(s) {
      return s.replace(/\s+$/,"");
    },

    /**
     * Strip all whitespace
     *@method string_remove_whitespace
     *@param {String} [s]
     *@return {String}
     */
    string_remove_whitespace: function(s) {
      return s.replace(/\s/g, '');
    },

    /**
     * limit a string to a certain length
     *@method string_truncate
     *@param {String} [s]
     *@param {Number} [n] Length to truncate to
     *@return {String}
     */
    string_truncate: function(s, n) {
      return (s.length>n) ? s.substr(0, n) : s;
    },

    /**
     * Add a "..." to the end of a string
     *@method string_ellipsis
     *@param {String} [s]
     *@param {Number} [n] Length of string to show before the ellipsis
     *@return {String}
     */
    string_ellipsis: function(s, n) {
      return (s.length>n) ? s.substr(0, n-1)+'&hellip;' : s;
    },

    /**
     * Does a string start with a prefix?
     *@method string_startsWith
     *@param {String} [s]
     *@param {String} [prefix]
     *@return {Bool}
     */
    string_startsWith: function(s, prefix) {
      return (s.indexOf(prefix) === 0);
    },

    /**
     * Does a string end with a suffix?
     *@method string_endsWith
     *@param {String} [s]
     *@param {String} [suffix]
     *@return {Bool}
     */
    string_endsWith: function(s, suffix) {
      return s.indexOf(suffix, s.length - suffix.length) !== -1;
    },

    /**
     * Does a string have characters
     *@method string_nonEmpty
     *@param {String} [s]
     *@return {Bool}
     */
    string_nonEmpty: function(s) {
      return _.isString(s) && s !== '';
    },

    // array methods
    /**
     *@method array_clear
     *@param {Array} [a]
     *@return {Array}
     */
    array_clear: function(a) {
      a.splice(0, a.length);
      return a;
    },

    /**
     *@method array_initialize
     *@param {Object} [type]
     *@param {Number} [length]
     *@return {Array}
     */
    array_initialize: function(type, length) {
      var i, a = [];
      for (i = 0; i < length; i++) {
        a[i] = new type();
      }
      return a;
    },

    /**
     * Remove a matching item
     * @method array_remove_at
     * @param {Array} [a] source array
     * @param {Object} [item] item
     * @return {Array} new array
     */
    array_remove: function(a, itemToFind) {
      var item = _.find(a, function(item) {
        return (itemToFind === item);
      });
      if (item) {
        var i = a.indexOf(item);
        a.splice(i, 1);
      }
      return a;
    },

    /**
     * Remove an item at index
     * @method array_remove_at
     * @param {Array} [a] source array
     * @param {Number} [i] array index
     * @return {Array} new array
     */
    array_remove_at: function(a, i) {
      var item = a[i];
      if (item) {
        a.splice(i, 1);
      }
      return a;
    },

    /**
     * Remove an item from an array where
     * the array item is an object with
     * an 'id' attribute matching the id
     *
     * @method array_remove_id
     * @param {Array} [a]
     * @param {String} [id]
     * @return {Array}
     */
    array_remove_id: function(a, id) {
      var item = _.find(a, function(item) {
        if (_.isArray(item.id) && _.isArray(id)) {
          var test = _.difference(item.id, id);
          if (test.length) {
            return false;
          } else
            return true;
        } else
          return (id === item.id);
      });
      if (item) {
        var i = a.indexOf(item);
        a.splice(i, 1);
      }
      return a;
    },

    /**
     * Find a array element object with a matching id
     *
     * @method array_find_id
     * @param {Array} [a]
     * @param {String} [id]
     * @return {Object}
     */
    array_find_id: function(a, id) {
      var item = _.find(a, function(item) {
        return (id === item.id);
      });
      return item;
    },

    /**
     * Find index of array element with a matching id
     *
     * @method array_find_id_index
     * @param {Array} [a]
     * @param {String} [id]
     * @return {index}
     */
    array_find_id_index: function(a, id) {
      var item = _.find(a, function(item) {
        return (_.isEqual(id, item.id));
      });
      return a.indexOf(item);
    },

    /**
     * Replace an array element object with a new
     * item by the element objects id
     *
     * @method array_replace_by_id
     * @param {Array} [a]
     * @param {String} [id]
     * @param {Object} [item] New item
     * @return {Object} item
     */
    array_replace_by_id: function(a, id, item) {
      var foundItem = Utils.array_find_id(a, id);
      var index = _.indexOf(a, foundItem);
      if (index === -1) {
        return null;
      }
      a[index] = item;
      return Utils.array_find_id(a, item.id);
    },

    /**
     * Does an array contain item?
     *
     * @method array_contains
     * @param {Array} [a]
     * @param {Mixed} [val] Array element
     * @return {Mixed} The found item
     */
    array_contains: function(a, val) {
      var item = _.find(a, function(item) {
        return _.isEqual(val, item);
      });
      return item;
    },

    /**
     * Create a new array of just the IDs of
     * the array element objects
     *
     * @method array_flatten_ids
     * @param {Array} [a]
     * @return {Array}
     */
    array_flatten_ids: function(a) {
      return _.map(a, function(item) {
        return item.id;
      });
    },

    /**
     * @method array_clamp
     * @param {Array} [a]
     * @param {Number} [clamp]
     * @param {Object} [item]
     * @return {Array}
     */
    array_clamp: function(a, clamp, item) {
      a = _.clone(a);
      var len = a.length;
      if (len > clamp) {
        a.splice(0, (len-clamp));
      }
      if (len < clamp) {
        for (var i = 0; i < clamp-len; i++) {
          a.splice(0, 0, item);
        }
      }
      return a;
    },

    /**
     * Remove all properties of an object
     *@method object_clear
     *@param {Object} [o]
     */
    object_clear: function(o) {
      _.each(o, function(value, key) {
        if (o.hasOwnProperty(key)) {
          delete o[key];
        }
      });
    },

    /**
     * Delete all object/array/dome elements props on an object (does not iterate on prototype)
     *@method deleteAll
     *@param {Object} [o]
     *@return {Object}
     */
    deleteAll: function(o) {
      if (_.isObject(o)) {
        _.each(o, function(value, key) {
          if (_.isObject(value) || _.isArray(value) || _.isElement(value)) {
            delete o[key];
          }

          if (value instanceof Backbone.Marionette.View && _.isFunction(value.destroy)) {
            value.destroy();
          }

        });
        o.isDestroyed = true;
      }
      return o;
    },

    /**
     * null all object/array/dome elements props on an object (does not iterate on prototype)
     *@method nullAll
     *@param {Object} [o]
     *@return {Object}
     */
    nullAll: function(o) {
      if (_.isObject(o)) {
        _.each(o, function(value, key) {
          if (_.isObject(value) || _.isArray(value) || _.isElement(value)) {
            o[key] = null;
          }
        });
        o.isDestroyed = true;
      }
      return o;
    },

    /**
     * Mixin from an object
     *@method inherit
     *@param {Object} [from]
     */
    inherit: function(from) {
      var to = this.prototype;
      Utils.extendOverrides(to, from);
    },

    /**
     * Mixin from.methodName -> to.methodName
     *
     * @method MethodName
     * @param {Object} [to]
     * @param {Object} [from]
     * @param {Function} [methodName]
     */
    extendMethod: function(to, from, methodName) {
      // if the method is defined on from
      if (!_.isUndefined(from[methodName])) {
        var old = to[methodName];

        // we create a new function on to
        to[methodName] = function() {

          // wherein we first call the method which exists on `to`
          var oldReturn = old.apply(this, arguments);
          // and then call the method on `from`
          from[methodName].apply(this, arguments);
          // and then return the expected result - what the method on `to` returns
          return oldReturn;
        };
      }
    },

    /**
     * Mixin the methods of the passed object
     *
     * @method extendOverrides
     * @param {Object} [obj]
     */
    extendOverrides: function(obj) {
      var slice = Array.prototype.slice;
      _.each(slice.call(arguments, 1), function(source) {
        for (var prop in source) {
          if (obj[prop] === null || obj[prop] === undefined) {
            // simply copy
            obj[prop] = source[prop];
          }
          else {
            // extend method
            Utils.extendMethod(obj, source, prop);
          }
        }
      });
    },

    // DOM
    /**
     * Redirect the browser to URL, optionally retain the query string
     *@method redirect
     *@param {String} [url]
     *@param {Bool} [keep_args]
     */
    redirect: function(url, keep_args) {
      window.location = url + (keep_args === true ? window.location.search : '');
    },

    /**
     *@method getQueryString
     *@param {String} [key]
     *@param {String} [default_]
     *@return {String} Query String
     */
    getQuerystring: function (key, default_) {
      if (default_ === null) default_ = "";
      key = key.replace(/[\[]/,"\\").replace(/[\]]/,"\\");
      var regex = new RegExp("[\\?&]"+key+"=([^&#]*)");
      var qs = regex.exec(window.location.href);
      if (qs === null)
        return default_;
      else
        return decodeURIComponent(qs[1]);
    },
    encodeQueryParams: function(params) {
      var s = '';
      if (_.isObject(params)) {
        var first = true;
        _.each(params, function(value, key) {
          s += (first) ? '?' : '&';
          s += key + '=' + encodeURIComponent(value);
          first = false;
        });
      }
      return s;
    },
    decodeQueryParams: function(s) {
      var obj = {};
      if (_.isString(s) && s !== '') {
        s = s.substring(1);
        s = s.split('&');
        for (var i = 0; i < s.length; i++) {
          var pair = s[i].split('=');
          obj[pair[0]] = decodeURIComponent(pair[1]);
        }
      }
      return obj;
    },

    //browser detection
    getBrowser: function (){
      var N=navigator.appName, ua=navigator.userAgent, tem;
      var M=ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
      if(M && (tem= ua.match(/version\/([\.\d]+)/i))!== null) M[2]= tem[1];
      M=M? [M[1], M[2]]: [N, navigator.appVersion, '-?'];
      return M[0];
    },
    getBrowserVersion: function(){
      var N=navigator.appName, ua=navigator.userAgent, tem;
      var M=ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
      if(M && (tem= ua.match(/version\/([\.\d]+)/i))!== null) M[2]= tem[1];
      M=M? [M[1], M[2]]: [N, navigator.appVersion, '-?'];
      return M[1];
    },

    // deferreds
    /**
     *@method deferredSuccess
     *@return {jQuery.Deferred}
     */
    deferredSuccess: function() {
      var d = $.Deferred();
      d.resolve.apply(this, arguments);
      return d.promise();
    },

    /**
     *@method deferredFail
     *@return {jQuery.Deferred}
     */
    deferredFail: function() {
      var d = $.Deferred();
      d.reject.apply(this, arguments);
      return d.promise();
    },

    // ajax
    /**
     * this helper allows functions that return a promise to be passed on to $.when
     *@method when
     *@param {jQuery.Deferred}
     *@return {jQuery.Deferred}
     */
    when: function(deferreds) {
      //
      var args = Array.prototype.slice.call(arguments);
      var length = args.length;

      var newDeferreds = [];
      _.each(args, function(fn) {
        // is hoisted?
        if ($.isFunction(fn)) {
          var promise = fn();
          if (promise.promise) {
            newDeferreds.push(promise.promise);
          }
          else {
            return Utils.deferredFail('not a valid method');
          }
        }
        // is a deferred
        else if ($.isFunction(fn.promise)) {
          newDeferreds.push(fn);
        }
        else {
          newDeferreds.push(fn);
        }
      });
      return $.when.apply(this, newDeferreds);
    },

    /**
     * Make a nice looking error report
     *
     *@method format_XHR_ErrorMessage
     *@param {String} [prefix] Prefix to the error message
     *@param {Object} [xhr] jQuery.XHR
     *@param {String} [status]
     *@param {String} [error]
     *@return {String} Error message
     */
    format_XHR_ErrorMessage: function(prefix, xhr, status, error) {
      var errorMessage = prefix + '\n';

      try {
        errorMessage += $(xhr.responseText).text() + '\n';
      }
      catch(ex) {
        // no need to catch this
      }

      errorMessage += 'Status Code: ' + xhr.status + '\n';
      if (status) {
        errorMessage += 'Status: ' + status + '\n';
      }
      if (error) {
        errorMessage += 'Error: ' + error + '\n';
      }
      return errorMessage;
    },

    /**
     *@method encodeBasicAuthentication
     *@param {String} [username]
     *@param {String} [password]
     *@return {String} Encoded auth header
     */
    encodeBasicAuthentication: function(username, password) {
      // Use Base64 encoding to create the authentication details
      // Using unescape and encodeURIComponent to allow for Unicode strings
      // https://developer.mozilla.org/en-US/docs/Web/API/window.btoa#Unicode_Strings
      return 'Basic ' + btoa(unescape(encodeURIComponent([username, password].join(':'))));
    },

    // misc
    /**
     *@method generateGuid
     *@return {string} GUID
     */
    generateGuid: function() {
      // rfc4122 version 4 compliant
      // see http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
      // Original solution - http://www.broofa.com/2008/09/javascript-uuid-function/
      // Updated with - http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
      var d = Date.now();
      var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : (r&0x7|0x8)).toString(16);
      });
      return uuid;
    },

    /**
     * Format a string
     *@example Utils.format('string {0} test {1}', 'aaa', 'bbb')
     *@method formatString
     *@param {String} s
     *@param {String} @optional additonal arguments
     *@return {String}
     */
    formatString: function(s) {
      // simple format method.  ex: Utils.format('string {0} test {1}', 'aaa', 'bbb')
      // more interesting string manipulation should use underscore.string
      var args = arguments;
      return s.replace(/\{(\d+)\}/g, function(match, number) {
        number = parseInt(number, 10) + 1;
        if (typeof args[number] === 'undefined') {
          return undefined;
        }
        var arg = args[number];
        if (_.isObject(arg)) {
          arg = JSON.stringify(arg);
        }
        return arg;
      });
    },

    // types

    /**
     * Ensure the value is a number, supply a default
     * @method safeParseInt
     * @param {Number} [value]
     * @param {Number} [defaultValue]
     * @return {Number}
     */
    safeParseInt: function(value, defaultValue) {
      try {
        value = parseInt(value, 10);
        if (_.isNaN(value)) {
          return defaultValue;
        }
        return value;
      }
      catch(error) {
        // use default
        return defaultValue;
      }
    },
    /**
     *@method isInt
     *@param {String|Number} [n]
     *@return {Number}
     */
    isInt: function(n) {
      return parseInt(n, 10) === n;
    },
    /**
     *@method clamp
     *@param {Number} [value]
     *@param {Number} [min]
     *@param {Number} [max]
     *@return {Number}
     */
    clamp: function(value, min, max) {
      return Math.min(Math.max(min, value), max);
    },
    /**
     *@method range
     *@param {Number} [value]
     *@param {Number} [range]
     *@param {Number} [minRange]
     *@param {Number} [maxRange]
     *@param {Number}
     */
    range: function(value, range, minRange, maxRange) {
      return (value/range) * (maxRange-minRange) + minRange;
    },

    /**
     *@method getRandomInt
     *@param {Number} [min]
     *@param {Number} [max]
     *@return {Number}
     */
    getRandomInt: function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },
    /**
     *@method getRandomFloat
     *@param {Number} [min]
     *@param {Number} [max]
     *@return {Number}
     */
    getRandomFloat: function(min, max) {
      return Math.random() * (max - min) + min;
    },
    /**
     *@method getRandomBool
     *@return {Boolean}
     */
    getRandomBool: function() {
      return Utils.getRandomInt(0, 1);
    },
    /**
     *@method getRandomDate
     *@return {Date}
     */
    getRandomDate: function(start, end) {
      if (!start) {
        throw new Error('start is required');
      }
      if (!end) {
        end = new Date();
      }
      return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
    },

    // dates
    /**
     *@method dateToUTC
     *@param {Date} [date]
     *@return {String} formatted date
     */
    dateToUTC: function(date) {
      return (Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds()) / 1000);
    },

    /**
     * Add time to a date in hours
     *
     * @method addHours
     * @for ForClass
     * @param {Date} [date]
     * @param {Number} [h] hours
     * @return {Date}
     */
    addHours: function(date, h) {
      date.setTime(date.getTime() + (h*60*60*1000));
    },

    // conversion
    /**
     * Query string to an object conversion
     *
     * @method paramsToObject
     * @param {String} [data]
     * @return {Object|null}
     */
    paramsToObject: function(data) {
      // key=value&key=value to {key:value}
      if (_.isString(data)) {
        var ret = {};

        var pairs = data.split('&');
        _.each(pairs, function(item) {
          item = item.split('=');
          if (item.length > 1) {
            ret[ item[0] ] = item[1];
          }
        });
        return ret;
      }
      return null;
    },

    // cookie
    /**
     * Get a cookie value or default value
     *
     * @method getCookieValue
     * @for ForClass
     * @param {String} [id]
     * @param {Mixed} [defaultValue]
     * @return {Mixed} Value of cookie or default value
     */
    getCookieValue: function(id, defaultValue) {
      return ($.cookie(id)) ? $.cookie(id) : defaultValue;
    },

    /**
     * Test if value is "valid" - invalid values are null or undefined
     *
     * @method isValid
     * @param {Mixed} [value]
     * @param {Mixed} [defaultValue]
     * @return {Mixed} value if valid, defaultValue if not
     */
    isValid: function(value, defaultValue) {
      try {
        if ((typeof value === "undefined") || (value === "undefined") || (value === "null") || (value === null)) {
          return defaultValue;
        } else {
          return value;
        }
      } catch (err) {
        return defaultValue;
      }
    },

    /**
     * Attempt to convert string to json, returns default if not valid json
     *
     * @method safeJSONParse
     * @param {string} [string]
     * @param {Mixed} [defaultValue]
     * @return {Mixed} json value if valid json, defaultValue if not
     */
    safeJSONParse: function(string, defaultValue) {
      try {
        return JSON.parse(string);
      }
      catch (err) {
        console.error('Unable to parse [' + string + ']');
        return defaultValue;
      }
    },

    formatDuration: function(duration) {
      var s = duration % 60;
      var m = parseInt(duration / 60, 0);
      if (m < 60) {
        return (m + 'm ' + s + 's');
      }

      var h = parseInt(m / 60, 0);
      m = (m % 60);

      if (h < 24) {
        return (h + 'h ' + m + 'm');
      }

      return '> 1d';
    },

    hasLink: function(text) {
      //URLs starting with http://, https://, or ftp://
      var exp = /(\b(((https?|file|):\/\/)))/ig;
      return exp.test(text);
    },
    linkify: function(inputText, truncate) {
      if (this.isValid(inputText, null) === null) {
        return "";
      }

      var replacedText, replacePattern1, replacePattern2, replacePattern3, replacePattern4;

      //URLs starting with http://, https://, or ftp://
      replacePattern1 = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim;
      replacedText = inputText.replace(replacePattern1, '<a href="$1" target="_blank">$1</a>');

      //URLs starting with "www." (without // before it, or it'd re-link the ones done above).
      replacePattern2 = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
      replacedText = replacedText.replace(replacePattern2, '$1<a href="http://$2" target="_blank">$2</a>');

      //Change email addresses to mailto:: links.
      replacePattern3 = /(([a-zA-Z0-9\-\_\.])+@[a-zA-Z0-9\-\_\.]+?(\.[a-zA-Z]{2,6})+)/gim;
      replacedText = replacedText.replace(replacePattern3, '<a href="mailto:$1">$1</a>');

      var lvData = $("<div>" + replacedText + "</div>");
      if (truncate) {
        lvData.find("a").each(function() {
          var value = $(this).html();
          if (value.length > 35) {
              $(this).html(value.substr(0, 35) + '...');
          }
        });
      }
      return lvData.html();
    },

    htmlEncode: function(text){
      return $('<div/>').text(text).html();
    },

    htmlDecode: function(text){
      return $('<div/>').html(text).text();
    },

    newLinesToBR: function(text) {
      return text.replace(/[\n\r]/g, '<br/>');
    },

    getDateFromSeconds: function(dateInSeconds) {
      var dateInMillisecond =  dateInSeconds * 1000;
      return new Date(dateInMillisecond);
    },

    saveSelection: function(input) {
      if (window.getSelection) {
        var sel = window.getSelection();
        if (sel.getRangeAt && sel.rangeCount) {
          return sel.getRangeAt(0);
        }
        else {
          if (input && 'selectionStart' in input.get(0) && input.contents && input.contents().length > 0) {
            var selectionStart = input.get(0).selectionStart;
            var selectionEnd = input.get(0).selectionEnd;
            var range = document.createRange();
            var startFound = false;
            var endFound = false;

            _.each(input.contents(), function(childNode) {
              if (childNode.nodeType === 3) {
                if (!startFound) {
                  if (selectionStart <= childNode.length) {
                    range.setStart(childNode, selectionStart);
                    startFound = true;
                  }
                  else {
                    selectionStart -= childNode.length;
                  }
                }

                if (!endFound) {
                  if (selectionEnd <= childNode.length) {
                    range.setEnd(childNode, selectionEnd);
                    endFound = true;
                  }
                  else {
                    selectionEnd -= childNode.length;
                  }
                }
              }
            });

            return range;
          }
        }
      } else if (document.selection && document.selection.createRange) {
        return document.selection.createRange();
      }
      return null;
    },

    restoreSelection: function(range) {
      if (range) {
        if (window.getSelection) {
          sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        } else if (document.selection && range.select) {
          range.select();
        }
      }
    },

    insertTextAtCaret: function(textValue) {
      var range = null;

      var selection = window.getSelection();
      if (selection.getRangeAt && selection.rangeCount) {
        range = selection.getRangeAt(0);
        range.deleteContents();
        var textNode = document.createTextNode(textValue);
        range.insertNode(textNode);
        range.setStartAfter(textNode);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    },
    insertHtmlAtCaret: function(htmlValue) {
      var range = null;

      var selection = window.getSelection();
      if (selection.getRangeAt && selection.rangeCount) {
        range = selection.getRangeAt(0);
        range.deleteContents();
        var $node = $(htmlValue);
        var node = $node[0];
        range.insertNode(node);
        range.setStartAfter(node);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    },

    getUUID: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16|0, v = c === 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
      });
    },

    validatePhoneNumber: function(number){
      if (typeof number !== 'string')
        return false;

      if (number.indexOf('+') >= 0) {
        if (number.indexOf('+') !== 0)
          return false;

        if (number.lastIndexOf('+') !== 0)
          return false;
      }

      return !_.isEmpty(number) &&
        /^[\d\s\\'!"#\$%&\(\)\*\+,\-\.\/:;<=>\?@\[\]\^_`\{\|\}~]+$/.test(number) &&
        number.replace(/\D/g, '').length >= INTERNATIONAL_MIN_NUMBER_LEN &&
        number.replace(/\D/g, '').length <= INTERNATIONAL_MAX_NUMBER_LEN;
    },
    escapeHtml: function(str) {
      var div = document.createElement('div');
      div.appendChild(document.createTextNode(str));
      return div.innerHTML;
    },
    stripHtml: function(str) {
      var safeText = str.replace(/&gt;/ig, ">");
      safeText = safeText.replace(/&lt;/ig, "<");
      safeText = safeText.replace(/(<([^>]+)>)/ig,"");
      return safeText;
    },
    stripHtmlScripts: function(s) {
      var div = document.createElement('div');
      div.innerHTML = s;
      var scripts = div.getElementsByTagName('script');
      var i = scripts.length;
      while (i--) {
        scripts[i].parentNode.removeChild(scripts[i]);
      }
      return div.innerHTML;
    },

    /**
     * Returns human readable string from html:
     * removes head tag content except title,
     * encodes HTML characters and prettifies spaces
     *
     * @method htmlToText
     * @param {string} [html]
     * @return {String}
     */
    htmlToText: function(html){
      var textarea = document.createElement("textarea");
      textarea.innerHTML = html;
      var text =  textarea.value;
      text = text.replace(/<head[^>]*>[\s\S]*<\/head>/gi, function(head){
        var title = head.match(/<title[^>]*>[\s\S]*<\/title>/gi);
        if(title && title.length > 0) {
          return title[0];
        }
        return '';
      });
      return Utils.stripHtml(text).replace(/\n/g, '').replace(/\s{2,}/g, ' ');
    },

    reportIncorrectFormat: function(category, message) {
      var args = Array.prototype.slice.call(arguments, 2);
      var finalMessage = '[' + category + '] API error: ' + message + ' is incorrect format.  truncation may have occurred.';
      console.warn(finalMessage);
    },

    arrayToSeparatedString: function(items, separator) {
      var s = '';
      if (items && _.isArray(items)) {
        items = _.map(items, function(item) {
          if (item && _.isString(item)) {
            return item.trim();
          }
        });
        items = _.filter(items, function(item) {
          if (item && _.isString(item)) {
            return item;
          }
        });

        for (var i = 0, l = items.length; i < l; i++) {
          s = s + items[i] + (i !== (l-1) ? separator : '');
        }
      }
      return s;
    }
  };

  return Utils;
});


/**
 * This module contains core features like the
 * ability to load and manage framework components.
 *
 * @module Core
 * @submodule UI
 */

define('core',[
  'underscore',
  'jquery',
  'utils'
],
function(_, $, Utils) {
  /**
   * Top level namespace for the Core object
   *
   * @class Core
   * @static
   */
  var Core = {
    /**
     * The event aggregator object
     * @property vent
     * @type {Object}
     */
    vent: null,

    /**
     * Store loaded bundles
     * @property loadedBundles
     * @type {Array}
     */
    loadedBundles: [],

    /**
     * track non-singleton components
     * @property createdComponents
     * @type {Array}
     */
    createdComponents: []
  };

  /**
   * Core object events.
   *
   * @namespace Core
   * @class Events
   * @static
   */
  Core.Events = {
    /**
     * Fires when the core begins loading
     * @event core:load
     */
    Load: 'core:load',

    /**
     * Fires when the core is done loading
     * @event core:load_complete
     */
    LoadComplete: 'core:load_complete',

    /**
     * Fires when there is an error loading something
     * with the core.
     * @event core:load_error
     */
    LoadError: 'core:load_error'
  };

  /**
   * An object that keeps an array of loaded components.
   *
   * @namespace Core
   * @class ComponentContainer
   * @constructor
   */
  Core.ComponentContainer = function() {
    this._components = [];
    return this;
  };
  _.extend(Core.ComponentContainer.prototype, {
    /**
     * Add a component to the ComponentContainer
     * @method addComponent
     * @param {Object} [component] The component object
     */
    addComponent: function(component) {
      this._components.push(component);
    },

    /**
     * Remove all the components of this container
     * And all their teardown method for memory cleanup.
     *
     * @method destroy
     */
    destroy: function() {
      _.each(this._components, function(component) {
        component.destroy();
      });
      this._components = [];
    }
  });

  /**
   * Dictionary-based container for components
   *
   * @namespace Core
   * @class ComponentHash
   * @contructor
   */
  Core.ComponentHash = function() {
    this._components = {};
    return this;
  };
  _.extend(Core.ComponentHash.prototype, {
    /**
     * Add a component to the hash
     *
     * @method add
     * @param {String} [id]
     * @param {Object} [component]
     */
    add: function(id, component) {
      if (this.get(id) !== null) {
        console.warn('component added multiple times to component cache', id);
      }
      this._components[id] = component;
    },
    /**
     * Get a component from the hash by its id
     *@method get
     *@param {String} [id]
     */
    get: function(id) {
      if (this._components.hasOwnProperty(id)) {
        return this._components[id];
      }
      return null;
    },
    /**
     * Remove a component from the hash by its id
     *@param {String} [id]
     */
    remove: function(id) {
      var component = this.get(id);
      if (component) {
        component.destroy();
      }
      delete this._components[id];
    },
    /**
     * Destroy the hash and clean up all components
     *@method destroy
     */
    destroy: function() {
      _.each(this._components, function(component) {
        component.destroy();
      });
      this._components = {};
    }
  });

  /**
   *@method loadBundle
   *@for Core
   *@param {String} [name] The name of the bundle to load
   *@todo Add an example
   *@return {jQuery.Promise} Promise object
   */
  Core.loadBundle = function(name) {
    console.log('Loading bundle', name);

    var dfd = $.Deferred();
    var loadedBundle = Core.getLoadedBundle(name);
    if (loadedBundle !== null) {
      // bundle already loaded
      dfd.resolve(loadedBundle);
      return dfd.promise();
    }

    var requireConfig = require.s.contexts._.config;
    Core.trigger(Core.Events.Load, name);

    // find path
    var fullPath = 'bundles/' + name + '.bundle';

    // use require to load the bundle
    require([fullPath], function(bundle) {
      Core.trigger(Core.Events.LoadComplete, {name:name,bundle:bundle});
      Core.loadedBundles.push({file:name,bundle:bundle});
      dfd.resolve(bundle);
    },
    function(err) {
      if (err.requireType === 'timeout') {
        console.error('Could not load bundle ' + err.requireModules);
      } else {
        // If a timeout hasn't occurred and there was another module
        // related error, unload the module report an error
        var failedId = err.requireModules && err.requireModules[0];
        require.undef(failedId);
      }
      console.error('Error loading bundle [' + name + ']', err);
      console.error(err.stack);
      dfd.reject(err);
    });

    return dfd.promise();
  };


  /**
   * Check if a bundle is already loaded
   *@method isBundleLoaded
   *@for Core
   *@param {String} [file] Bundle file name
   *@return {Bool}
   */
  Core.isBundleLoaded = function(file) {
    return (Core.getLoadedBundle(file) === null) ? false : true;
  };

  /**
   *
   *@method getLoadedBundle
   *@for Core
   *@param {String} [file] Bundle file name
   *@return {Object} Loaded component
   */
  Core.getLoadedBundle = function(file) {
    var found = null;
    _.each(Core.loadedBundles, function(bundle) {
      if (bundle.file === file) {
        found = bundle.bundle;
        return;
      }
    });
    return found;
  };

  /**
   *
   *@method isComponentCreated
   *@for Core
   *@param {String} [file] Name of component
   *@return {Bool} Is component loaded?
   */
  Core.isComponentCreated = function(file) {
    return (Core.getCreatedComponent(file) === null) ? false : true;
  };

  /**
   *@method getCreatedComponent
   *@for Core
   *@param {String} [file] Name of component
   *@return {Object} Component Object
   */
  Core.getCreatedComponent = function(file) {
    var found = null;
    _.each(Core.createdComponents, function(component) {
      if (component.file === file) {
        found = component.component;
        return;
      }
    });
    return found;
  };

  /**
   *
   *@method getCreatedComponentIndex
   *@for Core
   *@param {String} [file] Component name
   *@return {Object} Component
   */
  Core.getCreatedComponentIndex = function(file) {
    return _.find(Core.createdComponents, function(component) {
      return (component.file === file);
    });
  };

  /**
   *@method addCreatedComponent
   *@for Core
   *@param {String} [file] Component name
   *@param {Object} [component] Component object
   */
  Core.addCreatedComponent = function(file, component) {
    Core.createdComponents.push({file:file,component:component});
  };

  /**
   *@method removeCreatedComponent
   *@for Core
   *@param {String} [file] Component name
   */
  Core.removeCreatedComponent = function(file) {
    var index = Core.getCreatedComponentIndex(file);
    Core.createdComponents.splice(index, 1);
  };

  /**
   *@method findLoadedComponent
   *@for Core
   *@param {String} [file] Component Name
   *@return {Object | null}
   */
  Core.findLoadedComponent = function(file) {
    var contextMap = require.s.contexts._.defined;
    for (var key in contextMap) {
      if (contextMap.hasOwnProperty(key) && key.indexOf(file) !== -1) {
        return contextMap[file];
      }
    }
    return null;
  };

  /**
   *@method createComponents
   *@for Core
   *@param {Array} [keys]
   *@param {ComponentContainer}
   */
  Core.createComponents = function(keys, container) {
    var key;
    for (key in keys) {
      Core.createComponent(key, keys[key], container);
    }
  };

  /**
   *@method createComponent
   *@for Core
   *@param {String} [file]
   *@param {Object} [options]
   *@param {ComponentContainer} [container]
   *@return {Component}
   *@bubbles Core.Events.LoadError on error
   */
  Core.createComponent = function(file, options, container) {
    if (options instanceof Core.ComponentContainer) {
      // allow container to be passed as the second param
      container = options;
      options = {};
    }
    options = options || {};

    if (options.singleton && Core.isComponentCreated(file)) {
      return Core.getCreatedComponent(file);
    }

    console.log('Creating component [' + file + ']');
    var main = Core.findLoadedComponent('components/' + file + '/main');
    if (main === null) {
      console.warn('Unable to load component [' + file + ']');
      Core.trigger(Core.Events.LoadError, file);
      return null;
    }
    var component = new main(file, options);
    if (options.singleton) {
      Core.addCreatedComponent(file, component);
    }
    else {
      if (container) {
        container.addComponent(component);
      }
    }
    return component;
  };

  /**
   * Alias to Core.vent.trigger
   * Trigger the event on the aggregator
   *@param {String} [name] Event name
   *@param {Object} [data] Event data payload
   */
  Core.trigger = function(name, data) {
    if (Core.vent) {
      Core.vent.trigger(name, data);
    }
  };

  /**
   * An alias to Utils.deleteAll
   *@method deleteAll
   *@for Core
   */
  Core.deleteAll = Utils.deleteAll;

  /**
   * An alias to Utils.nullAll
   *@method nullAll
   *@for Core
   */
  Core.nullAll = Utils.nullAll;

  return Core;
});

//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define('backbone',['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

(function(root) {
define("marionette", ["backbone"], function() {
  return (function() {
 // Backbone.Marionette, v1.0.0-rc2
 // Copyright (c)2012 Derick Bailey, Muted Solutions, LLC.
 // Distributed under MIT license
 // http://github.com/marionettejs/backbone.marionette


/*!
 * Includes BabySitter
 * https://github.com/marionettejs/backbone.babysitter/
 *
 * Includes Wreqr
 * https://github.com/marionettejs/backbone.wreqr/
 *
 * Includes EventBinder
 * https://github.com/marionettejs/backbone.eventbinder/
 */


// Backbone.BabySitter, v0.0.4
// Copyright (c)2012 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
// http://github.com/marionettejs/backbone.babysitter
// Backbone.ChildViewContainer
// ---------------------------
//
// Provide a container to store, retrieve and
// shut down child views.

Backbone.ChildViewContainer = (function(Backbone, _){

  // Container Constructor
  // ---------------------

  var Container = function(initialViews){
    this._views = {};
    this._indexByModel = {};
    this._indexByCollection = {};
    this._indexByCustom = {};
    this._updateLength();

    this._addInitialViews(initialViews);
  };

  // Container Methods
  // -----------------

  _.extend(Container.prototype, {

    // Add a view to this container. Stores the view
    // by `cid` and makes it searchable by the model
    // and/or collection of the view. Optionally specify
    // a custom key to store an retrieve the view.
    add: function(view, customIndex){
      var viewCid = view.cid;

      // store the view
      this._views[viewCid] = view;

      // index it by model
      if (view.model){
        this._indexByModel[view.model.cid] = viewCid;
      }

      // index it by collection
      if (view.collection){
        this._indexByCollection[view.collection.cid] = viewCid;
      }

      // index by custom
      if (customIndex){
        this._indexByCustom[customIndex] = viewCid;
      }

      this._updateLength();
    },

    // Find a view by the model that was attached to
    // it. Uses the model's `cid` to find it, and
    // retrieves the view by it's `cid` from the result
    findByModel: function(model){
      var viewCid = this._indexByModel[model.cid];
      return this.findByCid(viewCid);
    },

    // Find a view by the collection that was attached to
    // it. Uses the collection's `cid` to find it, and
    // retrieves the view by it's `cid` from the result
    findByCollection: function(col){
      var viewCid = this._indexByCollection[col.cid];
      return this.findByCid(viewCid);
    },

    // Find a view by a custom indexer.
    findByCustom: function(index){
      var viewCid = this._indexByCustom[index];
      return this.findByCid(viewCid);
    },

    // Find by index. This is not guaranteed to be a
    // stable index.
    findByIndex: function(index){
      return _.values(this._views)[index];
    },

    // retrieve a view by it's `cid` directly
    findByCid: function(cid){
      return this._views[cid];
    },

    // Remove a view
    remove: function(view){
      var viewCid = view.cid;

      // delete model index
      if (view.model){
        delete this._indexByModel[view.model.cid];
      }

      // delete collection index
      if (view.collection){
        delete this._indexByCollection[view.collection.cid];
      }

      // delete custom index
      var cust;

      for (var key in this._indexByCustom){
        if (this._indexByCustom.hasOwnProperty(key)){
          if (this._indexByCustom[key] === viewCid){
            cust = key;
            break;
          }
        }
      }

      if (cust){
        delete this._indexByCustom[cust];
      }

      // remove the view from the container
      delete this._views[viewCid];

      // update the length
      this._updateLength();
    },

    // Call a method on every view in the container,
    // passing parameters to the call method one at a
    // time, like `function.call`.
    call: function(method, args){
      args = Array.prototype.slice.call(arguments, 1);
      this.apply(method, args);
    },

    // Apply a method on every view in the container,
    // passing parameters to the call method one at a
    // time, like `function.apply`.
    apply: function(method, args){
      var view;

      // fix for IE < 9
      args = args || [];

      _.each(this._views, function(view, key){
        if (_.isFunction(view[method])){
          view[method].apply(view, args);
        }
      });

    },

    // Update the `.length` attribute on this container
    _updateLength: function(){
      this.length = _.size(this._views);
    },

    // set up an initial list of views
    _addInitialViews: function(views){
      if (!views){ return; }

      var view, i,
          length = views.length;

      for (i=0; i<length; i++){
        view = views[i];
        this.add(view);
      }
    }
  });

  // Borrowing this code from Backbone.Collection:
  // http://backbonejs.org/docs/backbone.html#section-106
  //
  // Mix in methods from Underscore, for iteration, and other
  // collection related features.
  var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
    'select', 'reject', 'every', 'all', 'some', 'any', 'include',
    'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
    'last', 'without', 'isEmpty', 'pluck'];

  _.each(methods, function(method) {
    Container.prototype[method] = function() {
      var views = _.values(this._views);
      var args = [views].concat(_.toArray(arguments));
      return _[method].apply(_, args);
    };
  });

  // return the public API
  return Container;
})(Backbone, _);

// Backbone.EventBinder, v1.0.2
// Copyright (c)2012 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
// http://github.com/marionettejs/backbone.eventbinder
// EventBinder
// -----------
//
// The event binder facilitates the binding and unbinding of events
// from objects that extend `Backbone.Events`. It makes
// unbinding events, even with anonymous callback functions,
// easy.
//
// Inspired by [Johnny Oshika](http://stackoverflow.com/questions/7567404/backbone-js-repopulate-or-recreate-the-view/7607853#7607853)

Backbone.EventBinder = (function(Backbone, _){
  "use strict";

  // A map of objects that support binding/unbinding events.
  // This allows EventBinder to support events on arbitrary
  // objects with EB's consistent api.
  var handlerMap = {
    // 'default' type accounts for Backbone style objects extending
    // Backbone.Events
    "default" : {
      bindTo : function (obj, eventName, callback, context) {
        context = context || this;
        obj.on(eventName, callback, context);

        var binding = {
          type : 'default',
          obj: obj,
          eventName: eventName,
          callback: callback,
          context: context
        };

        return binding;
      },
      unbindFrom : function(binding){
        binding.obj.off(binding.eventName, binding.callback, binding.context);
      }
    },

    // 'jquery' style handlers allow us to bind to jQuery
    // (or compatible) objects
    jquery : {
      bindTo : function (obj, eventName, callback, context) {
        context = context || this;
        callback = _(callback).bind(context);
        obj.on(eventName, callback);

        var binding = {
          type : 'jquery',
          obj: obj,
          eventName: eventName,
          callback: callback,
          context: context
        };

        return binding;
      },
      unbindFrom : function(binding){
        binding.obj.off(binding.eventName, binding.callback);
      }
    }
  };

  // Use whatever best logic necessary to determine the type
  // of the supplied object
  function getHandlerForObject(obj) {
    if (_.isUndefined(obj) || _.isNull(obj)) {
      throw new Error("Can't bindTo undefined");
    }

    if (obj.jquery) { return handlerMap.jquery; }

    return handlerMap["default"];
  }

  // Constructor function
  var EventBinder = function(){
    this._eventBindings = [];
  };

  // Copy the `extend` function used by Backbone's classes
  EventBinder.extend = Backbone.View.extend;

  // Extend the EventBinder with additional methods
  _.extend(EventBinder.prototype, {

    // Delegate to the bindTo for the appropriate type and
    // store the event binding in array so it can be unbound
    // easily, at a later point in time.
    bindTo: function(/* args... */) {
      var obj = arguments[0];
      var handlers = getHandlerForObject(obj);

      var args = Array.prototype.slice.apply(arguments);
      var binding = handlers.bindTo.apply(this, args);

      this._eventBindings.push(binding);

      return binding;
    },

    // Unbind from a single binding object. Binding objects are
    // returned from the `bindTo` method call.
    unbindFrom: function(binding) {
      var args = Array.prototype.slice.apply(arguments);
      handlerMap[binding.type].unbindFrom.apply(this, args);

      this._eventBindings = _.reject(this._eventBindings, function(bind){return bind === binding;});
    },

    // Unbind all of the events that we have stored.
    unbindAll: function() {
      // The `unbindFrom` call removes elements from the array
      // while it is being iterated, so clone it first.
      var bindings = _.map(this._eventBindings, _.identity);
      _.each(bindings, this.unbindFrom, this);
    }
  });

  return EventBinder;
})(Backbone, _);

// Backbone.Wreqr, v0.1.0
// Copyright (c)2012 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
// http://github.com/marionettejs/backbone.wreqr
Backbone.Wreqr = (function(Backbone, Marionette, _){
  "option strict";
  var Wreqr = {};

  // Handlers
  // --------
  // A registry of functions to call, given a name

  Wreqr.Handlers = (function(Backbone, _){
    "option strict";

    // Constructor
    // -----------

    var Handlers = function(){
      "use strict";
      this._handlers = {};
    };

    Handlers.extend = Backbone.Model.extend;

    // Instance Members
    // ----------------

    _.extend(Handlers.prototype, {

      // Add a handler for the given name, with an
      // optional context to run the handler within
      addHandler: function(name, handler, context){
        var config = {
          callback: handler,
          context: context
        };

        this._handlers[name] = config;
      },

      // Get the currently registered handler for
      // the specified name. Throws an exception if
      // no handler is found.
      getHandler: function(name){
        var config = this._handlers[name];

        if (!config){
          throw new Error("Handler not found for '" + name + "'");
        }

        return function(){
          var args = Array.prototype.slice.apply(arguments);
          return config.callback.apply(config.context, args);
        };
      },

      // Remove a handler for the specified name
      removeHandler: function(name){
        delete this._handlers[name];
      },

      // Remove all handlers from this registry
      removeAllHandlers: function(){
        this._handlers = {};
      }
    });

    return Handlers;
  })(Backbone, _);

  // Wreqr.Commands
  // --------------
  //
  // A simple command pattern implementation. Register a command
  // handler and execute it.
  Wreqr.Commands = (function(Wreqr){
    "option strict";

    return Wreqr.Handlers.extend({
      execute: function(){
        var name = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);

        this.getHandler(name).apply(this, args);
      }
    });

  })(Wreqr);

  // Wreqr.RequestResponse
  // ---------------------
  //
  // A simple request/response implementation. Register a
  // request handler, and return a response from it
  Wreqr.RequestResponse = (function(Wreqr){
    "option strict";

    return Wreqr.Handlers.extend({
      request: function(){
        var name = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);

        return this.getHandler(name).apply(this, args);
      }
    });

  })(Wreqr);

  // Event Aggregator
  // ----------------
  // A pub-sub object that can be used to decouple various parts
  // of an application through event-driven architecture.

  Wreqr.EventAggregator = (function(Backbone, _){
    "option strict";
    var EA = function(){};

    // Copy the `extend` function used by Backbone's classes
    EA.extend = Backbone.Model.extend;

    // Copy the basic Backbone.Events on to the event aggregator
    _.extend(EA.prototype, Backbone.Events);

    return EA;
  })(Backbone, _);


  return Wreqr;
})(Backbone, Backbone.Marionette, _);

Backbone.Marionette = Marionette = (function(Backbone, _, $){
  var Marionette = {};

// Helpers
// -------

// For slicing `arguments` in functions
var slice = Array.prototype.slice;

// Marionette.extend
// -----------------

// Borrow the Backbone `extend` method so we can use it as needed
Marionette.extend = Backbone.Model.extend;

// Marionette.getOption
// --------------------

// Retrieve an object, function or other value from a target
// object or it's `options`, with `options` taking precedence.
Marionette.getOption = function(target, optionName){
  if (!target || !optionName){ return; }
  var value;

  if (target.options && target.options[optionName]){
    value = target.options[optionName];
  } else {
    value = target[optionName];
  }

  return value;
};

// Mairionette.createObject
// ------------------------

// A wrapper / shim for `Object.create`. Uses native `Object.create`
// if available, otherwise shims it in place for Marionette to use.
Marionette.createObject = (function(){
  var createObject;

  // Define this once, and just replace the .prototype on it as needed,
  // to improve performance in older / less optimized JS engines
  function F() {}


  // Check for existing native / shimmed Object.create
  if (typeof Object.create === "function"){

    // found native/shim, so use it
    createObject = Object.create;

  } else {

    // An implementation of the Boodman/Crockford delegation
    // w/ Cornford optimization, as suggested by @unscriptable
    // https://gist.github.com/3959151

    // native/shim not found, so shim it ourself
    createObject = function (o) {

      // set the prototype of the function
      // so we will get `o` as the prototype
      // of the new object instance
      F.prototype = o;

      // create a new object that inherits from
      // the `o` parameter
      var child = new F();

      // clean up just in case o is really large
      F.prototype = null;

      // send it back
      return child;
    };

  }

  return createObject;
})();

// Trigger an event and a corresponding method name. Examples:
//
// `this.triggerMethod("foo")` will trigger the "foo" event and
// call the "onFoo" method.
//
// `this.triggerMethod("foo:bar") will trigger the "foo:bar" event and
// call the "onFooBar" method.
Marionette.triggerMethod = function(){
  var args = Array.prototype.slice.apply(arguments);
  var eventName = args[0];
  var segments = eventName.split(":");
  var segment, capLetter, methodName = "on";

  for (var i = 0; i < segments.length; i++){
    segment = segments[i];
    capLetter = segment.charAt(0).toUpperCase();
    methodName += capLetter + segment.slice(1);
  }

  this.trigger.apply(this, args);

  if (_.isFunction(this[methodName])){
    args.shift();
    return this[methodName].apply(this, args);
  }
};

// DOMRefresh
// ----------
//
// Monitor a view's state, and after it has been rendered and shown
// in the DOM, trigger a "dom:refresh" event every time it is
// re-rendered.

Marionette.MonitorDOMRefresh = (function(){
  // track when the view has been rendered
  function handleShow(view){
    view._isShown = true;
    triggerDOMRefresh(view);
  }

  // track when the view has been shown in the DOM,
  // using a Marionette.Region (or by other means of triggering "show")
  function handleRender(view){
    view._isRendered = true;
    triggerDOMRefresh(view);
  }

  // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
  function triggerDOMRefresh(view){
    if (view._isShown && view._isRendered){
      if (_.isFunction(view.triggerMethod)){
        view.triggerMethod("dom:refresh");
      }
    }
  }

  // Export public API
  return function(view){
    view.bindTo(view, "show", function(){
      handleShow(view);
    });

    view.bindTo(view, "render", function(){
      handleRender(view);
    });
  };
})();


// EventBinder
// -----------
// Import the event binder from it's new home
// https://github.com/marionettejs/backbone.eventbinder
Marionette.EventBinder = Backbone.EventBinder.extend();

// Add the EventBinder methods to the view directly,
// but keep them bound to the EventBinder instance so they work properly.
// This allows the event binder's implementation to vary independently
// of it being attached to the view... for example the internal structure
// used to store the events can change without worry about it interfering
// with Marionette's views.
Marionette.addEventBinder = function(target){
  var eventBinder = new Marionette.EventBinder();
  target.eventBinder = eventBinder;

  target.bindTo = function(source, event, callback, context){
    // check the context of the bindTo and set it to the object
    // that is having the eventBinder attached to it, if no context
    // has been specified in the .bindTo call
    context = context || target;
    eventBinder.bindTo(source, event, callback, context);
  };

  target.unbindFrom = _.bind(eventBinder.unbindFrom, eventBinder);
  target.unbindAll = _.bind(eventBinder.unbindAll, eventBinder);
};

// Event Aggregator
// ----------------
// A pub-sub object that can be used to decouple various parts
// of an application through event-driven architecture.
//
// Extends [Backbone.Wreqr.EventAggregator](https://github.com/marionettejs/backbone.wreqr)
// and mixes in an EventBinder from [Backbone.EventBinder](https://github.com/marionettejs/backbone.eventbinder).
Marionette.EventAggregator = Backbone.Wreqr.EventAggregator.extend({

  constructor: function(){
    Marionette.addEventBinder(this);

    var args = Array.prototype.slice.apply(arguments);
    Backbone.Wreqr.EventAggregator.prototype.constructor.apply(this, args);
  }

});

// Marionette.bindEntityEvents
// ---------------------------
//
// This method is used to bind a backbone "entity" (collection/model)
// to methods on a target object.
//
// The first paremter, `target`, must have a `bindTo` method from the
// EventBinder object.
//
// The second parameter is the entity (Backbone.Model or Backbone.Collection)
// to bind the events from.
//
// The third parameter is a hash of { "event:name": "eventHandler" }
// configuration. Multiple handlers can be separated by a space. A
// function can be supplied instead of a string handler name.
Marionette.bindEntityEvents = (function(){

  // Bind the event to handlers specified as a string of
  // handler names on the target object
  function bindFromStrings(target, entity, evt, methods){
    var methodNames = methods.split(/\s+/);

    _.each(methodNames,function(methodName) {

      var method = target[methodName];
      if(!method) {
        throw new Error("Method '"+ methodName +"' was configured as an event handler, but does not exist.");
      }

      target.bindTo(entity, evt, method, target);
    });
  }

  // Bind the event to a supplied callback function
  function bindToFunction(target, entity, evt, method){
      target.bindTo(entity, evt, method, target);
  }

  // Export the bindEntityEvents method
  return function(target, entity, bindings){
    if (!entity || !bindings) { return; }

    _.each(bindings, function(methods, evt){

      // allow for a function as the handler,
      // or a list of event names as a string
      if (_.isFunction(methods)){
        bindToFunction(target, entity, evt, methods);
      } else {
        bindFromStrings(target, entity, evt, methods);
      }

    });
  };
})();


// Callbacks
// ---------

// A simple way of managing a collection of callbacks
// and executing them at a later point in time, using jQuery's
// `Deferred` object.
Marionette.Callbacks = function(){
  this._deferred = $.Deferred();
  this._callbacks = [];
};

_.extend(Marionette.Callbacks.prototype, {

  // Add a callback to be executed. Callbacks added here are
  // guaranteed to execute, even if they are added after the
  // `run` method is called.
  add: function(callback, contextOverride){
    this._callbacks.push({cb: callback, ctx: contextOverride});

    this._deferred.done(function(context, options){
      if (contextOverride){ context = contextOverride; }
      callback.call(context, options);
    });
  },

  // Run all registered callbacks with the context specified.
  // Additional callbacks can be added after this has been run
  // and they will still be executed.
  run: function(options, context){
    this._deferred.resolve(context, options);
  },

  // Resets the list of callbacks to be run, allowing the same list
  // to be run multiple times - whenever the `run` method is called.
  reset: function(){
    var that = this;
    var callbacks = this._callbacks;
    this._deferred = $.Deferred();
    this._callbacks = [];
    _.each(callbacks, function(cb){
      that.add(cb.cb, cb.ctx);
    });
  }
});


// Marionette Controller
// ---------------------
//
// A multi-purpose object to use as a controller for
// modules and routers, and as a mediator for workflow
// and coordination of other objects, views, and more.
Marionette.Controller = function(options){
  this.triggerMethod = Marionette.triggerMethod;
  this.options = options || {};

  Marionette.addEventBinder(this);

  if (_.isFunction(this.initialize)){
    this.initialize(this.options);
  }
};

Marionette.Controller.extend = Marionette.extend;

// Controller Methods
// --------------

// Ensure it can trigger events with Backbone.Events
_.extend(Marionette.Controller.prototype, Backbone.Events, {
  close: function(){
    this.unbindAll();
    this.triggerMethod("close");
    this.unbind();
  }
});

// Region
// ------
//
// Manage the visual regions of your composite application. See
// http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/

Marionette.Region = function(options){
  this.options = options || {};

  Marionette.addEventBinder(this);

  this.el = Marionette.getOption(this, "el");

  if (!this.el){
    var err = new Error("An 'el' must be specified for a region.");
    err.name = "NoElError";
    throw err;
  }

  if (this.initialize){
    var args = Array.prototype.slice.apply(arguments);
    this.initialize.apply(this, args);
  }
};


// Region Type methods
// -------------------

_.extend(Marionette.Region, {

  // Build an instance of a region by passing in a configuration object
  // and a default region type to use if none is specified in the config.
  //
  // The config object should either be a string as a jQuery DOM selector,
  // a Region type directly, or an object literal that specifies both
  // a selector and regionType:
  //
  // ```js
  // {
  //   selector: "#foo",
  //   regionType: MyCustomRegion
  // }
  // ```
  //
  buildRegion: function(regionConfig, defaultRegionType){
    var regionIsString = (typeof regionConfig === "string");
    var regionSelectorIsString = (typeof regionConfig.selector === "string");
    var regionTypeIsUndefined = (typeof regionConfig.regionType === "undefined");
    var regionIsType = (typeof regionConfig === "function");

    if (!regionIsType && !regionIsString && !regionSelectorIsString) {
      throw new Error("Region must be specified as a Region type, a selector string or an object with selector property");
    }

    var selector, RegionType;

    // get the selector for the region

    if (regionIsString) {
      selector = regionConfig;
    }

    if (regionConfig.selector) {
      selector = regionConfig.selector;
    }

    // get the type for the region

    if (regionIsType){
      RegionType = regionConfig;
    }

    if (!regionIsType && regionTypeIsUndefined) {
      RegionType = defaultRegionType;
    }

    if (regionConfig.regionType) {
      RegionType = regionConfig.regionType;
    }

    // build the region instance

    var regionManager = new RegionType({
      el: selector
    });

    return regionManager;
  }

});

// Region Instance Methods
// -----------------------

_.extend(Marionette.Region.prototype, Backbone.Events, {

  // Displays a backbone view instance inside of the region.
  // Handles calling the `render` method for you. Reads content
  // directly from the `el` attribute. Also calls an optional
  // `onShow` and `close` method on your view, just after showing
  // or just before closing the view, respectively.
  show: function(view){

    this.ensureEl();
    this.close();

    view.render();
    this.open(view);

    Marionette.triggerMethod.call(view, "show");
    Marionette.triggerMethod.call(this, "show", view);

    this.currentView = view;
  },

  ensureEl: function(){
    if (!this.$el || this.$el.length === 0){
      this.$el = this.getEl(this.el);
    }
  },

  // Override this method to change how the region finds the
  // DOM element that it manages. Return a jQuery selector object.
  getEl: function(selector){
    return $(selector);
  },

  // Override this method to change how the new view is
  // appended to the `$el` that the region is managing
  open: function(view){
    this.$el.empty().append(view.el);
  },

  // Close the current view, if there is one. If there is no
  // current view, it does nothing and returns immediately.
  close: function(){
    var view = this.currentView;
    if (!view || view.isClosed){ return; }

    if (view.close) { view.close(); }
    Marionette.triggerMethod.call(this, "close");

    delete this.currentView;
  },

  // Attach an existing view to the region. This
  // will not call `render` or `onShow` for the new view,
  // and will not replace the current HTML for the `el`
  // of the region.
  attachView: function(view){
    this.currentView = view;
  },

  // Reset the region by closing any existing view and
  // clearing out the cached `$el`. The next time a view
  // is shown via this region, the region will re-query the
  // DOM for the region's `el`.
  reset: function(){
    this.close();
    delete this.$el;
  }
});

// Copy the `extend` function used by Backbone's classes
Marionette.Region.extend = Marionette.extend;


// Template Cache
// --------------

// Manage templates stored in `<script>` blocks,
// caching them for faster access.
Marionette.TemplateCache = function(templateId){
  this.templateId = templateId;
};

// TemplateCache object-level methods. Manage the template
// caches from these method calls instead of creating
// your own TemplateCache instances
_.extend(Marionette.TemplateCache, {
  templateCaches: {},

  // Get the specified template by id. Either
  // retrieves the cached version, or loads it
  // from the DOM.
  get: function(templateId){
    var that = this;
    var cachedTemplate = this.templateCaches[templateId];

    if (!cachedTemplate){
      cachedTemplate = new Marionette.TemplateCache(templateId);
      this.templateCaches[templateId] = cachedTemplate;
    }

    return cachedTemplate.load();
  },

  // Clear templates from the cache. If no arguments
  // are specified, clears all templates:
  // `clear()`
  //
  // If arguments are specified, clears each of the
  // specified templates from the cache:
  // `clear("#t1", "#t2", "...")`
  clear: function(){
    var i;
    var args = Array.prototype.slice.apply(arguments);
    var length = args.length;

    if (length > 0){
      for(i=0; i<length; i++){
        delete this.templateCaches[args[i]];
      }
    } else {
      this.templateCaches = {};
    }
  }
});

// TemplateCache instance methods, allowing each
// template cache object to manage it's own state
// and know whether or not it has been loaded
_.extend(Marionette.TemplateCache.prototype, {

  // Internal method to load the template asynchronously.
  load: function(){
    var that = this;

    // Guard clause to prevent loading this template more than once
    if (this.compiledTemplate){
      return this.compiledTemplate;
    }

    // Load the template and compile it
    var template = this.loadTemplate(this.templateId);
    this.compiledTemplate = this.compileTemplate(template);

    return this.compiledTemplate;
  },

  // Load a template from the DOM, by default. Override
  // this method to provide your own template retrieval,
  // such as asynchronous loading from a server.
  loadTemplate: function(templateId){
    var template = $(templateId).html();

    if (!template || template.length === 0){
      var msg = "Could not find template: '" + templateId + "'";
      var err = new Error(msg);
      err.name = "NoTemplateError";
      throw err;
    }

    return template;
  },

  // Pre-compile the template before caching it. Override
  // this method if you do not need to pre-compile a template
  // (JST / RequireJS for example) or if you want to change
  // the template engine used (Handebars, etc).
  compileTemplate: function(rawTemplate){
    return _.template(rawTemplate);
  }
});


// Renderer
// --------

// Render a template with data by passing in the template
// selector and the data to render.
Marionette.Renderer = {

  // Render a template with data. The `template` parameter is
  // passed to the `TemplateCache` object to retrieve the
  // template function. Override this method to provide your own
  // custom rendering and template handling for all of Marionette.
  render: function(template, data){
    var templateFunc = typeof template === 'function' ? template : Marionette.TemplateCache.get(template);
    var html = templateFunc(data);
    return html;
  }
};



// Marionette.View
// ---------------

// The core view type that other Marionette views extend from.
Marionette.View = Backbone.View.extend({

  constructor: function(){
    _.bindAll(this, "render");
    Marionette.addEventBinder(this);

    var args = Array.prototype.slice.apply(arguments);
    Backbone.View.prototype.constructor.apply(this, args);

    Marionette.bindEntityEvents(this, this.model, Marionette.getOption(this, "modelEvents"));
    Marionette.bindEntityEvents(this, this.collection, Marionette.getOption(this, "collectionEvents"));

    Marionette.MonitorDOMRefresh(this);
    this.bindTo(this, "show", this.onShowCalled, this);
  },

  // import the "triggerMethod" to trigger events with corresponding
  // methods if the method exists
  triggerMethod: Marionette.triggerMethod,

  // Get the template for this view
  // instance. You can set a `template` attribute in the view
  // definition or pass a `template: "whatever"` parameter in
  // to the constructor options.
  getTemplate: function(){
    return Marionette.getOption(this, "template");
  },

  // Mix in template helper methods. Looks for a
  // `templateHelpers` attribute, which can either be an
  // object literal, or a function that returns an object
  // literal. All methods and attributes from this object
  // are copies to the object passed in.
  mixinTemplateHelpers: function(target){
    target = target || {};
    var templateHelpers = this.templateHelpers;
    if (_.isFunction(templateHelpers)){
      templateHelpers = templateHelpers.call(this);
    }
    return _.extend(target, templateHelpers);
  },

  // Configure `triggers` to forward DOM events to view
  // events. `triggers: {"click .foo": "do:foo"}`
  configureTriggers: function(){
    if (!this.triggers) { return; }

    var that = this;
    var triggerEvents = {};

    // Allow `triggers` to be configured as a function
    var triggers = _.result(this, "triggers");

    // Configure the triggers, prevent default
    // action and stop propagation of DOM events
    _.each(triggers, function(value, key){

      triggerEvents[key] = function(e){
        if (e && e.preventDefault){ e.preventDefault(); }
        if (e && e.stopPropagation){ e.stopPropagation(); }
        that.trigger(value);
      };

    });

    return triggerEvents;
  },

  // Overriding Backbone.View's delegateEvents specifically
  // to handle the `triggers` configuration
  delegateEvents: function(events){
    events = events || this.events;
    if (_.isFunction(events)){ events = events.call(this); }

    var combinedEvents = {};
    var triggers = this.configureTriggers();
    _.extend(combinedEvents, events, triggers);

    Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
  },

  // Internal method, handles the `show` event.
  onShowCalled: function(){},

  // Default `close` implementation, for removing a view from the
  // DOM and unbinding it. Regions will call this method
  // for you. You can specify an `onClose` method in your view to
  // add custom code that is called after the view is closed.
  close: function(){
    if (this.isClosed) { return; }

    // allow the close to be stopped by returning `false`
    // from the `onBeforeClose` method
    var shouldClose = this.triggerMethod("before:close");
    if (shouldClose === false){
      return;
    }

    // mark as closed before doing the actual close, to
    // prevent infinite loops within "close" event handlers
    // that are trying to close other views
    this.isClosed = true;

    this.remove();
    this.triggerMethod("close");
    this.unbindAll();
  },

  // This method binds the elements specified in the "ui" hash inside the view's code with
  // the associated jQuery selectors.
  bindUIElements: function(){
    if (!this.ui) { return; }

    var that = this;

    if (!this.uiBindings) {
      // We want to store the ui hash in uiBindings, since afterwards the values in the ui hash
      // will be overridden with jQuery selectors.
      this.uiBindings = this.ui;
    }

    // refreshing the associated selectors since they should point to the newly rendered elements.
    this.ui = {};
    _.each(_.keys(this.uiBindings), function(key) {
      var selector = that.uiBindings[key];
      that.ui[key] = that.$(selector);
    });
  }
});

// Item View
// ---------

// A single item view implementation that contains code for rendering
// with underscore.js templates, serializing the view's model or collection,
// and calling several methods on extended views, such as `onRender`.
Marionette.ItemView =  Marionette.View.extend({
  constructor: function(){
    var args = Array.prototype.slice.apply(arguments);
    Marionette.View.prototype.constructor.apply(this, args);

    if (this.initialEvents){
      this.initialEvents();
    }
  },

  // Serialize the model or collection for the view. If a model is
  // found, `.toJSON()` is called. If a collection is found, `.toJSON()`
  // is also called, but is used to populate an `items` array in the
  // resulting data. If both are found, defaults to the model.
  // You can override the `serializeData` method in your own view
  // definition, to provide custom serialization for your view's data.
  serializeData: function(){
    var data = {};

    if (this.model) {
      data = this.model.toJSON();
    }
    else if (this.collection) {
      data = { items: this.collection.toJSON() };
    }

    return data;
  },

  // Render the view, defaulting to underscore.js templates.
  // You can override this in your view definition to provide
  // a very specific rendering for your view. In general, though,
  // you should override the `Marionette.Renderer` object to
  // change how Marionette renders views.
  render: function(){
    this.isClosed = false;

    this.triggerMethod("before:render", this);
    this.triggerMethod("item:before:render", this);

    var data = this.serializeData();
    data = this.mixinTemplateHelpers(data);

    var template = this.getTemplate();
    var html = Marionette.Renderer.render(template, data);
    this.$el.html(html);
    this.bindUIElements();

    this.triggerMethod("render", this);
    this.triggerMethod("item:rendered", this);

    return this;
  },

  // Override the default close event to add a few
  // more events that are triggered.
  close: function(){
    if (this.isClosed){ return; }

    this.triggerMethod('item:before:close');

    var args = Array.prototype.slice.apply(arguments);
    Marionette.View.prototype.close.apply(this, args);

    this.triggerMethod('item:closed');
  }
});

// Collection View
// ---------------

// A view that iterates over a Backbone.Collection
// and renders an individual ItemView for each model.
Marionette.CollectionView = Marionette.View.extend({
  // used as the prefix for item view events
  // that are forwarded through the collectionview
  itemViewEventPrefix: "itemview",

  // constructor
  constructor: function(options){
    this.initChildViewStorage();
    this.onShowCallbacks = new Marionette.Callbacks();

    var args = Array.prototype.slice.apply(arguments);
    Marionette.View.prototype.constructor.apply(this, args);

    this.initialEvents();
  },

  // Configured the initial events that the collection view
  // binds to. Override this method to prevent the initial
  // events, or to add your own initial events.
  initialEvents: function(){
    if (this.collection){
      this.bindTo(this.collection, "add", this.addChildView, this);
      this.bindTo(this.collection, "remove", this.removeItemView, this);
      this.bindTo(this.collection, "reset", this.render, this);
    }
  },

  // Handle a child item added to the collection
  addChildView: function(item, collection, options){
    this.closeEmptyView();
    var ItemView = this.getItemView(item);

    var index;
    if(options && options.index){
      index = options.index;
    } else {
      index = 0;
    }

    return this.addItemView(item, ItemView, index);
  },

  // Override from `Marionette.View` to guarantee the `onShow` method
  // of child views is called.
  onShowCalled: function(){
    this.onShowCallbacks.run();
  },

  // Internal method to trigger the before render callbacks
  // and events
  triggerBeforeRender: function(){
    this.triggerMethod("before:render", this);
    this.triggerMethod("collection:before:render", this);
  },

  // Internal method to trigger the rendered callbacks and
  // events
  triggerRendered: function(){
    this.triggerMethod("render", this);
    this.triggerMethod("collection:rendered", this);
  },

  // Render the collection of items. Override this method to
  // provide your own implementation of a render function for
  // the collection view.
  render: function(){
    this.isClosed = false;

    this.triggerBeforeRender();
    this.closeEmptyView();
    this.closeChildren();

    if (this.collection && this.collection.length > 0) {
      this.showCollection();
    } else {
      this.showEmptyView();
    }

    this.triggerRendered();
    return this;
  },

  // Internal method to loop through each item in the
  // collection view and show it
  showCollection: function(){
    var that = this;
    var ItemView;
    this.collection.each(function(item, index){
      ItemView = that.getItemView(item);
      that.addItemView(item, ItemView, index);
    });
  },

  // Internal method to show an empty view in place of
  // a collection of item views, when the collection is
  // empty
  showEmptyView: function(){
    var EmptyView = Marionette.getOption(this, "emptyView");

    if (EmptyView && !this._showingEmptyView){
      this._showingEmptyView = true;
      var model = new Backbone.Model();
      this.addItemView(model, EmptyView, 0);
    }
  },

  // Internal method to close an existing emptyView instance
  // if one exists. Called when a collection view has been
  // rendered empty, and then an item is added to the collection.
  closeEmptyView: function(){
    if (this._showingEmptyView){
      this.closeChildren();
      delete this._showingEmptyView;
    }
  },

  // Retrieve the itemView type, either from `this.options.itemView`
  // or from the `itemView` in the object definition. The "options"
  // takes precedence.
  getItemView: function(item){
    var itemView = Marionette.getOption(this, "itemView");

    if (!itemView){
      var err = new Error("An `itemView` must be specified");
      err.name = "NoItemViewError";
      throw err;
    }

    return itemView;
  },

  // Render the child item's view and add it to the
  // HTML for the collection view.
  addItemView: function(item, ItemView, index){
    var that = this;

    // get the itemViewOptions if any were specified
    var itemViewOptions = Marionette.getOption(this, "itemViewOptions");
    if (_.isFunction(itemViewOptions)){
      itemViewOptions = itemViewOptions.call(this, item);
    }

    // build the view
    var view = this.buildItemView(item, ItemView, itemViewOptions);

    // set up the child view event forwarding
    this.addChildViewEventForwarding(view);

    // this view is about to be added
    this.triggerMethod("before:item:added", view);

    // Store the child view itself so we can properly
    // remove and/or close it later
    this.children.add(view);

    // Render it and show it
    var renderResult = this.renderItemView(view, index);

    // this view was added
    this.triggerMethod("after:item:added", view);

    // call onShow for child item views
    if (view.onShow){
      this.onShowCallbacks.add(view.onShow, view);
    }

    return renderResult;
  },

  // Set up the child view event forwarding. Uses an "itemview:"
  // prefix in front of all forwarded events.
  addChildViewEventForwarding: function(view){
    var prefix = Marionette.getOption(this, "itemViewEventPrefix");

    // Forward all child item view events through the parent,
    // prepending "itemview:" to the event name
    var childBinding = this.bindTo(view, "all", function(){
      var args = slice.call(arguments);
      args[0] = prefix + ":" + args[0];
      args.splice(1, 0, view);

      this.triggerMethod.apply(this, args);
    }, this);

    // Store all child event bindings so we can unbind
    // them when removing / closing the child view
    this._childBindings = this._childBindings || {};
    this._childBindings[view.cid] = childBinding;
  },

  // render the item view
  renderItemView: function(view, index) {
    view.render();
    this.appendHtml(this, view, index);
  },

  // Build an `itemView` for every model in the collection.
  buildItemView: function(item, ItemViewType, itemViewOptions){
    var options = _.extend({model: item}, itemViewOptions);
    var view = new ItemViewType(options);
    return view;
  },

  // Remove the child view and close it
  removeItemView: function(item){
    var view = this.children.findByModel(item);

    if (view){
      var childBinding = this._childBindings[view.cid];
      if (childBinding) {
        this.unbindFrom(childBinding);
        delete this._childBindings[view.cid];
      }

      if (view.close){
        view.close();
      }

      this.children.remove(view);
    }

    if (!this.collection || this.collection.length === 0){
      this.showEmptyView();
    }

    this.triggerMethod("item:removed", view);
  },

  // Append the HTML to the collection's `el`.
  // Override this method to do something other
  // then `.append`.
  appendHtml: function(collectionView, itemView, index){
    collectionView.$el.append(itemView.el);
  },

  // Internal method to set up the `children` object for
  // storing all of the child views
  initChildViewStorage: function(){
    this.children = new Backbone.ChildViewContainer();
  },

  // Handle cleanup and other closing needs for
  // the collection of views.
  close: function(){
    if (this.isClosed){ return; }

    this.triggerMethod("collection:before:close");
    this.closeChildren();
    this.triggerMethod("collection:closed");

    var args = Array.prototype.slice.apply(arguments);
    Marionette.View.prototype.close.apply(this, args);
  },

  // Close the child views that this collection view
  // is holding on to, if any
  closeChildren: function(){
    var that = this;
    this.children.apply("close");
    // re-initialize to clean up after ourselves
    this.initChildViewStorage();
  }
});


// Composite View
// --------------

// Used for rendering a branch-leaf, hierarchical structure.
// Extends directly from CollectionView and also renders an
// an item view as `modelView`, for the top leaf
Marionette.CompositeView = Marionette.CollectionView.extend({
  constructor: function(options){
    var args = Array.prototype.slice.apply(arguments);
    Marionette.CollectionView.apply(this, args);

    this.itemView = this.getItemView();
  },

  // Configured the initial events that the composite view
  // binds to. Override this method to prevent the initial
  // events, or to add your own initial events.
  initialEvents: function(){
    if (this.collection){
      this.bindTo(this.collection, "add", this.addChildView, this);
      this.bindTo(this.collection, "remove", this.removeItemView, this);
      this.bindTo(this.collection, "reset", this.renderCollection, this);
    }
  },

  // Retrieve the `itemView` to be used when rendering each of
  // the items in the collection. The default is to return
  // `this.itemView` or Marionette.CompositeView if no `itemView`
  // has been defined
  getItemView: function(item){
    var itemView = Marionette.getOption(this, "itemView") || this.constructor;

    if (!itemView){
      var err = new Error("An `itemView` must be specified");
      err.name = "NoItemViewError";
      throw err;
    }

    return itemView;
  },

  // Serialize the collection for the view.
  // You can override the `serializeData` method in your own view
  // definition, to provide custom serialization for your view's data.
  serializeData: function(){
    var data = {};

    if (this.model){
      data = this.model.toJSON();
    }

    return data;
  },

  // Renders the model once, and the collection once. Calling
  // this again will tell the model's view to re-render itself
  // but the collection will not re-render.
  render: function(){
    this.isClosed = false;

    this.resetItemViewContainer();

    var html = this.renderModel();
    this.$el.html(html);

    // the ui bindings is done here and not at the end of render since they
    // will not be available until after the model is rendered, but should be
    // available before the collection is rendered.
    this.bindUIElements();

    this.triggerMethod("composite:model:rendered");

    this.renderCollection();
    this.triggerMethod("composite:rendered");
    return this;
  },

  // Render the collection for the composite view
  renderCollection: function(){
    var args = Array.prototype.slice.apply(arguments);
    Marionette.CollectionView.prototype.render.apply(this, args);

    this.triggerMethod("composite:collection:rendered");
  },

  // Render an individual model, if we have one, as
  // part of a composite view (branch / leaf). For example:
  // a treeview.
  renderModel: function(){
    var data = {};
    data = this.serializeData();
    data = this.mixinTemplateHelpers(data);

    var template = this.getTemplate();
    return Marionette.Renderer.render(template, data);
  },

  // Appends the `el` of itemView instances to the specified
  // `itemViewContainer` (a jQuery selector). Override this method to
  // provide custom logic of how the child item view instances have their
  // HTML appended to the composite view instance.
  appendHtml: function(cv, iv){
    var $container = this.getItemViewContainer(cv);
    $container.append(iv.el);
  },

  // Internal method to ensure an `$itemViewContainer` exists, for the
  // `appendHtml` method to use.
  getItemViewContainer: function(containerView){
    if ("$itemViewContainer" in containerView){
      return containerView.$itemViewContainer;
    }

    var container;
    if (containerView.itemViewContainer){

      var selector = _.result(containerView, "itemViewContainer");
      container = containerView.$(selector);
      if (container.length <= 0) {
        var err = new Error("The specified `itemViewContainer` was not found: " + containerView.itemViewContainer);
        err.name = "ItemViewContainerMissingError";
        throw err;
      }

    } else {
      container = containerView.$el;
    }

    containerView.$itemViewContainer = container;
    return container;
  },

  // Internal method to reset the `$itemViewContainer` on render
  resetItemViewContainer: function(){
    if (this.$itemViewContainer){
      delete this.$itemViewContainer;
    }
  }
});


// Layout
// ------

// Used for managing application layouts, nested layouts and
// multiple regions within an application or sub-application.
//
// A specialized view type that renders an area of HTML and then
// attaches `Region` instances to the specified `regions`.
// Used for composite view management and sub-application areas.
Marionette.Layout = Marionette.ItemView.extend({
  regionType: Marionette.Region,

  // Ensure the regions are avialable when the `initialize` method
  // is called.
  constructor: function () {
    this._firstRender = true;
    this.initializeRegions();

    var args = Array.prototype.slice.apply(arguments);
    Backbone.Marionette.ItemView.apply(this, args);
  },

  // Layout's render will use the existing region objects the
  // first time it is called. Subsequent calls will close the
  // views that the regions are showing and then reset the `el`
  // for the regions to the newly rendered DOM elements.
  render: function(){

    if (this._firstRender){
      // if this is the first render, don't do anything to
      // reset the regions
      this._firstRender = false;
    } else {
      // If this is not the first render call, then we need to
      // re-initializing the `el` for each region
      this.closeRegions();
      this.reInitializeRegions();
    }

    var args = Array.prototype.slice.apply(arguments);
    var result = Marionette.ItemView.prototype.render.apply(this, args);

    return result;
  },

  // Handle closing regions, and then close the view itself.
  close: function () {
    if (this.isClosed){ return; }

    this.closeRegions();
    this.destroyRegions();

    var args = Array.prototype.slice.apply(arguments);
    Backbone.Marionette.ItemView.prototype.close.apply(this, args);
  },

  // Initialize the regions that have been defined in a
  // `regions` attribute on this layout. The key of the
  // hash becomes an attribute on the layout object directly.
  // For example: `regions: { menu: ".menu-container" }`
  // will product a `layout.menu` object which is a region
  // that controls the `.menu-container` DOM element.
  initializeRegions: function () {
    if (!this.regionManagers){
      this.regionManagers = {};
    }

    var that = this;
    var regions = this.regions || {};
    _.each(regions, function (region, name) {

      var regionManager = Marionette.Region.buildRegion(region, that.regionType);
      regionManager.getEl = function(selector){
        return that.$(selector);
      };

      that.regionManagers[name] = regionManager;
      that[name] = regionManager;
    });

  },

  // Re-initialize all of the regions by updating the `el` that
  // they point to
  reInitializeRegions: function(){
    if (this.regionManagers && _.size(this.regionManagers)===0){
      this.initializeRegions();
    } else {
      _.each(this.regionManagers, function(region){
        region.reset();
      });
    }
  },

  // Close all of the regions that have been opened by
  // this layout. This method is called when the layout
  // itself is closed.
  closeRegions: function () {
    var that = this;
    _.each(this.regionManagers, function (manager, name) {
      manager.close();
    });
  },

  // Destroys all of the regions by removing references
  // from the Layout
  destroyRegions: function(){
    var that = this;
    _.each(this.regionManagers, function (manager, name) {
      delete that[name];
    });
    this.regionManagers = {};
  }
});



// AppRouter
// ---------

// Reduce the boilerplate code of handling route events
// and then calling a single method on another object.
// Have your routers configured to call the method on
// your object, directly.
//
// Configure an AppRouter with `appRoutes`.
//
// App routers can only take one `controller` object.
// It is recommended that you divide your controller
// objects in to smaller peices of related functionality
// and have multiple routers / controllers, instead of
// just one giant router and controller.
//
// You can also add standard routes to an AppRouter.

Marionette.AppRouter = Backbone.Router.extend({

  constructor: function(options){
    var args = Array.prototype.slice.apply(arguments);
    Backbone.Router.prototype.constructor.apply(this, args);

    this.options = options;

    if (this.appRoutes){
      var controller = Marionette.getOption(this, "controller");
      this.processAppRoutes(controller, this.appRoutes);
    }
  },

  // Internal method to process the `appRoutes` for the
  // router, and turn them in to routes that trigger the
  // specified method on the specified `controller`.
  processAppRoutes: function(controller, appRoutes){
    var method, methodName;
    var route, routesLength, i;
    var routes = [];
    var router = this;

    for(route in appRoutes){
      if (appRoutes.hasOwnProperty(route)){
        routes.unshift([route, appRoutes[route]]);
      }
    }

    routesLength = routes.length;
    for (i = 0; i < routesLength; i++){
      route = routes[i][0];
      methodName = routes[i][1];
      method = controller[methodName];

      if (!method){
        var msg = "Method '" + methodName + "' was not found on the controller";
        var err = new Error(msg);
        err.name = "NoMethodError";
        throw err;
      }

      method = _.bind(method, controller);
      router.route(route, methodName, method);
    }
  }
});


// Application
// -----------

// Contain and manage the composite application as a whole.
// Stores and starts up `Region` objects, includes an
// event aggregator as `app.vent`
Marionette.Application = function(options){
  this.initCallbacks = new Marionette.Callbacks();
  this.vent = new Marionette.EventAggregator();
  this.commands = new Backbone.Wreqr.Commands();
  this.reqres = new Backbone.Wreqr.RequestResponse();
  this.submodules = {};

  _.extend(this, options);

  Marionette.addEventBinder(this);
  this.triggerMethod = Marionette.triggerMethod;
};

_.extend(Marionette.Application.prototype, Backbone.Events, {
  // Command execution, facilitated by Backbone.Wreqr.Commands
  execute: function(){
    var args = Array.prototype.slice.apply(arguments);
    this.commands.execute.apply(this.commands, args);
  },

  // Request/response, facilitated by Backbone.Wreqr.RequestResponse
  request: function(){
    var args = Array.prototype.slice.apply(arguments);
    return this.reqres.request.apply(this.reqres, args);
  },

  // Add an initializer that is either run at when the `start`
  // method is called, or run immediately if added after `start`
  // has already been called.
  addInitializer: function(initializer){
    this.initCallbacks.add(initializer);
  },

  // kick off all of the application's processes.
  // initializes all of the regions that have been added
  // to the app, and runs all of the initializer functions
  start: function(options){
    this.triggerMethod("initialize:before", options);
    this.initCallbacks.run(options, this);
    this.triggerMethod("initialize:after", options);

    this.triggerMethod("start", options);
  },

  // Add regions to your app.
  // Accepts a hash of named strings or Region objects
  // addRegions({something: "#someRegion"})
  // addRegions{{something: Region.extend({el: "#someRegion"}) });
  addRegions: function(regions){
    var that = this;
    _.each(regions, function (region, name) {
      var regionManager = Marionette.Region.buildRegion(region, Marionette.Region);
      that[name] = regionManager;
    });
  },

  // Removes a region from your app.
  // Accepts the regions name
  // removeRegion('myRegion')
  removeRegion: function(region) {
    this[region].close();
    delete this[region];
  },

  // Create a module, attached to the application
  module: function(moduleNames, moduleDefinition){
    // slice the args, and add this application object as the
    // first argument of the array
    var args = slice.call(arguments);
    args.unshift(this);

    // see the Marionette.Module object for more information
    return Marionette.Module.create.apply(Marionette.Module, args);
  }
});

// Copy the `extend` function used by Backbone's classes
Marionette.Application.extend = Marionette.extend;

// Module
// ------

// A simple module system, used to create privacy and encapsulation in
// Marionette applications
Marionette.Module = function(moduleName, app){
  this.moduleName = moduleName;

  // store sub-modules
  this.submodules = {};

  this._setupInitializersAndFinalizers();

  // store the configuration for this module
  this.config = {};
  this.config.app = app;

  // extend this module with an event binder
  Marionette.addEventBinder(this);
  this.triggerMethod = Marionette.triggerMethod;
};

// Extend the Module prototype with events / bindTo, so that the module
// can be used as an event aggregator or pub/sub.
_.extend(Marionette.Module.prototype, Backbone.Events, {

  // Initializer for a specific module. Initializers are run when the
  // module's `start` method is called.
  addInitializer: function(callback){
    this._initializerCallbacks.add(callback);
  },

  // Finalizers are run when a module is stopped. They are used to teardown
  // and finalize any variables, references, events and other code that the
  // module had set up.
  addFinalizer: function(callback){
    this._finalizerCallbacks.add(callback);
  },

  // Start the module, and run all of it's initializers
  start: function(options){
    // Prevent re-starting a module that is already started
    if (this._isInitialized){ return; }

    // start the sub-modules (depth-first hierarchy)
    _.each(this.submodules, function(mod){
      // check to see if we should start the sub-module with this parent
      var startWithParent = true;
      if (mod.config && mod.config.options){
        startWithParent = mod.config.options.startWithParent;
      }

      // start the sub-module
      if (startWithParent){
        mod.start(options);
      }
    });

    // run the callbacks to "start" the current module
    this.triggerMethod("before:start", options);

    this._initializerCallbacks.run(options, this);
    this._isInitialized = true;

    this.triggerMethod("start", options);
  },

  // Stop this module by running its finalizers and then stop all of
  // the sub-modules for this module
  stop: function(){
    // if we are not initialized, don't bother finalizing
    if (!this._isInitialized){ return; }
    this._isInitialized = false;

    Marionette.triggerMethod.call(this, "before:stop");

    // stop the sub-modules; depth-first, to make sure the
    // sub-modules are stopped / finalized before parents
    _.each(this.submodules, function(mod){ mod.stop(); });

    // run the finalizers
    this._finalizerCallbacks.run();

    // reset the initializers and finalizers
    this._initializerCallbacks.reset();
    this._finalizerCallbacks.reset();

    Marionette.triggerMethod.call(this, "stop");
  },

  // Configure the module with a definition function and any custom args
  // that are to be passed in to the definition function
  addDefinition: function(moduleDefinition, customArgs){
    this._runModuleDefinition(moduleDefinition, customArgs);
  },

  // Internal method: run the module definition function with the correct
  // arguments
  _runModuleDefinition: function(definition, customArgs){
    if (!definition){ return; }

    // build the correct list of arguments for the module definition
    var args = _.flatten([
      this,
      this.config.app,
      Backbone,
      Marionette,
      $, _,
      customArgs
    ]);

    definition.apply(this, args);
  },

  // Internal method: set up new copies of initializers and finalizers.
  // Calling this method will wipe out all existing initializers and
  // finalizers.
  _setupInitializersAndFinalizers: function(){
    this._initializerCallbacks = new Marionette.Callbacks();
    this._finalizerCallbacks = new Marionette.Callbacks();
  }
});

// Function level methods to create modules
_.extend(Marionette.Module, {

  // Create a module, hanging off the app parameter as the parent object.
  create: function(app, moduleNames, moduleDefinition){
    var that = this;
    var parentModule = app;
    moduleNames = moduleNames.split(".");

    // get the custom args passed in after the module definition and
    // get rid of the module name and definition function
    var customArgs = slice.apply(arguments);
    customArgs.splice(0, 3);

    // Loop through all the parts of the module definition
    var length = moduleNames.length;
    _.each(moduleNames, function(moduleName, i){
      var isLastModuleInChain = (i === length-1);
      var isFirstModuleInChain = (i === 0);
      var module = that._getModuleDefinition(parentModule, moduleName, app);

      // if this is the last module in the chain, then set up
      // all of the module options from the configuration
      if (isLastModuleInChain){
        module.config.options = that._getModuleOptions(module, parentModule, moduleDefinition);

        // Only add a module definition and initializer when this is the last
        // module in a "parent.child.grandchild" hierarchy of module names and
        // when the module call has a definition function supplied
        if (module.config.options.hasDefinition){
          module.addDefinition(module.config.options.definition, customArgs);
        }
      }

      // if it's a top level module, and this is the only
      // module in the chain, then this one gets configured
      // to start with the parent app.
      if (isFirstModuleInChain && isLastModuleInChain ){
        that._configureStartWithApp(app, module);
      }

      // Reset the parent module so that the next child
      // in the list will be added to the correct parent
      parentModule = module;
    });

    // Return the last module in the definition chain
    return parentModule;
  },

  // Only add the initializer if it is set to start with parent (the app),
  // and if it has not yet been added
  _configureStartWithApp: function(app, module){
    // skip this if we have already configured the module to start w/ the app
    if (module.config.startWithAppIsConfigured){
      return;
    }

    // start the module when the app starts
    app.addInitializer(function(options){
      // but only if the module is configured to start w/ parent
      if (module.config.options.startWithParent){
        module.start(options);
      }
    });

    // prevent this module from being configured for
    // auto start again. the first time the module
    // is defined, determines it's auto-start
    module.config.startWithAppIsConfigured = true;
  },

  _getModuleDefinition: function(parentModule, moduleName, app){
    // Get an existing module of this name if we have one
    var module = parentModule[moduleName];

    if (!module){
      // Create a new module if we don't have one
      module = new Marionette.Module(moduleName, app);
      parentModule[moduleName] = module;
      // store the module on the parent
      parentModule.submodules[moduleName] = module;
    }

    return module;
  },

  _getModuleOptions: function(module, parentModule, moduleDefinition){
    // default to starting the module with it's parent to whatever the
    var startWithParent = true;
    if (module.config.options && !module.config.options.startWithParent){
      startWithParent = false;
    }

    // set up initial options for the module
    var options = {
      startWithParent: startWithParent,
      hasDefinition: !!moduleDefinition
    };

    // short circuit if we don't have a module definition
    if (!options.hasDefinition){ return options; }

    if (_.isFunction(moduleDefinition)){
      // if the definition is a function, assign it directly
      // and use the defaults
      options.definition = moduleDefinition;

    } else {

      // the definition is an object.

      // grab the "define" attribute
      options.hasDefinition = !!moduleDefinition.define;
      options.definition = moduleDefinition.define;

      // grab the "startWithParent" attribute if one exists
      if (moduleDefinition.hasOwnProperty("startWithParent")){
        options.startWithParent = moduleDefinition.startWithParent;
      }
    }

    return options;
  }
});


  return Marionette;
})(Backbone, _, $ || window.jQuery || window.Zepto || window.ender);

return Backbone.Marionette;
  }).apply(root, arguments);
});
}(this));

define('app/five9.properties',[],
function () {
  var Properties = {apiBaseURL: location.protocol + '//' + location.host};

  Properties.getApiBaseURL = function() {
    return this.apiBaseURL;
  };

  Properties.setApiBaseURL = function(apiBaseURL) {
    this.apiBaseURL = apiBaseURL;
  };

  Properties.resetApiBaseURL = function() {
    this.apiBaseURL = location.protocol + '//' + location.host;
  };

  Properties.getHost = function() {
    return this.apiBaseURL + '/appsvcs/rs/svc';
  };

  Properties.getWebSocketURL = function() {
    var wsApiBaseURL = this.apiBaseURL.replace(/^http(s?)/, 'ws$1');
    return wsApiBaseURL + '/appsvcs/ws';
  };

  Properties.getProxyUrl = function() {
    return this.apiBaseURL + '/remote/proxy';
  };

  // Relying Perty Identifier
  Properties.getRPID = function(alias) {
    alias = alias || "defaultAlias";
    return location.protocol + '//' + location.host + '/appsvcs/saml/metadata/alias/' + alias;
  };

  Properties.getUrl = function() {
    return  window.location.protocol + "//" + window.location.host + window.location.pathname;
  };

  return Properties;
});


define('context',[
],
function() {

  var Context = {};

  return Context;
});

define('dataAdapter-api',[
  'jquery',
  'underscore',
  'app/five9.properties',
  'utils'
],
function($, _, Properties, Utils) {
  /**
   * Register ajax transports for blob send/recieve and array buffer send/receive via XMLHttpRequest Level 2
   * within the comfortable framework of the jquery ajax request, with full support for promises.
   *
   * Notice the +* in the dataType string? The + indicates we want this transport to be prepended to the list
   * of potential transports (so it gets first dibs if the request passes the conditions within to provide the
   * ajax transport, preventing the standard transport from hogging the request), and the * indicates that
   * potentially any request with any dataType might want to use the transports provided herein.
   *
   * Remember to specify 'processData:false' in the ajax options when attempting to send a blob or arraybuffer -
   * otherwise jquery will try (and fail) to convert the blob or buffer into a query string.
   */
  $.ajaxTransport("+arraybuffer", function(options, originalOptions, jqXHR){
    // Test for the conditions that mean we can/want to send/receive blobs or arraybuffers - we need XMLHttpRequest
    // level 2 (so feature-detect against window.FormData), feature detect against window.Blob or window.ArrayBuffer,
    // and then check to see if the dataType is blob/arraybuffer or the data itself is a Blob/ArrayBuffer
    if (window.FormData && ((options.dataType && (options.dataType === 'blob' || options.dataType === 'arraybuffer')) ||
      (options.data && ((window.Blob && options.data instanceof Blob) ||
      (window.ArrayBuffer && options.data instanceof ArrayBuffer)))
      ))
    {
      return {
        /**
         * Return a transport capable of sending and/or receiving blobs - in this case, we instantiate
         * a new XMLHttpRequest and use it to actually perform the request, and funnel the result back
         * into the jquery complete callback (such as the success function, done blocks, etc.)
         *
         * @param headers
         * @param completeCallback
         */
        send: function(headers, completeCallback){
          var xhr = new XMLHttpRequest(),
            url = options.url || window.location.href,
            type = options.type || 'GET',
            dataType = options.dataType || 'text',
            data = options.data || null,
            async = options.async || true,
            withCredentials = options.withCredentials || true,
            key;

          xhr.open(type, url, async);

          xhr.withCredentials = withCredentials;
          xhr.responseType = dataType;

          xhr.addEventListener('load', function(){
            var response = {}, status, isSuccess;

            isSuccess = xhr.status >= 200 && xhr.status < 300 || xhr.status === 304;

            if (isSuccess) {
              response[dataType] = xhr.response;
            } else {
              // In case an error occured we assume that the response body contains
              // text data - so let's convert the binary data to a string which we can
              // pass to the complete callback.
              response.text = String.fromCharCode.apply(null, new Uint8Array(xhr.response));
            }

            completeCallback(xhr.status, xhr.statusText, response, xhr.getAllResponseHeaders());
          });

          for (key in headers) {
            if (headers.hasOwnProperty(key)) xhr.setRequestHeader(key, headers[key]);
          }
          xhr.send(data);
        },
        abort: function(){
          jqXHR.abort();
        }
      };
    }
  });

  var API = {
    apiVersion: '1'
  };

  _.extend(API, {
    urlRoot: function() {
      return Properties.getHost();
    },
    addTransactionId: function(options, type, url) {
      options.headers = options.headers || {};

      var transactionId = Utils.generateGuid();
      _.extend(options.headers, {
        'f9-transaction-id': transactionId
      });

      console.info('HTTP ' + type + ' transaction[' + transactionId + '] ' + url);
    },

    xhr: function(url, verb, action, data, params, options) {
      if (action) {
         url +=  '/' + action;
      }
      if (params) {
        url += '?' + $.param(params);
      }

      var defaultOptions = {
        url: url,
        type: verb,
        dataType: 'json',
        cache: false
      };
      options = options || {};
      options = _.defaults(options, defaultOptions);

      if (data !== undefined) {
        if (verb === 'GET'){
          options.data = data;
        }
        else {
          options.data = JSON.stringify(data);
        }
      }

      if (verb !== 'GET' && _.isUndefined(options.contentType)) {
        options.contentType = 'application/json';
      }
      if (_.isFunction(Properties.generateCredentials)) {
        Properties.generateCredentials(options);
      }
      API.addTransactionId(options, verb, url);

      return $.ajax(options).promise();
    },

    xhrFileUpload: function (url, verb, action, formData, params) {
      if (action) {
        url += '/' + action;
      }
      if (params) {
        url += '?' + $.param(params);
      }

      var options = {
        url: url,
        type: verb,
        data: formData,
        //Options to tell jQuery not to process data or worry about content-type.
        cache: false,
        contentType: false,
        processData: false
      };

      return $.ajax(options).promise();
    },

    xhrBinaryDownload: function (url, verb, params, ajaxOptions) {
      if (params) {
        url += '?' + $.param(params);
      }

      var options = {
        url: url,
        type: verb,
        dataType: 'arraybuffer',
        //Options to tell jQuery not to process data or worry about content-type.
        cache: false,
        contentType: false,
        processData: false
      };

      _.extend(options, ajaxOptions);
      API.addTransactionId(options, verb, url);

      return $.ajax(options).promise();
    },

    performAction: function(resource, verb, id, action, data, params, options) {
      if (_.isUndefined(resource) || _.isUndefined(verb)) {
        console.warn('performAction missing required parameter', {resource:resource,verb:verb,action:action});
        return;
      }

      var urlRoot = API.urlRoot();
      var url = urlRoot + '/' + resource;
      if (!_.isUndefined(id) && !_.isNull(id)) {
        url += '/' + id;
      }
      if (!_.isUndefined(action) && !_.isNull(action)) {
        url += '/' + action;
      }
      return API.xhr(url, verb, null, data, params, options);
    }
  });

  return API;
});

/**
  Five9 core API for web-based applications.

  @module opts
  @submodule DataAdapter
*/
/**
  The data adapter class allows models/collections to match the interface of various REST-based api's (parse.com, etc).  For more complex interactions, Backbone.Sync should be overridden.

  To customize the interface to a particular API, global changes should be made to the adapter.

  To customize a model or collection to an api, changes can be made by overriding the Backbone.Model.parse() method (see
  the annotated source for Backbone.js for more details).

  @class DataAdapter
  @static
*/
/*
  Design Goals

  Minimal changes in app models
  Complete interopability with the rest of backbone
  Avoid overriding of Backbone.Sync
  Use open-source software (where feasible) without modification
*/
define('dataAdapter',[
  "backbone",
  "underscore",
  "jquery",
  "dataAdapter-api"
],

function(Backbone, _, $, API) {

  var DataAdapter = {};
  DataAdapter.Model = {};
  DataAdapter.Collection = {};

  // local API
  API = API || {};
  DataAdapter.API = API;

  var Helpers = {
    filterAttributesBlacklist: function(attrs, filterList) {
      // do not accept attrs in blacklist
      var attr, deletes = [];
      for (attr in attrs) {
        if ($.inArray(attr, filterList) !== -1) {
          deletes.push(attr);
        }
      }
      for (var i = 0; i <= deletes.length; i++) {
        delete attrs[ deletes[i] ];
      }
      return attrs;
    },
    mergeAttributes: function(originalModel, response, xhr) {
      var attrs = _.clone(originalModel.attributes);
      var serverAttrs = originalModel.parse(response, xhr);
      serverAttrs = _.extend(attrs || {}, serverAttrs);
      originalModel.set(serverAttrs, {});
    },
    generateUrl: function(modelOrCollection) {
      return API.urlRoot() + '/' + modelOrCollection.getApiClassType();
    }
  };

  /**
  Specify the API type (Apollo, DummyApi, Parse, Rest) for the application to use.  Rest is the standard for Backbone and is a simple pass-through.

  @method initialize
  @param config Specific configuration parameters for the chosen API are passed into the config parameter.  Configuration parameters which are not used by the chosen API will safely be ignored.
  @param {String=Apollo} config.apiType The api type to use for all REST calls.
  @param {String} config.appId The application id for parse.com.  Only valid for api type Parse.
  @param {String} config.apiKey The api key for parse.com.  Only valid for api type Parse.
  @example
    DataAdapter.initialize({apiType: DataAdapter.ApiTypes.Parse, appId: "PARSE\_APP\_ID", apiKey: "PARSE\_API\_KEY"});
  */
  DataAdapter.initialize = function(config) {
    config = config || {};
    DataAdapter.config = config;
  };

  /**
  Extend this class to automatically map this object to the specified DataAdapter api

  @class DataAdapter.Model
  @extends Backbone.Model
  */
  DataAdapter.Model = Backbone.Model.extend({
    /**
    Get the resource type for this model

    @method getApiClassType
    @return {String} apiClassType
    */
    getApiClassType: function() {
      if ("apiClassType" in this) {
        return this.apiClassType;
      }
      return 'undefined-api-class-type';
    },
    /**
    Get the api version for this model

    @method getApiVersion
    @return {String} apiVersion
    */
    getApiVersion: function() {
      if ("apiVersion" in this) {
        return this.apiVersion;
      }
      return API.apiVersion;
    },
    getApiUseTenant: function() {
      if ("apiUseTenant" in this) {
        return this.apiUseTenant;
      }
      return true;
    },
    /**
    Generate the proper url for the specified API type.

    Do not override/modify so that the DataAdapter can generate the url properly.

    @method urlRoot
    */
    urlRoot: function() {
      return Helpers.generateUrl(this);
    },

    parse: function(response, xhr) {
      if (response === null) return null;

      return Helpers.filterAttributesBlacklist(response, ['_actions']);
    },
    getConfig: function() {
      if (this._config) return this._config;

      if ("dataAdapter" in this) {
        this._config = this.dataAdapter;
      }
      return this._config;
    },
    copy: function(options) {
      // uncomment to use the header method to handle copies
      // return Backbone.Model.prototype.save.call(this, {}, {headers:{'X-Five9-Copy-Resource':'true'}});
      return Backbone.sync('copy', this, options);
    }
  });

  /**
  Extend this class to automatically map this collection to the specified DataAdapter api

  @class DataAdapter.Collection
  @extends Backbone.Collection
  */
  DataAdapter.Collection = Backbone.Collection.extend({
    getApiClassType: function() {
      if ("apiClassType" in this) {
        if ("apiItemClassType" in this) {
          return this.apiItemClassType+'/'+this.apiClassType;
        }
        else {
          return this.apiClassType;
        }
      }
      return 'undefined-api-class-type';
    },
    /**
    Get the api version for this model

    @method getApiVersion
    @return {String} apiVersion
    */
    getApiVersion: function() {
      if ("apiVersion" in this) {
        return this.apiVersion;
      }
      return API.apiVersion;
    },
    getApiUseTenant: function() {
      if ("apiUseTenant" in this) {
        return this.apiUseTenant;
      }
      return true;
    },
    /**
    Generate the proper url for the specified API type.

    Do not override/modify so that the DataAdapter can generate the url properly.

    @method urlRoot
    */
    url: function() {
      return Helpers.generateUrl(this);
    },
    parse: function(response, xhr) {
      if (response === null) return null;

      if (response.hasOwnProperty("items")) {
        if (response.items.length === 0) return null;
      }

      return response;
    }
  });

  return DataAdapter;
});

(function(root) {
define("loggerBase", [], function() {
  return (function() {
/**
 * Copyright 2009 Tim Down.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * log4javascript
 *
 * log4javascript is a logging framework for JavaScript based on log4j
 * for Java. This file contains all core log4javascript code and is the only
 * file required to use log4javascript, unless you require support for
 * document.domain, in which case you will also need console.html, which must be
 * stored in the same directory as the main log4javascript.js file.
 *
 * Author: Tim Down <tim@log4javascript.org>
 * Version: 1.4.2
 * Edition: log4javascript
 * Build date: 14 October 2011
 * Website: http://log4javascript.org
 */

/* -------------------------------------------------------------------------- */
// Array-related stuff

// Next three methods are solely for IE5, which is missing them
if (!Array.prototype.push) {
  Array.prototype.push = function() {
    for (var i = 0, len = arguments.length; i < len; i++){
      this[this.length] = arguments[i];
    }
    return this.length;
  };
}

if (!Array.prototype.shift) {
  Array.prototype.shift = function() {
    if (this.length > 0) {
      var firstItem = this[0];
      for (var i = 0, len = this.length - 1; i < len; i++) {
        this[i] = this[i + 1];
      }
      this.length = this.length - 1;
      return firstItem;
    }
  };
}

if (!Array.prototype.splice) {
  Array.prototype.splice = function(startIndex, deleteCount) {
    var itemsAfterDeleted = this.slice(startIndex + deleteCount);
    var itemsDeleted = this.slice(startIndex, startIndex + deleteCount);
    this.length = startIndex;
    // Copy the arguments into a proper Array object
    var argumentsArray = [];
    for (var i = 0, len = arguments.length; i < len; i++) {
      argumentsArray[i] = arguments[i];
    }
    var itemsToAppend = (argumentsArray.length > 2) ?
      itemsAfterDeleted = argumentsArray.slice(2).concat(itemsAfterDeleted) : itemsAfterDeleted;
    for (i = 0, len = itemsToAppend.length; i < len; i++) {
      this.push(itemsToAppend[i]);
    }
    return itemsDeleted;
  };
}

/* -------------------------------------------------------------------------- */

var log4javascript = (function() {

  function isUndefined(obj) {
    return typeof obj == "undefined";
  }

  /* ---------------------------------------------------------------------- */
  // Custom event support

  function EventSupport() {}

  EventSupport.prototype = {
    eventTypes: [],
    eventListeners: {},
    setEventTypes: function(eventTypesParam) {
      if (eventTypesParam instanceof Array) {
        this.eventTypes = eventTypesParam;
        this.eventListeners = {};
        for (var i = 0, len = this.eventTypes.length; i < len; i++) {
          this.eventListeners[this.eventTypes[i]] = [];
        }
      } else {
        handleError("log4javascript.EventSupport [" + this + "]: setEventTypes: eventTypes parameter must be an Array");
      }
    },

    addEventListener: function(eventType, listener) {
      if (typeof listener == "function") {
        if (!array_contains(this.eventTypes, eventType)) {
          handleError("log4javascript.EventSupport [" + this + "]: addEventListener: no event called '" + eventType + "'");
        }
        this.eventListeners[eventType].push(listener);
      } else {
        handleError("log4javascript.EventSupport [" + this + "]: addEventListener: listener must be a function");
      }
    },

    removeEventListener: function(eventType, listener) {
      if (typeof listener == "function") {
        if (!array_contains(this.eventTypes, eventType)) {
          handleError("log4javascript.EventSupport [" + this + "]: removeEventListener: no event called '" + eventType + "'");
        }
        array_remove(this.eventListeners[eventType], listener);
      } else {
        handleError("log4javascript.EventSupport [" + this + "]: removeEventListener: listener must be a function");
      }
    },

    dispatchEvent: function(eventType, eventArgs) {
      if (array_contains(this.eventTypes, eventType)) {
        var listeners = this.eventListeners[eventType];
        for (var i = 0, len = listeners.length; i < len; i++) {
          listeners[i](this, eventType, eventArgs);
        }
      } else {
        handleError("log4javascript.EventSupport [" + this + "]: dispatchEvent: no event called '" + eventType + "'");
      }
    }
  };

  /* -------------------------------------------------------------------------- */

  var applicationStartDate = new Date();
  var uniqueId = "log4javascript_" + applicationStartDate.getTime() + "_" +
    Math.floor(Math.random() * 100000000);
  var emptyFunction = function() {};
  var newLine = "\r\n";
  var pageLoaded = false;

  // Create main log4javascript object; this will be assigned public properties
  function Log4JavaScript() {}
  Log4JavaScript.prototype = new EventSupport();

  log4javascript = new Log4JavaScript();
  log4javascript.version = "1.4.2";
  log4javascript.edition = "log4javascript";

  /* -------------------------------------------------------------------------- */
  // Utility functions

  function toStr(obj) {
    if (obj && obj.toString) {
      return obj.toString();
    } else {
      return String(obj);
    }
  }

  function getExceptionMessage(ex) {
    if (ex.message) {
      return ex.message;
    } else if (ex.description) {
      return ex.description;
    } else {
      return toStr(ex);
    }
  }

  // Gets the portion of the URL after the last slash
  function getUrlFileName(url) {
    var lastSlashIndex = Math.max(url.lastIndexOf("/"), url.lastIndexOf("\\"));
    return url.substr(lastSlashIndex + 1);
  }

  // Returns a nicely formatted representation of an error
  function getExceptionStringRep(ex) {
    if (ex) {
      var exStr = "Exception: " + getExceptionMessage(ex);
      try {
        if (ex.lineNumber) {
          exStr += " on line number " + ex.lineNumber;
        }
        if (ex.fileName) {
          exStr += " in file " + getUrlFileName(ex.fileName);
        }
      } catch (localEx) {
        logLog.warn("Unable to obtain file and line information for error");
      }
      if (showStackTraces && ex.stack) {
        exStr += newLine + "Stack trace:" + newLine + ex.stack;
      }
      return exStr;
    }
    return null;
  }

  function bool(obj) {
    return Boolean(obj);
  }

  function trim(str) {
    return str.replace(/^\s+/, "").replace(/\s+$/, "");
  }

  function splitIntoLines(text) {
    // Ensure all line breaks are \n only
    var text2 = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    return text2.split("\n");
  }

  var urlEncode = (typeof window.encodeURIComponent != "undefined") ?
    function(str) {
      return encodeURIComponent(str);
    }:
    function(str) {
      return escape(str).replace(/\+/g, "%2B").replace(/"/g, "%22").replace(/'/g, "%27").replace(/\//g, "%2F").replace(/=/g, "%3D");
    };

  var urlDecode = (typeof window.decodeURIComponent != "undefined") ?
    function(str) {
      return decodeURIComponent(str);
    }:
    function(str) {
      return unescape(str).replace(/%2B/g, "+").replace(/%22/g, "\"").replace(/%27/g, "'").replace(/%2F/g, "/").replace(/%3D/g, "=");
    };

  function array_remove(arr, val) {
    var index = -1;
    for (var i = 0, len = arr.length; i < len; i++) {
      if (arr[i] === val) {
        index = i;
        break;
      }
    }
    if (index >= 0) {
      arr.splice(index, 1);
      return true;
    } else {
      return false;
    }
  }

  function array_contains(arr, val) {
    for(var i = 0, len = arr.length; i < len; i++) {
      if (arr[i] == val) {
        return true;
      }
    }
    return false;
  }

  function extractBooleanFromParam(param, defaultValue) {
    if (isUndefined(param)) {
      return defaultValue;
    } else {
      return bool(param);
    }
  }

  function extractStringFromParam(param, defaultValue) {
    if (isUndefined(param)) {
      return defaultValue;
    } else {
      return String(param);
    }
  }

  function extractIntFromParam(param, defaultValue) {
    if (isUndefined(param)) {
      return defaultValue;
    } else {
      try {
        var value = parseInt(param, 10);
        return isNaN(value) ? defaultValue : value;
      } catch (ex) {
        logLog.warn("Invalid int param " + param, ex);
        return defaultValue;
      }
    }
  }

  function extractFunctionFromParam(param, defaultValue) {
    if (typeof param == "function") {
      return param;
    } else {
      return defaultValue;
    }
  }

  function isError(err) {
    return (err instanceof Error);
  }

  if (!Function.prototype.apply){
    Function.prototype.apply = function(obj, args) {
      var methodName = "__apply__";
      if (typeof obj[methodName] != "undefined") {
        methodName += String(Math.random()).substr(2);
      }
      obj[methodName] = this;

      var argsStrings = [];
      for (var i = 0, len = args.length; i < len; i++) {
        argsStrings[i] = "args[" + i + "]";
      }
      var script = "obj." + methodName + "(" + argsStrings.join(",") + ")";
      var returnValue = eval(script);
      delete obj[methodName];
      return returnValue;
    };
  }

  if (!Function.prototype.call){
    Function.prototype.call = function(obj) {
      var args = [];
      for (var i = 1, len = arguments.length; i < len; i++) {
        args[i - 1] = arguments[i];
      }
      return this.apply(obj, args);
    };
  }

  function getListenersPropertyName(eventName) {
    return "__log4javascript_listeners__" + eventName;
  }

  function addEvent(node, eventName, listener, useCapture, win) {
    win = win ? win : window;
    if (node.addEventListener) {
      node.addEventListener(eventName, listener, useCapture);
    } else if (node.attachEvent) {
      node.attachEvent("on" + eventName, listener);
    } else {
      var propertyName = getListenersPropertyName(eventName);
      if (!node[propertyName]) {
        node[propertyName] = [];
        // Set event handler
        node["on" + eventName] = function(evt) {
          evt = getEvent(evt, win);
          var listenersPropertyName = getListenersPropertyName(eventName);

          // Clone the array of listeners to leave the original untouched
          var listeners = this[listenersPropertyName].concat([]);
          var currentListener;

          // Call each listener in turn
          while ((currentListener = listeners.shift())) {
            currentListener.call(this, evt);
          }
        };
      }
      node[propertyName].push(listener);
    }
  }

  function removeEvent(node, eventName, listener, useCapture) {
    if (node.removeEventListener) {
      node.removeEventListener(eventName, listener, useCapture);
    } else if (node.detachEvent) {
      node.detachEvent("on" + eventName, listener);
    } else {
      var propertyName = getListenersPropertyName(eventName);
      if (node[propertyName]) {
        array_remove(node[propertyName], listener);
      }
    }
  }

  function getEvent(evt, win) {
    win = win ? win : window;
    return evt ? evt : win.event;
  }

  function stopEventPropagation(evt) {
    if (evt.stopPropagation) {
      evt.stopPropagation();
    } else if (typeof evt.cancelBubble != "undefined") {
      evt.cancelBubble = true;
    }
    evt.returnValue = false;
  }

  /* ---------------------------------------------------------------------- */
  // Simple logging for log4javascript itself

  var logLog = {
    quietMode: false,

    debugMessages: [],

    setQuietMode: function(quietMode) {
      this.quietMode = bool(quietMode);
    },

    numberOfErrors: 0,

    alertAllErrors: false,

    setAlertAllErrors: function(alertAllErrors) {
      this.alertAllErrors = alertAllErrors;
    },

    debug: function(message) {
      this.debugMessages.push(message);
    },

    displayDebug: function() {
      alert(this.debugMessages.join(newLine));
    },

    warn: function(message, exception) {
    },

    error: function(message, exception) {
      if (++this.numberOfErrors == 1 || this.alertAllErrors) {
        if (!this.quietMode) {
          var alertMessage = "log4javascript error: " + message;
          if (exception) {
            alertMessage += newLine + newLine + "Original error: " + getExceptionStringRep(exception);
          }
          alert(alertMessage);
        }
      }
    }
  };
  log4javascript.logLog = logLog;

  log4javascript.setEventTypes(["load", "error"]);

  function handleError(message, exception) {
    logLog.error(message, exception);
    log4javascript.dispatchEvent("error", { "message": message, "exception": exception });
  }

  log4javascript.handleError = handleError;

  /* ---------------------------------------------------------------------- */

  var enabled = !((typeof log4javascript_disabled != "undefined") &&
          log4javascript_disabled);

  log4javascript.setEnabled = function(enable) {
    enabled = bool(enable);
  };

  log4javascript.isEnabled = function() {
    return enabled;
  };

  var useTimeStampsInMilliseconds = true;

  log4javascript.setTimeStampsInMilliseconds = function(timeStampsInMilliseconds) {
    useTimeStampsInMilliseconds = bool(timeStampsInMilliseconds);
  };

  log4javascript.isTimeStampsInMilliseconds = function() {
    return useTimeStampsInMilliseconds;
  };


  // This evaluates the given expression in the current scope, thus allowing
  // scripts to access private variables. Particularly useful for testing
  log4javascript.evalInScope = function(expr) {
    return eval(expr);
  };

  var showStackTraces = false;

  log4javascript.setShowStackTraces = function(show) {
    showStackTraces = bool(show);
  };

  /* ---------------------------------------------------------------------- */
  // Levels

  var Level = function(level, name) {
    this.level = level;
    this.name = name;
  };

  Level.prototype = {
    toString: function() {
      return this.name;
    },
    equals: function(level) {
      return this.level == level.level;
    },
    isGreaterOrEqual: function(level) {
      return this.level >= level.level;
    }
  };

  Level.ALL = new Level(Number.MIN_VALUE, "ALL");
  Level.TRACE = new Level(10000, "TRACE");
  Level.DEBUG = new Level(20000, "DEBUG");
  Level.INFO = new Level(30000, "INFO");
  Level.WARN = new Level(40000, "WARN");
  Level.ERROR = new Level(50000, "ERROR");
  Level.FATAL = new Level(60000, "FATAL");
  Level.OFF = new Level(Number.MAX_VALUE, "OFF");

  log4javascript.Level = Level;

  /* ---------------------------------------------------------------------- */
  // Timers

  function Timer(name, level) {
    this.name = name;
    this.level = isUndefined(level) ? Level.INFO : level;
    this.start = new Date();
  }

  Timer.prototype.getElapsedTime = function() {
    return new Date().getTime() - this.start.getTime();
  };

  /* ---------------------------------------------------------------------- */
  // Loggers

  var anonymousLoggerName = "[anonymous]";
  var defaultLoggerName = "[default]";
  var nullLoggerName = "[null]";
  var rootLoggerName = "root";

  function Logger(name) {
    this.name = name;
    this.parent = null;
    this.children = [];

    var appenders = [];
    var loggerLevel = null;
    var isRoot = (this.name === rootLoggerName);
    var isNull = (this.name === nullLoggerName);

    var appenderCache = null;
    var appenderCacheInvalidated = false;

    this.addChild = function(childLogger) {
      this.children.push(childLogger);
      childLogger.parent = this;
      childLogger.invalidateAppenderCache();
    };

    // Additivity
    var additive = true;
    this.getAdditivity = function() {
      return additive;
    };

    this.setAdditivity = function(additivity) {
      var valueChanged = (additive != additivity);
      additive = additivity;
      if (valueChanged) {
        this.invalidateAppenderCache();
      }
    };

    // Create methods that use the appenders variable in this scope
    this.addAppender = function(appender) {
      if (isNull) {
        handleError("Logger.addAppender: you may not add an appender to the null logger");
      } else {
        if (appender instanceof log4javascript.Appender) {
          if (!array_contains(appenders, appender)) {
            appenders.push(appender);
            appender.setAddedToLogger(this);
            this.invalidateAppenderCache();
          }
        } else {
          handleError("Logger.addAppender: appender supplied ('" +
            toStr(appender) + "') is not a subclass of Appender");
        }
      }
    };

    this.removeAppender = function(appender) {
      array_remove(appenders, appender);
      appender.setRemovedFromLogger(this);
      this.invalidateAppenderCache();
    };

    this.removeAllAppenders = function() {
      var appenderCount = appenders.length;
      if (appenderCount > 0) {
        for (var i = 0; i < appenderCount; i++) {
          appenders[i].setRemovedFromLogger(this);
        }
        appenders.length = 0;
        this.invalidateAppenderCache();
      }
    };

    this.getEffectiveAppenders = function() {
      if (appenderCache === null || appenderCacheInvalidated) {
        // Build appender cache
        var parentEffectiveAppenders = (isRoot || !this.getAdditivity()) ?
          [] : this.parent.getEffectiveAppenders();
        appenderCache = parentEffectiveAppenders.concat(appenders);
        appenderCacheInvalidated = false;
      }
      return appenderCache;
    };

    this.invalidateAppenderCache = function() {
      appenderCacheInvalidated = true;
      for (var i = 0, len = this.children.length; i < len; i++) {
        this.children[i].invalidateAppenderCache();
      }
    };

    this.log = function(level, params) {
      if (enabled && level.isGreaterOrEqual(this.getEffectiveLevel())) {
        // Check whether last param is an exception
        var exception;
        var finalParamIndex = params.length - 1;
        var lastParam = params[finalParamIndex];
        if (params.length > 1 && isError(lastParam)) {
          exception = lastParam;
          finalParamIndex--;
        }

        // Construct genuine array for the params
        var messages = [];
        for (var i = 0; i <= finalParamIndex; i++) {
          messages[i] = params[i];
        }

        var loggingEvent = new LoggingEvent(
          this, new Date(), level, messages, exception);

        this.callAppenders(loggingEvent);
      }
    };

    this.callAppenders = function(loggingEvent) {
      var effectiveAppenders = this.getEffectiveAppenders();
      for (var i = 0, len = effectiveAppenders.length; i < len; i++) {
        effectiveAppenders[i].doAppend(loggingEvent);
      }
    };

    this.setLevel = function(level) {
      // Having a level of null on the root logger would be very bad.
      if (isRoot && level === null) {
        handleError("Logger.setLevel: you cannot set the level of the root logger to null");
      } else if (level instanceof Level) {
        loggerLevel = level;
      } else {
        handleError("Logger.setLevel: level supplied to logger " +
          this.name + " is not an instance of log4javascript.Level");
      }
    };

    this.getLevel = function() {
      return loggerLevel;
    };

    this.getEffectiveLevel = function() {
      for (var logger = this; logger !== null; logger = logger.parent) {
        var level = logger.getLevel();
        if (level !== null) {
          return level;
        }
      }
    };

    this.group = function(name, initiallyExpanded) {
      if (enabled) {
        var effectiveAppenders = this.getEffectiveAppenders();
        for (var i = 0, len = effectiveAppenders.length; i < len; i++) {
          effectiveAppenders[i].group(name, initiallyExpanded);
        }
      }
    };

    this.groupEnd = function(name) {
      if (enabled) {
        var effectiveAppenders = this.getEffectiveAppenders();
        for (var i = 0, len = effectiveAppenders.length; i < len; i++) {
          effectiveAppenders[i].groupEnd();
        }
      }
    };

    var timers = {};

    this.time = function(name, level) {
      if (enabled) {
        if (isUndefined(name)) {
          handleError("Logger.time: a name for the timer must be supplied");
        } else if (level && !(level instanceof Level)) {
          handleError("Logger.time: level supplied to timer " +
            name + " is not an instance of log4javascript.Level");
        } else {
          timers[name] = new Timer(name, level);
        }
      }
    };

    this.timeEnd = function(name) {
      if (enabled) {
        if (isUndefined(name)) {
          handleError("Logger.timeEnd: a name for the timer must be supplied");
        } else if (timers[name]) {
          var timer = timers[name];
          var milliseconds = timer.getElapsedTime();
          this.log(timer.level, ["Timer " + toStr(name) + " completed in " + milliseconds + "ms"]);
          delete timers[name];
        } else {
          logLog.warn("Logger.timeEnd: no timer found with name " + name);
        }
      }
    };

    this.assert = function(expr) {
      if (enabled && !expr) {
        var args = [];
        for (var i = 1, len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        args = (args.length > 0) ? args : ["Assertion Failure"];
        args.push(newLine);
        args.push(expr);
        this.log(Level.ERROR, args);
      }
    };

    this.toString = function() {
      return "Logger[" + this.name + "]";
    };
  }

  Logger.prototype = {
    trace: function() {
      this.log(Level.TRACE, arguments);
    },

    debug: function() {
      this.log(Level.DEBUG, arguments);
    },

    info: function() {
      this.log(Level.INFO, arguments);
    },

    warn: function() {
      this.log(Level.WARN, arguments);
    },

    error: function() {
      this.log(Level.ERROR, arguments);
    },

    fatal: function() {
      this.log(Level.FATAL, arguments);
    },

    isEnabledFor: function(level) {
      return level.isGreaterOrEqual(this.getEffectiveLevel());
    },

    isTraceEnabled: function() {
      return this.isEnabledFor(Level.TRACE);
    },

    isDebugEnabled: function() {
      return this.isEnabledFor(Level.DEBUG);
    },

    isInfoEnabled: function() {
      return this.isEnabledFor(Level.INFO);
    },

    isWarnEnabled: function() {
      return this.isEnabledFor(Level.WARN);
    },

    isErrorEnabled: function() {
      return this.isEnabledFor(Level.ERROR);
    },

    isFatalEnabled: function() {
      return this.isEnabledFor(Level.FATAL);
    }
  };

  Logger.prototype.trace.isEntryPoint = true;
  Logger.prototype.debug.isEntryPoint = true;
  Logger.prototype.info.isEntryPoint = true;
  Logger.prototype.warn.isEntryPoint = true;
  Logger.prototype.error.isEntryPoint = true;
  Logger.prototype.fatal.isEntryPoint = true;

  /* ---------------------------------------------------------------------- */
  // Logger access methods

  // Hashtable of loggers keyed by logger name
  var loggers = {};
  var loggerNames = [];

  var ROOT_LOGGER_DEFAULT_LEVEL = Level.DEBUG;
  var rootLogger = new Logger(rootLoggerName);
  rootLogger.setLevel(ROOT_LOGGER_DEFAULT_LEVEL);

  log4javascript.getRootLogger = function() {
    return rootLogger;
  };

  log4javascript.getLogger = function(loggerName) {
    // Use default logger if loggerName is not specified or invalid
    if (!(typeof loggerName == "string")) {
      loggerName = anonymousLoggerName;
      logLog.warn("log4javascript.getLogger: non-string logger name " +
        toStr(loggerName) + " supplied, returning anonymous logger");
    }

    // Do not allow retrieval of the root logger by name
    if (loggerName == rootLoggerName) {
      handleError("log4javascript.getLogger: root logger may not be obtained by name");
    }

    // Create the logger for this name if it doesn't already exist
    if (!loggers[loggerName]) {
      var logger = new Logger(loggerName);
      loggers[loggerName] = logger;
      loggerNames.push(loggerName);

      // Set up parent logger, if it doesn't exist
      var lastDotIndex = loggerName.lastIndexOf(".");
      var parentLogger;
      if (lastDotIndex > -1) {
        var parentLoggerName = loggerName.substring(0, lastDotIndex);
        parentLogger = log4javascript.getLogger(parentLoggerName); // Recursively sets up grandparents etc.
      } else {
        parentLogger = rootLogger;
      }
      parentLogger.addChild(logger);
    }
    return loggers[loggerName];
  };

  var defaultLogger = null;
  log4javascript.getDefaultLogger = function() {
    if (!defaultLogger) {
      defaultLogger = log4javascript.getLogger(defaultLoggerName);
      var a = new log4javascript.PopUpAppender();
      defaultLogger.addAppender(a);
    }
    return defaultLogger;
  };

  var nullLogger = null;
  log4javascript.getNullLogger = function() {
    if (!nullLogger) {
      nullLogger = new Logger(nullLoggerName);
      nullLogger.setLevel(Level.OFF);
    }
    return nullLogger;
  };

  // Destroys all loggers
  log4javascript.resetConfiguration = function() {
    rootLogger.setLevel(ROOT_LOGGER_DEFAULT_LEVEL);
    loggers = {};
  };

  /* ---------------------------------------------------------------------- */
  // Logging events

  var LoggingEvent = function(logger, timeStamp, level, messages,
      exception) {
    this.logger = logger;
    this.timeStamp = timeStamp;
    this.timeStampInMilliseconds = timeStamp.getTime();
    this.timeStampInSeconds = Math.floor(this.timeStampInMilliseconds / 1000);
    this.milliseconds = this.timeStamp.getMilliseconds();
    this.level = level;
    this.messages = messages;
    this.exception = exception;
  };

  LoggingEvent.prototype = {
    getThrowableStrRep: function() {
      return this.exception ?
        getExceptionStringRep(this.exception) : "";
    },
    getCombinedMessages: function() {
      return (this.messages.length == 1) ? this.messages[0] :
           this.messages.join(newLine);
    },
    toString: function() {
      return "LoggingEvent[" + this.level + "]";
    }
  };

  log4javascript.LoggingEvent = LoggingEvent;

  /* ---------------------------------------------------------------------- */
  // Layout prototype

  var Layout = function() {
  };

  Layout.prototype = {
    defaults: {
      loggerKey: "logger",
      timeStampKey: "timestamp",
      millisecondsKey: "milliseconds",
      levelKey: "level",
      messageKey: "message",
      exceptionKey: "exception",
      urlKey: "url"
    },
    loggerKey: "logger",
    timeStampKey: "timestamp",
    millisecondsKey: "milliseconds",
    levelKey: "level",
    messageKey: "message",
    exceptionKey: "exception",
    urlKey: "url",
    batchHeader: "",
    batchFooter: "",
    batchSeparator: "",
    returnsPostData: false,
    overrideTimeStampsSetting: false,
    useTimeStampsInMilliseconds: null,

    format: function() {
      handleError("Layout.format: layout supplied has no format() method");
    },

    ignoresThrowable: function() {
      handleError("Layout.ignoresThrowable: layout supplied has no ignoresThrowable() method");
    },

    getContentType: function() {
      return "text/plain";
    },

    allowBatching: function() {
      return true;
    },

    setTimeStampsInMilliseconds: function(timeStampsInMilliseconds) {
      this.overrideTimeStampsSetting = true;
      this.useTimeStampsInMilliseconds = bool(timeStampsInMilliseconds);
    },

    isTimeStampsInMilliseconds: function() {
      return this.overrideTimeStampsSetting ?
        this.useTimeStampsInMilliseconds : useTimeStampsInMilliseconds;
    },

    getTimeStampValue: function(loggingEvent) {
      return this.isTimeStampsInMilliseconds() ?
        loggingEvent.timeStampInMilliseconds : loggingEvent.timeStampInSeconds;
    },

    getDataValues: function(loggingEvent, combineMessages) {
      var dataValues = [
        [this.loggerKey, loggingEvent.logger.name],
        [this.timeStampKey, this.getTimeStampValue(loggingEvent)],
        [this.levelKey, loggingEvent.level.name],
        [this.urlKey, window.location.href],
        [this.messageKey, combineMessages ? loggingEvent.getCombinedMessages() : loggingEvent.messages]
      ];
      if (!this.isTimeStampsInMilliseconds()) {
        dataValues.push([this.millisecondsKey, loggingEvent.milliseconds]);
      }
      if (loggingEvent.exception) {
        dataValues.push([this.exceptionKey, getExceptionStringRep(loggingEvent.exception)]);
      }
      if (this.hasCustomFields()) {
        for (var i = 0, len = this.customFields.length; i < len; i++) {
          var val = this.customFields[i].value;

          // Check if the value is a function. If so, execute it, passing it the
          // current layout and the logging event
          if (typeof val === "function") {
            val = val(this, loggingEvent);
          }
          dataValues.push([this.customFields[i].name, val]);
        }
      }
      return dataValues;
    },

    setKeys: function(loggerKey, timeStampKey, levelKey, messageKey,
        exceptionKey, urlKey, millisecondsKey) {
      this.loggerKey = extractStringFromParam(loggerKey, this.defaults.loggerKey);
      this.timeStampKey = extractStringFromParam(timeStampKey, this.defaults.timeStampKey);
      this.levelKey = extractStringFromParam(levelKey, this.defaults.levelKey);
      this.messageKey = extractStringFromParam(messageKey, this.defaults.messageKey);
      this.exceptionKey = extractStringFromParam(exceptionKey, this.defaults.exceptionKey);
      this.urlKey = extractStringFromParam(urlKey, this.defaults.urlKey);
      this.millisecondsKey = extractStringFromParam(millisecondsKey, this.defaults.millisecondsKey);
    },

    setCustomField: function(name, value) {
      var fieldUpdated = false;
      for (var i = 0, len = this.customFields.length; i < len; i++) {
        if (this.customFields[i].name === name) {
          this.customFields[i].value = value;
          fieldUpdated = true;
        }
      }
      if (!fieldUpdated) {
        this.customFields.push({"name": name, "value": value});
      }
    },

    hasCustomFields: function() {
      return (this.customFields.length > 0);
    },

    toString: function() {
      handleError("Layout.toString: all layouts must override this method");
    }
  };

  log4javascript.Layout = Layout;

  /* ---------------------------------------------------------------------- */
  // Appender prototype

  var Appender = function() {};

  Appender.prototype = new EventSupport();

  Appender.prototype.layout = new PatternLayout();
  Appender.prototype.threshold = Level.ALL;
  Appender.prototype.loggers = [];

  // Performs threshold checks before delegating actual logging to the
  // subclass's specific append method.
  Appender.prototype.doAppend = function(loggingEvent) {
    if (enabled && loggingEvent.level.level >= this.threshold.level) {
      this.append(loggingEvent);
    }
  };

  Appender.prototype.append = function(loggingEvent) {};

  Appender.prototype.setLayout = function(layout) {
    if (layout instanceof Layout) {
      this.layout = layout;
    } else {
      handleError("Appender.setLayout: layout supplied to " +
        this.toString() + " is not a subclass of Layout");
    }
  };

  Appender.prototype.getLayout = function() {
    return this.layout;
  };

  Appender.prototype.setThreshold = function(threshold) {
    if (threshold instanceof Level) {
      this.threshold = threshold;
    } else {
      handleError("Appender.setThreshold: threshold supplied to " +
        this.toString() + " is not a subclass of Level");
    }
  };

  Appender.prototype.getThreshold = function() {
    return this.threshold;
  };

  Appender.prototype.setAddedToLogger = function(logger) {
    this.loggers.push(logger);
  };

  Appender.prototype.setRemovedFromLogger = function(logger) {
    array_remove(this.loggers, logger);
  };

  Appender.prototype.group = emptyFunction;
  Appender.prototype.groupEnd = emptyFunction;

  Appender.prototype.toString = function() {
    handleError("Appender.toString: all appenders must override this method");
  };

  log4javascript.Appender = Appender;

  /* ---------------------------------------------------------------------- */
  // SimpleLayout

  function SimpleLayout() {
    this.customFields = [];
  }

  SimpleLayout.prototype = new Layout();

  SimpleLayout.prototype.format = function(loggingEvent) {
    return loggingEvent.level.name + " - " + loggingEvent.getCombinedMessages();
  };

  SimpleLayout.prototype.ignoresThrowable = function() {
      return true;
  };

  SimpleLayout.prototype.toString = function() {
      return "SimpleLayout";
  };

  log4javascript.SimpleLayout = SimpleLayout;
  /* ----------------------------------------------------------------------- */
  // NullLayout

  function NullLayout() {
    this.customFields = [];
  }

  NullLayout.prototype = new Layout();

  NullLayout.prototype.format = function(loggingEvent) {
    return loggingEvent.messages;
  };

  NullLayout.prototype.ignoresThrowable = function() {
      return true;
  };

  NullLayout.prototype.toString = function() {
      return "NullLayout";
  };

  log4javascript.NullLayout = NullLayout;
/* ---------------------------------------------------------------------- */
  // XmlLayout

  function XmlLayout(combineMessages) {
    this.combineMessages = extractBooleanFromParam(combineMessages, true);
    this.customFields = [];
  }

  XmlLayout.prototype = new Layout();

  XmlLayout.prototype.isCombinedMessages = function() {
    return this.combineMessages;
  };

  XmlLayout.prototype.getContentType = function() {
    return "text/xml";
  };

  XmlLayout.prototype.escapeCdata = function(str) {
    return str.replace(/\]\]>/, "]]>]]&gt;<![CDATA[");
  };

  XmlLayout.prototype.format = function(loggingEvent) {
    var layout = this;
    var i, len;
    function formatMessage(message) {
      message = (typeof message === "string") ? message : toStr(message);
      return "<log4javascript:message><![CDATA[" +
        layout.escapeCdata(message) + "]]></log4javascript:message>";
    }

    var str = "<log4javascript:event logger=\"" + loggingEvent.logger.name +
      "\" timestamp=\"" + this.getTimeStampValue(loggingEvent) + "\"";
    if (!this.isTimeStampsInMilliseconds()) {
      str += " milliseconds=\"" + loggingEvent.milliseconds + "\"";
    }
    str += " level=\"" + loggingEvent.level.name + "\">" + newLine;
    if (this.combineMessages) {
      str += formatMessage(loggingEvent.getCombinedMessages());
    } else {
      str += "<log4javascript:messages>" + newLine;
      for (i = 0, len = loggingEvent.messages.length; i < len; i++) {
        str += formatMessage(loggingEvent.messages[i]) + newLine;
      }
      str += "</log4javascript:messages>" + newLine;
    }
    if (this.hasCustomFields()) {
      for (i = 0, len = this.customFields.length; i < len; i++) {
        str += "<log4javascript:customfield name=\"" +
          this.customFields[i].name + "\"><![CDATA[" +
          this.customFields[i].value.toString() +
          "]]></log4javascript:customfield>" + newLine;
      }
    }
    if (loggingEvent.exception) {
      str += "<log4javascript:exception><![CDATA[" +
        getExceptionStringRep(loggingEvent.exception) +
        "]]></log4javascript:exception>" + newLine;
    }
    str += "</log4javascript:event>" + newLine + newLine;
    return str;
  };

  XmlLayout.prototype.ignoresThrowable = function() {
      return false;
  };

  XmlLayout.prototype.toString = function() {
      return "XmlLayout";
  };

  log4javascript.XmlLayout = XmlLayout;
  /* ---------------------------------------------------------------------- */
  // JsonLayout related

  function escapeNewLines(str) {
    return str.replace(/\r\n|\r|\n/g, "\\r\\n");
  }

  function JsonLayout(readable, combineMessages) {
    this.readable = extractBooleanFromParam(readable, false);
    this.combineMessages = extractBooleanFromParam(combineMessages, true);
    this.batchHeader = this.readable ? "[" + newLine : "[";
    this.batchFooter = this.readable ? "]" + newLine : "]";
    this.batchSeparator = this.readable ? "," + newLine : ",";
    this.setKeys();
    this.colon = this.readable ? ": " : ":";
    this.tab = this.readable ? "\t" : "";
    this.lineBreak = this.readable ? newLine : "";
    this.customFields = [];
  }

  /* ---------------------------------------------------------------------- */
  // JsonLayout

  JsonLayout.prototype = new Layout();

  JsonLayout.prototype.isReadable = function() {
    return this.readable;
  };

  JsonLayout.prototype.isCombinedMessages = function() {
    return this.combineMessages;
  };

    JsonLayout.prototype.format = function(loggingEvent) {
        var layout = this;
        var dataValues = this.getDataValues(loggingEvent, this.combineMessages);
        var str = "{" + this.lineBreak;
        var i, len;

        function formatValue(val, prefix, expand) {
            // Check the type of the data value to decide whether quotation marks
            // or expansion are required
            var formattedValue;
            var valType = typeof val;
            if (val instanceof Date) {
                formattedValue = String(val.getTime());
            } else if (expand && (val instanceof Array)) {
                formattedValue = "[" + layout.lineBreak;
                for (var i = 0, len = val.length; i < len; i++) {
                    var childPrefix = prefix + layout.tab;
                    formattedValue += childPrefix + formatValue(val[i], childPrefix, false);
                    if (i < val.length - 1) {
                        formattedValue += ",";
                    }
                    formattedValue += layout.lineBreak;
                }
                formattedValue += prefix + "]";
            } else if (val instanceof Object) {
              formattedValue = JSON.stringify(val);
            } else if (valType !== "number" && valType !== "boolean") {
                formattedValue = "\"" + escapeNewLines(toStr(val).replace(/\"/g, "\\\"")) + "\"";
            } else {
                formattedValue = val;
            }
            return formattedValue;
        }

        for (i = 0, len = dataValues.length - 1; i <= len; i++) {
            str += this.tab + "\"" + dataValues[i][0] + "\"" + this.colon + formatValue(dataValues[i][1], this.tab, true);
            if (i < len) {
                str += ",";
            }
            str += this.lineBreak;
        }

        str += "}" + this.lineBreak;
        return str;
    };

  JsonLayout.prototype.ignoresThrowable = function() {
      return false;
  };

  JsonLayout.prototype.toString = function() {
      return "JsonLayout";
  };

  JsonLayout.prototype.getContentType = function() {
    return "application/json";
  };

  log4javascript.JsonLayout = JsonLayout;
  /* ---------------------------------------------------------------------- */
  // HttpPostDataLayout

  function HttpPostDataLayout() {
    this.setKeys();
    this.customFields = [];
    this.returnsPostData = true;
  }

  HttpPostDataLayout.prototype = new Layout();

  // Disable batching
  HttpPostDataLayout.prototype.allowBatching = function() {
    return false;
  };

  HttpPostDataLayout.prototype.format = function(loggingEvent) {
    var dataValues = this.getDataValues(loggingEvent);
    var queryBits = [];
    for (var i = 0, len = dataValues.length; i < len; i++) {
      var val = (dataValues[i][1] instanceof Date) ?
        String(dataValues[i][1].getTime()) : dataValues[i][1];
      queryBits.push(urlEncode(dataValues[i][0]) + "=" + urlEncode(val));
    }
    return queryBits.join("&");
  };

  HttpPostDataLayout.prototype.ignoresThrowable = function(loggingEvent) {
      return false;
  };

  HttpPostDataLayout.prototype.toString = function() {
      return "HttpPostDataLayout";
  };

  log4javascript.HttpPostDataLayout = HttpPostDataLayout;
  /* ---------------------------------------------------------------------- */
  // formatObjectExpansion

  function formatObjectExpansion(obj, depth, indentation) {
    var objectsExpanded = [];

    function doFormat(obj, depth, indentation) {
      var i, j, len, childDepth, childIndentation, childLines, expansion,
        childExpansion;

      if (!indentation) {
        indentation = "";
      }

      function formatString(text) {
        var lines = splitIntoLines(text);
        for (var j = 1, jLen = lines.length; j < jLen; j++) {
          lines[j] = indentation + lines[j];
        }
        return lines.join(newLine);
      }

      if (obj === null) {
        return "null";
      } else if (typeof obj == "undefined") {
        return "undefined";
      } else if (typeof obj == "string") {
        return formatString(obj);
      } else if (typeof obj == "object" && array_contains(objectsExpanded, obj)) {
        try {
          expansion = toStr(obj);
        } catch (ex) {
          expansion = "Error formatting property. Details: " + getExceptionStringRep(ex);
        }
        return expansion + " [already expanded]";
      } else if ((obj instanceof Array) && depth > 0) {
        objectsExpanded.push(obj);
        expansion = "[" + newLine;
        childDepth = depth - 1;
        childIndentation = indentation + "  ";
        childLines = [];
        for (i = 0, len = obj.length; i < len; i++) {
          try {
            childExpansion = doFormat(obj[i], childDepth, childIndentation);
            childLines.push(childIndentation + childExpansion);
          } catch (ex) {
            childLines.push(childIndentation + "Error formatting array member. Details: " +
              getExceptionStringRep(ex) + "");
          }
        }
        expansion += childLines.join("," + newLine) + newLine + indentation + "]";
        return expansion;
      } else if (typeof obj == "object" && depth > 0) {
        objectsExpanded.push(obj);
        expansion = "{" + newLine;
        childDepth = depth - 1;
        childIndentation = indentation + "  ";
        childLines = [];
        for (i in obj) {
          try {
            childExpansion = doFormat(obj[i], childDepth, childIndentation);
            childLines.push(childIndentation + i + ": " + childExpansion);
          } catch (ex) {
            childLines.push(childIndentation + i + ": Error formatting property. Details: " +
              getExceptionStringRep(ex));
          }
        }
        expansion += childLines.join("," + newLine) + newLine + indentation + "}";
        return expansion;
      } else {
        return formatString(toStr(obj));
      }
    }
    return doFormat(obj, depth, indentation);
  }
  /* ---------------------------------------------------------------------- */
  // Date-related stuff

  var SimpleDateFormat;

  (function() {
    var regex = /('[^']*')|(G+|y+|M+|w+|W+|D+|d+|F+|E+|a+|H+|k+|K+|h+|m+|s+|S+|Z+)|([a-zA-Z]+)|([^a-zA-Z']+)/;
    var monthNames = ["January", "February", "March", "April", "May", "June",
      "July", "August", "September", "October", "November", "December"];
    var dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var TEXT2 = 0, TEXT3 = 1, NUMBER = 2, YEAR = 3, MONTH = 4, TIMEZONE = 5;
    var types = {
      G : TEXT2,
      y : YEAR,
      M : MONTH,
      w : NUMBER,
      W : NUMBER,
      D : NUMBER,
      d : NUMBER,
      F : NUMBER,
      E : TEXT3,
      a : TEXT2,
      H : NUMBER,
      k : NUMBER,
      K : NUMBER,
      h : NUMBER,
      m : NUMBER,
      s : NUMBER,
      S : NUMBER,
      Z : TIMEZONE
    };
    var ONE_DAY = 24 * 60 * 60 * 1000;
    var ONE_WEEK = 7 * ONE_DAY;
    var DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK = 1;

    var newDateAtMidnight = function(year, month, day) {
      var d = new Date(year, month, day, 0, 0, 0);
      d.setMilliseconds(0);
      return d;
    };

    Date.prototype.getDifference = function(date) {
      return this.getTime() - date.getTime();
    };

    Date.prototype.isBefore = function(d) {
      return this.getTime() < d.getTime();
    };

    Date.prototype.getUTCTime = function() {
      return Date.UTC(this.getFullYear(), this.getMonth(), this.getDate(), this.getHours(), this.getMinutes(),
          this.getSeconds(), this.getMilliseconds());
    };

    Date.prototype.getTimeSince = function(d) {
      return this.getUTCTime() - d.getUTCTime();
    };

    Date.prototype.getPreviousSunday = function() {
      // Using midday avoids any possibility of DST messing things up
      var midday = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 12, 0, 0);
      var previousSunday = new Date(midday.getTime() - this.getDay() * ONE_DAY);
      return newDateAtMidnight(previousSunday.getFullYear(), previousSunday.getMonth(),
          previousSunday.getDate());
    };

    Date.prototype.getWeekInYear = function(minimalDaysInFirstWeek) {
      if (isUndefined(this.minimalDaysInFirstWeek)) {
        minimalDaysInFirstWeek = DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK;
      }
      var previousSunday = this.getPreviousSunday();
      var startOfYear = newDateAtMidnight(this.getFullYear(), 0, 1);
      var numberOfSundays = previousSunday.isBefore(startOfYear) ?
        0 : 1 + Math.floor(previousSunday.getTimeSince(startOfYear) / ONE_WEEK);
      var numberOfDaysInFirstWeek =  7 - startOfYear.getDay();
      var weekInYear = numberOfSundays;
      if (numberOfDaysInFirstWeek < minimalDaysInFirstWeek) {
        weekInYear--;
      }
      return weekInYear;
    };

    Date.prototype.getWeekInMonth = function(minimalDaysInFirstWeek) {
      if (isUndefined(this.minimalDaysInFirstWeek)) {
        minimalDaysInFirstWeek = DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK;
      }
      var previousSunday = this.getPreviousSunday();
      var startOfMonth = newDateAtMidnight(this.getFullYear(), this.getMonth(), 1);
      var numberOfSundays = previousSunday.isBefore(startOfMonth) ?
        0 : 1 + Math.floor(previousSunday.getTimeSince(startOfMonth) / ONE_WEEK);
      var numberOfDaysInFirstWeek =  7 - startOfMonth.getDay();
      var weekInMonth = numberOfSundays;
      if (numberOfDaysInFirstWeek >= minimalDaysInFirstWeek) {
        weekInMonth++;
      }
      return weekInMonth;
    };

    Date.prototype.getDayInYear = function() {
      var startOfYear = newDateAtMidnight(this.getFullYear(), 0, 1);
      return 1 + Math.floor(this.getTimeSince(startOfYear) / ONE_DAY);
    };

    /* ------------------------------------------------------------------ */

    SimpleDateFormat = function(formatString) {
      this.formatString = formatString;
    };

    /**
     * Sets the minimum number of days in a week in order for that week to
     * be considered as belonging to a particular month or year
     */
    SimpleDateFormat.prototype.setMinimalDaysInFirstWeek = function(days) {
      this.minimalDaysInFirstWeek = days;
    };

    SimpleDateFormat.prototype.getMinimalDaysInFirstWeek = function() {
      return isUndefined(this.minimalDaysInFirstWeek) ?
        DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK : this.minimalDaysInFirstWeek;
    };

    var padWithZeroes = function(str, len) {
      while (str.length < len) {
        str = "0" + str;
      }
      return str;
    };

    var formatText = function(data, numberOfLetters, minLength) {
      return (numberOfLetters >= 4) ? data : data.substr(0, Math.max(minLength, numberOfLetters));
    };

    var formatNumber = function(data, numberOfLetters) {
      var dataString = "" + data;
      // Pad with 0s as necessary
      return padWithZeroes(dataString, numberOfLetters);
    };

    SimpleDateFormat.prototype.format = function(date) {
      var formattedString = "";
      var result;
      var searchString = this.formatString;
      while ((result = regex.exec(searchString))) {
        var quotedString = result[1];
        var patternLetters = result[2];
        var otherLetters = result[3];
        var otherCharacters = result[4];

        // If the pattern matched is quoted string, output the text between the quotes
        if (quotedString) {
          if (quotedString == "''") {
            formattedString += "'";
          } else {
            formattedString += quotedString.substring(1, quotedString.length - 1);
          }
        } else if (otherLetters) {
          // Swallow non-pattern letters by doing nothing here
        } else if (otherCharacters) {
          // Simply output other characters
          formattedString += otherCharacters;
        } else if (patternLetters) {
          // Replace pattern letters
          var patternLetter = patternLetters.charAt(0);
          var numberOfLetters = patternLetters.length;
          var rawData = "";
          switch(patternLetter) {
            case "G":
              rawData = "AD";
              break;
            case "y":
              rawData = date.getFullYear();
              break;
            case "M":
              rawData = date.getMonth();
              break;
            case "w":
              rawData = date.getWeekInYear(this.getMinimalDaysInFirstWeek());
              break;
            case "W":
              rawData = date.getWeekInMonth(this.getMinimalDaysInFirstWeek());
              break;
            case "D":
              rawData = date.getDayInYear();
              break;
            case "d":
              rawData = date.getDate();
              break;
            case "F":
              rawData = 1 + Math.floor((date.getDate() - 1) / 7);
              break;
            case "E":
              rawData = dayNames[date.getDay()];
              break;
            case "a":
              rawData = (date.getHours() >= 12) ? "PM" : "AM";
              break;
            case "H":
              rawData = date.getHours();
              break;
            case "k":
              rawData = date.getHours() || 24;
              break;
            case "K":
              rawData = date.getHours() % 12;
              break;
            case "h":
              rawData = (date.getHours() % 12) || 12;
              break;
            case "m":
              rawData = date.getMinutes();
              break;
            case "s":
              rawData = date.getSeconds();
              break;
            case "S":
              rawData = date.getMilliseconds();
              break;
            case "Z":
              rawData = date.getTimezoneOffset(); // This returns the number of minutes since GMT was this time.
              break;
          }
          // Format the raw data depending on the type
          switch(types[patternLetter]) {
            case TEXT2:
              formattedString += formatText(rawData, numberOfLetters, 2);
              break;
            case TEXT3:
              formattedString += formatText(rawData, numberOfLetters, 3);
              break;
            case NUMBER:
              formattedString += formatNumber(rawData, numberOfLetters);
              break;
            case YEAR:
              if (numberOfLetters <= 3) {
                // Output a 2-digit year
                var dataString = "" + rawData;
                formattedString += dataString.substr(2, 2);
              } else {
                formattedString += formatNumber(rawData, numberOfLetters);
              }
              break;
            case MONTH:
              if (numberOfLetters >= 3) {
                formattedString += formatText(monthNames[rawData], numberOfLetters, numberOfLetters);
              } else {
                // NB. Months returned by getMonth are zero-based
                formattedString += formatNumber(rawData + 1, numberOfLetters);
              }
              break;
            case TIMEZONE:
              var isPositive = (rawData > 0);
              // The following line looks like a mistake but isn't
              // because of the way getTimezoneOffset measures.
              var prefix = isPositive ? "-" : "+";
              var absData = Math.abs(rawData);

              // Hours
              var hours = "" + Math.floor(absData / 60);
              hours = padWithZeroes(hours, 2);
              // Minutes
              var minutes = "" + (absData % 60);
              minutes = padWithZeroes(minutes, 2);

              formattedString += prefix + hours + minutes;
              break;
          }
        }
        searchString = searchString.substr(result.index + result[0].length);
      }
      return formattedString;
    };
  })();

  log4javascript.SimpleDateFormat = SimpleDateFormat;

  /* ---------------------------------------------------------------------- */
  // PatternLayout

  function PatternLayout(pattern) {
    if (pattern) {
      this.pattern = pattern;
    } else {
      this.pattern = PatternLayout.DEFAULT_CONVERSION_PATTERN;
    }
    this.customFields = [];
  }

  PatternLayout.TTCC_CONVERSION_PATTERN = "%r %p %c - %m%n";
  PatternLayout.DEFAULT_CONVERSION_PATTERN = "%m%n";
  PatternLayout.ISO8601_DATEFORMAT = "yyyy-MM-dd HH:mm:ss,SSS";
  PatternLayout.DATETIME_DATEFORMAT = "dd MMM yyyy HH:mm:ss,SSS";
  PatternLayout.ABSOLUTETIME_DATEFORMAT = "HH:mm:ss,SSS";

  PatternLayout.prototype = new Layout();

  PatternLayout.prototype.format = function(loggingEvent) {
    var regex = /%(-?[0-9]+)?(\.?[0-9]+)?([acdfmMnpr%])(\{([^\}]+)\})?|([^%]+)/;
    var formattedString = "";
    var result;
    var searchString = this.pattern;

    // Cannot use regex global flag since it doesn't work with exec in IE5
    while ((result = regex.exec(searchString))) {
      var matchedString = result[0];
      var padding = result[1];
      var truncation = result[2];
      var conversionCharacter = result[3];
      var specifier = result[5];
      var text = result[6];

      // Check if the pattern matched was just normal text
      if (text) {
        formattedString += "" + text;
      } else {
        // Create a raw replacement string based on the conversion
        // character and specifier
        var replacement = "";
        switch(conversionCharacter) {
          case "a": // Array of messages
          case "m": // Message
            var depth = 0;
            if (specifier) {
              depth = parseInt(specifier, 10);
              if (isNaN(depth)) {
                handleError("PatternLayout.format: invalid specifier '" +
                  specifier + "' for conversion character '" + conversionCharacter +
                  "' - should be a number");
                depth = 0;
              }
            }
            var messages = (conversionCharacter === "a") ? loggingEvent.messages[0] : loggingEvent.messages;
            for (var i = 0, len = messages.length; i < len; i++) {
              if (i > 0 && (replacement.charAt(replacement.length - 1) !== " ")) {
                replacement += " ";
              }
              if (depth === 0) {
                replacement += messages[i];
              } else {
                replacement += formatObjectExpansion(messages[i], depth);
              }
            }
            break;
          case "c": // Logger name
            var loggerName = loggingEvent.logger.name;
            if (specifier) {
              var precision = parseInt(specifier, 10);
              var loggerNameBits = loggingEvent.logger.name.split(".");
              if (precision >= loggerNameBits.length) {
                replacement = loggerName;
              } else {
                replacement = loggerNameBits.slice(loggerNameBits.length - precision).join(".");
              }
            } else {
              replacement = loggerName;
            }
            break;
          case "d": // Date
            var dateFormat = PatternLayout.ISO8601_DATEFORMAT;
            if (specifier) {
              dateFormat = specifier;
              // Pick up special cases
              if (dateFormat == "ISO8601") {
                dateFormat = PatternLayout.ISO8601_DATEFORMAT;
              } else if (dateFormat == "ABSOLUTE") {
                dateFormat = PatternLayout.ABSOLUTETIME_DATEFORMAT;
              } else if (dateFormat == "DATE") {
                dateFormat = PatternLayout.DATETIME_DATEFORMAT;
              }
            }
            // Format the date
            replacement = (new SimpleDateFormat(dateFormat)).format(loggingEvent.timeStamp);
            break;
          case "f": // Custom field
            if (this.hasCustomFields()) {
              var fieldIndex = 0;
              if (specifier) {
                fieldIndex = parseInt(specifier, 10);
                if (isNaN(fieldIndex)) {
                  handleError("PatternLayout.format: invalid specifier '" +
                    specifier + "' for conversion character 'f' - should be a number");
                } else if (fieldIndex === 0) {
                  handleError("PatternLayout.format: invalid specifier '" +
                    specifier + "' for conversion character 'f' - must be greater than zero");
                } else if (fieldIndex > this.customFields.length) {
                  handleError("PatternLayout.format: invalid specifier '" +
                    specifier + "' for conversion character 'f' - there aren't that many custom fields");
                } else {
                  fieldIndex = fieldIndex - 1;
                }
              }
              replacement = this.customFields[fieldIndex].value;
            }
            break;
          case "n": // New line
            replacement = newLine;
            break;
          case "p": // Level
            replacement = loggingEvent.level.name;
            break;
          case "r": // Milliseconds since log4javascript startup
            replacement = "" + loggingEvent.timeStamp.getDifference(applicationStartDate);
            break;
          case "%": // Literal % sign
            replacement = "%";
            break;
          default:
            replacement = matchedString;
            break;
        }
        // Format the replacement according to any padding or
        // truncation specified
        var l;

        // First, truncation
        if (truncation) {
          l = parseInt(truncation.substr(1), 10);
          var strLen = replacement.length;
          if (l < strLen) {
            replacement = replacement.substring(strLen - l, strLen);
          }
        }
        // Next, padding
        if (padding) {
          if (padding.charAt(0) == "-") {
            l = parseInt(padding.substr(1), 10);
            // Right pad with spaces
            while (replacement.length < l) {
              replacement += " ";
            }
          } else {
            l = parseInt(padding, 10);
            // Left pad with spaces
            while (replacement.length < l) {
              replacement = " " + replacement;
            }
          }
        }
        formattedString += replacement;
      }
      searchString = searchString.substr(result.index + result[0].length);
    }
    return formattedString;
  };

  PatternLayout.prototype.ignoresThrowable = function() {
      return true;
  };

  PatternLayout.prototype.toString = function() {
      return "PatternLayout";
  };

  log4javascript.PatternLayout = PatternLayout;
  /* ---------------------------------------------------------------------- */
  // AlertAppender

  function AlertAppender() {}

  AlertAppender.prototype = new Appender();

  AlertAppender.prototype.layout = new SimpleLayout();

  AlertAppender.prototype.append = function(loggingEvent) {
    var formattedMessage = this.getLayout().format(loggingEvent);
    if (this.getLayout().ignoresThrowable()) {
      formattedMessage += loggingEvent.getThrowableStrRep();
    }
    alert(formattedMessage);
  };

  AlertAppender.prototype.toString = function() {
    return "AlertAppender";
  };

  log4javascript.AlertAppender = AlertAppender;
  /* ---------------------------------------------------------------------- */
  // BrowserConsoleAppender (only works in Opera and Safari and Firefox with
  // Firebug extension)

  function BrowserConsoleAppender() {}

  BrowserConsoleAppender.prototype = new log4javascript.Appender();
  BrowserConsoleAppender.prototype.layout = new NullLayout();
  BrowserConsoleAppender.prototype.threshold = Level.DEBUG;

  BrowserConsoleAppender.prototype.append = function(loggingEvent) {
    var appender = this;

    var getFormattedMessage = function() {
      var layout = appender.getLayout();
      var formattedMessage = layout.format(loggingEvent);
      if (layout.ignoresThrowable() && loggingEvent.exception) {
        formattedMessage += loggingEvent.getThrowableStrRep();
      }
      return formattedMessage;
    };

    if ((typeof opera != "undefined") && opera.postError) { // Opera
      opera.postError(getFormattedMessage());
    } else if (window.console && window.console.log) { // Safari and Firebug
      var formattedMesage = getFormattedMessage();
      // Log to Firebug using its logging methods or revert to the console.log
      // method in Safari
      if (window.console.debug && Level.DEBUG.isGreaterOrEqual(loggingEvent.level)) {
        window.console.debug(formattedMesage);
      } else if (window.console.info && Level.INFO.equals(loggingEvent.level)) {
        window.console.info(formattedMesage);
      } else if (window.console.warn && Level.WARN.equals(loggingEvent.level)) {
        window.console.warn(formattedMesage);
      } else if (window.console.error && loggingEvent.level.isGreaterOrEqual(Level.ERROR)) {
        window.console.error(formattedMesage);
      } else {
        window.console.log(formattedMesage);
      }
    }
  };

  BrowserConsoleAppender.prototype.group = function(name) {
    if (window.console && window.console.group) {
      window.console.group(name);
    }
  };

  BrowserConsoleAppender.prototype.groupEnd = function() {
    if (window.console && window.console.groupEnd) {
      window.console.groupEnd();
    }
  };

  BrowserConsoleAppender.prototype.toString = function() {
    return "BrowserConsoleAppender";
  };

  log4javascript.BrowserConsoleAppender = BrowserConsoleAppender;
  /* ---------------------------------------------------------------------- */
  // AjaxAppender related

    var xmlHttpFactories = [
        function() { return new XMLHttpRequest(); },
        function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
        function() { return new ActiveXObject("Microsoft.XMLHTTP"); }
    ];

    var getXmlHttp = function(errorHandler) {
        // This is only run the first time; the value of getXmlHttp gets
        // replaced with the factory that succeeds on the first run
        var xmlHttp = null, factory;
        for (var i = 0, len = xmlHttpFactories.length; i < len; i++) {
            factory = xmlHttpFactories[i];
            try {
                xmlHttp = factory();
                getXmlHttp = factory;
                return xmlHttp;
            } catch (e) {
            }
        }
        // If we're here, all factories have failed, so throw an error
        if (errorHandler) {
            errorHandler();
        } else {
            handleError("getXmlHttp: unable to obtain XMLHttpRequest object");
        }
    };

  function isHttpRequestSuccessful(xmlHttp) {
    return (isUndefined(xmlHttp.status) || xmlHttp.status === 0 ||
      (xmlHttp.status >= 200 && xmlHttp.status < 300));
  }

  /* ---------------------------------------------------------------------- */
  // AjaxAppender

  function AjaxAppender(url) {
    var appender = this;
    var isSupported = true;
    if (!url) {
      handleError("AjaxAppender: URL must be specified in constructor");
      isSupported = false;
    }

    var timed = this.defaults.timed;
    var waitForResponse = this.defaults.waitForResponse;
    var batchSize = this.defaults.batchSize;
    var timerInterval = this.defaults.timerInterval;
    var requestSuccessCallback = this.defaults.requestSuccessCallback;
    var failCallback = this.defaults.failCallback;
    var postVarName = this.defaults.postVarName;
    var sendAllOnUnload = this.defaults.sendAllOnUnload;
    var sessionId = null;

    var queuedLoggingEvents = [];
    var queuedRequests = [];
    var sending = false;
    var initialized = false;

    // Configuration methods. The function scope is used to prevent
    // direct alteration to the appender configuration properties.
    function checkCanConfigure(configOptionName) {
      if (initialized) {
        handleError("AjaxAppender: configuration option '" +
          configOptionName +
          "' may not be set after the appender has been initialized");
        return false;
      }
      return true;
    }

    this.getSessionId = function() { return sessionId; };
    this.setSessionId = function(sessionIdParam) {
      sessionId = extractStringFromParam(sessionIdParam, null);
      this.layout.setCustomField("sessionid", sessionId);
    };

    this.setLayout = function(layoutParam) {
      if (checkCanConfigure("layout")) {
        this.layout = layoutParam;
        // Set the session id as a custom field on the layout, if not already present
        if (sessionId !== null) {
          this.setSessionId(sessionId);
        }
      }
    };

    this.isTimed = function() { return timed; };
    this.setTimed = function(timedParam) {
      if (checkCanConfigure("timed")) {
        timed = bool(timedParam);
      }
    };

    this.getTimerInterval = function() { return timerInterval; };
    this.setTimerInterval = function(timerIntervalParam) {
      if (checkCanConfigure("timerInterval")) {
        timerInterval = extractIntFromParam(timerIntervalParam, timerInterval);
      }
    };

    this.isWaitForResponse = function() { return waitForResponse; };
    this.setWaitForResponse = function(waitForResponseParam) {
      if (checkCanConfigure("waitForResponse")) {
        waitForResponse = bool(waitForResponseParam);
      }
    };

    this.getBatchSize = function() { return batchSize; };
    this.setBatchSize = function(batchSizeParam) {
      if (checkCanConfigure("batchSize")) {
        batchSize = extractIntFromParam(batchSizeParam, batchSize);
      }
    };

    this.isSendAllOnUnload = function() { return sendAllOnUnload; };
    this.setSendAllOnUnload = function(sendAllOnUnloadParam) {
      if (checkCanConfigure("sendAllOnUnload")) {
        sendAllOnUnload = extractIntFromParam(sendAllOnUnloadParam, sendAllOnUnload);
      }
    };

    this.setRequestSuccessCallback = function(requestSuccessCallbackParam) {
      requestSuccessCallback = extractFunctionFromParam(requestSuccessCallbackParam, requestSuccessCallback);
    };

    this.setFailCallback = function(failCallbackParam) {
      failCallback = extractFunctionFromParam(failCallbackParam, failCallback);
    };

    this.getPostVarName = function() { return postVarName; };
    this.setPostVarName = function(postVarNameParam) {
      if (checkCanConfigure("postVarName")) {
        postVarName = extractStringFromParam(postVarNameParam, postVarName);
      }
    };

    // Internal functions
    function sendAll() {
      if (isSupported && enabled) {
        sending = true;
        var currentRequestBatch;
        if (waitForResponse) {
          // Send the first request then use this function as the callback once
          // the response comes back
          if (queuedRequests.length > 0) {
            currentRequestBatch = queuedRequests.shift();
            sendRequest(preparePostData(currentRequestBatch), sendAll);
          } else {
            sending = false;
            if (timed) {
              scheduleSending();
            }
          }
        } else {
          // Rattle off all the requests without waiting to see the response
          while ((currentRequestBatch = queuedRequests.shift())) {
            sendRequest(preparePostData(currentRequestBatch));
          }
          sending = false;
          if (timed) {
            scheduleSending();
          }
        }
      }
    }

    this.sendAll = sendAll;

    // Called when the window unloads. At this point we're past caring about
    // waiting for responses or timers or incomplete batches - everything
    // must go, now
    function sendAllRemaining() {
      if (isSupported && enabled) {
        // Create requests for everything left over, batched as normal
        var actualBatchSize = appender.getLayout().allowBatching() ? batchSize : 1;
        var currentLoggingEvent;
        var postData = "";
        var batchedLoggingEvents = [];
        while ((currentLoggingEvent = queuedLoggingEvents.shift())) {
          batchedLoggingEvents.push(currentLoggingEvent);
          if (queuedLoggingEvents.length >= actualBatchSize) {
            // Queue this batch of log entries
            queuedRequests.push(batchedLoggingEvents);
            batchedLoggingEvents = [];
          }
        }
        // If there's a partially completed batch, add it
        if (batchedLoggingEvents.length > 0) {
          queuedRequests.push(batchedLoggingEvents);
        }
        waitForResponse = false;
        timed = false;
        sendAll();
      }
    }

    function preparePostData(batchedLoggingEvents) {
      // Format the logging events
      var formattedMessages = [];
      var currentLoggingEvent;
      var postData = "";
      while ((currentLoggingEvent = batchedLoggingEvents.shift())) {
        var currentFormattedMessage = appender.getLayout().format(currentLoggingEvent);
        if (appender.getLayout().ignoresThrowable()) {
          currentFormattedMessage += loggingEvent.getThrowableStrRep();
        }
        formattedMessages.push(currentFormattedMessage);
      }
      // Create the post data string
      if (batchedLoggingEvents.length == 1) {
        postData = formattedMessages.join("");
      } else {
        postData = appender.getLayout().batchHeader +
          formattedMessages.join(appender.getLayout().batchSeparator) +
          appender.getLayout().batchFooter;
      }
      postData = appender.getLayout().returnsPostData ? postData :
        urlEncode(postVarName) + "=" + urlEncode(postData);
      // Add the layout name to the post data
      if (postData.length > 0) {
        postData += "&";
      }
      return postData + "layout=" + urlEncode(appender.getLayout().toString());
    }

    function scheduleSending() {
      window.setTimeout(sendAll, timerInterval);
    }

    function xmlHttpErrorHandler() {
      var msg = "AjaxAppender: could not create XMLHttpRequest object. AjaxAppender disabled";
      handleError(msg);
      isSupported = false;
      if (failCallback) {
        failCallback(msg);
      }
    }

    function sendRequest(postData, successCallback) {
      try {
        var xmlHttp = getXmlHttp(xmlHttpErrorHandler);
        if (isSupported) {
          if (xmlHttp.overrideMimeType) {
            xmlHttp.overrideMimeType(appender.getLayout().getContentType());
          }
          xmlHttp.onreadystatechange = function() {
            if (xmlHttp.readyState == 4) {
              if (isHttpRequestSuccessful(xmlHttp)) {
                if (requestSuccessCallback) {
                  requestSuccessCallback(xmlHttp);
                }
                if (successCallback) {
                  successCallback(xmlHttp);
                }
              } else {
                var msg = "AjaxAppender.append: XMLHttpRequest request to URL " +
                  url + " returned status code " + xmlHttp.status;
                handleError(msg);
                if (failCallback) {
                  failCallback(msg);
                }
              }
              xmlHttp.onreadystatechange = emptyFunction;
              xmlHttp = null;
            }
          };
          xmlHttp.open("POST", url, true);
          try {
            xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
          } catch (headerEx) {
            var msg = "AjaxAppender.append: your browser's XMLHttpRequest implementation" +
              " does not support setRequestHeader, therefore cannot post data. AjaxAppender disabled";
            handleError(msg);
            isSupported = false;
            if (failCallback) {
              failCallback(msg);
            }
            return;
          }
          xmlHttp.send(postData);
        }
      } catch (ex) {
        var errMsg = "AjaxAppender.append: error sending log message to " + url;
        handleError(errMsg, ex);
        isSupported = false;
        if (failCallback) {
          failCallback(errMsg + ". Details: " + getExceptionStringRep(ex));
        }
      }
    }

    this.append = function(loggingEvent) {
      if (isSupported) {
        if (!initialized) {
          init();
        }
        queuedLoggingEvents.push(loggingEvent);
        var actualBatchSize = this.getLayout().allowBatching() ? batchSize : 1;

        if (queuedLoggingEvents.length >= actualBatchSize) {
          var currentLoggingEvent;
          var batchedLoggingEvents = [];
          while ((currentLoggingEvent = queuedLoggingEvents.shift())) {
            batchedLoggingEvents.push(currentLoggingEvent);
          }
          // Queue this batch of log entries
          queuedRequests.push(batchedLoggingEvents);

          // If using a timer, the queue of requests will be processed by the
          // timer function, so nothing needs to be done here.
          if (!timed && (!waitForResponse || (waitForResponse && !sending))) {
                        sendAll();
          }
        }
      }
    };

    function init() {
      initialized = true;
      // Add unload event to send outstanding messages
      if (sendAllOnUnload) {
        addEvent(window, "unload", sendAllRemaining);
      }
      // Start timer
      if (timed) {
        scheduleSending();
      }
    }
  }

  AjaxAppender.prototype = new Appender();

  AjaxAppender.prototype.defaults = {
    waitForResponse: false,
    timed: false,
    timerInterval: 1000,
    batchSize: 1,
    sendAllOnUnload: true,
    requestSuccessCallback: null,
    failCallback: null,
    postVarName: "data"
  };

  AjaxAppender.prototype.layout = new HttpPostDataLayout();

  AjaxAppender.prototype.toString = function() {
    return "AjaxAppender";
  };

  log4javascript.AjaxAppender = AjaxAppender;

  /* ---------------------------------------------------------------------- */
  // SocketAppender

  function SocketAppender(url, socketAdapter) {
    var appender = this;
    var isSupported = true;
    this.socket = null;
    this.socketAdapter = socketAdapter;
    this.url = url;
    if (this.url !== null && this.url !== "") {
      this.socket = io.connect(url, {transports: ['websocket']});
    }
    if (this.socket === null && socketAdapter === null) {
      var errorMessage = "SocketAppender: URL or SocketAdapter must be specified in constructor";
      if (console && console.error) {
        console.error(errorMessage);
      }
      handleError(errorMessage);
      isSupported = false;
    }

    var timed = this.defaults.timed;
    var waitForResponse = this.defaults.waitForResponse;
    var batchSize = this.defaults.batchSize;
    var timerInterval = this.defaults.timerInterval;
    var postVarName = this.defaults.postVarName;
    var sendAllOnUnload = this.defaults.sendAllOnUnload;
    var sessionId = null;

    var queuedLoggingEvents = [];
    var queuedRequests = [];
    var sending = false;
    var initialized = false;

    // Configuration methods. The function scope is used to prevent
    // direct alteration to the appender configuration properties.
    function checkCanConfigure(configOptionName) {
      if (initialized) {
        handleError("SocketAppender: configuration option '" +
          configOptionName +
          "' may not be set after the appender has been initialized");
        return false;
      }
      return true;
    }

    this.getSessionId = function() { return sessionId; };
    this.setSessionId = function(sessionIdParam) {
      sessionId = extractStringFromParam(sessionIdParam, null);
      this.layout.setCustomField("sessionid", sessionId);
    };

    this.setLayout = function(layoutParam) {
      if (checkCanConfigure("layout")) {
        this.layout = layoutParam;
        // Set the session id as a custom field on the layout, if not already present
        if (sessionId !== null) {
          this.setSessionId(sessionId);
        }
      }
    };

    this.isTimed = function() { return timed; };
    this.setTimed = function(timedParam) {
      if (checkCanConfigure("timed")) {
        timed = bool(timedParam);
      }
    };

    this.getTimerInterval = function() { return timerInterval; };
    this.setTimerInterval = function(timerIntervalParam) {
      if (checkCanConfigure("timerInterval")) {
        timerInterval = extractIntFromParam(timerIntervalParam, timerInterval);
      }
    };

    this.isWaitForResponse = function() { return waitForResponse; };
    this.setWaitForResponse = function(waitForResponseParam) {
      if (checkCanConfigure("waitForResponse")) {
        waitForResponse = bool(waitForResponseParam);
      }
    };

    this.getBatchSize = function() { return batchSize; };
    this.setBatchSize = function(batchSizeParam) {
      if (checkCanConfigure("batchSize")) {
        batchSize = extractIntFromParam(batchSizeParam, batchSize);
      }
    };

    this.isSendAllOnUnload = function() { return sendAllOnUnload; };
    this.setSendAllOnUnload = function(sendAllOnUnloadParam) {
      if (checkCanConfigure("sendAllOnUnload")) {
        sendAllOnUnload = extractIntFromParam(sendAllOnUnloadParam, sendAllOnUnload);
      }
    };

    // Internal functions
    function sendAll() {
      if (isSupported && enabled) {
        sending = true;
        var currentRequestBatch;
        if (waitForResponse) {
          // Send the first request then use this function as the callback once
          // the response comes back
          if (queuedRequests.length > 0) {
            currentRequestBatch = queuedRequests.shift();
            sendData(prepareData(currentRequestBatch), sendAll);
          } else {
            sending = false;
            if (timed) {
              scheduleSending();
            }
          }
        } else {
          // Rattle off all the requests without waiting to see the response
          while ((currentRequestBatch = queuedRequests.shift())) {
            sendData(prepareData(currentRequestBatch));
          }
          sending = false;
          if (timed) {
            scheduleSending();
          }
        }
      }
    }

    this.sendAll = sendAll;

    // Called when the window unloads. At this point we're past caring about
    // waiting for responses or timers or incomplete batches - everything
    // must go, now
    function sendAllRemaining() {
      if (isSupported && enabled) {
        // Create requests for everything left over, batched as normal
        var actualBatchSize = appender.getLayout().allowBatching() ? batchSize : 1;
        var currentLoggingEvent;
        var postData = "";
        var batchedLoggingEvents = [];
        while ((currentLoggingEvent = queuedLoggingEvents.shift())) {
          batchedLoggingEvents.push(currentLoggingEvent);
          if (queuedLoggingEvents.length >= actualBatchSize) {
            // Queue this batch of log entries
            queuedRequests.push(batchedLoggingEvents);
            batchedLoggingEvents = [];
          }
        }
        // If there's a partially completed batch, add it
        if (batchedLoggingEvents.length > 0) {
          queuedRequests.push(batchedLoggingEvents);
        }
        waitForResponse = false;
        timed = false;
        sendAll();
      }
    }

    function prepareData(batchedLoggingEvents) {
      // Format the logging events
      var formattedMessages = [];
      var currentLoggingEvent;
      var data = "";
      while ((currentLoggingEvent = batchedLoggingEvents.shift())) {
        var currentFormattedMessage = appender.getLayout().format(currentLoggingEvent);
        if (appender.getLayout().ignoresThrowable()) {
          currentFormattedMessage += loggingEvent.getThrowableStrRep();
        }
        formattedMessages.push(currentFormattedMessage);
      }
      // Create the post data string
      if (batchedLoggingEvents.length == 1) {
        data = formattedMessages.join("");
      } else {
        data = appender.getLayout().batchHeader +
          formattedMessages.join(appender.getLayout().batchSeparator) +
          appender.getLayout().batchFooter;
      }
      data = JSON.parse(data);
      return data;
    }

    function scheduleSending() {
      window.setTimeout(sendAll, timerInterval);
    }

    function sendData(data, successCallback) {
      var eventName = "logger";
      if (appender.socket) {
        appender.socket.emit(eventName, data);
      }
      if (appender.socketAdapter) {
        appender.socketAdapter.request(eventName, data);
      }
      if (successCallback) {
        successCallback();
      }
    }

    this.append = function(loggingEvent) {
      if (isSupported) {
        if (!initialized) {
          init();
        }
        queuedLoggingEvents.push(loggingEvent);
        var actualBatchSize = this.getLayout().allowBatching() ? batchSize : 1;

        if (queuedLoggingEvents.length >= actualBatchSize) {
          var currentLoggingEvent;
          var batchedLoggingEvents = [];
          while ((currentLoggingEvent = queuedLoggingEvents.shift())) {
            batchedLoggingEvents.push(currentLoggingEvent);
          }
          // Queue this batch of log entries
          queuedRequests.push(batchedLoggingEvents);

          // If using a timer, the queue of requests will be processed by the
          // timer function, so nothing needs to be done here.
          if (!timed && (!waitForResponse || (waitForResponse && !sending))) {
                        sendAll();
          }
        }
      }
    };

    function init() {
      initialized = true;
      // Add unload event to send outstanding messages
      if (sendAllOnUnload) {
        addEvent(window, "unload", sendAllRemaining);
      }
      // Start timer
      if (timed) {
        scheduleSending();
      }
    }
  }

  SocketAppender.prototype = new Appender();

  SocketAppender.prototype.defaults = {
    waitForResponse: false,
    timed: false,
    timerInterval: 1000,
    batchSize: 1,
    sendAllOnUnload: true,
    requestSuccessCallback: null,
    failCallback: null,
    postVarName: "data"
  };

  SocketAppender.prototype.layout = new JsonLayout();

  SocketAppender.prototype.toString = function() {
    return "SocketAppender";
  };

  log4javascript.SocketAppender = SocketAppender;

  /* ---------------------------------------------------------------------- */
  // PopUpAppender and InPageAppender related

  function setCookie(name, value, days, path) {
      var expires;
      path = path ? "; path=" + path : "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toGMTString();
    } else {
        expires = "";
      }
    document.cookie = escape(name) + "=" + escape(value) + expires + path;
  }

  function getCookie(name) {
    var nameEquals = escape(name) + "=";
    var ca = document.cookie.split(";");
    for (var i = 0, len = ca.length; i < len; i++) {
      var c = ca[i];
      while (c.charAt(0) === " ") {
          c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEquals) === 0) {
          return unescape(c.substring(nameEquals.length, c.length));
          }
    }
    return null;
  }

  // Gets the base URL of the location of the log4javascript script.
  // This is far from infallible.
  function getBaseUrl() {
    var scripts = document.getElementsByTagName("script");
    for (var i = 0, len = scripts.length; i < len; ++i) {
      if (scripts[i].src.indexOf("log4javascript") != -1) {
        var lastSlash = scripts[i].src.lastIndexOf("/");
        return (lastSlash == -1) ? "" : scripts[i].src.substr(0, lastSlash + 1);
      }
    }
        return null;
    }

  function isLoaded(win) {
    try {
      return bool(win.loaded);
    } catch (ex) {
      return false;
    }
  }

  /* ---------------------------------------------------------------------- */
  // ConsoleAppender (prototype for PopUpAppender and InPageAppender)

  var ConsoleAppender;

  // Create an anonymous function to protect base console methods
  (function() {
    var getConsoleHtmlLines = function() {
      return [
'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
'<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">',
' <head>',
'   <title>log4javascript</title>',
'   <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />',
'   <!-- Make IE8 behave like IE7, having gone to all the trouble of making IE work -->',
'   <meta http-equiv="X-UA-Compatible" content="IE=7" />',
'   <script type="text/javascript">var isIe = false, isIePre7 = false;</script>',
'   <!--[if IE]><script type="text/javascript">isIe = true</script><![endif]-->',
'   <!--[if lt IE 7]><script type="text/javascript">isIePre7 = true</script><![endif]-->',
'   <script type="text/javascript">',
'     //<![CDATA[',
'     var loggingEnabled = true;',
'     var logQueuedEventsTimer = null;',
'     var logEntries = [];',
'     var logEntriesAndSeparators = [];',
'     var logItems = [];',
'     var renderDelay = 100;',
'     var unrenderedLogItemsExist = false;',
'     var rootGroup, currentGroup = null;',
'     var loaded = false;',
'     var currentLogItem = null;',
'     var logMainContainer;',
'',
'     function copyProperties(obj, props) {',
'       for (var i in props) {',
'         obj[i] = props[i];',
'       }',
'     }',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function LogItem() {',
'     }',
'',
'     LogItem.prototype = {',
'       mainContainer: null,',
'       wrappedContainer: null,',
'       unwrappedContainer: null,',
'       group: null,',
'',
'       appendToLog: function() {',
'         for (var i = 0, len = this.elementContainers.length; i < len; i++) {',
'           this.elementContainers[i].appendToLog();',
'         }',
'         this.group.update();',
'       },',
'',
'       doRemove: function(doUpdate, removeFromGroup) {',
'         if (this.rendered) {',
'           for (var i = 0, len = this.elementContainers.length; i < len; i++) {',
'             this.elementContainers[i].remove();',
'           }',
'           this.unwrappedElementContainer = null;',
'           this.wrappedElementContainer = null;',
'           this.mainElementContainer = null;',
'         }',
'         if (this.group && removeFromGroup) {',
'           this.group.removeChild(this, doUpdate);',
'         }',
'         if (this === currentLogItem) {',
'           currentLogItem = null;',
'         }',
'       },',
'',
'       remove: function(doUpdate, removeFromGroup) {',
'         this.doRemove(doUpdate, removeFromGroup);',
'       },',
'',
'       render: function() {},',
'',
'       accept: function(visitor) {',
'         visitor.visit(this);',
'       },',
'',
'       getUnwrappedDomContainer: function() {',
'         return this.group.unwrappedElementContainer.contentDiv;',
'       },',
'',
'       getWrappedDomContainer: function() {',
'         return this.group.wrappedElementContainer.contentDiv;',
'       },',
'',
'       getMainDomContainer: function() {',
'         return this.group.mainElementContainer.contentDiv;',
'       }',
'     };',
'',
'     LogItem.serializedItemKeys = {LOG_ENTRY: 0, GROUP_START: 1, GROUP_END: 2};',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function LogItemContainerElement() {',
'     }',
'',
'     LogItemContainerElement.prototype = {',
'       appendToLog: function() {',
'         var insertBeforeFirst = (newestAtTop && this.containerDomNode.hasChildNodes());',
'         if (insertBeforeFirst) {',
'           this.containerDomNode.insertBefore(this.mainDiv, this.containerDomNode.firstChild);',
'         } else {',
'           this.containerDomNode.appendChild(this.mainDiv);',
'         }',
'       }',
'     };',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function SeparatorElementContainer(containerDomNode) {',
'       this.containerDomNode = containerDomNode;',
'       this.mainDiv = document.createElement("div");',
'       this.mainDiv.className = "separator";',
'       this.mainDiv.innerHTML = "&nbsp;";',
'     }',
'',
'     SeparatorElementContainer.prototype = new LogItemContainerElement();',
'',
'     SeparatorElementContainer.prototype.remove = function() {',
'       this.mainDiv.parentNode.removeChild(this.mainDiv);',
'       this.mainDiv = null;',
'     };',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function Separator() {',
'       this.rendered = false;',
'     }',
'',
'     Separator.prototype = new LogItem();',
'',
'     copyProperties(Separator.prototype, {',
'       render: function() {',
'         var containerDomNode = this.group.contentDiv;',
'         if (isIe) {',
'           this.unwrappedElementContainer = new SeparatorElementContainer(this.getUnwrappedDomContainer());',
'           this.wrappedElementContainer = new SeparatorElementContainer(this.getWrappedDomContainer());',
'           this.elementContainers = [this.unwrappedElementContainer, this.wrappedElementContainer];',
'         } else {',
'           this.mainElementContainer = new SeparatorElementContainer(this.getMainDomContainer());',
'           this.elementContainers = [this.mainElementContainer];',
'         }',
'         this.content = this.formattedMessage;',
'         this.rendered = true;',
'       }',
'     });',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function GroupElementContainer(group, containerDomNode, isRoot, isWrapped) {',
'       this.group = group;',
'       this.containerDomNode = containerDomNode;',
'       this.isRoot = isRoot;',
'       this.isWrapped = isWrapped;',
'       this.expandable = false;',
'',
'       if (this.isRoot) {',
'         if (isIe) {',
'           this.contentDiv = logMainContainer.appendChild(document.createElement("div"));',
'           this.contentDiv.id = this.isWrapped ? "log_wrapped" : "log_unwrapped";',
'         } else {',
'           this.contentDiv = logMainContainer;',
'         }',
'       } else {',
'         var groupElementContainer = this;',
'         ',
'         this.mainDiv = document.createElement("div");',
'         this.mainDiv.className = "group";',
'',
'         this.headingDiv = this.mainDiv.appendChild(document.createElement("div"));',
'         this.headingDiv.className = "groupheading";',
'',
'         this.expander = this.headingDiv.appendChild(document.createElement("span"));',
'         this.expander.className = "expander unselectable greyedout";',
'         this.expander.unselectable = true;',
'         var expanderText = this.group.expanded ? "-" : "+";',
'         this.expanderTextNode = this.expander.appendChild(document.createTextNode(expanderText));',
'         ',
'         this.headingDiv.appendChild(document.createTextNode(" " + this.group.name));',
'',
'         this.contentDiv = this.mainDiv.appendChild(document.createElement("div"));',
'         var contentCssClass = this.group.expanded ? "expanded" : "collapsed";',
'         this.contentDiv.className = "groupcontent " + contentCssClass;',
'',
'         this.expander.onclick = function() {',
'           if (groupElementContainer.group.expandable) {',
'             groupElementContainer.group.toggleExpanded();',
'           }',
'         };',
'       }',
'     }',
'',
'     GroupElementContainer.prototype = new LogItemContainerElement();',
'',
'     copyProperties(GroupElementContainer.prototype, {',
'       toggleExpanded: function() {',
'         if (!this.isRoot) {',
'           var oldCssClass, newCssClass, expanderText;',
'           if (this.group.expanded) {',
'             newCssClass = "expanded";',
'             oldCssClass = "collapsed";',
'             expanderText = "-";',
'           } else {',
'             newCssClass = "collapsed";',
'             oldCssClass = "expanded";',
'             expanderText = "+";',
'           }',
'           replaceClass(this.contentDiv, newCssClass, oldCssClass);',
'           this.expanderTextNode.nodeValue = expanderText;',
'         }',
'       },',
'',
'       remove: function() {',
'         if (!this.isRoot) {',
'           this.headingDiv = null;',
'           this.expander.onclick = null;',
'           this.expander = null;',
'           this.expanderTextNode = null;',
'           this.contentDiv = null;',
'           this.containerDomNode = null;',
'           this.mainDiv.parentNode.removeChild(this.mainDiv);',
'           this.mainDiv = null;',
'         }',
'       },',
'',
'       reverseChildren: function() {',
'         // Invert the order of the log entries',
'         var node = null;',
'',
'         // Remove all the log container nodes',
'         var childDomNodes = [];',
'         while ((node = this.contentDiv.firstChild)) {',
'           this.contentDiv.removeChild(node);',
'           childDomNodes.push(node);',
'         }',
'',
'         // Put them all back in reverse order',
'         while ((node = childDomNodes.pop())) {',
'           this.contentDiv.appendChild(node);',
'         }',
'       },',
'',
'       update: function() {',
'         if (!this.isRoot) {',
'           if (this.group.expandable) {',
'             removeClass(this.expander, "greyedout");',
'           } else {',
'             addClass(this.expander, "greyedout");',
'           }',
'         }',
'       },',
'',
'       clear: function() {',
'         if (this.isRoot) {',
'           this.contentDiv.innerHTML = "";',
'         }',
'       }',
'     });',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function Group(name, isRoot, initiallyExpanded) {',
'       this.name = name;',
'       this.group = null;',
'       this.isRoot = isRoot;',
'       this.initiallyExpanded = initiallyExpanded;',
'       this.elementContainers = [];',
'       this.children = [];',
'       this.expanded = initiallyExpanded;',
'       this.rendered = false;',
'       this.expandable = false;',
'     }',
'',
'     Group.prototype = new LogItem();',
'',
'     copyProperties(Group.prototype, {',
'       addChild: function(logItem) {',
'         this.children.push(logItem);',
'         logItem.group = this;',
'       },',
'',
'       render: function() {',
'         if (isIe) {',
'           var unwrappedDomContainer, wrappedDomContainer;',
'           if (this.isRoot) {',
'             unwrappedDomContainer = logMainContainer;',
'             wrappedDomContainer = logMainContainer;',
'           } else {',
'             unwrappedDomContainer = this.getUnwrappedDomContainer();',
'             wrappedDomContainer = this.getWrappedDomContainer();',
'           }',
'           this.unwrappedElementContainer = new GroupElementContainer(this, unwrappedDomContainer, this.isRoot, false);',
'           this.wrappedElementContainer = new GroupElementContainer(this, wrappedDomContainer, this.isRoot, true);',
'           this.elementContainers = [this.unwrappedElementContainer, this.wrappedElementContainer];',
'         } else {',
'           var mainDomContainer = this.isRoot ? logMainContainer : this.getMainDomContainer();',
'           this.mainElementContainer = new GroupElementContainer(this, mainDomContainer, this.isRoot, false);',
'           this.elementContainers = [this.mainElementContainer];',
'         }',
'         this.rendered = true;',
'       },',
'',
'       toggleExpanded: function() {',
'         this.expanded = !this.expanded;',
'         for (var i = 0, len = this.elementContainers.length; i < len; i++) {',
'           this.elementContainers[i].toggleExpanded();',
'         }',
'       },',
'',
'       expand: function() {',
'         if (!this.expanded) {',
'           this.toggleExpanded();',
'         }',
'       },',
'',
'       accept: function(visitor) {',
'         visitor.visitGroup(this);',
'       },',
'',
'       reverseChildren: function() {',
'         if (this.rendered) {',
'           for (var i = 0, len = this.elementContainers.length; i < len; i++) {',
'             this.elementContainers[i].reverseChildren();',
'           }',
'         }',
'       },',
'',
'       update: function() {',
'         var previouslyExpandable = this.expandable;',
'         this.expandable = (this.children.length !== 0);',
'         if (this.expandable !== previouslyExpandable) {',
'           for (var i = 0, len = this.elementContainers.length; i < len; i++) {',
'             this.elementContainers[i].update();',
'           }',
'         }',
'       },',
'',
'       flatten: function() {',
'         var visitor = new GroupFlattener();',
'         this.accept(visitor);',
'         return visitor.logEntriesAndSeparators;',
'       },',
'',
'       removeChild: function(child, doUpdate) {',
'         array_remove(this.children, child);',
'         child.group = null;',
'         if (doUpdate) {',
'           this.update();',
'         }',
'       },',
'',
'       remove: function(doUpdate, removeFromGroup) {',
'         for (var i = 0, len = this.children.length; i < len; i++) {',
'           this.children[i].remove(false, false);',
'         }',
'         this.children = [];',
'         this.update();',
'         if (this === currentGroup) {',
'           currentGroup = this.group;',
'         }',
'         this.doRemove(doUpdate, removeFromGroup);',
'       },',
'',
'       serialize: function(items) {',
'         items.push([LogItem.serializedItemKeys.GROUP_START, this.name]);',
'         for (var i = 0, len = this.children.length; i < len; i++) {',
'           this.children[i].serialize(items);',
'         }',
'         if (this !== currentGroup) {',
'           items.push([LogItem.serializedItemKeys.GROUP_END]);',
'         }',
'       },',
'',
'       clear: function() {',
'         for (var i = 0, len = this.elementContainers.length; i < len; i++) {',
'           this.elementContainers[i].clear();',
'         }',
'       }',
'     });',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function LogEntryElementContainer() {',
'     }',
'',
'     LogEntryElementContainer.prototype = new LogItemContainerElement();',
'',
'     copyProperties(LogEntryElementContainer.prototype, {',
'       remove: function() {',
'         this.doRemove();',
'       },',
'',
'       doRemove: function() {',
'         this.mainDiv.parentNode.removeChild(this.mainDiv);',
'         this.mainDiv = null;',
'         this.contentElement = null;',
'         this.containerDomNode = null;',
'       },',
'',
'       setContent: function(content, wrappedContent) {',
'         if (content === this.formattedMessage) {',
'           this.contentElement.innerHTML = "";',
'           this.contentElement.appendChild(document.createTextNode(this.formattedMessage));',
'         } else {',
'           this.contentElement.innerHTML = content;',
'         }',
'       },',
'',
'       setSearchMatch: function(isMatch) {',
'         var oldCssClass = isMatch ? "searchnonmatch" : "searchmatch";',
'         var newCssClass = isMatch ? "searchmatch" : "searchnonmatch";',
'         replaceClass(this.mainDiv, newCssClass, oldCssClass);',
'       },',
'',
'       clearSearch: function() {',
'         removeClass(this.mainDiv, "searchmatch");',
'         removeClass(this.mainDiv, "searchnonmatch");',
'       }',
'     });',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function LogEntryWrappedElementContainer(logEntry, containerDomNode) {',
'       this.logEntry = logEntry;',
'       this.containerDomNode = containerDomNode;',
'       this.mainDiv = document.createElement("div");',
'       this.mainDiv.appendChild(document.createTextNode(this.logEntry.formattedMessage));',
'       this.mainDiv.className = "logentry wrapped " + this.logEntry.level;',
'       this.contentElement = this.mainDiv;',
'     }',
'',
'     LogEntryWrappedElementContainer.prototype = new LogEntryElementContainer();',
'',
'     LogEntryWrappedElementContainer.prototype.setContent = function(content, wrappedContent) {',
'       if (content === this.formattedMessage) {',
'         this.contentElement.innerHTML = "";',
'         this.contentElement.appendChild(document.createTextNode(this.formattedMessage));',
'       } else {',
'         this.contentElement.innerHTML = wrappedContent;',
'       }',
'     };',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function LogEntryUnwrappedElementContainer(logEntry, containerDomNode) {',
'       this.logEntry = logEntry;',
'       this.containerDomNode = containerDomNode;',
'       this.mainDiv = document.createElement("div");',
'       this.mainDiv.className = "logentry unwrapped " + this.logEntry.level;',
'       this.pre = this.mainDiv.appendChild(document.createElement("pre"));',
'       this.pre.appendChild(document.createTextNode(this.logEntry.formattedMessage));',
'       this.pre.className = "unwrapped";',
'       this.contentElement = this.pre;',
'     }',
'',
'     LogEntryUnwrappedElementContainer.prototype = new LogEntryElementContainer();',
'',
'     LogEntryUnwrappedElementContainer.prototype.remove = function() {',
'       this.doRemove();',
'       this.pre = null;',
'     };',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function LogEntryMainElementContainer(logEntry, containerDomNode) {',
'       this.logEntry = logEntry;',
'       this.containerDomNode = containerDomNode;',
'       this.mainDiv = document.createElement("div");',
'       this.mainDiv.className = "logentry nonielogentry " + this.logEntry.level;',
'       this.contentElement = this.mainDiv.appendChild(document.createElement("span"));',
'       this.contentElement.appendChild(document.createTextNode(this.logEntry.formattedMessage));',
'     }',
'',
'     LogEntryMainElementContainer.prototype = new LogEntryElementContainer();',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function LogEntry(level, formattedMessage) {',
'       this.level = level;',
'       this.formattedMessage = formattedMessage;',
'       this.rendered = false;',
'     }',
'',
'     LogEntry.prototype = new LogItem();',
'',
'     copyProperties(LogEntry.prototype, {',
'       render: function() {',
'         var logEntry = this;',
'         var containerDomNode = this.group.contentDiv;',
'',
'         // Support for the CSS attribute white-space in IE for Windows is',
'         // non-existent pre version 6 and slightly odd in 6, so instead',
'         // use two different HTML elements',
'         if (isIe) {',
'           this.formattedMessage = this.formattedMessage.replace(/\\r\\n/g, "\\r"); // Workaround for IE\'s treatment of white space',
'           this.unwrappedElementContainer = new LogEntryUnwrappedElementContainer(this, this.getUnwrappedDomContainer());',
'           this.wrappedElementContainer = new LogEntryWrappedElementContainer(this, this.getWrappedDomContainer());',
'           this.elementContainers = [this.unwrappedElementContainer, this.wrappedElementContainer];',
'         } else {',
'           this.mainElementContainer = new LogEntryMainElementContainer(this, this.getMainDomContainer());',
'           this.elementContainers = [this.mainElementContainer];',
'         }',
'         this.content = this.formattedMessage;',
'         this.rendered = true;',
'       },',
'',
'       setContent: function(content, wrappedContent) {',
'         if (content != this.content) {',
'           if (isIe && (content !== this.formattedMessage)) {',
'             content = content.replace(/\\r\\n/g, "\\r"); // Workaround for IE\'s treatment of white space',
'           }',
'           for (var i = 0, len = this.elementContainers.length; i < len; i++) {',
'             this.elementContainers[i].setContent(content, wrappedContent);',
'           }',
'           this.content = content;',
'         }',
'       },',
'',
'       getSearchMatches: function() {',
'         var matches = [];',
'         var i, len;',
'         if (isIe) {',
'           var unwrappedEls = getElementsByClass(this.unwrappedElementContainer.mainDiv, "searchterm", "span");',
'           var wrappedEls = getElementsByClass(this.wrappedElementContainer.mainDiv, "searchterm", "span");',
'           for (i = 0, len = unwrappedEls.length; i < len; i++) {',
'             matches[i] = new Match(this.level, null, unwrappedEls[i], wrappedEls[i]);',
'           }',
'         } else {',
'           var els = getElementsByClass(this.mainElementContainer.mainDiv, "searchterm", "span");',
'           for (i = 0, len = els.length; i < len; i++) {',
'             matches[i] = new Match(this.level, els[i]);',
'           }',
'         }',
'         return matches;',
'       },',
'',
'       setSearchMatch: function(isMatch) {',
'         for (var i = 0, len = this.elementContainers.length; i < len; i++) {',
'           this.elementContainers[i].setSearchMatch(isMatch);',
'         }',
'       },',
'',
'       clearSearch: function() {',
'         for (var i = 0, len = this.elementContainers.length; i < len; i++) {',
'           this.elementContainers[i].clearSearch();',
'         }',
'       },',
'',
'       accept: function(visitor) {',
'         visitor.visitLogEntry(this);',
'       },',
'',
'       serialize: function(items) {',
'         items.push([LogItem.serializedItemKeys.LOG_ENTRY, this.level, this.formattedMessage]);',
'       }',
'     });',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function LogItemVisitor() {',
'     }',
'',
'     LogItemVisitor.prototype = {',
'       visit: function(logItem) {',
'       },',
'',
'       visitParent: function(logItem) {',
'         if (logItem.group) {',
'           logItem.group.accept(this);',
'         }',
'       },',
'',
'       visitChildren: function(logItem) {',
'         for (var i = 0, len = logItem.children.length; i < len; i++) {',
'           logItem.children[i].accept(this);',
'         }',
'       },',
'',
'       visitLogEntry: function(logEntry) {',
'         this.visit(logEntry);',
'       },',
'',
'       visitSeparator: function(separator) {',
'         this.visit(separator);',
'       },',
'',
'       visitGroup: function(group) {',
'         this.visit(group);',
'       }',
'     };',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function GroupFlattener() {',
'       this.logEntriesAndSeparators = [];',
'     }',
'',
'     GroupFlattener.prototype = new LogItemVisitor();',
'',
'     GroupFlattener.prototype.visitGroup = function(group) {',
'       this.visitChildren(group);',
'     };',
'',
'     GroupFlattener.prototype.visitLogEntry = function(logEntry) {',
'       this.logEntriesAndSeparators.push(logEntry);',
'     };',
'',
'     GroupFlattener.prototype.visitSeparator = function(separator) {',
'       this.logEntriesAndSeparators.push(separator);',
'     };',
'',
'     /*----------------------------------------------------------------*/',
'',
'     window.onload = function() {',
'       // Sort out document.domain',
'       if (location.search) {',
'         var queryBits = unescape(location.search).substr(1).split("&"), nameValueBits;',
'         for (var i = 0, len = queryBits.length; i < len; i++) {',
'           nameValueBits = queryBits[i].split("=");',
'           if (nameValueBits[0] == "log4javascript_domain") {',
'             document.domain = nameValueBits[1];',
'             break;',
'           }',
'         }',
'       }',
'',
'       // Create DOM objects',
'       logMainContainer = $("log");',
'       if (isIePre7) {',
'         addClass(logMainContainer, "oldIe");',
'       }',
'',
'       rootGroup = new Group("root", true);',
'       rootGroup.render();',
'       currentGroup = rootGroup;',
'       ',
'       setCommandInputWidth();',
'       setLogContainerHeight();',
'       toggleLoggingEnabled();',
'       toggleSearchEnabled();',
'       toggleSearchFilter();',
'       toggleSearchHighlight();',
'       applyFilters();',
'       checkAllLevels();',
'       toggleWrap();',
'       toggleNewestAtTop();',
'       toggleScrollToLatest();',
'       renderQueuedLogItems();',
'       loaded = true;',
'       $("command").value = "";',
'       $("command").autocomplete = "off";',
'       $("command").onkeydown = function(evt) {',
'         evt = getEvent(evt);',
'         if (evt.keyCode == 10 || evt.keyCode == 13) { // Return/Enter',
'           evalCommandLine();',
'           stopPropagation(evt);',
'         } else if (evt.keyCode == 27) { // Escape',
'           this.value = "";',
'           this.focus();',
'         } else if (evt.keyCode == 38 && commandHistory.length > 0) { // Up',
'           currentCommandIndex = Math.max(0, currentCommandIndex - 1);',
'           this.value = commandHistory[currentCommandIndex];',
'           moveCaretToEnd(this);',
'         } else if (evt.keyCode == 40 && commandHistory.length > 0) { // Down',
'           currentCommandIndex = Math.min(commandHistory.length - 1, currentCommandIndex + 1);',
'           this.value = commandHistory[currentCommandIndex];',
'           moveCaretToEnd(this);',
'         }',
'       };',
'',
'       // Prevent the keypress moving the caret in Firefox',
'       $("command").onkeypress = function(evt) {',
'         evt = getEvent(evt);',
'         if (evt.keyCode == 38 && commandHistory.length > 0 && evt.preventDefault) { // Up',
'           evt.preventDefault();',
'         }',
'       };',
'',
'       // Prevent the keyup event blurring the input in Opera',
'       $("command").onkeyup = function(evt) {',
'         evt = getEvent(evt);',
'         if (evt.keyCode == 27 && evt.preventDefault) { // Up',
'           evt.preventDefault();',
'           this.focus();',
'         }',
'       };',
'',
'       // Add document keyboard shortcuts',
'       document.onkeydown = function keyEventHandler(evt) {',
'         evt = getEvent(evt);',
'         switch (evt.keyCode) {',
'           case 69: // Ctrl + shift + E: re-execute last command',
'             if (evt.shiftKey && (evt.ctrlKey || evt.metaKey)) {',
'               evalLastCommand();',
'               cancelKeyEvent(evt);',
'               return false;',
'             }',
'             break;',
'           case 75: // Ctrl + shift + K: focus search',
'             if (evt.shiftKey && (evt.ctrlKey || evt.metaKey)) {',
'               focusSearch();',
'               cancelKeyEvent(evt);',
'               return false;',
'             }',
'             break;',
'           case 40: // Ctrl + shift + down arrow: focus command line',
'           case 76: // Ctrl + shift + L: focus command line',
'             if (evt.shiftKey && (evt.ctrlKey || evt.metaKey)) {',
'               focusCommandLine();',
'               cancelKeyEvent(evt);',
'               return false;',
'             }',
'             break;',
'         }',
'       };',
'',
'       // Workaround to make sure log div starts at the correct size',
'       setTimeout(setLogContainerHeight, 20);',
'',
'       setShowCommandLine(showCommandLine);',
'       doSearch();',
'     };',
'',
'     window.onunload = function() {',
'       if (mainWindowExists()) {',
'         appender.unload();',
'       }',
'       appender = null;',
'     };',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function toggleLoggingEnabled() {',
'       setLoggingEnabled($("enableLogging").checked);',
'     }',
'',
'     function setLoggingEnabled(enable) {',
'       loggingEnabled = enable;',
'     }',
'',
'     var appender = null;',
'',
'     function setAppender(appenderParam) {',
'       appender = appenderParam;',
'     }',
'',
'     function setShowCloseButton(showCloseButton) {',
'       $("closeButton").style.display = showCloseButton ? "inline" : "none";',
'     }',
'',
'     function setShowHideButton(showHideButton) {',
'       $("hideButton").style.display = showHideButton ? "inline" : "none";',
'     }',
'',
'     var newestAtTop = false;',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function LogItemContentReverser() {',
'     }',
'     ',
'     LogItemContentReverser.prototype = new LogItemVisitor();',
'     ',
'     LogItemContentReverser.prototype.visitGroup = function(group) {',
'       group.reverseChildren();',
'       this.visitChildren(group);',
'     };',
'',
'     /*----------------------------------------------------------------*/',
'',
'     function setNewestAtTop(isNewestAtTop) {',
'       var oldNewestAtTop = newestAtTop;',
'       var i, iLen, j, jLen;',
'       newestAtTop = Boolean(isNewestAtTop);',
'       if (oldNewestAtTop != newestAtTop) {',
'         var visitor = new LogItemContentReverser();',
'         rootGroup.accept(visitor);',
'',
'         // Reassemble the matches array',
'         if (currentSearch) {',
'           var currentMatch = currentSearch.matches[currentMatchIndex];',
'           var matchIndex = 0;',
'           var matches = [];',
'           var actOnLogEntry = function(logEntry) {',
'             var logEntryMatches = logEntry.getSearchMatches();',
'             for (j = 0, jLen = logEntryMatches.length; j < jLen; j++) {',
'               matches[matchIndex] = logEntryMatches[j];',
'               if (currentMatch && logEntryMatches[j].equals(currentMatch)) {',
'                 currentMatchIndex = matchIndex;',
'               }',
'               matchIndex++;',
'             }',
'           };',
'           if (newestAtTop) {',
'             for (i = logEntries.length - 1; i >= 0; i--) {',
'               actOnLogEntry(logEntries[i]);',
'             }',
'           } else {',
'             for (i = 0, iLen = logEntries.length; i < iLen; i++) {',
'               actOnLogEntry(logEntries[i]);',
'             }',
'           }',
'           currentSearch.matches = matches;',
'           if (currentMatch) {',
'             currentMatch.setCurrent();',
'           }',
'         } else if (scrollToLatest) {',
'           doScrollToLatest();',
'         }',
'       }',
'       $("newestAtTop").checked = isNewestAtTop;',
'     }',
'',
'     function toggleNewestAtTop() {',
'       var isNewestAtTop = $("newestAtTop").checked;',
'       setNewestAtTop(isNewestAtTop);',
'     }',
'',
'     var scrollToLatest = true;',
'',
'     function setScrollToLatest(isScrollToLatest) {',
'       scrollToLatest = isScrollToLatest;',
'       if (scrollToLatest) {',
'         doScrollToLatest();',
'       }',
'       $("scrollToLatest").checked = isScrollToLatest;',
'     }',
'',
'     function toggleScrollToLatest() {',
'       var isScrollToLatest = $("scrollToLatest").checked;',
'       setScrollToLatest(isScrollToLatest);',
'     }',
'',
'     function doScrollToLatest() {',
'       var l = logMainContainer;',
'       if (typeof l.scrollTop != "undefined") {',
'         if (newestAtTop) {',
'           l.scrollTop = 0;',
'         } else {',
'           var latestLogEntry = l.lastChild;',
'           if (latestLogEntry) {',
'             l.scrollTop = l.scrollHeight;',
'           }',
'         }',
'       }',
'     }',
'',
'     var closeIfOpenerCloses = true;',
'',
'     function setCloseIfOpenerCloses(isCloseIfOpenerCloses) {',
'       closeIfOpenerCloses = isCloseIfOpenerCloses;',
'     }',
'',
'     var maxMessages = null;',
'',
'     function setMaxMessages(max) {',
'       maxMessages = max;',
'       pruneLogEntries();',
'     }',
'',
'     var showCommandLine = false;',
'',
'     function setShowCommandLine(isShowCommandLine) {',
'       showCommandLine = isShowCommandLine;',
'       if (loaded) {',
'         $("commandLine").style.display = showCommandLine ? "block" : "none";',
'         setCommandInputWidth();',
'         setLogContainerHeight();',
'       }',
'     }',
'',
'     function focusCommandLine() {',
'       if (loaded) {',
'         $("command").focus();',
'       }',
'     }',
'',
'     function focusSearch() {',
'       if (loaded) {',
'         $("searchBox").focus();',
'       }',
'     }',
'',
'     function getLogItems() {',
'       var items = [];',
'       for (var i = 0, len = logItems.length; i < len; i++) {',
'         logItems[i].serialize(items);',
'       }',
'       return items;',
'     }',
'',
'     function setLogItems(items) {',
'       var loggingReallyEnabled = loggingEnabled;',
'       // Temporarily turn logging on',
'       loggingEnabled = true;',
'       for (var i = 0, len = items.length; i < len; i++) {',
'         switch (items[i][0]) {',
'           case LogItem.serializedItemKeys.LOG_ENTRY:',
'             log(items[i][1], items[i][2]);',
'             break;',
'           case LogItem.serializedItemKeys.GROUP_START:',
'             group(items[i][1]);',
'             break;',
'           case LogItem.serializedItemKeys.GROUP_END:',
'             groupEnd();',
'             break;',
'         }',
'       }',
'       loggingEnabled = loggingReallyEnabled;',
'     }',
'',
'     function log(logLevel, formattedMessage) {',
'       if (loggingEnabled) {',
'         var logEntry = new LogEntry(logLevel, formattedMessage);',
'         logEntries.push(logEntry);',
'         logEntriesAndSeparators.push(logEntry);',
'         logItems.push(logEntry);',
'         currentGroup.addChild(logEntry);',
'         if (loaded) {',
'           if (logQueuedEventsTimer !== null) {',
'             clearTimeout(logQueuedEventsTimer);',
'           }',
'           logQueuedEventsTimer = setTimeout(renderQueuedLogItems, renderDelay);',
'           unrenderedLogItemsExist = true;',
'         }',
'       }',
'     }',
'',
'     function renderQueuedLogItems() {',
'       logQueuedEventsTimer = null;',
'       var pruned = pruneLogEntries();',
'',
'       // Render any unrendered log entries and apply the current search to them',
'       var initiallyHasMatches = currentSearch ? currentSearch.hasMatches() : false;',
'       for (var i = 0, len = logItems.length; i < len; i++) {',
'         if (!logItems[i].rendered) {',
'           logItems[i].render();',
'           logItems[i].appendToLog();',
'           if (currentSearch && (logItems[i] instanceof LogEntry)) {',
'             currentSearch.applyTo(logItems[i]);',
'           }',
'         }',
'       }',
'       if (currentSearch) {',
'         if (pruned) {',
'           if (currentSearch.hasVisibleMatches()) {',
'             if (currentMatchIndex === null) {',
'               setCurrentMatchIndex(0);',
'             }',
'             displayMatches();',
'           } else {',
'             displayNoMatches();',
'           }',
'         } else if (!initiallyHasMatches && currentSearch.hasVisibleMatches()) {',
'           setCurrentMatchIndex(0);',
'           displayMatches();',
'         }',
'       }',
'       if (scrollToLatest) {',
'         doScrollToLatest();',
'       }',
'       unrenderedLogItemsExist = false;',
'     }',
'',
'     function pruneLogEntries() {',
'       if ((maxMessages !== null) && (logEntriesAndSeparators.length > maxMessages)) {',
'         var numberToDelete = logEntriesAndSeparators.length - maxMessages;',
'         var prunedLogEntries = logEntriesAndSeparators.slice(0, numberToDelete);',
'         if (currentSearch) {',
'           currentSearch.removeMatches(prunedLogEntries);',
'         }',
'         var group;',
'         for (var i = 0; i < numberToDelete; i++) {',
'           group = logEntriesAndSeparators[i].group;',
'           array_remove(logItems, logEntriesAndSeparators[i]);',
'           array_remove(logEntries, logEntriesAndSeparators[i]);',
'           logEntriesAndSeparators[i].remove(true, true);',
'           if (group.children.length === 0 && group !== currentGroup && group !== rootGroup) {',
'             array_remove(logItems, group);',
'             group.remove(true, true);',
'           }',
'         }',
'         logEntriesAndSeparators = array_removeFromStart(logEntriesAndSeparators, numberToDelete);',
'         return true;',
'       }',
'       return false;',
'     }',
'',
'     function group(name, startExpanded) {',
'       if (loggingEnabled) {',
'         initiallyExpanded = (typeof startExpanded === "undefined") ? true : Boolean(startExpanded);',
'         var newGroup = new Group(name, false, initiallyExpanded);',
'         currentGroup.addChild(newGroup);',
'         currentGroup = newGroup;',
'         logItems.push(newGroup);',
'         if (loaded) {',
'           if (logQueuedEventsTimer !== null) {',
'             clearTimeout(logQueuedEventsTimer);',
'           }',
'           logQueuedEventsTimer = setTimeout(renderQueuedLogItems, renderDelay);',
'           unrenderedLogItemsExist = true;',
'         }',
'       }',
'     }',
'',
'     function groupEnd() {',
'       currentGroup = (currentGroup === rootGroup) ? rootGroup : currentGroup.group;',
'     }',
'',
'     function mainPageReloaded() {',
'       currentGroup = rootGroup;',
'       var separator = new Separator();',
'       logEntriesAndSeparators.push(separator);',
'       logItems.push(separator);',
'       currentGroup.addChild(separator);',
'     }',
'',
'     function closeWindow() {',
'       if (appender && mainWindowExists()) {',
'         appender.close(true);',
'       } else {',
'         window.close();',
'       }',
'     }',
'',
'     function hide() {',
'       if (appender && mainWindowExists()) {',
'         appender.hide();',
'       }',
'     }',
'',
'     var mainWindow = window;',
'     var windowId = "log4javascriptConsoleWindow_" + new Date().getTime() + "_" + ("" + Math.random()).substr(2);',
'',
'     function setMainWindow(win) {',
'       mainWindow = win;',
'       mainWindow[windowId] = window;',
'       // If this is a pop-up, poll the opener to see if it\'s closed',
'       if (opener && closeIfOpenerCloses) {',
'         pollOpener();',
'       }',
'     }',
'',
'     function pollOpener() {',
'       if (closeIfOpenerCloses) {',
'         if (mainWindowExists()) {',
'           setTimeout(pollOpener, 500);',
'         } else {',
'           closeWindow();',
'         }',
'       }',
'     }',
'',
'     function mainWindowExists() {',
'       try {',
'         return (mainWindow && !mainWindow.closed &&',
'           mainWindow[windowId] == window);',
'       } catch (ex) {}',
'       return false;',
'     }',
'',
'     var logLevels = ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "FATAL"];',
'',
'     function getCheckBox(logLevel) {',
'       return $("switch_" + logLevel);',
'     }',
'',
'     function getIeWrappedLogContainer() {',
'       return $("log_wrapped");',
'     }',
'',
'     function getIeUnwrappedLogContainer() {',
'       return $("log_unwrapped");',
'     }',
'',
'     function applyFilters() {',
'       for (var i = 0; i < logLevels.length; i++) {',
'         if (getCheckBox(logLevels[i]).checked) {',
'           addClass(logMainContainer, logLevels[i]);',
'         } else {',
'           removeClass(logMainContainer, logLevels[i]);',
'         }',
'       }',
'       updateSearchFromFilters();',
'     }',
'',
'     function toggleAllLevels() {',
'       var turnOn = $("switch_ALL").checked;',
'       for (var i = 0; i < logLevels.length; i++) {',
'         getCheckBox(logLevels[i]).checked = turnOn;',
'         if (turnOn) {',
'           addClass(logMainContainer, logLevels[i]);',
'         } else {',
'           removeClass(logMainContainer, logLevels[i]);',
'         }',
'       }',
'     }',
'',
'     function checkAllLevels() {',
'       for (var i = 0; i < logLevels.length; i++) {',
'         if (!getCheckBox(logLevels[i]).checked) {',
'           getCheckBox("ALL").checked = false;',
'           return;',
'         }',
'       }',
'       getCheckBox("ALL").checked = true;',
'     }',
'',
'     function clearLog() {',
'       rootGroup.clear();',
'       currentGroup = rootGroup;',
'       logEntries = [];',
'       logItems = [];',
'       logEntriesAndSeparators = [];',
'         doSearch();',
'     }',
'',
'     function toggleWrap() {',
'       var enable = $("wrap").checked;',
'       if (enable) {',
'         addClass(logMainContainer, "wrap");',
'       } else {',
'         removeClass(logMainContainer, "wrap");',
'       }',
'       refreshCurrentMatch();',
'     }',
'',
'     /* ------------------------------------------------------------------- */',
'',
'     // Search',
'',
'     var searchTimer = null;',
'',
'     function scheduleSearch() {',
'       try {',
'         clearTimeout(searchTimer);',
'       } catch (ex) {',
'         // Do nothing',
'       }',
'       searchTimer = setTimeout(doSearch, 500);',
'     }',
'',
'     function Search(searchTerm, isRegex, searchRegex, isCaseSensitive) {',
'       this.searchTerm = searchTerm;',
'       this.isRegex = isRegex;',
'       this.searchRegex = searchRegex;',
'       this.isCaseSensitive = isCaseSensitive;',
'       this.matches = [];',
'     }',
'',
'     Search.prototype = {',
'       hasMatches: function() {',
'         return this.matches.length > 0;',
'       },',
'',
'       hasVisibleMatches: function() {',
'         if (this.hasMatches()) {',
'           for (var i = 0; i < this.matches.length; i++) {',
'             if (this.matches[i].isVisible()) {',
'               return true;',
'             }',
'           }',
'         }',
'         return false;',
'       },',
'',
'       match: function(logEntry) {',
'         var entryText = String(logEntry.formattedMessage);',
'         var matchesSearch = false;',
'         if (this.isRegex) {',
'           matchesSearch = this.searchRegex.test(entryText);',
'         } else if (this.isCaseSensitive) {',
'           matchesSearch = (entryText.indexOf(this.searchTerm) > -1);',
'         } else {',
'           matchesSearch = (entryText.toLowerCase().indexOf(this.searchTerm.toLowerCase()) > -1);',
'         }',
'         return matchesSearch;',
'       },',
'',
'       getNextVisibleMatchIndex: function() {',
'         for (var i = currentMatchIndex + 1; i < this.matches.length; i++) {',
'           if (this.matches[i].isVisible()) {',
'             return i;',
'           }',
'         }',
'         // Start again from the first match',
'         for (i = 0; i <= currentMatchIndex; i++) {',
'           if (this.matches[i].isVisible()) {',
'             return i;',
'           }',
'         }',
'         return -1;',
'       },',
'',
'       getPreviousVisibleMatchIndex: function() {',
'         for (var i = currentMatchIndex - 1; i >= 0; i--) {',
'           if (this.matches[i].isVisible()) {',
'             return i;',
'           }',
'         }',
'         // Start again from the last match',
'         for (var i = this.matches.length - 1; i >= currentMatchIndex; i--) {',
'           if (this.matches[i].isVisible()) {',
'             return i;',
'           }',
'         }',
'         return -1;',
'       },',
'',
'       applyTo: function(logEntry) {',
'         var doesMatch = this.match(logEntry);',
'         if (doesMatch) {',
'           logEntry.group.expand();',
'           logEntry.setSearchMatch(true);',
'           var logEntryContent;',
'           var wrappedLogEntryContent;',
'           var searchTermReplacementStartTag = "<span class=\\\"searchterm\\\">";',
'           var searchTermReplacementEndTag = "<" + "/span>";',
'           var preTagName = isIe ? "pre" : "span";',
'           var preStartTag = "<" + preTagName + " class=\\\"pre\\\">";',
'           var preEndTag = "<" + "/" + preTagName + ">";',
'           var startIndex = 0;',
'           var searchIndex, matchedText, textBeforeMatch;',
'           if (this.isRegex) {',
'             var flags = this.isCaseSensitive ? "g" : "gi";',
'             var capturingRegex = new RegExp("(" + this.searchRegex.source + ")", flags);',
'',
'             // Replace the search term with temporary tokens for the start and end tags',
'             var rnd = ("" + Math.random()).substr(2);',
'             var startToken = "%%s" + rnd + "%%";',
'             var endToken = "%%e" + rnd + "%%";',
'             logEntryContent = logEntry.formattedMessage.replace(capturingRegex, startToken + "$1" + endToken);',
'',
'             // Escape the HTML to get rid of angle brackets',
'             logEntryContent = escapeHtml(logEntryContent);',
'',
'             // Substitute the proper HTML back in for the search match',
'             var result;',
'             var searchString = logEntryContent;',
'             logEntryContent = "";',
'             wrappedLogEntryContent = "";',
'             while ((searchIndex = searchString.indexOf(startToken, startIndex)) > -1) {',
'               var endTokenIndex = searchString.indexOf(endToken, searchIndex);',
'               matchedText = searchString.substring(searchIndex + startToken.length, endTokenIndex);',
'               textBeforeMatch = searchString.substring(startIndex, searchIndex);',
'               logEntryContent += preStartTag + textBeforeMatch + preEndTag;',
'               logEntryContent += searchTermReplacementStartTag + preStartTag + matchedText +',
'                 preEndTag + searchTermReplacementEndTag;',
'               if (isIe) {',
'                 wrappedLogEntryContent += textBeforeMatch + searchTermReplacementStartTag +',
'                   matchedText + searchTermReplacementEndTag;',
'               }',
'               startIndex = endTokenIndex + endToken.length;',
'             }',
'             logEntryContent += preStartTag + searchString.substr(startIndex) + preEndTag;',
'             if (isIe) {',
'               wrappedLogEntryContent += searchString.substr(startIndex);',
'             }',
'           } else {',
'             logEntryContent = "";',
'             wrappedLogEntryContent = "";',
'             var searchTermReplacementLength = searchTermReplacementStartTag.length +',
'               this.searchTerm.length + searchTermReplacementEndTag.length;',
'             var searchTermLength = this.searchTerm.length;',
'             var searchTermLowerCase = this.searchTerm.toLowerCase();',
'             var logTextLowerCase = logEntry.formattedMessage.toLowerCase();',
'             while ((searchIndex = logTextLowerCase.indexOf(searchTermLowerCase, startIndex)) > -1) {',
'               matchedText = escapeHtml(logEntry.formattedMessage.substr(searchIndex, this.searchTerm.length));',
'               textBeforeMatch = escapeHtml(logEntry.formattedMessage.substring(startIndex, searchIndex));',
'               var searchTermReplacement = searchTermReplacementStartTag +',
'                 preStartTag + matchedText + preEndTag + searchTermReplacementEndTag;',
'               logEntryContent += preStartTag + textBeforeMatch + preEndTag + searchTermReplacement;',
'               if (isIe) {',
'                 wrappedLogEntryContent += textBeforeMatch + searchTermReplacementStartTag +',
'                   matchedText + searchTermReplacementEndTag;',
'               }',
'               startIndex = searchIndex + searchTermLength;',
'             }',
'             var textAfterLastMatch = escapeHtml(logEntry.formattedMessage.substr(startIndex));',
'             logEntryContent += preStartTag + textAfterLastMatch + preEndTag;',
'             if (isIe) {',
'               wrappedLogEntryContent += textAfterLastMatch;',
'             }',
'           }',
'           logEntry.setContent(logEntryContent, wrappedLogEntryContent);',
'           var logEntryMatches = logEntry.getSearchMatches();',
'           this.matches = this.matches.concat(logEntryMatches);',
'         } else {',
'           logEntry.setSearchMatch(false);',
'           logEntry.setContent(logEntry.formattedMessage, logEntry.formattedMessage);',
'         }',
'         return doesMatch;',
'       },',
'',
'       removeMatches: function(logEntries) {',
'         var matchesToRemoveCount = 0;',
'         var currentMatchRemoved = false;',
'         var matchesToRemove = [];',
'         var i, iLen, j, jLen;',
'',
'         // Establish the list of matches to be removed',
'         for (i = 0, iLen = this.matches.length; i < iLen; i++) {',
'           for (j = 0, jLen = logEntries.length; j < jLen; j++) {',
'             if (this.matches[i].belongsTo(logEntries[j])) {',
'               matchesToRemove.push(this.matches[i]);',
'               if (i === currentMatchIndex) {',
'                 currentMatchRemoved = true;',
'               }',
'             }',
'           }',
'         }',
'',
'         // Set the new current match index if the current match has been deleted',
'         // This will be the first match that appears after the first log entry being',
'         // deleted, if one exists; otherwise, it\'s the first match overall',
'         var newMatch = currentMatchRemoved ? null : this.matches[currentMatchIndex];',
'         if (currentMatchRemoved) {',
'           for (i = currentMatchIndex, iLen = this.matches.length; i < iLen; i++) {',
'             if (this.matches[i].isVisible() && !array_contains(matchesToRemove, this.matches[i])) {',
'               newMatch = this.matches[i];',
'               break;',
'             }',
'           }',
'         }',
'',
'         // Remove the matches',
'         for (i = 0, iLen = matchesToRemove.length; i < iLen; i++) {',
'           array_remove(this.matches, matchesToRemove[i]);',
'           matchesToRemove[i].remove();',
'         }',
'',
'         // Set the new match, if one exists',
'         if (this.hasVisibleMatches()) {',
'           if (newMatch === null) {',
'             setCurrentMatchIndex(0);',
'           } else {',
'             // Get the index of the new match',
'             var newMatchIndex = 0;',
'             for (i = 0, iLen = this.matches.length; i < iLen; i++) {',
'               if (newMatch === this.matches[i]) {',
'                 newMatchIndex = i;',
'                 break;',
'               }',
'             }',
'             setCurrentMatchIndex(newMatchIndex);',
'           }',
'         } else {',
'           currentMatchIndex = null;',
'           displayNoMatches();',
'         }',
'       }',
'     };',
'',
'     function getPageOffsetTop(el, container) {',
'       var currentEl = el;',
'       var y = 0;',
'       while (currentEl && currentEl != container) {',
'         y += currentEl.offsetTop;',
'         currentEl = currentEl.offsetParent;',
'       }',
'       return y;',
'     }',
'',
'     function scrollIntoView(el) {',
'       var logContainer = logMainContainer;',
'       // Check if the whole width of the element is visible and centre if not',
'       if (!$("wrap").checked) {',
'         var logContainerLeft = logContainer.scrollLeft;',
'         var logContainerRight = logContainerLeft  + logContainer.offsetWidth;',
'         var elLeft = el.offsetLeft;',
'         var elRight = elLeft + el.offsetWidth;',
'         if (elLeft < logContainerLeft || elRight > logContainerRight) {',
'           logContainer.scrollLeft = elLeft - (logContainer.offsetWidth - el.offsetWidth) / 2;',
'         }',
'       }',
'       // Check if the whole height of the element is visible and centre if not',
'       var logContainerTop = logContainer.scrollTop;',
'       var logContainerBottom = logContainerTop  + logContainer.offsetHeight;',
'       var elTop = getPageOffsetTop(el) - getToolBarsHeight();',
'       var elBottom = elTop + el.offsetHeight;',
'       if (elTop < logContainerTop || elBottom > logContainerBottom) {',
'         logContainer.scrollTop = elTop - (logContainer.offsetHeight - el.offsetHeight) / 2;',
'       }',
'     }',
'',
'     function Match(logEntryLevel, spanInMainDiv, spanInUnwrappedPre, spanInWrappedDiv) {',
'       this.logEntryLevel = logEntryLevel;',
'       this.spanInMainDiv = spanInMainDiv;',
'       if (isIe) {',
'         this.spanInUnwrappedPre = spanInUnwrappedPre;',
'         this.spanInWrappedDiv = spanInWrappedDiv;',
'       }',
'       this.mainSpan = isIe ? spanInUnwrappedPre : spanInMainDiv;',
'     }',
'',
'     Match.prototype = {',
'       equals: function(match) {',
'         return this.mainSpan === match.mainSpan;',
'       },',
'',
'       setCurrent: function() {',
'         if (isIe) {',
'           addClass(this.spanInUnwrappedPre, "currentmatch");',
'           addClass(this.spanInWrappedDiv, "currentmatch");',
'           // Scroll the visible one into view',
'           var elementToScroll = $("wrap").checked ? this.spanInWrappedDiv : this.spanInUnwrappedPre;',
'           scrollIntoView(elementToScroll);',
'         } else {',
'           addClass(this.spanInMainDiv, "currentmatch");',
'           scrollIntoView(this.spanInMainDiv);',
'         }',
'       },',
'',
'       belongsTo: function(logEntry) {',
'         if (isIe) {',
'           return isDescendant(this.spanInUnwrappedPre, logEntry.unwrappedPre);',
'         } else {',
'           return isDescendant(this.spanInMainDiv, logEntry.mainDiv);',
'         }',
'       },',
'',
'       setNotCurrent: function() {',
'         if (isIe) {',
'           removeClass(this.spanInUnwrappedPre, "currentmatch");',
'           removeClass(this.spanInWrappedDiv, "currentmatch");',
'         } else {',
'           removeClass(this.spanInMainDiv, "currentmatch");',
'         }',
'       },',
'',
'       isOrphan: function() {',
'         return isOrphan(this.mainSpan);',
'       },',
'',
'       isVisible: function() {',
'         return getCheckBox(this.logEntryLevel).checked;',
'       },',
'',
'       remove: function() {',
'         if (isIe) {',
'           this.spanInUnwrappedPre = null;',
'           this.spanInWrappedDiv = null;',
'         } else {',
'           this.spanInMainDiv = null;',
'         }',
'       }',
'     };',
'',
'     var currentSearch = null;',
'     var currentMatchIndex = null;',
'',
'     function doSearch() {',
'       var searchBox = $("searchBox");',
'       var searchTerm = searchBox.value;',
'       var isRegex = $("searchRegex").checked;',
'       var isCaseSensitive = $("searchCaseSensitive").checked;',
'       var i;',
'',
'       if (searchTerm === "") {',
'         $("searchReset").disabled = true;',
'         $("searchNav").style.display = "none";',
'         removeClass(document.body, "searching");',
'         removeClass(searchBox, "hasmatches");',
'         removeClass(searchBox, "nomatches");',
'         for (i = 0; i < logEntries.length; i++) {',
'           logEntries[i].clearSearch();',
'           logEntries[i].setContent(logEntries[i].formattedMessage, logEntries[i].formattedMessage);',
'         }',
'         currentSearch = null;',
'         setLogContainerHeight();',
'       } else {',
'         $("searchReset").disabled = false;',
'         $("searchNav").style.display = "block";',
'         var searchRegex;',
'         var regexValid;',
'         if (isRegex) {',
'           try {',
'             searchRegex = isCaseSensitive ? new RegExp(searchTerm, "g") : new RegExp(searchTerm, "gi");',
'             regexValid = true;',
'             replaceClass(searchBox, "validregex", "invalidregex");',
'             searchBox.title = "Valid regex";',
'           } catch (ex) {',
'             regexValid = false;',
'             replaceClass(searchBox, "invalidregex", "validregex");',
'             searchBox.title = "Invalid regex: " + (ex.message ? ex.message : (ex.description ? ex.description : "unknown error"));',
'             return;',
'           }',
'         } else {',
'           searchBox.title = "";',
'           removeClass(searchBox, "validregex");',
'           removeClass(searchBox, "invalidregex");',
'         }',
'         addClass(document.body, "searching");',
'         currentSearch = new Search(searchTerm, isRegex, searchRegex, isCaseSensitive);',
'         for (i = 0; i < logEntries.length; i++) {',
'           currentSearch.applyTo(logEntries[i]);',
'         }',
'         setLogContainerHeight();',
'',
'         // Highlight the first search match',
'         if (currentSearch.hasVisibleMatches()) {',
'           setCurrentMatchIndex(0);',
'           displayMatches();',
'         } else {',
'           displayNoMatches();',
'         }',
'       }',
'     }',
'',
'     function updateSearchFromFilters() {',
'       if (currentSearch) {',
'         if (currentSearch.hasMatches()) {',
'           if (currentMatchIndex === null) {',
'             currentMatchIndex = 0;',
'           }',
'           var currentMatch = currentSearch.matches[currentMatchIndex];',
'           if (currentMatch.isVisible()) {',
'             displayMatches();',
'             setCurrentMatchIndex(currentMatchIndex);',
'           } else {',
'             currentMatch.setNotCurrent();',
'             // Find the next visible match, if one exists',
'             var nextVisibleMatchIndex = currentSearch.getNextVisibleMatchIndex();',
'             if (nextVisibleMatchIndex > -1) {',
'               setCurrentMatchIndex(nextVisibleMatchIndex);',
'               displayMatches();',
'             } else {',
'               displayNoMatches();',
'             }',
'           }',
'         } else {',
'           displayNoMatches();',
'         }',
'       }',
'     }',
'',
'     function refreshCurrentMatch() {',
'       if (currentSearch && currentSearch.hasVisibleMatches()) {',
'         setCurrentMatchIndex(currentMatchIndex);',
'       }',
'     }',
'',
'     function displayMatches() {',
'       replaceClass($("searchBox"), "hasmatches", "nomatches");',
'       $("searchBox").title = "" + currentSearch.matches.length + " matches found";',
'       $("searchNav").style.display = "block";',
'       setLogContainerHeight();',
'     }',
'',
'     function displayNoMatches() {',
'       replaceClass($("searchBox"), "nomatches", "hasmatches");',
'       $("searchBox").title = "No matches found";',
'       $("searchNav").style.display = "none";',
'       setLogContainerHeight();',
'     }',
'',
'     function toggleSearchEnabled(enable) {',
'       enable = (typeof enable == "undefined") ? !$("searchDisable").checked : enable;',
'       $("searchBox").disabled = !enable;',
'       $("searchReset").disabled = !enable;',
'       $("searchRegex").disabled = !enable;',
'       $("searchNext").disabled = !enable;',
'       $("searchPrevious").disabled = !enable;',
'       $("searchCaseSensitive").disabled = !enable;',
'       $("searchNav").style.display = (enable && ($("searchBox").value !== "") &&',
'           currentSearch && currentSearch.hasVisibleMatches()) ?',
'         "block" : "none";',
'       if (enable) {',
'         removeClass($("search"), "greyedout");',
'         addClass(document.body, "searching");',
'         if ($("searchHighlight").checked) {',
'           addClass(logMainContainer, "searchhighlight");',
'         } else {',
'           removeClass(logMainContainer, "searchhighlight");',
'         }',
'         if ($("searchFilter").checked) {',
'           addClass(logMainContainer, "searchfilter");',
'         } else {',
'           removeClass(logMainContainer, "searchfilter");',
'         }',
'         $("searchDisable").checked = !enable;',
'       } else {',
'         addClass($("search"), "greyedout");',
'         removeClass(document.body, "searching");',
'         removeClass(logMainContainer, "searchhighlight");',
'         removeClass(logMainContainer, "searchfilter");',
'       }',
'       setLogContainerHeight();',
'     }',
'',
'     function toggleSearchFilter() {',
'       var enable = $("searchFilter").checked;',
'       if (enable) {',
'         addClass(logMainContainer, "searchfilter");',
'       } else {',
'         removeClass(logMainContainer, "searchfilter");',
'       }',
'       refreshCurrentMatch();',
'     }',
'',
'     function toggleSearchHighlight() {',
'       var enable = $("searchHighlight").checked;',
'       if (enable) {',
'         addClass(logMainContainer, "searchhighlight");',
'       } else {',
'         removeClass(logMainContainer, "searchhighlight");',
'       }',
'     }',
'',
'     function clearSearch() {',
'       $("searchBox").value = "";',
'       doSearch();',
'     }',
'',
'     function searchNext() {',
'       if (currentSearch !== null && currentMatchIndex !== null) {',
'         currentSearch.matches[currentMatchIndex].setNotCurrent();',
'         var nextMatchIndex = currentSearch.getNextVisibleMatchIndex();',
'         if (nextMatchIndex > currentMatchIndex || confirm("Reached the end of the page. Start from the top?")) {',
'           setCurrentMatchIndex(nextMatchIndex);',
'         }',
'       }',
'     }',
'',
'     function searchPrevious() {',
'       if (currentSearch !== null && currentMatchIndex !== null) {',
'         currentSearch.matches[currentMatchIndex].setNotCurrent();',
'         var previousMatchIndex = currentSearch.getPreviousVisibleMatchIndex();',
'         if (previousMatchIndex < currentMatchIndex || confirm("Reached the start of the page. Continue from the bottom?")) {',
'           setCurrentMatchIndex(previousMatchIndex);',
'         }',
'       }',
'     }',
'',
'     function setCurrentMatchIndex(index) {',
'       currentMatchIndex = index;',
'       currentSearch.matches[currentMatchIndex].setCurrent();',
'     }',
'',
'     /* ------------------------------------------------------------------------- */',
'',
'     // CSS Utilities',
'',
'     function addClass(el, cssClass) {',
'       if (!hasClass(el, cssClass)) {',
'         if (el.className) {',
'           el.className += " " + cssClass;',
'         } else {',
'           el.className = cssClass;',
'         }',
'       }',
'     }',
'',
'     function hasClass(el, cssClass) {',
'       if (el.className) {',
'         var classNames = el.className.split(" ");',
'         return array_contains(classNames, cssClass);',
'       }',
'       return false;',
'     }',
'',
'     function removeClass(el, cssClass) {',
'       if (hasClass(el, cssClass)) {',
'         // Rebuild the className property',
'         var existingClasses = el.className.split(" ");',
'         var newClasses = [];',
'         for (var i = 0, len = existingClasses.length; i < len; i++) {',
'           if (existingClasses[i] != cssClass) {',
'             newClasses[newClasses.length] = existingClasses[i];',
'           }',
'         }',
'         el.className = newClasses.join(" ");',
'       }',
'     }',
'',
'     function replaceClass(el, newCssClass, oldCssClass) {',
'       removeClass(el, oldCssClass);',
'       addClass(el, newCssClass);',
'     }',
'',
'     /* ------------------------------------------------------------------------- */',
'',
'     // Other utility functions',
'',
'     function getElementsByClass(el, cssClass, tagName) {',
'       var elements = el.getElementsByTagName(tagName);',
'       var matches = [];',
'       for (var i = 0, len = elements.length; i < len; i++) {',
'         if (hasClass(elements[i], cssClass)) {',
'           matches.push(elements[i]);',
'         }',
'       }',
'       return matches;',
'     }',
'',
'     // Syntax borrowed from Prototype library',
'     function $(id) {',
'       return document.getElementById(id);',
'     }',
'',
'     function isDescendant(node, ancestorNode) {',
'       while (node != null) {',
'         if (node === ancestorNode) {',
'           return true;',
'         }',
'         node = node.parentNode;',
'       }',
'       return false;',
'     }',
'',
'     function isOrphan(node) {',
'       var currentNode = node;',
'       while (currentNode) {',
'         if (currentNode == document.body) {',
'           return false;',
'         }',
'         currentNode = currentNode.parentNode;',
'       }',
'       return true;',
'     }',
'',
'     function escapeHtml(str) {',
'       return str.replace(/&/g, "&amp;").replace(/[<]/g, "&lt;").replace(/>/g, "&gt;");',
'     }',
'',
'     function getWindowWidth() {',
'       if (window.innerWidth) {',
'         return window.innerWidth;',
'       } else if (document.documentElement && document.documentElement.clientWidth) {',
'         return document.documentElement.clientWidth;',
'       } else if (document.body) {',
'         return document.body.clientWidth;',
'       }',
'       return 0;',
'     }',
'',
'     function getWindowHeight() {',
'       if (window.innerHeight) {',
'         return window.innerHeight;',
'       } else if (document.documentElement && document.documentElement.clientHeight) {',
'         return document.documentElement.clientHeight;',
'       } else if (document.body) {',
'         return document.body.clientHeight;',
'       }',
'       return 0;',
'     }',
'',
'     function getToolBarsHeight() {',
'       return $("switches").offsetHeight;',
'     }',
'',
'     function getChromeHeight() {',
'       var height = getToolBarsHeight();',
'       if (showCommandLine) {',
'         height += $("commandLine").offsetHeight;',
'       }',
'       return height;',
'     }',
'',
'     function setLogContainerHeight() {',
'       if (logMainContainer) {',
'         var windowHeight = getWindowHeight();',
'         $("body").style.height = getWindowHeight() + "px";',
'         logMainContainer.style.height = "" +',
'           Math.max(0, windowHeight - getChromeHeight()) + "px";',
'       }',
'     }',
'',
'     function setCommandInputWidth() {',
'       if (showCommandLine) {',
'         $("command").style.width = "" + Math.max(0, $("commandLineContainer").offsetWidth -',
'           ($("evaluateButton").offsetWidth + 13)) + "px";',
'       }',
'     }',
'',
'     window.onresize = function() {',
'       setCommandInputWidth();',
'       setLogContainerHeight();',
'     };',
'',
'     if (!Array.prototype.push) {',
'       Array.prototype.push = function() {',
'             for (var i = 0, len = arguments.length; i < len; i++){',
'                 this[this.length] = arguments[i];',
'             }',
'             return this.length;',
'       };',
'     }',
'',
'     if (!Array.prototype.pop) {',
'       Array.prototype.pop = function() {',
'         if (this.length > 0) {',
'           var val = this[this.length - 1];',
'           this.length = this.length - 1;',
'           return val;',
'         }',
'       };',
'     }',
'',
'     if (!Array.prototype.shift) {',
'       Array.prototype.shift = function() {',
'         if (this.length > 0) {',
'           var firstItem = this[0];',
'           for (var i = 0, len = this.length - 1; i < len; i++) {',
'             this[i] = this[i + 1];',
'           }',
'           this.length = this.length - 1;',
'           return firstItem;',
'         }',
'       };',
'     }',
'',
'     if (!Array.prototype.splice) {',
'       Array.prototype.splice = function(startIndex, deleteCount) {',
'         var itemsAfterDeleted = this.slice(startIndex + deleteCount);',
'         var itemsDeleted = this.slice(startIndex, startIndex + deleteCount);',
'         this.length = startIndex;',
'         // Copy the arguments into a proper Array object',
'         var argumentsArray = [];',
'         for (var i = 0, len = arguments.length; i < len; i++) {',
'           argumentsArray[i] = arguments[i];',
'         }',
'         var itemsToAppend = (argumentsArray.length > 2) ?',
'           itemsAfterDeleted = argumentsArray.slice(2).concat(itemsAfterDeleted) : itemsAfterDeleted;',
'         for (i = 0, len = itemsToAppend.length; i < len; i++) {',
'           this.push(itemsToAppend[i]);',
'         }',
'         return itemsDeleted;',
'       };',
'     }',
'',
'     function array_remove(arr, val) {',
'       var index = -1;',
'       for (var i = 0, len = arr.length; i < len; i++) {',
'         if (arr[i] === val) {',
'           index = i;',
'           break;',
'         }',
'       }',
'       if (index >= 0) {',
'         arr.splice(index, 1);',
'         return index;',
'       } else {',
'         return false;',
'       }',
'     }',
'',
'     function array_removeFromStart(array, numberToRemove) {',
'       if (Array.prototype.splice) {',
'         array.splice(0, numberToRemove);',
'       } else {',
'         for (var i = numberToRemove, len = array.length; i < len; i++) {',
'           array[i - numberToRemove] = array[i];',
'         }',
'         array.length = array.length - numberToRemove;',
'       }',
'       return array;',
'     }',
'',
'     function array_contains(arr, val) {',
'       for (var i = 0, len = arr.length; i < len; i++) {',
'         if (arr[i] == val) {',
'           return true;',
'         }',
'       }',
'       return false;',
'     }',
'',
'     function getErrorMessage(ex) {',
'       if (ex.message) {',
'         return ex.message;',
'       } else if (ex.description) {',
'         return ex.description;',
'       }',
'       return "" + ex;',
'     }',
'',
'     function moveCaretToEnd(input) {',
'       if (input.setSelectionRange) {',
'         input.focus();',
'         var length = input.value.length;',
'         input.setSelectionRange(length, length);',
'       } else if (input.createTextRange) {',
'         var range = input.createTextRange();',
'         range.collapse(false);',
'         range.select();',
'       }',
'       input.focus();',
'     }',
'',
'     function stopPropagation(evt) {',
'       if (evt.stopPropagation) {',
'         evt.stopPropagation();',
'       } else if (typeof evt.cancelBubble != "undefined") {',
'         evt.cancelBubble = true;',
'       }',
'     }',
'',
'     function getEvent(evt) {',
'       return evt ? evt : event;',
'     }',
'',
'     function getTarget(evt) {',
'       return evt.target ? evt.target : evt.srcElement;',
'     }',
'',
'     function getRelatedTarget(evt) {',
'       if (evt.relatedTarget) {',
'         return evt.relatedTarget;',
'       } else if (evt.srcElement) {',
'         switch(evt.type) {',
'           case "mouseover":',
'             return evt.fromElement;',
'           case "mouseout":',
'             return evt.toElement;',
'           default:',
'             return evt.srcElement;',
'         }',
'       }',
'     }',
'',
'     function cancelKeyEvent(evt) {',
'       evt.returnValue = false;',
'       stopPropagation(evt);',
'     }',
'',
'     function evalCommandLine() {',
'       var expr = $("command").value;',
'       evalCommand(expr);',
'       $("command").value = "";',
'     }',
'',
'     function evalLastCommand() {',
'       if (lastCommand != null) {',
'         evalCommand(lastCommand);',
'       }',
'     }',
'',
'     var lastCommand = null;',
'     var commandHistory = [];',
'     var currentCommandIndex = 0;',
'',
'     function evalCommand(expr) {',
'       if (appender) {',
'         appender.evalCommandAndAppend(expr);',
'       } else {',
'         var prefix = ">>> " + expr + "\\r\\n";',
'         try {',
'           log("INFO", prefix + eval(expr));',
'         } catch (ex) {',
'           log("ERROR", prefix + "Error: " + getErrorMessage(ex));',
'         }',
'       }',
'       // Update command history',
'       if (expr != commandHistory[commandHistory.length - 1]) {',
'         commandHistory.push(expr);',
'         // Update the appender',
'         if (appender) {',
'           appender.storeCommandHistory(commandHistory);',
'         }',
'       }',
'       currentCommandIndex = (expr == commandHistory[currentCommandIndex]) ? currentCommandIndex + 1 : commandHistory.length;',
'       lastCommand = expr;',
'     }',
'     //]]>',
'   </script>',
'   <style type="text/css">',
'     body {',
'       background-color: white;',
'       color: black;',
'       padding: 0;',
'       margin: 0;',
'       font-family: tahoma, verdana, arial, helvetica, sans-serif;',
'       overflow: hidden;',
'     }',
'',
'     div#switchesContainer input {',
'       margin-bottom: 0;',
'     }',
'',
'     div.toolbar {',
'       border-top: solid #ffffff 1px;',
'       border-bottom: solid #aca899 1px;',
'       background-color: #f1efe7;',
'       padding: 3px 5px;',
'       font-size: 68.75%;',
'     }',
'',
'     div.toolbar, div#search input {',
'       font-family: tahoma, verdana, arial, helvetica, sans-serif;',
'     }',
'',
'     div.toolbar input.button {',
'       padding: 0 5px;',
'       font-size: 100%;',
'     }',
'',
'     div.toolbar input.hidden {',
'       display: none;',
'     }',
'',
'     div#switches input#clearButton {',
'       margin-left: 20px;',
'     }',
'',
'     div#levels label {',
'       font-weight: bold;',
'     }',
'',
'     div#levels label, div#options label {',
'       margin-right: 5px;',
'     }',
'',
'     div#levels label#wrapLabel {',
'       font-weight: normal;',
'     }',
'',
'     div#search label {',
'       margin-right: 10px;',
'     }',
'',
'     div#search label.searchboxlabel {',
'       margin-right: 0;',
'     }',
'',
'     div#search input {',
'       font-size: 100%;',
'     }',
'',
'     div#search input.validregex {',
'       color: green;',
'     }',
'',
'     div#search input.invalidregex {',
'       color: red;',
'     }',
'',
'     div#search input.nomatches {',
'       color: white;',
'       background-color: #ff6666;',
'     }',
'',
'     div#search input.nomatches {',
'       color: white;',
'       background-color: #ff6666;',
'     }',
'',
'     div#searchNav {',
'       display: none;',
'     }',
'',
'     div#commandLine {',
'       display: none;',
'     }',
'',
'     div#commandLine input#command {',
'       font-size: 100%;',
'       font-family: Courier New, Courier;',
'     }',
'',
'     div#commandLine input#evaluateButton {',
'     }',
'',
'     *.greyedout {',
'       color: gray !important;',
'       border-color: gray !important;',
'     }',
'',
'     *.greyedout *.alwaysenabled { color: black; }',
'',
'     *.unselectable {',
'       -khtml-user-select: none;',
'       -moz-user-select: none;',
'       user-select: none;',
'     }',
'',
'     div#log {',
'       font-family: Courier New, Courier;',
'       font-size: 75%;',
'       width: 100%;',
'       overflow: auto;',
'       clear: both;',
'       position: relative;',
'     }',
'',
'     div.group {',
'       border-color: #cccccc;',
'       border-style: solid;',
'       border-width: 1px 0 1px 1px;',
'       overflow: visible;',
'     }',
'',
'     div.oldIe div.group, div.oldIe div.group *, div.oldIe *.logentry {',
'       height: 1%;',
'     }',
'',
'     div.group div.groupheading span.expander {',
'       border: solid black 1px;',
'       font-family: Courier New, Courier;',
'       font-size: 0.833em;',
'       background-color: #eeeeee;',
'       position: relative;',
'       top: -1px;',
'       color: black;',
'       padding: 0 2px;',
'       cursor: pointer;',
'       cursor: hand;',
'       height: 1%;',
'     }',
'',
'     div.group div.groupcontent {',
'       margin-left: 10px;',
'       padding-bottom: 2px;',
'       overflow: visible;',
'     }',
'',
'     div.group div.expanded {',
'       display: block;',
'     }',
'',
'     div.group div.collapsed {',
'       display: none;',
'     }',
'',
'     *.logentry {',
'       overflow: visible;',
'       display: none;',
'       white-space: pre;',
'     }',
'',
'     span.pre {',
'       white-space: pre;',
'     }',
'     ',
'     pre.unwrapped {',
'       display: inline !important;',
'     }',
'',
'     pre.unwrapped pre.pre, div.wrapped pre.pre {',
'       display: inline;',
'     }',
'',
'     div.wrapped pre.pre {',
'       white-space: normal;',
'     }',
'',
'     div.wrapped {',
'       display: none;',
'     }',
'',
'     body.searching *.logentry span.currentmatch {',
'       color: white !important;',
'       background-color: green !important;',
'     }',
'',
'     body.searching div.searchhighlight *.logentry span.searchterm {',
'       color: black;',
'       background-color: yellow;',
'     }',
'',
'     div.wrap *.logentry {',
'       white-space: normal !important;',
'       border-width: 0 0 1px 0;',
'       border-color: #dddddd;',
'       border-style: dotted;',
'     }',
'',
'     div.wrap #log_wrapped, #log_unwrapped {',
'       display: block;',
'     }',
'',
'     div.wrap #log_unwrapped, #log_wrapped {',
'       display: none;',
'     }',
'',
'     div.wrap *.logentry span.pre {',
'       overflow: visible;',
'       white-space: normal;',
'     }',
'',
'     div.wrap *.logentry pre.unwrapped {',
'       display: none;',
'     }',
'',
'     div.wrap *.logentry span.wrapped {',
'       display: inline;',
'     }',
'',
'     div.searchfilter *.searchnonmatch {',
'       display: none !important;',
'     }',
'',
'     div#log *.TRACE, label#label_TRACE {',
'       color: #666666;',
'     }',
'',
'     div#log *.DEBUG, label#label_DEBUG {',
'       color: green;',
'     }',
'',
'     div#log *.INFO, label#label_INFO {',
'       color: #000099;',
'     }',
'',
'     div#log *.WARN, label#label_WARN {',
'       color: #999900;',
'     }',
'',
'     div#log *.ERROR, label#label_ERROR {',
'       color: red;',
'     }',
'',
'     div#log *.FATAL, label#label_FATAL {',
'       color: #660066;',
'     }',
'',
'     div.TRACE#log *.TRACE,',
'     div.DEBUG#log *.DEBUG,',
'     div.INFO#log *.INFO,',
'     div.WARN#log *.WARN,',
'     div.ERROR#log *.ERROR,',
'     div.FATAL#log *.FATAL {',
'       display: block;',
'     }',
'',
'     div#log div.separator {',
'       background-color: #cccccc;',
'       margin: 5px 0;',
'       line-height: 1px;',
'     }',
'   </style>',
' </head>',
'',
' <body id="body">',
'   <div id="switchesContainer">',
'     <div id="switches">',
'       <div id="levels" class="toolbar">',
'         Filters:',
'         <input type="checkbox" id="switch_TRACE" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide trace messages" /><label for="switch_TRACE" id="label_TRACE">trace</label>',
'         <input type="checkbox" id="switch_DEBUG" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide debug messages" /><label for="switch_DEBUG" id="label_DEBUG">debug</label>',
'         <input type="checkbox" id="switch_INFO" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide info messages" /><label for="switch_INFO" id="label_INFO">info</label>',
'         <input type="checkbox" id="switch_WARN" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide warn messages" /><label for="switch_WARN" id="label_WARN">warn</label>',
'         <input type="checkbox" id="switch_ERROR" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide error messages" /><label for="switch_ERROR" id="label_ERROR">error</label>',
'         <input type="checkbox" id="switch_FATAL" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide fatal messages" /><label for="switch_FATAL" id="label_FATAL">fatal</label>',
'         <input type="checkbox" id="switch_ALL" onclick="toggleAllLevels(); applyFilters()" checked="checked" title="Show/hide all messages" /><label for="switch_ALL" id="label_ALL">all</label>',
'       </div>',
'       <div id="search" class="toolbar">',
'         <label for="searchBox" class="searchboxlabel">Search:</label> <input type="text" id="searchBox" onclick="toggleSearchEnabled(true)" onkeyup="scheduleSearch()" size="20" />',
'         <input type="button" id="searchReset" disabled="disabled" value="Reset" onclick="clearSearch()" class="button" title="Reset the search" />',
'         <input type="checkbox" id="searchRegex" onclick="doSearch()" title="If checked, search is treated as a regular expression" /><label for="searchRegex">Regex</label>',
'         <input type="checkbox" id="searchCaseSensitive" onclick="doSearch()" title="If checked, search is case sensitive" /><label for="searchCaseSensitive">Match case</label>',
'         <input type="checkbox" id="searchDisable" onclick="toggleSearchEnabled()" title="Enable/disable search" /><label for="searchDisable" class="alwaysenabled">Disable</label>',
'         <div id="searchNav">',
'           <input type="button" id="searchNext" disabled="disabled" value="Next" onclick="searchNext()" class="button" title="Go to the next matching log entry" />',
'           <input type="button" id="searchPrevious" disabled="disabled" value="Previous" onclick="searchPrevious()" class="button" title="Go to the previous matching log entry" />',
'           <input type="checkbox" id="searchFilter" onclick="toggleSearchFilter()" title="If checked, non-matching log entries are filtered out" /><label for="searchFilter">Filter</label>',
'           <input type="checkbox" id="searchHighlight" onclick="toggleSearchHighlight()" title="Highlight matched search terms" /><label for="searchHighlight" class="alwaysenabled">Highlight all</label>',
'         </div>',
'       </div>',
'       <div id="options" class="toolbar">',
'         Options:',
'         <input type="checkbox" id="enableLogging" onclick="toggleLoggingEnabled()" checked="checked" title="Enable/disable logging" /><label for="enableLogging" id="enableLoggingLabel">Log</label>',
'         <input type="checkbox" id="wrap" onclick="toggleWrap()" title="Enable / disable word wrap" /><label for="wrap" id="wrapLabel">Wrap</label>',
'         <input type="checkbox" id="newestAtTop" onclick="toggleNewestAtTop()" title="If checked, causes newest messages to appear at the top" /><label for="newestAtTop" id="newestAtTopLabel">Newest at the top</label>',
'         <input type="checkbox" id="scrollToLatest" onclick="toggleScrollToLatest()" checked="checked" title="If checked, window automatically scrolls to a new message when it is added" /><label for="scrollToLatest" id="scrollToLatestLabel">Scroll to latest</label>',
'         <input type="button" id="clearButton" value="Clear" onclick="clearLog()" class="button" title="Clear all log messages"  />',
'         <input type="button" id="hideButton" value="Hide" onclick="hide()" class="hidden button" title="Hide the console" />',
'         <input type="button" id="closeButton" value="Close" onclick="closeWindow()" class="hidden button" title="Close the window" />',
'       </div>',
'     </div>',
'   </div>',
'   <div id="log" class="TRACE DEBUG INFO WARN ERROR FATAL"></div>',
'   <div id="commandLine" class="toolbar">',
'     <div id="commandLineContainer">',
'       <input type="text" id="command" title="Enter a JavaScript command here and hit return or press \'Evaluate\'" />',
'       <input type="button" id="evaluateButton" value="Evaluate" class="button" title="Evaluate the command" onclick="evalCommandLine()" />',
'     </div>',
'   </div>',
' </body>',
'</html>',
''
];
    };

    var defaultCommandLineFunctions = [];

    ConsoleAppender = function() {};

    var consoleAppenderIdCounter = 1;
    ConsoleAppender.prototype = new Appender();

    ConsoleAppender.prototype.create = function(inPage, container,
        lazyInit, initiallyMinimized, useDocumentWrite, width, height, focusConsoleWindow) {
      var appender = this;

      // Common properties
      var initialized = false;
      var consoleWindowCreated = false;
      var consoleWindowLoaded = false;
      var consoleClosed = false;

      var queuedLoggingEvents = [];
      var isSupported = true;
      var consoleAppenderId = consoleAppenderIdCounter++;

      // Local variables
      initiallyMinimized = extractBooleanFromParam(initiallyMinimized, this.defaults.initiallyMinimized);
      lazyInit = extractBooleanFromParam(lazyInit, this.defaults.lazyInit);
      useDocumentWrite = extractBooleanFromParam(useDocumentWrite, this.defaults.useDocumentWrite);
      var newestMessageAtTop = this.defaults.newestMessageAtTop;
      var scrollToLatestMessage = this.defaults.scrollToLatestMessage;
      width = width ? width : this.defaults.width;
      height = height ? height : this.defaults.height;
      var maxMessages = this.defaults.maxMessages;
      var showCommandLine = this.defaults.showCommandLine;
      var commandLineObjectExpansionDepth = this.defaults.commandLineObjectExpansionDepth;
      var showHideButton = this.defaults.showHideButton;
            var showCloseButton = this.defaults.showCloseButton;
            var showLogEntryDeleteButtons = this.defaults.showLogEntryDeleteButtons;

      this.setLayout(this.defaults.layout);

      // Functions whose implementations vary between subclasses
      var init, createWindow, safeToAppend, getConsoleWindow, open;

      // Configuration methods. The function scope is used to prevent
      // direct alteration to the appender configuration properties.
      var appenderName = inPage ? "InPageAppender" : "PopUpAppender";
      var checkCanConfigure = function(configOptionName) {
        if (consoleWindowCreated) {
          handleError(appenderName + ": configuration option '" + configOptionName + "' may not be set after the appender has been initialized");
          return false;
        }
        return true;
      };

      var consoleWindowExists = function() {
        return (consoleWindowLoaded && isSupported && !consoleClosed);
      };

      this.isNewestMessageAtTop = function() { return newestMessageAtTop; };
      this.setNewestMessageAtTop = function(newestMessageAtTopParam) {
        newestMessageAtTop = bool(newestMessageAtTopParam);
        if (consoleWindowExists()) {
          getConsoleWindow().setNewestAtTop(newestMessageAtTop);
        }
      };

      this.isScrollToLatestMessage = function() { return scrollToLatestMessage; };
      this.setScrollToLatestMessage = function(scrollToLatestMessageParam) {
        scrollToLatestMessage = bool(scrollToLatestMessageParam);
        if (consoleWindowExists()) {
          getConsoleWindow().setScrollToLatest(scrollToLatestMessage);
        }
      };

      this.getWidth = function() { return width; };
      this.setWidth = function(widthParam) {
        if (checkCanConfigure("width")) {
          width = extractStringFromParam(widthParam, width);
        }
      };

      this.getHeight = function() { return height; };
      this.setHeight = function(heightParam) {
        if (checkCanConfigure("height")) {
          height = extractStringFromParam(heightParam, height);
        }
      };

      this.getMaxMessages = function() { return maxMessages; };
      this.setMaxMessages = function(maxMessagesParam) {
        maxMessages = extractIntFromParam(maxMessagesParam, maxMessages);
        if (consoleWindowExists()) {
          getConsoleWindow().setMaxMessages(maxMessages);
        }
      };

      this.isShowCommandLine = function() { return showCommandLine; };
      this.setShowCommandLine = function(showCommandLineParam) {
        showCommandLine = bool(showCommandLineParam);
        if (consoleWindowExists()) {
          getConsoleWindow().setShowCommandLine(showCommandLine);
        }
      };

      this.isShowHideButton = function() { return showHideButton; };
      this.setShowHideButton = function(showHideButtonParam) {
        showHideButton = bool(showHideButtonParam);
        if (consoleWindowExists()) {
          getConsoleWindow().setShowHideButton(showHideButton);
        }
      };

      this.isShowCloseButton = function() { return showCloseButton; };
      this.setShowCloseButton = function(showCloseButtonParam) {
        showCloseButton = bool(showCloseButtonParam);
        if (consoleWindowExists()) {
          getConsoleWindow().setShowCloseButton(showCloseButton);
        }
      };

      this.getCommandLineObjectExpansionDepth = function() { return commandLineObjectExpansionDepth; };
      this.setCommandLineObjectExpansionDepth = function(commandLineObjectExpansionDepthParam) {
        commandLineObjectExpansionDepth = extractIntFromParam(commandLineObjectExpansionDepthParam, commandLineObjectExpansionDepth);
      };

      var minimized = initiallyMinimized;
      this.isInitiallyMinimized = function() { return initiallyMinimized; };
      this.setInitiallyMinimized = function(initiallyMinimizedParam) {
        if (checkCanConfigure("initiallyMinimized")) {
          initiallyMinimized = bool(initiallyMinimizedParam);
          minimized = initiallyMinimized;
        }
      };

      this.isUseDocumentWrite = function() { return useDocumentWrite; };
      this.setUseDocumentWrite = function(useDocumentWriteParam) {
        if (checkCanConfigure("useDocumentWrite")) {
          useDocumentWrite = bool(useDocumentWriteParam);
        }
      };

      // Common methods
      function QueuedLoggingEvent(loggingEvent, formattedMessage) {
        this.loggingEvent = loggingEvent;
        this.levelName = loggingEvent.level.name;
        this.formattedMessage = formattedMessage;
      }

      QueuedLoggingEvent.prototype.append = function() {
        getConsoleWindow().log(this.levelName, this.formattedMessage);
      };

      function QueuedGroup(name, initiallyExpanded) {
        this.name = name;
        this.initiallyExpanded = initiallyExpanded;
      }

      QueuedGroup.prototype.append = function() {
        getConsoleWindow().group(this.name, this.initiallyExpanded);
      };

      function QueuedGroupEnd() {}

      QueuedGroupEnd.prototype.append = function() {
        getConsoleWindow().groupEnd();
      };

      var checkAndAppend = function() {
        // Next line forces a check of whether the window has been closed
        safeToAppend();
        if (!initialized) {
          init();
        } else if (consoleClosed && reopenWhenClosed) {
          createWindow();
        }
        if (safeToAppend()) {
          appendQueuedLoggingEvents();
        }
      };

      this.append = function(loggingEvent) {
        if (isSupported) {
          // Format the message
          var formattedMessage = appender.getLayout().format(loggingEvent);
          if (this.getLayout().ignoresThrowable()) {
            formattedMessage += loggingEvent.getThrowableStrRep();
          }
          queuedLoggingEvents.push(new QueuedLoggingEvent(loggingEvent, formattedMessage));
          checkAndAppend();
        }
      };

            this.group = function(name, initiallyExpanded) {
        if (isSupported) {
          queuedLoggingEvents.push(new QueuedGroup(name, initiallyExpanded));
          checkAndAppend();
        }
      };

            this.groupEnd = function() {
        if (isSupported) {
          queuedLoggingEvents.push(new QueuedGroupEnd());
          checkAndAppend();
        }
      };

      var appendQueuedLoggingEvents = function() {
        var currentLoggingEvent;
        while (queuedLoggingEvents.length > 0) {
          queuedLoggingEvents.shift().append();
        }
        if (focusConsoleWindow) {
          getConsoleWindow().focus();
        }
      };

      this.setAddedToLogger = function(logger) {
        this.loggers.push(logger);
        if (enabled && !lazyInit) {
          init();
        }
      };

      this.clear = function() {
        if (consoleWindowExists()) {
          getConsoleWindow().clearLog();
        }
        queuedLoggingEvents.length = 0;
      };

      this.focus = function() {
        if (consoleWindowExists()) {
          getConsoleWindow().focus();
        }
      };

      this.focusCommandLine = function() {
        if (consoleWindowExists()) {
          getConsoleWindow().focusCommandLine();
        }
      };

      this.focusSearch = function() {
        if (consoleWindowExists()) {
          getConsoleWindow().focusSearch();
        }
      };

      var commandWindow = window;

      this.getCommandWindow = function() { return commandWindow; };
      this.setCommandWindow = function(commandWindowParam) {
        commandWindow = commandWindowParam;
      };

      this.executeLastCommand = function() {
        if (consoleWindowExists()) {
          getConsoleWindow().evalLastCommand();
        }
      };

      var commandLayout = new PatternLayout("%m");
      this.getCommandLayout = function() { return commandLayout; };
      this.setCommandLayout = function(commandLayoutParam) {
        commandLayout = commandLayoutParam;
      };

      this.evalCommandAndAppend = function(expr) {
        var commandReturnValue = { appendResult: true, isError: false };
        var commandOutput = "";
        // Evaluate the command
        try {
          var result, i;
          // The next three lines constitute a workaround for IE. Bizarrely, iframes seem to have no
          // eval method on the window object initially, but once execScript has been called on
          // it once then the eval method magically appears. See http://www.thismuchiknow.co.uk/?p=25
          if (!commandWindow.eval && commandWindow.execScript) {
            commandWindow.execScript("null");
          }

          var commandLineFunctionsHash = {};
          for (i = 0, len = commandLineFunctions.length; i < len; i++) {
            commandLineFunctionsHash[commandLineFunctions[i][0]] = commandLineFunctions[i][1];
          }

          // Keep an array of variables that are being changed in the command window so that they
          // can be restored to their original values afterwards
          var objectsToRestore = [];
          var addObjectToRestore = function(name) {
            objectsToRestore.push([name, commandWindow[name]]);
          };

          addObjectToRestore("appender");
          commandWindow.appender = appender;

          addObjectToRestore("commandReturnValue");
          commandWindow.commandReturnValue = commandReturnValue;

          addObjectToRestore("commandLineFunctionsHash");
          commandWindow.commandLineFunctionsHash = commandLineFunctionsHash;

          var addFunctionToWindow = function(name) {
            addObjectToRestore(name);
            commandWindow[name] = function() {
              return this.commandLineFunctionsHash[name](appender, arguments, commandReturnValue);
            };
          };

          for (i = 0, len = commandLineFunctions.length; i < len; i++) {
            addFunctionToWindow(commandLineFunctions[i][0]);
          }

          // Another bizarre workaround to get IE to eval in the global scope
          if (commandWindow === window && commandWindow.execScript) {
            addObjectToRestore("evalExpr");
            addObjectToRestore("result");
            window.evalExpr = expr;
            commandWindow.execScript("window.result=eval(window.evalExpr);");
            result = window.result;
          } else {
            result = commandWindow.eval(expr);
          }
          commandOutput = isUndefined(result) ? result : formatObjectExpansion(result, commandLineObjectExpansionDepth);

          // Restore variables in the command window to their original state
          for (i = 0, len = objectsToRestore.length; i < len; i++) {
            commandWindow[objectsToRestore[i][0]] = objectsToRestore[i][1];
          }
        } catch (ex) {
          commandOutput = "Error evaluating command: " + getExceptionStringRep(ex);
          commandReturnValue.isError = true;
        }
        // Append command output
        if (commandReturnValue.appendResult) {
          var message = ">>> " + expr;
          if (!isUndefined(commandOutput)) {
            message += newLine + commandOutput;
          }
          var level = commandReturnValue.isError ? Level.ERROR : Level.INFO;
          var loggingEvent = new LoggingEvent(null, new Date(), level, [message], null);
          var mainLayout = this.getLayout();
          this.setLayout(commandLayout);
          this.append(loggingEvent);
          this.setLayout(mainLayout);
        }
      };

      var commandLineFunctions = defaultCommandLineFunctions.concat([]);

      this.addCommandLineFunction = function(functionName, commandLineFunction) {
        commandLineFunctions.push([functionName, commandLineFunction]);
      };

      var commandHistoryCookieName = "log4javascriptCommandHistory";
      this.storeCommandHistory = function(commandHistory) {
        setCookie(commandHistoryCookieName, commandHistory.join(","));
      };

      var writeHtml = function(doc) {
        var lines = getConsoleHtmlLines();
        doc.open();
        for (var i = 0, len = lines.length; i < len; i++) {
          doc.writeln(lines[i]);
        }
        doc.close();
      };

      // Set up event listeners
      this.setEventTypes(["load", "unload"]);

      var consoleWindowLoadHandler = function() {
        var win = getConsoleWindow();
        win.setAppender(appender);
        win.setNewestAtTop(newestMessageAtTop);
        win.setScrollToLatest(scrollToLatestMessage);
        win.setMaxMessages(maxMessages);
        win.setShowCommandLine(showCommandLine);
        win.setShowHideButton(showHideButton);
        win.setShowCloseButton(showCloseButton);
        win.setMainWindow(window);

        // Restore command history stored in cookie
        var storedValue = getCookie(commandHistoryCookieName);
        if (storedValue) {
          win.commandHistory = storedValue.split(",");
          win.currentCommandIndex = win.commandHistory.length;
        }

        appender.dispatchEvent("load", { "win" : win });
      };

      this.unload = function() {
        logLog.debug("unload " + this + ", caller: " + this.unload.caller);
        if (!consoleClosed) {
          logLog.debug("really doing unload " + this);
          consoleClosed = true;
          consoleWindowLoaded = false;
          consoleWindowCreated = false;
          appender.dispatchEvent("unload", {});
        }
      };

      var pollConsoleWindow = function(windowTest, interval, successCallback, errorMessage) {
        function doPoll() {
          try {
            // Test if the console has been closed while polling
            if (consoleClosed) {
              clearInterval(poll);
            }
            if (windowTest(getConsoleWindow())) {
              clearInterval(poll);
              successCallback();
            }
          } catch (ex) {
            clearInterval(poll);
            isSupported = false;
            handleError(errorMessage, ex);
          }
        }

        // Poll the pop-up since the onload event is not reliable
        var poll = setInterval(doPoll, interval);
      };

      var getConsoleUrl = function() {
        var documentDomainSet = (document.domain != location.hostname);
        return useDocumentWrite ? "" : getBaseUrl() + "console_uncompressed.html" +
                         (documentDomainSet ? "?log4javascript_domain=" + escape(document.domain) : "");
      };

      // Define methods and properties that vary between subclasses
      if (inPage) {
        // InPageAppender

        var containerElement = null;

        // Configuration methods. The function scope is used to prevent
        // direct alteration to the appender configuration properties.
        var cssProperties = [];
        this.addCssProperty = function(name, value) {
          if (checkCanConfigure("cssProperties")) {
            cssProperties.push([name, value]);
          }
        };

        // Define useful variables
        var windowCreationStarted = false;
        var iframeContainerDiv;
        var iframeId = uniqueId + "_InPageAppender_" + consoleAppenderId;

        this.hide = function() {
          if (initialized && consoleWindowCreated) {
            if (consoleWindowExists()) {
              getConsoleWindow().$("command").blur();
            }
            iframeContainerDiv.style.display = "none";
            minimized = true;
          }
        };

        this.show = function() {
          if (initialized) {
            if (consoleWindowCreated) {
              iframeContainerDiv.style.display = "block";
              this.setShowCommandLine(showCommandLine); // Force IE to update
              minimized = false;
            } else if (!windowCreationStarted) {
              createWindow(true);
            }
          }
        };

        this.isVisible = function() {
          return !minimized && !consoleClosed;
        };

        this.close = function(fromButton) {
          if (!consoleClosed && (!fromButton || confirm("This will permanently remove the console from the page. No more messages will be logged. Do you wish to continue?"))) {
            iframeContainerDiv.parentNode.removeChild(iframeContainerDiv);
            this.unload();
          }
        };

        // Create open, init, getConsoleWindow and safeToAppend functions
        open = function() {
          var initErrorMessage = "InPageAppender.open: unable to create console iframe";

          function finalInit() {
            try {
              if (!initiallyMinimized) {
                appender.show();
              }
              consoleWindowLoadHandler();
              consoleWindowLoaded = true;
              appendQueuedLoggingEvents();
            } catch (ex) {
              isSupported = false;
              handleError(initErrorMessage, ex);
            }
          }

          function writeToDocument() {
            try {
              var windowTest = function(win) { return isLoaded(win); };
              if (useDocumentWrite) {
                writeHtml(getConsoleWindow().document);
              }
              if (windowTest(getConsoleWindow())) {
                finalInit();
              } else {
                pollConsoleWindow(windowTest, 100, finalInit, initErrorMessage);
              }
            } catch (ex) {
              isSupported = false;
              handleError(initErrorMessage, ex);
            }
          }

          minimized = false;
          iframeContainerDiv = containerElement.appendChild(document.createElement("div"));

          iframeContainerDiv.style.width = width;
          iframeContainerDiv.style.height = height;
          iframeContainerDiv.style.border = "solid gray 1px";

          for (var i = 0, len = cssProperties.length; i < len; i++) {
            iframeContainerDiv.style[cssProperties[i][0]] = cssProperties[i][1];
          }

          var iframeSrc = useDocumentWrite ? "" : " src='" + getConsoleUrl() + "'";

          // Adding an iframe using the DOM would be preferable, but it doesn't work
          // in IE5 on Windows, or in Konqueror prior to version 3.5 - in Konqueror
          // it creates the iframe fine but I haven't been able to find a way to obtain
          // the iframe's window object
          iframeContainerDiv.innerHTML = "<iframe id='" + iframeId + "' name='" + iframeId +
            "' width='100%' height='100%' frameborder='0'" + iframeSrc +
            " scrolling='no'></iframe>";
          consoleClosed = false;

          // Write the console HTML to the iframe
          var iframeDocumentExistsTest = function(win) {
            try {
              return bool(win) && bool(win.document);
            } catch (ex) {
              return false;
            }
          };
          if (iframeDocumentExistsTest(getConsoleWindow())) {
            writeToDocument();
          } else {
            pollConsoleWindow(iframeDocumentExistsTest, 100, writeToDocument, initErrorMessage);
          }
          consoleWindowCreated = true;
        };

        createWindow = function(show) {
          if (show || !initiallyMinimized) {
            var pageLoadHandler = function() {
              if (!container) {
                // Set up default container element
                containerElement = document.createElement("div");
                containerElement.style.position = "fixed";
                containerElement.style.left = "0";
                containerElement.style.right = "0";
                containerElement.style.bottom = "0";
                document.body.appendChild(containerElement);
                appender.addCssProperty("borderWidth", "1px 0 0 0");
                appender.addCssProperty("zIndex", 1000000); // Can't find anything authoritative that says how big z-index can be
                open();
              } else {
                try {
                  var el = document.getElementById(container);
                  if (el.nodeType == 1) {
                    containerElement = el;
                  }
                  open();
                } catch (ex) {
                  handleError("InPageAppender.init: invalid container element '" + container + "' supplied", ex);
                }
              }
            };

            // Test the type of the container supplied. First, check if it's an element
            if (pageLoaded && container && container.appendChild) {
              containerElement = container;
              open();
            } else if (pageLoaded) {
              pageLoadHandler();
            } else {
              log4javascript.addEventListener("load", pageLoadHandler);
            }
            windowCreationStarted = true;
          }
        };

        init = function() {
          createWindow();
          initialized = true;
        };

        getConsoleWindow = function() {
          var iframe = window.frames[iframeId];
          if (iframe) {
            return iframe;
          }
        };

        safeToAppend = function() {
          if (isSupported && !consoleClosed) {
            if (consoleWindowCreated && !consoleWindowLoaded && getConsoleWindow() && isLoaded(getConsoleWindow())) {
              consoleWindowLoaded = true;
            }
            return consoleWindowLoaded;
          }
          return false;
        };
      } else {
        // PopUpAppender

        // Extract params
        var useOldPopUp = appender.defaults.useOldPopUp;
        var complainAboutPopUpBlocking = appender.defaults.complainAboutPopUpBlocking;
        var reopenWhenClosed = this.defaults.reopenWhenClosed;

        // Configuration methods. The function scope is used to prevent
        // direct alteration to the appender configuration properties.
        this.isUseOldPopUp = function() { return useOldPopUp; };
        this.setUseOldPopUp = function(useOldPopUpParam) {
          if (checkCanConfigure("useOldPopUp")) {
            useOldPopUp = bool(useOldPopUpParam);
          }
        };

        this.isComplainAboutPopUpBlocking = function() { return complainAboutPopUpBlocking; };
        this.setComplainAboutPopUpBlocking = function(complainAboutPopUpBlockingParam) {
          if (checkCanConfigure("complainAboutPopUpBlocking")) {
            complainAboutPopUpBlocking = bool(complainAboutPopUpBlockingParam);
          }
        };

        this.isFocusPopUp = function() { return focusConsoleWindow; };
        this.setFocusPopUp = function(focusPopUpParam) {
          // This property can be safely altered after logging has started
          focusConsoleWindow = bool(focusPopUpParam);
        };

        this.isReopenWhenClosed = function() { return reopenWhenClosed; };
        this.setReopenWhenClosed = function(reopenWhenClosedParam) {
          // This property can be safely altered after logging has started
          reopenWhenClosed = bool(reopenWhenClosedParam);
        };

        this.close = function() {
          logLog.debug("close " + this);
          try {
            popUp.close();
            this.unload();
          } catch (ex) {
            // Do nothing
          }
        };

        this.hide = function() {
          logLog.debug("hide " + this);
          if (consoleWindowExists()) {
            this.close();
          }
        };

        this.show = function() {
          logLog.debug("show " + this);
          if (!consoleWindowCreated) {
            open();
          }
        };

        this.isVisible = function() {
          return safeToAppend();
        };

        // Define useful variables
        var popUp;

        // Create open, init, getConsoleWindow and safeToAppend functions
        open = function() {
          var windowProperties = "width=" + width + ",height=" + height + ",status,resizable";
          var windowName = "PopUp_" + location.host.replace(/[^a-z0-9]/gi, "_") + "_" + consoleAppenderId;
          if (!useOldPopUp || !useDocumentWrite) {
            // Ensure a previous window isn't used by using a unique name
            windowName = windowName + "_" + uniqueId;
          }

          var checkPopUpClosed = function(win) {
            if (consoleClosed) {
              return true;
            } else {
              try {
                return bool(win) && win.closed;
              } catch(ex) {}
            }
            return false;
          };

          var popUpClosedCallback = function() {
            if (!consoleClosed) {
              appender.unload();
            }
          };

          function finalInit() {
            getConsoleWindow().setCloseIfOpenerCloses(!useOldPopUp || !useDocumentWrite);
            consoleWindowLoadHandler();
            consoleWindowLoaded = true;
            appendQueuedLoggingEvents();
            pollConsoleWindow(checkPopUpClosed, 500, popUpClosedCallback,
                "PopUpAppender.checkPopUpClosed: error checking pop-up window");
          }

          try {
            popUp = window.open(getConsoleUrl(), windowName, windowProperties);
            consoleClosed = false;
            consoleWindowCreated = true;
            if (popUp && popUp.document) {
              if (useDocumentWrite && useOldPopUp && isLoaded(popUp)) {
                popUp.mainPageReloaded();
                finalInit();
              } else {
                if (useDocumentWrite) {
                  writeHtml(popUp.document);
                }
                // Check if the pop-up window object is available
                var popUpLoadedTest = function(win) { return bool(win) && isLoaded(win); };
                if (isLoaded(popUp)) {
                  finalInit();
                } else {
                  pollConsoleWindow(popUpLoadedTest, 100, finalInit,
                      "PopUpAppender.init: unable to create console window");
                }
              }
            } else {
              isSupported = false;
              logLog.warn("PopUpAppender.init: pop-ups blocked, please unblock to use PopUpAppender");
              if (complainAboutPopUpBlocking) {
                handleError("log4javascript: pop-up windows appear to be blocked. Please unblock them to use pop-up logging.");
              }
            }
          } catch (ex) {
            handleError("PopUpAppender.init: error creating pop-up", ex);
          }
        };

        createWindow = function() {
          if (!initiallyMinimized) {
            open();
          }
        };

        init = function() {
          createWindow();
          initialized = true;
        };

        getConsoleWindow = function() {
          return popUp;
        };

        safeToAppend = function() {
          if (isSupported && !isUndefined(popUp) && !consoleClosed) {
            if (popUp.closed ||
                (consoleWindowLoaded && isUndefined(popUp.closed))) { // Extra check for Opera
              appender.unload();
              logLog.debug("PopUpAppender: pop-up closed");
              return false;
            }
            if (!consoleWindowLoaded && isLoaded(popUp)) {
              consoleWindowLoaded = true;
            }
          }
          return isSupported && consoleWindowLoaded && !consoleClosed;
        };
      }

      // Expose getConsoleWindow so that automated tests can check the DOM
      this.getConsoleWindow = getConsoleWindow;
    };

    ConsoleAppender.addGlobalCommandLineFunction = function(functionName, commandLineFunction) {
      defaultCommandLineFunctions.push([functionName, commandLineFunction]);
    };

    /* ------------------------------------------------------------------ */

    function PopUpAppender(lazyInit, initiallyMinimized, useDocumentWrite,
                 width, height) {
      this.create(false, null, lazyInit, initiallyMinimized,
          useDocumentWrite, width, height, this.defaults.focusPopUp);
    }

    PopUpAppender.prototype = new ConsoleAppender();

    PopUpAppender.prototype.defaults = {
      layout: new PatternLayout("%d{HH:mm:ss} %-5p - %m{1}%n"),
      initiallyMinimized: false,
      focusPopUp: false,
      lazyInit: true,
      useOldPopUp: true,
      complainAboutPopUpBlocking: true,
      newestMessageAtTop: false,
      scrollToLatestMessage: true,
      width: "600",
      height: "400",
      reopenWhenClosed: false,
      maxMessages: null,
      showCommandLine: true,
      commandLineObjectExpansionDepth: 1,
      showHideButton: false,
      showCloseButton: true,
            showLogEntryDeleteButtons: true,
            useDocumentWrite: true
    };

    PopUpAppender.prototype.toString = function() {
      return "PopUpAppender";
    };

    log4javascript.PopUpAppender = PopUpAppender;

    /* ------------------------------------------------------------------ */

    function InPageAppender(container, lazyInit, initiallyMinimized,
                useDocumentWrite, width, height) {
      this.create(true, container, lazyInit, initiallyMinimized,
          useDocumentWrite, width, height, false);
    }

    InPageAppender.prototype = new ConsoleAppender();

    InPageAppender.prototype.defaults = {
      layout: new PatternLayout("%d{HH:mm:ss} %-5p - %m{1}%n"),
      initiallyMinimized: false,
      lazyInit: true,
      newestMessageAtTop: false,
      scrollToLatestMessage: true,
      width: "100%",
      height: "220px",
      maxMessages: null,
      showCommandLine: true,
      commandLineObjectExpansionDepth: 1,
      showHideButton: false,
      showCloseButton: false,
            showLogEntryDeleteButtons: true,
            useDocumentWrite: true
    };

    InPageAppender.prototype.toString = function() {
      return "InPageAppender";
    };

    log4javascript.InPageAppender = InPageAppender;

    // Next line for backwards compatibility
    log4javascript.InlineAppender = InPageAppender;
  })();
  /* ---------------------------------------------------------------------- */
  // Console extension functions

  function padWithSpaces(str, len) {
    if (str.length < len) {
      var spaces = [];
      var numberOfSpaces = Math.max(0, len - str.length);
      for (var i = 0; i < numberOfSpaces; i++) {
        spaces[i] = " ";
      }
      str += spaces.join("");
    }
    return str;
  }

  (function() {
    function dir(obj) {
      var maxLen = 0;
      // Obtain the length of the longest property name
      for (var p in obj) {
        maxLen = Math.max(toStr(p).length, maxLen);
      }
      // Create the nicely formatted property list
      var propList = [];
      for (p in obj) {
        var propNameStr = "  " + padWithSpaces(toStr(p), maxLen + 2);
        var propVal;
        try {
          propVal = splitIntoLines(toStr(obj[p])).join(padWithSpaces(newLine, maxLen + 6));
        } catch (ex) {
          propVal = "[Error obtaining property. Details: " + getExceptionMessage(ex) + "]";
        }
        propList.push(propNameStr + propVal);
      }
      return propList.join(newLine);
    }

    var nodeTypes = {
      ELEMENT_NODE: 1,
      ATTRIBUTE_NODE: 2,
      TEXT_NODE: 3,
      CDATA_SECTION_NODE: 4,
      ENTITY_REFERENCE_NODE: 5,
      ENTITY_NODE: 6,
      PROCESSING_INSTRUCTION_NODE: 7,
      COMMENT_NODE: 8,
      DOCUMENT_NODE: 9,
      DOCUMENT_TYPE_NODE: 10,
      DOCUMENT_FRAGMENT_NODE: 11,
      NOTATION_NODE: 12
    };

    var preFormattedElements = ["script", "pre"];

    // This should be the definitive list, as specified by the XHTML 1.0 Transitional DTD
    var emptyElements = ["br", "img", "hr", "param", "link", "area", "input", "col", "base", "meta"];
    var indentationUnit = "  ";

    // Create and return an XHTML string from the node specified
    function getXhtml(rootNode, includeRootNode, indentation, startNewLine, preformatted) {
      includeRootNode = (typeof includeRootNode == "undefined") ? true : !!includeRootNode;
      if (typeof indentation != "string") {
        indentation = "";
      }
      startNewLine = !!startNewLine;
      preformatted = !!preformatted;
      var xhtml;

      function isWhitespace(node) {
        return ((node.nodeType == nodeTypes.TEXT_NODE) && /^[ \t\r\n]*$/.test(node.nodeValue));
      }

      function fixAttributeValue(attrValue) {
        return attrValue.toString().replace(/\&/g, "&amp;").replace(/</g, "&lt;").replace(/\"/g, "&quot;");
      }

      function getStyleAttributeValue(el) {
        var stylePairs = el.style.cssText.split(";");
        var styleValue = "";
        var isFirst = true;
        for (var j = 0, len = stylePairs.length; j < len; j++) {
          var nameValueBits = stylePairs[j].split(":");
          var props = [];
          if (!/^\s*$/.test(nameValueBits[0])) {
            props.push(trim(nameValueBits[0]).toLowerCase() + ":" + trim(nameValueBits[1]));
          }
          styleValue = props.join(";");
        }
        return styleValue;
      }

      function getNamespace(el) {
        if (el.prefix) {
          return el.prefix;
        } else if (el.outerHTML) {
          var regex = new RegExp("<([^:]+):" + el.tagName + "[^>]*>", "i");
          if (regex.test(el.outerHTML)) {
            return RegExp.$1.toLowerCase();
          }
        }
                return "";
      }

      var lt = "<";
      var gt = ">";

      if (includeRootNode && rootNode.nodeType != nodeTypes.DOCUMENT_FRAGMENT_NODE) {
        switch (rootNode.nodeType) {
          case nodeTypes.ELEMENT_NODE:
            var tagName = rootNode.tagName.toLowerCase();
            xhtml = startNewLine ? newLine + indentation : "";
            xhtml += lt;
            // Allow for namespaces, where present
            var prefix = getNamespace(rootNode);
            var hasPrefix = !!prefix;
            if (hasPrefix) {
              xhtml += prefix + ":";
            }
            xhtml += tagName;
            for (i = 0, len = rootNode.attributes.length; i < len; i++) {
              var currentAttr = rootNode.attributes[i];
              // Check the attribute is valid.
              if (! currentAttr.specified ||
                  currentAttr.nodeValue === null ||
                  currentAttr.nodeName.toLowerCase() === "style" ||
                  typeof currentAttr.nodeValue !== "string" ||
                  currentAttr.nodeName.indexOf("_moz") === 0) {
                continue;
              }
              xhtml += " " + currentAttr.nodeName.toLowerCase() + "=\"";
              xhtml += fixAttributeValue(currentAttr.nodeValue);
              xhtml += "\"";
            }
            // Style needs to be done separately as it is not reported as an
            // attribute in IE
            if (rootNode.style.cssText) {
              var styleValue = getStyleAttributeValue(rootNode);
              if (styleValue !== "") {
                xhtml += " style=\"" + getStyleAttributeValue(rootNode) + "\"";
              }
            }
            if (array_contains(emptyElements, tagName) ||
                (hasPrefix && !rootNode.hasChildNodes())) {
              xhtml += "/" + gt;
            } else {
              xhtml += gt;
              // Add output for childNodes collection (which doesn't include attribute nodes)
              var childStartNewLine = !(rootNode.childNodes.length === 1 &&
                rootNode.childNodes[0].nodeType === nodeTypes.TEXT_NODE);
              var childPreformatted = array_contains(preFormattedElements, tagName);
              for (var i = 0, len = rootNode.childNodes.length; i < len; i++) {
                xhtml += getXhtml(rootNode.childNodes[i], true, indentation + indentationUnit,
                  childStartNewLine, childPreformatted);
              }
              // Add the end tag
              var endTag = lt + "/" + tagName + gt;
              xhtml += childStartNewLine ? newLine + indentation + endTag : endTag;
            }
            return xhtml;
          case nodeTypes.TEXT_NODE:
            if (isWhitespace(rootNode)) {
              xhtml = "";
            } else {
              if (preformatted) {
                xhtml = rootNode.nodeValue;
              } else {
                // Trim whitespace from each line of the text node
                var lines = splitIntoLines(trim(rootNode.nodeValue));
                var trimmedLines = [];
                for (var i = 0, len = lines.length; i < len; i++) {
                  trimmedLines[i] = trim(lines[i]);
                }
                xhtml = trimmedLines.join(newLine + indentation);
              }
              if (startNewLine) {
                xhtml = newLine + indentation + xhtml;
              }
            }
            return xhtml;
          case nodeTypes.CDATA_SECTION_NODE:
            return "<![CDA" + "TA[" + rootNode.nodeValue + "]" + "]>" + newLine;
          case nodeTypes.DOCUMENT_NODE:
            xhtml = "";
            // Add output for childNodes collection (which doesn't include attribute nodes)
            for (var i = 0, len = rootNode.childNodes.length; i < len; i++) {
              xhtml += getXhtml(rootNode.childNodes[i], true, indentation);
            }
            return xhtml;
          default:
            return "";
        }
      } else {
        xhtml = "";
        // Add output for childNodes collection (which doesn't include attribute nodes)
        for (var i = 0, len = rootNode.childNodes.length; i < len; i++) {
          xhtml += getXhtml(rootNode.childNodes[i], true, indentation + indentationUnit);
        }
        return xhtml;
      }
    }

    var layouts = {};

    function createCommandLineFunctions(appender) {
      ConsoleAppender.addGlobalCommandLineFunction("$", function(appender, args, returnValue) {
        return document.getElementById(args[0]);
      });

      ConsoleAppender.addGlobalCommandLineFunction("dir", function(appender, args, returnValue) {
        var lines = [];
        for (var i = 0, len = args.length; i < len; i++) {
          lines[i] = dir(args[i]);
        }
        return lines.join(newLine + newLine);
      });

      ConsoleAppender.addGlobalCommandLineFunction("dirxml", function(appender, args, returnValue) {
        var lines = [];
        for (var i = 0, len = args.length; i < len; i++) {
          var win = appender.getCommandWindow();
          lines[i] = getXhtml(args[i]);
        }
        return lines.join(newLine + newLine);
      });

      ConsoleAppender.addGlobalCommandLineFunction("cd", function(appender, args, returnValue) {
        var win, message;
        if (args.length === 0 || args[0] === "") {
          win = window;
          message = "Command line set to run in main window";
        } else {
          if (args[0].window == args[0]) {
            win = args[0];
            message = "Command line set to run in frame '" + args[0].name + "'";
          } else {
            win = window.frames[args[0]];
            if (win) {
              message = "Command line set to run in frame '" + args[0] + "'";
            } else {
              returnValue.isError = true;
              message = "Frame '" + args[0] + "' does not exist";
              win = appender.getCommandWindow();
            }
          }
        }
        appender.setCommandWindow(win);
        return message;
      });

      ConsoleAppender.addGlobalCommandLineFunction("clear", function(appender, args, returnValue) {
        returnValue.appendResult = false;
        appender.clear();
      });

      ConsoleAppender.addGlobalCommandLineFunction("keys", function(appender, args, returnValue) {
        var keys = [];
        for (var k in args[0]) {
          keys.push(k);
        }
        return keys;
      });

      ConsoleAppender.addGlobalCommandLineFunction("values", function(appender, args, returnValue) {
        var values = [];
        for (var k in args[0]) {
          try {
            values.push(args[0][k]);
          } catch (ex) {
            logLog.warn("values(): Unable to obtain value for key " + k + ". Details: " + getExceptionMessage(ex));
          }
        }
        return values;
      });

      ConsoleAppender.addGlobalCommandLineFunction("expansionDepth", function(appender, args, returnValue) {
        var expansionDepth = parseInt(args[0], 10);
        if (isNaN(expansionDepth) || expansionDepth < 0) {
          returnValue.isError = true;
          return "" + args[0] + " is not a valid expansion depth";
        } else {
          appender.setCommandLineObjectExpansionDepth(expansionDepth);
          return "Object expansion depth set to " + expansionDepth;
        }
      });
    }

    function init() {
      // Add command line functions
      createCommandLineFunctions();
      initialized = true;
    }

    /* ------------------------------------------------------------------ */

    init();
  })();

  /* ---------------------------------------------------------------------- */
  // Main load

   log4javascript.setDocumentReady = function() {
       pageLoaded = true;
       log4javascript.dispatchEvent("load", {});
   };

    if (window.addEventListener) {
        window.addEventListener("load", log4javascript.setDocumentReady, false);
    } else if (window.attachEvent) {
        window.attachEvent("onload", log4javascript.setDocumentReady);
    } else {
        var oldOnload = window.onload;
        if (typeof window.onload != "function") {
            window.onload = log4javascript.setDocumentReady;
        } else {
            window.onload = function(evt) {
                if (oldOnload) {
                    oldOnload(evt);
                }
                log4javascript.setDocumentReady();
            };
        }
    }

    // Ensure that the log4javascript object is available in the window. This
    // is necessary for log4javascript to be available in IE if loaded using
    // Dojo's module system
    window.log4javascript = log4javascript;

    return log4javascript;
})();
return root.log4javascript = log4javascript;
  }).apply(root, arguments);
});
}(this));

define('local.storage',[
  'backbone',
  'underscore'
],
function(Backbone, _) {
  var _eventHandler = {};
  _.extend(_eventHandler, Backbone.Events);

  var _pollingKeyTime = {};
  var _pollingKeys = {};
  var _pollingStarted = false;

  var _pageId = _.now().toString() + Math.random().toString(36).substr(2, 9);

  function serialize(data) {
    return JSON.stringify(data);
  }

  function deserialize(data) {
    try {
      return _.isString(data) ? JSON.parse(data): {};
    }
    catch(e) {
      return {};
    }
  }

  function addListener(callback) {
    if(window.addEventListener) {
      window.addEventListener('storage', callback, false);
    }
    else {
      //IE support
      document.attachEvent('onstorage', callback);
    }
  }

  function stopListening (callback) {
    if(window.removeEventListener) {
      window.removeEventListener('storage', callback, false);
    }
    else {
      //IE support
      document.detachEvent('onstorage', callback);
    }
  }

  function onStorageEvent(event) {
    var key = event.key;
    if(_pollingStarted && _pollingKeys[key]){
      return;
    }
    processStorageEvent(event);

  }

  function processStorageEvent(event) {
    var key = event.key;
    var storageItem = deserialize(event.newValue);
    var data =  storageItem.data;
    var metadata  = _.omit(storageItem, 'data');
    //IE workaround: event should be delivered to all windows excluding original one
    if(storageItem.destinationId) {
      if(storageItem.destinationId === _pageId) {
        _eventHandler.trigger(key, data, metadata);
      }
    }
    else if(storageItem.id !== _pageId) {
      _eventHandler.trigger(key, data, metadata);
    }
  }

  function StorageItem(value, options, destinationId) {
    this.id = _pageId;
    this.data= value;
    this.timestamp = _.now();
    this.options = options;
    this.destinationId = destinationId;
  }

  function pollStorage(){
    _.each(_pollingKeys, function(keyOptions, key){
      LocalStorage.set("TEST_KEY", _.now());
      var data = window.localStorage.getItem(key);
      var item = deserialize(data);

      if(!_pollingKeyTime[key]) {
        _pollingKeyTime[key] = item.timestamp;
        return;
      }

      if(item.timestamp && item.timestamp > _pollingKeyTime[key]){
        if(!_.isObject(keyOptions) || keyOptions.logging !== false) {
          console.log("LocalStorage: Item changed:"+ key+"; new data:"+data);
        }
        processStorageEvent({'key': key, 'newValue': data});
        _pollingKeyTime[key] = item.timestamp;
      }
    });
    window.setTimeout(pollStorage, 200);
  }

  var LocalStorage = {};

  LocalStorage.set = function(key, value, options) {
    var storageItem = new StorageItem(value, options);
    return this.setRaw(key, storageItem);
  };

  LocalStorage.getRaw = function(key) {
    var data = window.localStorage.getItem(key);
    return deserialize(data);
  };

  LocalStorage.setRaw = function(key, data) {
    var val = serialize(data);
    window.localStorage.setItem(key, val);
    return val;
  };

  LocalStorage.get = function(key) {
    var storageItem = this.getRaw(key);
    return storageItem.data;
  };

  LocalStorage.remove = function(key) {
    window.localStorage.removeItem(key);
    delete _pollingKeyTime[key];
  };

  LocalStorage.clear = function() {
    window.localStorage.clear();
    _pollingKeyTime={};
  };

  LocalStorage.on = function(key, callback, context) {
    _eventHandler.on(key, callback, context);
  };

  LocalStorage.off = function(key, callback, context) {
    _eventHandler.off(key, callback, context);
  };

  LocalStorage.triggerOtherPages = function(key, data) {
    var storageItem = new StorageItem(data);
    this.setRaw(key, storageItem);
  };

  LocalStorage.triggerAllPages = function(key, data) {
    var storageItem = new StorageItem(data);
    var metadata  = _.omit(storageItem, 'data');
    _eventHandler.trigger(key, data, metadata);  //trigger current page
    this.setRaw(key, storageItem);  //trigger all other pages
  };

  LocalStorage.triggerSinglePage = function(destinationId, key, data) {
    var storageItem = new StorageItem(data, {}, destinationId);
    if (destinationId === _pageId) {
      _eventHandler.trigger(key, data, _.omit(storageItem, 'data')); //trigger current page
    } else {
      this.setRaw(key, storageItem);
    }
  };

  LocalStorage.getPageId = function() {
    return _pageId;
  };

  LocalStorage.getAllKeys = function() {
    return Object.keys(window.localStorage);
  };

  LocalStorage.invokeStorageEvent = function(event){
    onStorageEvent(event);
  };

  LocalStorage.stop = function () {
    stopListening(onStorageEvent);
  };

  LocalStorage.serialize = serialize;

  LocalStorage.deserialize = deserialize;


  LocalStorage.addPollingKeys = function(keys){
    if(_.isArray(keys)) {
      _.each(keys, function(value) {
        _pollingKeys[value] = true;
      });
    } else if(_.isObject(keys)) {
      _.extend(_pollingKeys, keys);
    } else {
      _pollingKeys[keys] = true;
    }
  };

  LocalStorage.removePollingKeys = function (keys) {
    if (_.isArray(keys)) {
      _pollingKeys = _.omit(_pollingKeys, keys);
    } else if (_.isObject(keys)) {
      _pollingKeys = _.omit(_pollingKeys, _.keys(keys));
    } else {
      delete _pollingKeys[keys];
    }
  };

  LocalStorage.startPolling = function() {
    if(!_pollingStarted) {
      pollStorage();
      _pollingStarted = true;
    }
  };

  addListener(onStorageEvent);

  return LocalStorage;
});

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define('moment',factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0 &&
                    m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(+config._d);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && hasOwnProp(obj, '_isAMomentObject'));
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = typeof regex === 'function' ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            config._pf.invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && m._pf.overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                warn(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYY', 'YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = createUTCDate(year, 0, 1).getUTCDay();
        var daysToAdd;
        var dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year      : dayOfYear > 0 ? year      : year - 1,
            dayOfYear : dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var input = config._i,
            format = config._f,
            res;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        res = new Moment(checkOverflow(config));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
        return model._isUTC ? local__createLocal(input).zone(model._offset || 0) : local__createLocal(input).local();
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!input) {
            input = 0;
        }
        else {
            input = local__createLocal(input).utcOffset();
        }

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (this._a) {
            var other = this._isUTC ? create_utc__createUTC(this._a) : local__createLocal(this._a);
            return this.isValid() && compareArrays(this._a, other.toArray()) > 0;
        }

        return false;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function moment_format__format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, this._pf);
    }

    function invalidAt () {
        return this._pf.overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            config._pf.invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        config._pf.bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    function millisecond__milliseconds (token) {
        addFormatToken(0, [token, 3], 0, 'millisecond');
    }

    millisecond__milliseconds('SSS');
    millisecond__milliseconds('SSSS');

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);
    addRegexToken('SSSS', matchUnsigned);
    addParseToken(['S', 'SS', 'SSS', 'SSSS'], function (input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    });

    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = moment_format__format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment_moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment_moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY LT',
        LLLL : 'dddd, MMMM D, YYYY LT'
    };

    function longDateFormat (key) {
        var output = this._longDateFormat[key];
        if (!output && this._longDateFormat[key.toUpperCase()]) {
            output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                return val.slice(1);
            });
            this._longDateFormat[key] = output;
        }
        return output;
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years = 0;

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // Accurately convert days to years, assume start from year 0.
        years = absFloor(daysToYears(days));
        days -= absFloor(yearsToDays(years));

        // 30 days to a month
        // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
        months += absFloor(days / 30);
        days   %= 30;

        // 12 months -> 1 year
        years  += absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absFloor(years / 4) -
        //     absFloor(years / 100) + absFloor(years / 400);
        return years * 146097 / 400;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToYears(days) * 12;
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(yearsToDays(this._months / 12));
            switch (units) {
                case 'week'   : return days / 7            + milliseconds / 6048e5;
                case 'day'    : return days                + milliseconds / 864e5;
                case 'hour'   : return days * 24           + milliseconds / 36e5;
                case 'minute' : return days * 24 * 60      + milliseconds / 6e4;
                case 'second' : return days * 24 * 60 * 60 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var duration_get__milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var duration_get__months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = iso_string__abs(this.years());
        var M = iso_string__abs(this.months());
        var D = iso_string__abs(this.days());
        var h = iso_string__abs(this.hours());
        var m = iso_string__abs(this.minutes());
        var s = iso_string__abs(this.seconds() + this.milliseconds() / 1000);
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = duration_get__milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = duration_get__months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports

    ;

    //! moment.js
    //! version : 2.10.2
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com

    utils_hooks__hooks.version = '2.10.2';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment_moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment_moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment__default = utils_hooks__hooks;

    //! moment.js locale configuration
    //! locale : afrikaans (af)
    //! author : Werner Mollentze : https://github.com/wernerm

    var af = _moment__default.defineLocale('af', {
        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM : function (input) {
            return /^nm$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Vandag om] LT',
            nextDay : '[Môre om] LT',
            nextWeek : 'dddd [om] LT',
            lastDay : '[Gister om] LT',
            lastWeek : '[Laas] dddd [om] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'oor %s',
            past : '%s gelede',
            s : '\'n paar sekondes',
            m : '\'n minuut',
            mm : '%d minute',
            h : '\'n uur',
            hh : '%d ure',
            d : '\'n dag',
            dd : '%d dae',
            M : '\'n maand',
            MM : '%d maande',
            y : '\'n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
        },
        week : {
            dow : 1, // Maandag is die eerste dag van die week.
            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });

    //! moment.js locale configuration
    //! locale : Moroccan Arabic (ar-ma)
    //! author : ElFadili Yassine : https://github.com/ElFadiliY
    //! author : Abdel Said : https://github.com/abdelsaid

    var ar_ma = _moment__default.defineLocale('ar-ma', {
        months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'في %s',
            past : 'منذ %s',
            s : 'ثوان',
            m : 'دقيقة',
            mm : '%d دقائق',
            h : 'ساعة',
            hh : '%d ساعات',
            d : 'يوم',
            dd : '%d أيام',
            M : 'شهر',
            MM : '%d أشهر',
            y : 'سنة',
            yy : '%d سنوات'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Arabic Saudi Arabia (ar-sa)
    //! author : Suhail Alkowaileet : https://github.com/xsoh

    var ar_sa__symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
    }, ar_sa__numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
    };

    var ar_sa = _moment__default.defineLocale('ar-sa', {
        months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        meridiemParse: /ص|م/,
        isPM : function (input) {
            return 'م' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar : {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'في %s',
            past : 'منذ %s',
            s : 'ثوان',
            m : 'دقيقة',
            mm : '%d دقائق',
            h : 'ساعة',
            hh : '%d ساعات',
            d : 'يوم',
            dd : '%d أيام',
            M : 'شهر',
            MM : '%d أشهر',
            y : 'سنة',
            yy : '%d سنوات'
        },
        preparse: function (string) {
            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                return ar_sa__numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ar_sa__symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale  : Tunisian Arabic (ar-tn)

    var ar_tn = _moment__default.defineLocale('ar-tn', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'LT:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY LT',
            LLLL: 'dddd D MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! Locale: Arabic (ar)
    //! Author: Abdel Said: https://github.com/abdelsaid
    //! Changes in months, weekdays: Ahmed Elkhatib
    //! Native plural forms: forabi https://github.com/forabi

    var ar__symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
    }, ar__numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, ar__months = [
        'كانون الثاني يناير',
        'شباط فبراير',
        'آذار مارس',
        'نيسان أبريل',
        'أيار مايو',
        'حزيران يونيو',
        'تموز يوليو',
        'آب أغسطس',
        'أيلول سبتمبر',
        'تشرين الأول أكتوبر',
        'تشرين الثاني نوفمبر',
        'كانون الأول ديسمبر'
    ];

    var ar = _moment__default.defineLocale('ar', {
        months : ar__months,
        monthsShort : ar__months,
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        meridiemParse: /ص|م/,
        isPM : function (input) {
            return 'م' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar : {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'بعد %s',
            past : 'منذ %s',
            s : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                return ar__numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ar__symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : azerbaijani (az)
    //! author : topchiyev : https://github.com/topchiyev

    var az__suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-üncü',
        4: '-üncü',
        100: '-üncü',
        6: '-ncı',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-ıncı',
        90: '-ıncı'
    };

    var az = _moment__default.defineLocale('az', {
        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
        weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
        weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[bugün saat] LT',
            nextDay : '[sabah saat] LT',
            nextWeek : '[gələn həftə] dddd [saat] LT',
            lastDay : '[dünən] LT',
            lastWeek : '[keçən həftə] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s əvvəl',
            s : 'birneçə saniyyə',
            m : 'bir dəqiqə',
            mm : '%d dəqiqə',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gün',
            dd : '%d gün',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir il',
            yy : '%d il'
        },
        meridiemParse: /gecə|səhər|gündüz|axşam/,
        isPM : function (input) {
            return /^(gündüz|axşam)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gecə';
            } else if (hour < 12) {
                return 'səhər';
            } else if (hour < 17) {
                return 'gündüz';
            } else {
                return 'axşam';
            }
        },
        ordinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '-ıncı';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (az__suffixes[a] || az__suffixes[b] || az__suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : belarusian (be)
    //! author : Dmitry Demidov : https://github.com/demidov91
    //! author: Praleska: http://praleska.pro/
    //! Author : Menelion Elensúle : https://github.com/Oire

    function be__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function be__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
            'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
            'dd': 'дзень_дні_дзён',
            'MM': 'месяц_месяцы_месяцаў',
            'yy': 'год_гады_гадоў'
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвіліна' : 'хвіліну';
        }
        else if (key === 'h') {
            return withoutSuffix ? 'гадзіна' : 'гадзіну';
        }
        else {
            return number + ' ' + be__plural(format[key], +number);
        }
    }
    function be__monthsCaseReplace(m, format) {
        var months = {
            'nominative': 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_'),
            'accusative': 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function be__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
            'accusative': 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_')
        },
        nounCase = (/\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/).test(format) ?
            'accusative' :
            'nominative';
        return weekdays[nounCase][m.day()];
    }

    var be = _moment__default.defineLocale('be', {
        months : be__monthsCaseReplace,
        monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
        weekdays : be__weekdaysCaseReplace,
        weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY г.',
            LLL : 'D MMMM YYYY г., LT',
            LLLL : 'dddd, D MMMM YYYY г., LT'
        },
        calendar : {
            sameDay: '[Сёння ў] LT',
            nextDay: '[Заўтра ў] LT',
            lastDay: '[Учора ў] LT',
            nextWeek: function () {
                return '[У] dddd [ў] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return '[У мінулую] dddd [ў] LT';
                case 1:
                case 2:
                case 4:
                    return '[У мінулы] dddd [ў] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'праз %s',
            past : '%s таму',
            s : 'некалькі секунд',
            m : be__relativeTimeWithPlural,
            mm : be__relativeTimeWithPlural,
            h : be__relativeTimeWithPlural,
            hh : be__relativeTimeWithPlural,
            d : 'дзень',
            dd : be__relativeTimeWithPlural,
            M : 'месяц',
            MM : be__relativeTimeWithPlural,
            y : 'год',
            yy : be__relativeTimeWithPlural
        },
        meridiemParse: /ночы|раніцы|дня|вечара/,
        isPM : function (input) {
            return /^(дня|вечара)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночы';
            } else if (hour < 12) {
                return 'раніцы';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечара';
            }
        },
        ordinalParse: /\d{1,2}-(і|ы|га)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
            case 'D':
                return number + '-га';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : bulgarian (bg)
    //! author : Krasen Borisov : https://github.com/kraz

    var bg = _moment__default.defineLocale('bg', {
        months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
        weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
        weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Днес в] LT',
            nextDay : '[Утре в] LT',
            nextWeek : 'dddd [в] LT',
            lastDay : '[Вчера в] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[В изминалата] dddd [в] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[В изминалия] dddd [в] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'след %s',
            past : 'преди %s',
            s : 'няколко секунди',
            m : 'минута',
            mm : '%d минути',
            h : 'час',
            hh : '%d часа',
            d : 'ден',
            dd : '%d дни',
            M : 'месец',
            MM : '%d месеца',
            y : 'година',
            yy : '%d години'
        },
        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bengali (bn)
    //! author : Kaushik Gandhi : https://github.com/kaushikgandhi

    var bn__symbolMap = {
        '1': '১',
        '2': '২',
        '3': '৩',
        '4': '৪',
        '5': '৫',
        '6': '৬',
        '7': '৭',
        '8': '৮',
        '9': '৯',
        '0': '০'
    },
    bn__numberMap = {
        '১': '1',
        '২': '2',
        '৩': '3',
        '৪': '4',
        '৫': '5',
        '৬': '6',
        '৭': '7',
        '৮': '8',
        '৯': '9',
        '০': '0'
    };

    var bn = _moment__default.defineLocale('bn', {
        months : 'জানুয়ারী_ফেবুয়ারী_মার্চ_এপ্রিল_মে_জুন_জুলাই_অগাস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
        monthsShort : 'জানু_ফেব_মার্চ_এপর_মে_জুন_জুল_অগ_সেপ্ট_অক্টো_নভ_ডিসেম্'.split('_'),
        weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পত্তিবার_শুক্রুবার_শনিবার'.split('_'),
        weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পত্তি_শুক্রু_শনি'.split('_'),
        weekdaysMin : 'রব_সম_মঙ্গ_বু_ব্রিহ_শু_শনি'.split('_'),
        longDateFormat : {
            LT : 'A h:mm সময়',
            LTS : 'A h:mm:ss সময়',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[আজ] LT',
            nextDay : '[আগামীকাল] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[গতকাল] LT',
            lastWeek : '[গত] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s পরে',
            past : '%s আগে',
            s : 'কএক সেকেন্ড',
            m : 'এক মিনিট',
            mm : '%d মিনিট',
            h : 'এক ঘন্টা',
            hh : '%d ঘন্টা',
            d : 'এক দিন',
            dd : '%d দিন',
            M : 'এক মাস',
            MM : '%d মাস',
            y : 'এক বছর',
            yy : '%d বছর'
        },
        preparse: function (string) {
            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                return bn__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return bn__symbolMap[match];
            });
        },
        meridiemParse: /রাত|শকাল|দুপুর|বিকেল|রাত/,
        isPM: function (input) {
            return /^(দুপুর|বিকেল|রাত)$/.test(input);
        },
        //Bengali is a vast language its spoken
        //in different forms in various parts of the world.
        //I have just generalized with most common one used
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'রাত';
            } else if (hour < 10) {
                return 'শকাল';
            } else if (hour < 17) {
                return 'দুপুর';
            } else if (hour < 20) {
                return 'বিকেল';
            } else {
                return 'রাত';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : tibetan (bo)
    //! author : Thupten N. Chakrishar : https://github.com/vajradog

    var bo__symbolMap = {
        '1': '༡',
        '2': '༢',
        '3': '༣',
        '4': '༤',
        '5': '༥',
        '6': '༦',
        '7': '༧',
        '8': '༨',
        '9': '༩',
        '0': '༠'
    },
    bo__numberMap = {
        '༡': '1',
        '༢': '2',
        '༣': '3',
        '༤': '4',
        '༥': '5',
        '༦': '6',
        '༧': '7',
        '༨': '8',
        '༩': '9',
        '༠': '0'
    };

    var bo = _moment__default.defineLocale('bo', {
        months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
        monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
        weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
        weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
        weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[དི་རིང] LT',
            nextDay : '[སང་ཉིན] LT',
            nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
            lastDay : '[ཁ་སང] LT',
            lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ལ་',
            past : '%s སྔན་ལ',
            s : 'ལམ་སང',
            m : 'སྐར་མ་གཅིག',
            mm : '%d སྐར་མ',
            h : 'ཆུ་ཚོད་གཅིག',
            hh : '%d ཆུ་ཚོད',
            d : 'ཉིན་གཅིག',
            dd : '%d ཉིན་',
            M : 'ཟླ་བ་གཅིག',
            MM : '%d ཟླ་བ',
            y : 'ལོ་གཅིག',
            yy : '%d ལོ'
        },
        preparse: function (string) {
            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
                return bo__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return bo__symbolMap[match];
            });
        },
        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
        isPM: function (input) {
            return /^(ཉིན་གུང|དགོང་དག|མཚན་མོ)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'མཚན་མོ';
            } else if (hour < 10) {
                return 'ཞོགས་ཀས';
            } else if (hour < 17) {
                return 'ཉིན་གུང';
            } else if (hour < 20) {
                return 'དགོང་དག';
            } else {
                return 'མཚན་མོ';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : breton (br)
    //! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
            return number + ' bloaz';
        default:
            return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = _moment__default.defineLocale('br', {
        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        longDateFormat : {
            LT : 'h[e]mm A',
            LTS : 'h[e]mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [a viz] MMMM YYYY',
            LLL : 'D [a viz] MMMM YYYY LT',
            LLLL : 'dddd, D [a viz] MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Hiziv da] LT',
            nextDay : '[Warc\'hoazh da] LT',
            nextWeek : 'dddd [da] LT',
            lastDay : '[Dec\'h da] LT',
            lastWeek : 'dddd [paset da] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'a-benn %s',
            past : '%s \'zo',
            s : 'un nebeud segondennoù',
            m : 'ur vunutenn',
            mm : relativeTimeWithMutation,
            h : 'un eur',
            hh : '%d eur',
            d : 'un devezh',
            dd : relativeTimeWithMutation,
            M : 'ur miz',
            MM : relativeTimeWithMutation,
            y : 'ur bloaz',
            yy : specialMutationForYears
        },
        ordinalParse: /\d{1,2}(añ|vet)/,
        ordinal : function (number) {
            var output = (number === 1) ? 'añ' : 'vet';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : bosnian (bs)
    //! author : Nedim Cholich : https://github.com/frontyard
    //! based on (hr) translation by Bojan Marković

    function bs__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var bs = _moment__default.defineLocale('bs', {
        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jučer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[prošlu] dddd [u] LT';
                case 6:
                    return '[prošle] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prošli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : bs__translate,
            mm     : bs__translate,
            h      : bs__translate,
            hh     : bs__translate,
            d      : 'dan',
            dd     : bs__translate,
            M      : 'mjesec',
            MM     : bs__translate,
            y      : 'godinu',
            yy     : bs__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : catalan (ca)
    //! author : Juan G. Hurtado : https://github.com/juanghurtado

    var ca = _moment__default.defineLocale('ca', {
        months : 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay : function () {
                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextDay : function () {
                return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastDay : function () {
                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'fa %s',
            s : 'uns segons',
            m : 'un minut',
            mm : '%d minuts',
            h : 'una hora',
            hh : '%d hores',
            d : 'un dia',
            dd : '%d dies',
            M : 'un mes',
            MM : '%d mesos',
            y : 'un any',
            yy : '%d anys'
        },
        ordinalParse: /\d{1,2}(r|n|t|è|a)/,
        ordinal : function (number, period) {
            var output = (number === 1) ? 'r' :
                (number === 2) ? 'n' :
                (number === 3) ? 'r' :
                (number === 4) ? 't' : 'è';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : czech (cs)
    //! author : petrbela : https://github.com/petrbela

    var cs__months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
        cs__monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
    function cs__plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function cs__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'minuty' : 'minut');
            } else {
                return result + 'minutami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'hodiny' : 'hodin');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'dny' : 'dní');
            } else {
                return result + 'dny';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'měsíce' : 'měsíců');
            } else {
                return result + 'měsíci';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'roky' : 'let');
            } else {
                return result + 'lety';
            }
            break;
        }
    }

    var cs = _moment__default.defineLocale('cs', {
        months : cs__months,
        monthsShort : cs__monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (červenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(cs__months, cs__monthsShort)),
        weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
        weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
        weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd D. MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[zítra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v neděli v] LT';
                case 1:
                case 2:
                    return '[v] dddd [v] LT';
                case 3:
                    return '[ve středu v] LT';
                case 4:
                    return '[ve čtvrtek v] LT';
                case 5:
                    return '[v pátek v] LT';
                case 6:
                    return '[v sobotu v] LT';
                }
            },
            lastDay: '[včera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minulou neděli v] LT';
                case 1:
                case 2:
                    return '[minulé] dddd [v] LT';
                case 3:
                    return '[minulou středu v] LT';
                case 4:
                case 5:
                    return '[minulý] dddd [v] LT';
                case 6:
                    return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'před %s',
            s : cs__translate,
            m : cs__translate,
            mm : cs__translate,
            h : cs__translate,
            hh : cs__translate,
            d : cs__translate,
            dd : cs__translate,
            M : cs__translate,
            MM : cs__translate,
            y : cs__translate,
            yy : cs__translate
        },
        ordinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : chuvash (cv)
    //! author : Anatoly Mironov : https://github.com/mirontoli

    var cv = _moment__default.defineLocale('cv', {
        months : 'кăрлач_нарăс_пуш_ака_май_çĕртме_утă_çурла_авăн_юпа_чӳк_раштав'.split('_'),
        monthsShort : 'кăр_нар_пуш_ака_май_çĕр_утă_çур_ав_юпа_чӳк_раш'.split('_'),
        weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кĕçнерникун_эрнекун_шăматкун'.split('_'),
        weekdaysShort : 'выр_тун_ытл_юн_кĕç_эрн_шăм'.split('_'),
        weekdaysMin : 'вр_тн_ыт_юн_кç_эр_шм'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD-MM-YYYY',
            LL : 'YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ]',
            LLL : 'YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ], LT',
            LLLL : 'dddd, YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ], LT'
        },
        calendar : {
            sameDay: '[Паян] LT [сехетре]',
            nextDay: '[Ыран] LT [сехетре]',
            lastDay: '[Ĕнер] LT [сехетре]',
            nextWeek: '[Çитес] dddd LT [сехетре]',
            lastWeek: '[Иртнĕ] dddd LT [сехетре]',
            sameElse: 'L'
        },
        relativeTime : {
            future : function (output) {
                var affix = /сехет$/i.exec(output) ? 'рен' : /çул$/i.exec(output) ? 'тан' : 'ран';
                return output + affix;
            },
            past : '%s каялла',
            s : 'пĕр-ик çеккунт',
            m : 'пĕр минут',
            mm : '%d минут',
            h : 'пĕр сехет',
            hh : '%d сехет',
            d : 'пĕр кун',
            dd : '%d кун',
            M : 'пĕр уйăх',
            MM : '%d уйăх',
            y : 'пĕр çул',
            yy : '%d çул'
        },
        ordinalParse: /\d{1,2}-мĕш/,
        ordinal : '%d-мĕш',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Welsh (cy)
    //! author : Robert Allen

    var cy = _moment__default.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'LT:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY LT',
            LLLL: 'dddd, D MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn ôl',
            s: 'ychydig eiliadau',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : danish (da)
    //! author : Ulrik Nielsen : https://github.com/mrbase

    var da = _moment__default.defineLocale('da', {
        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd [d.] D. MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[I dag kl.] LT',
            nextDay : '[I morgen kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[I går kl.] LT',
            lastWeek : '[sidste] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'få sekunder',
            m : 'et minut',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dage',
            M : 'en måned',
            MM : '%d måneder',
            y : 'et år',
            yy : '%d år'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : austrian german (de-at)
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elensúle: https://github.com/Oire
    //! author : Martin Groller : https://github.com/MadMG

    function de_at__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de_at = _moment__default.defineLocale('de-at', {
        months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[Morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[Gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : de_at__processRelativeTime,
            mm : '%d Minuten',
            h : de_at__processRelativeTime,
            hh : '%d Stunden',
            d : de_at__processRelativeTime,
            dd : de_at__processRelativeTime,
            M : de_at__processRelativeTime,
            MM : de_at__processRelativeTime,
            y : de_at__processRelativeTime,
            yy : de_at__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : german (de)
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elensúle: https://github.com/Oire

    function de__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = _moment__default.defineLocale('de', {
        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[Morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[Gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : de__processRelativeTime,
            mm : '%d Minuten',
            h : de__processRelativeTime,
            hh : '%d Stunden',
            d : de__processRelativeTime,
            dd : de__processRelativeTime,
            M : de__processRelativeTime,
            MM : de__processRelativeTime,
            y : de__processRelativeTime,
            yy : de__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : modern greek (el)
    //! author : Aggelos Karalias : https://github.com/mehiel

    var el = _moment__default.defineLocale('el', {
        monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
        monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
        months : function (momentToFormat, format) {
            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
        weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
        weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
        weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'μμ' : 'ΜΜ';
            } else {
                return isLower ? 'πμ' : 'ΠΜ';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === 'μ');
        },
        meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendarEl : {
            sameDay : '[Σήμερα {}] LT',
            nextDay : '[Αύριο {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[Χθες {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[το προηγούμενο] dddd [{}] LT';
                    default:
                        return '[την προηγούμενη] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (typeof output === 'function') {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
        },
        relativeTime : {
            future : 'σε %s',
            past : '%s πριν',
            s : 'λίγα δευτερόλεπτα',
            m : 'ένα λεπτό',
            mm : '%d λεπτά',
            h : 'μία ώρα',
            hh : '%d ώρες',
            d : 'μία μέρα',
            dd : '%d μέρες',
            M : 'ένας μήνας',
            MM : '%d μήνες',
            y : 'ένας χρόνος',
            yy : '%d χρόνια'
        },
        ordinalParse: /\d{1,2}η/,
        ordinal: '%dη',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : australian english (en-au)

    var en_au = _moment__default.defineLocale('en-au', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : canadian english (en-ca)
    //! author : Jonathan Abourbih : https://github.com/jonbca

    var en_ca = _moment__default.defineLocale('en-ca', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM, YYYY',
            LLL : 'D MMMM, YYYY LT',
            LLLL : 'dddd, D MMMM, YYYY LT'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    //! moment.js locale configuration
    //! locale : great britain english (en-gb)
    //! author : Chris Gedrim : https://github.com/chrisgedrim

    var en_gb = _moment__default.defineLocale('en-gb', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : esperanto (eo)
    //! author : Colin Dean : https://github.com/colindean
    //! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
    //!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

    var eo = _moment__default.defineLocale('eo', {
        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
        weekdays : 'Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato'.split('_'),
        weekdaysShort : 'Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Ĵa_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'D[-an de] MMMM, YYYY',
            LLL : 'D[-an de] MMMM, YYYY LT',
            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY LT'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar : {
            sameDay : '[Hodiaŭ je] LT',
            nextDay : '[Morgaŭ je] LT',
            nextWeek : 'dddd [je] LT',
            lastDay : '[Hieraŭ je] LT',
            lastWeek : '[pasinta] dddd [je] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'je %s',
            past : 'antaŭ %s',
            s : 'sekundoj',
            m : 'minuto',
            mm : '%d minutoj',
            h : 'horo',
            hh : '%d horoj',
            d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
            dd : '%d tagoj',
            M : 'monato',
            MM : '%d monatoj',
            y : 'jaro',
            yy : '%d jaroj'
        },
        ordinalParse: /\d{1,2}a/,
        ordinal : '%da',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : spanish (es)
    //! author : Julio Napurí : https://github.com/julionc

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        es__monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var es = _moment__default.defineLocale('es', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return es__monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_Mi_Ju_Vi_Sá'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY LT',
            LLLL : 'dddd, D [de] MMMM [de] YYYY LT'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un año',
            yy : '%d años'
        },
        ordinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : estonian (et)
    //! author : Henry Kehlmann : https://github.com/madhenry
    //! improvements : Illimar Tambek : https://github.com/ragulka

    function et__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
            'm' : ['ühe minuti', 'üks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h' : ['ühe tunni', 'tund aega', 'üks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd' : ['ühe päeva', 'üks päev'],
            'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y' : ['ühe aasta', 'aasta', 'üks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = _moment__default.defineLocale('et', {
        months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat : {
            LT   : 'H:mm',
            LTS : 'LT:ss',
            L    : 'DD.MM.YYYY',
            LL   : 'D. MMMM YYYY',
            LLL  : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay  : '[Täna,] LT',
            nextDay  : '[Homme,] LT',
            nextWeek : '[Järgmine] dddd LT',
            lastDay  : '[Eile,] LT',
            lastWeek : '[Eelmine] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s pärast',
            past   : '%s tagasi',
            s      : et__processRelativeTime,
            m      : et__processRelativeTime,
            mm     : et__processRelativeTime,
            h      : et__processRelativeTime,
            hh     : et__processRelativeTime,
            d      : et__processRelativeTime,
            dd     : '%d päeva',
            M      : et__processRelativeTime,
            MM     : et__processRelativeTime,
            y      : et__processRelativeTime,
            yy     : et__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : euskara (eu)
    //! author : Eneko Illarramendi : https://github.com/eillarra

    var eu = _moment__default.defineLocale('eu', {
        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY[ko] MMMM[ren] D[a]',
            LLL : 'YYYY[ko] MMMM[ren] D[a] LT',
            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] LT',
            l : 'YYYY-M-D',
            ll : 'YYYY[ko] MMM D[a]',
            lll : 'YYYY[ko] MMM D[a] LT',
            llll : 'ddd, YYYY[ko] MMM D[a] LT'
        },
        calendar : {
            sameDay : '[gaur] LT[etan]',
            nextDay : '[bihar] LT[etan]',
            nextWeek : 'dddd LT[etan]',
            lastDay : '[atzo] LT[etan]',
            lastWeek : '[aurreko] dddd LT[etan]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s barru',
            past : 'duela %s',
            s : 'segundo batzuk',
            m : 'minutu bat',
            mm : '%d minutu',
            h : 'ordu bat',
            hh : '%d ordu',
            d : 'egun bat',
            dd : '%d egun',
            M : 'hilabete bat',
            MM : '%d hilabete',
            y : 'urte bat',
            yy : '%d urte'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Persian (fa)
    //! author : Ebrahim Byagowi : https://github.com/ebraminio

    var fa__symbolMap = {
        '1': '۱',
        '2': '۲',
        '3': '۳',
        '4': '۴',
        '5': '۵',
        '6': '۶',
        '7': '۷',
        '8': '۸',
        '9': '۹',
        '0': '۰'
    }, fa__numberMap = {
        '۱': '1',
        '۲': '2',
        '۳': '3',
        '۴': '4',
        '۵': '5',
        '۶': '6',
        '۷': '7',
        '۸': '8',
        '۹': '9',
        '۰': '0'
    };

    var fa = _moment__default.defineLocale('fa', {
        months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
        monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
        weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
        weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
        weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        meridiemParse: /قبل از ظهر|بعد از ظهر/,
        isPM: function (input) {
            return /بعد از ظهر/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'قبل از ظهر';
            } else {
                return 'بعد از ظهر';
            }
        },
        calendar : {
            sameDay : '[امروز ساعت] LT',
            nextDay : '[فردا ساعت] LT',
            nextWeek : 'dddd [ساعت] LT',
            lastDay : '[دیروز ساعت] LT',
            lastWeek : 'dddd [پیش] [ساعت] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'در %s',
            past : '%s پیش',
            s : 'چندین ثانیه',
            m : 'یک دقیقه',
            mm : '%d دقیقه',
            h : 'یک ساعت',
            hh : '%d ساعت',
            d : 'یک روز',
            dd : '%d روز',
            M : 'یک ماه',
            MM : '%d ماه',
            y : 'یک سال',
            yy : '%d سال'
        },
        preparse: function (string) {
            return string.replace(/[۰-۹]/g, function (match) {
                return fa__numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return fa__symbolMap[match];
            }).replace(/,/g, '،');
        },
        ordinalParse: /\d{1,2}م/,
        ordinal : '%dم',
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : finnish (fi)
    //! author : Tarmo Aidantausta : https://github.com/bleadof

    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function fi__translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
        case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
        case 'm':
            return isFuture ? 'minuutin' : 'minuutti';
        case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;
        case 'h':
            return isFuture ? 'tunnin' : 'tunti';
        case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;
        case 'd':
            return isFuture ? 'päivän' : 'päivä';
        case 'dd':
            result = isFuture ? 'päivän' : 'päivää';
            break;
        case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';
        case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;
        case 'y':
            return isFuture ? 'vuoden' : 'vuosi';
        case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = _moment__default.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] LT',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] LT',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] LT',
            llll : 'ddd, Do MMM YYYY, [klo] LT'
        },
        calendar : {
            sameDay : '[tänään] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s päästä',
            past : '%s sitten',
            s : fi__translate,
            m : fi__translate,
            mm : fi__translate,
            h : fi__translate,
            hh : fi__translate,
            d : fi__translate,
            dd : fi__translate,
            M : fi__translate,
            MM : fi__translate,
            y : fi__translate,
            yy : fi__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : faroese (fo)
    //! author : Ragnar Johannesen : https://github.com/ragnar123

    var fo = _moment__default.defineLocale('fo', {
        months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
        weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
        weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D. MMMM, YYYY LT'
        },
        calendar : {
            sameDay : '[Í dag kl.] LT',
            nextDay : '[Í morgin kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[Í gjár kl.] LT',
            lastWeek : '[síðstu] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'um %s',
            past : '%s síðani',
            s : 'fá sekund',
            m : 'ein minutt',
            mm : '%d minuttir',
            h : 'ein tími',
            hh : '%d tímar',
            d : 'ein dagur',
            dd : '%d dagar',
            M : 'ein mánaði',
            MM : '%d mánaðir',
            y : 'eitt ár',
            yy : '%d ár'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : canadian french (fr-ca)
    //! author : Jonathan Abourbih : https://github.com/jonbca

    var fr_ca = _moment__default.defineLocale('fr-ca', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Aujourd\'hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        }
    });

    //! moment.js locale configuration
    //! locale : french (fr)
    //! author : John Fischer : https://github.com/jfroffice

    var fr = _moment__default.defineLocale('fr', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Aujourd\'hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : frisian (fy)
    //! author : Robin van der Vliet : https://github.com/robin0van0der0v

    var fy__monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
        fy__monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = _moment__default.defineLocale('fy', {
        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return fy__monthsShortWithoutDots[m.month()];
            } else {
                return fy__monthsShortWithDots[m.month()];
            }
        },
        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[ôfrûne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'oer %s',
            past : '%s lyn',
            s : 'in pear sekonden',
            m : 'ien minút',
            mm : '%d minuten',
            h : 'ien oere',
            hh : '%d oeren',
            d : 'ien dei',
            dd : '%d dagen',
            M : 'ien moanne',
            MM : '%d moannen',
            y : 'ien jier',
            yy : '%d jierren'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : galician (gl)
    //! author : Juan G. Hurtado : https://github.com/juanghurtado

    var gl = _moment__default.defineLocale('gl', {
        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuño_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xuñ._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
        weekdays : 'Domingo_Luns_Martes_Mércores_Xoves_Venres_Sábado'.split('_'),
        weekdaysShort : 'Dom._Lun._Mar._Mér._Xov._Ven._Sáb.'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_Mé_Xo_Ve_Sá'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay : function () {
                return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
            },
            nextDay : function () {
                return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
            },
            lastDay : function () {
                return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
            },
            lastWeek : function () {
                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : function (str) {
                if (str === 'uns segundos') {
                    return 'nuns segundos';
                }
                return 'en ' + str;
            },
            past : 'hai %s',
            s : 'uns segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'unha hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ano',
            yy : '%d anos'
        },
        ordinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Hebrew (he)
    //! author : Tomer Cohen : https://github.com/tomer
    //! author : Moshe Simantov : https://github.com/DevelopmentIL
    //! author : Tal Ater : https://github.com/TalAter

    var he = _moment__default.defineLocale('he', {
        months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
        monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
        weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
        weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
        weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [ב]MMMM YYYY',
            LLL : 'D [ב]MMMM YYYY LT',
            LLLL : 'dddd, D [ב]MMMM YYYY LT',
            l : 'D/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY LT',
            llll : 'ddd, D MMM YYYY LT'
        },
        calendar : {
            sameDay : '[היום ב־]LT',
            nextDay : '[מחר ב־]LT',
            nextWeek : 'dddd [בשעה] LT',
            lastDay : '[אתמול ב־]LT',
            lastWeek : '[ביום] dddd [האחרון בשעה] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'בעוד %s',
            past : 'לפני %s',
            s : 'מספר שניות',
            m : 'דקה',
            mm : '%d דקות',
            h : 'שעה',
            hh : function (number) {
                if (number === 2) {
                    return 'שעתיים';
                }
                return number + ' שעות';
            },
            d : 'יום',
            dd : function (number) {
                if (number === 2) {
                    return 'יומיים';
                }
                return number + ' ימים';
            },
            M : 'חודש',
            MM : function (number) {
                if (number === 2) {
                    return 'חודשיים';
                }
                return number + ' חודשים';
            },
            y : 'שנה',
            yy : function (number) {
                if (number === 2) {
                    return 'שנתיים';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' שנה';
                }
                return number + ' שנים';
            }
        }
    });

    //! moment.js locale configuration
    //! locale : hindi (hi)
    //! author : Mayank Singhal : https://github.com/mayanksinghal

    var hi__symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
    },
    hi__numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
    };

    var hi = _moment__default.defineLocale('hi', {
        months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
        monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
        weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat : {
            LT : 'A h:mm बजे',
            LTS : 'A h:mm:ss बजे',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[आज] LT',
            nextDay : '[कल] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[कल] LT',
            lastWeek : '[पिछले] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s में',
            past : '%s पहले',
            s : 'कुछ ही क्षण',
            m : 'एक मिनट',
            mm : '%d मिनट',
            h : 'एक घंटा',
            hh : '%d घंटे',
            d : 'एक दिन',
            dd : '%d दिन',
            M : 'एक महीने',
            MM : '%d महीने',
            y : 'एक वर्ष',
            yy : '%d वर्ष'
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return hi__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return hi__symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /रात|सुबह|दोपहर|शाम/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'रात') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सुबह') {
                return hour;
            } else if (meridiem === 'दोपहर') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'शाम') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'रात';
            } else if (hour < 10) {
                return 'सुबह';
            } else if (hour < 17) {
                return 'दोपहर';
            } else if (hour < 20) {
                return 'शाम';
            } else {
                return 'रात';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : hrvatski (hr)
    //! author : Bojan Marković : https://github.com/bmarkovic

    function hr__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var hr = _moment__default.defineLocale('hr', {
        months : 'sječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),
        monthsShort : 'sje._vel._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jučer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[prošlu] dddd [u] LT';
                case 6:
                    return '[prošle] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prošli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : hr__translate,
            mm     : hr__translate,
            h      : hr__translate,
            hh     : hr__translate,
            d      : 'dan',
            dd     : hr__translate,
            M      : 'mjesec',
            MM     : hr__translate,
            y      : 'godinu',
            yy     : hr__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : hungarian (hu)
    //! author : Adam Brunner : https://github.com/adambrunner

    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
    function hu__translate(number, withoutSuffix, key, isFuture) {
        var num = number,
            suffix;
        switch (key) {
        case 's':
            return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
        case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
        case 'hh':
            return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
        case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
        case 'MM':
            return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
        case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
        case 'yy':
            return num + (isFuture || withoutSuffix ? ' év' : ' éve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = _moment__default.defineLocale('hu', {
        months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
        monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
        weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D., LT',
            LLLL : 'YYYY. MMMM D., dddd LT'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s múlva',
            past : '%s',
            s : hu__translate,
            m : hu__translate,
            mm : hu__translate,
            h : hu__translate,
            hh : hu__translate,
            d : hu__translate,
            dd : hu__translate,
            M : hu__translate,
            MM : hu__translate,
            y : hu__translate,
            yy : hu__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Armenian (hy-am)
    //! author : Armendarabyan : https://github.com/armendarabyan

    function hy_am__monthsCaseReplace(m, format) {
        var months = {
            'nominative': 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_'),
            'accusative': 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function hy_am__monthsShortCaseReplace(m, format) {
        var monthsShort = 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_');
        return monthsShort[m.month()];
    }
    function hy_am__weekdaysCaseReplace(m, format) {
        var weekdays = 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_');
        return weekdays[m.day()];
    }

    var hy_am = _moment__default.defineLocale('hy-am', {
        months : hy_am__monthsCaseReplace,
        monthsShort : hy_am__monthsShortCaseReplace,
        weekdays : hy_am__weekdaysCaseReplace,
        weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY թ.',
            LLL : 'D MMMM YYYY թ., LT',
            LLLL : 'dddd, D MMMM YYYY թ., LT'
        },
        calendar : {
            sameDay: '[այսօր] LT',
            nextDay: '[վաղը] LT',
            lastDay: '[երեկ] LT',
            nextWeek: function () {
                return 'dddd [օրը ժամը] LT';
            },
            lastWeek: function () {
                return '[անցած] dddd [օրը ժամը] LT';
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s հետո',
            past : '%s առաջ',
            s : 'մի քանի վայրկյան',
            m : 'րոպե',
            mm : '%d րոպե',
            h : 'ժամ',
            hh : '%d ժամ',
            d : 'օր',
            dd : '%d օր',
            M : 'ամիս',
            MM : '%d ամիս',
            y : 'տարի',
            yy : '%d տարի'
        },
        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
        isPM: function (input) {
            return /^(ցերեկվա|երեկոյան)$/.test(input);
        },
        meridiem : function (hour) {
            if (hour < 4) {
                return 'գիշերվա';
            } else if (hour < 12) {
                return 'առավոտվա';
            } else if (hour < 17) {
                return 'ցերեկվա';
            } else {
                return 'երեկոյան';
            }
        },
        ordinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
                if (number === 1) {
                    return number + '-ին';
                }
                return number + '-րդ';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bahasa Indonesia (id)
    //! author : Mohammad Satrio Utomo : https://github.com/tyok
    //! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

    var id = _moment__default.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'LT.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] LT',
            LLLL : 'dddd, D MMMM YYYY [pukul] LT'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : icelandic (is)
    //! author : Hinrik Örn Sigurðsson : https://github.com/hinrik

    function is__plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function is__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
        case 'm':
            return withoutSuffix ? 'mínúta' : 'mínútu';
        case 'mm':
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
            } else if (withoutSuffix) {
                return result + 'mínúta';
            }
            return result + 'mínútu';
        case 'hh':
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }
            return result + 'klukkustund';
        case 'd':
            if (withoutSuffix) {
                return 'dagur';
            }
            return isFuture ? 'dag' : 'degi';
        case 'dd':
            if (is__plural(number)) {
                if (withoutSuffix) {
                    return result + 'dagar';
                }
                return result + (isFuture ? 'daga' : 'dögum');
            } else if (withoutSuffix) {
                return result + 'dagur';
            }
            return result + (isFuture ? 'dag' : 'degi');
        case 'M':
            if (withoutSuffix) {
                return 'mánuður';
            }
            return isFuture ? 'mánuð' : 'mánuði';
        case 'MM':
            if (is__plural(number)) {
                if (withoutSuffix) {
                    return result + 'mánuðir';
                }
                return result + (isFuture ? 'mánuði' : 'mánuðum');
            } else if (withoutSuffix) {
                return result + 'mánuður';
            }
            return result + (isFuture ? 'mánuð' : 'mánuði');
        case 'y':
            return withoutSuffix || isFuture ? 'ár' : 'ári';
        case 'yy':
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
            }
            return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
        }
    }

    var is = _moment__default.defineLocale('is', {
        months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
        weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
        weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
        weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] LT',
            LLLL : 'dddd, D. MMMM YYYY [kl.] LT'
        },
        calendar : {
            sameDay : '[í dag kl.] LT',
            nextDay : '[á morgun kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[í gær kl.] LT',
            lastWeek : '[síðasta] dddd [kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'eftir %s',
            past : 'fyrir %s síðan',
            s : is__translate,
            m : is__translate,
            mm : is__translate,
            h : 'klukkustund',
            hh : is__translate,
            d : is__translate,
            dd : is__translate,
            M : is__translate,
            MM : is__translate,
            y : is__translate,
            yy : is__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : italian (it)
    //! author : Lorenzo : https://github.com/aliem
    //! author: Mattia Larentis: https://github.com/nostalgiaz

    var it = _moment__default.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato'.split('_'),
        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
        weekdaysMin : 'D_L_Ma_Me_G_V_S'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        ordinalParse : /\d{1,2}º/,
        ordinal: '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : japanese (ja)
    //! author : LI Long : https://github.com/baryon

    var ja = _moment__default.defineLocale('ja', {
        months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
        longDateFormat : {
            LT : 'Ah時m分',
            LTS : 'LTs秒',
            L : 'YYYY/MM/DD',
            LL : 'YYYY年M月D日',
            LLL : 'YYYY年M月D日LT',
            LLLL : 'YYYY年M月D日LT dddd'
        },
        meridiemParse: /午前|午後/i,
        isPM : function (input) {
            return input === '午後';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '午前';
            } else {
                return '午後';
            }
        },
        calendar : {
            sameDay : '[今日] LT',
            nextDay : '[明日] LT',
            nextWeek : '[来週]dddd LT',
            lastDay : '[昨日] LT',
            lastWeek : '[前週]dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s後',
            past : '%s前',
            s : '数秒',
            m : '1分',
            mm : '%d分',
            h : '1時間',
            hh : '%d時間',
            d : '1日',
            dd : '%d日',
            M : '1ヶ月',
            MM : '%dヶ月',
            y : '1年',
            yy : '%d年'
        }
    });

    //! moment.js locale configuration
    //! locale : Georgian (ka)
    //! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

    function ka__monthsCaseReplace(m, format) {
        var months = {
            'nominative': 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
            'accusative': 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
        },
        nounCase = (/D[oD] *MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function ka__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
            'accusative': 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_')
        },
        nounCase = (/(წინა|შემდეგ)/).test(format) ?
            'accusative' :
            'nominative';
        return weekdays[nounCase][m.day()];
    }

    var ka = _moment__default.defineLocale('ka', {
        months : ka__monthsCaseReplace,
        monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
        weekdays : ka__weekdaysCaseReplace,
        weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
        weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[დღეს] LT[-ზე]',
            nextDay : '[ხვალ] LT[-ზე]',
            lastDay : '[გუშინ] LT[-ზე]',
            nextWeek : '[შემდეგ] dddd LT[-ზე]',
            lastWeek : '[წინა] dddd LT-ზე',
            sameElse : 'L'
        },
        relativeTime : {
            future : function (s) {
                return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
                    s.replace(/ი$/, 'ში') :
                    s + 'ში';
            },
            past : function (s) {
                if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
                    return s.replace(/(ი|ე)$/, 'ის წინ');
                }
                if ((/წელი/).test(s)) {
                    return s.replace(/წელი$/, 'წლის წინ');
                }
            },
            s : 'რამდენიმე წამი',
            m : 'წუთი',
            mm : '%d წუთი',
            h : 'საათი',
            hh : '%d საათი',
            d : 'დღე',
            dd : '%d დღე',
            M : 'თვე',
            MM : '%d თვე',
            y : 'წელი',
            yy : '%d წელი'
        },
        ordinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
        ordinal : function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-ლი';
            }
            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                return 'მე-' + number;
            }
            return number + '-ე';
        },
        week : {
            dow : 1,
            doy : 7
        }
    });

    //! moment.js locale configuration
    //! locale : khmer (km)
    //! author : Kruy Vanna : https://github.com/kruyvanna

    var km = _moment__default.defineLocale('km', {
        months: 'មករា_កុម្ភៈ_មិនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
        monthsShort: 'មករា_កុម្ភៈ_មិនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'LT:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY LT',
            LLLL: 'dddd, D MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[ថ្ងៃនៈ ម៉ោង] LT',
            nextDay: '[ស្អែក ម៉ោង] LT',
            nextWeek: 'dddd [ម៉ោង] LT',
            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%sទៀត',
            past: '%sមុន',
            s: 'ប៉ុន្មានវិនាទី',
            m: 'មួយនាទី',
            mm: '%d នាទី',
            h: 'មួយម៉ោង',
            hh: '%d ម៉ោង',
            d: 'មួយថ្ងៃ',
            dd: '%d ថ្ងៃ',
            M: 'មួយខែ',
            MM: '%d ខែ',
            y: 'មួយឆ្នាំ',
            yy: '%d ឆ្នាំ'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : korean (ko)
    //!
    //! authors
    //!
    //! - Kyungwook, Park : https://github.com/kyungw00k
    //! - Jeeeyul Lee <jeeeyul@gmail.com>

    var ko = _moment__default.defineLocale('ko', {
        months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
        weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
        weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
        longDateFormat : {
            LT : 'A h시 m분',
            LTS : 'A h시 m분 s초',
            L : 'YYYY.MM.DD',
            LL : 'YYYY년 MMMM D일',
            LLL : 'YYYY년 MMMM D일 LT',
            LLLL : 'YYYY년 MMMM D일 dddd LT'
        },
        calendar : {
            sameDay : '오늘 LT',
            nextDay : '내일 LT',
            nextWeek : 'dddd LT',
            lastDay : '어제 LT',
            lastWeek : '지난주 dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s 후',
            past : '%s 전',
            s : '몇초',
            ss : '%d초',
            m : '일분',
            mm : '%d분',
            h : '한시간',
            hh : '%d시간',
            d : '하루',
            dd : '%d일',
            M : '한달',
            MM : '%d달',
            y : '일년',
            yy : '%d년'
        },
        ordinalParse : /\d{1,2}일/,
        ordinal : '%d일',
        meridiemParse : /오전|오후/,
        isPM : function (token) {
            return token === '오후';
        },
        meridiem : function (hour, minute, isUpper) {
            return hour < 12 ? '오전' : '오후';
        }
    });

    //! moment.js locale configuration
    //! locale : Luxembourgish (lb)
    //! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz

    function lb__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = _moment__default.defineLocale('lb', {
        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY LT',
            LLLL: 'dddd, D. MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gëschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime : {
            future : processFutureTime,
            past : processPastTime,
            s : 'e puer Sekonnen',
            m : lb__processRelativeTime,
            mm : '%d Minutten',
            h : lb__processRelativeTime,
            hh : '%d Stonnen',
            d : lb__processRelativeTime,
            dd : '%d Deeg',
            M : lb__processRelativeTime,
            MM : '%d Méint',
            y : lb__processRelativeTime,
            yy : '%d Joer'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Lithuanian (lt)
    //! author : Mindaugas Mozūras : https://github.com/mmozuras

    var lt__units = {
        'm' : 'minutė_minutės_minutę',
        'mm': 'minutės_minučių_minutes',
        'h' : 'valanda_valandos_valandą',
        'hh': 'valandos_valandų_valandas',
        'd' : 'diena_dienos_dieną',
        'dd': 'dienos_dienų_dienas',
        'M' : 'mėnuo_mėnesio_mėnesį',
        'MM': 'mėnesiai_mėnesių_mėnesius',
        'y' : 'metai_metų_metus',
        'yy': 'metai_metų_metus'
    },
    weekDays = 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_');
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekundės';
        } else {
            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return lt__units[key].split('_');
    }
    function lt__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    function relativeWeekDay(moment, format) {
        var nominative = format.indexOf('dddd HH:mm') === -1,
            weekDay = weekDays[moment.day()];
        return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + 'į';
    }

    var lt = _moment__default.defineLocale('lt', {
        months : 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays : relativeWeekDay,
        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
        weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY [m.] MMMM D [d.]',
            LLL : 'YYYY [m.] MMMM D [d.], LT [val.]',
            LLLL : 'YYYY [m.] MMMM D [d.], dddd, LT [val.]',
            l : 'YYYY-MM-DD',
            ll : 'YYYY [m.] MMMM D [d.]',
            lll : 'YYYY [m.] MMMM D [d.], LT [val.]',
            llll : 'YYYY [m.] MMMM D [d.], ddd, LT [val.]'
        },
        calendar : {
            sameDay : '[Šiandien] LT',
            nextDay : '[Rytoj] LT',
            nextWeek : 'dddd LT',
            lastDay : '[Vakar] LT',
            lastWeek : '[Praėjusį] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'po %s',
            past : 'prieš %s',
            s : translateSeconds,
            m : translateSingular,
            mm : lt__translate,
            h : translateSingular,
            hh : lt__translate,
            d : translateSingular,
            dd : lt__translate,
            M : translateSingular,
            MM : lt__translate,
            y : translateSingular,
            yy : lt__translate
        },
        ordinalParse: /\d{1,2}-oji/,
        ordinal : function (number) {
            return number + '-oji';
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : latvian (lv)
    //! author : Kristaps Karlsons : https://github.com/skakri

    var lv__units = {
        'mm': 'minūti_minūtes_minūte_minūtes',
        'hh': 'stundu_stundas_stunda_stundas',
        'dd': 'dienu_dienas_diena_dienas',
        'MM': 'mēnesi_mēnešus_mēnesis_mēneši',
        'yy': 'gadu_gadus_gads_gadi'
    };
    function lv__format(word, number, withoutSuffix) {
        var forms = word.split('_');
        if (withoutSuffix) {
            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
        } else {
            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
        }
    }
    function lv__relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + lv__format(lv__units[key], number, withoutSuffix);
    }

    var lv = _moment__default.defineLocale('lv', {
        months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'YYYY. [gada] D. MMMM',
            LLL : 'YYYY. [gada] D. MMMM, LT',
            LLLL : 'YYYY. [gada] D. MMMM, dddd, LT'
        },
        calendar : {
            sameDay : '[Šodien pulksten] LT',
            nextDay : '[Rīt pulksten] LT',
            nextWeek : 'dddd [pulksten] LT',
            lastDay : '[Vakar pulksten] LT',
            lastWeek : '[Pagājušā] dddd [pulksten] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s vēlāk',
            past : '%s agrāk',
            s : 'dažas sekundes',
            m : 'minūti',
            mm : lv__relativeTimeWithPlural,
            h : 'stundu',
            hh : lv__relativeTimeWithPlural,
            d : 'dienu',
            dd : lv__relativeTimeWithPlural,
            M : 'mēnesi',
            MM : lv__relativeTimeWithPlural,
            y : 'gadu',
            yy : lv__relativeTimeWithPlural
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : macedonian (mk)
    //! author : Borislav Mickov : https://github.com/B0k0

    var mk = _moment__default.defineLocale('mk', {
        months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
        weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
        weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
        weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Денес во] LT',
            nextDay : '[Утре во] LT',
            nextWeek : 'dddd [во] LT',
            lastDay : '[Вчера во] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[Во изминатата] dddd [во] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[Во изминатиот] dddd [во] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'после %s',
            past : 'пред %s',
            s : 'неколку секунди',
            m : 'минута',
            mm : '%d минути',
            h : 'час',
            hh : '%d часа',
            d : 'ден',
            dd : '%d дена',
            M : 'месец',
            MM : '%d месеци',
            y : 'година',
            yy : '%d години'
        },
        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : malayalam (ml)
    //! author : Floyd Pink : https://github.com/floydpink

    var ml = _moment__default.defineLocale('ml', {
        months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
        monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
        weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
        weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
        weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
        longDateFormat : {
            LT : 'A h:mm -നു',
            LTS : 'A h:mm:ss -നു',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[ഇന്ന്] LT',
            nextDay : '[നാളെ] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[ഇന്നലെ] LT',
            lastWeek : '[കഴിഞ്ഞ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s കഴിഞ്ഞ്',
            past : '%s മുൻപ്',
            s : 'അൽപ നിമിഷങ്ങൾ',
            m : 'ഒരു മിനിറ്റ്',
            mm : '%d മിനിറ്റ്',
            h : 'ഒരു മണിക്കൂർ',
            hh : '%d മണിക്കൂർ',
            d : 'ഒരു ദിവസം',
            dd : '%d ദിവസം',
            M : 'ഒരു മാസം',
            MM : '%d മാസം',
            y : 'ഒരു വർഷം',
            yy : '%d വർഷം'
        },
        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
        isPM : function (input) {
            return /^(ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'രാത്രി';
            } else if (hour < 12) {
                return 'രാവിലെ';
            } else if (hour < 17) {
                return 'ഉച്ച കഴിഞ്ഞ്';
            } else if (hour < 20) {
                return 'വൈകുന്നേരം';
            } else {
                return 'രാത്രി';
            }
        }
    });

    //! moment.js locale configuration
    //! locale : Marathi (mr)
    //! author : Harshad Kale : https://github.com/kalehv

    var mr__symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
    },
    mr__numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
    };

    var mr = _moment__default.defineLocale('mr', {
        months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
        weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat : {
            LT : 'A h:mm वाजता',
            LTS : 'A h:mm:ss वाजता',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[आज] LT',
            nextDay : '[उद्या] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[काल] LT',
            lastWeek: '[मागील] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s नंतर',
            past : '%s पूर्वी',
            s : 'सेकंद',
            m: 'एक मिनिट',
            mm: '%d मिनिटे',
            h : 'एक तास',
            hh : '%d तास',
            d : 'एक दिवस',
            dd : '%d दिवस',
            M : 'एक महिना',
            MM : '%d महिने',
            y : 'एक वर्ष',
            yy : '%d वर्षे'
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return mr__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return mr__symbolMap[match];
            });
        },
        meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'रात्री') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सकाळी') {
                return hour;
            } else if (meridiem === 'दुपारी') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'सायंकाळी') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'रात्री';
            } else if (hour < 10) {
                return 'सकाळी';
            } else if (hour < 17) {
                return 'दुपारी';
            } else if (hour < 20) {
                return 'सायंकाळी';
            } else {
                return 'रात्री';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bahasa Malaysia (ms-MY)
    //! author : Weldan Jamili : https://github.com/weldan

    var ms_my = _moment__default.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'LT.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] LT',
            LLLL : 'dddd, D MMMM YYYY [pukul] LT'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Burmese (my)
    //! author : Squar team, mysquar.com

    var my__symbolMap = {
        '1': '၁',
        '2': '၂',
        '3': '၃',
        '4': '၄',
        '5': '၅',
        '6': '၆',
        '7': '၇',
        '8': '၈',
        '9': '၉',
        '0': '၀'
    }, my__numberMap = {
        '၁': '1',
        '၂': '2',
        '၃': '3',
        '၄': '4',
        '၅': '5',
        '၆': '6',
        '၇': '7',
        '၈': '8',
        '၉': '9',
        '၀': '0'
    };

    var my = _moment__default.defineLocale('my', {
        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
        weekdaysShort: 'နွေ_လာ_င်္ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
        weekdaysMin: 'နွေ_လာ_င်္ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY LT',
            LLLL: 'dddd D MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[ယနေ.] LT [မှာ]',
            nextDay: '[မနက်ဖြန်] LT [မှာ]',
            nextWeek: 'dddd LT [မှာ]',
            lastDay: '[မနေ.က] LT [မှာ]',
            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'လာမည့် %s မှာ',
            past: 'လွန်ခဲ့သော %s က',
            s: 'စက္ကန်.အနည်းငယ်',
            m: 'တစ်မိနစ်',
            mm: '%d မိနစ်',
            h: 'တစ်နာရီ',
            hh: '%d နာရီ',
            d: 'တစ်ရက်',
            dd: '%d ရက်',
            M: 'တစ်လ',
            MM: '%d လ',
            y: 'တစ်နှစ်',
            yy: '%d နှစ်'
        },
        preparse: function (string) {
            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
                return my__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return my__symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : norwegian bokmål (nb)
    //! authors : Espen Hovlandsdal : https://github.com/rexxars
    //!           Sigurd Gartmann : https://github.com/sigurdga

    var nb = _moment__default.defineLocale('nb', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort : 'søn_man_tirs_ons_tors_fre_lør'.split('_'),
        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
        longDateFormat : {
            LT : 'H.mm',
            LTS : 'LT.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] LT',
            LLLL : 'dddd D. MMMM YYYY [kl.] LT'
        },
        calendar : {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i går kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'for %s siden',
            s : 'noen sekunder',
            m : 'ett minutt',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dager',
            M : 'en måned',
            MM : '%d måneder',
            y : 'ett år',
            yy : '%d år'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : nepali/nepalese
    //! author : suvash : https://github.com/suvash

    var ne__symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
    },
    ne__numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
    };

    var ne = _moment__default.defineLocale('ne', {
        months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
        monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
        weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
        weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
        weekdaysMin : 'आइ._सो._मङ्_बु._बि._शु._श.'.split('_'),
        longDateFormat : {
            LT : 'Aको h:mm बजे',
            LTS : 'Aको h:mm:ss बजे',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return ne__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ne__symbolMap[match];
            });
        },
        meridiemParse: /राती|बिहान|दिउँसो|बेलुका|साँझ|राती/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'राती') {
                return hour < 3 ? hour : hour + 12;
            } else if (meridiem === 'बिहान') {
                return hour;
            } else if (meridiem === 'दिउँसो') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'बेलुका' || meridiem === 'साँझ') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 3) {
                return 'राती';
            } else if (hour < 10) {
                return 'बिहान';
            } else if (hour < 15) {
                return 'दिउँसो';
            } else if (hour < 18) {
                return 'बेलुका';
            } else if (hour < 20) {
                return 'साँझ';
            } else {
                return 'राती';
            }
        },
        calendar : {
            sameDay : '[आज] LT',
            nextDay : '[भोली] LT',
            nextWeek : '[आउँदो] dddd[,] LT',
            lastDay : '[हिजो] LT',
            lastWeek : '[गएको] dddd[,] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%sमा',
            past : '%s अगाडी',
            s : 'केही समय',
            m : 'एक मिनेट',
            mm : '%d मिनेट',
            h : 'एक घण्टा',
            hh : '%d घण्टा',
            d : 'एक दिन',
            dd : '%d दिन',
            M : 'एक महिना',
            MM : '%d महिना',
            y : 'एक बर्ष',
            yy : '%d बर्ष'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : dutch (nl)
    //! author : Joris Röling : https://github.com/jjupiter

    var nl__monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        nl__monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var nl = _moment__default.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return nl__monthsShortWithoutDots[m.month()];
            } else {
                return nl__monthsShortWithDots[m.month()];
            }
        },
        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            m : 'één minuut',
            mm : '%d minuten',
            h : 'één uur',
            hh : '%d uur',
            d : 'één dag',
            dd : '%d dagen',
            M : 'één maand',
            MM : '%d maanden',
            y : 'één jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : norwegian nynorsk (nn)
    //! author : https://github.com/mechuwind

    var nn = _moment__default.defineLocale('nn', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I går klokka] LT',
            lastWeek: '[Føregåande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'for %s sidan',
            s : 'nokre sekund',
            m : 'eit minutt',
            mm : '%d minutt',
            h : 'ein time',
            hh : '%d timar',
            d : 'ein dag',
            dd : '%d dagar',
            M : 'ein månad',
            MM : '%d månader',
            y : 'eit år',
            yy : '%d år'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : polish (pl)
    //! author : Rafal Hirsz : https://github.com/evoL

    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
    function pl__plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function pl__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minutę';
        case 'mm':
            return result + (pl__plural(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzinę';
        case 'hh':
            return result + (pl__plural(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (pl__plural(number) ? 'miesiące' : 'miesięcy');
        case 'yy':
            return result + (pl__plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = _moment__default.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
        weekdaysShort : 'nie_pon_wt_śr_czw_pt_sb'.split('_'),
        weekdaysMin : 'N_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Dziś o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: '[W] dddd [o] LT',
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[W zeszłą niedzielę o] LT';
                case 3:
                    return '[W zeszłą środę o] LT';
                case 6:
                    return '[W zeszłą sobotę o] LT';
                default:
                    return '[W zeszły] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            m : pl__translate,
            mm : pl__translate,
            h : pl__translate,
            hh : pl__translate,
            d : '1 dzień',
            dd : '%d dni',
            M : 'miesiąc',
            MM : pl__translate,
            y : 'rok',
            yy : pl__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : brazilian portuguese (pt-br)
    //! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

    var pt_br = _moment__default.defineLocale('pt-br', {
        months : 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
        monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
        weekdays : 'domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado'.split('_'),
        weekdaysShort : 'dom_seg_ter_qua_qui_sex_sáb'.split('_'),
        weekdaysMin : 'dom_2ª_3ª_4ª_5ª_6ª_sáb'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [às] LT',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [às] LT'
        },
        calendar : {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[Último] dddd [às] LT' : // Saturday + Sunday
                    '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : '%s atrás',
            s : 'segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um mês',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}º/,
        ordinal : '%dº'
    });

    //! moment.js locale configuration
    //! locale : portuguese (pt)
    //! author : Jefferson : https://github.com/jalex79

    var pt = _moment__default.defineLocale('pt', {
        months : 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
        monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
        weekdays : 'domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado'.split('_'),
        weekdaysShort : 'dom_seg_ter_qua_qui_sex_sáb'.split('_'),
        weekdaysMin : 'dom_2ª_3ª_4ª_5ª_6ª_sáb'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY LT',
            LLLL : 'dddd, D [de] MMMM [de] YYYY LT'
        },
        calendar : {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[Último] dddd [às] LT' : // Saturday + Sunday
                    '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'há %s',
            s : 'segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um mês',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : romanian (ro)
    //! author : Vlad Gurdiga : https://github.com/gurdiga
    //! author : Valentin Agachi : https://github.com/avaly

    function ro__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                'mm': 'minute',
                'hh': 'ore',
                'dd': 'zile',
                'MM': 'luni',
                'yy': 'ani'
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = _moment__default.defineLocale('ro', {
        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[azi la] LT',
            nextDay: '[mâine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'peste %s',
            past : '%s în urmă',
            s : 'câteva secunde',
            m : 'un minut',
            mm : ro__relativeTimeWithPlural,
            h : 'o oră',
            hh : ro__relativeTimeWithPlural,
            d : 'o zi',
            dd : ro__relativeTimeWithPlural,
            M : 'o lună',
            MM : ro__relativeTimeWithPlural,
            y : 'un an',
            yy : ro__relativeTimeWithPlural
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : russian (ru)
    //! author : Viktorminator : https://github.com/Viktorminator
    //! Author : Menelion Elensúle : https://github.com/Oire

    function ru__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function ru__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
            'hh': 'час_часа_часов',
            'dd': 'день_дня_дней',
            'MM': 'месяц_месяца_месяцев',
            'yy': 'год_года_лет'
        };
        if (key === 'm') {
            return withoutSuffix ? 'минута' : 'минуту';
        }
        else {
            return number + ' ' + ru__plural(format[key], +number);
        }
    }
    function ru__monthsCaseReplace(m, format) {
        var months = {
            'nominative': 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
            'accusative': 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function ru__monthsShortCaseReplace(m, format) {
        var monthsShort = {
            'nominative': 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
            'accusative': 'янв_фев_мар_апр_мая_июня_июля_авг_сен_окт_ноя_дек'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return monthsShort[nounCase][m.month()];
    }
    function ru__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
            'accusative': 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_')
        },
        nounCase = (/\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/).test(format) ?
            'accusative' :
            'nominative';
        return weekdays[nounCase][m.day()];
    }

    var ru = _moment__default.defineLocale('ru', {
        months : ru__monthsCaseReplace,
        monthsShort : ru__monthsShortCaseReplace,
        weekdays : ru__weekdaysCaseReplace,
        weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        monthsParse : [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[й|я]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i],
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY г.',
            LLL : 'D MMMM YYYY г., LT',
            LLLL : 'dddd, D MMMM YYYY г., LT'
        },
        calendar : {
            sameDay: '[Сегодня в] LT',
            nextDay: '[Завтра в] LT',
            lastDay: '[Вчера в] LT',
            nextWeek: function () {
                return this.day() === 2 ? '[Во] dddd [в] LT' : '[В] dddd [в] LT';
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                    case 0:
                        return '[В прошлое] dddd [в] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[В прошлый] dddd [в] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[В прошлую] dddd [в] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[Во] dddd [в] LT';
                    } else {
                        return '[В] dddd [в] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'через %s',
            past : '%s назад',
            s : 'несколько секунд',
            m : ru__relativeTimeWithPlural,
            mm : ru__relativeTimeWithPlural,
            h : 'час',
            hh : ru__relativeTimeWithPlural,
            d : 'день',
            dd : ru__relativeTimeWithPlural,
            M : 'месяц',
            MM : ru__relativeTimeWithPlural,
            y : 'год',
            yy : ru__relativeTimeWithPlural
        },
        meridiemParse: /ночи|утра|дня|вечера/i,
        isPM : function (input) {
            return /^(дня|вечера)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночи';
            } else if (hour < 12) {
                return 'утра';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечера';
            }
        },
        ordinalParse: /\d{1,2}-(й|го|я)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-й';
            case 'D':
                return number + '-го';
            case 'w':
            case 'W':
                return number + '-я';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : slovak (sk)
    //! author : Martin Minka : https://github.com/k2s
    //! based on work of petrbela : https://github.com/petrbela

    var sk__months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
        sk__monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
    function sk__plural(n) {
        return (n > 1) && (n < 5);
    }
    function sk__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'minúty' : 'minút');
            } else {
                return result + 'minútami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'hodiny' : 'hodín');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'dni' : 'dní');
            } else {
                return result + 'dňami';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'mesiace' : 'mesiacov');
            } else {
                return result + 'mesiacmi';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'roky' : 'rokov');
            } else {
                return result + 'rokmi';
            }
            break;
        }
    }

    var sk = _moment__default.defineLocale('sk', {
        months : sk__months,
        monthsShort : sk__monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (červenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(sk__months, sk__monthsShort)),
        weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
        weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
        weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd D. MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v nedeľu o] LT';
                case 1:
                case 2:
                    return '[v] dddd [o] LT';
                case 3:
                    return '[v stredu o] LT';
                case 4:
                    return '[vo štvrtok o] LT';
                case 5:
                    return '[v piatok o] LT';
                case 6:
                    return '[v sobotu o] LT';
                }
            },
            lastDay: '[včera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minulú nedeľu o] LT';
                case 1:
                case 2:
                    return '[minulý] dddd [o] LT';
                case 3:
                    return '[minulú stredu o] LT';
                case 4:
                case 5:
                    return '[minulý] dddd [o] LT';
                case 6:
                    return '[minulú sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'pred %s',
            s : sk__translate,
            m : sk__translate,
            mm : sk__translate,
            h : sk__translate,
            hh : sk__translate,
            d : sk__translate,
            dd : sk__translate,
            M : sk__translate,
            MM : sk__translate,
            y : sk__translate,
            yy : sk__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : slovenian (sl)
    //! author : Robert Sedovšek : https://github.com/sedovsek

    function sl__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2) {
                result += 'minuti';
            } else if (number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minut';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';
        case 'hh':
            if (number === 1) {
                result += 'ura';
            } else if (number === 2) {
                result += 'uri';
            } else if (number === 3 || number === 4) {
                result += 'ure';
            } else {
                result += 'ur';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dni';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mesec';
            } else if (number === 2) {
                result += 'meseca';
            } else if (number === 3 || number === 4) {
                result += 'mesece';
            } else {
                result += 'mesecev';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'leto';
            } else if (number === 2) {
                result += 'leti';
            } else if (number === 3 || number === 4) {
                result += 'leta';
            } else {
                result += 'let';
            }
            return result;
        }
    }

    var sl = _moment__default.defineLocale('sl', {
        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
        weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
        weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay  : '[danes ob] LT',
            nextDay  : '[jutri ob] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[v] [nedeljo] [ob] LT';
                case 3:
                    return '[v] [sredo] [ob] LT';
                case 6:
                    return '[v] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[v] dddd [ob] LT';
                }
            },
            lastDay  : '[včeraj ob] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[prejšnja] dddd [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prejšnji] dddd [ob] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'čez %s',
            past   : '%s nazaj',
            s      : 'nekaj sekund',
            m      : sl__translate,
            mm     : sl__translate,
            h      : sl__translate,
            hh     : sl__translate,
            d      : 'en dan',
            dd     : sl__translate,
            M      : 'en mesec',
            MM     : sl__translate,
            y      : 'eno leto',
            yy     : sl__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Albanian (sq)
    //! author : Flakërim Ismani : https://github.com/flakerimi
    //! author: Menelion Elensúle: https://github.com/Oire (tests)
    //! author : Oerd Cukalla : https://github.com/oerd (fixes)

    var sq = _moment__default.defineLocale('sq', {
        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
        weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
        weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
        weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem : function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Sot në] LT',
            nextDay : '[Nesër në] LT',
            nextWeek : 'dddd [në] LT',
            lastDay : '[Dje në] LT',
            lastWeek : 'dddd [e kaluar në] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'në %s',
            past : '%s më parë',
            s : 'disa sekonda',
            m : 'një minutë',
            mm : '%d minuta',
            h : 'një orë',
            hh : '%d orë',
            d : 'një ditë',
            dd : '%d ditë',
            M : 'një muaj',
            MM : '%d muaj',
            y : 'një vit',
            yy : '%d vite'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Serbian-cyrillic (sr-cyrl)
    //! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

    var sr_cyrl__translator = {
        words: { //Different grammatical cases
            m: ['један минут', 'једне минуте'],
            mm: ['минут', 'минуте', 'минута'],
            h: ['један сат', 'једног сата'],
            hh: ['сат', 'сата', 'сати'],
            dd: ['дан', 'дана', 'дана'],
            MM: ['месец', 'месеца', 'месеци'],
            yy: ['година', 'године', 'година']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = sr_cyrl__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + sr_cyrl__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr_cyrl = _moment__default.defineLocale('sr-cyrl', {
        months: ['јануар', 'фебруар', 'март', 'април', 'мај', 'јун', 'јул', 'август', 'септембар', 'октобар', 'новембар', 'децембар'],
        monthsShort: ['јан.', 'феб.', 'мар.', 'апр.', 'мај', 'јун', 'јул', 'авг.', 'сеп.', 'окт.', 'нов.', 'дец.'],
        weekdays: ['недеља', 'понедељак', 'уторак', 'среда', 'четвртак', 'петак', 'субота'],
        weekdaysShort: ['нед.', 'пон.', 'уто.', 'сре.', 'чет.', 'пет.', 'суб.'],
        weekdaysMin: ['не', 'по', 'ут', 'ср', 'че', 'пе', 'су'],
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'LT:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY LT',
            LLLL: 'dddd, D. MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[данас у] LT',
            nextDay: '[сутра у] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[у] [недељу] [у] LT';
                case 3:
                    return '[у] [среду] [у] LT';
                case 6:
                    return '[у] [суботу] [у] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[у] dddd [у] LT';
                }
            },
            lastDay  : '[јуче у] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[прошле] [недеље] [у] LT',
                    '[прошлог] [понедељка] [у] LT',
                    '[прошлог] [уторка] [у] LT',
                    '[прошле] [среде] [у] LT',
                    '[прошлог] [четвртка] [у] LT',
                    '[прошлог] [петка] [у] LT',
                    '[прошле] [суботе] [у] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'за %s',
            past   : 'пре %s',
            s      : 'неколико секунди',
            m      : sr_cyrl__translator.translate,
            mm     : sr_cyrl__translator.translate,
            h      : sr_cyrl__translator.translate,
            hh     : sr_cyrl__translator.translate,
            d      : 'дан',
            dd     : sr_cyrl__translator.translate,
            M      : 'месец',
            MM     : sr_cyrl__translator.translate,
            y      : 'годину',
            yy     : sr_cyrl__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Serbian-latin (sr)
    //! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

    var sr__translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = sr__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + sr__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = _moment__default.defineLocale('sr', {
        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
        weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'četvrtak', 'petak', 'subota'],
        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'čet.', 'pet.', 'sub.'],
        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'če', 'pe', 'su'],
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'LT:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY LT',
            LLLL: 'dddd, D. MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedelju] [u] LT';
                case 3:
                    return '[u] [sredu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juče u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prošle] [nedelje] [u] LT',
                    '[prošlog] [ponedeljka] [u] LT',
                    '[prošlog] [utorka] [u] LT',
                    '[prošle] [srede] [u] LT',
                    '[prošlog] [četvrtka] [u] LT',
                    '[prošlog] [petka] [u] LT',
                    '[prošle] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'pre %s',
            s      : 'nekoliko sekundi',
            m      : sr__translator.translate,
            mm     : sr__translator.translate,
            h      : sr__translator.translate,
            hh     : sr__translator.translate,
            d      : 'dan',
            dd     : sr__translator.translate,
            M      : 'mesec',
            MM     : sr__translator.translate,
            y      : 'godinu',
            yy     : sr__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : swedish (sv)
    //! author : Jens Alm : https://github.com/ulmus

    var sv = _moment__default.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
        weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
        weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igår] LT',
            nextWeek: 'dddd LT',
            lastWeek: '[Förra] dddd[en] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'för %s sedan',
            s : 'några sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en månad',
            MM : '%d månader',
            y : 'ett år',
            yy : '%d år'
        },
        ordinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : tamil (ta)
    //! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

    var ta = _moment__default.defineLocale('ta', {
        months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
        monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
        weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
        weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
        weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[இன்று] LT',
            nextDay : '[நாளை] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[நேற்று] LT',
            lastWeek : '[கடந்த வாரம்] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s இல்',
            past : '%s முன்',
            s : 'ஒரு சில விநாடிகள்',
            m : 'ஒரு நிமிடம்',
            mm : '%d நிமிடங்கள்',
            h : 'ஒரு மணி நேரம்',
            hh : '%d மணி நேரம்',
            d : 'ஒரு நாள்',
            dd : '%d நாட்கள்',
            M : 'ஒரு மாதம்',
            MM : '%d மாதங்கள்',
            y : 'ஒரு வருடம்',
            yy : '%d ஆண்டுகள்'
        },
        ordinalParse: /\d{1,2}வது/,
        ordinal : function (number) {
            return number + 'வது';
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
        meridiem : function (hour, minute, isLower) {
            if (hour < 2) {
                return ' யாமம்';
            } else if (hour < 6) {
                return ' வைகறை';  // வைகறை
            } else if (hour < 10) {
                return ' காலை'; // காலை
            } else if (hour < 14) {
                return ' நண்பகல்'; // நண்பகல்
            } else if (hour < 18) {
                return ' எற்பாடு'; // எற்பாடு
            } else if (hour < 22) {
                return ' மாலை'; // மாலை
            } else {
                return ' யாமம்';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'யாமம்') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
                return hour;
            } else if (meridiem === 'நண்பகல்') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : thai (th)
    //! author : Kridsada Thanabulpong : https://github.com/sirn

    var th = _moment__default.defineLocale('th', {
        months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
        monthsShort : 'มกรา_กุมภา_มีนา_เมษา_พฤษภา_มิถุนา_กรกฎา_สิงหา_กันยา_ตุลา_พฤศจิกา_ธันวา'.split('_'),
        weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
        weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
        weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
        longDateFormat : {
            LT : 'H นาฬิกา m นาที',
            LTS : 'LT s วินาที',
            L : 'YYYY/MM/DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY เวลา LT',
            LLLL : 'วันddddที่ D MMMM YYYY เวลา LT'
        },
        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
        isPM: function (input) {
            return input === 'หลังเที่ยง';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ก่อนเที่ยง';
            } else {
                return 'หลังเที่ยง';
            }
        },
        calendar : {
            sameDay : '[วันนี้ เวลา] LT',
            nextDay : '[พรุ่งนี้ เวลา] LT',
            nextWeek : 'dddd[หน้า เวลา] LT',
            lastDay : '[เมื่อวานนี้ เวลา] LT',
            lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'อีก %s',
            past : '%sที่แล้ว',
            s : 'ไม่กี่วินาที',
            m : '1 นาที',
            mm : '%d นาที',
            h : '1 ชั่วโมง',
            hh : '%d ชั่วโมง',
            d : '1 วัน',
            dd : '%d วัน',
            M : '1 เดือน',
            MM : '%d เดือน',
            y : '1 ปี',
            yy : '%d ปี'
        }
    });

    //! moment.js locale configuration
    //! locale : Tagalog/Filipino (tl-ph)
    //! author : Dan Hagman

    var tl_ph = _moment__default.defineLocale('tl-ph', {
        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'MM/D/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM DD, YYYY LT'
        },
        calendar : {
            sameDay: '[Ngayon sa] LT',
            nextDay: '[Bukas sa] LT',
            nextWeek: 'dddd [sa] LT',
            lastDay: '[Kahapon sa] LT',
            lastWeek: 'dddd [huling linggo] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'sa loob ng %s',
            past : '%s ang nakalipas',
            s : 'ilang segundo',
            m : 'isang minuto',
            mm : '%d minuto',
            h : 'isang oras',
            hh : '%d oras',
            d : 'isang araw',
            dd : '%d araw',
            M : 'isang buwan',
            MM : '%d buwan',
            y : 'isang taon',
            yy : '%d taon'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : turkish (tr)
    //! authors : Erhan Gundogan : https://github.com/erhangundogan,
    //!           Burak Yiğit Kaya: https://github.com/BYK

    var tr__suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',
        6: '\'ncı',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'ıncı',
        90: '\'ıncı'
    };

    var tr = _moment__default.defineLocale('tr', {
        months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
        monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[bugün saat] LT',
            nextDay : '[yarın saat] LT',
            nextWeek : '[haftaya] dddd [saat] LT',
            lastDay : '[dün] LT',
            lastWeek : '[geçen hafta] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s önce',
            s : 'birkaç saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gün',
            dd : '%d gün',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yıl',
            yy : '%d yıl'
        },
        ordinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '\'ıncı';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (tr__suffixes[a] || tr__suffixes[b] || tr__suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Morocco Central Atlas Tamaziɣt in Latin (tzm-latn)
    //! author : Abdel Said : https://github.com/abdelsaid

    var tzm_latn = _moment__default.defineLocale('tzm-latn', {
        months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dadkh s yan %s',
            past : 'yan %s',
            s : 'imik',
            m : 'minuḍ',
            mm : '%d minuḍ',
            h : 'saɛa',
            hh : '%d tassaɛin',
            d : 'ass',
            dd : '%d ossan',
            M : 'ayowr',
            MM : '%d iyyirn',
            y : 'asgas',
            yy : '%d isgasn'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Morocco Central Atlas Tamaziɣt (tzm)
    //! author : Abdel Said : https://github.com/abdelsaid

    var tzm = _moment__default.defineLocale('tzm', {
        months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS: 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
            nextWeek: 'dddd [ⴴ] LT',
            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
            lastWeek: 'dddd [ⴴ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
            past : 'ⵢⴰⵏ %s',
            s : 'ⵉⵎⵉⴽ',
            m : 'ⵎⵉⵏⵓⴺ',
            mm : '%d ⵎⵉⵏⵓⴺ',
            h : 'ⵙⴰⵄⴰ',
            hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
            d : 'ⴰⵙⵙ',
            dd : '%d oⵙⵙⴰⵏ',
            M : 'ⴰⵢoⵓⵔ',
            MM : '%d ⵉⵢⵢⵉⵔⵏ',
            y : 'ⴰⵙⴳⴰⵙ',
            yy : '%d ⵉⵙⴳⴰⵙⵏ'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : ukrainian (uk)
    //! author : zemlanin : https://github.com/zemlanin
    //! Author : Menelion Elensúle : https://github.com/Oire

    function uk__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function uk__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': 'хвилина_хвилини_хвилин',
            'hh': 'година_години_годин',
            'dd': 'день_дні_днів',
            'MM': 'місяць_місяці_місяців',
            'yy': 'рік_роки_років'
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвилина' : 'хвилину';
        }
        else if (key === 'h') {
            return withoutSuffix ? 'година' : 'годину';
        }
        else {
            return number + ' ' + uk__plural(format[key], +number);
        }
    }
    function uk__monthsCaseReplace(m, format) {
        var months = {
            'nominative': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_'),
            'accusative': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_')
        },
        nounCase = (/D[oD]? *MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function uk__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
            'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
            'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
        },
        nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
            'accusative' :
            ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
                'genitive' :
                'nominative');
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
        };
    }

    var uk = _moment__default.defineLocale('uk', {
        months : uk__monthsCaseReplace,
        monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
        weekdays : uk__weekdaysCaseReplace,
        weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY р.',
            LLL : 'D MMMM YYYY р., LT',
            LLLL : 'dddd, D MMMM YYYY р., LT'
        },
        calendar : {
            sameDay: processHoursFunction('[Сьогодні '),
            nextDay: processHoursFunction('[Завтра '),
            lastDay: processHoursFunction('[Вчора '),
            nextWeek: processHoursFunction('[У] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return processHoursFunction('[Минулої] dddd [').call(this);
                case 1:
                case 2:
                case 4:
                    return processHoursFunction('[Минулого] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'за %s',
            past : '%s тому',
            s : 'декілька секунд',
            m : uk__relativeTimeWithPlural,
            mm : uk__relativeTimeWithPlural,
            h : 'годину',
            hh : uk__relativeTimeWithPlural,
            d : 'день',
            dd : uk__relativeTimeWithPlural,
            M : 'місяць',
            MM : uk__relativeTimeWithPlural,
            y : 'рік',
            yy : uk__relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /ночі|ранку|дня|вечора/,
        isPM: function (input) {
            return /^(дня|вечора)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночі';
            } else if (hour < 12) {
                return 'ранку';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечора';
            }
        },
        ordinalParse: /\d{1,2}-(й|го)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return number + '-й';
            case 'D':
                return number + '-го';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : uzbek (uz)
    //! author : Sardor Muminov : https://github.com/muminoff

    var uz = _moment__default.defineLocale('uz', {
        months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
        monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
        weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
        weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'D MMMM YYYY, dddd LT'
        },
        calendar : {
            sameDay : '[Бугун соат] LT [да]',
            nextDay : '[Эртага] LT [да]',
            nextWeek : 'dddd [куни соат] LT [да]',
            lastDay : '[Кеча соат] LT [да]',
            lastWeek : '[Утган] dddd [куни соат] LT [да]',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'Якин %s ичида',
            past : 'Бир неча %s олдин',
            s : 'фурсат',
            m : 'бир дакика',
            mm : '%d дакика',
            h : 'бир соат',
            hh : '%d соат',
            d : 'бир кун',
            dd : '%d кун',
            M : 'бир ой',
            MM : '%d ой',
            y : 'бир йил',
            yy : '%d йил'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : vietnamese (vi)
    //! author : Bang Nguyen : https://github.com/bangnk

    var vi = _moment__default.defineLocale('vi', {
        months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [năm] YYYY',
            LLL : 'D MMMM [năm] YYYY LT',
            LLLL : 'dddd, D MMMM [năm] YYYY LT',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY LT',
            llll : 'ddd, D MMM YYYY LT'
        },
        calendar : {
            sameDay: '[Hôm nay lúc] LT',
            nextDay: '[Ngày mai lúc] LT',
            nextWeek: 'dddd [tuần tới lúc] LT',
            lastDay: '[Hôm qua lúc] LT',
            lastWeek: 'dddd [tuần rồi lúc] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s tới',
            past : '%s trước',
            s : 'vài giây',
            m : 'một phút',
            mm : '%d phút',
            h : 'một giờ',
            hh : '%d giờ',
            d : 'một ngày',
            dd : '%d ngày',
            M : 'một tháng',
            MM : '%d tháng',
            y : 'một năm',
            yy : '%d năm'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : chinese (zh-cn)
    //! author : suupic : https://github.com/suupic
    //! author : Zeno Zeng : https://github.com/zenozeng

    var zh_cn = _moment__default.defineLocale('zh-cn', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        longDateFormat : {
            LT : 'Ah点mm',
            LTS : 'Ah点m分s秒',
            L : 'YYYY-MM-DD',
            LL : 'YYYY年MMMD日',
            LLL : 'YYYY年MMMD日LT',
            LLLL : 'YYYY年MMMD日ddddLT',
            l : 'YYYY-MM-DD',
            ll : 'YYYY年MMMD日',
            lll : 'YYYY年MMMD日LT',
            llll : 'YYYY年MMMD日ddddLT'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' ||
                    meridiem === '上午') {
                return hour;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            } else {
                // '中午'
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar : {
            sameDay : function () {
                return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';
            },
            nextDay : function () {
                return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';
            },
            lastDay : function () {
                return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';
            },
            nextWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = _moment__default().startOf('week');
                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[下]' : '[本]';
                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
            },
            lastWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = _moment__default().startOf('week');
                prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
            },
            sameElse : 'LL'
        },
        ordinalParse: /\d{1,2}(日|月|周)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '日';
            case 'M':
                return number + '月';
            case 'w':
            case 'W':
                return number + '周';
            default:
                return number;
            }
        },
        relativeTime : {
            future : '%s内',
            past : '%s前',
            s : '几秒',
            m : '1分钟',
            mm : '%d分钟',
            h : '1小时',
            hh : '%d小时',
            d : '1天',
            dd : '%d天',
            M : '1个月',
            MM : '%d个月',
            y : '1年',
            yy : '%d年'
        },
        week : {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : traditional chinese (zh-tw)
    //! author : Ben : https://github.com/ben-lin

    var zh_tw = _moment__default.defineLocale('zh-tw', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        longDateFormat : {
            LT : 'Ah點mm',
            LTS : 'Ah點m分s秒',
            L : 'YYYY年MMMD日',
            LL : 'YYYY年MMMD日',
            LLL : 'YYYY年MMMD日LT',
            LLLL : 'YYYY年MMMD日ddddLT',
            l : 'YYYY年MMMD日',
            ll : 'YYYY年MMMD日',
            lll : 'YYYY年MMMD日LT',
            llll : 'YYYY年MMMD日ddddLT'
        },
        meridiemParse: /早上|上午|中午|下午|晚上/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar : {
            sameDay : '[今天]LT',
            nextDay : '[明天]LT',
            nextWeek : '[下]ddddLT',
            lastDay : '[昨天]LT',
            lastWeek : '[上]ddddLT',
            sameElse : 'L'
        },
        ordinalParse: /\d{1,2}(日|月|週)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '日';
            case 'M' :
                return number + '月';
            case 'w' :
            case 'W' :
                return number + '週';
            default :
                return number;
            }
        },
        relativeTime : {
            future : '%s內',
            past : '%s前',
            s : '幾秒',
            m : '一分鐘',
            mm : '%d分鐘',
            h : '一小時',
            hh : '%d小時',
            d : '一天',
            dd : '%d天',
            M : '一個月',
            MM : '%d個月',
            y : '一年',
            yy : '%d年'
        }
    });

    var moment_with_locales = _moment__default;

    return moment_with_locales;

}));
/**
 Five9 core API for web-based applications.

 @module opts
 @submodule Logger
 */
/**
 The logger is a configurable singleton for logging messages to the debug console, REST, and.or socket endpoints.

 @class Logger
 @static
 */
/*
 Design Goals

 Easy integration of logging into apps
 Uniform logging methodology / format across all apps
 Don't require programmers to initialize a separate logger in each module (performance/usability considerations)

 Important Tradeoffs:
 Restrict customization by individual apps to encourage uniformity of reporting
 and allow switching to other loggers if necessary
 */
define('logger',[
    "jquery",
    "underscore",
    "loggerBase",
    "local.storage",
    "moment"
  ],
  function($, _, LoggerBase, LocalStorage, Moment) {

    /**
     * The Logger Class
     *
     * @class Logger
     * @namespace
     * @constructor
     */
    var Logger = {

      // Properties
      // ------------
      collectorTypes: ["All","Clicks","Events"],
      appenderTypes: ["All","Console","Rest","Socket"],
      defaultSettings: {
        collectors: ["All"],
        appenders: "Console",
        vent: [],
        Rest: {
          uri: "http://localhost:8080/logs",
          batchSize: 10
        },
        Socket: {
          // can talk to either a socketAdapter or a socket uri
          uri: "",
          socketAdapter: null,
          batchSize: 10
        },
        eventLogBlacklist: []
      },
      settings: {},
      logger: null,
      jsonLayout: null,
      Events: {
        LOGGING_VENT_KEY: 'LOGGING_EVT'
      }
    };

    // Internal API
    // ------------
    var _appenderMap = {};

    Logger.addAppenders = function() {
      this.logger.removeAllAppenders();
      if (_.include(this.settings.appenders, "All")) {
        _.each(this.appenderTypes, function(element) {
          this.addAppender(element);
        }, this);
      }
      else {
        _.each(this.settings.appenders, function(element) {
          this.addAppender(element);
        }, this);
      }
    };
    Logger.addAppender = function(type) {
      if (type !== "All") {
        if(_appenderMap[type]) {
          return;
        }
        if (type === "Console") {
          _appenderMap[type] = this.addConsoleAppender();
        }
        if (type === "LocalStorage") {
          _appenderMap[type] = this.addLocalStorageAppender();
        }
      }
    };

    Logger.removeAppender = function(type) {
      var appender =_appenderMap[type];
      if(appender) {
        this.logger.removeAppender(appender);
        delete _appenderMap[type];
      }
    };

    Logger.addLocalStorageAppender = function() {
      var LocalStorageEventAppender = function () {
        this.append = function (loggingEvent) {
          var logString = this.getLayout().format(loggingEvent);
          LocalStorage.triggerAllPages(Logger.Events.LOGGING_VENT_KEY, logString);
        };
        this.toString = function () {
          return "LocalStorageEventAppender";
        };
      };

      LocalStorageEventAppender.prototype = new LoggerBase.Appender();


      var appender = new LocalStorageEventAppender();
      appender.setThreshold(LoggerBase.Level.ALL);
      appender.setLayout(new this.Five9MessageLayout());
      this.logger.addAppender(appender);
      return appender;
    };

    Logger.addConsoleAppender = function() {
      // browser console
      var consoleDebug = window.console.debug;
      var consoleInfo = window.console.info;
      var consoleWarn = window.console.warn;
      var consoleError = window.console.error;
      var consoleLog = window.console.log;

      var replaceConsoleMethods = function() {
        window.console.debug = function() {
          Logger.debug.apply(Logger, arguments);
        };
        window.console.info = function() {
          Logger.info.apply(Logger, arguments);
        };
        window.console.warn = function() {
          Logger.warn.apply(Logger, arguments);
        };
        window.console.error = function() {
          Logger.error.apply(Logger, arguments);
        };
        window.console.log = function() {
          Logger.info.apply(Logger, arguments);
        };
      };

      var restoreConsoleMethods = function() {
        window.console.debug = consoleDebug;
        window.console.info = consoleInfo;
        window.console.warn = consoleWarn;
        window.console.error = consoleError;
        window.console.log = consoleLog;
      };

      var CustomConsoleAppender = function() {
        this.append = function (loggingEvent) {
          restoreConsoleMethods();
          CustomConsoleAppender.prototype.append.apply(this, arguments);
          replaceConsoleMethods();
        };
        this.toString = function () {
          return "CustomConsoleAppender";
        };
      };

      CustomConsoleAppender.prototype = new LoggerBase.BrowserConsoleAppender();

      // browser console
      var appender = new CustomConsoleAppender();
      appender.setThreshold(LoggerBase.Level.ALL);
      appender.setLayout(new this.Five9MessageLayout());
      replaceConsoleMethods();
      this.logger.addAppender(appender);
      return appender;
    };

    Logger.addCollectors = function() {
      if (_.include(this.settings.collectors, "All")) {
        _.each(this.collectorTypes, function(element) {
          this.addCollector(element);
        }, this);
      }
      else {
        _.each(this.settings.collectors, function(element) {
          this.addCollector(element);
        }, this);
      }
    };
    Logger.addCollector = function(type) {
      if (type !== "All") {
        if (type === "Clicks") {
          this.addClickCollector();
        }
        if (type === "Events") {
          this.addEventsCollector();
        }
      }
    };
    Logger.addClickCollector = function() {
      $(document).on("click", null, _.bind(this.onClickCollector, this));
    };
    Logger.addEventsCollector = function() {
      _.each(this.settings.vent, function(element) {
        element.on("all", _.bind(Logger.onEventCollector, this));
      }, this);
    };
    Logger.onEventCollector = function(name, object) {
      if (name === "logger") {
        Logger.formatLoggerEvent(name, object);
      }
      else {
        Logger.formatStandardEvent(name, object);
      }
    };
    Logger.formatStandardEvent = function(name, object) {
      // standard events sent to debug
      var basicEvent = {
        name: name
      };
      if (object && typeof object === "string") {
        basicEvent.arg = object;
      }
      var detailEvent = {
        name: name,
        messageType: "event"
      };
      if (object) {
        detailEvent.arg = object;
      }

      // standard events sent to debug
      if (this.settings.eventLogBlacklist !== ['none'] && !_.contains(this.settings.eventLogBlacklist, name.toString())) {
        this.debug("event: "+Logger.safe_JSON_stringify(basicEvent), detailEvent.arg);
      }
    };
    Logger.formatLoggerEvent = function(name, object) {
      var type = this.mapTypeToMethod("debug");
      if ("type" in object) {
        type = this.mapTypeToMethod(object.type);
      }

      var message ='';
      if (object && typeof(object) === "object") {
        message += " : [";
        if ("message" in object) {
          message += object.message;
        }
        else {
          message += Logger.safe_JSON_stringify(object);
        }
        message += "]";
      }

      if (object) {
        type.apply(this, [message, object]);
      }
      else {
        type.apply(this, [message]);
      }
    };
    Logger.onClickCollector = function(e) {
      var target = e.target;
      var click = {
        tagType:target.tagName
      };
      if (target.id !== "") {
        click.target = target.id;
      }
      var classes = $(target).attr("class");
      if (classes) {
        click["class"] = classes;
      }
      // specific tags
      if (target.tagName === "A") {
        click.href = $(target).attr("href");
      }

      var detailClick = {
        messageType: "click"
      };
      detailClick = _.extend(detailClick, click);
      this.debug("click: "+Logger.safe_JSON_stringify(click), detailClick);
    };
    Logger.safe_JSON_stringify = function(o) {
      // hides circular refs
      // from http://stackoverflow.com/questions/11616630/json-stringify-avoid-typeerror-converting-circular-structure-to-json
      var i = 0;
      var maxRecursion = 100;
      var cache = [];
      var ret = JSON.stringify(o, function(key, value) {
        if (i > maxRecursion) {
          return;
        }

        if (typeof value === 'object' && value !== null) {
          if (cache.indexOf(value) !== -1) {
            // Circular reference found, discard key
            return;
          }
          // Store value in our collection
          cache.push(value);
        }
        i++;
        return value;
      });
      return ret;
    };

    var Five9MessageLayout = function() {
      var newLine = "\r\n";
      this.format = function(loggingEvent) {
        var logString;
        var prefix = Moment(loggingEvent.timeStamp).format('MM/DD/YYYY HH:mm:ss,SSS') + " [" + LocalStorage.getPageId() + "] [" +
          loggingEvent.level.toString().substring(0,3) + "] ";
        try {
          logString = prefix + Logger.safe_JSON_stringify(loggingEvent.messages);

          var exceptionString = _.result(loggingEvent, 'getThrowableStrRep', '');
          if(exceptionString) {
            logString += newLine + exceptionString;
          }
        } catch (e) {
          // problems with stringify, try to log with toString
          Logger.error(e);
          logString = prefix + loggingEvent.messages;
        }
        return logString;
      };
    };

    Five9MessageLayout.prototype = new LoggerBase.Layout();
    Logger.Five9MessageLayout = Five9MessageLayout;

    // Public API
    // ------------

    /**
     Specify the logger for use.

     @method initialize
     @param config Configuration parameters for the logger.
     @param {Array=["All"]} config.collectors The information the logger will collect automatically.  Options: ["All","Clicks","Events"]
     @param {Array=["Console"]} config.appenders The endpoints to send the log information.  Options: ["All","Console","Rest"]
     @param {Array} config.vent An array of event aggregator(s).  The logger will automatically collect events from these aggregators when "Events" is specified as a collector.
     @param config.Rest Configuration parameters for the Rest endpoint.
     @param config.Socket Configuration parameters for the Socket endpoint.

     @example
     Logger.initialize({
      appenders: ["Console","Rest"],
      collectors: ["All"],
      vent: [Five9,Five9.vent],
      Rest: {
        uri: "http://localhost:"+port+"/logs",
        batchSize: 10
      }
    });
     */
    Logger.initialize = function(config) {
      this.settings = $.extend(true, this.defaultSettings, config);

      var logger = LoggerBase.getLogger("client");
      // internal method to hide non-api methods
      this.logger = logger;

      this.jsonLayout = new LoggerBase.JsonLayout(true, false);

      // global config items
      LoggerBase.setEnabled(true);
      LoggerBase.logLog.setQuietMode(true);
      LoggerBase.setShowStackTraces(true);

      this.addAppenders();
      this.addCollectors();
      this.debug("Logger::initialize {["+this.settings.appenders+"],["+this.settings.collectors+"]}");
    };
    /**
     Set a custom field to be added to every log message.  If there is already a custom field with the specified name, its value will be updated with value.

     @method setCustomField
     @param {String} name Name of the custom property included in the formatted output
     @param {Object} value Value of the custom property included in the formatted output.  This value may be a function (which will receive two parameters: layout, loggingEvent).
     */
    Logger.setCustomField = function(name, value) {
      if (this.jsonLayout) {
        this.jsonLayout.setCustomField(name, value);
      }
    };
    /**
     Retrieve various information from the browser

     @method getBrowserSettings
     @return {Object} browser settings
     */
    Logger.getBrowserSettings = function() {
      var settings = {};
      if (window && window.screen) {
        settings.resolution = {
          width: window.screen.width,
          height: window.screen.height
        };
      }
      return settings;
    };

    // pass-throughs (see tradeoffs)
    // ------------

    /**
     Log a message to the logger using [debug] level

     @method debug
     @param message
     @param object This object can be viewed/expanded in the console appender.  The entire contents of the object will be sent as JSON to the Rest endpoint.
     */
    Logger.debug = function() {
      if (this.logger) {
        this.logger.debug.apply(this.logger, arguments);
      }
    };
    /**
     Log a message to the logger using [info] level

     @method info
     @param message
     @param object This object can be viewed/expanded in the console appender.  The entire contents of the object will be sent as JSON to the Rest endpoint.
     */
    Logger.info = function() {
      if (this.logger) {
        this.logger.info.apply(this.logger, arguments);
      }
    };
    /**
     Log a message to the logger using [warn] level

     @method warn
     @param message
     @param object This object can be viewed/expanded in the console appender.  The entire contents of the object will be sent as JSON to the Rest endpoint.
     */
    Logger.warn = function() {
      if (this.logger) {
        this.logger.warn.apply(this.logger, arguments);
      }
    };
    /**
     Log a message to the logger using [error] level

     @method error
     @param message
     @param object This object can be viewed/expanded in the console appender.  The entire contents of the object will be sent as JSON to the Rest endpoint.
     */
    Logger.error = function() {
      var mainArguments = Array.prototype.slice.call(arguments);
      if (mainArguments.length > 0 && mainArguments[0] instanceof Error) {
        // Workaround for log4javascript error: Not detecting exception as first argument
        mainArguments.unshift("Exception: ");
      }
      if (this.logger) {
        this.logger.error.apply(this.logger, mainArguments);
      }
    };
    Logger.nullMethod = function() {
    };
    Logger.mapTypeToMethod = function(type) {
      // filter types
      if (type === "debug") {
        return this.debug;
      }
      if (type === "info") {
        return this.info;
      }
      if (type === "warn") {
        return this.warn;
      }
      if (type === "error") {
        return this.error;
      }
      return this.nullMethod;
    };

    return Logger;
  });

(function(root) {
define("pnotify", ["jquery"], function() {
  return (function() {
/*
 * jQuery Pines Notify (pnotify) Plugin 1.2.2
 *
 * http://pinesframework.org/pnotify/
 * Copyright (c) 2009-2012 Hunter Perrin
 *
 * Triple license under the GPL, LGPL, and MPL:
 *	  http://www.gnu.org/licenses/gpl.html
 *	  http://www.gnu.org/licenses/lgpl.html
 *	  http://www.mozilla.org/MPL/MPL-1.1.html
 */

(function($) {
	var history_handle_top,
		timer,
		body,
		jwindow = $(window),
		styling = {
			jqueryui: {
				container: "ui-widget ui-widget-content ui-corner-all",
				notice: "ui-state-highlight",
				// (The actual jQUI notice icon looks terrible.)
				notice_icon: "ui-icon ui-icon-info",
				info: "",
				info_icon: "ui-icon ui-icon-info",
				success: "ui-state-default",
				success_icon: "ui-icon ui-icon-circle-check",
				error: "ui-state-error",
				error_icon: "ui-icon ui-icon-alert",
				closer: "ui-icon ui-icon-close",
				pin_up: "ui-icon ui-icon-pin-w",
				pin_down: "ui-icon ui-icon-pin-s",
				hi_menu: "ui-state-default ui-corner-bottom",
				hi_btn: "ui-state-default ui-corner-all",
				hi_btnhov: "ui-state-hover",
				hi_hnd: "ui-icon ui-icon-grip-dotted-horizontal"
			},
			bootstrap: {
				container: "alert",
				notice: "",
				notice_icon: "icon-exclamation-sign",
				info: "alert-info",
				info_icon: "icon-info-sign",
				success: "alert-success",
				success_icon: "icon-ok-sign",
				error: "alert-error",
				error_icon: "icon-warning-sign",
				closer: "icon-remove",
				pin_up: "icon-pause",
				pin_down: "icon-play",
				hi_menu: "well",
				hi_btn: "btn",
				hi_btnhov: "",
				hi_hnd: "icon-chevron-down"
			}
		};
	// Set global variables.
	var do_when_ready = function(){
		body = $("body");
		jwindow = $(window);
		// Reposition the notices when the window resizes.
		jwindow.bind('resize', function(){
			if (timer)
				clearTimeout(timer);
			timer = setTimeout($.pnotify_position_all, 10);
		});
	};
	if (document.body)
		do_when_ready();
	else
		$(do_when_ready);
	$.extend({
		pnotify_remove_all: function () {
			var notices_data = jwindow.data("pnotify");
			/* POA: Added null-check */
			if (notices_data && notices_data.length) {
				$.each(notices_data, function(){
					if (this.pnotify_remove)
						this.pnotify_remove();
				});
			}
		},
		pnotify_position_all: function () {
			// This timer is used for queueing this function so it doesn't run
			// repeatedly.
			if (timer)
				clearTimeout(timer);
			timer = null;
			// Get all the notices.
			var notices_data = jwindow.data("pnotify");
			if (!notices_data || !notices_data.length)
				return;
			// Reset the next position data.
			$.each(notices_data, function(){
				var s = this.opts.stack;
				if (!s) return;
				s.nextpos1 = s.firstpos1;
				s.nextpos2 = s.firstpos2;
				s.addpos2 = 0;
				s.animation = true;
			});
			$.each(notices_data, function(){
				this.pnotify_position();
			});
		},
		pnotify: function(options) {
			// Stores what is currently being animated (in or out).
			var animating;

			// Build main options.
			var opts;
			if (typeof options != "object") {
				opts = $.extend({}, $.pnotify.defaults);
				opts.text = options;
			} else {
				opts = $.extend({}, $.pnotify.defaults, options);
			}
			// Translate old pnotify_ style options.
			for (var i in opts) {
				if (typeof i == "string" && i.match(/^pnotify_/))
					opts[i.replace(/^pnotify_/, "")] = opts[i];
			}

			if (opts.before_init) {
				if (opts.before_init(opts) === false)
					return null;
			}

			// This keeps track of the last element the mouse was over, so
			// mouseleave, mouseenter, etc can be called.
			var nonblock_last_elem;
			// This is used to pass events through the notice if it is non-blocking.
			var nonblock_pass = function(e, e_name){
				pnotify.css("display", "none");
				var element_below = document.elementFromPoint(e.clientX, e.clientY);
				pnotify.css("display", "block");
				var jelement_below = $(element_below);
				var cursor_style = jelement_below.css("cursor");
				pnotify.css("cursor", cursor_style != "auto" ? cursor_style : "default");
				// If the element changed, call mouseenter, mouseleave, etc.
				if (!nonblock_last_elem || nonblock_last_elem.get(0) != element_below) {
					if (nonblock_last_elem) {
						dom_event.call(nonblock_last_elem.get(0), "mouseleave", e.originalEvent);
						dom_event.call(nonblock_last_elem.get(0), "mouseout", e.originalEvent);
					}
					dom_event.call(element_below, "mouseenter", e.originalEvent);
					dom_event.call(element_below, "mouseover", e.originalEvent);
				}
				dom_event.call(element_below, e_name, e.originalEvent);
				// Remember the latest element the mouse was over.
				nonblock_last_elem = jelement_below;
			};

			// Get our styling object.
			var styles = styling[opts.styling];

			// Create our widget.
			// Stop animation, reset the removal timer, and show the close
			// button when the user mouses over.
			var pnotify = $("<div />", {
				"class": "ui-pnotify "+opts.addclass,
				"css": {"display": "none"},
				"mouseenter": function(e){
					if (opts.nonblock) e.stopPropagation();
					if (opts.mouse_reset && animating == "out") {
						// If it's animating out, animate back in really quickly.
						pnotify.stop(true);
						animating = "in";
						pnotify.css("height", "auto").animate({"width": opts.width, "opacity": opts.nonblock ? opts.nonblock_opacity : opts.opacity}, "fast");
					}
					if (opts.nonblock) {
						// If it's non-blocking, animate to the other opacity.
						pnotify.animate({"opacity": opts.nonblock_opacity}, "fast");
					}
					// Stop the close timer.
					if (opts.hide && opts.mouse_reset) pnotify.pnotify_cancel_remove();
					// Show the buttons.
					if (opts.sticker && !opts.nonblock) pnotify.sticker.trigger("pnotify_icon").css("visibility", "visible");
					if (opts.closer && !opts.nonblock) pnotify.closer.css("visibility", "visible");
				},
				"mouseleave": function(e){
					if (opts.nonblock) e.stopPropagation();
					nonblock_last_elem = null;
					pnotify.css("cursor", "auto");
					// Animate back to the normal opacity.
					if (opts.nonblock && animating != "out")
						pnotify.animate({"opacity": opts.opacity}, "fast");
					// Start the close timer.
					if (opts.hide && opts.mouse_reset) pnotify.pnotify_queue_remove();
					// Hide the buttons.
					if (opts.sticker_hover)
						pnotify.sticker.css("visibility", "hidden");
					if (opts.closer_hover)
						pnotify.closer.css("visibility", "hidden");
					$.pnotify_position_all();
				},
				"mouseover": function(e){
					if (opts.nonblock) e.stopPropagation();
				},
				"mouseout": function(e){
					if (opts.nonblock) e.stopPropagation();
				},
				"mousemove": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						nonblock_pass(e, "onmousemove");
					}
				},
				"mousedown": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						e.preventDefault();
						nonblock_pass(e, "onmousedown");
					}
				},
				"mouseup": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						e.preventDefault();
						nonblock_pass(e, "onmouseup");
					}
				},
				"click": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						nonblock_pass(e, "onclick");
					}
				},
				"dblclick": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						nonblock_pass(e, "ondblclick");
					}
				}
			});
			pnotify.opts = opts;
			// Create a container for the notice contents.
			pnotify.container = $("<div />", {"class": styles.container+" ui-pnotify-container "+(opts.type == "error" ? styles.error : (opts.type == "info" ? styles.info : (opts.type == "success" ? styles.success : styles.notice)))})
			.appendTo(pnotify);
			if (opts.cornerclass != "")
				pnotify.container.removeClass("ui-corner-all").addClass(opts.cornerclass);
			// Create a drop shadow.
			if (opts.shadow)
				pnotify.container.addClass("ui-pnotify-shadow");

			// The current version of Pines Notify.
			pnotify.pnotify_version = "1.2.2";

			// This function is for updating the notice.
			pnotify.pnotify = function(options) {
				// Update the notice.
				var old_opts = opts;
				if (typeof options == "string")
					opts.text = options;
				else
					opts = $.extend({}, opts, options);
				// Translate old pnotify_ style options.
				for (var i in opts) {
					if (typeof i == "string" && i.match(/^pnotify_/))
						opts[i.replace(/^pnotify_/, "")] = opts[i];
				}
				pnotify.opts = opts;
				// Update the corner class.
				if (opts.cornerclass != old_opts.cornerclass)
					pnotify.container.removeClass("ui-corner-all").addClass(opts.cornerclass);
				// Update the shadow.
				if (opts.shadow != old_opts.shadow) {
					if (opts.shadow)
						pnotify.container.addClass("ui-pnotify-shadow");
					else
						pnotify.container.removeClass("ui-pnotify-shadow");
				}
				// Update the additional classes.
				if (opts.addclass === false)
					pnotify.removeClass(old_opts.addclass);
				else if (opts.addclass !== old_opts.addclass)
					pnotify.removeClass(old_opts.addclass).addClass(opts.addclass);
				// Update the title.
				if (opts.title === false)
					pnotify.title_container.slideUp("fast");
				else if (opts.title !== old_opts.title) {
					if (opts.title_escape)
						pnotify.title_container.text(opts.title).slideDown(200);
					else
						pnotify.title_container.html(opts.title).slideDown(200);
				}
				// Update the text.
				if (opts.text === false) {
					pnotify.text_container.slideUp("fast");
				} else if (opts.text !== old_opts.text) {
					if (opts.text_escape)
						pnotify.text_container.text(opts.text).slideDown(200);
					else
						pnotify.text_container.html(opts.insert_brs ? String(opts.text).replace(/\n/g, "<br />") : opts.text).slideDown(200);
				}
				// Update values for history menu access.
				pnotify.pnotify_history = opts.history;
				pnotify.pnotify_hide = opts.hide;
				// Change the notice type.
				if (opts.type != old_opts.type)
					pnotify.container.removeClass(styles.error+" "+styles.notice+" "+styles.success+" "+styles.info).addClass(opts.type == "error" ? styles.error : (opts.type == "info" ? styles.info : (opts.type == "success" ? styles.success : styles.notice)));
				if (opts.icon !== old_opts.icon || (opts.icon === true && opts.type != old_opts.type)) {
					// Remove any old icon.
					pnotify.container.find("div.ui-pnotify-icon").remove();
					if (opts.icon !== false) {
						// Build the new icon.
						$("<div />", {"class": "ui-pnotify-icon"})
						.append($("<span />", {"class": opts.icon === true ? (opts.type == "error" ? styles.error_icon : (opts.type == "info" ? styles.info_icon : (opts.type == "success" ? styles.success_icon : styles.notice_icon))) : opts.icon}))
						.prependTo(pnotify.container);
					}
				}
				// Update the width.
				if (opts.width !== old_opts.width)
					pnotify.animate({width: opts.width});
				// Update the minimum height.
				if (opts.min_height !== old_opts.min_height)
					pnotify.container.animate({minHeight: opts.min_height});
				// Update the opacity.
				if (opts.opacity !== old_opts.opacity)
					pnotify.fadeTo(opts.animate_speed, opts.opacity);
				// Update the sticker and closer buttons.
				if (!opts.closer || opts.nonblock)
					pnotify.closer.css("display", "none");
				else
					pnotify.closer.css("display", "block");
				if (!opts.sticker || opts.nonblock)
					pnotify.sticker.css("display", "none");
				else
					pnotify.sticker.css("display", "block");
				// Update the sticker icon.
				pnotify.sticker.trigger("pnotify_icon");
				// Update the hover status of the buttons.
				if (opts.sticker_hover)
					pnotify.sticker.css("visibility", "hidden");
				else if (!opts.nonblock)
					pnotify.sticker.css("visibility", "visible");
				if (opts.closer_hover)
					pnotify.closer.css("visibility", "hidden");
				else if (!opts.nonblock)
					pnotify.closer.css("visibility", "visible");
				// Update the timed hiding.
				if (!opts.hide)
					pnotify.pnotify_cancel_remove();
				else if (!old_opts.hide)
					pnotify.pnotify_queue_remove();
				pnotify.pnotify_queue_position();
				return pnotify;
			};

			// Position the notice. dont_skip_hidden causes the notice to
			// position even if it's not visible.
			pnotify.pnotify_position = function(dont_skip_hidden){
				// Get the notice's stack.
				var s = pnotify.opts.stack;
				if (!s) return;
				if (!s.nextpos1)
					s.nextpos1 = s.firstpos1;
				if (!s.nextpos2)
					s.nextpos2 = s.firstpos2;
				if (!s.addpos2)
					s.addpos2 = 0;
				var hidden = pnotify.css("display") == "none";
				// Skip this notice if it's not shown.
				if (!hidden || dont_skip_hidden) {
					var curpos1, curpos2;
					// Store what will need to be animated.
					var animate = {};
					// Calculate the current pos1 value.
					var csspos1;
					switch (s.dir1) {
						case "down":
							csspos1 = "top";
							break;
						case "up":
							csspos1 = "bottom";
							break;
						case "left":
							csspos1 = "right";
							break;
						case "right":
							csspos1 = "left";
							break;
					}
					curpos1 = parseInt(pnotify.css(csspos1));
					if (isNaN(curpos1))
						curpos1 = 0;
					// Remember the first pos1, so the first visible notice goes there.
					if (typeof s.firstpos1 == "undefined" && !hidden) {
						s.firstpos1 = curpos1;
						s.nextpos1 = s.firstpos1;
					}
					// Calculate the current pos2 value.
					var csspos2;
					switch (s.dir2) {
						case "down":
							csspos2 = "top";
							break;
						case "up":
							csspos2 = "bottom";
							break;
						case "left":
							csspos2 = "right";
							break;
						case "right":
							csspos2 = "left";
							break;
					}
					curpos2 = parseInt(pnotify.css(csspos2));
					if (isNaN(curpos2))
						curpos2 = 0;
					// Remember the first pos2, so the first visible notice goes there.
					if (typeof s.firstpos2 == "undefined" && !hidden) {
						s.firstpos2 = curpos2;
						s.nextpos2 = s.firstpos2;
					}
					// Check that it's not beyond the viewport edge.
					if ((s.dir1 == "down" && s.nextpos1 + pnotify.height() > jwindow.height()) ||
						(s.dir1 == "up" && s.nextpos1 + pnotify.height() > jwindow.height()) ||
						(s.dir1 == "left" && s.nextpos1 + pnotify.width() > jwindow.width()) ||
						(s.dir1 == "right" && s.nextpos1 + pnotify.width() > jwindow.width()) ) {
						// If it is, it needs to go back to the first pos1, and over on pos2.
						s.nextpos1 = s.firstpos1;
						s.nextpos2 += s.addpos2 + (typeof s.spacing2 == "undefined" ? 25 : s.spacing2);
						s.addpos2 = 0;
					}
					// Animate if we're moving on dir2.
					if (s.animation && s.nextpos2 < curpos2) {
						switch (s.dir2) {
							case "down":
								animate.top = s.nextpos2+"px";
								break;
							case "up":
								animate.bottom = s.nextpos2+"px";
								break;
							case "left":
								animate.right = s.nextpos2+"px";
								break;
							case "right":
								animate.left = s.nextpos2+"px";
								break;
						}
					} else
						pnotify.css(csspos2, s.nextpos2+"px");
					// Keep track of the widest/tallest notice in the column/row, so we can push the next column/row.
					switch (s.dir2) {
						case "down":
						case "up":
							if (pnotify.outerHeight(true) > s.addpos2)
								s.addpos2 = pnotify.height();
							break;
						case "left":
						case "right":
							if (pnotify.outerWidth(true) > s.addpos2)
								s.addpos2 = pnotify.width();
							break;
					}
					// Move the notice on dir1.
					if (s.nextpos1) {
						// Animate if we're moving toward the first pos.
						if (s.animation && (curpos1 > s.nextpos1 || animate.top || animate.bottom || animate.right || animate.left)) {
							switch (s.dir1) {
								case "down":
									animate.top = s.nextpos1+"px";
									break;
								case "up":
									animate.bottom = s.nextpos1+"px";
									break;
								case "left":
									animate.right = s.nextpos1+"px";
									break;
								case "right":
									animate.left = s.nextpos1+"px";
									break;
							}
						} else
							pnotify.css(csspos1, s.nextpos1+"px");
					}
					// Run the animation.
					if (animate.top || animate.bottom || animate.right || animate.left)
						pnotify.animate(animate, {duration: 500, queue: false});
					// Calculate the next dir1 position.
					switch (s.dir1) {
						case "down":
						case "up":
							s.nextpos1 += pnotify.height() + (typeof s.spacing1 == "undefined" ? 25 : s.spacing1);
							break;
						case "left":
						case "right":
							s.nextpos1 += pnotify.width() + (typeof s.spacing1 == "undefined" ? 25 : s.spacing1);
							break;
					}
				}
			};

			// Queue the positiona all function so it doesn't run repeatedly and
			// use up resources.
			pnotify.pnotify_queue_position = function(milliseconds){
				if (timer)
					clearTimeout(timer);
				if (!milliseconds)
					milliseconds = 10;
				timer = setTimeout($.pnotify_position_all, milliseconds);
			};

			// Display the notice.
			pnotify.pnotify_display = function() {
				// If the notice is not in the DOM, append it.
				if (!pnotify.parent().length)
					pnotify.appendTo(body);
				// Run callback.
				if (opts.before_open) {
					if (opts.before_open(pnotify) === false)
						return;
				}
				// Try to put it in the right position.
				if (opts.stack.push != "top")
					pnotify.pnotify_position(true);
				// First show it, then set its opacity, then hide it.
				if (opts.animation == "fade" || opts.animation.effect_in == "fade") {
					// If it's fading in, it should start at 0.
					pnotify.show().fadeTo(0, 0).hide();
				} else {
					// Or else it should be set to the opacity.
					if (opts.opacity != 1)
						pnotify.show().fadeTo(0, opts.opacity).hide();
				}
				pnotify.animate_in(function(){
					if (opts.after_open)
						opts.after_open(pnotify);

					pnotify.pnotify_queue_position();

					// Now set it to hide.
					if (opts.hide)
						pnotify.pnotify_queue_remove();
				});
			};

			// Remove the notice.
			pnotify.pnotify_remove = function() {
				if (pnotify.timer) {
					window.clearTimeout(pnotify.timer);
					pnotify.timer = null;
				}
				// Run callback.
				if (opts.before_close) {
					if (opts.before_close(pnotify) === false)
						return;
				}
				pnotify.animate_out(function(){
					if (opts.after_close) {
						if (opts.after_close(pnotify) === false)
							return;
					}
					pnotify.pnotify_queue_position();
					// If we're supposed to remove the notice from the DOM, do it.
					if (opts.remove)
						pnotify.detach();
				});
			};

			// Animate the notice in.
			pnotify.animate_in = function(callback){
				// Declare that the notice is animating in. (Or has completed animating in.)
				animating = "in";
				var animation;
				if (typeof opts.animation.effect_in != "undefined")
					animation = opts.animation.effect_in;
				else
					animation = opts.animation;
				if (animation == "none") {
					pnotify.show();
					callback();
				} else if (animation == "show")
					pnotify.show(opts.animate_speed, callback);
				else if (animation == "fade")
					pnotify.show().fadeTo(opts.animate_speed, opts.opacity, callback);
				else if (animation == "slide")
					pnotify.slideDown(opts.animate_speed, callback);
				else if (typeof animation == "function")
					animation("in", callback, pnotify);
				else
					pnotify.show(animation, (typeof opts.animation.options_in == "object" ? opts.animation.options_in : {}), opts.animate_speed, callback);
			};

			// Animate the notice out.
			pnotify.animate_out = function(callback){
				// Declare that the notice is animating out. (Or has completed animating out.)
				animating = "out";
				var animation;
				if (typeof opts.animation.effect_out != "undefined")
					animation = opts.animation.effect_out;
				else
					animation = opts.animation;
				if (animation == "none") {
					pnotify.hide();
					callback();
				} else if (animation == "show")
					pnotify.hide(opts.animate_speed, callback);
				else if (animation == "fade")
					pnotify.fadeOut(opts.animate_speed, callback);
				else if (animation == "slide")
					pnotify.slideUp(opts.animate_speed, callback);
				else if (typeof animation == "function")
					animation("out", callback, pnotify);
				else
					pnotify.hide(animation, (typeof opts.animation.options_out == "object" ? opts.animation.options_out : {}), opts.animate_speed, callback);
			};

			// Cancel any pending removal timer.
			pnotify.pnotify_cancel_remove = function() {
				if (pnotify.timer)
					window.clearTimeout(pnotify.timer);
			};

			// Queue a removal timer.
			pnotify.pnotify_queue_remove = function() {
				// Cancel any current removal timer.
				pnotify.pnotify_cancel_remove();
				pnotify.timer = window.setTimeout(function(){
					pnotify.pnotify_remove();
				}, (isNaN(opts.delay) ? 0 : opts.delay));
			};

			// Provide a button to close the notice.
			pnotify.closer = $("<div />", {
				"class": "ui-pnotify-closer",
				"css": {"cursor": "pointer", "visibility": opts.closer_hover ? "hidden" : "visible"},
				"click": function(){
					pnotify.pnotify_remove();
					pnotify.sticker.css("visibility", "hidden");
					pnotify.closer.css("visibility", "hidden");
				}
			})
			.append($("<span />", {"class": styles.closer}))
			.appendTo(pnotify.container);
			if (!opts.closer || opts.nonblock)
				pnotify.closer.css("display", "none");

			// Provide a button to stick the notice.
			pnotify.sticker = $("<div />", {
				"class": "ui-pnotify-sticker",
				"css": {"cursor": "pointer", "visibility": opts.sticker_hover ? "hidden" : "visible"},
				"click": function(){
					opts.hide = !opts.hide;
					if (opts.hide)
						pnotify.pnotify_queue_remove();
					else
						pnotify.pnotify_cancel_remove();
					$(this).trigger("pnotify_icon");
				}
			})
			.bind("pnotify_icon", function(){
				$(this).children().removeClass(styles.pin_up+" "+styles.pin_down).addClass(opts.hide ? styles.pin_up : styles.pin_down);
			})
			.append($("<span />", {"class": styles.pin_up}))
			.appendTo(pnotify.container);
			if (!opts.sticker || opts.nonblock)
				pnotify.sticker.css("display", "none");

			// Add the appropriate icon.
			if (opts.icon !== false) {
				$("<div />", {"class": "ui-pnotify-icon"})
				.append($("<span />", {"class": opts.icon === true ? (opts.type == "error" ? styles.error_icon : (opts.type == "info" ? styles.info_icon : (opts.type == "success" ? styles.success_icon : styles.notice_icon))) : opts.icon}))
				.prependTo(pnotify.container);
			}

			// Add a title.
			pnotify.title_container = $("<h4 />", {
				"class": "ui-pnotify-title"
			})
			.appendTo(pnotify.container);
			if (opts.title === false)
				pnotify.title_container.hide();
			else if (opts.title_escape)
				pnotify.title_container.text(opts.title);
			else
				pnotify.title_container.html(opts.title);

			// Add text.
			pnotify.text_container = $("<div />", {
				"class": "ui-pnotify-text"
			})
			.appendTo(pnotify.container);
			if (opts.text === false)
				pnotify.text_container.hide();
			else if (opts.text_escape)
				pnotify.text_container.text(opts.text);
			else
				pnotify.text_container.html(opts.insert_brs ? String(opts.text).replace(/\n/g, "<br />") : opts.text);

			// Set width and min height.
			if (typeof opts.width == "string")
				pnotify.css("width", opts.width);
			if (typeof opts.min_height == "string")
				pnotify.container.css("min-height", opts.min_height);

			// The history variable controls whether the notice gets redisplayed
			// by the history pull down.
			pnotify.pnotify_history = opts.history;
			// The hide variable controls whether the history pull down should
			// queue a removal timer.
			pnotify.pnotify_hide = opts.hide;

			// Add the notice to the notice array.
			var notices_data = jwindow.data("pnotify");
			if (notices_data == null || typeof notices_data != "object")
				notices_data = [];
			if (opts.stack.push == "top")
				notices_data = $.merge([pnotify], notices_data);
			else
				notices_data = $.merge(notices_data, [pnotify]);
			jwindow.data("pnotify", notices_data);
			// Now position all the notices if they are to push to the top.
			if (opts.stack.push == "top")
				pnotify.pnotify_queue_position(1);

			// Run callback.
			if (opts.after_init)
				opts.after_init(pnotify);

			if (opts.history) {
				// If there isn't a history pull down, create one.
				var history_menu = jwindow.data("pnotify_history");
				if (typeof history_menu == "undefined") {
					history_menu = $("<div />", {
						"class": "ui-pnotify-history-container "+styles.hi_menu,
						"mouseleave": function(){
							history_menu.animate({top: "-"+history_handle_top+"px"}, {duration: 100, queue: false});
						}
					})
					.append($("<div />", {"class": "ui-pnotify-history-header", "text": "Redisplay"}))
					.append($("<button />", {
							"class": "ui-pnotify-history-all "+styles.hi_btn,
							"text": "All",
							"mouseenter": function(){
								$(this).addClass(styles.hi_btnhov);
							},
							"mouseleave": function(){
								$(this).removeClass(styles.hi_btnhov);
							},
							"click": function(){
								// Display all notices. (Disregarding non-history notices.)
								$.each(notices_data, function(){
									if (this.pnotify_history) {
										if (this.is(":visible")) {
											if (this.pnotify_hide)
												this.pnotify_queue_remove();
										} else if (this.pnotify_display)
											this.pnotify_display();
									}
								});
								return false;
							}
					}))
					.append($("<button />", {
							"class": "ui-pnotify-history-last "+styles.hi_btn,
							"text": "Last",
							"mouseenter": function(){
								$(this).addClass(styles.hi_btnhov);
							},
							"mouseleave": function(){
								$(this).removeClass(styles.hi_btnhov);
							},
							"click": function(){
								// Look up the last history notice, and display it.
								var i = -1;
								var notice;
								do {
									if (i == -1)
										notice = notices_data.slice(i);
									else
										notice = notices_data.slice(i, i+1);
									if (!notice[0])
										break;
									i--;
								} while (!notice[0].pnotify_history || notice[0].is(":visible"));
								if (!notice[0])
									return false;
								if (notice[0].pnotify_display)
									notice[0].pnotify_display();
								return false;
							}
					}))
					.appendTo(body);

					// Make a handle so the user can pull down the history tab.
					var handle = $("<span />", {
						"class": "ui-pnotify-history-pulldown "+styles.hi_hnd,
						"mouseenter": function(){
							history_menu.animate({top: "0"}, {duration: 100, queue: false});
						}
					})
					.appendTo(history_menu);

					// Get the top of the handle.
					history_handle_top = handle.offset().top + 2;
					// Hide the history pull down up to the top of the handle.
					history_menu.css({top: "-"+history_handle_top+"px"});
					// Save the history pull down.
					jwindow.data("pnotify_history", history_menu);
				}
			}

			// Mark the stack so it won't animate the new notice.
			opts.stack.animation = false;

			// Display the notice.
			if (opts.auto_display)
				pnotify.pnotify_display();

			return pnotify;
		}
	});

	// Some useful regexes.
	var re_on = /^on/,
		re_mouse_events = /^(dbl)?click$|^mouse(move|down|up|over|out|enter|leave)$|^contextmenu$/,
		re_ui_events = /^(focus|blur|select|change|reset)$|^key(press|down|up)$/,
		re_html_events = /^(scroll|resize|(un)?load|abort|error)$/;
	// Fire a DOM event.
	var dom_event = function(e, orig_e){
		var event_object;
		e = e.toLowerCase();
		if (document.createEvent && this.dispatchEvent) {
			// FireFox, Opera, Safari, Chrome
			e = e.replace(re_on, '');
			if (e.match(re_mouse_events)) {
				// This allows the click event to fire on the notice. There is
				// probably a much better way to do it.
				$(this).offset();
				event_object = document.createEvent("MouseEvents");
				event_object.initMouseEvent(
					e, orig_e.bubbles, orig_e.cancelable, orig_e.view, orig_e.detail,
					orig_e.screenX, orig_e.screenY, orig_e.clientX, orig_e.clientY,
					orig_e.ctrlKey, orig_e.altKey, orig_e.shiftKey, orig_e.metaKey, orig_e.button, orig_e.relatedTarget
				);
			} else if (e.match(re_ui_events)) {
				event_object = document.createEvent("UIEvents");
				event_object.initUIEvent(e, orig_e.bubbles, orig_e.cancelable, orig_e.view, orig_e.detail);
			} else if (e.match(re_html_events)) {
				event_object = document.createEvent("HTMLEvents");
				event_object.initEvent(e, orig_e.bubbles, orig_e.cancelable);
			}
			if (!event_object) return;
			this.dispatchEvent(event_object);
		} else {
			// Internet Explorer
			if (!e.match(re_on)) e = "on"+e;
			event_object = document.createEventObject(orig_e);
			this.fireEvent(e, event_object);
		}
	};

	$.pnotify.defaults = {
		// The notice's title.
		title: false,
		// Whether to escape the content of the title. (Not allow HTML.)
		title_escape: false,
		// The notice's text.
		text: false,
		// Whether to escape the content of the text. (Not allow HTML.)
		text_escape: false,
		// What styling classes to use. (Can be either jqueryui or bootstrap.)
		styling: "bootstrap",
		// Additional classes to be added to the notice. (For custom styling.)
		addclass: "",
		// Class to be added to the notice for corner styling.
		cornerclass: "",
		// Create a non-blocking notice. It lets the user click elements underneath it.
		nonblock: false,
		// The opacity of the notice (if it's non-blocking) when the mouse is over it.
		nonblock_opacity: .2,
		// Display a pull down menu to redisplay previous notices, and place the notice in the history.
		history: true,
		// Display the notice when it is created. Turn this off to add notifications to the history without displaying them.
		auto_display: true,
		// Width of the notice.
		width: "300px",
		// Minimum height of the notice. It will expand to fit content.
		min_height: "16px",
		// Type of the notice. "notice", "info", "success", or "error".
		type: "notice",
		// Set icon to true to use the default icon for the selected style/type, false for no icon, or a string for your own icon class.
		icon: true,
		// The animation to use when displaying and hiding the notice. "none", "show", "fade", and "slide" are built in to jQuery. Others require jQuery UI. Use an object with effect_in and effect_out to use different effects.
		animation: "fade",
		// Speed at which the notice animates in and out. "slow", "def" or "normal", "fast" or number of milliseconds.
		animate_speed: "slow",
		// Opacity of the notice.
		opacity: 1,
		// Display a drop shadow.
		shadow: true,
		// Provide a button for the user to manually close the notice.
		closer: true,
		// Only show the closer button on hover.
		closer_hover: true,
		// Provide a button for the user to manually stick the notice.
		sticker: true,
		// Only show the sticker button on hover.
		sticker_hover: true,
		// After a delay, remove the notice.
		hide: true,
		// Delay in milliseconds before the notice is removed.
		delay: 8000,
		// Reset the hide timer if the mouse moves over the notice.
		mouse_reset: true,
		// Remove the notice's elements from the DOM after it is removed.
		remove: true,
		// Change new lines to br tags.
		insert_brs: true,
		// The stack on which the notices will be placed. Also controls the direction the notices stack.
		stack: {"dir1": "down", "dir2": "left", "push": "bottom", "spacing1": 25, "spacing2": 25}
	};
})(jQuery);

  }).apply(root, arguments);
});
}(this));

define('websocketjs',[],
function () {
  if (window.WebSocket) {
    return;
  } else if (window.MozWebSocket) {
    // Firefox.
    window.WebSocket = MozWebSocket;
    return;
  }

  console.error("WebSocket NOT supported by your browser!!!");
  return;
});

/**
 Five9 core API for web-based applications.

 @module Five9
 */
/**
 The socket adapter class allows for web-socket based communication.  The adapter is an abstraction above sockets.

 Messages are received as events on a specified event aggregator.  Messages are sent using the method 'send'.

 @class SocketAdapter
 @static
 */
define('socketAdapter',[
    'core',
    'underscore',
    'utils',
    'app/five9.properties',
    'jquery',
    'pnotify',
    'websocketjs'
  ],
  function(Core, _, Utils, Properties) {
    var SocketAdapter = {
      broadcastEvents: true,
      debug: false,
      settings: {},
      Events: {
        Connected:'socket:connected',
        Disconnected: 'socket:disconnected',
        Reconnected: 'socket:reconnected',
        Lost: 'socket:lost'
      },
      vent: null,
      vents: []
    };

    SocketAdapter.CloseCodes = {
      CLOSE_NORMAL: 1000,
      CLOSE_GOING_AWAY: 1001,
      CLOSE_PROTOCOL_ERROR: 1002,
      CLOSE_UNSUPPORTED: 1003,
      CLOSE_NO_STATUS: 1004,
      CLOSE_ABNORMAL: 1006,
      CLOSE_DUPLICATE_CONNECTION: 3000
    };


    /**
     * The Register class resends requests that did not
     * get responded to within a timeout interval.
     *
     * Used for request/response sequences delivered entirely on socket
     */
    SocketAdapter.Register = function(options) {
      this.initialize(options);
    };
    SocketAdapter.Register.prototype = {
      initialize: function(options) {
        var defaults = {
          timeout: (1000 * 6)
        };
        this.options = _.defaults(options || {}, defaults);
        this.requests = {};
      },

      findByRequestId: function(requestId) {
        if (_.isObject(this.requests[requestId])) {
          return this.requests[requestId];
        }
        return false;
      },

      /**
       * Resend a request to be checked for a response
       * after the timeout
       * @param {String} requestId - Request UUID
       */
      registerCheck: function(requestId) {
        setTimeout(_.bind(this.checkForResponse, this, requestId), this.options.timeout);
      },

      /**
       * Add a request to the register.  Each request will check
       * if check the queue after a timeout to make sure it
       * has been responded to.
       * @param {Object} request - Socket request object
       */
      addRequest: function(request, eventName, options) {
        var defaults = {
          responded: false,
          isSubscription: false,
          subscriptionId: null
        };

        options = _.defaults(options || {}, defaults);

        if (!this.findByRequestId(request.requestId)) {
          // add all three params to the request entry.
          this.requests[request.requestId] = {
            request: request,
            eventName: eventName,
            options: options
          };

          this.registerCheck(request.requestId);
        }
      },

      /**
       * Adding a response to the register clears the
       * original matching request from the register.
       * When checkForResponse runs it will not find
       * the request ID in the array of requests and
       * know the request has been handled.
       * @param {String} requestId - UUID of socket request
       */
      addResponse: function(requestId) {
        if (_.isObject(this.requests[requestId])) {
          if (this.requests[requestId].options.isSubscription) {
            // If we get a response to our subscription
            // it's marked as responded to in the options.
            this.requests[requestId].options.responded = true;
          } else {
            // clean it from the register
            delete this.requests[requestId];
          }
        }
      },

      /**
       * Check if this request ID is still in the register.
       * If so, initiate a retry and set a new timeout
       * to check for the response again.
       * @param {String} requestId - UUID of socket request
       */
      checkForResponse: function(requestId) {
        Five9.Logger.info('SocketAdapter: SOCKET Register - checking for response', requestId);
        var request = this.findByRequestId(requestId);

        if (_.isObject(request) && !request.options.responded) {
          // At this point we have a request that
          // has had no response after the timeout
          if (SocketAdapter.getReadyState() === 1) {
            // the socket is open, resend the request
            Five9.Logger.info('SOCKET Register - Resending request', requestId);
            SocketAdapter.send(request.eventName, request.request);
          }

          // If the socket is NOT open, then we will
          // still queue the request for another check
          // since it could be that the socket will be
          // re-established by then
          this.registerCheck(requestId);
        } else {
          // request was responded to already
        }
      },

      /**
       * We want to clean all requests from the register except
       * pending PUT requests for user dashboards, those are widget
       * updates.
       *
       * @method clean
       *
       */
      clean: function() {
        var cleanedRequests = {};

        _.each(this.requests, function(requestObject, requestId) {
          if (requestObject.request.verb === 'PUT' &&
            requestObject.request.payload.dashboardType === 'user' &&
            requestObject.request.payload.widgets.length) {
            // a widget update is pending
            cleanedRequests[requestId] = requestObject;
          }
        });

        this.requests = cleanedRequests;
      },

      /**
       * The next two methods are used in the edge case that the updates
       * stopped because the connection was lost, when it came back up the
       * subscriptions where lost and would need to be started again but re-issuing
       * all the subscription requests.
       *
       * This is additional to the original defect DE5069
       */

      /**
       * associate a subscription ID with a registered request.
       * This is so that we could resent the subscription requests
       * if needed.
       */
      addSubscriptionId: function(requestId, subscriptionId) {
        var request = this.findByRequestId(requestId);

        if (_.isObject(request) && request.options.isSubscription) {
          request.options.subscriptionId = subscriptionId;
        }
      },

      /**
       * Remove a subscription request from the register if the widget
       * unsubscribed
       */
      removeSubscription: function(subscriptionId) {
        var requestIds = _.keys(this.requests);

        for (var i = 0; i < requestIds.length; i++) {
          var requestId = requestIds[i];

          if (this.requests[requestId].options.subscriptionId === subscriptionId) {
            delete this.requests[requestId];
            break;
          }
        }
      },

      getSubcriptionCount: function() {
        var subscriptions = _.filter(this.requests, function(request) {
          return request.options.isSubscription;
        });
        return subscriptions.length;
      },
      getNonSubcriptionCount: function() {
        var notSubscriptions = _.filter(this.requests, function(request) {
          return !request.options.isSubscription;
        });
        return notSubscriptions.length;
      }
    };

    /**
     * SocketAdapter
     */
    SocketAdapter.defaultSettings = {
      url: '',
      sendKeepAlive: false
    };

    var socket = null;
    var register = new SocketAdapter.Register();

    // Helper Methods
    // --------------
    function setupSocketEvents(socket) {
      socket.onopen = function() {
        Five9.Logger.info('SocketAdapter:socket.onopen: connected to socket server');
        setConnected(true);
        SocketAdapter.trigger(SocketAdapter.Events.Connected);
      };

      socket.onclose = function(closeEvent) {
        var data = _.isObject(closeEvent) ? _.pick(closeEvent, 'code', 'reason'): closeEvent;
        Five9.Logger.info('SocketAdapter:socket.onclose: disconnected from socket server', data);

        setConnected(false);
        SocketAdapter.trigger(SocketAdapter.Events.Disconnected, closeEvent);
      };

      socket.onmessage = _.bind(SocketAdapter._onMessage, this);
    }
    function setConnected(connected) {
      SocketAdapter.connected = connected;
    }
    function createKeepAlive() {
      destroyKeepAlive();
      SocketAdapter.keepAliveTimer = setInterval(onKeepAliveInterval, 5 * 60 * 1000);
    }
    function destroyKeepAlive() {
      if (SocketAdapter.keepAliveTimer) {
        clearInterval(SocketAdapter.keepAliveTimer);
      }
    }
    function onKeepAliveInterval() {
      if (SocketAdapter.connected && SocketAdapter.settings.sendKeepAlive) {
        var data = {
          'requestId': Utils.generateGuid(),
          'resource': '1/keep-alive',
          'verb': 'PUT',
          'payload': null
        };
        SocketAdapter.send('request', data);
      }
    }

    // Public API
    // ----------

    /**
     Setup the socket adapter for use.

     config.url

     @method initialize
     @param vent An event aggregator to receive socket messages (including adapter connect/disconnect/error).
     */
    SocketAdapter.initialize = function(vent) {
      SocketAdapter.vent = vent;
      if (SocketAdapter.vent === null) {
        throw 'SocketAdapter:: an event aggregator is required';
      }

      // reverse compatibility incase the vent is being used directly anywhere.
      SocketAdapter.vents.push(SocketAdapter.vent);
      SocketAdapter.settings = _.extend(SocketAdapter.defaultSettings, {url: Properties.getWebSocketURL()});

      SocketAdapter.connect = function(firstTime) {
        Five9.Logger.debug('SocketAdapter connect()');
        this.broadcastEvents = true;
        socket = new window.WebSocket(Properties.getWebSocketURL());

        if (SocketAdapter.getReadyState() === WebSocket.OPEN && firstTime === false) {
          Five9.vent.trigger(SocketAdapter.Events.Reconnected);
        }

        createKeepAlive();
        setupSocketEvents(socket);
        if (socket.connect) {
          Five9.Logger.debug('SocketAdapter connect start');
          socket.connect();
          Five9.Logger.debug('SocketAdapter connect end');
        }
      };
    };

    SocketAdapter.disableEvents = function() {
      SocketAdapter.broadcastEvents = false;
    };

    SocketAdapter.close = function() {
      Five9.Logger.debug('SocketAdapter close()');
      if (!socket){
        Five9.Logger.warn("Attempt to close uninitialized websocket");
        return;
      }
      socket.close();
      Five9.Logger.debug('SocketAdapter close end');
    };

    /**
     Send an event-based message

     @method send
     @param {String} eventName The name of the event
     @param data The data to be passed along.  Typically, this data is in json format.
     */
    SocketAdapter.send = function(eventName, data, options) {
      // for passing to the register object
      options = _.defaults(options || {}, {});

      if (socket) {
        Five9.Logger.debug('SocketAdapter: SOCKET send', {eventName:eventName,data:data});
        register.addRequest(data, eventName, options);
        socket.send(JSON.stringify({event: eventName, args: data}));
      }
    };

    /**
     * Add another event aggregator
     */
    SocketAdapter.addListener = function(vent) {
      SocketAdapter.vents.push(vent);
    };

    /**
     * Remove a listener
     * @param {Backbone.Wreqr.EventAggregator} vent
     */
    SocketAdapter.removeListener = function(vent) {
      SocketAdapter.vents = _.without(SocketAdapter.vents, vent);
    };

    /**
     * Trigger an event across all listeners
     * @param {string} event - event name
     * @param {object} message - event message
     * @param {object} context - context
     */
    SocketAdapter.trigger = function(event, message, context) {
      _.each(SocketAdapter.vents, function(vent) {
        vent.trigger(event, message, context);
      });
    };

    SocketAdapter.pendingRequests = function() {
      return register.getNonSubcriptionCount();
    };

    /**
     * Return the readyState of the socket connection
     */
    SocketAdapter.getReadyState = function() {
      return socket.readyState;
    };

    /**
     * Facade for SocketAdapter.Register.addSubscription
     */
    SocketAdapter.registerSubscription = function(requestId, subscriptionId) {
      register.addSubscriptionId(requestId, subscriptionId);
    };

    /**
     * Facade for SocketAdapter.Register.removeSubscription
     */
    SocketAdapter.unRegisterSubscription = function(subscriptionId) {
      register.removeSubscription(subscriptionId);
    };

    /**
     * Facade to clean the register of requests on dashboard change
     */
    SocketAdapter.cleanRegister = function() {
      register.clean();
    };

    // private API
    SocketAdapter._onMessage = function(msg) {
      var msgObj;
      try {
        msgObj = JSON.parse(msg.data);
        Five9.Logger.info('SocketAdapter: socket event received', msgObj.context.eventId, msgObj);
      }
      catch (ex) {
        Five9.Logger.error('SocketAdapter: Unable to parse socket response [not valid json data]', ex);
        return;
      }

      if (!SocketAdapter.broadcastEvents) {
        Five9.Logger.warn('Event broadcasting was disabled');
        return;
      }

      if (msgObj.hasOwnProperty('error')) {
        Five9.Logger.error('SocketAdapter: socket.onmessage: error in data', msgObj.error);
        SocketAdapter.trigger('SocketAdapter: socket.onmessage: error in data', msgObj.error);
      }
      else {
        if (_.isObject(msgObj.context)) {
          SocketAdapter.trigger(msgObj.context.eventId, msgObj.payLoad, msgObj.context);

          if (msgObj.requestId) {
            register.addResponse(msgObj.requestId);
          }
        }
        else {
          Five9.Logger.error('SocketAdapter: socket.onmessage: [incorrect message format] failed to parse args:', msgObj);

          // the VCC backend doesn't send errors properly.  we might get an improperly formatted error message
          // we still need to handle it.  assume it is a 'response' and send to handlers
          SocketAdapter.trigger('response', msgObj);
          register.addResponse(msgObj.requestId);
        }
      }
    };

    return SocketAdapter;
  });

/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

  var async = {};

  // global on the server, window in the browser
  var root, previous_async;

  root = this;
  if (root != null) {
    previous_async = root.async;
  }

  async.noConflict = function () {
    root.async = previous_async;
    return async;
  };

  function only_once(fn) {
    var called = false;
    return function() {
      if (called) throw new Error("Callback was already called.");
      called = true;
      fn.apply(root, arguments);
    }
  }

  //// cross-browser compatiblity functions ////

  var _toString = Object.prototype.toString;

  var _isArray = Array.isArray || function (obj) {
    return _toString.call(obj) === '[object Array]';
  };

  var _each = function (arr, iterator) {
    if (arr.forEach) {
      return arr.forEach(iterator);
    }
    for (var i = 0; i < arr.length; i += 1) {
      iterator(arr[i], i, arr);
    }
  };

  var _map = function (arr, iterator) {
    if (arr.map) {
      return arr.map(iterator);
    }
    var results = [];
    _each(arr, function (x, i, a) {
      results.push(iterator(x, i, a));
    });
    return results;
  };

  var _reduce = function (arr, iterator, memo) {
    if (arr.reduce) {
      return arr.reduce(iterator, memo);
    }
    _each(arr, function (x, i, a) {
      memo = iterator(memo, x, i, a);
    });
    return memo;
  };

  var _keys = function (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keys = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        keys.push(k);
      }
    }
    return keys;
  };

  //// exported async module functions ////

  //// nextTick implementation with browser-compatible fallback ////
  if (typeof process === 'undefined' || !(process.nextTick)) {
    if (typeof setImmediate === 'function') {
      async.nextTick = function (fn) {
        // not a direct alias for IE10 compatibility
        setImmediate(fn);
      };
      async.setImmediate = async.nextTick;
    }
    else {
      async.nextTick = function (fn) {
        setTimeout(fn, 0);
      };
      async.setImmediate = async.nextTick;
    }
  }
  else {
    async.nextTick = process.nextTick;
    if (typeof setImmediate !== 'undefined') {
      async.setImmediate = function (fn) {
        // not a direct alias for IE10 compatibility
        setImmediate(fn);
      };
    }
    else {
      async.setImmediate = async.nextTick;
    }
  }

  async.each = function (arr, iterator, callback) {
    callback = callback || function () {};
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    _each(arr, function (x) {
      iterator(x, only_once(done) );
    });
    function done(err) {
      if (err) {
        callback(err);
        callback = function () {};
      }
      else {
        completed += 1;
        if (completed >= arr.length) {
          callback();
        }
      }
    }
  };
  async.forEach = async.each;

  async.eachSeries = function (arr, iterator, callback) {
    callback = callback || function () {};
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    var iterate = function () {
      iterator(arr[completed], function (err) {
        if (err) {
          callback(err);
          callback = function () {};
        }
        else {
          completed += 1;
          if (completed >= arr.length) {
            callback();
          }
          else {
            iterate();
          }
        }
      });
    };
    iterate();
  };
  async.forEachSeries = async.eachSeries;

  async.eachLimit = function (arr, limit, iterator, callback) {
    var fn = _eachLimit(limit);
    fn.apply(null, [arr, iterator, callback]);
  };
  async.forEachLimit = async.eachLimit;

  var _eachLimit = function (limit) {

    return function (arr, iterator, callback) {
      callback = callback || function () {};
      if (!arr.length || limit <= 0) {
        return callback();
      }
      var completed = 0;
      var started = 0;
      var running = 0;

      (function replenish () {
        if (completed >= arr.length) {
          return callback();
        }

        while (running < limit && started < arr.length) {
          started += 1;
          running += 1;
          iterator(arr[started - 1], function (err) {
            if (err) {
              callback(err);
              callback = function () {};
            }
            else {
              completed += 1;
              running -= 1;
              if (completed >= arr.length) {
                callback();
              }
              else {
                replenish();
              }
            }
          });
        }
      })();
    };
  };


  var doParallel = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.each].concat(args));
    };
  };
  var doParallelLimit = function(limit, fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [_eachLimit(limit)].concat(args));
    };
  };
  var doSeries = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.eachSeries].concat(args));
    };
  };


  var _asyncMap = function (eachfn, arr, iterator, callback) {
    arr = _map(arr, function (x, i) {
      return {index: i, value: x};
    });
    if (!callback) {
      eachfn(arr, function (x, callback) {
        iterator(x.value, function (err) {
          callback(err);
        });
      });
    } else {
      var results = [];
      eachfn(arr, function (x, callback) {
        iterator(x.value, function (err, v) {
          results[x.index] = v;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.map = doParallel(_asyncMap);
  async.mapSeries = doSeries(_asyncMap);
  async.mapLimit = function (arr, limit, iterator, callback) {
    return _mapLimit(limit)(arr, iterator, callback);
  };

  var _mapLimit = function(limit) {
    return doParallelLimit(limit, _asyncMap);
  };

  // reduce only has a series version, as doing reduce in parallel won't
  // work in many situations.
  async.reduce = function (arr, memo, iterator, callback) {
    async.eachSeries(arr, function (x, callback) {
      iterator(memo, x, function (err, v) {
        memo = v;
        callback(err);
      });
    }, function (err) {
      callback(err, memo);
    });
  };
  // inject alias
  async.inject = async.reduce;
  // foldl alias
  async.foldl = async.reduce;

  async.reduceRight = function (arr, memo, iterator, callback) {
    var reversed = _map(arr, function (x) {
      return x;
    }).reverse();
    async.reduce(reversed, memo, iterator, callback);
  };
  // foldr alias
  async.foldr = async.reduceRight;

  var _filter = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {index: i, value: x};
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.filter = doParallel(_filter);
  async.filterSeries = doSeries(_filter);
  // select alias
  async.select = async.filter;
  async.selectSeries = async.filterSeries;

  var _reject = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {index: i, value: x};
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (!v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.reject = doParallel(_reject);
  async.rejectSeries = doSeries(_reject);

  var _detect = function (eachfn, arr, iterator, main_callback) {
    eachfn(arr, function (x, callback) {
      iterator(x, function (result) {
        if (result) {
          main_callback(x);
          main_callback = function () {};
        }
        else {
          callback();
        }
      });
    }, function (err) {
      main_callback();
    });
  };
  async.detect = doParallel(_detect);
  async.detectSeries = doSeries(_detect);

  async.some = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (v) {
          main_callback(true);
          main_callback = function () {};
        }
        callback();
      });
    }, function (err) {
      main_callback(false);
    });
  };
  // any alias
  async.any = async.some;

  async.every = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (!v) {
          main_callback(false);
          main_callback = function () {};
        }
        callback();
      });
    }, function (err) {
      main_callback(true);
    });
  };
  // all alias
  async.all = async.every;

  async.sortBy = function (arr, iterator, callback) {
    async.map(arr, function (x, callback) {
      iterator(x, function (err, criteria) {
        if (err) {
          callback(err);
        }
        else {
          callback(null, {value: x, criteria: criteria});
        }
      });
    }, function (err, results) {
      if (err) {
        return callback(err);
      }
      else {
        var fn = function (left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        };
        callback(null, _map(results.sort(fn), function (x) {
          return x.value;
        }));
      }
    });
  };

  async.auto = function (tasks, callback) {
    callback = callback || function () {};
    var keys = _keys(tasks);
    var remainingTasks = keys.length
    if (!remainingTasks) {
      return callback();
    }

    var results = {};

    var listeners = [];
    var addListener = function (fn) {
      listeners.unshift(fn);
    };
    var removeListener = function (fn) {
      for (var i = 0; i < listeners.length; i += 1) {
        if (listeners[i] === fn) {
          listeners.splice(i, 1);
          return;
        }
      }
    };
    var taskComplete = function () {
      remainingTasks--
      _each(listeners.slice(0), function (fn) {
        fn();
      });
    };

    addListener(function () {
      if (!remainingTasks) {
        var theCallback = callback;
        // prevent final callback from calling itself if it errors
        callback = function () {};

        theCallback(null, results);
      }
    });

    _each(keys, function (k) {
      var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
      var taskCallback = function (err) {
        var args = Array.prototype.slice.call(arguments, 1);
        if (args.length <= 1) {
          args = args[0];
        }
        if (err) {
          var safeResults = {};
          _each(_keys(results), function(rkey) {
            safeResults[rkey] = results[rkey];
          });
          safeResults[k] = args;
          callback(err, safeResults);
          // stop subsequent errors hitting callback multiple times
          callback = function () {};
        }
        else {
          results[k] = args;
          async.setImmediate(taskComplete);
        }
      };
      var requires = task.slice(0, Math.abs(task.length - 1)) || [];
      var ready = function () {
        return _reduce(requires, function (a, x) {
          return (a && results.hasOwnProperty(x));
        }, true) && !results.hasOwnProperty(k);
      };
      if (ready()) {
        task[task.length - 1](taskCallback, results);
      }
      else {
        var listener = function () {
          if (ready()) {
            removeListener(listener);
            task[task.length - 1](taskCallback, results);
          }
        };
        addListener(listener);
      }
    });
  };

  async.retry = function(times, task, callback) {
    var DEFAULT_TIMES = 5;
    var attempts = [];
    // Use defaults if times not passed
    if (typeof times === 'function') {
      callback = task;
      task = times;
      times = DEFAULT_TIMES;
    }
    // Make sure times is a number
    times = parseInt(times, 10) || DEFAULT_TIMES;
    var wrappedTask = function(wrappedCallback, wrappedResults) {
      var retryAttempt = function(task, finalAttempt) {
        return function(seriesCallback) {
          task(function(err, result){
            seriesCallback(!err || finalAttempt, {err: err, result: result});
          }, wrappedResults);
        };
      };
      while (times) {
        attempts.push(retryAttempt(task, !(times-=1)));
      }
      async.series(attempts, function(done, data){
        data = data[data.length - 1];
        (wrappedCallback || callback)(data.err, data.result);
      });
    }
    // If a callback is passed, run this as a controll flow
    return callback ? wrappedTask() : wrappedTask
  };

  async.waterfall = function (tasks, callback) {
    callback = callback || function () {};
    if (!_isArray(tasks)) {
      var err = new Error('First argument to waterfall must be an array of functions');
      return callback(err);
    }
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {};
        }
        else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          }
          else {
            args.push(callback);
          }
          async.setImmediate(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(async.iterator(tasks))();
  };

  var _parallel = function(eachfn, tasks, callback) {
    callback = callback || function () {};
    if (_isArray(tasks)) {
      eachfn.map(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    }
    else {
      var results = {};
      eachfn.each(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };

  async.parallel = function (tasks, callback) {
    _parallel({ map: async.map, each: async.each }, tasks, callback);
  };

  async.parallelLimit = function(tasks, limit, callback) {
    _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
  };

  async.series = function (tasks, callback) {
    callback = callback || function () {};
    if (_isArray(tasks)) {
      async.mapSeries(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    }
    else {
      var results = {};
      async.eachSeries(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };

  async.iterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return (index < tasks.length - 1) ? makeCallback(index + 1): null;
      };
      return fn;
    };
    return makeCallback(0);
  };

  async.apply = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return fn.apply(
        null, args.concat(Array.prototype.slice.call(arguments))
      );
    };
  };

  var _concat = function (eachfn, arr, fn, callback) {
    var r = [];
    eachfn(arr, function (x, cb) {
      fn(x, function (err, y) {
        r = r.concat(y || []);
        cb(err);
      });
    }, function (err) {
      callback(err, r);
    });
  };
  async.concat = doParallel(_concat);
  async.concatSeries = doSeries(_concat);

  async.whilst = function (test, iterator, callback) {
    if (test()) {
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        async.whilst(test, iterator, callback);
      });
    }
    else {
      callback();
    }
  };

  async.doWhilst = function (iterator, test, callback) {
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      var args = Array.prototype.slice.call(arguments, 1);
      if (test.apply(null, args)) {
        async.doWhilst(iterator, test, callback);
      }
      else {
        callback();
      }
    });
  };

  async.until = function (test, iterator, callback) {
    if (!test()) {
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        async.until(test, iterator, callback);
      });
    }
    else {
      callback();
    }
  };

  async.doUntil = function (iterator, test, callback) {
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      var args = Array.prototype.slice.call(arguments, 1);
      if (!test.apply(null, args)) {
        async.doUntil(iterator, test, callback);
      }
      else {
        callback();
      }
    });
  };

  async.queue = function (worker, concurrency) {
    if (concurrency === undefined) {
      concurrency = 1;
    }
    function _insert(q, data, pos, callback) {
      if (!q.started){
        q.started = true;
      }
      if (!_isArray(data)) {
        data = [data];
      }
      if(data.length == 0) {
        // call drain immediately if there are no tasks
        return async.setImmediate(function() {
          if (q.drain) {
            q.drain();
          }
        });
      }
      _each(data, function(task) {
        var item = {
          data: task,
          callback: typeof callback === 'function' ? callback : null
        };

        if (pos) {
          q.tasks.unshift(item);
        } else {
          q.tasks.push(item);
        }

        if (q.saturated && q.tasks.length === q.concurrency) {
          q.saturated();
        }
        async.setImmediate(q.process);
      });
    }

    var workers = 0;
    var q = {
      tasks: [],
      concurrency: concurrency,
      saturated: null,
      empty: null,
      drain: null,
      started: false,
      paused: false,
      push: function (data, callback) {
        _insert(q, data, false, callback);
      },
      kill: function () {
        q.drain = null;
        q.tasks = [];
      },
      unshift: function (data, callback) {
        _insert(q, data, true, callback);
      },
      process: function () {
        if (!q.paused && workers < q.concurrency && q.tasks.length) {
          var task = q.tasks.shift();
          if (q.empty && q.tasks.length === 0) {
            q.empty();
          }
          workers += 1;
          var next = function () {
            workers -= 1;
            if (task.callback) {
              task.callback.apply(task, arguments);
            }
            if (q.drain && q.tasks.length + workers === 0) {
              q.drain();
            }
            q.process();
          };
          var cb = only_once(next);
          worker(task.data, cb);
        }
      },
      length: function () {
        return q.tasks.length;
      },
      running: function () {
        return workers;
      },
      idle: function() {
        return q.tasks.length + workers === 0;
      },
      pause: function () {
        if (q.paused === true) { return; }
        q.paused = true;
      },
      resume: function () {
        if (q.paused === false) { return; }
        q.paused = false;
        // Need to call q.process once per concurrent
        // worker to preserve full concurrency after pause
        for (var w = 1; w <= q.concurrency; w++) {
          async.setImmediate(q.process);
        }
      }
    };
    return q;
  };

  async.priorityQueue = function (worker, concurrency) {

    function _compareTasks(a, b){
      return a.priority - b.priority;
    };

    function _binarySearch(sequence, item, compare) {
      var beg = -1,
        end = sequence.length - 1;
      while (beg < end) {
        var mid = beg + ((end - beg + 1) >>> 1);
        if (compare(item, sequence[mid]) >= 0) {
          beg = mid;
        } else {
          end = mid - 1;
        }
      }
      return beg;
    }

    function _insert(q, data, priority, callback) {
      if (!q.started){
        q.started = true;
      }
      if (!_isArray(data)) {
        data = [data];
      }
      if(data.length == 0) {
        // call drain immediately if there are no tasks
        return async.setImmediate(function() {
          if (q.drain) {
            q.drain();
          }
        });
      }
      _each(data, function(task) {
        var item = {
          data: task,
          priority: priority,
          callback: typeof callback === 'function' ? callback : null
        };

        q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

        if (q.saturated && q.tasks.length === q.concurrency) {
          q.saturated();
        }
        async.setImmediate(q.process);
      });
    }

    // Start with a normal queue
    var q = async.queue(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function (data, priority, callback) {
      _insert(q, data, priority, callback);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
  };

  async.cargo = function (worker, payload) {
    var working     = false,
      tasks       = [];

    var cargo = {
      tasks: tasks,
      payload: payload,
      saturated: null,
      empty: null,
      drain: null,
      drained: true,
      push: function (data, callback) {
        if (!_isArray(data)) {
          data = [data];
        }
        _each(data, function(task) {
          tasks.push({
            data: task,
            callback: typeof callback === 'function' ? callback : null
          });
          cargo.drained = false;
          if (cargo.saturated && tasks.length === payload) {
            cargo.saturated();
          }
        });
        async.setImmediate(cargo.process);
      },
      process: function process() {
        if (working) return;
        if (tasks.length === 0) {
          if(cargo.drain && !cargo.drained) cargo.drain();
          cargo.drained = true;
          return;
        }

        var ts = typeof payload === 'number'
          ? tasks.splice(0, payload)
          : tasks.splice(0, tasks.length);

        var ds = _map(ts, function (task) {
          return task.data;
        });

        if(cargo.empty) cargo.empty();
        working = true;
        worker(ds, function () {
          working = false;

          var args = arguments;
          _each(ts, function (data) {
            if (data.callback) {
              data.callback.apply(null, args);
            }
          });

          process();
        });
      },
      length: function () {
        return tasks.length;
      },
      running: function () {
        return working;
      }
    };
    return cargo;
  };

  var _console_fn = function (name) {
    return function (fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      fn.apply(null, args.concat([function (err) {
        var args = Array.prototype.slice.call(arguments, 1);
        if (typeof console !== 'undefined') {
          if (err) {
            if (console.error) {
              console.error(err);
            }
          }
          else if (console[name]) {
            _each(args, function (x) {
              console[name](x);
            });
          }
        }
      }]));
    };
  };
  async.log = _console_fn('log');
  async.dir = _console_fn('dir');
  /*async.info = _console_fn('info');
   async.warn = _console_fn('warn');
   async.error = _console_fn('error');*/

  async.memoize = function (fn, hasher) {
    var memo = {};
    var queues = {};
    hasher = hasher || function (x) {
      return x;
    };
    var memoized = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      var key = hasher.apply(null, args);
      if (key in memo) {
        async.nextTick(function () {
          callback.apply(null, memo[key]);
        });
      }
      else if (key in queues) {
        queues[key].push(callback);
      }
      else {
        queues[key] = [callback];
        fn.apply(null, args.concat([function () {
          memo[key] = arguments;
          var q = queues[key];
          delete queues[key];
          for (var i = 0, l = q.length; i < l; i++) {
            q[i].apply(null, arguments);
          }
        }]));
      }
    };
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
  };

  async.unmemoize = function (fn) {
    return function () {
      return (fn.unmemoized || fn).apply(null, arguments);
    };
  };

  async.times = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.map(counter, iterator, callback);
  };

  async.timesSeries = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.mapSeries(counter, iterator, callback);
  };

  async.seq = function (/* functions... */) {
    var fns = arguments;
    return function () {
      var that = this;
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      async.reduce(fns, args, function (newargs, fn, cb) {
          fn.apply(that, newargs.concat([function () {
            var err = arguments[0];
            var nextargs = Array.prototype.slice.call(arguments, 1);
            cb(err, nextargs);
          }]))
        },
        function (err, results) {
          callback.apply(that, [err].concat(results));
        });
    };
  };

  async.compose = function (/* functions... */) {
    return async.seq.apply(null, Array.prototype.reverse.call(arguments));
  };

  var _applyEach = function (eachfn, fns /*args...*/) {
    var go = function () {
      var that = this;
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      return eachfn(fns, function (fn, cb) {
          fn.apply(that, args.concat([cb]));
        },
        callback);
    };
    if (arguments.length > 2) {
      var args = Array.prototype.slice.call(arguments, 2);
      return go.apply(this, args);
    }
    else {
      return go;
    }
  };
  async.applyEach = doParallel(_applyEach);
  async.applyEachSeries = doSeries(_applyEach);

  async.forever = function (fn, callback) {
    function next(err) {
      if (err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      fn(next);
    }
    next();
  };

  // Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = async;
  }
  // AMD / RequireJS
  else if (typeof define !== 'undefined' && define.amd) {
    define('async',[], function () {
      return async;
    });
  }
  // included directly via <script> tag
  else {
    root.async = async;
  }

}());

/**
 * I18N UI String Localization
 *@module Core
 *@submodule Localize
 */

define('localize',[
  // this module is optimized for fast loading.  don't add modules without evaluating performance cost
  'async',
  'utils',
  'jquery'
],
function(Async, Utils, $) {

  /**
   * @class Localize
   * @constructor
   */
  var Localize = {};

  // set supported locales (hard-coded list for now)
  /**
   *@property defaultLocale
   *@type {String}
   *@default 'en'
   */
  Localize.defaultLocale = 'en';
  /**
   *@property supportedLocales
   *@type {Array}
   *@readOnly
   */
  Localize.supportedLocales = [
    {id:'en'},
    {id:'ru'},
    {id:'es'},
    {id:'he'},
    {id:'zh'},
    {id:'fr'}
  ];

  /**
   *@property localeKey
   *@type {String}
   */
  Localize.localeKey = 'f9-locale';

  /**
   *@property defaultStrings
   *@type {Object}
   */
  Localize.defaultStrings = {};

  /**
   *@property strings
   *@type {Object}
   */
  Localize.strings = {};

  // internal methods
  /**
   *@private
   */
  function _normaliseLang(lang) {
    lang = lang.replace(/_/, '-').toLowerCase();
    if (lang.length > 3) {
      lang = lang.substring(0, 3) + lang.substring(3).toUpperCase();
    }
    return lang;
  }
  /**
   *@private
   */
  function _getLocale() {
    return _normaliseLang(navigator.language || navigator.userLanguage || Localize.defaultLocale);
  }
  /**
   *@private
   */
  function _readStoredLocale() {
    return localStorage.getItem(Localize.localeKey);
  }
  /**
   *@private
   */
  function _writeStoredLocale(locale) {
    localStorage.setItem(Localize.localeKey, locale);
  }
  /**
   *@private
   */
  function _hasString(o, code) {
    var split = code.split('.');
    if (o.hasOwnProperty(split[0])) {
      if (split.length > 1) {
        code = code.substring(split[0].length + 1, code.length);
        return _hasString(o[split[0]], code);
      }
      return !_.isUndefined([split[0]]);
    }
    return false;
  }

  /**
   *@private
   */
  function _getString(o, code) {
    var split = code.split('.');
    if (o.hasOwnProperty(split[0])) {
      if (split.length > 1) {
        code = code.substring(split[0].length + 1, code.length);
        return _getString(o[split[0]], code);
      }
      return o[split[0]];
    }
    console.warn('Localize::getString() unable to find string for code [' + code + '] locale [' + Localize.locale + ']', Localize.strings);
    return '';
  }
  /**
   *@private
   */
  function _writeToDOM(locale, dir) {
    // write lang to html
    document.documentElement.lang = locale;

    // rtl is a non-trivial problem.  the code here is a start.
    // see http://24ways.org/2011/going-both-ways/ for more details

    // document.documentElement.dir = Localize.dir;
    $('input,label,button,span,div,legend').attr('dir', dir);
  }

  // internal methods that perform network activity
  /**
   *@private
   */
  function _loadGlobalizationLocale(locale) {
    var d = $.Deferred();

    var filename = Utils.formatString('kendoCultures/kendo.culture.{0}.min', locale);
    require([filename], function(strings) {
      kendo.culture(locale);
      d.resolve();
    });
    return d.promise();
  }
  /**
   *@private
   */
  function _loadStringBundle(locale, isDefaultLocale) {
    var d = $.Deferred();
    var filename = 'lang-' + locale + '.json';
    // text is used instead of i18n for flexibility
    require(['text!lang/' + filename], function(strings) {
      try {
        strings = JSON.parse(strings);
      }
      catch (error) {
        var errorMessage = 'Unable to parse string bundle [' + filename + ']';
        console.error(errorMessage);
        d.reject(errorMessage);
        return;
      }
      if (isDefaultLocale) {
        Localize.defaultStrings = strings;
      }
      else {
        Localize.strings = $.extend(true, {}, Localize.defaultStrings, strings);
        Localize.dir = (strings.hasOwnProperty('LANG_DIR')) ? strings['LANG_DIR'] : 'ltr';
        _writeToDOM(Localize.locale, Localize.dir);
      }
      d.resolve();
    });
    return d.promise();
  }

  /**
   *@private
   */
  function loadAll() {
    var d = $.Deferred();

    Async.series([
      function(done) {
        // load default
        _loadStringBundle(Localize.defaultLocale, true)
          .done(function() {
            done();
          })
          .fail(function(errorMessage) {
            done(errorMessage);
          });
      },
      function(done) {
        // load current
        _loadStringBundle(Localize.locale)
          .done(function() {
            done();
          })
          .fail(function(errorMessage) {
            done(errorMessage);
          });
      },
      function(done) {
        // load kendo locales
        if (Localize.loadKendo) {
          _loadGlobalizationLocale(Localize.locale).done(function() {
            done();
          });
        }
        else {
          done();
        }
      }
    ],
    function(errors) {
      if (errors) {
        d.reject(errors);
      }
      else {
        Localize.trigger('localize:load');
        d.resolve();
      }
    });
    return d.promise();
  }

  // main class
  Localize = $.extend(Localize, {
    /**
     *@method initialize
     *@for Localize
     *@param {Object} [options]
     */
    initialize: function(options) {
      options = options || {};

      Localize.vent = options.vent;
      Localize.loadKendo = _.isUndefined(options.loadKendo) ? true : false;

      if (options.supportedLocales) {
        Localize.supportedLocales = options.supportedLocales;
      }

      if (options.defaultLocale) {
        Localize.defaultLocale = options.defaultLocale;
      }

      // get browser locale
      Localize.locale = _getLocale();
      console.info('browser locale [' + Localize.locale + ']');

      // has browser locale been overridden?
      var locale = _readStoredLocale();
      if (locale) {
        console.info('specified locale [' + locale + ']');
        Localize.locale = locale;
      }

      return Localize.setLocale(Localize.locale, false);
    },

    /**
     *@method getLocale
     *@for Localize
     *@return {String} current locale
     */
    getLocale: function() {
      return Localize.locale;
    },
    /**
     *@method setLocale
     *@for Localize
     *@param {String} [locale]
     *@return {jQuery.Promise} Promise object for deferred resolution
     */
    setLocale: function(locale, write) {
      if (_.isUndefined(write)) {
        write = true;
      }
      var d = $.Deferred();

      Localize.locale = locale;
      // if not a supported locale, use default
      if (Localize.isSupportedLocale(Localize.locale) === false) {
        Localize.locale = Localize.defaultLocale;
      }
      // load all necessary locale files
      loadAll()
        .done(function() {
          if (write) {
            _writeStoredLocale(Localize.locale);
            console.info('Localize::setLocale() [' + Localize.locale + ']');
          }

          Localize.trigger('localize:locale:change');
          d.resolve();
        })
        .fail(function() {
          d.reject();
        });
      return d.promise();
    },

    /**
     *@method getSupportedLocales
     *@for Localize
     *@return {Array} supported locales array
     */
    getSupportedLocales: function() {
      return Localize.supportedLocales;
    },

    /**
     *@method isSupportedLocale
     *@for Localize
     *@param {String} [locale]
     *@return {Boolean}
     */
    isSupportedLocale: function(locale) {
      var model = Utils.array_find_id(Localize.supportedLocales, locale);
      return (model) ? true : false;
    },

    /**
     * Alias to Localize.vent.trigger
     *@method trigger
     *@for Localize
     */
    trigger: function() {
      if (Localize.vent) {
        Localize.vent.trigger.apply(Localize.vent, arguments);
      }
    },

    /**
     * Does string table contain a string for code
     *
     *@method hasString
     *@param {String} [code] Localize string label
     *@return {Boolean} true if defined, false if not
     */
    hasString: function(code) {
      return _hasString(Localize.strings, code);
    },

    /**
     * Get a localized string by passing in the string label (key)
     * and returns the localized string in the current locale.
     *
     *@method getString
     *@param {String} [code] Localize string label
     *@return {String} localized string
     */
    getString: function(code) {
      return _getString(Localize.strings, code);
    },

    /**
     * Works like get string but accepts additonal parameters
     * that are substituted in the localized string
     *
     *@method getFormattedString
     *@param {String} [code] string label
     *@param {Mixed} [args]
     *@return {String}
     */
    getFormattedString: function(code) {
      var s = _getString(Localize.strings, code);

      var args = Array.prototype.slice.call(arguments);
      args[0] = s;
      return Utils.formatString.apply(null, args);
    }
  });

  // shorthand methods for getString
  /**
   * Global alias for Localize.getString
   *@method _S
   *@namespace window
   */
  window._S = function() {
    return Localize.getString.apply(Localize, arguments);
  };

  /**
   * Alias for Localize.getFormattedString
   *@method _S_FORMAT
   *@namespace window
   */
  window._S_FORMAT = function() {
    return Localize.getFormattedString.apply(Localize, arguments);
  };

  /**
   * Alias for Localize.getString().toLowerCase()
   *@method _S_LOWER
   *@namespace window
   */
  window._S_LOWER = function() {
    var s = Localize.getString.apply(Localize, arguments);
    if (s) s = s.toLowerCase();
    return s;
  };

  /**
   * Alias for Localize.getString().toUpperCase()
   *@method _S_UPPER
   *@namespace window
   */
  window._S_UPPER = function() {
    var s = Localize.getString.apply(Localize, arguments);
    if (s) s = s.toUpperCase();
    return s;
  };

  return Localize;
});

define('five9',[
  'jquery',
  'underscore',
  'core',
  'utils',
  'backbone',
  'marionette',
  'app/five9.properties',
  'context',
  'dataAdapter',
  'logger',
  'socketAdapter',
  'localize',
  'async'
],
function($, _, Core, Utils, Backbone, Marionette, Properties, Context, DataAdapter, Logger, SocketAdapter, Localize, Async) {
  // Application instance
  // --------------------
  var Five9 = new Marionette.Application({
    // The root path to run the application.
    root: '/',
    selectors: {
      mainContent: '#main-content'
    },

    Context: Context,
    DataAdapter: DataAdapter,
    Logger: Logger,
    Properties: Properties,
    Socket: SocketAdapter,
    Localize: Localize,
    RootComponent: new Core.ComponentContainer(),
    Settings: null,

    getJSTTemplate: function(template, data) {
      try {
        return JST[template](data);
      }
      catch(error) {
        Logger.error('Unable to compile template ['+template+'] '+error);
      }
    },

    loadFile: function(file) {
      var d = $.Deferred();
      var MAX_RETRY_COUNT = 3;
      var retryCount = 0;
      var loadAttempt = function() {
        require([file], function() {
          d.resolve();
        }, function(e) {

          var src='';
          if(e && e.originalError) {
            var evt = e.originalError;
            var node = evt.currentTarget || evt.srcElement;
            src = node && node.src;
          }

          console.error('Loading failed attempt=' + retryCount +', file=' + file + ', src=' + src);

          if(retryCount++ < MAX_RETRY_COUNT) {
            require.undef(file);
            loadAttempt();
          }
          else {
            d.reject();
          }
        });
      };

      loadAttempt();
      return d;
    },


    loadBundle: function(bundle) {
      var d = $.Deferred();
      var that = this;

      Async.series([

        function(next) {
          if (window.loadBundles) {
            next();
          } else {
            that.loadFile('all-' + bundle).done(function() {
              next();
            });
          }
        },
        function() {
          Core.loadBundle(bundle).done(function(){
            d.resolve();
          }).fail(function(){
            d.reject();
          });
        }
      ]);
      return d.promise();
    },

    loadBundleList: function(bundleList) {
      var that = this;
      var d = $.Deferred();
      Async.eachSeries(bundleList, function (bundleName, callback) {
          that.loadBundle(bundleName).done(function() {
            callback();
          });
        },
        function() {
          d.resolve();
        });
      return d.promise();
    }
  });

  // setup Logger
  // ----------------------------
  Logger.initialize({
    appenders: ['Console'],
    collectors: ['All'],
    vent: [Five9,Five9.vent]
  });

  Five9.on('initialize:before', function() {
    Core.vent = Five9.vent;
  });

  // global access - to make debugging easier
  window.Five9 = Five9;

  return Five9;
});

define('server.models.storage',[
  'backbone',
  'jquery',
  'underscore',
  'dataAdapter-api'
],
function (Backbone, $, _, API) {
  var Helpers = {};

  Helpers.Sync = {};
  Helpers.Sync.modelFetch = Backbone.Model.prototype.fetch;
  Helpers.Sync.collectionFetch = Backbone.Collection.prototype.fetch;

  Helpers.Sync.fetch = function (modelOrCollection, options) {
    var fetch = modelOrCollection.isCollection()? this.collectionFetch : this.modelFetch;
    return fetch.call(modelOrCollection, options);
  };

  Helpers.ModelHash = {};

  Helpers.ModelHash.initialize = function () {
    this._modelHash = {};

    return this;
  };

  Helpers.ModelHash.model = function (key) {
    return _.result(this._modelHash[key], 'model');
  };

  Helpers.ModelHash.keysByPattern = function(pattern) {
    pattern = pattern.replace(/^\//, "");// remove first slash
    pattern = pattern.replace(/\//g, "\\/");
    pattern = pattern.replace(/\*/g, "\\w+");
    var reg = new RegExp("^"+pattern+"\\W?.*");
    var result = [];
    _.each(this._modelHash, function(box, key){
      if(reg.test(key)) {
        result.push(key);
      }
    });
    return result;
  };

  Helpers.ModelHash.setModel = function (key, model) {
    if (model) {
      this._box(key).model = model;
    } else {
      this.clearModel(key);
    }
  };

  Helpers.ModelHash.clearModel = function (key) {
    delete this._modelHash[key];
  };

  Helpers.ModelHash.clear = function() {
    this._modelHash = {};
  };

  Helpers.ModelHash._box = function (key) {
    var box = this._modelHash[key];
    return box? box: (this._modelHash[key] = {});
  };

  Helpers.Path = {};

  Helpers.Path.createPath = function (pathParts) {
    var parts = _.isArray(pathParts)? pathParts: arguments;
    parts = _.reject(parts, function(part) {
      return (part === '' || _.isUndefined(part) || _.isNull(part));
    });

    return parts.join('/');
  };

  Helpers.Path.modelPath = function (parentPath, ModelConstructors, modelId) {
    if (_.isUndefined(ModelConstructors.apiClassType)) {
      throw new Error('No apiClassType defined');
    }
    return this.createPath(parentPath, ModelConstructors.apiClassType, modelId);
  };

  Helpers.Path.collectionPath = function (parentPath, ModelConstructors) {
    var ret;

    if (!_.isUndefined(ModelConstructors.Collection)) {
      ret = this.createPath(parentPath, ModelConstructors.apiClassType);
    }

    return ret;
  };

  Helpers.ResourceType = {
    _resourceInfo: {},

    setModelData: function(parentPath, constructors) {
      var resourceId = constructors.resourceId;
      if(!_.isUndefined(resourceId)) {
        if(!_.has(this._resourceInfo, resourceId)) {
          this._resourceInfo[resourceId] = {parent: parentPath, constructors: constructors};
        }
      }
    },

    getModelConstructors: function(resourceId) {
      var modelData = this._resourceInfo[resourceId];
      return modelData && modelData.constructors;
    },

    getParentPath: function(resourceId) {
      var modelData = this._resourceInfo[resourceId];
      return modelData && modelData.parent;
    }
  };

  Helpers.BatchQueue = {
    _modelHolderQueue: [],
    _timer: null,
    _BATCH_API_URL_PREFIX: '/appsvcs/rs/svc',

    getScheduledDeferred: function(model) {
      var holder = _.findWhere(this._modelHolderQueue, {model:model});
      return holder && holder.deferred;
    },

    scheduleFetch: function(model, deferred) {
      this._modelHolderQueue.push({model:model, deferred: deferred});
      console.log("ModelStorage: BatchQueue: queuing resource: ", model.path());

      if(this._modelHolderQueue.length === 1) {
        console.log("ModelStorage: BatchQueue: Scheduling batch fetch");
        this._timer = setTimeout(_.bind(function() {
          console.log("ModelStorage: BatchQueue: Running batch fetch, size=", this._modelHolderQueue.length);
          this.batchFetch(this._modelHolderQueue);
          this._modelHolderQueue = [];
        }, this), 0);
      }
    },

    batchFetch: function(modelHolders) {
      //fetch fresh models
      var payload = {
        requests: []
      };

      _.each(modelHolders, function(modelHolder) {
        payload.requests.push({
          method:'GET',
          relativeURL: Helpers.Path.createPath(this._BATCH_API_URL_PREFIX, modelHolder.model.path())
        });
      }, this);

      API.performAction('batchapi', 'POST', null, null, payload).done(_.bind(function(data){
        _.each(data.responses, function(response, index) {
          try {
            var model = modelHolders[index].model;
            var deferred = modelHolders[index].deferred;
            if(response.code >= 200 && response.code < 300) {
              if(response.content) {
                var rawData = JSON.parse(response.content);
                if(model instanceof Backbone.Model) {
                  var data = model.parse(rawData);
                  model.set(data);
                }
                else if(model instanceof Backbone.Collection) {
                  model.set(rawData, {parse: true});
                }
              }

              deferred.resolve();
            }
            else if(_.isFunction(model.canIgnoreError) && model.canIgnoreError(response.code, response.content)) {
              deferred.resolve();
            }
            else {
              console.error('ModelStorage: batchFetch: rejecting model with URL: ' + response.relativeURL, + ' reason: ' + response.content);
              deferred.reject();
            }
          }
          catch(ex) {
            console.error("ModelStorage: batchFetch: exception while processing " + response.relativeURL, ex);
          }

        }, this);
      }, this));

      var deferreds = _.map(modelHolders, function(modelHolder) {
        return modelHolder.deferred;
      }, this);

      return $.when.apply($, deferreds);
    },

    clear: function() {
      this._modelHolderQueue = [];
      if(this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
    }
  };

  var PayloadTypes = {
    MODEL: 'MODEL', //payload contains a json to parse a model
    ARRAY_OF_MODELS: 'ARRAY_OF_MODELS', //payload contains an array of json to parse a model collection
    ARRAY_OF_FAKE_MODELS: 'ARRAY_OF_FAKE_MODELS', //payload contains data used for construction a model collection
    ARRAY_OF_IDS: 'ARRAY_OF_IDS', //payload contains an array of models ids
    ARRAY_OF_CHANGED_MODELS: 'ARRAY_OF_CHANGED_MODELS' //the same as ARRAY_OF_MODELS but an array contains only changed models
  };


  var ModelStorage = {};
  ModelStorage.Helpers = Helpers;

  ModelStorage.StorageEvents = {
    Deleted: 'modelstorage:deleted',
    StorageCleared: 'modelstorage:cleared'
  };


  ModelStorage.WebSocketEvents = {
    Five9ExceptionDetails: '1',
    IncomingPreview: '2',
    CallCreated: '3',
    CallUpdated: '4',
    CallDeleted: '5',
    InteractionSessionUpdated: '6',
    ConfigurationUpdated: '7',
    PreviewCreated: '8',
    PreviewDeleted: '9',
    PreviewUpdated: '10',
    ActiveSkillsUpdated: '11',
    PresenceUpdated: '12',
    OptionsUpdated: '13',
    PermissionsUpdated: '14',
    AgentReadyPresencesUpdate: '15',
    SubscriptionUpdated: '16',
    LoginStateUpdated: '17',
    StationUpdated: '18',
    AgentRemovedFromSkill: '19',
    IncomingQueueCallback: '20',
    QueueCallbackCreated: '21',
    QueueCallbackUpdated: '22',
    QueueCallbackDeleted: '23',
    VoicemailCreated: '24',
    VoicemailUpdated: '25',
    VoicemailDeleted: '26',
    IncomingSkillVoicemail: '27',
    ForcedLogout: '28',
    SkillStatsSnapshot: '29',
    IncomingCall: '30',
    CallInterrupted: '31',//DEPRICATED
    NewInteraction: '32',
    PendingConnectorCreated: '33',
    PendingConnectorDeleted: '34',
    EchoCallStarted: '35',
    EchoCallEnded: '36',
    MaintenanceAnnounced: '37',
    MaintenanceCanceled: '38',
    AgentAddedToSkill: '39',
    NoAnswerOnTransferredCall: '40',
    AudioPlayerUpdated: '41',
    StationNeedsRestart: '42',
    ChatCreated: '43',
    ChatUpdated: '44',
    ChatDeleted: '45',
    ChatMessageReceived: '46',
    IncomingMessage: '47',
    NotReadyReasonCodesUpdated: '48',
    NotReadyReasonCodesDeleted: '49',
    LogoutReasonCodesUpdated: '50',
    LogoutReasonCodesDeleted: '51',
    CallQualityUpdated: '52',
    CallbackCreated: '53',
    CallbackUpdated: '54',
    CallbackDeleted: '55',
    ChannelsUpdated: '56',
    ResourcesBunchUpdate: '57',
    TransferFailed: '58',
    CampaignsUpdated: '59',
    CallLoggingSettingsChanged: '60',
    CampaignConfigUpdated: '61',
    DashboardSubscriptionCreated: '62',
    DashboardSubscriptionRemoved: '63',
    DashboardSubscriptionUpdateFailed: '64',
    MakeCallFailed: '65',
    CallVariablesUpdated: '66',
    CallVariablesDeleted: '67',
    MaintenanceStarted: '70',
    SwitchedToBackupHost: '71',
    SwitchedToPrimaryHost: '72',
    MaintenanceCompleted: '73',
    ClickToDialRequest: '74',
    ClickToDialRequestFailed: '75',
    IncomingSocialItem: '100',
    StatisticsHandledInteractions: '200',
    StatisticsDispositions: '201',
    StatisticsSkillsNotification: '202',

    Pong: '1202',

    ServerUnavailable: '1000',
    ServerMaintenanceSwitchoverRelogin: '1001',
    ServerMaintenanceSwitchoverReloginForced: '1002',
    JMSServerUnavailable: '1003',
    GRSwitchover: '1005',
    ServerConnected: '1010',
    DuplicateConnection: '1020',
    InteractionMessages: '10000',
    AgentMessages: '10001',
    StatisticsMessage: '10002',
    InstantMessage: '10003',
    InteractionStatusChanged: '10010',

    PongEvent: '1202'
  };

  ModelStorage.InternalEvents = {
    SkypeContactsUploaded: '99999001'
  };

  ModelStorage.Resources = {
    Call: 'CALL',
    ActiveSkills: 'ACTIVE_SKILLS',
    Skills: 'SKILLS',
    Preview: 'PREVIEW',
    Contact: 'CONTACT',
    CRMContact: 'CRM_CONTACT',
    Presence: 'PRESENCE',
    Options: 'OPTIONS',
    Permissions: 'PERMISSIONS',
    LoginState: 'LOGIN_STATE',
    Voicemail: 'VOICEMAIL',
    QueueCallbacks: 'QUEUE_CALLBACKS',
    Callbacks: 'CALLBACKS',
    Station: 'STATION',
    SkillStatsSnapshot: 'SKILL_STATS_SNAPSHOT',
    InteractionSessions: 'INTERACTION_SESSIONS',
    ContactSessions: 'CONTACT_SESSIONS',
    KeyStore: 'KEY_STORE',
    EchoCall: 'ECHO_CALL',
    PendingConnectors: 'PENDING_CONNECTORS',
    TextInteraction: 'TEXT_INTERACTION',
    Agent: 'AGENT',
    Statistics: 'STATISTICS',
    Instant: 'INSTANT',
    ReadyStates: 'READY_STATES',
    Subscriptions: 'SUBSCRIPTIONS',
    AgentsReadyPresences: 'AGENTS_READY_PRESENCES',
    // Added new resource id for the same resource and left old one for Web UI Agent
    AgentsReadyPresences2: 'AGENTS_READY_PRESENCES2',
    LogoutReasonCodes: 'LOGOUT_REASON_CODES',
    NotReadyReasonCodes: 'NOT_READY_REASON_CODES',
    Player: 'PLAYER',
    Channels: 'CHANNELS',
    InternalMessage: 'INTERNAL_MESSAGE',
    Campaigns: 'CAMPAIGNS',
    CampaignsConfig: 'CAMPAIGNS_CONFIG',
    Versions: 'VERSIONS',
    CallLoggingConfig: 'CALL_LOGGING_CONFIG',
    CustomerPortal: 'CUSTOMER_PORTAL',
    AgentGroups: 'AGENT_GROUPS',
    CallVariable: 'CALL_VARIABLE',
    StatisticsHandledInteractions: 'STATISTICS_HANDLED_INTERACTIONS',
    StatisticsDispositions: 'STATISTICS_DISPOSITIONS',
    StatisticsSkillsNotification: 'STATISTICS_SKILLS_NOTOFICATIONS',
    TimeZones: 'TIME_ZONES',
    SkypeContact: 'SKYPECONTACT',
    UCSettings: 'UC_SETTINGS'
  };

  ModelStorage.subscribeEvents = function() {
    this.vent.on(this.WebSocketEvents.ResourcesBunchUpdate, function(payload) {
      this.BunchModelsReload(payload);
    }, this);

    this.vent.on(this.WebSocketEvents.PresenceUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Presence, context, PayloadTypes.MODEL);
    }, this);

    this.vent.on(this.WebSocketEvents.LoginStateUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.LoginState, context, PayloadTypes.MODEL);
    }, this);

    //preview call
    this.vent.on(this.WebSocketEvents.IncomingPreview, function(payload, context) {
      this.createOrUpdateModelsWithPayload(payload.contact, this.Resources.Contact, context, PayloadTypes.MODEL);
      this.createOrUpdateModelsWithPayload(payload, this.Resources.Preview, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.PreviewUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Preview, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.PreviewDeleted, function(payload, context) {
      this.deleteModelsWithPayload(payload, this.Resources.Preview, context, PayloadTypes.MODEL);
    }, this);

    //call
    this.vent.on(this.WebSocketEvents.CallCreated, function(payload, context) {
      if (payload.contactLookupResult) {
        _.each(payload.contactLookupResult.contacts, _.bind(function(contact) {
          this.createOrUpdateModelsWithPayload(contact, this.Resources.Contact, context, PayloadTypes.MODEL);
        }, this));
      }
      this.createOrUpdateModelsWithPayload(payload, this.Resources.Call, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.CallUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Call, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.CallDeleted, function(payload, context) {
      /* Update is required when the call get transferred (or when leaving a conference)
      *  to save disposition for logging purposes in SalesForce
      */
      this.updateModelsWithPayload(payload, this.Resources.Call, context, PayloadTypes.MODEL);

      this.deleteModelsWithPayload(payload, this.Resources.Call, context, PayloadTypes.MODEL);
    }, this);

    // Text Interaction
    this.vent.on(this.WebSocketEvents.InteractionMessages, function(payload, context) {
      //TODO: update this.Resources.TextInteraction resource then server model will be create
    }, this);

    // Agent SCC messages from the server (login)
    this.vent.on(this.WebSocketEvents.AgentMessages, function(payload, context) {
      //TODO: update this.Resources.Agent resource then server model will be create
    }, this);

    // Statistics messages
    this.vent.on(this.WebSocketEvents.StatisticsMessage, function(payload, context) {
      //TODO: update this.Resources.Statistics resource then server model will be create
    }, this);

    // StatisticsHandledInteraction
    this.vent.on(this.WebSocketEvents.StatisticsHandledInteractions, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.StatisticsHandledInteractions, context, PayloadTypes.MODEL);
    }, this);

    // StatisticsDispositions
    this.vent.on(this.WebSocketEvents.StatisticsDispositions, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.StatisticsDispositions, context, PayloadTypes.MODEL);
    }, this);

    // StatisticsSkillsNotification
    this.vent.on(this.WebSocketEvents.StatisticsSkillsNotification, function(payload, context) {
      // this.updateModelsWithPayload(payload, this.Resources.StatisticsSkillsNotification, context, PayloadTypes.MODEL);
    }, this);

    // Instant or broadcast messages
    this.vent.on(this.WebSocketEvents.InstantMessage, function(payload, context) {
      this.createModelsWithPayload(payload, this.Resources.InternalMessage, context);
    }, this);

    //voicemail
    this.vent.on(this.WebSocketEvents.VoicemailCreated, function(payload, context) {
      if (payload.contactLookupResult) {
        _.each(payload.contactLookupResult.contacts, _.bind(function(contact) {
          this.createOrUpdateModelsWithPayload(contact, this.Resources.Contact, context, PayloadTypes.MODEL);
        }, this));
      }
      this.createOrUpdateModelsWithPayload(payload, this.Resources.Voicemail, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.VoicemailUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Voicemail, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.VoicemailDeleted, function(payload, context) {
      this.deleteModelsWithPayload(payload, this.Resources.Voicemail, context, PayloadTypes.MODEL);
    }, this);

    //queue callbacks
    this.vent.on(this.WebSocketEvents.IncomingQueueCallback, function(payload, context) {
      this.createOrUpdateModelsWithPayload(payload.contact, this.Resources.Contact, context, PayloadTypes.MODEL);
      this.createOrUpdateModelsWithPayload(payload, this.Resources.QueueCallbacks, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.QueueCallbackUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.QueueCallbacks, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.QueueCallbackDeleted, function(payload, context) {
      this.deleteModelsWithPayload(payload, this.Resources.QueueCallbacks, context, PayloadTypes.MODEL);
    }, this);

    //active Skills
    this.vent.on(this.WebSocketEvents.ActiveSkillsUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.ActiveSkills, context, PayloadTypes.ARRAY_OF_FAKE_MODELS);
    }, this);

    //skills
    this.vent.on(this.WebSocketEvents.AgentRemovedFromSkill, function(payload, context) {
      this.deleteModelsWithPayload(payload, this.Resources.Skills, context, PayloadTypes.ARRAY_OF_IDS);
    }, this);

    this.vent.on(this.WebSocketEvents.AgentAddedToSkill, function (payload, context) {
      this.createOrUpdateModelsWithPayload(payload, this.Resources.Skills, context, PayloadTypes.MODEL);
    }, this);

    //options
    this.vent.on(this.WebSocketEvents.OptionsUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Options, context, PayloadTypes.ARRAY_OF_FAKE_MODELS);
    }, this);

    //permissions
    this.vent.on(this.WebSocketEvents.PermissionsUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Permissions, context, PayloadTypes.ARRAY_OF_FAKE_MODELS);
    }, this);

    //station
    this.vent.on(this.WebSocketEvents.StationUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Station, context, PayloadTypes.MODEL);
    }, this);

    //ACD stats
    this.vent.on(this.WebSocketEvents.SkillStatsSnapshot, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.SkillStatsSnapshot, context, PayloadTypes.MODEL);
    }, this);

    //Echo call
    this.vent.on(this.WebSocketEvents.EchoCallStarted, function(payload, context){
      this.updateModelsWithPayload({echoCall: true}, this.Resources.EchoCall, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.EchoCallEnded, function(payload, context){
      this.updateModelsWithPayload({echoCall: false}, this.Resources.EchoCall, context, PayloadTypes.MODEL);
    }, this);

    // Not Ready and Logout Reason Codes
    this.vent.on(this.WebSocketEvents.NotReadyReasonCodesUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.NotReadyReasonCodes, context,  PayloadTypes.ARRAY_OF_CHANGED_MODELS);
    }, this);

    this.vent.on(this.WebSocketEvents.NotReadyReasonCodesDeleted, function(payload, context) {
      this.deleteModelsWithPayload(payload, this.Resources.NotReadyReasonCodes, context, PayloadTypes.ARRAY_OF_IDS);
    }, this);

    this.vent.on(this.WebSocketEvents.LogoutReasonCodesUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.LogoutReasonCodes, context,  PayloadTypes.ARRAY_OF_CHANGED_MODELS);
    }, this);

    this.vent.on(this.WebSocketEvents.LogoutReasonCodesDeleted, function(payload, context) {
      this.deleteModelsWithPayload(payload, this.Resources.LogoutReasonCodes, context, PayloadTypes.ARRAY_OF_IDS);
    }, this);

    //call variable
    this.vent.on(this.WebSocketEvents.CallVariablesUpdated, function (payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.CallVariable, context, PayloadTypes.ARRAY_OF_CHANGED_MODELS);
    }, this);

    this.vent.on(this.WebSocketEvents.CallVariablesDeleted, function(payload, context) {
      this.deleteModelsWithPayload(payload, this.Resources.CallVariable, context, PayloadTypes.ARRAY_OF_IDS);
    }, this);

    //callbacks
    this.vent.on(this.WebSocketEvents.CallbackCreated, function(payload, context) {
      this.createOrUpdateModelsWithPayload(payload, this.Resources.Callbacks, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.CallbackUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Callbacks, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.CallbackDeleted, function(payload, context) {
      this.deleteModelsWithPayload(payload, this.Resources.Callbacks, context, PayloadTypes.MODEL);
    }, this);

    //pending connectors
    this.vent.on(this.WebSocketEvents.PendingConnectorCreated, function(payload, context) {
      this.createOrUpdateModelsWithPayload(payload, this.Resources.PendingConnectors, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.PendingConnectorDeleted, function(payload, context) {
      this.deleteModelsWithPayload(payload, this.Resources.PendingConnectors, context, PayloadTypes.MODEL);
    }, this);

    //subscriptions
    this.vent.on(this.WebSocketEvents.AgentReadyPresencesUpdate, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.AgentsReadyPresences, context, PayloadTypes.MODEL);
      this.updateModelsWithPayload(payload, this.Resources.AgentsReadyPresences2, context, PayloadTypes.MODEL);
    }, this);
    this.vent.on(this.WebSocketEvents.SubscriptionUpdated, function(payload, context) {
      if (payload.name === 'skillStatsSnapshotSubscription') {
        console.log((new Date()).toISOString() + ' ' + payload.name + ': ' + context.eventReason);
      }
      this.updateModelsWithPayload(payload, this.Resources.Subscriptions, context, PayloadTypes.MODEL);
    }, this);

    //Player
    this.vent.on(this.WebSocketEvents.AudioPlayerUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Player, context, PayloadTypes.MODEL);
    }, this);

    //Channels
    this.vent.on(this.WebSocketEvents.ChannelsUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Channels, context, PayloadTypes.ARRAY_OF_FAKE_MODELS);
    }, this);
    this.vent.on(this.WebSocketEvents.InteractionStatusChanged, function(payload, context) {
      var channels = ModelStorage.findFromPayload(this.Resources.Channels, payload);
      if (channels && payload && payload.currentState && payload.currentState.unavailableChannels) {
        channels.updateInteractionStatus(payload.currentState.unavailableChannels);
      }
    }, this);

    //Campaigns
    this.vent.on(this.WebSocketEvents.CampaignsUpdated, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.Campaigns, context, PayloadTypes.ARRAY_OF_CHANGED_MODELS);
    }, this);

    //CampaignConfigUpdated
    this.vent.on(this.WebSocketEvents.CampaignConfigUpdated, function(payload){
      var modelConstructors = this.Helpers.ResourceType.getModelConstructors(this.Resources.CampaignsConfig);
      if (modelConstructors) {
        var modelId = this.extractModelIdFromPayload(modelConstructors, payload);
        var parentPath = this.Helpers.ResourceType.getParentPath(this.Resources.CampaignsConfig);
        var campaignConfigPath = this.Helpers.Path.modelPath(parentPath, modelConstructors, modelId);
        var campaignConfigModel = this._modelHash.model(campaignConfigPath);
        if (campaignConfigModel && campaignConfigModel.length) {
          // please see DE15982
          if (payload.defaultCampaignId === null) {
            payload.defaultCampaignId = "0";
          }
          campaignConfigModel.at(0).set(payload);
        }
      }
    }, this);

    //organization config
    this.vent.on(this.WebSocketEvents.CallLoggingSettingsChanged, function (payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.CallLoggingConfig, context, PayloadTypes.MODEL);
    }, this);

    //Skype Contacts
    this.vent.on(this.InternalEvents.SkypeContactsUploaded, function(payload, context) {
      this.updateModelsWithPayload(payload, this.Resources.SkypeContact, context, PayloadTypes.ARRAY_OF_FAKE_MODELS);
    }, this);
  };

  ModelStorage.initialize = function (vent, options) {
    this._modelHash = this.Helpers.ModelHash.initialize();
    this.vent = vent;
    this.subscribeEvents();
    this.options = options || {};
    this.pipeId = 0;
    return this;
  };

  ModelStorage.clear = function() {
    this.pipeId++;
    console.log("PipeId just changed", this.pipeId);
    this._modelHash.clear();
    this.Helpers.BatchQueue.clear();
    this.vent.trigger(ModelStorage.StorageEvents.StorageCleared);
  };

  ModelStorage.BunchModelsReload = function(payload){
    _.each(payload.resourceURls, function(pattern){
      this.ReloadModelsHashByKeyPattern(pattern);
    }, this);
  };
  ModelStorage.ReloadModelsHashByKeyPattern = function (pattern) {
    var keys = this._modelHash.keysByPattern(pattern);
    _.each(keys, function(key) {
      this.fetch(Helpers.ModelHash.model(key), {cache: false});
    }, this);
  };

  ModelStorage.updateModelsWithPayload = function(payload, resourceId, context, payloadType) {
    console.debug ("ModelStorage:updateModelsWithPayload:enter event: " + (context && context.eventId) + "; payload: ", payload);
    var ModelConstructors = this.Helpers.ResourceType.getModelConstructors(resourceId);
    if(!ModelConstructors) {
      return;
    }

    var modelOrCollection = ModelStorage.findFromPayload(resourceId, payload);
    if (!modelOrCollection) {
      return;
    }

    this.setFetched(modelOrCollection);

    var updateModelFunction = _.bind(function() {
      console.debug ("ModelStorage:updateModelsWithPayload updating data for event: " + (context && context.eventId) + "; payload: ", payload);
      switch(payloadType) {
        case PayloadTypes.MODEL :
          if (modelOrCollection instanceof Backbone.Model) {
            // Backbone.Model does not support parse on set (see https://github.com/jashkenas/backbone/issues/2627)
            var newAttributes = modelOrCollection.parse(payload);
            modelOrCollection.set(newAttributes, {context:context});
            break;
          } //else goto case PayloadTypes.ARRAY_OF_MODELS
        /* falls through */
        case PayloadTypes.ARRAY_OF_MODELS :
          modelOrCollection.set(payload, {parse:true,context:context});
          break;
        case PayloadTypes.ARRAY_OF_CHANGED_MODELS :
          modelOrCollection.set(payload, {parse:true,context:context, remove: false});
          break;
        case PayloadTypes.ARRAY_OF_FAKE_MODELS :
          // convert the payload through Backbone.parse to ensure it is correctly interpreted by Backbone.set()
          // DETAILS:
          // when fetched via REST, models/collections are parsed using backbone
          // updates occur using Backbone.collection.set()
          // unfortunately, Backbone.collection.set() does not correctly parse both the collection and the embedded models
          payload = new ModelConstructors.Collection(payload, {parse:true}).toJSON();
          modelOrCollection.set(payload, {parse:true,context:context});
          break;
      }
    }, this);

    this.getFetchDeferrsPromise(modelOrCollection).done(updateModelFunction);
  };

  ModelStorage.createModelsWithPayload = function(payload, resourceId, context) {
    console.debug ("ModelStorage:createModelsWithPayload:enter event: " + (context && context.eventId) + "; payload: ", payload);
    var ModelConstructors = this.Helpers.ResourceType.getModelConstructors(resourceId);
    if(!ModelConstructors) {
      return;
    }
    var modelId = this.extractModelIdFromPayload(ModelConstructors, payload);
    var parentPath = this.Helpers.ResourceType.getParentPath(resourceId);
    var createModelFunction = _.bind(function() {
      console.debug ("ModelStorage:createModelsWithPayload create model for event: " + (context && context.eventId) + "; payload: ", payload);
      var modelOrCollection = ModelStorage.findFromPayload(resourceId, payload);
      if (!modelOrCollection) {
        modelOrCollection = this.createModel(parentPath, ModelConstructors, modelId, payload, {parse: true, context: context});
        this.setFetched(modelOrCollection);
      }
    }, this);
    if(ModelConstructors.Collection) {
      var collectionPath = this.Helpers.Path.collectionPath(parentPath, ModelConstructors);
      var collection = this._modelHash.model(collectionPath);
      if (collection && collection.fetchDeferred) {
        collection.fetchDeferred.done(createModelFunction);
      } else {
        createModelFunction();
      }
    } else {
      createModelFunction();
    }
  };

  ModelStorage.createOrUpdateModelsWithPayload = function(payload, resourceId, context, payloadType) {
    var modelOrCollection = ModelStorage.findFromPayload(resourceId, payload);
    if (!modelOrCollection) {
      ModelStorage.createModelsWithPayload(payload, resourceId, context);
    } else {
      ModelStorage.updateModelsWithPayload(payload, resourceId, context, payloadType);
    }
  };

  ModelStorage.deleteModelsWithPayload = function(payload, resourceId, context, payloadType) {
    console.debug ("ModelStorage:deleteModelsWithPayload:enter event: " + (context && context.eventId) + "; payload: ", payload);
    var ModelConstructors = this.Helpers.ResourceType.getModelConstructors(resourceId);
    if(!ModelConstructors) {
      return;
    }

    var deleteModelFunction = _.bind(function() {
      console.debug ("ModelStorage:deleteModelsWithPayload delete model for event: " + (context && context.eventId) + "; payload: ", payload);
      var parentPath = this.Helpers.ResourceType.getParentPath(resourceId);
      switch(payloadType) {
        case PayloadTypes.MODEL :
          var modelId = this.extractModelIdFromPayload(ModelConstructors, payload);
          this.deleteModelsById(parentPath, ModelConstructors, modelId, context);
          break;
        case PayloadTypes.ARRAY_OF_IDS :
          this.deleteModelsById(parentPath, ModelConstructors, payload, context);
          break;
      }
    }, this);

    var modelOrCollection = ModelStorage.findFromPayload(resourceId, payload);
    this.getFetchDeferrsPromise(modelOrCollection).done(deleteModelFunction);
  };

  ModelStorage.deleteModelsById = function(parentPath, ModelConstructors, ids, context) {
    if (!ids) {
      return;
    }
    console.log("ModelStorage: deleteModelsById " + JSON.stringify(ids));
    if(ModelConstructors.Collection){
      var collectionPath = this.Helpers.Path.collectionPath(parentPath, ModelConstructors);
      var collection = this._modelHash.model(collectionPath);
      console.log("ModelStorage: deleting from collection " + collection);
      if(collection) {
        var removedModels = collection.remove(ids, {context:context});
        removedModels = _.isArray(removedModels)? removedModels: [removedModels];
        _.each(removedModels, function(model) {
          this.processDeletedModel(model);
        }, this);
      }
    }
    else {
      console.log("ModelStorage: deleting model");
      var id = _.isArray(ids) ? ids[0] : ids;
      var modelPath = this.Helpers.Path.modelPath(parentPath, ModelConstructors, id);
      var deletedModel = this._modelHash.model(modelPath);
        this._modelHash.clearModel(modelPath);
        this.processDeletedModel(deletedModel);
      }
  };

  ModelStorage.processDeletedModel = function(model) {
    var path = model.path();
    console.log('ModelStorage: deleting models with key', path);
    this.markDeleted(model);
    var childKeys = this._modelHash.keysByPattern(path);
    console.log('ModelStorage: deleting child models with keys', childKeys);
    _.each(childKeys, function(modelKey) {
      var deletingModel = this._modelHash.model(modelKey);
      this._modelHash.clearModel(modelKey);
      this.markDeleted(deletingModel);
    }, this);
  };

  ModelStorage.extractModelIdFromPayload = function(ModelConstructors, payload) {
    // extract model id (must parse in case id is not at root of payload or is built)
    var modelId;
    if(ModelConstructors.Model && _.isObject(payload) && !_.isArray(payload)) {
      var tempModel = new ModelConstructors.Model();
      modelId = tempModel.parse(payload).id;
    }
    return modelId;
  };

  ModelStorage.markDeleted = function(model) {
    model.deletedFromStorage = true;
    model.trigger(ModelStorage.StorageEvents.Deleted, model);
    if(!_.isEmpty(model._events)) {
      console.log('ModelStorage: Subscribers of the deleted model:', model._events);
    }
  };

  ModelStorage.isDeleted = function(model) {
    return !!model.deletedFromStorage;
  };

  ModelStorage.find = function (modelPath, collectionPath, modelId) {
    var model = this._modelHash.model(modelPath);

    if (!model) {
      var collection = this._modelHash.model(collectionPath);

      if (collection) {
        model = collection.get(modelId);
      }
    }

    return model;
  };
  ModelStorage.findFromPayload = function(resourceId, payload) {
    var modelConstructors = this.Helpers.ResourceType.getModelConstructors(resourceId);
    if(!modelConstructors) {
      return null;
    }

    modelConstructors = this.Helpers.ResourceType.getModelConstructors(resourceId);
    var modelId = this.extractModelIdFromPayload(modelConstructors, payload);
    var parentPath = this.Helpers.ResourceType.getParentPath(resourceId);
    var modelPath = this.Helpers.Path.modelPath(parentPath, modelConstructors, modelId);
    var collectionPath = this.Helpers.Path.collectionPath(parentPath, modelConstructors);
    var modelOrCollection = this.find(modelPath, collectionPath, modelId);
    return modelOrCollection;
  };

  ModelStorage.get = function (parentPath, ModelConstructors, modelId, modelAttributes) {
    var modelPath = this.Helpers.Path.modelPath(parentPath, ModelConstructors, modelId);
    var collectionPath = this.Helpers.Path.collectionPath(parentPath, ModelConstructors);
    var model = this.find(modelPath, collectionPath, modelId);

    if (!model) {
      model = this.createModel(parentPath, ModelConstructors, modelId, modelAttributes);
    }

    return model;
  };

  ModelStorage.createModel = function (parentPath, ModelConstructors, modelId, modelAttributes, modelOptions) {
    var model;

    if(ModelConstructors.Collection) {
      var collectionPath = this.Helpers.Path.collectionPath(parentPath, ModelConstructors);
      var collection = this._modelHash.model(collectionPath);
      if(!collection) {
        collection = new ModelConstructors.Collection();
        collection._init(parentPath, ModelConstructors);

        this._modelHash.setModel(collection.path(), collection);
      }

      if(!_.isUndefined(modelId) && !_.isNull(modelId)) {
        model = new ModelConstructors.Model(modelAttributes, modelOptions);
        model._init(parentPath, modelId, ModelConstructors);
        collection.add(model);
      }
      else {
        model = collection;
      }
    }
    else {
      model = new ModelConstructors.Model(modelAttributes, modelOptions);
      model._init(parentPath, modelId, ModelConstructors);
      this._modelHash.setModel(model.path(), model);
    }

    this.Helpers.ResourceType.setModelData(parentPath, ModelConstructors);


    return model;
  };

  ModelStorage.fetch = function (model, options) {
    options = options || {};

    model.pipeId = this.pipeId;
    model.fetchDeferred = this.getFetchDeferred(model);
    var parentPath = model.parentPath;
    var modelConstructors = model.ModelConstructors;

    var that = this;
    var filterOnDone = function(){
      if (model.isCollection() && parentPath) {
        _.each(model.models, function(model) {
          model._init(parentPath, model.id, modelConstructors);
        });
      }

      var d = $.Deferred();
      if(that.pipeId !== model.pipeId){//defer never resolve
        console.log("PipeId has changed, all fetch callbacks should be ignored! for model: ", model.path());
      }
      else {
        d.resolve.apply(d, arguments);
      }
      return d.promise();
    };
    var filterOnFail = function(){
      var d = $.Deferred();
      if(that.pipeId !== model.pipeId){//defer never rejects
        console.log("PipeId has changed, all fetch callbacks should be ignored! for model: ", model.path());
      }
      else {
        d.reject.apply(d, arguments);
      }
      return d.promise();
    };

    if (!model.fetchDeferred || model.fetchDeferred.state() === 'rejected' || options.cache === false) {
      if((this.options.batchApi || options.batchApi) && !model.disableBatch) {
        var deferred = this.Helpers.BatchQueue.getScheduledDeferred(model);
        if(!deferred) {
          deferred = $.Deferred();
          if(options.cache !== false) {
            model.fetchDeferred = deferred;
          }
          else {
            model.fetchDeferred = model.fetchDeferred || deferred;
          }
          this.Helpers.BatchQueue.scheduleFetch(model,deferred);
        }
        return deferred.then(filterOnDone, filterOnFail).promise();
      }
      else {
        model.fetchDeferred = this.Helpers.Sync.fetch(model, options)
                                               .then(filterOnDone, filterOnFail);

        model.fetchDeferred.fail(_.bind(function () {
          console.error('ModelStorage: fetch error: [' + _.result(model, 'url') + ']', arguments);
          this.triggerError(arguments);
        }, this));
        return model.fetchDeferred.promise();
      }
    }

     return model.fetchDeferred.promise();
  };

  ModelStorage.getFetchDeferrsPromise = function(model) {
    var deferrs = [];
    if (model) {
      if (model.fetchDeferred) {
        deferrs.push(model.fetchDeferred);
      }
      if (model.collection && model.collection.fetchDeferred) {
        deferrs.push(model.collection.fetchDeferred);
      }
    }
    return $.when.apply($,deferrs);
  };

  ModelStorage.getFetchDeferred = function(model) {
    var deferred = model.fetchDeferred;
    if(!deferred && model.collection) {
      //if parent collection is fetched the child model will be fetched too
      deferred = model.collection.fetchDeferred;
    }
    return deferred;
  };

  ModelStorage.isFetched = function (model) {
    var deferred =  this.getFetchDeferred(model);
    return deferred && (deferred.state() === 'resolved') || false;
  };

  ModelStorage.setFetched = function(model){
    if(!model.fetchDeferred) {
      model.fetchDeferred = $.Deferred().resolve().promise();
    }
  };

  ModelStorage.trigger = function() {
    if (this.vent) {
      this.vent.trigger.apply(this.vent, arguments);
    }
  };
  ModelStorage.triggerError = function(error) {
    if (this.vent) {
      this.trigger('ModelStorage:error', error);
    }
  };

  ModelStorage.eventIdToValue = function(eventId) {
    return _.invert(ModelStorage.WebSocketEvents)[eventId];
  };

  return ModelStorage;
});

define('server.models.adapter',[
  'jquery',
  'server.models.storage',
  'backbone',
  'dataAdapter-api',
  'underscore'
],
function($, ModelStorage, Backbone, API, _) {
  var Helpers = {};

  Helpers.getUrlParts = function (obj, fields) {
    return _.map(fields, _.bind(function (pathPart) {
      return _.result(this, pathPart);
    }, obj));
  };


  var ModelAdapter = {
    Events: {
      ActionSuccess: 'modelAdapter:action:success',
      ActionError: 'modelAdapter:action:error'
    },

    options: {},

    initialize: function (options) {
      this.options = options || {};
    }
  };

  /**
   * @class ServerModel
   * @extends Backbone.Model
   */
  var a = 5;


  ModelAdapter.Model = Backbone.Model.extend({
    /**@lends ServerModel
     */
    _init: function (parentPath, modelId, ModelConstructors) {
      this.parentPath = parentPath;
      if (_.isString(modelId) && modelId.length > 0) {
        this.set('id', modelId);
      }
      this._actionErrorHandler = function(){};
      this.ModelConstructors = ModelConstructors;
    },

    /**
     * @memberof ServerModel
     */
    path: function () {
      var pathParts = Helpers.getUrlParts(this, ['parentPath', 'apiClassType', 'id']);
      if (this.collection) {
        pathParts = _.defaults(Helpers.getUrlParts(this.collection, ['parentPath']), pathParts);
      }
      var path = ModelStorage.Helpers.Path.createPath(pathParts);
      if (this.urlQueryParams && !_.isEmpty(this.urlQueryParams)) {
        path += '?' + $.param(this.urlQueryParams);
      }
      return path;
    },

    url: function (addSocial) {
      return ModelStorage.Helpers.Path.createPath(API.urlRoot(), this.path(addSocial));
    },

    isCollection: function () {
      return false;
    },

    /**
     * @memberof ServerModel
     * @description fetches model from server
     * @returns {Promise}
     */
    fetch: function (options) {
      return ModelStorage.fetch(this, options);
    },
    save: function(attrs, options) {
      if (this instanceof Backbone.Model) {
        if (!_.isUndefined(attrs)) {
          options = options || {};
          options.data = JSON.stringify(attrs);
        }

        return Backbone.Model.prototype.save.call(this, attrs, options);
      }
      throw new Error('Model must be a Backbone.Model');
    },

    set: function(attrs, options) {
      this.update_timestamp = _.now();
      return Backbone.Model.prototype.set.call(this, attrs, options);
    },

    isFetched: function () {
      return ModelStorage.isFetched(this);
    },

    isDeleted: function() {
      return ModelStorage.isDeleted(this);
    },

    /**
     * @memberof ServerModel
     * @returns {Promise}
     */
    performAction: function(action, data, verb, suppressError, params, skipModelUpdate, ajaxOptions, addSocial) {
      verb = verb || 'PUT';
      suppressError = suppressError || false;

      var d = $.Deferred();

      var localSkipModelUpdate = skipModelUpdate;
      if (_.isBoolean(ModelAdapter.options.skipModelsUpdate)) {
        localSkipModelUpdate = ModelAdapter.options.skipModelsUpdate;
      }

      var url = this.url(addSocial);
      API.xhr(url, verb, action, data, params, ajaxOptions)
        .done(_.bind(function(attrs, status, xhr) {
          if (!localSkipModelUpdate && xhr.status === 200 && _.isObject(attrs)) {
            attrs = this.parse(attrs);
            this.set(attrs);
          }

          var result = {
            id: this.get('id'),
            action: action,
            attrs: attrs,
            responseCode: xhr.status
          };
          this.trigger(ModelAdapter.Events.ActionSuccess, result);
          ModelStorage.trigger(ModelAdapter.Events.ActionSuccess, result);

          console.info('performAction success', result);
          d.resolve({action:action,attrs:attrs});
        }, this))
        .fail(_.bind(function(xhr, status, error) {
          var args = {
            id:this.get('id'),
            xhr:xhr,
            status:status,
            error:error,
            action: action
          };

          if (!suppressError && status !== 'abort') {
            this.trigger(ModelAdapter.Events.ActionError, args);
            ModelStorage.trigger(ModelAdapter.Events.ActionError, args);
          }

          d.reject(xhr, status, error);
        }, this));

      var result = d.promise().fail(this._actionErrorHandler);
      this._actionErrorHandler = function(){};
      return result;
    },

    uploadFile: function(action, formData, verb) {
      verb = verb || 'PUT';
      var url = _.result(this, 'url');
      return API.xhrFileUpload(url, verb, action, formData);
    },

    setActionErrorHandler: function(handler) {this._actionErrorHandler = handler;}
  });


  ModelAdapter.Collection = Backbone.Collection.extend({
    model: this.Model,

    _init: function (parentPath, ModelConstructors) {
      this.parentPath = parentPath;
      this.ModelConstructors = ModelConstructors;
    },

    path: function () {
      var pathParts = Helpers.getUrlParts(this, ['parentPath', 'apiClassType']);
      return ModelStorage.Helpers.Path.createPath(pathParts);
    },

    url: function (social) {
      return ModelStorage.Helpers.Path.createPath(API.urlRoot(), this.path(social));
    },

    isCollection: function () {
      return true;
    },

    isNew: function () {
      return false;
    },

    fetch: function (options) {
      return ModelStorage.fetch(this, options);
    },

    isFetched: function () {
      return ModelStorage.isFetched(this);
    }
  });


  var modelCompare = function(modelA, modelB, attributeObj) {
    var normaliseValue = function(value) {
      if(typeof value === 'string') {
        value = value.toLowerCase();
      }
      return value;
    };

    var result = 0;
    var modelAValue;
    var modelBValue;
    if (attributeObj.func) {
      modelAValue = normaliseValue(modelA[attributeObj.func]());
      modelBValue = normaliseValue(modelB[attributeObj.func]());
    }
    else {
      modelAValue = normaliseValue(modelA.get(attributeObj.attribute));
      modelBValue = normaliseValue(modelB.get(attributeObj.attribute));
    }

    if (_.isString(modelAValue) > _.isString(modelBValue)) {
      result = modelAValue.localeCompare(modelBValue);
    }
    else if (modelAValue > modelBValue) {
      result = 1;
    }
    else if (modelAValue < modelBValue) {
      result = -1;
    }

    if (attributeObj.order === 'descending') {
      result = -result;
    }
    return result;
  };


  ModelAdapter.multiSort = function(modelA, modelB, attributes) {
    var compResult;
    if (modelA instanceof Backbone.Model && modelB instanceof Backbone.Model) {
      compResult = modelCompare(modelA, modelB, attributes[0]);
      if (compResult === 0 && attributes.length > 1) {
        attributes.splice(0, 1);
        compResult = ModelAdapter.multiSort(modelA, modelB, attributes);
      }
      return compResult;
    }

    throw new Error('Both models must be Backbone Models');
  };

  return ModelAdapter;
});

define('models/server/freedom.helpers',[
  'underscore'
],
function(_) {
  var Helpers = {};

  Helpers.ModelMixin = {
    useFreedomCredentials: true
  };
  Helpers.CollectionMixin = {
    useFreedomCredentials: true
  };
  Helpers.ModelContactMixin = {
    getContactId: function(index) {
      var ids = this.getContactIds();
      if (ids.length) {
        return ids[0];
      }
      return null;
    },
    getContactIds: function() {
      var ids = [];
      var info = this.get('contactLookupResult');
      if (info && info.contacts) {
        ids = _.map(info.contacts, function(model) {
          return model.id;
        });
      }
      return ids;
    }
  };

  return Helpers;
});

define('models/server/acdStatus',[
  'underscore',
  'server.models.adapter',
  'jquery',
  'server.models.storage',
  './freedom.helpers'
],
/*
 * This provides ACD status
 */
function(_, ServerModels, $, ModelStorage, FreedomHelpers) {
  var AcdStatus = {
    apiClassType: 'skill_stats_Snapshot',
    resourceId: ModelStorage.Resources.SkillStatsSnapshot
  };

  AcdStatus.Model = ServerModels.Model.extend({
    apiClassType:AcdStatus.apiClassType,

    defaults: {
      data: {}
    },

    fetch: function() {
      return new $.Deferred().resolve().promise();
    },

    parse: function(response) {
      //response example { "349":{"skillId":"349","inQueueCallCount":1,"inQueueCallbackCount":0,"longestTimeInQueueSec":5} }
      return {data: response};
    },

    // isNew ensures that backbone will always save using PUT
    isNew: function() {
      return false;
    }
  });
  _.extend(AcdStatus.Model.prototype, FreedomHelpers.ModelMixin);
  return AcdStatus;
});


define('models/server/activeSkills',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
  var API = DataAdapter.API;

  var ActiveSkills = {
    apiClassType: 'active_skills',
    resourceId: ModelStorage.Resources.ActiveSkills
  };

  ActiveSkills.Model = ServerModels.Model.extend({
    apiClassType: ActiveSkills.apiClassType,
    defaults: {
    },

    parse: function(response) {
      if (_.isObject(response)) {
        return response;
      }
      return {id:response};
    }
  });
  _.extend(ActiveSkills.Model.prototype, FreedomHelpers.ModelMixin);

  ActiveSkills.Collection = ServerModels.Collection.extend({
    apiClassType: ActiveSkills.apiClassType,
    model: ActiveSkills.Model,

    parse: function(response) {
      if (response.skillIds) {
        response = response.skillIds;
      }
      return response;
    },
    save: function() {
      var activeSkills = _.map(this.toJSON(), function(model) {
        return model.id;
      });
      return API.performAction('agents/' + Five9.Context.AgentId + '/active_skills', 'PUT', null, null, activeSkills);
    }
  });
  _.extend(ActiveSkills.Collection.prototype, FreedomHelpers.CollectionMixin);

  return ActiveSkills;
});

define('models/server/agentOptions',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
  var API = DataAdapter.API;

  var AgentOptions = {
    apiClassType: 'options',
    resourceId: ModelStorage.Resources.Options
  };

  /**
   * @class AgentOptions
   * @extends {ServerModel}
   * @classdesc
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/agents/getOptions Freedom Api getOptions}
   * </pre>
   */
  AgentOptions.Model = ServerModels.Model.extend({
    apiClassType:AgentOptions.apiClassType,
    defaults: {
    },

    parse: function(response) {
      // list of strings to collection
      if (_.isString(response)) {
        var id = response;
        response = {id:id};
      }
      return response;
    }
  });
  _.extend(AgentOptions.Model.prototype, FreedomHelpers.ModelMixin);

  AgentOptions.Collection = ServerModels.Collection.extend({
    apiClassType:AgentOptions.apiClassType,
    model: AgentOptions.Model,

    isSet: function(option) {
      return (this.get(option)) ? true : false;
    },
    parse: function(response) {
      if (response.options) {
        response = response.options;
      }
      return response;
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setOptions Freedom Api setOptions}
     * @returns {Promise}
     * @memberof AgentOptions
     */
    save: function() {
      var parsed = _.map(this.toJSON(), function(model) {
        return model.id;
      });
      return API.performAction('agents/' + Five9.Context.AgentId + '/options', 'PUT', null, null, {options:parsed});
    }
  });
  _.extend(AgentOptions.Collection.prototype, FreedomHelpers.CollectionMixin);

  return AgentOptions;
});

define('models/server/agentsPassword',[
  'jquery',
  'server.models.adapter'
],
function($, ServerModels) {
  var AgentsPassword = {
    apiClassType: 'password'
  };

  AgentsPassword.Model = ServerModels.Model.extend({
    apiClassType: AgentsPassword.apiClassType,

    defaults: {
      oldPassword: '',
      newPassword: ''
    },

    fetch: function() {
      // dummy fetch, because we shouldn't get password from server
      return $.Deferred().resolve().promise();
    },

    setPassword: function(suppressError) {
      var payload = {
        oldPassword: this.get('oldPassword'),
        newPassword: this.get('newPassword')
      };
      return this.performAction(null, payload, 'PUT', suppressError);
    }
  });

  return AgentsPassword;
});

define('models/server/channels',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var Channels = {
    apiClassType: 'channels',
    resourceId: ModelStorage.Resources.Channels,
    Types: {
      Call: 'CALL',
      Chat: 'CHAT',
      Email: 'EMAIL',
      Social: 'SOCIAL',
      Voicemail: 'VOICE_MAIL'
    }
  };

  Channels.Model = ServerModels.Model.extend({
    apiClassType: Channels.apiClassType,
    defaults: {
      order: -1,
      type: 'ready'
    },

    parse: function(response) {
      // list of strings to collection
      response.id = response.type;
      return response;
    }
  });
  _.extend(Channels.Model.prototype, FreedomHelpers.ModelMixin);

  Channels.Collection = ServerModels.Collection.extend({
    apiClassType: Channels.apiClassType,
    model: Channels.Model,
    _unavailableChannels: [],

    comparator: function(item) {
      return item.get('order');
    },
    containsType: function(type) {
      return _.isUndefined(this.get(type)) ? false : true;
    },
    availableType: function(type) {
      var channel = this.get(type);
      return _.isUndefined(channel) ? false : _.indexOf(this._unavailableChannels, channel.id) === -1;
    },
    updateInteractionStatus: function(unavailableChannels) {
      if (!_.isUndefined(unavailableChannels)) {
        this._unavailableChannels = unavailableChannels;
        this.trigger('change');
      }
    },
    getUnavailableChannels: function() {
      return this._unavailableChannels;
    }
  });
  _.extend(Channels.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Channels;
});

define('models/server/agentPresence',[
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage',
  'underscore',
  'models/server/channels'
],
function(ServerModels, FreedomHelpers, ModelStorage, _, Channels) {
  var Presence = {
    apiClassType: 'presence',
    resourceId: ModelStorage.Resources.Presence
  };

  // use for setting "Agent ready/not-ready"
  /**
   * @class AgentsPresence
   * @extends ServerModel
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/agents/getPresence Freedom Api getPresence}
   * </pre>
   */
  Presence.Model = ServerModels.Model.extend({
    apiClassType:Presence.apiClassType,

    defaults: {
      currentState: {
        readyChannels: [],
        notReadyReasonCodeId: ''
      },
      pendingState: {
        readyChannels: [],
        notReadyReasonCodeId: ''
      },
      currentStateTime: 0
    },

    // isNew ensures that backbone will always save using PUT
    isNew: function() {
      return false;
    },

    isReady: function() {
      return !_.isEmpty(this.get('currentState').readyChannels);
    },
    isReadyForCall: function() {
      return _.contains(this.get('currentState').readyChannels, Channels.Types.Call);
    },
    isReadyForVM: function() {
      return _.contains(this.get('currentState').readyChannels, Channels.Types.Voicemail);
    },
    isReadyForEmail: function() {
      return _.contains(this.get('currentState').readyChannels, Channels.Types.Email);
    },
    isReadyForChat: function() {
      return _.contains(this.get('currentState').readyChannels, Channels.Types.Chat);
    },
    isReadyForSocial: function() {
      return _.contains(this.get('currentState').readyChannels, Channels.Types.Social);
    },
    isReadyForText: function() {
      return (this.isReadyForEmail() || this.isReadyForChat() || this.isReadyForSocial()) ;
    },
    canMakeCall: function() {
      return true;
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setPresence Freedom Api setPresence}
     * @param {Array} readyChannels
     * @returns {Promise}
     * @memberof AgentsPresence
     */
    setReadyChannels: function(readyChannels) {
      var payload = {
        readyChannels:readyChannels,
        notReadyReasonCodeId: 0
      };
      return this.performAction('', payload, 'PUT', undefined, undefined, true);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setPresence Freedom Api setPresence}
     * @param {string} reasonCodeId
     * @returns {Promise}
     * @memberof AgentsPresence
     */
    setNotReady: function(reasonCodeId) {
      var payload = {
        readyChannels: [],
        notReadyReasonCodeId: reasonCodeId
      };
      return this.performAction('', payload, 'PUT', undefined, undefined, true);
    }

  });
  _.extend(Presence.Model.prototype, FreedomHelpers.ModelMixin);

  return Presence;
});

define('base.model',[
  'dataAdapter',
  'underscore'
],
function(DataAdapter, _) {
  var BaseModels = {};

  // model
  BaseModels.Model = DataAdapter.Model.extend({
  });

  // collection
  BaseModels.Collection = DataAdapter.Collection.extend({
    model: BaseModels.Model,
    clone: function() {
      return new this.constructor(this.models);
    }
  });

  return BaseModels;
});

define('models/server/callConstants',['base.model'],
  function(BaseModels) {
    // call states
    var CallConstants = {
      State:{
        Queued: 'QUEUED',
        Dialing: 'DIALING',
        RingingOurSide: 'RINGING_ON_OUR_SIDE',
        Offered: 'OFFERED',
        RingingOtherSide: 'RINGING_ON_OTHER_SIDE',
        Talking: 'TALKING',
        OnHold: 'ON_HOLD',
        Acw: 'WRAP_UP',
        Parked: 'PARKED',
        Finished: 'FINISHED',
        ParticipantRinging: 'CONFERENCE_PARTICIPANT_RINGING',
        ParticipantTalking: 'CONFERENCE_PARTICIPANT_TALKING',
        ParticipantConsulting: 'CONFERENCE_PARTICIPANT_CONSULTING'
      },
      Type:{
        Outbound : 'OUTBOUND',
        Inbound  : 'INBOUND',
        Test     : 'TEST',
        Agent    : 'AGENT',
        Autodial : 'AUTODIAL',
        Internal : 'INTERNAL',
        Queue_callback : 'QUEUE_CALLBACK',
        Visual   : 'VISUAL',
        InboundVoicemail   : 'INBOUND_VOICEMAIL',
        OutboundVoicemail   : 'OUTBOUND_VOICEMAIL',
        InternalVoicemail   : 'INTERNAL_VOICEMAIL',
        AgentPreview   : 'AGENT_PREVIEW',
        TestPreview   : 'TEST_PREVIEW',
        OutboundPreview   : 'OUTBOUND_PREVIEW'
      },
      ConferenceDispositioning: {
        Initiator : 'INITIATOR_DISPOSITION',
        LastAgent : 'LAST_AGENT_DISPOSITION',
        InitiatorDecides : 'INITIATOR_DECIDES_WHO_DISPOSITION'
      }
    };

    return CallConstants;
  });

define('models/server/notes',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var Notes = {
    apiClassType: 'comment',
    maxLength: 32768
  };

  // models / collections
  Notes.Model = ServerModels.Model.extend({
    apiClassType: Notes.apiClassType,

    defaults: {
      modified: 0,
      campaignId: 0,
      agentId: "",
      dispositionId: "",
      sessionId: "",
      type: "ContactSessionType",
      comment: ""
    }
  });
  _.extend(Notes.Model.prototype, FreedomHelpers.ModelMixin);

  Notes.Collection = ServerModels.Collection.extend({
    apiClassType: Notes.apiClassType,

    model: Notes.Model,

    initialize: function(options) {
    },

    comparator: function(a, b) {
      var at = a.get('modificationTime');
      var bt = b.get('modificationTime');
      if (at < bt) {
        return 1;
      }
      if (at > bt) {
        return -1;
      }
      return 0;
    }
  });
  _.extend(Notes.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Notes;
});

define('models/server/replies',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var Replies = {
    apiClassType: 'replies'
  };

  Replies.Model = ServerModels.Model.extend({
    apiClassType: Replies.apiClassType,

    defaults: {
      id:           null,
      fname:        null,
      lname:        null,
      parentId:     null,
      profileId:    null,
      replyText:    null,
      replyTime:    null,
      tenantId:     '-1',
      userId:       '-1'
      // tag:          '',
      // priority:     ''
    },

    initialize: function() {
    },

    parse: function(response) {
      response.replyTime = parseInt(response.replyTime, 10);

      if (!response.title) {
        response.title = 'This is the title';
      }

      var campaign = Five9.Context.Tenant.Campaigns().get(response.profileId);
      if (campaign && campaign.get('name')) {
        response.campaign = campaign.get('name');
      } else {
        response.campaign = 'None';
      }

      return response;
    }
  });
  _.extend(Replies.Model.prototype, FreedomHelpers.ModelMixin);

  Replies.Collection = ServerModels.Collection.extend({
    apiClassType: Replies.apiClassType,

    model: Replies.Model,

    initialize: function(options) {
    },

    comparator: function(item) {
      return (item.get('replyTime') * -1);
    }
  });
  _.extend(Replies.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Replies;
});

define('models/server/interactionMessageTypes',[
],
function() {
  var MessageTypes = {
    INTERACTIONS: 1100,
    SET_DISPOSITION: 1101,
    LOCK: 1102,

    SOCIAL_REPLY: 1120,
    EMAIL_REPLY: 1121,
    HISTORY_REPLY: 1122,
    EMAIL_OUTBOUND: 1123,

    CHANGE_STATUS: 1202,
    CHANGE_STATUSES: 1203,

    TRANSFER_TO_GROUP: 1751,
    TRANSFERT_TO_AGENT: 1752,
    AGENT_TRANSFER_AGENT: 1753,

    OFFERED_ACD_INTERACTION: 19500,
    AGENT_ACCEPT: 19501,
    AGENT_REJECT: 19502,
    ASSIGNED: 19503,
    REJECTED: 19504,
    FORCED: 19505,
    OFFERED_CHERRY_INTERACTION: 19506,
    TERMINATE: 19507,

    PREVIEW_OFFER_ITEM: 19600,
    PREVIEW_ASSIGN_ITEM: 19601,
    PREVIEW_REJECT_ITEM: 19602,
    PREVIEW_ENGAGE_ITEM: 19603,
    PREVIEW_ENGAGE_ACCEPT_ITEM: 19604,
    PREVIEW_ENGAGE_REJECT_ITEM: 19605,

    CUSTOMER_CONTACT_UPDATE: 19608,

    PREVIEW_OFFER_CHERRY_ITEM: 19700,
    PREVIEW_LOCK_CHERRY_ITEM: 19701,


    // CHAT_CLIENT_REQUEST:                17001,
    CHAT_CLIENT_MESSAGE: 17002,
    CHAT_CLIENT_MESSAGE_RECEIVED: 17004,
    CHAT_CLIENT_TERMINATE: 17003,
    CHAT_CLIENT_TYPING: 17005,


    CHAT_AGENT_ACCEPT: 18000,
    CHAT_AGENT_MESSAGE: 18001,
    CHAT_AGENT_TERMINATE: 18002,
    CHAT_AGENT_TRANSFER: 18003,
    // CHAT_AGENT_MESSAGE_TO_AGENT:        18004,
    CHAT_AGENT_TYPING: 18005,
    CHAT_AGENT_MESSAGE_RECEIVED: 18007,
    CHAT_AGENT_ADD_AGENT_TO_CHAT: 18008,
    CHAT_AGENT_REMOVE_AGENT_FROM_CHAT: 18009,
    CHAT_NEW_CONFERENCE_INTERACTION: 18011,
    CHAT_SIGHTCALL_ESCALATION: 18012,
    CHAT_SIGHTCALL_VIDEO_ACTIVATED: 18013,
    CHAT_SIGHTCALL_VIDEO_TERMINATED: 18014
  };

  return MessageTypes;
});

define('models/server/chatMessages',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'utils',
  'models/server/interactionMessageTypes'
],
function(_, ServerModels, FreedomHelpers, Utils, MessageTypes) {
  Direction = {
    IN:               1,
    OUT:              2
  };

  ChatStates = {
    STATE_PENDING:    1,
    STATE_DELIVERED:  2,
    STATE_TYPING:     3,
    STATE_DELETING:   4
  };

  MessageContent = {
    MSG_TEXT:         1,
    MSG_HTML:         2,
    MSG_VOICE:        3,
    MSG_VIDEO:        4,
    MSG_FILE:         5
  };

  ChatFrom = {
    AGENT:            1,
    CLIENT:           2,
    SERVER:           3,
    TYPING:           4
  };

  var ChatMessages = {
    MaxLength: 2048,
    apiClassType: 'chat', // Not used, forcing the path to be returned using the function path

    removeDuplicates: function(userIds) {
      var uniq = _.uniq(userIds);
      userIds.length = 0;
      for (var i = 0; i < uniq.length; i++) {
        userIds.push(uniq[i]);
      }
    },
    validateUserIds: function(userIds, ownerId) {
      var agentId = Five9.Context.AgentId;

      for (var i1 = 0; i1 < userIds.length; i1++) {
        if (!_.isString(userIds[i1])) {
          userIds[i1] = userIds[i1].toString();
        }
      }

      // remove duplicates
      ChatMessages.removeDuplicates(userIds);

      // if no participants, empty userIds
      var participants = _.clone(userIds);
      participants = Utils.array_remove(participants, ownerId);
      if (participants.length === 0 && userIds.length > 0) {
        var copyUserIds = _.clone(userIds);
        for (var i = 0; i < copyUserIds.length; i++) {
          Utils.array_remove(userIds, copyUserIds[i]);
        }
      }

      // if participants, make sure ownerId is in array
      if (ownerId && participants.length > 0) {
        userIds.push(ownerId);
        ChatMessages.removeDuplicates(userIds);
      }

      // if participants, make sure agentId is in array
      if (participants.length > 0) {
        userIds.push(agentId);
        ChatMessages.removeDuplicates(userIds);
      }
    }
  };

  ChatMessages.Model = ServerModels.Model.extend({
    apiClassType: ChatMessages.apiClassType,

    defaults: {
      id:                       -1,                               /* Unique Id just so backbone insert the model into the collection */
      chatId:                   '',                               /* id of the interaction */
      content:                  '',                               /* Message content to be sent */
      displayName:              '',                               /* Name of who created the message */
      fromType:                 -1,                               /* AGENT, CLIENT, SERVER, TYPING*/
      messageId:                -1,                               /* Current message id in the form of chatId + (Client - '.c.' || Agent - '.a.' + <agentId>) + '.' + <incremental number> */
      timestamp:                -1,                               /* -1 by default or the server time the message was sent */
      date:                     ((new Date()).getTime() / 1000),  /* date in second when model was created */
      contentType:              -1,
      messageType:              -1,                               /* One of the possible values of MessageTypes */
      direction:                -1,                               /* IN (from someone) or OUT (current agent sending) */
      acknowledgement:          false,                            /* If a acknowledgement message need to be send */
      confirmations:            0,                                /* Number of confirmation received so far, must be equal to the number of users in the chat + 1 (for the client) */
      confirmationCompleted:    false,
      timerTyping:              null,
      processMessage:           false
    },

    initialize: function(option) {
      if (this.get('acknowledgement') === false) {
        this.set('confirmationCompleted', true);
      }
      if (this.get('processMessage')) {
        this.processMessage();
      }
    },

    parse: function(response) {
      response.chatId = response.id;
      response.id =  Utils.getUUID(); /* Need unique id for backbone's collection */

      response.userIds = response.userIds ? response.userIds : [];

      /**
       * Don't have the messageType in the history (and no need for it so just put -1 if not present)
       */
      response.messageType = Utils.isValid(response.messageType, -1);

      if (!response.messageId) {
        response.messageId = this.getMessageId();
      }

      response.typing = ((response.messageType == MessageTypes.CHAT_CLIENT_TYPING) || (response.messageType == MessageTypes.CHAT_AGENT_TYPING));

      if (response.messageType == -1 || !response.processMessage) {
        response.confirmationCompleted = true;
      }

      response.acknowledgement = (((response.messageType == MessageTypes.CHAT_CLIENT_MESSAGE) || (response.messageType == MessageTypes.CHAT_AGENT_MESSAGE) || (response.messageType == MessageTypes.CHAT_AGENT_MESSAGE_TO_AGENT) ) && (response.direction == Direction.IN));

      if (!_.isString(response.ownerId)) {
        Utils.reportIncorrectFormat('chatMessages', 'ownerId', response.ownerId);
        if (!_.isUndefined(response.ownerId)) {
          response.ownerId = response.ownerId.toString();
        }
      }

      // delete response.userids;

      return response;
    },

    path: function() {
      return ('agents/' + Five9.Context.AgentId + '/interactions/chat/' + this.get('chatId'));
    },

    getMessageId: function() {
      return  'agent.' + Five9.Context.Agent.id + '.' + (new Date()).getTime();
    },

    getPayload: function() {
      var payload = {
        messageId: this.get('messageId'),
        displayName: this.get('displayName'),
        content: this.get('content'),
        contentType: this.get('formatType'),
        ownerId: this.get('ownerId'),
        userIds: this.get('userIds')
      };
      ChatMessages.validateUserIds(payload.userIds, this.get('ownerId'));

      return payload;
    },

    processMessage: function() {
      var userIds;
      var messageType = this.get('messageType');
      var payload = this.getPayload();

      switch(messageType) {
        case MessageTypes.CHAT_AGENT_MESSAGE:
        case MessageTypes.CHAT_SIGHTCALL_ESCALATION:
        case MessageTypes.CHAT_SIGHTCALL_VIDEO_ACTIVATED:
        case MessageTypes.CHAT_SIGHTCALL_VIDEO_TERMINATED:
          console.info('SCC_DEBUG: message', payload);
          this.performAction('message', payload, 'POST', undefined, undefined, undefined, {registerResponse:true});
          break;

        case MessageTypes.CHAT_AGENT_TERMINATE:
          payload.profileId = this.get('profileId');
          console.info('SCC_DEBUG: terminate', payload);
          this.performAction('terminate', payload, 'POST', undefined, undefined, undefined, {registerResponse:true});
          break;

        case MessageTypes.CHAT_AGENT_TYPING:
          this.startTimerTyping();
          this.performAction('typing', payload, 'POST', undefined, undefined, undefined, {registerResponse:true});
          break;

        case MessageTypes.CHAT_AGENT_TRANSFER:
          console.info('SCC_DEBUG: transfer', payload);
          this.performAction('transfer', payload, 'POST', undefined, undefined, undefined, {registerResponse:true});
          break;

        case MessageTypes.CHAT_AGENT_ADD_AGENT_TO_CHAT:
          payload.addUserIds = this.get('addUserIds');
          payload.addUserNames = this.get('addUserNames');

          console.info('SCC_DEBUG: add_users', payload);
          this.performAction('add_users', payload, 'POST', undefined, undefined, undefined, {registerResponse:true});
          break;

        case MessageTypes.CHAT_AGENT_REMOVE_AGENT_FROM_CHAT:
          payload.removeUserIds = this.get('removeUserIds');
          payload.removeUserNames = this.get('removeUserNames');

          console.info('SCC_DEBUG: remove_users', payload);
          this.performAction('remove_users', payload, 'DELETE', undefined, undefined, undefined, {registerResponse:true});
          break;

        case MessageTypes.CHAT_CLIENT_TYPING:
          this.startTimerTyping();
          break;

        default:
          console.log('Nothing to send messageType (' + messageType + ')');
      }
    },

    needToSendAcknowledgement: function() {
      return this.get('acknowledgement');
    },

    confirmationReceived: function(timestamp) {
      var confirmations = this.get('confirmations');

      this.set({'timestamp': timestamp, 'confirmations': confirmations++});

      if (confirmations >= this.getNumberOfConfirmationNeeded()) {
        this.set('confirmationCompleted', true);
      }

      this.get('itemView').render();
    },

    getNumberOfConfirmationNeeded: function() {
      // return (this.get('userIds').length + 1);
      return (this.get('userIds').length);
    },

    remove: function() {
      if (this.get('itemView')) {
        this.get('itemView').remove();

        if (this.collection) {
          this.collection.remove(this);
        }
      }
    },

    resetTimerTyping: function() {
      if (this.timerTyping) {
        this.stopTimerTyping();

        this.startTimerTyping();
      }
    },

    startTimerTyping: function() {
      this.timerTyping = setTimeout(_.bind(function () {
        this.remove();
      }, this), 4000);
    },
    stopTimerTyping: function() {
      if (this.timerTyping !== null) {
        clearInterval(this.timerTyping);

        this.timerTyping = null;
      }
    }
  });
  _.extend(ChatMessages.Model.prototype, FreedomHelpers.ModelMixin);

  ChatMessages.Collection = ServerModels.Collection.extend({
    apiClassType: ChatMessages.apiClassType,

    model: ChatMessages.Model,


    add: function(model, options) {
      return ServerModels.Collection.prototype.add.apply(this, arguments);
    },
    comparator: function(item) {
      return item.get('date');
    },

    hasTimestamp: function(timestamp) {
      if (timestamp === -1) {
        return false;
      }
      return this.findWhere({timestamp:timestamp});
    },
    getClientTypingMessage: function() {
      return this.findWhere({'messageType': MessageTypes.CHAT_CLIENT_TYPING});
    },
    getAgentTypingMessage: function() {
      return this.findWhere({'messageType': MessageTypes.CHAT_AGENT_TYPING});
    }
  });
  _.extend(ChatMessages.Collection.prototype, FreedomHelpers.CollectionMixin);

  return ChatMessages;
});

define('models/server/customFields',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var CustomFields = {
    apiClassType: 'customfields'
  };

  CustomFields.Model = ServerModels.Model.extend({
    apiClassType: CustomFields.apiClassType,

    defaults: {
      key: '',
      value: ''
    },

    // initialize: function() {
    // },

    parse: function(response) {
      if (response.key.charAt(response.key.length - 1) == ':') {
        response.key = response.key.substring(0, response.key.length - 1);
      }

      return response;
    }

  });
  _.extend(CustomFields.Model.prototype, FreedomHelpers.ModelMixin);

  CustomFields.Collection = ServerModels.Collection.extend({
    apiClassType: CustomFields.apiClassType,

    model: CustomFields.Model,

    // initialize: function(options) {
    // },

    comparator: function(item) {
      return [item.get('key')];
    }
  });
  _.extend(CustomFields.Collection.prototype, FreedomHelpers.CollectionMixin);

  return CustomFields;
});

define('models/server/dispositions',[
    'underscore',
    'server.models.adapter',
    './freedom.helpers',
    'utils'
  ],
  function(_, ServerModels, FreedomHelpers, Utils) {
    var Dispositions = {
      apiClassType: 'dispositions',

      Constants: {
        NoTimeout: -1
      },
      Actions: {
        /**
         * Action disposing a call
         */
        DisposeCall: 'DISPOSE_CALL',
        /**
         * Action disposing transferring call
         */
        TransferCall: 'TRANSFER_CALL',
        /**
         * Action skipping preview
         */
        SkipPreview: 'SKIP_PREVIEW',
        /**
         * Action finalizing conference
         */
        EndConference: 'END_CONFERENCE'
      },
      Flags: {
        /**
         * If the flag is set agent must confirm setting of selected disposition
         */
        MustConfirm: 'MUST_CONFIRM',
        /**
         * Indicates if agent can set redial timeout for redial dispositions
         */
        AllowSetRedialTimer: 'ALLOW_SET_REDIAL_TIMER',
        /**
         * Indicates if agent can set reactivate timeout for reactivate dispositions
         */
        AllowSetReactivateTimer: 'ALLOW_SET_REACTIVATE_TIMER',
        /**
         * Indicates if disposition accepts custom redial timer
         */
        UseRedialTimer: 'USE_REDIAL_TIMER',
        /**
         * Indicates if disposition accepts reactivate timer
         */
        UseReactivateNumberTimer: 'USE_REACTIVATE_NUMBER_TIMER',
        /**
         * Indicates if disposition is open
         */
        IsOpen: 'SOCIAL_OPEN',
        /**
         * Indicates if disposition is closed
         */
        IsClose: 'SOCIAL_CLOSED'
      },
      System: {
        RejectPreviewOffer: '-1001',
        WithdrawPreview: '-1002'
      },

      isOpen: function(dispositionId) {
        return (dispositionId == '0' || dispositionId.charAt(0) == '-');
      }
    };

    Dispositions.Model = ServerModels.Model.extend({
      apiClassType:Dispositions.apiClassType,
      defaults: {
        name: '',
        description: '',
        timeout: null,
        actions: [],
        channelTypes: [],
        flags: [],
        numberForTransfersAndConferences: null
      },

      initialize: function(options) {
        options = options || {};

        if (!options.actions) {
          this.set({'actions': []});
        }
        if (!options.channelTypes) {
          this.set({'channelTypes': []});
        }
        if (!options.flags) {
          this.set({'flags': []});
        }
      },

      isClose: function() {
        return (this.get('flags').indexOf(Dispositions.Flags.IsClose) > -1);
      },

      parse: function(response) {
        if (response) {
          var name = response.displayName || response.name;
          response.name = _.isString(name) ? Utils.stripHtmlScripts(name) : "";
        }
        return response;
      }
    });
    _.extend(Dispositions.Model.prototype, FreedomHelpers.ModelMixin);

    Dispositions.Collection = ServerModels.Collection.extend({
      apiClassType:Dispositions.apiClassType,
      model: Dispositions.Model,

      comparator: function(item) {
        return [item.get('name').toLowerCase()];
      },

      getSCCDisposition: function() {
        var filtered = this.filter(function(model) {
          if (_.contains(Dispositions.System, model.id)) {
            return false;
          }
          return (model.get('channelTypes').SOCIAL || model.get('channelTypes').CHAT || model.get('channelTypes').EMAIL);
        });
        return new Dispositions.Collection(filtered);
      },

      parse: function(response) {
        return response;
      }
    });
    _.extend(Dispositions.Collection.prototype, FreedomHelpers.CollectionMixin);

    return Dispositions;
  });

define('presentation.models.utils/altocloud.utils',[
  'five9',
  'utils'
],
function(Five9, Utils) {
  var altoCloudBaseUrl = 'https://app.altocloud.com/gadgets';
  var AltocloudUtils = {
    VariableKey: 'Altocloud.VisitId',
    CustomerKey: 'Altocloud.CustomerId',
    PersonaKey: 'Altocloud.PersonaId',

    altoCloudId: {
      visitId: 'Altocloud.VisitId',
      customerId: 'Altocloud.CustomerId',
      shortId: 'Altocloud.ShortId'
    },
    CompositeGadgetByVisitIdUrl: altoCloudBaseUrl + '/customer-composite/?visitId={0}&accessToken={1}&css={2}',

    CompositeGadgetByShortIdUrl: altoCloudBaseUrl + '/customer-composite/?shortId={0}&accessToken={1}&css={2}',

    CustomerJourneyByVisitIdUrl: altoCloudBaseUrl + '/customer-journey/?visitId={0}&accessToken={1}&css={2}',

    SummaryUrl: altoCloudBaseUrl + '/web-visit-summary/?customerId={0}&accessToken={1}&css={2}',
    CartUrl: altoCloudBaseUrl + '/ecommerce-customer-profile/?customerId={0}&accessToken={1}&css={2}',

    generateCompositeGadgetByVisitIdUrl: function(visitId) {
      return Utils.formatString(AltocloudUtils.CompositeGadgetByVisitIdUrl, visitId, this.getAccessToken(), this.getCssOverride());
    },
    generateCompositeGadgetByShortIdUrl: function(shortId) {
      return Utils.formatString(AltocloudUtils.CompositeGadgetByShortIdUrl, shortId, this.getAccessToken(), this.getCssOverride());
    },
    generateCustomerJourneyByVisitIdUrl: function(visitId) {
      return Utils.formatString(AltocloudUtils.CustomerJourneyByVisitIdUrl, visitId, this.getAccessToken(), this.getCssOverride());
    },
    generateSummaryUrl: function(customerId) {
      return Utils.formatString(AltocloudUtils.SummaryUrl, customerId, this.getAccessToken(), this.getCssOverride());
    },
    generateCartUrl: function(customerId) {
      return Utils.formatString(AltocloudUtils.CartUrl, customerId, this.getAccessToken(), this.getCssOverride());
    },
    getAccessToken: function() {
      return Five9.Context.Agent.WebAnalytics().get('token');
    },
    getCssOverride: function() {
      // Some browsers (mainly IE) does not have this property, so we need to build it manually...
      if (!window.location.origin) {
        window.location.origin = window.location.protocol + '//' + window.location.hostname + (window.location.port ? (':' + window.location.port) : '');
      }
      var origin = window.location.origin;
      var version = Five9.Context.Tenant.get('version');
      var agentVersion;
      var path;

      if (version) {
        agentVersion = version.agentVersion;
      }

      if (agentVersion) {
        path = origin + '/five9_clients/agent.v' + agentVersion + '/css/altocloud-override.css';
      }

      return path;
    }
  };

  return AltocloudUtils;
});

define('presentation.models.utils/campaign.utils',[
  'underscore'
],
function(_) {
  var CampaignUtils = {};

  CampaignUtils.NoneCampaignId = null;
  var CampaignsComparator = function (a, b) {
    if (_.isString(a.name) && _.isString(b.name)) {
      return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
    }
    return -1;
  };

  CampaignUtils.getCampaignName = function(campaignId, campaignsCollection) {
    if(campaignId === CampaignUtils.NoneCampaignId) {
      return _S('S_CAMPAIGN.S_NONE');
    }
    else {
      var campaignModel = campaignsCollection.get(campaignId);
      return campaignModel ? campaignModel.get('name') : _S('S_CAMPAIGN.S_NOT_FOUND');
    }
  };

  CampaignUtils.getCampaignId = function(campaignName, campaignsCollection) {
    var campaign = _.find(campaignsCollection.models, function (campaign) {
      return campaign.get('name') === campaignName;
    });
    var campaignId = '-1';
    if (campaign) {
      campaignId = campaign.get('id');
    }
    return campaignId;
  };

  CampaignUtils.computeCampaigns = function(campaignsCollection, campaignConfig) {
    if (!campaignConfig) {
      return null;
    }
    var campaignIds = [];
    var defaultCampaignId = campaignConfig.get('defaultCampaignId');
    if (defaultCampaignId) {
      campaignIds = [defaultCampaignId];
    }
    if (campaignConfig.get('selectAllowed')) {
      campaignIds = _.union(campaignIds, campaignConfig.get('campaignIds'));

      if (campaignConfig.get('selectNoneAllowed')) {
        campaignIds = _.union(campaignIds, [CampaignUtils.NoneCampaignId]);
      }
    }
    var campaigns = _.map(campaignIds, function (campaignId) {
      return {
        id: campaignId,
        name: CampaignUtils.getCampaignName(campaignId, campaignsCollection)
      };
    });
    return _.sortBy(campaigns, function(item) {
      if (item.id === CampaignUtils.NoneCampaignId) {
        return "";
      }
      return item.name.toLowerCase();
    });
  };

  CampaignUtils.computeSortedCampaigns = function(campaignsCollection, campaignConfig) {
    var campaigns = this.computeCampaigns(campaignsCollection, campaignConfig);
    if (campaigns) {
      campaigns = campaigns.sort(CampaignsComparator);
    }
    return campaigns;
  };

  CampaignUtils.computeEmailCampaigns = function(campaignsCollection, activeSkills) {
    // unfortunately, all filtering has to be done on the client since API/SCC does not have a clean way to send associated campaigns
    var allCampaigns = campaignsCollection.toJSON();
    activeSkills = _.map(activeSkills.toJSON(), function(item) {
      return item.id;
    });

    var campaigns = _.filter(allCampaigns, function(item) {
      return _.intersection(activeSkills, item.skillIds).length && item.outEmail === 1;
    });
    return campaigns.sort(CampaignsComparator);
  };

  return CampaignUtils;
});

define('models/server/histories',[
  'server.models.adapter',
  './freedom.helpers',
  'utils',
  'models/server/replies',
  'models/server/chatMessages',
  'models/server/customFields',
  'models/server/dispositions',
  'presentation.models.utils/altocloud.utils',
  'presentation.models.utils/campaign.utils'
],
function(ServerModels, FreedomHelpers, Utils, Replies, ChatMessages, CustomFields, Dispositions, AltocloudUtils, CampaignUtils) {
  var Histories = {
    apiClassType: 'history',

    MediaTypes: {
      SOCIAL:                 1,
      NOTE:                   100,
      CHAT:                   1000,
      AGENT_CHAT:             1010,
      EMAIL:                  2000,
      CALL:                   3000,
      VM:                     4000
    },

    ChatStates: {
      CHAT_STATE_ACTIVE:      1,
      CHAT_STATE_TEMINATED:   2
    }
  };

  Histories.Model = ServerModels.Model.extend({
    apiClassType: Histories.apiClassType,

    defaults: {
      agentName:        '',
      publishedDate:    -1,
      disposition:      null,
      dispositionId:    '0',
      dispositionTime:  -1,
      mediaType:        -1,
      subMediaType:     -1,
      open:             false,
      profile:          null,
      profileId:        '-1',
      sentiment:        -1,
      startTime:        -1,
      title:            null,
      wasResponded:     -1,
      workedById:       '-1',
      contactId:        null,
      from:             '', // When a call, phone number, when a vm, phone number, when text, email address
      to:               '',
      comment:          '',
      priority:         '',
      attributes:       ''
    //  talkTime:         0,
    //  wrapTime:         0
    },

    initialize: function() {
    },

    parse: function(response) {
      // console.log('History response', response);

      if (response.mediaType === 0 || response.mediaType == 1) {
        response.media = Five9.Context.Tenant.Medias().search(response.source);
      } else if (response.mediaType == 2) {
        response.media = Five9.Context.Tenant.Medias().search('article');
      } else if (response.mediaType == 3) {
          response.media = Five9.Context.Tenant.Medias().search('blogger');
      } else if (response.mediaType >= 60 && response.mediaType <= 62) {
        response.subMediaType = response.mediaType;
        response.mediaType = Histories.MediaTypes.VM;
      } else if (response.mediaType >= 5 && response.mediaType < 100) {
        response.subMediaType = response.mediaType;
        response.mediaType = Histories.MediaTypes.CALL;
      } else if (response.mediaType == 100) {
          response.media = Five9.Context.Tenant.Medias().search('note');
      } else if (response.mediaType == 1000) {
          response.media = Five9.Context.Tenant.Medias().search('chat');
      } else if (response.mediaType == 1010) {
          response.media = Five9.Context.Tenant.Medias().search('agentchat');
      } else if (response.mediaType == 2000) {
          response.media = Five9.Context.Tenant.Medias().search('email');
      } else {
          response.media = Five9.Context.Tenant.Medias().search('');
      }

      response.sentiment = parseFloat(Utils.isValid(response.sentiment, 0), 10);
      response.spam = parseFloat(Utils.isValid(response.spam, 0), 10);
      response.issue = parseInt(Utils.isValid(response.issue, 0), 10);

      response.replies = new Replies.Collection(Utils.isValid(response.replies, null), { parse: true });

      response.to = Utils.isValid(response.to, '');
      response.from = Utils.isValid(response.from, '');
      response.cc = Utils.isValid(response.cc, '');
      response.comment = Utils.isValid(response.comment, '');
      response.title = Utils.isValid(response.title, '');

      if (response.source === null) {
        response.source = 'default';
      }

      if (!_.isUndefined(response.dispositionId)) {
        if (!_.isString(response.dispositionId)) {
          Utils.reportIncorrectFormat('histories', 'dispositionId', response.dispositionId);
          response.dispositionId = response.dispositionId.toString();
        }

        /*
        hacky work around for SCC using the -1 dispositionId differently from VCC
        */
        if (response.dispositionId == '-1') {
          response.dispositionId = '0';
        }

        var disposition = Five9.Context.Tenant.Dispositions().get({id: response.dispositionId});
        if (disposition) {
          response.disposition = disposition.get('name');
        }
        else {
          response.disposition = 'None';
        }

        response.isOpen = Dispositions.isOpen(response.dispositionId);
      }

      if (response.profileId === CampaignUtils.NoneCampaignId) {
        response.campaign = 'None';
        if (response.profileId && response.profileId !== '0') {
          console.warn(Utils.formatString('Unable to find campaign[{0}] for history[{1}]', response.profileId, response.id));
        }
      }
      else {
        var campaign = Five9.Context.Tenant.Campaigns().get(response.profileId);
        if (campaign) {
          response.campaign = campaign.get('name');
        }
        else {
          response.campaign = 'Deleted';
        }
      }

      var cluster = Five9.Context.Tenant.Clusters().get({id: response.clusterId});
      if (cluster) {
        response.clusterName = cluster.get('name');
      }
      else {
        response.clusterName = 'None';
        if (response.clusterId && response.clusterId !== '0') {
          console.warn(Utils.formatString('Unable to find cluster[{0}] for history[{1}]', response.clusterId, response.id));
        }
      }

      response.topicName = Utils.isValid(response.topicName, 'None');
      response.priority = Utils.isValid(response.priority, 'None');
      response.attributes = Utils.isValid(response.attributes, 'None');

      response.publishedDate = parseInt(response.datePublished, 10);
      response.dispositionTime = parseInt(response.dispositionTime, 10);
      response.startTime = parseInt(response.startTime, 10);

      var agent = Five9.Root.Agents().get({id: response.workedById});
      if (agent) {
        response.agentName = agent.get('fullName');
      } else {
        response.agentName = '';
      }

      var i = 0;
      var jsonMessages = null;
      var tmp = null;

      if ((response.mediaType == Histories.MediaTypes.CHAT) || (response.mediaType == Histories.MediaTypes.AGENT_CHAT)) {
        tmp = new ChatMessages.Collection();
        var messages = [];
        jsonMessages = Utils.safeJSONParse(Utils.isValid(response.fullData, '[]'), '[]');
        for (i=0; i<jsonMessages.length; i++) {
          jsonMessages[i].id = jsonMessages[i].id + '.' + (i + 1);
          messages.push(new ChatMessages.Model(jsonMessages[i], {parse: true, silent: true}));
        }
        tmp.set(messages, {parse: false, silent: true});
      }
      else if (response.mediaType == Histories.MediaTypes.EMAIL) {
        tmp = '';

        jsonMessages = Utils.safeJSONParse(Utils.isValid(response.fullData, '[]'), '[]');
        // the data currently coming in this field appears to have an extra level of structure
        // this modification handles descending down a level to get at the desired data
        if (jsonMessages.length === 1 && _.isArray(jsonMessages[0].bodyType) && _.isArray(jsonMessages[0].textBodyPart)) {
          jsonMessages = Utils.safeJSONParse(Utils.isValid(jsonMessages[0].textBodyPart[0], '[]'), '[]');
        }
        for (i = 0; i < jsonMessages.length; i++) {
            switch (jsonMessages[i].bodyType) {
              case 1: // Text
                tmp = tmp.concat(Utils.linkify(jsonMessages[i].textBodyPart.replace(/\n/g, "<br />")));
                break;

              case 2: // HTML
                // tmp = tmp.concat(jsonMessages[i].textBodyPart.replace(/\n/g, ""));
                tmp = $('<div></div>').html(jsonMessages[i].textBodyPart.replace(/\n/g, ''));
                tmp.find('base').remove();
                tmp = tmp.html();
                break;

              case 3: // Binary
                 // Not handing this right now
                break;

              case 4: // Attachment
                // Don't do anything with attachments here
                break;
            }
        }
      }
      else {
        var fullData = response.fullData;
        var jsonData = Utils.safeJSONParse(Utils.isValid(fullData, '[]'), '[]');
        // the data currently coming in this field appears to have an extra level of structure
        // this modification handles descending down a level to get at the desired data
        if (jsonData.length === 1 && _.isArray(jsonData[0].bodyType) && _.isArray(jsonData[0].textBodyPart)) {
          fullData = jsonData[0].textBodyPart[0];
        }
        tmp = Utils.isValid(fullData, "").replace(/(<([^>]+)>)/ig,"");
        tmp = Utils.linkify(tmp);
        tmp = tmp.replace("ORIGINAL POST:", "<br><br>ORIGINAL POST:" );
      }

      response.data = tmp;

      if ((response.mediaType == Histories.MediaTypes.CHAT) || (response.mediaType == Histories.MediaTypes.AGENT_CHAT)) {
        try {
          if (_.isString(response.replyData)) {
            response.replyData = JSON.parse(response.replyData);
            response.chatCustomFields =  new CustomFields.Collection(response.replyData, { parse: true });
            delete response.replyData;

            var visitId = response.chatCustomFields.findWhere({key: AltocloudUtils.altoCloudId.visitId});
            if (visitId) {
              visitId = visitId.get('value');
              response.visitId = visitId;
              response.journeyLink = AltocloudUtils.generateCustomerJourneyByVisitIdUrl(visitId);
              console.log(Utils.formatString('Altocloud history: [{0}] visitId[{1}] link[{2}]', response.id, visitId, response.journeyLink));
            }
            var customerId = response.chatCustomFields.findWhere({key: AltocloudUtils.CustomerKey});
            if (customerId) {
              customerId = customerId.get('value');
              response.customerId = customerId;
              console.log(Utils.formatString('Altocloud cart: [{0}] customerId[{1}]]', response.id, customerId));
            }
          }
        }
        catch (ex) {
          console.error('Error parsing response.replyData', ex);
        }
      }

      delete response.datePublished;

      return response;
    },
    hasAltocloud: function() {
      return Utils.string_nonEmpty(this.get('journeyLink'));
    },
    hasVideo: function() {
      return false;
    }
  });
  _.extend(Histories.Model.prototype, FreedomHelpers.ModelMixin);

  Histories.Collection = ServerModels.Collection.extend({
    apiClassType: Histories.apiClassType,

    model: Histories.Model,

    initialize: function() {
      this.field = 'publishedDate';
      this.ascending = true;
    },
    setContactId: function(contactId) {
      this.each(function(model) {
        if (!model.get('contactId')) {
          model.set('contactId', contactId);
        }
      });
    },

    findCustomerIds: function() {
      var models = this.map(function(model) {
        if (model.has('customerId')) {
          return model.get('customerId');
        }
      });
      models = _.compact(models);
      models = _.uniq(models);
      return models;
    },
    findVisitIds: function() {
      var models = this.map(function(model) {
        if (model.has('visitId')) {
          return model.get('visitId');
        }
      });
      models = _.compact(models);
      models = _.uniq(models);
      return models;
    },

    // sorting
    setSortedField: function(field) {
      this.field = field;
    },
    getSortedField: function() {
      return this.field;
    },
    setSortAscending: function() {
      this.ascending = true;
    },
    setSortDescending: function() {
      this.ascending = false;
    },
    isSortedAscending: function() {
      return this.ascending;
    },
    setSort: function(field, sortDirection) {
      this.setSortedField(field);
      if (sortDirection === 'descending') {
        this.setSortDescending();
      }
      else {
        this.setSortAscending();
      }
    },
    comparator: function(itemA, itemB) {
      var fieldA = itemA.get(this.field);
      var fieldB = itemB.get(this.field);

      if (this.field === "talkTime" || this.field === "wrapTime") {
        if (itemA.get("mediaType") !== Histories.MediaTypes.CALL) {
          fieldA = -1;
        }
        if (itemB.get("mediaType") !== Histories.MediaTypes.CALL) {
          fieldB = -1;
        }
      }

      if (_.isString(fieldA)) {
        fieldA = fieldA.toLowerCase();
      }
      if (_.isString(fieldB)) {
        fieldB = fieldB.toLowerCase();
      }
      if (fieldA > fieldB) {
        return -1 * (this.ascending ? -1 : 1);
      }

      if (fieldA < fieldB) {
        return 1 * (this.ascending ? -1 : 1);
      }

      return 0;
      // return ((this.ascending ? '' : '-') + item.get(this.field));
    }
  });
  _.extend(Histories.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Histories;
});

define('models/server/accounts',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'utils'
],
function(_, ServerModels, FreedomHelpers, Utils) {
  var Accounts = {
    apiClassType: 'accounts'
  };

  Accounts.Model = ServerModels.Model.extend({
    apiClassType: Accounts.apiClassType,
    defaults: {
      accountId: '',
      type: '',
      handleId: '',
      handleName: '',
      imageURL: '',
      relation: '',
      updateTime: '',
      media: null
    },

    initialize: function() {
    },

    parse: function(response) {
      var handleName = Utils.isValid(response.handleName, null);
      if (handleName !== null && handleName.length > 0 && handleName.charAt(0) == '/') {
        handleName = handleName.substring(1);
      }

      response.handleName = handleName;
      response.profileURL = Utils.isValid(response.profileURL, null);
      response.type = Utils.isValid(response.type, "").toLowerCase();
      response.media = Five9.Context.Tenant.Medias().findWhere({type: response.type});

      return response;
    },

    canUpdateAccount: function() {
      if (this.get('media')) {
        return this.get('media').canUpdateAccount();
      }
      return false;
    },

    canGetRelation: function() {
      if (this.get('media')) {
        return this.get('media').canGetRelation();
      }
      return false;
    }
    // ,
    // toJSON: function() {
    //   /*
    //    * Only need to send back type, handleId, handleName, imageURL and profileURL
    //    */
    //   var data = {
    //     handleName: this.get("handleName"),
    //     handleId: this.get("handleId"),
    //     url: this.get("url"),
    //     type: this.get("type"),
    //     imageURL: this.get("imageURL")
    //   };

    //   return data;
    // }
  });
  _.extend(Accounts.Model.prototype, FreedomHelpers.ModelMixin);

  Accounts.Collection = ServerModels.Collection.extend({
    apiClassType: Accounts.apiClassType,

    model: Accounts.Model,

    initialize: function(options) {
    },

    comparator: function(item) {
      return [item.get('name')];
    }
  });
  _.extend(Accounts.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Accounts;
});

define('models/server/topics',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var Topics = {
    apiClassType: 'topics'
  };

  Topics.Model = ServerModels.Model.extend({
    apiClassType: Topics.apiClassType,

    defaults: {
      id: '',
      topic: '',
      creationTime: ''
    },

    initialize: function() {
    },

    parse: function(response) {
      response.id = response.topicId;
      response.topic = response.topicName.trim();

      delete response.topicId;
      delete response.topicName;
      return response;
    }

  });
  _.extend(Topics.Model.prototype, FreedomHelpers.ModelMixin);

  Topics.Collection = ServerModels.Collection.extend({
    apiClassType: Topics.apiClassType,

    model: Topics.Model,

    initialize: function() {},

    comparator: function(item) {
      return item.get('topic');
    }
  });
  _.extend(Topics.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Topics;
});

define('models/server/authorHistory.helpers',[
  'models/server/histories'
],
function(Histories) {
  var Helpers = {
    HistoryStatus: {
      INIT:                 0,
      FETCHING:             1,
      RECEIVED:             2
    }
  };

  Helpers.ModelMixin = {
    loadOnSelect: function() {
      return true;
    },

    invalidateHistory: function() {
      this.set('historyStatus', Helpers.HistoryStatus.INIT);
    },

    isHistoryReady: function() {
      return (this.get('historyStatus') == Helpers.HistoryStatus.RECEIVED);
    },

    reloadHistory: function() {
      this.set('historyStatus', Helpers.HistoryStatus.INIT);
      this.loadHistory(this.get('period'), this.get('mediaTypes'), this.get('campaignIds'), this.get('includeDialAttempts'), this.get('from'), this.get('limit'));
    },

    loadHistory: function(period, mediaTypes, campaignIds, includeDialAttempts, from, limit, force) {
      if (this.id == -1) {
        return ;
      }

      var histories = this.get('histories');
      if (!histories) {
        histories = new Histories.Collection();
        this.set('histories', histories);
      }

      var payload = this.setHistoryPayload(period, mediaTypes, campaignIds, includeDialAttempts, from, limit, force);
      var self = this;
      if (this.get('historyStatus') === Helpers.HistoryStatus.INIT) {
        this.set('historyStatus', Helpers.HistoryStatus.FETCHING);

        this._loadHistory(payload)
          .done(function(response) {
            console.log('LoadHistory Success!');

            if (response && response.attrs) {
              response = response.attrs;
            }

            self.hasMore = response.hasMore;
            self.pagingCursor = response.id;
            response = response.records;

            histories.reset(response, {silent: true, parse: true});
            if (_.isFunction(histories.setContactId)) {
              histories.setContactId(self.id);
            }

            self.set('historyStatus', Helpers.HistoryStatus.RECEIVED);
            self.triggerHistoryReceived();
          })
          .fail(function(xhr, textStatus, error) {
            self.onLoadHistoryError(xhr, textStatus, error);
          });
      }
    },
    loadMoreHistory: function(period, mediaTypes, campaignIds, includeDialAttempts, from, limit, force) {
      var histories = this.get('histories');
      var payload = this.setHistoryPayload(period, mediaTypes, campaignIds, includeDialAttempts, from, limit, force);
      var self = this;
      if (this.get('historyStatus') === Helpers.HistoryStatus.INIT) {
        this.set('historyStatus', Helpers.HistoryStatus.FETCHING);

        this._loadHistory(payload)
          .done(function(response) {
            console.log('Call history Success!');

            if (response && response.attrs) {
              response = response.attrs;
            }

            self.hasMore = response.hasMore;
            response = response.records;

            histories.add(response, {silent: true, parse: true});
            if (_.isFunction(histories.setContactId)) {
              histories.setContactId(self.id);
            }

            self.set('historyStatus', Helpers.HistoryStatus.RECEIVED);
            self.triggerHistoryReceived();
          })
          .fail(function(xhr, textStatus, error) {
            self.onLoadHistoryError(xhr, textStatus, error);
          });
      }
    },

    setHistoryPayload: function(period, mediaTypes, campaignIds, includeDialAttempts, from, limit, force) {
      this.set({
        'limit': limit,
        'from': from,
        'period': period,
        'mediaTypes': mediaTypes,
        'campaignIds': campaignIds,
        'includeDialAttempts': includeDialAttempts
      });

      if (force) {
        this.set('historyStatus', Helpers.HistoryStatus.INIT);
      }

      var payload = {
        limit: limit,
        period: period,
        includeDialAttempts: includeDialAttempts,
        mediaTypes: mediaTypes,
        campaignIds: campaignIds
      };
      return payload;
    },
    onLoadHistoryError: function(xhr, textStatus, error) {
      console.error('LoadHistory Error!');

      var histories = this.get('histories');
      if (histories) {
        histories.reset();
      }
      this.set('historyStatus', Helpers.HistoryStatus.RECEIVED);
      this.triggerHistoryReceived();
    }
  };

  return Helpers;
});

define('models/server/authors',[
  'dataAdapter',
  'server.models.storage',
  'server.models.adapter',
  './freedom.helpers',
  'utils',
  'models/server/accounts',
  'models/server/topics',
  'models/server/histories',
  'models/server/authorHistory.helpers'
],
function(DataAdapter, ModelStorage, ServerModels, FreedomHelpers, Utils, Accounts, Topics, Histories, AuthorHistoryHelpers) {

  var API = DataAdapter.API;

  var Authors = {
    apiClassType: 'authors'
  };

  Authors.Model = ServerModels.Model.extend({
    apiClassType: Authors.apiClassType,

    defaults: {
      id: '',
      email: '',
      name: '',
      firstname: '',
      lastname: '',
      middleName: '',
      bio: '',
      imageURL: '',
      birthday: 0,
      locale: '',
      locationName: '',
      enterpriseScore: 0,
      influenceScore: 0,
      spamScore: 0,
      gender: -1,
      accounts: null,
      topicThreads: null,
      histories: null,
      historyStatus: 0,
      period: 'NONE',
      includeDialAttempts: false,
      mediaTypes: [],
      campaignIds: [],
      from: null,
      limit: null
    },

    initialize: function() {
    },

    parse: function(response) {
      var primaryEmailModel = Five9.Context.Tenant.ContactFields().getPrimaryField('EMAIL');
      if (!primaryEmailModel) {
        primaryEmailModel = Five9.Context.Tenant.ContactFields().assumePrimaryField('EMAIL');
      }
      var primaryEmailField = primaryEmailModel ? primaryEmailModel.get('name') : 'email';
      var email = response[primaryEmailField];
      if (Utils.string_nonEmpty(email)) {
        response.email = email;
      }
      else {
        response.email = _S('S_UNKNOWN_SENDER');
      }

      response.firstname = Utils.isValid(response.firstName, '');
      response.lastname = Utils.isValid(response.lastName, '');
      response.middlename = Utils.isValid(response.middleName, '');
      response.bio = Utils.isValid(response.bio, '');
      response.imageURL = Utils.isValid(response.imageURL, null);
      response.birthday = parseInt(Utils.isValid(response.birthday, '0'), 10);
      response.locale = Utils.isValid(response.locale, null);
      response.locationName = Utils.isValid(response.locationName, null);
      response.enterpriseScore = parseInt(Utils.isValid(response.enterpriseScore, '0'), 10);
      response.influenceScore = parseInt(Utils.isValid(response.influenceScore, '0'), 10);
      response.spamScore = parseInt(Utils.isValid(response.spamScore, '0'), 10);
      response.gender = parseInt(Utils.isValid(response.gender, '-1'), 10);
      response.histories = ModelStorage.get('orgs/'+ Five9.Context.TenantId + '/authors/' + response.id, Histories);

      if (!response.imageURL || response.imageURL.length < 10) {
        response.imageURL = 'images/scc/avatar/avatar-default.png';
      }

      response.name = Utils.arrayToSeparatedString([response.firstname,response.middlename,response.lastname], ' ');

      response.accounts = new Accounts.Collection(response.accounts, { parse: true });
      response.topics = new Topics.Collection(response.topics, { parse: true });

      delete response.enterpriseInfluence; // Not needed, don't want to mix between other influence score - Should be removed from server
      delete response.firstName;
      delete response.lastName;
      delete response.middleName;

      return response;
    },
    getEmail: function() {
      return this.get('email');
    },
    setName: function(firstname, middlename, lastname) {
      var name = Utils.arrayToSeparatedString([firstname,middlename,lastname], ' ');
      this.set('name', name);
    },

    triggerHistoryReceived: function() {
      Five9.vent.trigger('scc:author:history:received', this);
    },
    _loadHistory: function(payload) {
      var url = 'orgs/' + Five9.Context.TenantId + '/contacts/' + this.get('id') + '/history';
      var verb = 'POST';
      if (this.pagingCursor) {
        url += '/' + this.pagingCursor + '/next';
        verb = 'PUT';
      }
      return API.performAction(url, verb, null, null, payload);
    }
  });
  _.extend(Authors.Model.prototype, FreedomHelpers.ModelMixin);
  _.extend(Authors.Model.prototype, AuthorHistoryHelpers.ModelMixin);

  Authors.Collection = ServerModels.Collection.extend({
    apiClassType: Authors.apiClassType,

    model: Authors.Model,

    initialize: function(options) {
    },

    parse: function(response) {
    },

    comparator: function(item) {
      return [item.get('name')];
    }
  });
  _.extend(Authors.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Authors;
});

define('models/server/contacts',[
  'underscore',
  'dataAdapter',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers',
  'models/server/notes',
  'models/server/histories',
  'models/server/authors',
  'models/server/authorHistory.helpers'
],
function(_, DataAdapter, ServerModels, ModelStorage, FreedomHelpers, Notes, Histories, Authors, AuthorHistoryHelpers) {

  var API = DataAdapter.API;

  var Contacts = {
    apiClassType: 'contacts',

    resourceId: ModelStorage.Resources.Contact,

    SystemFields: {
      number1: 'number1',
      number2: 'number2',
      number3: 'number3',
      firstName: 'first_name',
      lastName: 'last_name',
      company: 'company',
      street: 'street',
      city: 'city',
      state: 'state',
      zip: 'zip'
    },

    fromCRMContact: function(crmContact) {
      var contact = crmContact.toJSON();
      if (contact.accounts instanceof ServerModels.Collection) {
        contact.accounts = contact.accounts.toJSON();
      }
      if (contact.notes instanceof ServerModels.Collection) {
        contact.notes = contact.notes.toJSON();
      }
      return new Contacts.Model(_.pick(contact, 'accounts','notes','fields','id','modificationTime'));
    }
  };

  /**
   * @class Contacts
   * @extends ServerModel
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/orgs/getContacts Freedom Api getContacts}
   *   {@link {@substitute apiBaseUrl}#!/orgs/getContact Freedom Api getContact}
   * </pre>
   */
  Contacts.Model = ServerModels.Model.extend({
    apiClassType:Contacts.apiClassType,

    defaults: {
      accounts: [],
      fields: {},
      notes: [],
      modificationTime: 0
    },

    Notes: function() {
      return ModelStorage.get(this.path(), Notes);
    },

    // system field helpers
    getByFieldId: function(id) {
      return this.get('fields')[id];
    },
    mergeFields: function(newFields) {
      var fields = _.clone(this.get('fields'));
      _.each(newFields, function(value, key) {
        fields[key] = value;
      });
      this.set('fields', fields);
    },

    search: function(criteria) {
      console.log('send the search...', criteria);

      return this.performAction('search', criteria, 'POST');
    },

    getModificationTimeAsDate: function() {
      var modificationTime;
      if (this.has('modificationTime')) {
        modificationTime = new Date(this.get('modificationTime'));
      }
      return modificationTime;
    },

    setData: function(response) {
      this.set('notes', response.notes);
      this.set('accounts', response.accounts);
      this.set('modificationTime', response.modificationTime);
      this.set('fields', response.fields);
    },

    triggerHistoryReceived: function() {
      setTimeout(_.bind(function() {
        Five9.vent.trigger(Five9.GlobalEvents.InteractionHistoryReceived, this);
      }, this), 100);
    },
    _loadHistory: function(payload) {
      var url = 'orgs/' + Five9.Context.TenantId + '/contacts/' + this.get('id') + '/history';
      var verb = 'POST';
      if (this.pagingCursor) {
        url += '/' + this.pagingCursor + '/next';
        verb = 'PUT';
      }
      return API.performAction(url, verb, null, null, payload);
    },
    history: function(payload) {
      var url = 'orgs/' + Five9.Context.TenantId + '/contacts/' + this.get('id') + '/history';
      return API.performAction(url, 'POST', null, null, payload);
    },
    next: function(viewCursor, payload) {
      var url = 'orgs/' + Five9.Context.TenantId + '/contacts/' + this.get('id') + '/history/' + viewCursor + '/next';
      return API.performAction(url, 'PUT', null, null, payload);
    }
  });
  _.extend(Contacts.Model.prototype, FreedomHelpers.ModelMixin);
  _.extend(Contacts.Model.prototype, AuthorHistoryHelpers.ModelMixin);

  Contacts.Collection = ServerModels.Collection.extend({
    apiClassType:Contacts.apiClassType,
    model: Contacts.Model,
    parse: function(response) {
      if (response && response.contacts) {
        response = response.contacts;
      }
      return response;
    }
  });
  _.extend(Contacts.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Contacts;
});

define('models/server/connectorsManual',[
    'underscore',
    'server.models.adapter',
    './freedom.helpers'
  ],
function (_, ServerModels, FreedomHelpers) {
  /**@class ManualConnectors
   * @classdesc
   * <pre>
   * {@link {@substitute apiBaseUrl}/#!/agents/getCallManualConnectors Freedom API getCallManualConnectors}
   * </pre>
   */
  var ManualConnectors = {
    apiClassType: 'manual_connectors'
  };

  ManualConnectors.Model = ServerModels.Model.extend({
    apiClassType: ManualConnectors.apiClassType,
    defaults: {
      id: null,
      name: '',
      description: ''
    },

    /**
     * @description Executes manual connector
     * {@link {@substitute apiBaseUrl}#!/agents/processCallManualConnector Freedom API getCallManualConnectors}
     * @memberof ManualConnectors
     * @returns {Promise}
     */
    execute: function(){
      return this.performAction('execute', null, 'POST', null, null, true);
    }
  });
  _.extend(ManualConnectors.Model.prototype, FreedomHelpers.ModelMixin);

  ManualConnectors.Collection = ServerModels.Collection.extend({
    apiClassType: ManualConnectors.apiClassType,
    model: ManualConnectors.Model
  });
  _.extend(ManualConnectors.Collection.prototype, FreedomHelpers.CollectionMixin);

  return ManualConnectors;
});

define('models/server/player',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var Player = {
    apiClassType: 'player',
    resourceId: ModelStorage.Resources.Player
  };

  Player.Model = ServerModels.Model.extend({
    apiClassType: Player.apiClassType,
    defaults: {
      status: 'NON_PLAYING',
      trackInfo: null
    },

    playPrompt: function(id) {
      return this.performAction('play_prompt', id);
    },

    playRecording: function(id) {
      return this.performAction('play_recording', id);
    },

    pause: function() {
      return this.performAction('pause', {});
    },

    resume: function() {
      return this.performAction('resume', {});
    },

    stop: function() {
      return this.performAction('stop', {});
    }
  });
  _.extend(Player.Model.prototype, FreedomHelpers.ModelMixin);

  return Player;
});

define('models/server/audio',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers',
  'models/server/player'
],
function(_, ServerModels, ModelStorage, FreedomHelpers, Player) {
  var Audio = {
    apiClassType: 'audio'
  };

  Audio.Model = ServerModels.Model.extend({
    apiClassType: Audio.apiClassType,
    defaults: {
      skillPrompts: [],
      recordings: []
    },

    Player: function() {
      return ModelStorage.get(this.path(), Player);
    }
  });
  _.extend(Audio.Model.prototype, FreedomHelpers.ModelMixin);

  return Audio;
});

define('models/server/callAuxData',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
  var CallAuxData = {
    apiClassType: 'aux_data'
  };

  CallAuxData.Model = ServerModels.Model.extend({
    apiClassType: CallAuxData.apiClassType,
    defaults: {
      value:''
    },

    saveAuxData: function(value) {
      this.set('value', value);
      var payload = {
        value: this.get('value')
      };
      return this.performAction(null, payload, 'PUT', false);
    }
  });
  _.extend(CallAuxData.Model.prototype, FreedomHelpers.ModelMixin);

  return CallAuxData;
});
define('models/server/calls',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers',
  'models/server/callConstants',
  'models/server/contacts',
  'models/server/connectorsManual',
  'models/server/audio',
  'models/server/callAuxData'
],
function(_, ServerModels, ModelStorage, FreedomHelpers, CallConstants, Contacts, ManualConnectors, Audio, CallAuxData) {
  var Calls = {
    apiClassType: 'interactions/calls',
    resourceId: ModelStorage.Resources.Call,
    Reasons: {
      Created:'CREATED',
      Updated:'UPDATED',
      Connected:'CONNECTED',
      Restored:'RESTORED',
      Rejected:'REJECTED',
      DisconnectedByAgent:'DISCONNECTED_BY_AGENT',
      DisconnectedByCaller:'DISCONNECTED_BY_CALLER',
      AbandonedByAdmin:'ABANDONED_BY_ADMIN',
      CallEnteredQueue:'CALL_ENTERED_QUEUE',
      CallLeftQueue:'CALL_LEFT_QUEUE',
      OnHold:'ON_HOLD',
      OffHold:'OFF_HOLD',
      Parked:'PARKED',
      Reparked:'REPARKED',
      Retrieved:'RETRIEVED',
      Dispositioned:'DISPOSITIONED',
      Transferred:'TRANSFERRED',
      ContactChanged:'CONTACT_CHANGED',
      FailedToAccept:'FAILED_TO_ACCEPT',
      FailedToConnect:'FAILED_TO_CONNECT',
      Busy:'DIAL_RESULT_BUSY',
      NoAnswer:'DIAL_RESULT_NO_ANSWER',
      EditableInfoUpdated:'EDITABLE_INFO_UPDATED',
      RecordingAllowed: 'RECORDING_ALLOWED',
      ConferenceParticipantRinging: 'CONFERENCE_PARTICIPANT_RINGING',
      ConferenceParticipantAdded: 'CONFERENCE_PARTICIPANT_ADDED',
      RemovedFromConferenceByAgent: 'REMOVED_FROM_CONFERENCE_BY_AGENT',
      ConferenceLeft: 'CONFERENCE_LEFT',
      RecordingInfoUpdated: 'RECORDING_INFO_UPDATED',
      WarmTransferStarted: 'WARM_TRANSFER_STARTED',
      WarmTransferCanceled: 'WARM_TRANSFER_CANCELED',
      TransferConsultantDisconnected: 'TRANSFER_CONSULTANT_DISCONNECTED',
      Expired: 'EXPIRED',
      Restoring: 'RESTORING',
      AfterCallWorkTimeExpired: 'AFTER_CALL_WORK_TIME_EXPIRED',
      RingingCalled: 'RINGING_CANCELED',
      Finished: 'FINISHED'
    },
    Types: {
      Outbound:'OUTBOUND',
      Inbound:'INBOUND',
      Test:'TEST',
      Agent:'AGENT',
      Autodial:'AUTODIAL',
      Internal:'INTERNAL',
      QueueCallback:'QUEUE_CALLBACK',
      Visual:'VISUAL',
      InboundVoicemail:'INBOUND_VOICEMAIL',
      OutboundVoicemail:'OUTBOUND_VOICEMAIL',
      InternalVoicemail:'INTERNAL_VOICEMAIL',
      AgentPreview:'AGENT_PREVIEW',
      TestPreview:'TEST_PREVIEW',
      OutboundPreview:'OUTBOUND_PREVIEW'
    },
    QueueTypes: {
      Personal: 'PERSONAL',
      Skill: 'SKILL'
    },
    AddressTypes: {
      External: 'EXTERNAL',
      Agent: 'AGENT',
      Skill: 'SKILL',
      Campaign: 'CAMPAIGN',
      Voicemail: 'VOICEMAIL'
    },
    ReceptionStatus: {
      /**
       * Call reception status is unknown
       */
      Unknown: 'UNKNOWN',
      /**
       *  Call not answered from the agent's personal queue.
       */
      Missed: 'MISSED',
      /**
       * Call was missed but agent returned call to contact from missed call.
       */
      MissedReturned: 'MISSED_RETURNED',
      /**
       *  Call received by the agent.
       */
      Received: 'RECEIVED'
    }
  };

  // models / collections
  /** Calls module
   * @class Calls
   * @extends ServerModel
   * @classdesc
   * <pre>
   * {@link {@substitute apiBaseUrl}/#!/agents/getCalls Freedom API getCalls}
   * {@link {@substitute apiBaseUrl}/#!/agents/getCallInfo Freedom API getCallInfo}
   * </pre>
   */
  Calls.Model = ServerModels.Model.extend({
    apiClassType: Calls.apiClassType,
    defaults: {
      campaignId: null,
      callType: null,
      isTransfer: false,
      userTransferringId: null,
      isInternalReceiver: false,
      contactLookupResult: {},
      previewId: null,
      customer: null,
      priority: null,
      createTime: null,
      acceptTime: null,
      averageHandleTime: null,
      stateSince: null,
      stateDuration: null,
      billingTimestamp: null,
      billingTime: null,
      handleTimestamp: null,
      handleTime: null,
      talkTimestamp: null,
      talkTime: null,
      holdTimestamp: null,
      holdTime: null,
      parkTimestamp: null,
      parkTime: null,
      wrapupTimestamp: null,
      wrapupTime: null,
      startTimestamp: null,
      duration: null,
      afterCallWorkTimeout: null,
      queueType: null,
      state: CallConstants.State.None,
      addressType: null,
      conferenceDispositioning: null,
      activeContact: {},
      comment: null,
      variables: null,
      worksheet: null,
      recording: false,
      recordingAllowed: false,
      autoRecording: false,
      ani: '',
      dnis: '',
      remoteNumber: '',
      canRecycle: false,
      isAutoAnswer: false,
      hasIncompleteTransfer: false,
      dispositionId: null,
      ivrTransferModule: null,
      isCallback: null,
      transferPauseTimeout: null,
      callbackId: null
    },

    initialize: function(options) {
      options = options || {};

      if (!options.contactLookupResult) {
        this.set({'contactLookupResult': {}});
      }
    },

    parse: function(response) {
      if (_.isObject(response)) {
        if (!_.isObject(response.worksheet))
          response.worksheet = {
            answers: {},
            finished: false,
            duration: 0
          };
        return response;
      }
    },

    Contacts: function() {
      return ModelStorage.get(this.path(), Contacts);
    },
    Contact: function(id) {
      return ModelStorage.get(this.path(), Contacts, id);
    },
    /**
     * Get all manual connectors for call
     *
     * {@link {@substitute apiBaseUrl}/#!/agents/getCallManualConnectors Freedom API getCallManualConnectors}
     * {@link ManualConnectors}
     * @memberof Calls
     * @returns {ManualConnectors}
     */
    ManualConnectors: function() {
      return ModelStorage.get(this.path(), ManualConnectors);
    },

    /**
     * @memberof Calls
     * <pre>
     * Get specific manual connector for call
     * {@link {@substitute apiBaseUrl}/#!/agents/getCallManualConnectors Freedom API getCallManualConnectors}
     * {@link ManualConnectors}
     * </pre>
     * @param {string} id connector ID
     * @returns {ManualConnectors}
     */
    ManualConnector: function (id) {
      return ModelStorage.get(this.path(), ManualConnectors, id);
    },

    /**
     * @memberof Calls
     * {@link {@substitute apiBaseUrl}/#!/agents/getAudioFiles Freedom API getAudioFiles}
     * @returns {Audio}
     */
    Audio: function() {
      return ModelStorage.get(this.path(), Audio);
    },
    AuxData: function() {
      return ModelStorage.get(this.path(), CallAuxData);
    },

    // helpers
    isRingingOtherSide: function() {
      return (this.get('state') === CallConstants.State.RingingOtherSide);
    },
    isActive: function() {
      return (this.get('state') === CallConstants.State.Talking ||
              this.get('state') === CallConstants.State.OnHold);
    },
    isWrapUP: function() {
      return (this.get('state') === CallConstants.State.Acw);
    },

    isOffered: function(){
      return (this.get('state') === CallConstants.State.Offered);
    },

    isRingingOnOurSide: function(){
      return (this.get('state') === CallConstants.State.RingingOurSide);
    },

    isAutoAnswer: function(){
      return ( this.get('autoAnswer') );
    },

    isInternal: function(){
      return ( this.get('callType') == CallConstants.Type.Internal );
    },

    getConferenceDispositioning: function(){
      return ( this.get('conferenceDispositioning') );
    },

    // pseudo-actions

    /**
     * <pre>
     * Perform hold/unhold
     * {@link {@substitute apiBaseUrl}/#!/agents/holdCall Freedom API hold}
     * {@link {@substitute apiBaseUrl}/#!/agents/unholdCall Freedom API unhold}
     * </pre>
     * @memberof Calls
     * @param {Object} data - additional data for API methods
     * @returns {Promise}
     */
    toggleHold: function(data) {
      if (this.get('state') === CallConstants.State.OnHold) {
        return this.performAction('unhold', data);
      }
      else {
        return this.performAction('hold', data);
      }
    },

    /**
     * <pre>
     * Performs park/retrieve
     * {@link {@substitute apiBaseUrl}#!/agents/parkCall Freedom API park}
     * {@link {@substitute apiBaseUrl}#!/agents/retrieveCall Freedom API retrieve}
     * </pre>
     * @memberof Calls
     * @param {Object} data - additional data for API methods
     * @returns {Promise}
     */
    togglePark: function(data) {
      if (this.get('state') === CallConstants.State.Parked) {
        return this.performAction('retrieve', data);
      }
      else {
        return this.performAction('park', data);
      }
    },

    /**
     * @memberof Calls
     * Starts recording of call
     * {@link {@substitute apiBaseUrl}#!/agents/startRecording Freedom API start_recording}
     * @memberof Calls
     * @param data
     * @returns {Promise}
     */
    startRecording: function(data) {
      return this.performAction('start_recording', data);
    },

    /**
     * @description Stops recording of call
     * {@link {@substitute apiBaseUrl}#!/agents/stopRecording Freedom API stop_recording}
     * @memberof Calls
     * @param data
     * @returns {Promise}
     */
    stopRecording: function(data) {
      return this.performAction('stop_recording', data);
    },


    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setCallDisposition Freedom API dispose}
     * @memberof Calls
     * @param {String} dispositionId
     * @param {Number} timeout
     * @returns {Promise}
     */
    setDisposition: function(dispositionId, timeout) {
      var payload = {"dispositionId": dispositionId};
      if(timeout){
        payload.timeout = timeout;
      }
      return this.performAction('dispose', payload, 'PUT', false, null, true);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/disconnectCall Freedom API disconnect}
     * @memberof Calls
     * @returns {Promise}
     */
    disconnect: function() {
      return this.performAction('disconnect');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/parkCall Freedom API park}
     * @memberof Calls
     * @returns {Promise}
     */
    park: function(){
      return this.performAction('park');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/retrieveCall Freedom API retrieve}
     * @memberof Calls
     * @returns {Promise}
     */
    retrieve: function(){
      return this.performAction('retrieve');
    },

    /**
     * @memberof Calls
     * {@link {@substitute apiBaseUrl}#!/agents/answerCall Freedom API answer}
     * @returns {Promise}
     */
    answer: function(){
      return this.performAction('answer');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/answerCall Freedom API reject}
     * @memberof Calls
     * @returns {Promise}
     */
    reject: function(){
      return this.performAction('reject');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setCallActiveContact Freedom API active_contact}
     * @param {string} contactId
     * @memberof Calls
     * @returns {Promise}
     */
    setActiveContact: function(contactId) {
      return this.performAction('active_contact', contactId, 'PUT');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/transferCallToAgent Freedom API active_contact}
     * @param {string} agentId
     * @param {boolean} warm
     * @param {number} timeout
     * @param {boolean} recordVoicemail
     * @memberof Calls
     * @returns {Promise}
     */
    transferToAgent: function(agentId, warm, timeout, recordVoicemail) {
      var payload = {
        agentId: agentId,
        recordVoicemail: recordVoicemail,
        warm: warm,
        timeout: timeout
      };
      return this.performAction('transfer_to_agent', payload);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/transferCallToSkills Freedom API transfer_to_skill}
     * @memberof Calls
     * @param {string} skillIds
     * @param {boolean} warm
     * @param {number} timeout
     * @param {boolean} recordVoicemail
     * @returns {Promise}
     */
    transferToSkills: function(skillIds, warm, timeout, recordVoicemail) {
      var payload = {
        skillIds: skillIds,
        recordVoicemail: recordVoicemail,
        warm: warm,
        timeout: timeout
      };
      return this.performAction('transfer_to_skill', payload);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/transferCallToCampaign Freedom API transfer_to_campaign}
     * @memberof Calls
     * @param {string} campaignId
     * @param {boolean} warm
     * @returns {Promise}
     */
    transferToCampaign: function(campaignId, warm) {
      var payload = {
        campaignId: campaignId,
        warm: warm
      };
      return this.performAction('transfer_to_campaign', payload);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/transferCallToExternalDestination Freedom API transfer_to_external_number}
     * @memberof Calls
     * @param {string} destination
     * @param {boolean} warm
     * @param {number} timeout
     * @param {string} dispositionId
     * @param {number} dispositionTimeout
     * @returns {Promise}
     */
    transferToExternal: function(destination, warm, timeout, dispositionId, dispositionTimeout) {
      var payload = {
        destination: destination,
        warm: warm,
        timeout: timeout,
        dispositionId: dispositionId,
        dispositionTimeout: dispositionTimeout
      };
      return this.performAction('transfer_to_external_number', payload);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/transferCallToSpeedDial Freedom API transfer_to_speed_dial}
     * @memberof Calls
     * @param {string} destination
     * @param {boolean} warm
     * @param {number} timeout
     * @param {string} dispositionId
     * @param {number} dispositionTimeout
     * @returns {Promise}
     */
    transferToSpeedDial: function(destination, warm, timeout, dispositionId, dispositionTimeout) {
      var payload = {
        destination: destination,
        warm: warm,
        timeout: timeout,
        dispositionId: dispositionId,
        dispositionTimeout: dispositionTimeout
      };
      return this.performAction('transfer_to_speed_dial', payload);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/completeTransfer Freedom API complete_transfer}
     * @memberof Calls
     * @returns {Promise}
     */
    completeTransfer: function() {
      return this.performAction('complete_transfer', {});
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/cancelTransfer Freedom API cancel_transfer}
     * @memberof Calls
     * @returns {Promise}
     */
    cancelTransfer: function() {
      return this.performAction('cancel_transfer', {});
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setCallWorksheet Freedom API worksheet}
     * @memberof Calls
     * @param {Object} answer
     * @returns {Promise}
     */
    saveWorksheetAnswer : function(answer)
    {
      var payload = _.clone(this.get('worksheet'));
      payload.answers[answer.id] = answer.value;
      return this.performAction('worksheet', payload, 'PUT', false, null, true);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setCallWorksheet Freedom API worksheet}
     * @memberof Calls
     * @param {number} duration
     * @returns {Promise}
     */
    finishWorksheet : function(duration)
    {
      var payload = _.clone(this.get('worksheet'));
      payload.finished = true;
      payload.duration = duration;
      return this.performAction('worksheet', payload, 'PUT', false, null, true);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setCallComment Freedom API comments}
     * @memberof Calls
     * @param {string} comment
     * @returns {Promise}
     */
    setCallComment: function (comment)
    {
      var payload = {
        value: comment
      };
      return this.performAction('comments', payload, 'PUT', false, null, true);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setCallVariables Freedom API variables}
     * @memberof Calls
     * @param {string} id
     * @param {string} value
     * @returns {Promise}
     */
    setCallVariable: function (id, value)
    {
      var payload = {};
      payload[id]= value;
      return this.performAction('variables', payload, 'PUT', false, null, true);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setCallVariables Freedom API variables}
     * @memberof Calls
     * @param {Array} values
     * @returns {Promise}
     */
    setCallVariables: function (values)
    {
      /* this is a hack since we can't send null back to the server */
      _.each(values, function(value, key, obj) { obj[key] = value === "null" ? "" : value; });
      return this.performAction('variables', values, 'PUT', false, null, true);
    },

    /* ------ Conference related actions ------ */
    /**
     * {@link {@substitute apiBaseUrl}#!/agents/addConferenceExternalParticipant Freedom API add_external_to_conference}
     * @memberof Calls
     * @param {string} number
     * @param {boolean} checkDNC
     * @param {boolean} isWarm
     * @param {boolean} includeCallerInfo
     * @param {string} contactId
     * @returns {Promise}
     */
    conferenceAddExternal: function(number, checkDNC, isWarm, includeCallerInfo, contactId) {
      var payload;

      payload = {
        number: number,
        contactId: contactId,
        checkDNC: checkDNC,
        warm: isWarm
      };
      if(_.isBoolean(includeCallerInfo)){// if omitted backend use CampaignFlag#PASS_CONTACTS_ANI_FOR_3RD_PARTY_CONFERENCES.
        payload.includeCallerInfo = includeCallerInfo;
      }

      return this.performAction('add_external_to_conference', payload, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/addConferenceAgentParticipant Freedom API add_agent_to_conference}
     * @memberof Calls
     * @param {string} id
     * @param {boolean} isWarm
     * @param {boolean} includeCallerInfo
     * @returns {Promise}
     */
    conferenceAddAgent: function(id, isWarm, includeCallerInfo) {
      var payload = {
        id: id,
        warm: isWarm,
        includeCallerInfo: includeCallerInfo
      };
      return this.performAction('add_agent_to_conference', payload, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/addConferenceSkillParticipant Freedom API add_skill_to_conference}
     * @memberof Calls
     * @param {string} id
     * @param {boolean} isWarm
     * @param {boolean} includeCallerInfo
     * @returns {Promise}
     */
    conferenceAddSkill: function(id, isWarm, includeCallerInfo) {
      var payload = {
        id: id,
        warm: isWarm,
        includeCallerInfo: includeCallerInfo
      };
      return this.performAction('add_skill_to_conference', payload, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/addConferenceSpeedDialParticipant Freedom API add_speed_dial_to_conference}
     * @memberof Calls
     * @param {string} speedDialId
     * @param {boolean} isWarm
     * @param {boolean} includeCallerInfo
     * @param {boolean} checkDNC
     * @returns {Promise}
     */
    conferenceAddSpeedDial: function(speedDialId, isWarm, includeCallerInfo, checkDNC) {
      var payload = {
        speedDialId : speedDialId,
        warm: isWarm,
        checkDNC: checkDNC
      };
      if(_.isBoolean(includeCallerInfo)){// if omitted backend use CampaignFlag#PASS_CONTACTS_ANI_FOR_3RD_PARTY_CONFERENCES.
        payload.includeCallerInfo = includeCallerInfo;
      }
      return this.performAction('add_speed_dial_to_conference', payload, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/addConferenceCampaignParticipant Freedom API add_campaign_to_conference}
     * @memberof Calls
     * @param {string} campaignId
     * @param {boolean} isWarm
     * @returns {Promise}
     */
    conferenceAddCampaign: function(campaignId, isWarm) {
      var payload = {
        campaignId : campaignId,
        warm: isWarm
      };
      return this.performAction('add_campaign_to_conference', payload, 'POST');
    },


    //Should be used only for parked calls

    /**
     * <pre>
     * @description Should be used only for parked calls
     * {@link {@substitute apiBaseUrl}#!/agents/addParkedCallToConference Freedom API add_to_conference}
     * </pre>
     * @memberof Calls
     * @param {string} activeCallId
     * @returns {Promise}
     */
    addToConference: function(activeCallId) {
      return this.performAction('add_to_conference', {value: activeCallId});
    },

    /**
     * @memberof Calls
     * <pre>
     * @description Should be used only for parked calls
     * {@link {@substitute apiBaseUrl}#!/agents/disconnectConferenceParticipant Freedom API disconnectConferenceParticipant}
     * </pre>
     * @returns {Promise}
     */
    disconnectParticipant: function() {
      return this.performAction('disconnectConferenceParticipant');
    },

    /**
     * <pre>
     * @description Should be used only for parked calls
     * {@link {@substitute apiBaseUrl}#!/agents/leaveConference Freedom API leave_conference}
     * </pre>
     * @memberof Calls
     * @param {string} dispositionId
     * @param {number} dispositionTimeout
     * @param {boolean} isToTransferCallOwnership
     * @returns {Promise}
     */
    conferenceLeave: function(dispositionId, dispositionTimeout, isToTransferCallOwnership) {
      var payload = {
        dispositionId : dispositionId,
        isToTransferCallOwnership: isToTransferCallOwnership
      };
      if (dispositionTimeout) {
        payload.dispositionTimeout = dispositionTimeout;
      }
      return this.performAction('leave_conference', payload);
    },

    /**
     * <pre>
     * @description Should be used only for parked calls
     * {@link {@substitute apiBaseUrl}#!/agents/completeConference Freedom API complete_warm_conference}
     * </pre>
     * @memberof Calls
     * @returns {Promise}
     */
    completeWarmConference: function() {
      return this.performAction('complete_warm_conference', {}, 'POST', undefined, undefined, true);
    }
  });
  _.extend(Calls.Model.prototype, FreedomHelpers.ModelMixin);
  _.extend(Calls.Model.prototype, FreedomHelpers.ModelContactMixin);

  Calls.Collection = ServerModels.Collection.extend({
    apiClassType: Calls.apiClassType,
    model: Calls.Model
  });
  _.extend(Calls.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Calls;
});

define('models/server/callPreviewStates',[
  'base.model'
],
function(BaseModels) {

  var CallPreviewStates = {
    Preview: 'PREVIEW',
    OnCall: 'ON_CALL',
    Postponed: 'POSTPONED',
    Renew: 'RENEWING',
    Finished: 'FINISHED'
  };

  return CallPreviewStates;
});

define('models/server/callPreviews',[
  'underscore',
  'jquery',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage',
  'models/server/callPreviewStates',
  'models/server/connectorsManual'
],
function(_, $, ServerModels, FreedomHelpers, ModelStorage, CallPreviewStates, ManualConnectors) {
  var CallPreviews = {
    apiClassType: 'previews',
    resourceId: ModelStorage.Resources.Preview,
    Reasons: {
      Withdrawn: "WITHDRAWN",
      Timeout: "TIMEOUT",
      Expired: "EXPIRED"
    }
  };

  // models / collections
  /**
   * @class CallPreviews
   * @classdesc
   * <pre>
   * {@link {@substitute apiBaseUrl}#!/agents/getPreviews Freedom API getPreviews}
   * {@link {@substitute apiBaseUrl}#!/agents/getPreview Freedom API getPreview}
   * </pre>
   */

  CallPreviews.Model = ServerModels.Model.extend({
    apiClassType: CallPreviews.apiClassType,
    defaults: {
      contact: {},
      campaignId: null,
      timeout: null,
      beforeTimeoutTime: null,
      state: CallPreviewStates.Preview,
      restrictions: null,
      variables: null
    },

    parse: function(response) {
      // flatten info item (until API team fixes)
      if (response.info) {
        response = $.extend(true, response, response.info);
        delete response.info;
      }
      if (response.incomingInfo) {
        response = $.extend(true, response, response.incomingInfo);
        delete response.incomingInfo;
      }
      return response;
    },

    /**
     * @description Creates ManualConnectors collection model for this call preview
     * @memberof CallPreviews
     * @returns {ManualConnectors}
     */
    ManualConnectors: function() {
      return ModelStorage.get(this.path(), ManualConnectors);
    },

    /**
     * @description Creates ManualConnectors model with specific id for this call preview
     * @memberof CallPreviews
     * @returns {ManualConnectors}
     */
    ManualConnector: function (id) {
      return ModelStorage.get(this.path(), ManualConnectors, id);
    },

    // API
    /**
     * {@link {@substitute apiBaseUrl}#!/agents/skipPreview Freedom API skipPreview}
     * @param {string} dispositionId
     * @param {number} timeout
     * @memberof CallPreviews
     * @returns {Promise}
     */
    setDisposition: function(dispositionId, timeout) {
      var payload = {"dispositionId": dispositionId};
      if(timeout){
        payload.timeout = timeout;
      }
      return this.performAction('dispose', payload);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/makePreviewCall Freedom API makePreviewCall}
     * @param {string} contactFieldId
     * @returns {Promise}
     * @memberof CallPreviews
     */
    makeCall: function(contactFieldId) {
      var d = $.Deferred();

      if (this.has('id')) {
        var payload = {value: contactFieldId};
        return this.performAction('make_call', payload, 'POST');
      }
      else {
        d.resolve();
      }
      return d.promise();
    },

    /**
     * @memberof CallPreviews
     * {@link {@substitute apiBaseUrl}#!/agents/renewPreview Freedom API renewPreview}
     * @returns {Promise}
     */
    renew: function() {
      var d = $.Deferred();

      if (this.has('id')) {
        return this.performAction('renew');
      }
      else {
        d.resolve();
      }
      return d.promise();
    },

    /**
     * @memberof CallPreviews
     * {@link {@substitute apiBaseUrl}#!/agents/endPreview Freedom API renewPreview}
     * @returns {Promise}
     */
    end: function() {
      var d = $.Deferred();

      if (this.has('id')) {
        return this.performAction('end');
      }
      else {
        d.resolve();
      }
      return d.promise();
    },

    /**
     * @memberof CallPreviews
     * {@link {@substitute apiBaseUrl}#!/agents/updatePreviewContact Freedom API updatePreviewContact}
     * @returns {Promise}
     */
    updateContact: function(contactInfo) {
      var payload = contactInfo || {};
      return this.performAction('update_contact', payload);
    }
  });
  _.extend(CallPreviews.Model.prototype, FreedomHelpers.ModelMixin);

  CallPreviews.Collection = ServerModels.Collection.extend({
    apiClassType: CallPreviews.apiClassType,
    model: CallPreviews.Model
  });
  _.extend(CallPreviews.Collection.prototype, FreedomHelpers.CollectionMixin);

  return CallPreviews;
});

define('models/server/echoCall',[
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function(ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
  var EchoCall = {
    apiClassType: 'echo_call',
    resourceId: ModelStorage.Resources.EchoCall
  };

  EchoCall.Model = ServerModels.Model.extend({
    apiClassType: EchoCall.apiClassType,

    echoCall: function() {
      return this.performAction(null, null, 'POST');
    },

    echoCallCancel: function() {
      return this.performAction(null, null, 'DELETE');
    },

    isEchoCall: function() {
      return this.performAction(null, null, 'GET');
    }
  });

  return EchoCall;
});
define('models/server/testCall',[
    'server.models.adapter',
    'server.models.storage',
    'dataAdapter',
    './freedom.helpers'
  ],
  function(ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
    var TestCall = {
      apiClassType: 'interactions/make_test_call',
      resourceId: ModelStorage.Resources.TestCall
    };

    TestCall.Model = ServerModels.Model.extend({
      apiClassType: TestCall.apiClassType,

      testCall: function() {
        return this.performAction(null, null, 'POST');
      }

    });

    return TestCall;
  });

define('models/server/campaignConfig',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var CampaignConfig = {
    apiClassType: 'campaigns_config',
    resourceId: ModelStorage.Resources.CampaignsConfig
  };

  /**
   * @class CampaignConfig
   * @extends ServerModel
   * {@link {@substitute apiBaseUrl}#!/agents/getCampaignsConfig Freedom Api getCampaignsConfig}
   */
  CampaignConfig.Model = ServerModels.Model.extend({
      apiClassType: CampaignConfig.apiClassType,
      defaults: {
    }
  });
  _.extend(CampaignConfig.Model.prototype, FreedomHelpers.ModelMixin);

  CampaignConfig.Collection = ServerModels.Collection.extend({
    apiClassType: CampaignConfig.apiClassType,
    model: CampaignConfig.Model
  });
  _.extend(CampaignConfig.Collection.prototype, FreedomHelpers.CollectionMixin);

  return CampaignConfig;
});

define('models/server/destinationCampaigns',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var DestinationCampaigns = {
    apiClassType: 'campaigns'
  };

  DestinationCampaigns.Model = ServerModels.Model.extend({
    apiClassType: DestinationCampaigns.apiClassType,
    defaults: {
    }
  });
  _.extend(DestinationCampaigns.Model.prototype, FreedomHelpers.ModelMixin);

  DestinationCampaigns.Collection = ServerModels.Collection.extend({
    apiClassType: DestinationCampaigns.apiClassType,
    model: DestinationCampaigns.Model
  });
  _.extend(DestinationCampaigns.Collection.prototype, FreedomHelpers.CollectionMixin);

  return DestinationCampaigns;
});

define('models/server/contacts-noFullTextSearch',[
  'underscore',
  'models/server/contacts'
],
function(_, Contacts) {

  _.extend(Contacts.Model.prototype, {urlQueryParams: {'fullTextSearch': false}});

  return Contacts;
});

define('models/server/fieldViews',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var FieldViews = {
    apiClassType: 'contact/field_views'
  };

  // models / collections
  FieldViews.Model = ServerModels.Model.extend({
    apiClassType:FieldViews.apiClassType,

    defaults: {
      label: '',
      order: -1,
      width: 0,
      editable: true,
      relatedField: {}
    }
  });
  _.extend(FieldViews.Model.prototype, FreedomHelpers.ModelMixin);

  FieldViews.Collection = ServerModels.Collection.extend({
    apiClassType:FieldViews.apiClassType,
    model: FieldViews.Model,

    comparator: function(item) {
      return item.get('order');
    }
  });
  _.extend(FieldViews.Collection.prototype, FreedomHelpers.CollectionMixin);

  return FieldViews;
});

define('models/server/internalMessages',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers',
  'utils'
],
function(_, ServerModels, ModelStorage, DataAdapter, FreedomHelpers, Utils) {
  var InternalMessages = {
    apiClassType: 'messages',
    resourceId: ModelStorage.Resources.InternalMessage,

    Types: {
      Broadcast: 'broadcast',
      InstantMessage: 'im'
    },

    MessageTypes: {
      Regular: 37000,
      AddUsers: 37002,
      RemoveUsers: 37003,
      TerminateChat: 37004,
      SetAsRead: 37005
    },

    ExchangeName: 'five9.IM_SERVER'
  };

  InternalMessages.Model = ServerModels.Model.extend({
    apiClassType:InternalMessages.apiClassType,

    defaults: {
      id: null,
      users: null,
      message: '',
      type: '',
      guuid: '',
      messageDate: 0,
      senderId: '',
      originatorId: '',
      messageRead: false
    },

    initialize: function (data) {
      if (data && data.senderId) {
        this.parentPath = ModelStorage.Helpers.Path.createPath(['agents', data.senderId]);
      }
    },

    parse: function (data) {
      var defaults = {
        messageDate: Date.now(),
        messageRead: false
      };
      var filledData = _.extend(defaults, data);
      if (data.messageDate){
        filledData.messageDate *= 1000;
      }
      return filledData;
    },

    sendMessage: function() {
      var context = {
        msgType: InternalMessages.MessageTypes.Regular,
        tenantId: this.get('tenantId'),
        userId: this.get('senderId')
      };
      var payLoad = {
        id: this.get('id'),
        senderId: this.get('senderId'),
        message:this.get('message'),
        users: this.get('users'),
        type:this.get('type'),
        guuid:this.get('guuid'),
        originatorId: this.get('originatorId'),
        messageRead: false
      };
      var messageData = {
        context: context,
        payLoad: payLoad
      };
      var jsonString = JSON.stringify(messageData);
      var data = {
        exchangeName: InternalMessages.ExchangeName,
        jsonString: jsonString
      };

      console.log (data);
      return this.performAction(null, data, 'POST', false);
    },

    setMessageAsReadOnServer: function() {
      var context = {
        msgType: InternalMessages.MessageTypes.SetAsRead,
        tenantId: this.get('tenantId'),
        userId: this.get('senderId')
      };
      var payLoad = {
        id: this.get('id'),
        guuid: this.get('guuid'),
        messageRead: true,
        senderId: this.get('senderId'),
        users: this.get('users')
      };
      var messageData = {
        context: context,
        payLoad: payLoad
      };
      var jsonString = JSON.stringify(messageData);
      var data = {
        exchangeName: InternalMessages.ExchangeName,
        jsonString: jsonString
      };
      console.log (data);
      return this.performAction(null, data, 'POST', false);
    },

    addUsersToChatConversation: function() {
      var context = {
        msgType: InternalMessages.MessageTypes.AddUsers,
        tenantId: this.get('tenantId'),
        userId: this.get('senderId')
      };
      var payLoad = {
        users: this.get('users'),
        added_users: this.get('addedUsers'),
        guuid: this.get('guuid'),
        senderId: this.get('senderId')
      };
      var messageData = {
        context: context,
        payLoad: payLoad
      };
      var jsonString = JSON.stringify(messageData);
      var data = {
        exchangeName: InternalMessages.ExchangeName,
        jsonString: jsonString
      };
      console.log (data);
      return this.performAction(null, data, 'POST', false);
    },

    removeUsersFromChatConversation: function() {
      var context = {
        msgType: InternalMessages.MessageTypes.RemoveUsers,
        tenantId: this.get('tenantId'),
        userId: this.get('senderId')
      };
      var payLoad = {
        users: this.get('users'),
        removed_users: this.get('removedUsers'),
        guuid: this.get('guuid'),
        senderId: this.get('senderId')
      };
      var messageData = {
        context: context,
        payLoad: payLoad
      };
      var jsonString = JSON.stringify(messageData);
      var data = {
        exchangeName: InternalMessages.ExchangeName,
        jsonString: jsonString
      };
      console.log (data);
      return this.performAction(null, data, 'POST', false);
    },

    terminateChatConversation: function() {
      var context = {
        msgType: InternalMessages.MessageTypes.TerminateChat,
        tenantId: this.get('tenantId'),
        userId: this.get('senderId')
      };
      var payLoad = {
        users: this.get('users'),
        guuid: this.get('guuid'),
        senderId: this.get('senderId')
      };
      var messageData = {
        context: context,
        payLoad: payLoad
      };
      var jsonString = JSON.stringify(messageData);
      var data = {
        exchangeName: InternalMessages.ExchangeName,
        jsonString: jsonString
      };
      console.log (data);
      return this.performAction(null, data, 'POST', false);
    }

  });

  InternalMessages.Collection = ServerModels.Collection.extend({
    apiClassType: InternalMessages.apiClassType,
    model: InternalMessages.Model,

    comparator: function (model) {
      var messageDate = model.get('messageDate');
      return -messageDate;
    },

    getMessageCount: function(status) {
      var guuidMap = {};
      var readMessageCount = 0, unreadMessageCount = 0;
      this.forEach(function(message) {
        var guuid = message.get('guuid');
        if (!(guuid in guuidMap)) {
          guuidMap[guuid] = true;
          if (message.get('messageRead')) {
            readMessageCount++;
          }
          else {
            unreadMessageCount++;
          }
        }
      });
      switch (status) {
        case 'read': return readMessageCount;
        case 'unread': return unreadMessageCount;
        default: return (readMessageCount + unreadMessageCount);
      }
    },

    getMessage: function(id) {
      var rc = this.find(function(model) {
        return (model.get('id') === id);
      });
      if (rc) {
        var messageRead = rc.get ('messageRead');
        if (!messageRead) {
          rc.set ('messageRead', true);
          var internalMessageServerModel = new InternalMessages.Model({id: id, users: rc.get ('users'), guuid: rc.get('guuid'),
                                                  senderId: Five9.Context.AgentId, tenantId: Five9.Context.TenantId});
          internalMessageServerModel.setMessageAsReadOnServer()
          .done( function() {
            console.log ('Message ' + id + ' read flag set successfully');
            rc.set('message', Utils.stripHtml(rc.get('message')));
          })
          .fail( function() {
            console.error ('Message ' + id + ': read flag setting on server failed');
          });
        }
      }
      return rc;
    }

  });

  return InternalMessages;
});
define('models/server/loginState',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var LoginState = {
    apiClassType: 'login_state',
    resourceId: ModelStorage.Resources.LoginState,

    AgentLoginStatus: {
      'SelectStation': 'SELECT_STATION',  // Agent need to select station
      'AcceptNotice': 'ACCEPT_NOTICE',    // Agent must accept maintenance notice
      'SelectSkills': 'SELECT_SKILLS',    // Agent need to select active skills
      'Working': 'WORKING',               // Agent is ready for work
      'Relogin': 'RELOGIN'                // Agent needs to relogin - sort of - but not really.  actually, agent needs to call restart_session repeatedly.  yep
    }
  };

  /**
   * @class LoginState
   * @extends {ServerModel}
   * @classdesc
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/agents/getLoginState Freedom Api getLoginState}
   * </pre>
   */
  LoginState.Model = ServerModels.Model.extend({
    apiClassType:LoginState.apiClassType,

    defaults: {
      state:LoginState.AgentLoginStatus.SelectStation
    },

    state: function () {
      return this.get('state');
    },

    // isNew ensures that backbone will always save using PUT
    isNew: function() {
      return false;
    },
    parse: function(response) {
      if (_.isString(response)) {
        response = {state:response};
      }
      return response;
    }
  });
  _.extend(LoginState.Model.prototype, FreedomHelpers.ModelMixin);

  return LoginState;
});

define('models/server/logIssue',[
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function(ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
  var LogIssue = {
    apiClassType: 'log_issue'
  };

  LogIssue.Model = ServerModels.Model.extend({
    apiClassType:LogIssue.apiClassType,
    defaults: {
      value:''
    },

    logIssue: function() {
      var payload = {
        value: this.get('value')
      };
      return this.performAction(null, payload, 'POST', false);
    }
  });

  return LogIssue;
});
define('models/server/issue',[
  'underscore',
  'server.models.adapter'
],
function(_, ServerModels) {
  var Issue = {
    apiClassType: 'issue'
  };

  Issue.Model = ServerModels.Model.extend({
    apiClassType:Issue.apiClassType,
    defaults: {
    },

    postIssue: function(description, logs, progressCallback, beforeSendCallback) {
      var logBlob = new Blob([logs], {type: "text/plain;charset=utf-8"});
      var formData = new FormData();
      formData.append('logs', logBlob);
      formData.append('description', description );
      var ajaxOptions = {
        data: formData,
        cache: false,
        contentType: false,
        processData: false
      };
      ajaxOptions.xhr = function(){// Custom XMLHttpRequest
        var theXhr = $.ajaxSettings.xhr();
        if(_.isFunction(progressCallback) && theXhr.upload){
          theXhr.upload.addEventListener('progress', progressCallback, false);
        }
        return theXhr;
      };
      if(_.isFunction(beforeSendCallback)){
        ajaxOptions.beforeSend = beforeSendCallback;
      } else {
        ajaxOptions.beforeSend = function () {
          //overriding original beforeSend to exclude logs from Logger
        };
      }
      return this.performAction(null, undefined, 'POST', false, undefined, undefined, ajaxOptions);
    },

    url: function(){
      return ServerModels.Model.prototype.url.call(this, arguments).replace('appsvcs', 'strsvcs');
    }
  });

  return Issue;
});
define('models/server/permissions',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var Permissions = {
    apiClassType: 'permissions',
    resourceId: ModelStorage.Resources.Permissions
  };

  /**
   * @class Permissions
   * @extends ServerModel
   * @classdesc
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/agents/getPermissions Freedom Api getPermissions}
   * </pre>
   */
  Permissions.Model = ServerModels.Model.extend({
    apiClassType:Permissions.apiClassType,
    defaults: {
    },

    parse: function(response) {
      // list of strings to collection
      if (_.isString(response)) {
        var id = response;
        response = {id:id};
      }
      return response;
    }
  });
  _.extend(Permissions.Model.prototype, FreedomHelpers.ModelMixin);

  Permissions.Collection = ServerModels.Collection.extend({
    apiClassType:Permissions.apiClassType,
    model: Permissions.Model,

    /**
     * @description check if permission set for agent
     * @param {string} perm
     * @returns {boolean}
     * @memberof Permissions
     */
    isAllowed: function(perm) {
      return (this.get(perm)) ? true : false;
    }
  });
  _.extend(Permissions.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Permissions;
});

define('models/server/queueCallbackStates',[
  'base.model'
],
function(BaseModels) {

  var QueueCallbackState = {
    Dialing: 'DIALING',
    Answering: 'ANSWERING'
  };

  return QueueCallbackState;
});
define('models/server/queueCallbacks',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers',
  'models/server/queueCallbackStates'
],
function(_, ServerModels, ModelStorage, FreedomHelpers, QueueCallbackStates) {
  var QueueCallbacks = {
    apiClassType: 'queue_callbacks',
    resourceId: ModelStorage.Resources.QueueCallbacks
  };

  QueueCallbacks.Model = ServerModels.Model.extend({
    apiClassType: QueueCallbacks.apiClassType,
    defaults: {
      state: QueueCallbackStates.Dialing,
      contact: {}
    },
    parse: function(response) {
      console.log('QueueCallbacks response', response);
      return response;
    },
    answer: function() {
      return this.performAction('answer', {}, 'PUT');
    },
    reject: function() {
      return this.performAction('reject', {}, 'PUT');
    }
  });
  _.extend(QueueCallbacks.Model.prototype, FreedomHelpers.ModelMixin);

  QueueCallbacks.Collection = ServerModels.Collection.extend({
    apiClassType: QueueCallbacks.apiClassType,
    model: QueueCallbacks.Model,

    comparator: function(item) {
      return item.get('name');
    }
  });
  _.extend(QueueCallbacks.Collection.prototype, FreedomHelpers.CollectionMixin);

  return QueueCallbacks;
});

define('models/server/callbacks',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var Callbacks = {
    apiClassType: 'callbacks',
    resourceId: ModelStorage.Resources.Callbacks
  };

  /**
   * @class Callbacks
   * @extends {ServerModel}
   * @classdesc
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/agents/getCallbacks Freedom API getCallbacks}
   * </pre>
   */
  Callbacks.Model = ServerModels.Model.extend({
    apiClassType: Callbacks.apiClassType,
    defaults: {},
    parse: function(response) {
      console.log('Callbacks response', response);
      return response;
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/removeCallback Freedom API removeCallback}
     * @returns {Promise}
     * @memberof Callbacks
     */
    deleteCallback: function(){
      return this.performAction(null, null, 'DELETE');
    },

    updateCallback: function (payload, suppressError) {
      suppressError = suppressError || false;
      payload = _.extend(_.clone(this.attributes), payload);
      return this.performAction(null, payload, 'PUT', suppressError);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/snoozeCallback Freedom Api snoozeCallback}
     * @param {number} snoozeTimestamp
     * @returns {Promise}
     * @memberof Callbacks
     */
    snoozeCallback: function(snoozeTimestamp) {
      var payload = {
        value: snoozeTimestamp
      };
      return this.performAction('snooze', payload, 'PUT');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/dismissCallback Freedom Api dismissCallback}
     * @returns {Promise}
     * @memberof Callbacks
     */
    dismissCallback: function() {
      return this.performAction('dismiss', {}, 'PUT');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/makeCallback Freedom Api makeCallback}
     * @param {boolean} skipDNC
     * @param {string} contactId
     * @param {boolean} skipMultipleContactsCheck
     * @returns {Promise}
     * @memberof Callbacks
     */
    makeCall: function(skipDNC, contactId, skipMultipleContactsCheck) {
      if (_.isUndefined(contactId)) contactId = null;
      skipDNC = !!skipDNC;
      skipMultipleContactsCheck = !!skipMultipleContactsCheck;
      var payload = {
        contactId: contactId,
        skipDNCCheck: skipDNC,
        skipMultipleContactsCheck: skipMultipleContactsCheck
      };
      return this.performAction('make_call', payload, 'POST');
    }
  });
  _.extend(Callbacks.Model.prototype, FreedomHelpers.ModelMixin);

  Callbacks.Collection = ServerModels.Collection.extend({
    apiClassType: Callbacks.apiClassType,
    model: Callbacks.Model,

    comparator: function(item) {
      return item.get('number');
    }
  });
  _.extend(Callbacks.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Callbacks;
});

define('models/server/skills',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var Skills = {
    apiClassType: 'skills',
    resourceId: ModelStorage.Resources.Skills
  };

  /**
   * @class Skills
   * @extends ServerModel
   * {@link {@substitute apiBaseUrl}#!/orgs/getSkills Freedom Api getSkills}
   */
  Skills.Model = ServerModels.Model.extend({
    apiClassType: Skills.apiClassType,
    defaults: {
      name: '',
      motD: '',
    }
  });
  _.extend(Skills.Model.prototype, FreedomHelpers.ModelMixin);

  Skills.Collection = ServerModels.Collection.extend({
    apiClassType: Skills.apiClassType,
    model: Skills.Model,

    comparator: function(item) {
      return [item.get('name').toLowerCase()];
    }
  });
  _.extend(Skills.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Skills;
});

define('models/server/station',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var Station = {
    apiClassType: 'station',
    resourceId: ModelStorage.Resources.Station,
    States: {
      Disconnected: 'DISCONNECTED',
      Connected: 'CONNECTED',
      Connecting: 'CONNECTING'
    },
    Types: {
      SOFTPHONE: 'SOFTPHONE',
      PSTN: 'PSTN',
      GATEWAY: 'GATEWAY',
      EMPTY: 'EMPTY'
    }
  };

  Station.Model = ServerModels.Model.extend({
    apiClassType: Station.apiClassType,

    defaults: {
      stationId: '',
      stationType: Station.Types.SOFTPHONE,
      state: Station.States.Disconnected
    },

    stationId: function() {
      return this.stationType() === Station.Types.EMPTY ? '': this.get('stationId');
    },

    stationType: function () {
      return this.get('stationType');
    },

    stationState: function () {
      return this.get('state');
    },

    stationInfo: function () {
      return {
        stationId: this.stationId(),
        stationType: this.stationType()
      };
    },

    // actions
    restart: function() {
      //the fourth param is to suppress error notifications from model adapter
      return this.performAction('restart', null, 'PUT', true);
    }
  });

  _.extend(Station.Model.prototype, FreedomHelpers.ModelMixin);

  return Station;
});

define('models/server/stationState',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var StationStates = {
    apiClassType: 'station_state',
    States: {
      'Disconnected': 'DISCONNECTED',
      'Connected': 'CONNECTED',
      'Connecting': 'CONNECTING'
    }
  };

  StationStates.Collection = ServerModels.Model.extend({
    apiClassType:StationStates.apiClassType,

    defaults: {
      stationState:StationStates.States.Disconnected
    },

    isNew: function() {
      return false;
    },
    parse: function(response) {
      if (_.isString(response)) {
        return {state:response};
      }
      return response;
    }
  });
  _.extend(StationStates.Collection.prototype, FreedomHelpers.ModelMixin);

  return StationStates;
});

define('models/server/softphoneConfig',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var calculateRange = function (begin, end) {
    return end - begin + 1;
  };

  var SoftphoneConfig = {
    apiClassType: 'softphone_config'
  };

  SoftphoneConfig.Model = ServerModels.Model.extend({
    apiClassType: SoftphoneConfig.apiClassType,

    softphoneType: function () {
      return this.get('softphoneType');
    },

    licence: function () {
      return this.get('licence');
    },

    username: function () {
      return this.get('username');
    },

    password: function () {
      return this.get('password');
    },

    domains: function () {
      return this.get('sipProxyServers');
    },

    protocol: function () {
      return this.get('protocol');
    },

    sipPort: function () {
      return this.get('sipPortRangeStart');
    },

    sipPortRange: function () {
      return calculateRange(this.get('sipPortRangeStart'), this.get('sipPortRangeStop'));
    },

    rtpPort: function () {
      return this.get('rtpPortRangeStart');
    },

    rtpPortRange: function () {
      return calculateRange(this.get('rtpPortRangeStart'), this.get('rtpPortRangeStop'));
    },

    ptime: function () {
      return this.get('ptime');
    },

    silenceSuppression: function () {
      return this.get('silenceSuppression');
    },

    codecs: function () {
      return this.get('codecs');
    },

    agc: function () {
      return this.get('enableAutoGainControl');
    },

    aec: function () {
      return this.get('enableAcousticEchoCancellation');
    },

    overrideUserSettings: function () {
      return this.get('overrideUserLevelSettings');
    }
  });

  _.extend(SoftphoneConfig.Model.prototype, FreedomHelpers.ModelMixin);

  return SoftphoneConfig;
});

define('models/server/transfereeAgents',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var TransfereeAgents = {
    apiClassType: 'transferable_agents'
  };

  TransfereeAgents.Model = ServerModels.Model.extend({
    apiClassType: TransfereeAgents.apiClassType,
    defaults: {
      userName: '',
      fullName: '',
      extension: '',
      email: '',
      active: true
    },
    parse: function(response) {
      if (_.isUndefined(response.fullName) || !_.isString(response.fullName) || response.fullName === '') {
        response.fullName = response.userName;
      }
      return response;
    },
    getId: function() {
      return this.get('id');
    }
  });
  _.extend(TransfereeAgents.Model.prototype, FreedomHelpers.ModelMixin);


  TransfereeAgents.Collection = ServerModels.Collection.extend({
    apiClassType: TransfereeAgents.apiClassType,
    model: TransfereeAgents.Model
  });
  _.extend(TransfereeAgents.Collection.prototype, FreedomHelpers.CollectionMixin);

  return TransfereeAgents;
});

define('models/server/transferableSkillsChat',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var TransferableSkills = {
    apiClassType: 'chat_transferable_skills'
  };

  TransferableSkills.Model = ServerModels.Model.extend({
    apiClassType: TransferableSkills.apiClassType,
    defaults: {
      name: '',
      motD: '',
    }
  });
  _.extend(TransferableSkills.Model.prototype, FreedomHelpers.ModelMixin);


  TransferableSkills.Collection = ServerModels.Collection.extend({
    apiClassType: TransferableSkills.apiClassType,
    model: TransferableSkills.Model
  });
  _.extend(TransferableSkills.Collection.prototype, FreedomHelpers.CollectionMixin);

  return TransferableSkills;
});

define('models/server/transferableSkillsEmail',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var TransferableSkills = {
    apiClassType: 'email_transferable_skills'
  };

  TransferableSkills.Model = ServerModels.Model.extend({
    apiClassType: TransferableSkills.apiClassType,
    defaults: {
      name: '',
      motD: '',
    }
  });
  _.extend(TransferableSkills.Model.prototype, FreedomHelpers.ModelMixin);


  TransferableSkills.Collection = ServerModels.Collection.extend({
    apiClassType: TransferableSkills.apiClassType,
    model: TransferableSkills.Model
  });
  _.extend(TransferableSkills.Collection.prototype, FreedomHelpers.CollectionMixin);

  return TransferableSkills;
});

define('models/server/transferableSkillsSocial',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var TransferableSkills = {
    apiClassType: 'social_transferable_skills'
  };

  TransferableSkills.Model = ServerModels.Model.extend({
    apiClassType: TransferableSkills.apiClassType,
    defaults: {
      name: '',
      motD: '',
    }
  });
  _.extend(TransferableSkills.Model.prototype, FreedomHelpers.ModelMixin);


  TransferableSkills.Collection = ServerModels.Collection.extend({
    apiClassType: TransferableSkills.apiClassType,
    model: TransferableSkills.Model
  });
  _.extend(TransferableSkills.Collection.prototype, FreedomHelpers.CollectionMixin);

  return TransferableSkills;
});

define('models/server/voicemailStates',[],
function() {
  var VoicemailStates = {
    None: 'NONE',

    /**
     * A voicemail is currently offered to the agent
     * (but not yet accepted by the agent).
     * For personal voicemails it means "unread" state
     */
    New: 'NEW',

    /**
     * The skill voicemail has been accepted by the agent and has not been
     * postponed (see POSTPONED). In this state, the agent can process the
     * voicemail.
     */
    Processing: 'PROCESSING',

    /**
     * The accepted skill voicemail is postponed due to an incoming call.
     * The agent cannot operate on the voicemail until the call is completed.
     */
    Postponed: 'POSTPONED',

    /**
     * Indicates that personal voicemail has been processed.
     */
    Processed: 'PROCESSED'
  };

  return VoicemailStates;
});

define('models/server/voicemails',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers',
  'models/server/voicemailStates',
  'models/server/contacts'
],
function(_, ServerModels, ModelStorage, FreedomHelpers, VoicemailStates, Contacts) {
  var Voicemails = {
    apiClassType: 'interactions/voicemails',
    resourceId: ModelStorage.Resources.Voicemail,

    Types: {
      None: 'NONE',
      Personal: 'PERSONAL',
      Skill: 'SKILL'
    }
  };

  /**
   * @class Voicemails
   * @extends ServerModel
   * @classdesc
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/agents/getVoicemails Freedom Api getVoicemails}
   *   {@link {@substitute apiBaseUrl}#!/agents/getVoicemail Freedom Api getVoicemail}
   * </pre>
   */
  Voicemails.Model = ServerModels.Model.extend({
    apiClassType: Voicemails.apiClassType,
    defaults: {
      type: Voicemails.Types.None,
      contactLookupResult: [],
      activeContact: {},
      state: VoicemailStates.None,
      number: '',
      comment: '',
      campaignId: null,
      recordings: [],
      variables: null,
      created: null,
      length: null
    },

    initialize: function(options) {
      options = options || {};

      if (!options.contactLookupResult) {
        this.set({'contactLookupResult': []});
      }
      if (!options.recordings) {
        this.set({'recordings': []});
      }
    },

    // children
    /**
     * @memberof Voicemails
     * @returns {Contacts}
     */
    Contacts: function () {
      return ModelStorage.get(this.path(), Contacts);
    },

    //actions
    /**
     * {@link {@substitute apiBaseUrl}#!/agents/acceptSkillVoicemail Freedom Api acceptSkillVoicemail}
     * @returns {Promise}
     * @memberof Voicemails
     */
    acceptSkillVoicemail: function () {
      if (this.get('type')  === Voicemails.Types.Skill) {
        return this.performAction('accept');
      }
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/rejectSkillVoicemail Freedom Api rejectSkillVoicemail}
     * @returns {Promise}
     * @memberof Voicemails
     */
    rejectSkillVoicemail: function () {
      if (this.get('type') === Voicemails.Types.Skill) {
        return this.performAction('reject');
      }
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/markVoicemailAsRead Freedom Api markVoicemailAsRead}
     * @returns {Promise}
     * @memberof Voicemails
     */
    markAsRead: function () {
      return this.performAction('mark_as_read');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/returnCall Freedom Api returnCall}
     * @param {boolean} skipDNCCheck
     * @param {string} contactId
     * @param {boolean} checkMultipleContacts
     * @param {string} number
     * @returns {Promise}
     * @memberof Voicemails
     */
    returnCall: function (skipDNCCheck, contactId, checkMultipleContacts, number) {
      var payload = {
        skipDNCCheck: skipDNCCheck,
        contactId: contactId,
        checkMultipleContacts: checkMultipleContacts,
        number: number
      };
      return this.performAction('return_call', payload, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/removeVoicemail Freedom Api removeVoicemail}
     * @returns {Promise}
     * @memberof Voicemails
     */
    deleteVoicemail: function(){
      return this.performAction(null, null, 'DELETE');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/updateVoicemail Freedom Api updateVoicemail}
     * @param {Object} payload
     * @returns {Promise}
     * @memberof Voicemails
     */
    changeVoicemail: function (payload) {
      // it's not needed to send all the fields
      var necessary_fields = {
        id: this.get('id'),
        number: this.get('number')
      };
      payload = _.extend(necessary_fields, payload);
      return this.performAction(null, payload, 'PUT');
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/transferVoicemail Freedom Api transferVoicemail}
     * @param {string} destination
     * @returns {Promise}
     * @memberof Voicemails
     */
    transferVoicemail: function (destination) {
      return this.performAction('transfer', destination, 'PUT');
    },

    /**
     * @description returns url of voicemail recording
     * @param {string} id
     * @returns {string} url
     * @memberof Voicemails
     */
    getRecordingPath: function (id) {
      var url = Five9.Properties.getHost().replace('appsvcs', 'strsvcs') + '/' + this.path() + '/recordings/' +id;
      return url;
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/setVoicemailActiveContact Freedom Api setVoicemailActiveContact}
     * @param {string} contactId
     * @returns {Promise}
     * @memberof Voicemails
     */
    setActiveContact: function(contactId) {
      return this.performAction('active_contact', contactId, 'PUT');
    },

    // helpers
    isSkillVoicemail: function(){
      return (this.get('type') === Voicemails.Types.Skill);
    },
    isNewState: function() {
      return (this.get('state') === VoicemailStates.New);
    },
    save: function() {
      return ServerModels.Model.prototype.save.apply(this, arguments);
    },
    parse: function(response) {
      // skill voicemails are delivered with a contact.  personal voicemails contacts must be fetched.  pvm's will have a stub contactLayout + activeContact
      // it is possible for skill voicemails to not be assigned a contact
      // note that commands will cause the API to return the original stubs - be sure not to overwrite the fetched contacts with stubs
      if (response.activeContact === null) {
        delete response.activeContact;
      }
      if (response.contactLookupResult === null) {
        delete response.contactLookupResult;
      }
      return response;
    }
  });
  _.extend(Voicemails.Model.prototype, FreedomHelpers.ModelMixin);
  _.extend(Voicemails.Model.prototype, FreedomHelpers.ModelContactMixin);

  Voicemails.Collection = ServerModels.Collection.extend({
    apiClassType: Voicemails.apiClassType,
    model: Voicemails.Model,
    hasMore: false,
    cursor: null,

    parse: function(response) {
      if (response.items) {
        this.hasMore = response.hasMoreRecords;
        this.cursor = response.cursor;
        response = response.items;
      }
      return response;
    },

    skillVoicemail: function() {
      return this.findWhere({type: Voicemails.Types.Skill});
    },
    skillVoicemails: function() {
      return this.where({type: Voicemails.Types.Skill});
    },
    personalVoicemails: function() {
      return this.where({type: Voicemails.Types.Personal});
    },
    personalVoicemail: function(id) {
      return this.findWhere({type: Voicemails.Types.Personal, id: id});
    }
  });
  _.extend(Voicemails.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Voicemails;
});

define('models/server/keyStore',[
  'jquery',
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function($, ServerModels, ModelStorage, DataAdapter) {
  var API = DataAdapter.API;
  var KeyStore = {
    apiClassType: 'client_tools',
    resourceId: ModelStorage.Resources.KeyStore
  };

  KeyStore.Model = ServerModels.Model.extend({
    apiClassType:KeyStore.apiClassType,
    defaults: {
    },

    getItem: function(key) {
      var d = $.Deferred();
      API.performAction('client_tools/key_store/' + key, 'GET', null, null, undefined)
        .done(function(attrs, status, xhr) {
          if (xhr && xhr.status === 204) {
            d.reject({}, 'error', 'OK');
          }
          else {
            d.resolve.apply(d, arguments);
          }
        })
        .fail(function() {
          d.reject.apply(d, arguments);
        });
      return d.promise();
    },

    putItem: function(key, payload) {
      return API.performAction('client_tools/key_store/' + key, 'PUT', null, null, payload);
    },

    deleteItem: function(key) {
      return API.performAction('client_tools/key_store/' + key, 'DELETE', null, null, undefined);
    }
  });

  return KeyStore;
});

define('models/server/connectorsPending',[
    'underscore',
    'server.models.adapter',
    'server.models.storage',
    './freedom.helpers'
  ],
function (_, ServerModels, ModelStorage, FreedomHelpers) {
  var PendingConnectors = {
    apiClassType: 'pending_connectors',
    resourceId: ModelStorage.Resources.PendingConnectors,

    httpMethod: {
      get: 'GET',
      post: 'POST'
    },
    displayMode: {
      noDisplay: 'DO_NOT_DISPLAY',
      currentWindow: 'CURRENT_WINDOW',
      newWindow: 'NEW_WINDOW'
    },
    ctiDisplayMode: {
      noDisplay: 'DO_NOT_DISPLAY',
      currentWindow: 'CURRENT_WINDOW',
      newWindow: 'NEW_WINDOW'
    }
  };

  /**
   * @class PendingConnectors
   * @extends ServerModel
   * @classdesc
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/agents/getPendingConnectors Freedom Api getPendingConnectors}
   *   {@link {@substitute apiBaseUrl}#!/agents/getPendingConnector Freedom Api getPendingConnector}
   * </pre>
   */
  PendingConnectors.Model = ServerModels.Model.extend({
    apiClassType: PendingConnectors.apiClassType,

    defaults: {
      id: null,
      connectorId: null,
      url: '',
      httpMethod: PendingConnectors.httpMethod.get,
      payload: '',
      displayMode: PendingConnectors.displayMode.noDisplay,
      ctiDisplayMode: PendingConnectors.ctiDisplayMode.noDisplay,
      channel: 'VOICE'
    },

    // API methods
    /**
     * {@link {@substitute apiBaseUrl}#!/agents/finalizePendingConnector Freedom Api finalizePendingConnector}
     * @param httpResponseCode
     * @returns {Promise}
     * @memberof PendingConnectors
     */
    finalize: function(httpResponseCode){
      httpResponseCode = _.isNumber(httpResponseCode)? httpResponseCode : 204;
      var payload = {
        httpResponseCode : httpResponseCode,
        channel: this.get('channel')
      };
      return this.performAction('finalize', payload);
    }
  });
  _.extend(PendingConnectors.Model.prototype, FreedomHelpers.ModelMixin);

  PendingConnectors.Collection = ServerModels.Collection.extend({
    apiClassType: PendingConnectors.apiClassType,
    model: PendingConnectors.Model
  });
  _.extend(PendingConnectors.Collection.prototype, FreedomHelpers.CollectionMixin);

  return PendingConnectors;
});

define('models/server/settings',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  'utils',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, DataAdapter, Utils, FreedomHelpers) {
  var API = DataAdapter.API;

  var Settings = {
    apiClassType: 'settings',

    resourceId: ModelStorage.Resources.Settings
  };

  Settings.Model = ServerModels.Model.extend({
    apiClassType:Settings.apiClassType,

    defaults: {
      autoLock:               1,

      chatACDType:            1,
      emailACDType:           1,
      socialACDType:          1,

      chatTerminateMessage:   null,
      chatWelcomeMessage:     null,
      name:                   null,
      timeZone:               null,
      username:               null,

      isFIFO:                 false,
      signatureEnabled:       0,

      currentStatusId:        -1,
      dateRangeEnd:           -1,
      dateRangeStart:         -1,
      lockByDate:             -1,
      lockByUserId:           -1,
      loginStatus:            -1,
      maxChat:                -1,
      maxEmail:               -1,
      maxSocial:              -1,
      showProfiles:           0,
      userId:                 -1,

      sortByInfluence:        0,

      clusters:               [],
      dispositions:           [],
      priorities:             [],
      profiles:               [],
      sentiments:             [],
      spams:                  [],

      signature:              ''
    },

    parse: function(response) {
      if (response.userFilter) {
        response = response.userFilter;
      }

      response.maxChat = parseInt(response.maxChat, 10);
      response.maxEmail = parseInt(response.maxEmail, 10);
      response.maxSocial = parseInt(response.maxSocial, 10);
      response.showProfiles = parseInt(response.showProfiles, 10);

      response.autoLock = (response.autoLock == 1);
      response.sortByInfluence = (response.sortInfluence == 1);
      response.signatureEnabled = (response.signatureEnabled == 1);

      if (response.dateRangeStart < 100) {
        response.dateRangeStart = -1;
      }
      if (response.dateRangeEnd < 100) {
        response.dateRangeEnd = -1;
      }

      _.each(response.clusters, function(item) {
        if (!_.isString(item)) {
          Utils.reportIncorrectFormat('settings', 'clusters', item);
        }
      });
      _.each(response.dispositions, function(item) {
        if (!_.isString(item)) {
          Utils.reportIncorrectFormat('settings', 'dispositions', item);
        }
      });
      _.each(response.profiles, function(item) {
        if (!_.isString(item)) {
          Utils.reportIncorrectFormat('settings', 'profiles', item);
        }
      });

      delete response.fifo;
      delete response.sortInfluence;

      return response;
    },

    isACDChat: function() {
      return (this.get('chatACDType') == 2);
    },

    isACDEmail: function() {
      return (this.get('emailACDType') == 2);
    },

    isACDSocial: function() {
      return (this.get('socialACDType') == 2);
    },

    isAutoLock: function() {
      return this.get('autoLock');
    },

    isEmailSignatureEnabled: function() {
      return this.get('signatureEnabled');
    },

    emailSignature: function() {
      if (this.get('signature')) {
        return this.get('signature').replace(/[\r|\n]/g, '<br>');
      }
      else {
        return '';
      }
    },

    setToggle: function(id) {
      this.set(id, !this.get(id));
    },

    update: function(updatedModel) {
      var settings = this;

      var keys = _.keys(updatedModel.attributes);

      _.each(keys, function(key) {
        settings.set(key, updatedModel.get(key), {silent : true});
      });
    },

    toJSON: function() {
      var settings = {
        autoLock               : this.get("autoLock") ? 1 : 0,
        chatACDType            : this.get("chatACDType"),
        chatTerminateMessage   : this.get("chatTerminateMessage"),
        chatWelcomeMessage     : this.get("chatWelcomeMessage"),
        clusters               : this.get("clusters"),
        currentStatusId        : this.get("currentStatusId"),
        dateRangeEnd           : this.get("dateRangeEnd"),
        dateRangeStart         : this.get("dateRangeStart"),
        dispositions           : this.get("dispositions"),
        emailACDType           : this.get("emailACDType"),
        isFIFO                 : this.get("isFIFO"),
        lockByDate             : this.get("lockByDate"),
        lockByUserId           : this.get("lockByUserId"),
        loginStatus            : this.get("loginStatus"),
        maxChat                : this.get("maxChat"),
        maxEmail               : this.get("maxEmail"),
        maxSocial              : this.get("maxSocial"),
        name                   : this.get("name"),
        priorities             : this.get("priorities"),
        profiles               : this.get("profiles"),
        sentiments             : this.get("sentiments"),
        showProfiles           : this.get("showProfiles"),
        socialACDType          : this.get("socialACDType"),
        sortInfluence          : this.get("sortByInfluence") ? 1 : 0,
        spams                  : this.get("spams"),
        timeZone               : this.get("timeZone"),
        userId                 : this.get("userId"),
        username               : this.get("username"),
        signatureEnabled       : this.get("signatureEnabled") ? 1 : 0,
        signature              : this.get("signature")
      };

      return settings;
    },

     save: function() {
      var settings = this.toJSON();

      /**
       * Removing field that the API can't receive
       */
      delete settings.chatTerminateMessage;
      delete settings.chatWelcomeMessage;
      delete settings.currentStatusId;
      delete settings.loginStatus;
      delete settings.maxChat;
      delete settings.maxEmail;
      delete settings.maxSocial;
      delete settings.name;
      delete settings.showProfiles;
      delete settings.timeZone;
      delete settings.userId;
      delete settings.username;

      settings.isFIFO = settings.isFIFO ? 1 : 0;

      return API.performAction('agents/' + Five9.Context.AgentId + '/settings', 'PUT', null, null, settings);
     }
  });
  _.extend(Settings.Model.prototype, FreedomHelpers.ModelMixin);

  return Settings;
});

define('models/server/personalGreeting',[
    'underscore',
    'server.models.adapter',
    'server.models.storage',
    './freedom.helpers'
  ],
  function(_, ServerModels, ModelStorage, FreedomHelpers) {
    var Greetings = {
      apiClassType: 'personal_greeting'
    };

    Greetings.Model = ServerModels.Model.extend({
      apiClassType: Greetings.apiClassType,
      defaults: {
        hasGreeting: false
      },

      uploadGreeting: function(formData) {
        return this.uploadFile(null, formData, 'PUT');
      },

      deleteGreeting: function () {
        return this.performAction(null, null, 'DELETE');
      }
    });
    _.extend(Greetings.Model.prototype, FreedomHelpers.ModelMixin);

    return Greetings;
  });

define('models/server/subscriptions',[
    'underscore',
    'server.models.adapter',
    'server.models.storage',
    './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var Subscriptions = {
    apiClassType: 'subscriptions',
    resourceId: ModelStorage.Resources.Subscriptions,
    Resources: {
      //currently known
      agentsPresences: 'agentsReadyPresencesSubscription',
      skillStats: 'skillStatsSnapshotSubscription'
    }
  };

  /**
   * @class Subscriptions
   * @extends ServerModel
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/agents/getSubscriptions Freedom Api getSubscriptions}
   * </pre>
   */
  Subscriptions.Model = ServerModels.Model.extend({
    apiClassType: Subscriptions.apiClassType,
    defaults: {
      name: '',
      parameters: null,
      subscribed: false
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/subscribe Freedom Api subscribe}
     * @memberof Subscriptions
     * @returns {Promise}
     */
    save: function () {
      this.performAction(null, this, 'PUT');
    }
  });
  _.extend(Subscriptions.Model.prototype, FreedomHelpers.ModelMixin);

  Subscriptions.Collection = ServerModels.Collection.extend({
    apiClassType: Subscriptions.apiClassType,
    model: Subscriptions.Model,
    getByName: function (subscriptionName) {
      return this.findWhere({name: subscriptionName});
    }
  });
  _.extend(Subscriptions.Collection.prototype, FreedomHelpers.CollectionMixin);
  return Subscriptions;
});

define('models/server/agentsReadyPresences',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var AgentsReadyPresences = {
    apiClassType: "webSocketResources/agentsReadyPresences", //fake, received only by web socket
    resourceId: ModelStorage.Resources.AgentsReadyPresences,
    interactionTypes: {
      CALL: 'CALL',
      VOICE_MAIL: 'VOICE_MAIL'
    }
  };

  var defaultLogoutReadyStatuses = {
      "VOICE_MAIL": "LOGGED_OUT",
      "EMAIL": "LOGGED_OUT",
      "SOCIAL": "LOGGED_OUT",
      "CHAT": "LOGGED_OUT",
      "CALL": "LOGGED_OUT"
  };

  var defaultNotReadyStatuses = {
      "VOICE_MAIL": "NOT_READY",
      "EMAIL": "NOT_READY",
      "SOCIAL": "NOT_READY",
      "CHAT": "NOT_READY",
      "CALL": "NOT_READY"
  };

  var letterChannelMapping = {
      "v": "VOICE_MAIL",
      "e": "EMAIL",
      "s": "SOCIAL",
      "h": "CHAT",
      "c": "CALL"
  };

  AgentsReadyPresences.Model = ServerModels.Model.extend({
    apiClassType: AgentsReadyPresences.apiClassType,
    defaults: {
      data: {}
    },

    isReadyForCall: function (agentId) {
      var agentPresence = this.get('data')[agentId];
      if (agentPresence && agentPresence.availableInteractions) {
        return agentPresence.availableInteractions[AgentsReadyPresences.interactionTypes.CALL] === 1;
      }
    },

    // Parse payload to old format:
    // Use single letter for ready channel.
    //   c-for CALL, v-VOICE_MAIL, s-SOCIAL, h-CHAT, e-EMAIL. o-letter reserved for logged out agent.
    //   “empty string” means agent is logged in but ready for nothing.
    //
    // Example:
    //  {
    //      "100": “o”,
    //      "194": ”cv”
    //  }
    //
    // We have to bring it to old format for back compatibility
    //  {
    //      "100": {
    //      "readyStatuses": {
    //          "VOICE_MAIL": "LOGGED_OUT",
    //                  "EMAIL": "LOGGED_OUT",
    //                  "SOCIAL": "LOGGED_OUT",
    //                  "CHAT": "LOGGED_OUT",
    //                  "CALL": "LOGGED_OUT"
    //      }
    //  },
    //      "194": {
    //      "readyStatuses": {
    //          "VOICE_MAIL": "READY",
    //                  "EMAIL": "NOT_READY",
    //                  "SOCIAL": "NOT_READY",
    //                  "CHAT": "NOT_READY",
    //                  "CALL": "READY"
    //      }
    //  }}
    parse: function (response) {
      var data = {};
      _.each(response, function(value, key) {
        if (value.length === 0) {
          // User logged in but in not ready state
          data[key] = {"readyStatuses":_.clone(defaultNotReadyStatuses)};
        } else if (value.indexOf('o') >= 0) {
          // User Logged out
          data[key] = {"readyStatuses":_.clone(defaultLogoutReadyStatuses)};
        } else {
          data[key] = {"readyStatuses":_.clone(defaultNotReadyStatuses)};
          for (var i = 0; i < value.length; i++) {
            var channel = letterChannelMapping[value.charAt(i)];
            if (channel) {
              data[key].readyStatuses[channel] = "READY";
            }
          }
        }
      });
      return {data:data};
    },

    fetch: function () {
      //dummy fetch, cause it's can't be accessed via HTTP, only via web sockets
      return $.Deferred().resolve().promise();
    }
  });
  _.extend(AgentsReadyPresences.Model.prototype, FreedomHelpers.ModelMixin);

  return AgentsReadyPresences;
});

define('models/server/sessionExpInfo',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var ExpirationInfo = {
    apiClassType: 'session_expiration'
  };

  ExpirationInfo.Model = ServerModels.Model.extend({
    apiClassType: ExpirationInfo.apiClassType,
    defaults: {
      expirationMode: 'NEVER_EXPIRE',
      maxInactivityTime: 0,
      timeToWarnBeforeLogout: 0,
      pingInterval: 0
    }
  });
  _.extend(ExpirationInfo.Model.prototype, FreedomHelpers.ModelMixin);

  return ExpirationInfo;
});

define('models/server/versions',[
    'server.models.adapter',
    'server.models.storage',
    'dataAdapter'
  ],
  function(ServerModels, ModelStorage, DataAdapter) {
    var API = DataAdapter.API;
    var Versions = {
      apiClassType: 'orgs',
      resourceId: ModelStorage.Resources.Versions
    };

    Versions.Model = ServerModels.Model.extend({
      apiClassType:Versions.apiClassType,
      defaults: {
      },

      getVersions: function() {
        return API.performAction('orgs/' + Five9.Context.TenantId, 'GET', null, null, undefined);
      }
    });

    return Versions;
  });

define('models/server/customerPortal',[
  'underscore',
  'server.models.adapter',
  'jquery',
  'server.models.storage',
  './freedom.helpers'
],

function(_, ServerModels, $, ModelStorage, FreedomHelpers) {
  var CustomerPortal = {
    apiClassType: 'customer_portal',
    resourceId: ModelStorage.Resources.CustomerPortal
  };

  CustomerPortal.Model = ServerModels.Model.extend({
    apiClassType:CustomerPortal.apiClassType,

    parse: function(response) {
      return response;
    }

  });
  _.extend(CustomerPortal.Model.prototype, FreedomHelpers.ModelMixin);
  return CustomerPortal;
});

define('models/server/agentGroups',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var AgentGroups = {
    apiClassType: 'agent_groups',
    resourceId: ModelStorage.Resources.AgentGroups
  };

  AgentGroups.Model = ServerModels.Model.extend({
    apiClassType: AgentGroups.apiClassType,
    defaults: {
      name: ''
    }
  });
  _.extend(AgentGroups.Model.prototype, FreedomHelpers.ModelMixin);

  AgentGroups.Collection = ServerModels.Collection.extend({
    apiClassType: AgentGroups.apiClassType,
    model: AgentGroups.Model,

    comparator: function(item) {
      return item.get('name');
    }
  });
  _.extend(AgentGroups.Collection.prototype, FreedomHelpers.CollectionMixin);

  return AgentGroups;
});

define('models/server/campaignFieldViews',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var CampaignFieldViews = {
    apiClassType: 'field_views'
  };

  // models / collections
  CampaignFieldViews.Model = ServerModels.Model.extend({
    apiClassType:CampaignFieldViews.apiClassType,

    defaults: {
      label: '',
      width: 0,
      editable: true,
      relatedField: {}
    }
  });
  _.extend(CampaignFieldViews.Model.prototype, FreedomHelpers.ModelMixin);

  CampaignFieldViews.Collection = ServerModels.Collection.extend({
    apiClassType:CampaignFieldViews.apiClassType,
    model: CampaignFieldViews.Model
  });
  _.extend(CampaignFieldViews.Collection.prototype, FreedomHelpers.CollectionMixin);

  return CampaignFieldViews;
});

define('models/server/agentCampaigns',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage',
  'models/server/campaignFieldViews'
],
function(_, ServerModels, FreedomHelpers, ModelStorage, CampaignFieldViews) {
  var AgentCampaigns = {
    apiClassType: 'campaign'
  };

  AgentCampaigns.Model = ServerModels.Model.extend({
    apiClassType: AgentCampaigns.apiClassType,
    defaults: {
    },

    FieldViews: function() {
      return ModelStorage.get(this.path(), CampaignFieldViews);
    },

    FieldView: function(id) {
      return ModelStorage.get(this.path(), CampaignFieldViews, id);
    }

  });
  _.extend(AgentCampaigns.Model.prototype, FreedomHelpers.ModelMixin);


  AgentCampaigns.Collection = ServerModels.Collection.extend({
    apiClassType: AgentCampaigns.apiClassType,
    model: AgentCampaigns.Model
  });
  _.extend(AgentCampaigns.Collection.prototype, FreedomHelpers.CollectionMixin);

  return AgentCampaigns;
});

define('models/server/maintenanceNotices',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
  ],
function(_, ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
  var API = DataAdapter.API;
  var MaintenanceNotices = {
    apiClassType: 'maintenance_notices',
    resourceId: ModelStorage.Resources.MaintenanceNotices
  };

  MaintenanceNotices.Model = ServerModels.Model.extend({
    apiClassType: MaintenanceNotices.apiClassType,
    defaults: {
      text: '',
      annotation: ''
    },

    accept: function() {
      return this.performAction('accept', null, 'PUT');
    }
  });

  _.extend(MaintenanceNotices.Model.prototype, FreedomHelpers.ModelMixin);

  MaintenanceNotices.Collection = ServerModels.Collection.extend({
    apiClassType: MaintenanceNotices.apiClassType,
    model: MaintenanceNotices.Model
  });
  _.extend(MaintenanceNotices.Collection.prototype, FreedomHelpers.CollectionMixin);

  return MaintenanceNotices;
});


define('models/server/prompts',[
    'underscore',
    'server.models.adapter',
    'server.models.storage',
    './freedom.helpers'
  ],
  function(_, ServerModels, ModelStorage, FreedomHelpers) {
    var Prompts = {
      apiClassType: 'prompts'
    };

    Prompts.Model = ServerModels.Model.extend({
      apiClassType: Prompts.apiClassType,
      defaults: {
        id: null,
        name: "",
        description: "",
        duration: ""
      }
    });

    Prompts.Collection = ServerModels.Collection.extend({
      apiClassType: Prompts.apiClassType,
      model: Prompts.Model
    });

    _.extend(Prompts.Model.prototype, FreedomHelpers.ModelMixin);
    _.extend(Prompts.Collection.prototype, FreedomHelpers.CollectionMixin);

    return Prompts;
  });

define('models/server/locale',[
    'underscore',
		'server.models.adapter',
		'server.models.storage',
		'dataAdapter',
		'./freedom.helpers'
	],
	function(_, ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
		var Locale = {
			apiClassType: 'locale'
		};

		Locale.Model = ServerModels.Model.extend({
			apiClassType: Locale.apiClassType,
			defaults: {
				value: 'en'
			},

			save: function() {
				return this.performAction(null, this.attributes, 'PUT');
			}
		});

		_.extend(Locale.Model.prototype, FreedomHelpers.ModelMixin);

		return Locale;
	});

define('models/server/missedCalls',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage',
  'app/five9.properties',
  'dataAdapter-api',
  'five9'
],
function(_, ServerModels, FreedomHelpers, ModelStorage, Properties, API, Five9) {

  var MissedCalls = {
    apiClassType: 'missed',

    ReceptionStatus : {
      // Call reception status is unknown
      Unknown: 'UNKNOWN',
      // Call not answered from the agent's personal queue
      Missed: 'MISSED',
      // Call was missed but agent returned call to contact from missed call
      MissedReturned: 'MISSED_RETURNED',
      // Call received by the agent
      Received: 'RECEIVED'
    }
  };

  MissedCalls.Model = ServerModels.Model.extend({
    apiClassType: MissedCalls.apiClassType,

    defaults: {
      id: -1,
      from: 0,
      agentName: null,
      contactId: -1,
      startTime: 0,
      profileId: 0
    }

  });

  MissedCalls.Collection = ServerModels.Collection.extend({
    model: MissedCalls.Model,
    apiClassType: MissedCalls.apiClassType,

    _init: function () {
      var self = this;
      ServerModels.Collection.prototype._init.apply(this, arguments);
      this.iteratorUrl = this.path().match(/agents\/\d+/i) + '/history';
      var splitted = this.path().split('/');
      this.timePeriod = splitted[splitted.length - 2];

      Five9.vent.on(ModelStorage.WebSocketEvents.NewInteraction, function(payload) {
        if (payload.receptionStatus !== MissedCalls.ReceptionStatus.Missed) {
          return;
        }
        if (self.timePeriod === 'YESTERDAY' || self.timePeriod === 'LAST_WEEK') {
          return;
        }
        ModelStorage.setFetched(this);
        ModelStorage.getFetchDeferrsPromise(this).done(function() {
          self.add(payload, {parse: true});
        });

      }, this);

      Five9.vent.on(ModelStorage.WebSocketEvents.InteractionSessionUpdated, function (payload) {
        if (payload.receptionStatus === MissedCalls.ReceptionStatus.MissedReturned) {
          this.remove(payload.id);
        }
      }, this);

    },

    sync: function(operation, model, options) {
      var self = this;

      var iterate = function(iteratorId, accumulation, deffered) {
        API.performAction(self.iteratorUrl + '/' + iteratorId + '/next', 'PUT')
          .done(function(data) {
            // Append the records to our collection
            accumulation = accumulation.concat(data.records);
            if (data.hasMore) {
              iterate(iteratorId, accumulation, deffered);
            } else {
              deffered.resolve(accumulation);
            }
          })
          .fail(function(jqXHR, textStatus, errorThrown) {
            deffered.reject(jqXHR, textStatus, errorThrown);
          });

        return deffered.promise();
      };

      var masterDeffered = new $.Deferred();

      //50 is a max value for limit
      var payload = {"limit": 50, "period": self.timePeriod, "includeDialAttempts": true, "onlyMissed": true};
      API.performAction(self.iteratorUrl, 'POST', null, null, payload).done(_.bind(function(iterator) {
        var iteratorId = iterator.id;
        var iteratorRecords = iterator.records;
        if ( !iterator.hasMore ) {
          options.success(iteratorRecords);
          masterDeffered.resolve(iteratorRecords);
        } else {
          iterate(iteratorId, [], new $.Deferred())
            .done(_.bind( function(data) {
              var result = iteratorRecords.concat(data);
              options.success(result);
              masterDeffered.resolve(iteratorRecords.concat(data));
            } ,this))
            .fail(function(jqXHR, textStatus, errorThrown) {
              masterDeffered.reject(jqXHR, textStatus, errorThrown);
            });
        }
      }, this))
        .fail(function(xhr, status, error) {
          // Reject the master Deferred with the error object
          masterDeffered.reject(xhr, status, error);
        });

      return masterDeffered.promise();
    },

    comparator: function(model) {
      return -model.get('startTime');
    }
  });

  _.extend(MissedCalls.Model.prototype, FreedomHelpers.ModelMixin);

  return MissedCalls;
});

define('models/server/historyPeriod',[
    'underscore',
    'server.models.adapter',
    './freedom.helpers',
    'server.models.storage',
    'models/server/missedCalls'
  ],
  function(_, ServerModels, FreedomHelpers, ModelStorage, MissedCalls) {

    var HistoryPeriod = {
      apiClassType: 'historyPeriod',

      TimePeriod: {
        CurrentSession: 'CURRENT_SESSION',
        Today:          'TODAY',
        Yesterday:      'YESTERDAY',
        Last7Days:      'LAST_7_DAYS',
        LastWeek:       'LAST_WEEK',
        Last14Days:     'LAST_14_DAYS',
        Last30Days:     'LAST_30_DAYS',
        Last60Days:     'LAST_60_DAYS'
      }
    };

    HistoryPeriod.Model = ServerModels.Model.extend({
      apiClassType: HistoryPeriod.apiClassType,
      defaults: HistoryPeriod.TimePeriod.CurrentSession,

      sync: function() {
        throw new Error('Sync is not supported by HistoryPeriod.Model');
      },

      MissedCalls: function() {
        return ModelStorage.get(this.path(), MissedCalls);
      }
    });


    HistoryPeriod.Collection = ServerModels.Collection.extend({
      apiClassType: HistoryPeriod.apiClassType,
      model: HistoryPeriod.Model,

      sync: function() {
        throw new Error('Sync is not supported by HistoryPeriod.Collection');
      }
    });

    _.extend(HistoryPeriod.Model.prototype, FreedomHelpers.ModelMixin);

    return HistoryPeriod;
  });

define('models/server/webAnalytics',[
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function(ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {

  var WebAnalytics = {
    apiClassType: 'web_analytics_license',
    licenseType: {
      Full: 'FULL',
      Limited: 'LIMITED'
    }
  };

  WebAnalytics.Model = ServerModels.Model.extend({
    apiClassType: WebAnalytics.apiClassType,

    defaults: {
      type: null,
      token: null,
      expiresInSec: null
    },

    createAccessToken: function(licenseType) {
      var payload = {};
      if (!licenseType) {
        payload.type = WebAnalytics.licenseType.Full;
      }
      else {
        payload.type = licenseType;
      }

      return this.performAction(null, payload, 'POST');
    },
    refreshAccessToken: function() {
      return this.performAction(null, null, 'PUT');
    },
    deleteAccessToken: function() {
      return this.performAction(null, null, 'DELETE');
    },

    isFullLicenseAllowed: function() {
      if (this.get('token') && this.get('type') === WebAnalytics.licenseType.Full) {
        return true;
      }
      return false;
    }
  });

  return WebAnalytics;
});


define('models/server/webAnalyticsProxy',[
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function(ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
  var Proxy = {
    apiClassType: 'altocloud_proxy',
    resourceId: ModelStorage.Resources.Proxy
  };

  Proxy.Model = ServerModels.Model.extend({
    apiClassType: Proxy.apiClassType,

    proxy: function(payload) {
      var ajaxOptions = {
        noRetry: true,
        suppressErrorHandling: true
      };
      return this.performAction(null, payload, 'PUT', true, undefined, true, ajaxOptions);
    }
  });

  return Proxy;
});

define('models/server/agents',[
  'dataAdapter',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers',
  'underscore',
  'models/server/acdStatus',
  'models/server/activeSkills',
  'models/server/agentOptions',
  'models/server/agentsPassword',
  'models/server/agentPresence',
  'models/server/calls',
  'models/server/callPreviews',
  'models/server/echoCall',
  'models/server/testCall',
  'models/server/campaignConfig',
  'models/server/destinationCampaigns',
  'models/server/channels',
  'models/server/contacts',
  'models/server/contacts-noFullTextSearch',
  'models/server/fieldViews',
  'models/server/internalMessages',
  'models/server/loginState',
  'models/server/logIssue',
  'models/server/issue',
  'models/server/permissions',
  'models/server/queueCallbacks',
  'models/server/callbacks',
  'models/server/skills',
  'models/server/station',
  'models/server/stationState',
  'models/server/softphoneConfig',
  'models/server/transfereeAgents',
  'models/server/transferableSkillsChat',
  'models/server/transferableSkillsEmail',
  'models/server/transferableSkillsSocial',
  'models/server/voicemails',
  'models/server/keyStore',
  'models/server/connectorsPending',
  'models/server/settings',
  'models/server/personalGreeting',
  'models/server/subscriptions',
  'models/server/agentsReadyPresences',
  'models/server/sessionExpInfo',
  'models/server/versions',
  'models/server/customerPortal',
  'models/server/agentGroups',
  'models/server/agentCampaigns',
  'models/server/maintenanceNotices',
  'models/server/prompts',
  'models/server/histories',
  'models/server/authors',
  'models/server/authorHistory.helpers',
  'models/server/locale',
  'models/server/historyPeriod',
  'models/server/webAnalytics',
  'models/server/webAnalyticsProxy'
],
function(DataAdapter, ServerModels, ModelStorage, FreedomHelpers, _, AcdStatus, ActiveSkills, AgentOptions, AgentsPassword, AgentPresence, Calls, CallPreviews, EchoCall, TestCall, CampaignConfig, DestinationCampaigns, Channels,
         Contacts, ContactsNoFullTextSearch, FieldViews, InternalMessages, LoginStates, LogIssue, Issue, Permissions, QueueCallbacks, Callbacks, Skills, Station, StationState, SoftphoneConfig, TransfereeAgents,
         ChatTransferableSkills, EmailTransferableSkills, SocialTransferableSkills, Voicemails, KeyStore,
         PendingConnectors, Settings, PersonalGreeting, Subscriptions, AgentsReadyPresences, SessionExpInfo, Versions, CustomerPortal, AgentGroups, AgentCampaigns, MaintenanceNotices, Prompts, Histories, Authors, AuthorHistoryHelpers,
         Locale, HistoryPeriod, WebAnalytics, WebAnalyticsProxy) {

  var API = DataAdapter.API;



  var Agents = {
    apiClassType: 'agents'
  };

  Agents.ReadyStates = {
    Ready: 'ready',
    NotReady: 'not_ready',
    Unavailable: 'not_logged_in'
  };

  Agents.ExtendedReadyStates = {
    Undefined:    'UNDEFINED',    /** Agent's presence is undefined */
    LoggedOut:    'LOGGED_OUT',   /** Agent is logged out */
    Ready:        'READY',        /** Agent is ready for a task */
    NotReady:     'NOT_READY',    /** Agent is not ready */
    Ringing:      'RINGING',      /** Agent has a call that is ringing */
    OnCall:       'ON_CALL',      /** Agent is on a call */
    ACW:          'ACW',          /** Agent is performing After Call Work */
    OnPreview:    'ON_PREVIEW',   /** Agent is previewing a task */
    OnVoicemail:  'ON_VOICEMAIL', /** Agent is working on a voicemail */
    OnChat:       'ON_CHAT',      /** Agent is in a chat session */
    onSocial:     'ON_SOCIAL',    /** Agent is working on a social item */
    OnEmail:      'ON_EMAIL'      /** Agent is working on an email */
  };
  Agents.extendedStateToReadyState = function(extendedState) {
    switch (extendedState) {
      case Agents.ExtendedReadyStates.Ready:
        return Agents.ReadyStates.Ready;
      case Agents.ExtendedReadyStates.NotReady:
      case Agents.ExtendedReadyStates.Ringing:
      case Agents.ExtendedReadyStates.OnCall:
      case Agents.ExtendedReadyStates.ACW:
      case Agents.ExtendedReadyStates.OnPreview:
      case Agents.ExtendedReadyStates.OnVoicemail:
      case Agents.ExtendedReadyStates.OnChat:
      case Agents.ExtendedReadyStates.onSocial:
      case Agents.ExtendedReadyStates.OnEmail:
        return Agents.ReadyStates.NotReady;
      case Agents.ExtendedReadyStates.Undefined:
      case Agents.ExtendedReadyStates.LoggedOut:
        return Agents.ReadyStates.Unavailable;
      default:
        return Agents.ReadyStates.Unavailable;
    }
  };

  Agents.Status = {
    onEmail:      -4000,
    onChat:       -3000,
    onSocial:     -2000,
    available:    0,
    busy:         1
  };

  /**
   * @class Agents
   * @extends ServerModel
   */
  Agents.Model = ServerModels.Model.extend({
    apiClassType:Agents.apiClassType,

    defaults: {
      userName: '',
      fullName: '',
      extension: '',
      email: '',
      active: true,
      status: Agents.ReadyStates.Unavailable,
      statusId: Agents.Status.busy,
      timeZone: null
    },

    // getters
    getId: function() {
      return this.get('id');
    },

    // helpers
    isReady: function() {
      return this.get('ready') === Agents.ReadyStates.Ready;
    },

    // API's
    AcdStatus: function() {
      return ModelStorage.get(this.path(), AcdStatus);
    },
    ActiveSkills: function() {
      return ModelStorage.get(this.path(), ActiveSkills);
    },
    AgentGroups: function() {
      return ModelStorage.get(this.path(), AgentGroups);
    },

    Channels: function() {
      return ModelStorage.get(this.path(), Channels);
    },
    Channel: function(id) {
      return ModelStorage.get(this.path(), Channels, id);
    },
    /**
     * @memberof Agents
     * @description Get all calls collection
     * {@link Calls}
     *
     * @returns {Calls}
     */
    Calls: function() {
      return ModelStorage.get(this.path(), Calls);
    },
    /**
     * @memberof Agents
     * @description Get call with specific id
     * @param {string} id
     * @returns {Calls}
     */
    Call: function(id) {
      return ModelStorage.get(this.path(), Calls, id);
    },
    /**
     * @memberof Agents
     * @description Get call previews collection
     * @returns {CallPreviews}
     */
    CallPreviews: function() {
      return ModelStorage.get(this.path(), CallPreviews);
    },
    /**
     * @memberof Agents
     * @description Get call preview with specific id
     * @returns {CallPreviews}
     **/
    CallPreview: function(id) {
      return ModelStorage.get(this.path(), CallPreviews, id);
    },
    /**
     * @memberof Agents
     * @returns {CampaignConfig}
     */
    CampaignConfig: function() {
      return ModelStorage.get(this.path(), CampaignConfig);
    },
    CustomerPortal: function(){
      return ModelStorage.get(this.path(), CustomerPortal);
    },
    DestinationCampaigns: function() {
      return ModelStorage.get(this.path(), DestinationCampaigns);
    },
    /**
     * @memberof Agents
     * @description get contact with specific id
     * @param id {string} contact id
     * @returns {Contacts}
     */
    Contact: function(id) {
      return ModelStorage.get(this.path(), Contacts, id);
    },
    ContactNoFullTextSearch: function(id) {
      return ModelStorage.get(this.path(), ContactsNoFullTextSearch, id);
    },
    EchoCall: function() {
      return ModelStorage.get(this.path(), EchoCall);
    },
    TestCall: function() {
      return ModelStorage.get(this.path(), TestCall);
    },
    FieldViews: function() {
      return ModelStorage.get(this.path(), FieldViews);
    },
    FieldView: function(id) {
      return ModelStorage.get(this.path(), FieldViews, id);
    },
    PersonalGreeting: function() {
      return ModelStorage.get(this.path(), PersonalGreeting);
    },
    Prompt: function (id) {
      return ModelStorage.get(this.path(), Prompts, id);
    },
    InternalMessages: function() {
      return ModelStorage.get(this.path(), InternalMessages);
    },
    InternalMessage: function(id) {
      return ModelStorage.get(this.path(), InternalMessages, id);
    },
    /**
     * @memberof Agents
     * @description get agents login state
     * @returns {LoginState}
     */
    LoginState: function() {
      return ModelStorage.get(this.path(), LoginStates);
    },
    LogIssue: function() {
      return ModelStorage.get(this.path(), LogIssue);
    },
    Issue: function() {
      return ModelStorage.get(this.path(), Issue);
    },

    /**
     * @memberof Agents
     * @returns {AgentOptions}
     */
    Options: function() {
      return ModelStorage.get(this.path(), AgentOptions);
    },
    Password: function() {
      return ModelStorage.get(this.path(), AgentsPassword);
    },

    /**
     * @returns {Permissions}
     * @memberof Agents
     */
    Permissions: function() {
      return ModelStorage.get(this.path(), Permissions);
    },
    /**
     * @memberof Agents
     * @description get agents presence info
     * @returns {Presence}
     */
    Presence: function() {
      return ModelStorage.get(this.path(), AgentPresence);
    },
    QueueCallbacks: function() {
      return ModelStorage.get(this.path(), QueueCallbacks);
    },
    QueueCallback: function(id) {
      return ModelStorage.get(this.path(), QueueCallbacks, id);
    },
    /**
     * @memberof Agents
     * @description get agents callbacks
     * @returns {Callbacks}
     */
    Callbacks: function() {
      return ModelStorage.get(this.path(), Callbacks);
    },
    /**
     * @memberof Agents
     * @description get agents callback with specific id
     * @param id {string} callback id
     * @returns {Callbacks}
     */
    Callback: function(id) {
      return ModelStorage.get(this.path(), Callbacks, id);
    },
    Settings: function() {
      return ModelStorage.get(this.path(), Settings);
    },
    Skills: function() {
      return ModelStorage.get(this.path(), Skills);
    },
    KeyStore: function() {
      return ModelStorage.get(this.path(), KeyStore);
    },
    Station: function() {
      return ModelStorage.get(this.path(), Station);
    },
    StationState: function() {
      return ModelStorage.get(this.path(), StationState);
    },
    SoftphoneConfig: function() {
      return ModelStorage.get(this.path(), SoftphoneConfig);
    },
    Transferees: function() {
      return ModelStorage.get(this.path(), TransfereeAgents);
    },
    ChatTransferableSkills: function() {
      return ModelStorage.get(this.path(), ChatTransferableSkills);
    },
    EmailTransferableSkills: function() {
      return ModelStorage.get(this.path(), EmailTransferableSkills);
    },
    SocialTransferableSkills: function() {
      return ModelStorage.get(this.path(), SocialTransferableSkills);
    },
    /**
     * @memberof Agents
     * @returns {Voicemails}
     */
    Voicemails: function() {
      return ModelStorage.get(this.path(), Voicemails);
    },
    /**
     * @param {string} id
     * @memberof Agents
     * @returns {Voicemails}
     */
    Voicemail: function(id) {
      return ModelStorage.get(this.path(), Voicemails, id);
    },
    /**
     * @memberof Agents
     * @returns {PendingConnectors}
     */
    PendingConnectors: function() {
      return ModelStorage.get(this.path(), PendingConnectors);
    },
    /**
     * @param {string} id
     * @memberof Agents
     * @returns {PendingConnectors}
     */
    PendingConnector: function(id) {
      return ModelStorage.get(this.path(), PendingConnectors, id);
    },
    /**
     * @memberof Agents
     * @description get subscriptions collection
     * @returns {Subscriptions}
     */
    Subscriptions: function () {
      return ModelStorage.get(this.path(), Subscriptions);
    },
    AgentsReadyPresences: function () {
      return ModelStorage.get(this.path(), AgentsReadyPresences);
    },
    SessionExpirationInfo: function () {
      return ModelStorage.get(this.path(), SessionExpInfo);
    },
    Versions: function() {
      return ModelStorage.get(this.path(), Versions);
    },
    Campaign: function(id) {
      return ModelStorage.get(this.path(), AgentCampaigns, id);
    },
    MaintenanceNotices: function() {
      return ModelStorage.get(this.path(), MaintenanceNotices);
    },
    Locale: function () {
      return ModelStorage.get(this.path(), Locale);
    },
    HistoryPeriod: function (timePeriod) {
      return ModelStorage.get(this.path(), HistoryPeriod, timePeriod);
    },
    HistoryPeriods: function () {
      return ModelStorage.get(this.path(), HistoryPeriod);
    },
    WebAnalytics: function() {
      return ModelStorage.get(this.path(), WebAnalytics);
    },
    WebAnalyticsProxy: function() {
      return ModelStorage.get(this.path(), WebAnalyticsProxy);
    },

    // actions
    addNumberToDncList: function(number) {
      var payload = {
          value:number
        };
      return this.performAction('add_number_to_dnc', payload, 'PUT', true);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/createSession Freedom API createSession}
     * @param {Object} payload
     * @param {boolean} force
     * @param {string} appType
     * @returns {Promise}
     * @memberof Agents
     */
    startSession: function(payload, force, appType) {
      var params = {};
      params.timeZoneOffset = new Date().getTimezoneOffset() * -1;
      if (!_.isUndefined(force)) {
        params.force = force;
      }
      if (!_.isUndefined(appType)) {
        params.appType = appType;
      }
      return this.performAction('session_start', payload, 'PUT', true, params);
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/sessionStop Freedom API sessionStop}
     * @param {string} reasonId
     * @param {boolean} isForce
     * @returns {Promise}
     * @memberof Agents
     */
    stopSession: function(reasonId, isForce) {
      isForce = !!isForce;
      var payload = {
        id:reasonId
      };
      return this.performAction('session_stop', payload, 'PUT', true, {force: isForce});
    },

    /**
     * {@link {@substitute apiBaseUrl}#!/agents/sessionRestart Freedom API sessionRestart}
     * @memberof Agents
     */
    restartSession: function() {
      return this.performAction('session_restart', null, 'PUT');
    },
    getServerSocialItembyId: function(id) {
      return this.performAction('interactions/' + id, null, 'GET', undefined, undefined, true);
    },

    /**
     * {@link {@substitute apiBaseUrl}/#!/agents/makeCallToAgent Freedom API makeCallToAgent}
     * @param {string} agentId
     * @returns {Promise}
     * @memberof Agents
     */
    makeAgentCall: function(agentId) {
      var payload = {
        agentId:agentId
      };
      return this.performAction('interactions/make_agent_call', payload, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}/#!/agents/makeCallToSkill Freedom API makeCallToSkill}
     * @param {string} skillId
     * @returns {Promise}
     * @memberof Agents
     */
    makeSkillCall: function(skillId) {
      var payload = {
        skillId:skillId
      };
      return this.performAction('interactions/make_skill_call', payload, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}/#!/agents/makeCallToSkill Freedom API makeCallToSkill}
     * @param {string} number
     * @param {boolean} skipDNCCheck
     * @param {string} contactId
     * @param {boolean} checkMultipleContacts
     * @param {string} campaignId
     * @returns {Promise}
     * @memberof Agents
     */
    makeExternalCall: function(number, skipDNCCheck, contactId, checkMultipleContacts, campaignId) {
      campaignId = campaignId || "none";
      var payload = {
        number:number,
        skipDNCCheck:skipDNCCheck,
        contactId:contactId,
        checkMultipleContacts:checkMultipleContacts,
        campaignId:campaignId
      };

      if ((campaignId === 'none') || _.isEmpty(campaignId)) {
        delete payload['campaignId'];
      }

      return this.performAction('interactions/make_external_call', payload, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}/#!/agents/makeTestCall Freedom API makeTestCall}
     * @memberof Agents
     * @returns {Promise}
     */
    makeTestCall: function() {
      return this.performAction('interactions/make_test_call', {}, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}/#!/agents/makeCallToSpeedDial Freedom API makeCallToSpeedDial}
     * @param {string} speedDialId
     * @param {boolean} skipDNCCheck
     * @param {string} contactId
     * @param {boolean} checkMultipleContacts
     * @param {string} campaignId
     * @returns {Promise}
     * @memberof Agents
     */
    makeSpeedDialCall: function(speedDialId, skipDNCCheck, contactId, checkMultipleContacts, campaignId) {
      campaignId = campaignId || "none";
      var payload = {
        speedDialId :speedDialId,
        skipDNCCheck:skipDNCCheck,
        contactId:contactId,
        checkMultipleContacts:checkMultipleContacts,
        campaignId:campaignId
      };

      if ((campaignId === 'none') || _.isEmpty(campaignId)) {
        delete payload['campaignId'];
      }

      return this.performAction('interactions/make_speed_dial_call', payload, 'POST');
    },


    returnMissedCall: function(historyId, skipDncCheck) {
      skipDncCheck = !!skipDncCheck;

      var payload = {
        sessionId: historyId,
        skipDNCCheck: skipDncCheck,
        checkMultipleContacts: false
      };

      return this.performAction('interactions/return_missed_call', payload, 'POST');
    },

    /**
     * {@link {@substitute apiBaseUrl}/#!/agents/addCallback Freedom API addCallback}
     * @param {string} number
     * @param {string} campaignId
     * @param {number} dueDate
     * @param {string} comment
     * @param {string} contactId
     * @param {string} agentId
     * @param {boolean} suppressError
     * @returns {Promise}
     * @memberof Agents
     */
    createCallback: function (number, campaignId, dueDate, comment, contactId, agentId, suppressError) {
      suppressError = suppressError || false;
      var payload = {
        number: number,
        campaignId: campaignId,
        dueDate: dueDate,
        comments: comment,
        contactId: contactId,
        agentId: agentId
      };
      //skipModelUpdate has to be true for this call or the agent object gets corrupted
      return this.performAction('callbacks', payload, 'POST', suppressError, undefined, true);
    },

    /**
     * {@link {@substitute apiBaseUrl}/#!/agents/ping Freedom API ping}
     * @returns {Promise}
     * @memberof Agents
     */
    ping: function() {
      return this.performAction('ping', {}, 'PUT', true, undefined, true, {noRetry:true,timeout:10*1000});
    },

    parse: function(response) {
      if (_.isUndefined(response.fullName) || !_.isString(response.fullName) || response.fullName === '') {
        response.fullName = response.userName;
      }

      if (!response.extension) {
        response.extension = '';
      }

      if (!response.status) {
        response.status = Agents.ReadyStates.Unavailable;
      }

      return response;
    },

    changeStatus: function(statusId) {
      var payload = {
        statusId: statusId
      };

      return this.performAction('status', payload, 'PUT');
    },

    requestHelp: function(allAdministrators, allSupervisors, mySkillsSupervisors, skillSupervisors, groupSupervisors, suppressError) {
      suppressError = suppressError || false;
      var payload = {
        allAdministrators: allAdministrators,
        allSupervisors: allSupervisors,
        mySkillsSupervisors: mySkillsSupervisors,
        skillSupervisors: skillSupervisors,
        groupSupervisors:groupSupervisors
      };
      return this.performAction('help_request', payload, 'POST', suppressError);
    },

    triggerHistoryReceived: function() {
      Five9.vent.trigger('agent:history:received', this);
    },
    _loadHistory: function(payload) {
      var url = 'agents/' + this.get('id') + '/history';
      var verb = 'POST';
      if (this.pagingCursor) {
        url += '/' + this.pagingCursor + '/next';
        verb = 'PUT';
      }
      return API.performAction(url, verb, null, null, payload);
    },

    thirdPartyConfig: function(payload) {
      return this.performAction('third_party_config', payload, 'POST');
    },

    sendOutboundEmail: function(email, suppressError) {
      suppressError = suppressError || false;
      return this.performAction('interactions/email/outbound', email, 'PUT', suppressError);
    },

    loadItems: function() {
      return this.performAction('interactions', null, 'POST');
    },
    requestVideoLicense: function () {
      return this.performAction('video_license', null, 'POST');
    },
    releaseVideoLicense: function () {
      return this.performAction('video_license', null, 'DELETE');
    }
  });
  _.extend(Agents.Model.prototype, FreedomHelpers.ModelMixin);
  _.extend(Agents.Model.prototype, AuthorHistoryHelpers.ModelMixin);

  Agents.Collection = ServerModels.Collection.extend({
    apiClassType:Agents.apiClassType,
    model: Agents.Model,
    comparator: function(item) {
        return [item.get('fullName').toLowerCase()];
    }
  });
  _.extend(Agents.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Agents;
});

define('models/server/contactFields',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var ContactFields = {
    apiClassType: 'contact_fields',
    DataTypes: {
      Boolean:      'BOOLEAN',
      Currency:     'CURRENCY',
      Date:         'DATE',
      DateTime:     'DATE_TIME',
      Email:        'EMAIL',
      Number:       'NUMBER',
      Percent:      'PERCENT',
      Phone:        'PHONE',
      String:       'STRING',
      Time:         'TIME',
      TimePeriod:   'TIME_PERIOD',
      Url:          'URL',
      Undefined:    'UNDEFINED'
    }
  };

  // models / collections
  ContactFields.Model = ServerModels.Model.extend({
    apiClassType:ContactFields.apiClassType,

    defaults: {
      name: '',
      dataType: ContactFields.DataTypes.Undefined,    // dataType == db representation (STRING, DATETIME)
      primary: false,
      restrictions: {}
    },

    parse: function(response) {
      if (response.dataType == ContactFields.DataTypes.Email && response.primary) {
        console.info('Primary email field is [' + response.id + ',' + response.name + ']');
      }
      return response;
    }
  });
  _.extend(ContactFields.Model.prototype, FreedomHelpers.ModelMixin);

  ContactFields.Collection = ServerModels.Collection.extend({
    apiClassType:ContactFields.apiClassType,
    model: ContactFields.Model,

    getPrimaryField: function(dataType) {
      return this.findWhere({primary:true, dataType:dataType});
    },
    assumePrimaryField: function(dataType) {
      var primaryField = this.getPrimaryField(dataType);
      if (primaryField) {
        return primaryField;
      }
      return this.where({dataType:dataType})[0];
    }
  });
  _.extend(ContactFields.Collection.prototype, FreedomHelpers.CollectionMixin);

  return ContactFields;
});

define('models/server/notReadyReasonCodes',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var NotReadyReasonCodes = {
    apiClassType: 'not_ready_reason_codes',
    resourceId: ModelStorage.Resources.NotReadyReasonCodes
  };

  /**
   * @class NotReadyReasonCodes
   * @extends ServerModels
   * {@link {@link {@substitute apiBaseUrl}#!/orgs/getNotReadyReasonCodes Freedom Api getNotReadyReasonCodes}
   */
  NotReadyReasonCodes.Model = ServerModels.Model.extend({
    apiClassType: NotReadyReasonCodes.apiClassType,
    defaults: {
      order: -1,
      type: 'not-ready'
    }
  });
  _.extend(NotReadyReasonCodes.Model.prototype, FreedomHelpers.ModelMixin);

  NotReadyReasonCodes.Collection = ServerModels.Collection.extend({
    apiClassType: NotReadyReasonCodes.apiClassType,
    model: NotReadyReasonCodes.Model,
    comparator: function (s1, s2) {
      s1 = s1.get('name').toLowerCase();
      s2 = s2.get('name').toLowerCase();
      if (s1 < s2) return -1;
      if (s1 > s2) return 1;
      return 0;
    }
  });
  _.extend(NotReadyReasonCodes.Collection.prototype, FreedomHelpers.CollectionMixin);

  return NotReadyReasonCodes;
});

define('models/server/speedDials',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {

  var SpeedDials = {
    apiClassType: 'speed_dials'
  };

  /**
   * @class SpeedDials
   * @extends ServerModels
   * {@link {@substitute apiBaseUrl}#!/orgs/getPasswordPolicies Freedom Api getPasswordPolicies}
   */
  SpeedDials.Model = ServerModels.Model.extend({
    apiClassType:SpeedDials.apiClassType,

    defaults: {
      name: '',
      description: '',
      number: ''
    }
  });
  _.extend(SpeedDials.Model.prototype, FreedomHelpers.ModelMixin);

  SpeedDials.Collection = ServerModels.Collection.extend({
    apiClassType:SpeedDials.apiClassType,
    model: SpeedDials.Model,
    comparator: 'name'
  });
  _.extend(SpeedDials.Collection.prototype, FreedomHelpers.CollectionMixin);

  return SpeedDials;
});

define('models/server/agentsPresence',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage',
  'models/server/channels'
],
/*
 * This provides a complete list of all agents' status
 * used in the Address Book
 */
function(_, ServerModels, FreedomHelpers, ModelStorage, Channels) {
  var Presences = {
    apiClassType: 'agent_states',
    resourceId: ModelStorage.Resources.AgentsReadyPresences2,
    // maybe it is better to hold this enum up-to-date in models/server/channels ?
    interactionTypes: {
      CALL: 'CALL',
      VOICE_MAIL: 'VOICE_MAIL',
      EMAIL: 'EMAIL',
      SOCIAL: 'SOCIAL',
      CHAT: 'CHAT'
    },
    presenceTypes: {
      READY: 'READY',
      NOT_READY: 'NOT_READY',
      LOGGED_OUT: 'LOGGED_OUT'
    },
    Reasons: {
      Supervisor: 'SUPERVISOR',
      AutoNotReady: 'AUTO_NOT_READY',
      HookStateError: 'HOOK_STATE_ERROR',
      NoStation: 'NO_STATION',
      Agent: 'AGENT',
      Initial: 'INITIAL',
      PermissionRemoved: 'PERMISSION_REMOVED',
      ReasonCodeDisabled: 'REASON_CODE_DISABLED',
      AfterCallWorkTimeExpired: 'AFTER_CALL_WORK_TIME_EXPIRED',
      PreviewEndNotReady: 'PREVIEW_END_NOT_READY',
      TaskCompletion: 'TASK_COMPLETION',
      InteractionNotAnswered: 'INTERACTION_NOT_ANSWERED',
      CallFinished: 'CALL_FINISHED'
    }
  };

  var defaultLogoutReadyStatuses = {
      "VOICE_MAIL": "LOGGED_OUT",
      "EMAIL": "LOGGED_OUT",
      "SOCIAL": "LOGGED_OUT",
      "CHAT": "LOGGED_OUT",
      "CALL": "LOGGED_OUT"
  };

  var defaultNotReadyStatuses = {
      "VOICE_MAIL": "NOT_READY",
      "EMAIL": "NOT_READY",
      "SOCIAL": "NOT_READY",
      "CHAT": "NOT_READY",
      "CALL": "NOT_READY"
  };

  var letterChannelMapping = {
      "v": "VOICE_MAIL",
      "e": "EMAIL",
      "s": "SOCIAL",
      "h": "CHAT",
      "c": "CALL"
  };

  /**
   * @class AgentsPresence
   * @extends ServerModels
   * {@link {@substitute apiBaseUrl}#!/orgs/getAgentPresences Freedom Api getAgentPresences}
   */
  Presences.Model = ServerModels.Model.extend({
    apiClassType:Presences.apiClassType,

    defaults: {
      readyStatuses: []
    },

    // Parse payload to old format:
    // Use single letter for ready channel.
    //   c-for CALL, v-VOICE_MAIL, s-SOCIAL, h-CHAT, e-EMAIL. o-letter reserved for logged out agent.
    //   “empty string” means agent is logged in but ready for nothing.
    //
    // Example:    //  {
    //      "100": “o”,
    //      "194": ”cv”
    //  }
    // We have to bring it to old format for back compatibility
    //  {
    //      "100": {
    //      "readyStatuses": {
    //          "VOICE_MAIL": "LOGGED_OUT",
    //                  "EMAIL": "LOGGED_OUT",
    //                  "SOCIAL": "LOGGED_OUT",
    //                  "CHAT": "LOGGED_OUT",
    //                  "CALL": "LOGGED_OUT"
    //      }
    //  },
    //      "194": {
    //      "readyStatuses": {
    //          "VOICE_MAIL": "READY",
    //                  "EMAIL": "NOT_READY",
    //                  "SOCIAL": "NOT_READY",
    //                  "CHAT": "NOT_READY",
    //                  "CALL": "READY"
    //      }
    //  }}
    parse: function (response) {
      var data = {};
      _.each(response, function(value, key) {
        if (value.length === 0) {
          // User logged in but in not ready state
          data[key] = {"readyStatuses":_.clone(defaultNotReadyStatuses)};
        } else if (value.indexOf('o') >= 0) {
          // User Logged out
          data[key] = {"readyStatuses":_.clone(defaultLogoutReadyStatuses)};
        } else {
          data[key] = {"readyStatuses":_.clone(defaultNotReadyStatuses)};
          for (var i = 0; i < value.length; i++) {
            var channel = letterChannelMapping[value.charAt(i)];
            if (channel) {
              data[key].readyStatuses[channel] = "READY";
            }
          }
        }
      });
      return {data:data};
    },

    isLoggedIn: function(agentId) {
      var agentIsLoggedIn = false;
      var agentPresence = this.get('data')[agentId];
      if (agentPresence && agentPresence.readyStatuses) {
        _.every(agentPresence.readyStatuses, function(readyStatus){
          if (readyStatus !== Presences.presenceTypes.LOGGED_OUT) {
            agentIsLoggedIn = true;
            return false;
          }
          return true;
        });
      }
      return agentIsLoggedIn;
    },

    isReadyForCall: function (agentId) {
      return this.isAgentReadyForChannel(agentId, Channels.Types.Call);
    },
    isReadyForVM: function(agentId) {
      return this.isAgentReadyForChannel(agentId, Channels.Types.Voicemail);
    },
    isReadyForEmail: function(agentId) {
      return this.isAgentReadyForChannel(agentId, Channels.Types.Email);
    },
    isReadyForChat: function(agentId) {
      return this.isAgentReadyForChannel(agentId, Channels.Types.Chat);
    },
    isReadyForSocial: function(agentId) {
      return this.isAgentReadyForChannel(agentId, Channels.Types.Social);
    },
    isReadyForText: function(agentId) {
      return this.isReadyForEmail(agentId) || this.isReadyForChat(agentId) || this.isReadyForSocial(agentId);
    },
    isReadyForAny: function(agentId) {
      return this.isReadyForCall(agentId) || this.isReadyForVM(agentId) || this.isReadyForText(agentId);
    },
    isAgentReadyForChannel: function(agentId, channel) {
      var agentPresence = this.get('data')[agentId];
      if (agentPresence && agentPresence.readyStatuses) {
        return agentPresence.readyStatuses[channel] === Presences.presenceTypes.READY;
      }
    }

  });
  _.extend(Presences.Model.prototype, FreedomHelpers.ModelMixin);

  return Presences;
});

define('models/server/logoutReasonCodes',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var LogoutReasonCodes = {
    apiClassType: 'logout_reason_codes',
    resourceId: ModelStorage.Resources.LogoutReasonCodes
  };

  /**
   * @class LogoutReasonCodes
   * @extends ServerModel
   * {@link {@substitute apiBaseUrl}#!/orgs/getLogoutReasonCodes Freedom Api getLogoutReasonCodes}}
   */
  LogoutReasonCodes.Model = ServerModels.Model.extend({
    apiClassType: LogoutReasonCodes.apiClassType,
    defaults: {}
  });
  _.extend(LogoutReasonCodes.Model.prototype, FreedomHelpers.ModelMixin);

  LogoutReasonCodes.Collection = ServerModels.Collection.extend({
    apiClassType: LogoutReasonCodes.apiClassType,
    model: LogoutReasonCodes.Model,
    comparator: function (s1, s2) {
      s1 = s1.get('name').toLowerCase();
      s2 = s2.get('name').toLowerCase();
      if (s1 < s2) return -1;
      if (s1 > s2) return 1;
      return 0;
    }
  });
  _.extend(LogoutReasonCodes.Collection.prototype, FreedomHelpers.CollectionMixin);

  return LogoutReasonCodes;
});

define('models/server/campaignDispositionInfo',[
    'underscore',
    'server.models.adapter',
    './freedom.helpers'
  ],
  function(_, ServerModels, FreedomHelpers) {
    var CampaignDispositions = {
      apiClassType: 'dispositions'
    };

    CampaignDispositions.Model = ServerModels.Model.extend({
      apiClassType:CampaignDispositions.apiClassType,
      defaults: {
        name: '',
        description: '',
        timeout: null,
        actions: [],
        channelTypes: [],
        flags: []
      }
    });
    _.extend(CampaignDispositions.Model.prototype, FreedomHelpers.ModelMixin);

    CampaignDispositions.Collection = ServerModels.Collection.extend({
      apiClassType:CampaignDispositions.apiClassType,
      model: CampaignDispositions.Model
    });
    _.extend(CampaignDispositions.Collection.prototype, FreedomHelpers.CollectionMixin);

    return CampaignDispositions;
  });

/* pako 0.2.5 nodeca/pako */!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define('pako',[],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.pako=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){



var zlib_inflate = _dereq_('./zlib/inflate.js');
var utils = _dereq_('./utils/common');
var strings = _dereq_('./utils/strings');
var c = _dereq_('./zlib/constants');
var msg = _dereq_('./zlib/messages');
var zstream = _dereq_('./zlib/zstream');
var gzheader = _dereq_('./zlib/gzheader');


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
var Inflate = function(options) {

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new gzheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
};

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That flush internal pending buffers and call
 * [[Inflate#onEnd]].
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && _mode === c.Z_FINISH)) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
  } while ((strm.avail_in > 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }
  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell inflate that input stream complete
 * or error happenned. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function(status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":2,"./utils/strings":3,"./zlib/constants":5,"./zlib/gzheader":7,"./zlib/inflate.js":9,"./zlib/messages":11,"./zlib/zstream":12}],2:[function(_dereq_,module,exports){



var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof(source) !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs+len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for(var i=0; i<len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i=0, l=chunks.length; i<l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i=0, l=chunks.length; i<l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for(var i=0; i<len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);
},{}],3:[function(_dereq_,module,exports){
// String encode/decode helpers



var utils = _dereq_('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [0]); } catch(__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch(__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var i=0; i<256; i++) {
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
}
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
      c2 = str.charCodeAt(m_pos+1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i=0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
      c2 = str.charCodeAt(m_pos+1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for(var i=0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function(buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function(str) {
  var buf = new utils.Buf8(str.length);
  for(var i=0, len=buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len*2);

  for (out=0, i=0; i<len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function(buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max-1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":2}],4:[function(_dereq_,module,exports){


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0
    , s2 = ((adler >>> 16) & 0xffff) |0
    , n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;
},{}],5:[function(_dereq_,module,exports){
module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
},{}],6:[function(_dereq_,module,exports){


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for(var n =0; n < 256; n++){
    c = n;
    for(var k =0; k < 8; k++){
      c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable
    , end = pos + len;

  crc = crc ^ (-1);

  for (var i = pos; i < end; i++ ) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;
},{}],7:[function(_dereq_,module,exports){



function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;
},{}],8:[function(_dereq_,module,exports){


// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  var window;                 /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],9:[function(_dereq_,module,exports){



var utils = _dereq_('../utils/common');
var adler32 = _dereq_('./adler32');
var crc32   = _dereq_('./crc32');
var inflate_fast = _dereq_('./inffast');
var inflate_table = _dereq_('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function ZSWAP32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, {bits: 9});

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, {bits: 5});

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window,src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window,src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window,src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = ZSWAP32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = {bits: state.lenbits};
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = {bits: state.lenbits};
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = {bits: state.distbits};
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) -1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) -1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too
        if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}


exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/
},{"../utils/common":2,"./adler32":4,"./crc32":6,"./inffast":8,"./inftrees":10}],10:[function(_dereq_,module,exports){



var utils = _dereq_('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
      base = extra = work;    /* dummy value--not used */
      end = 19;
  } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
  } else {                    /* DISTS */
      base = dbase;
      extra = dext;
      end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  var i=0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":2}],11:[function(_dereq_,module,exports){


module.exports = {
  '2':    'need dictionary',     /* Z_NEED_DICT       2  */
  '1':    'stream end',          /* Z_STREAM_END      1  */
  '0':    '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};
},{}],12:[function(_dereq_,module,exports){



function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;
},{}]},{},[1])
(1)
});
define('models/server/script',[
    'underscore',
    'server.models.adapter',
    './freedom.helpers',
    'pako',
    'dataAdapter-api'
  ],
  function(_, ServerModels, FreedomHelpers, pako, API) {
    var CHUNK_SIZE = 0x8000;

    var Script = {
      apiClassType: 'script'
    };

    Script.Model = ServerModels.Model.extend({
      binaryData: true,
      apiClassType: Script.apiClassType,
      defaults: {
        script: null
      },

      disableBatch: true,

      parse: function(response) {
        var decodedString = null;

        if (response.byteLength > 0) {
          var data = new Uint8Array(response);
          var result = pako.inflate(data);
          var encodedString = '';
          var index = 0;
          while (index < result.length) {
            encodedString += String.fromCharCode.apply(null, result.subarray(index, Math.min(index + CHUNK_SIZE, result.length)));
            index += CHUNK_SIZE;
          }
          decodedString = decodeURIComponent(escape(encodedString));
          // Check if decoded string is empty or has only BOM symbols (0xEF, 0xBB, 0xBF)
          if (decodedString.length === 0 || decodedString === '\ufeff') {
            decodedString = null;
          }
        }

        return {'script': decodedString};
      },
      sync: function(method, model, options){
        return API.xhrBinaryDownload(_.result(this, 'url'), 'GET', null, options);
      },

      fetch: function(options) {
        var opt = options || {};
        opt.disableBatch = true;
        return ServerModels.Model.prototype.fetch.call(this, opt);
      }
    });
    _.extend(Script.Model.prototype, FreedomHelpers.ModelMixin);

    return Script;
  });

define('models/server/worksheetQuestions',[
    'underscore',
    'server.models.adapter',
    'server.models.storage',
    './freedom.helpers'

  ],
  function(_, ServerModels, ModelStorage, FreedomHelpers) {
    var WorksheetQuestions = {
      apiClassType: 'worksheet_questions',
      resourceId: ModelStorage.Resources.WorksheetQuestions
    };

    WorksheetQuestions.Model = ServerModels.Model.extend({
      apiClassType: WorksheetQuestions.apiClassType,
      defaults: {
        id: '',
        name: '',
        description: '',
        dataType: 'NONE',
        viewType: 'NONE',
        dataRestrictions: [],
        answerCriteria: [],
        finishAllowed: false,
        fieldRestrictions: [],
        contactLookupResult: [],
        fieldType: 'NONE'
      },

      initialize: function(options) {
        options = options || {};
      }

    });
    _.extend(WorksheetQuestions.Model.prototype, FreedomHelpers.ModelMixin);

    WorksheetQuestions.Collection = ServerModels.Collection.extend({
      apiClassType: WorksheetQuestions.apiClassType,
      model: WorksheetQuestions.Model,

      parse: function(response) {
        if (response.items) {
          response = response.items;
        }
        return response;
      }

    });
    _.extend(WorksheetQuestions.Collection.prototype, FreedomHelpers.CollectionMixin);

    return WorksheetQuestions;
  });

define('models/server/campaigns',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage',
  'models/server/campaignDispositionInfo',
  'models/server/script',
  'models/server/worksheetQuestions'
],
function(_, ServerModels, FreedomHelpers, ModelStorage, DispositionInfo, Script, WorksheetQuestions) {
  var Campaigns = {
    apiClassType: 'campaigns',
    resourceId: ModelStorage.Resources.Campaigns,
    Types: {
      None: 'NONE',
      Inbound: 'INBOUND',
      Outbound: 'OUTBOUND',
      Autodial: 'AUTODIAL'
    },
    State: {
      NotRunning: 'NOT_RUNNING',
      Running: 'RUNNING',
      Stopping: 'STOPPING',
      Starting: 'STARTING',
      Resetting: 'RESETTING'
    }
  };

  /**
   * @class Campaigns
   * @extends ServerModel
   * @classdesc
   * <pre>
   *   {@link {@substitute apiBaseUrl}#!/orgs/getCampaigns Freedom Api getCampaigns}
   * </pre>
   */
  Campaigns.Model = ServerModels.Model.extend({
    apiClassType: Campaigns.apiClassType,
    defaults: {
      name: '',
      campaignType: Campaigns.Types.None,
      state: Campaigns.State.NotRunning,
      assistances: [],
      skillIds: [],
      previewAutoEngage: 0,
      autoEngageMessage: '',
      previewAutoAccept: 0
    },

    /**
     * @memberof Campaigns
     * @returns {DispositionInfo}
     */
    DispositionInfo: function() {
      return ModelStorage.get(this.path(), DispositionInfo);
    },

    /**
     * @memberof Campaigns
     * @returns {Script}
     */
    Script: function() {
      return ModelStorage.get(this.path(), Script);
    },

    /**
     * @memberof Campaigns
     * @returns {WorksheetQuestions}
     */
    WorksheetQuestions: function() {
      return ModelStorage.get(this.path(), WorksheetQuestions);
    },

    hasAssistances: function() {
      if (this.getAssistances()) {
        return this.getAssistances().length > 0;
      }
      return false;
    },
    getAssistances: function() {
      var tenant = Five9.Context.Tenant;
      var assistances = tenant.Assistances();
      var campaignAssistances = this.get('assistances');
      return _.map(campaignAssistances, function(id) {
        return assistances.get(id);
      });
    }
  });
  _.extend(Campaigns.Model.prototype, FreedomHelpers.ModelMixin);


  Campaigns.Collection = ServerModels.Collection.extend({
    apiClassType: Campaigns.apiClassType,

    model: Campaigns.Model,

    comparator: function(item) {
      return [item.get('name').toLowerCase()];
    }
  });
  _.extend(Campaigns.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Campaigns;
});

define('models/server/callVariables',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'server.models.storage'
],
function(_, ServerModels, FreedomHelpers, ModelStorage) {
  var CallVariables = {
    apiClassType: 'call_variables',
    resourceId: ModelStorage.Resources.CallVariable,
    DataTypes: {
      Boolean:      'BOOLEAN',
      Currency:     'CURRENCY',
      Date:         'DATE',
      DateTime:     'DATE_TIME',
      Email:        'EMAIL',
      Number:       'NUMBER',
      Percent:      'PERCENT',
      Phone:        'PHONE',
      String:       'STRING',
      Time:         'TIME',
      TimePeriod:   'TIME_PERIOD',
      Url:          'URL',
      Undefined:    'UNDEFINED'
    }
  };

  // models / collections
  CallVariables.Model = ServerModels.Model.extend({
    apiClassType:CallVariables.apiClassType,

    defaults: {
      name: '',
      type: CallVariables.DataTypes.Undefined,    // dataType == db representation (STRING, DATETIME)
      restrictions: {}
    }
  });
  _.extend(CallVariables.Model.prototype, FreedomHelpers.ModelMixin);

  CallVariables.Collection = ServerModels.Collection.extend({
    apiClassType:CallVariables.apiClassType,
    model: CallVariables.Model
  });
  _.extend(CallVariables.Collection.prototype, FreedomHelpers.CollectionMixin);

  return CallVariables;
});

define('models/server/passwordPolicies',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers){
  var PasswordPolicies = {
    apiClassType: 'password_policies'
  };

  /**
   * @class PasswordPolicies
   * @extends ServerModel
   * {@link {@substitute apiBaseUrl}#!/orgs/getPasswordPolicies Freedom Api getPasswordPolicies}
   */
  PasswordPolicies.Model = ServerModels.Model.extend({
    apiClassType: PasswordPolicies.apiClassType
  });

  _.extend(PasswordPolicies.Model.prototype, FreedomHelpers.ModelMixin);

  return PasswordPolicies;
});

define('models/server/noneCampaignDispositionInfo',[
    'underscore',
    'server.models.adapter',
    './freedom.helpers'
  ],
  function(_, ServerModels, FreedomHelpers) {
    var NoneCampaignDispositions = {
      apiClassType: 'no_campaign_dispositions'
    };

    NoneCampaignDispositions.Model = ServerModels.Model.extend({
      apiClassType:NoneCampaignDispositions.apiClassType,
      defaults: {
        name: '',
        description: '',
        timeout: null,
        actions: [],
        channelTypes: [],
        flags: []
      }
    });
    _.extend(NoneCampaignDispositions.Model.prototype, FreedomHelpers.ModelMixin);

    NoneCampaignDispositions.Collection = ServerModels.Collection.extend({
      apiClassType:NoneCampaignDispositions.apiClassType,
      model: NoneCampaignDispositions.Model
    });
    _.extend(NoneCampaignDispositions.Collection.prototype, FreedomHelpers.CollectionMixin);

    return NoneCampaignDispositions;
  });

define('models/server/assistances',[
  'server.models.adapter',
  './freedom.helpers',
  'underscore',
  'utils'
],
function(ServerModels, FreedomHelpers, _, Utils) {
  var Assistances = {
    apiClassType: 'assistances'
  };

  Assistances.Model = ServerModels.Model.extend({
    apiClassType: Assistances.apiClassType,

    defaults: {
      id:           '-1',
      name:         '',
      response:     ''
    },

    initialize: function() {
    },

    parse: function(response) {
      response.name = response.value;
      response.hasLink = false;
      var description = response.response;
      if (_.isString(description)) {
        if (Utils.hasLink(description)) {
          response.hasLink = true;
        }
      }

      if (!_.isString(response.id)) {
        Utils.reportIncorrectFormat('assistances', 'id', response.id);
        response.id = response.id.toString();
      }
      if (!_.isString(response.profileId)) {
        Utils.reportIncorrectFormat('assistances', 'profileId', response.profileId);
        response.profileId = response.profileId.toString();
      }

      delete response.value;
      return response;
    }
  });
  _.extend(Assistances.Model.prototype, FreedomHelpers.ModelMixin);

  Assistances.Collection = ServerModels.Collection.extend({
    apiClassType: Assistances.apiClassType,

    model: Assistances.Model,

    comparator: function(item) {
      return item.get('name');
    }
  });
  _.extend(Assistances.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Assistances;
});

define('models/server/values',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var Values = {
    apiClassType: 'values'
  };

  Values.Model = ServerModels.Model.extend({

    apiClassType: Values.apiClassType,

    defaults: {
      id:       -1,
      name:     ''
    },

    initialize: function() {
    },

    parse: function(response) {
      response.id = response.valueId;

      delete response.valueId;
      return response;
    }
  });
  _.extend(Values.Model.prototype, FreedomHelpers.ModelMixin);

  Values.Collection = ServerModels.Collection.extend({
    apiClassType: Values.apiClassType,

    model: Values.Model,

    initialize: function() {},

    comparator: function(item) {
      return [item.get('name')];
    }
  });
  _.extend(Values.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Values;
});

define('models/server/attributes',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'models/server/values'
],
function(_, ServerModels, FreedomHelpers, Values) {
  var Attributes = {
    apiClassType: 'attributes'
  };

  Attributes.Model = ServerModels.Model.extend({
    apiClassType: Attributes.apiClassType,

    defaults: {
      id:       '-1',
      name:     '',
      values:   null
    },

    initialize: function() {
    },

    parse: function(response) {
      response.values = new Values.Collection(response.values, { parse: true });

      return response;
    }
  });
  _.extend(Attributes.Model.prototype, FreedomHelpers.ModelMixin);

  Attributes.Collection = ServerModels.Collection.extend({
    apiClassType: Attributes.apiClassType,

    model: Attributes.Model,

    initialize: function(options) {
    },

    comparator: function(item) {
      return [item.get('name')];
    }

    // getArray: function() {
    //   var tmp = [];

    //   this.forEach(function (attribute) {
    //     tmp.push({id: value.id, name: value.name, values: attribute.getArray()});
    //   }

    //   return tmp;
    // }
  });
  _.extend(Attributes.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Attributes;
});



define('models/server/clusters',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'utils'
],
function(_, ServerModels, FreedomHelpers, Utils) {
  var Clusters = {
    apiClassType: 'clusters'
  };

  Clusters.Model = ServerModels.Model.extend({
    apiClassType: Clusters.apiClassType,

    defaults: {
      id:     '-1',
      name:   ''
    },

    initialize: function() {
    },

    parse: function(response) {
      if (!_.isString(response.id)) {
        Utils.reportIncorrectFormat('clusters', 'id', response.id);
        response.id = response.id.toString();
      }

      delete response.tenantId;
      delete response.tag;
      delete response.classification;
      delete response.creationTime;
      delete response.deletionTime;
      delete response.modificationTime;
      delete response.catchAll;
      delete response.sfId;
      delete response.sfClusterNr;

      return response;
    }
  });
  _.extend(Clusters.Model.prototype, FreedomHelpers.ModelMixin);

  Clusters.Collection = ServerModels.Collection.extend({
    apiClassType: Clusters.apiClassType,

    model: Clusters.Model,

    initialize: function(options) {
    },

    comparator: function(item) {
      return [item.get('name').toLowerCase()];
    },

    getCluster: function(clusterId) {
      var cluster = Five9.Context.Tenant.Cluster(clusterId);
      if (cluster && clusterId !== '-1') {
        return cluster;
      }
      return new Clusters.Model({id: '-1', name: 'None'}, { parse: true });
    }
  });
  _.extend(Clusters.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Clusters;
});

define('models/server/medias',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'utils'
],
function(_, ServerModels, FreedomHelpers, Utils) {
  var Medias = {
    apiClassType: 'medias'
  };

  var mediasInAuthor = [ 'twitter', 'facebook', 'linkedin', 'youtube','yahoo','googleplus', 'flickr', 'blogger', 'myspace', 'tumblr', 'telligent status', 'telligent blog', 'telligent forum', 'telligent wiki' ];

  Medias.Model = ServerModels.Model.extend({
    apiClassType: Medias.apiClassType,

    defaults: {
      id: '',
      type: '',
      name: '',
      icon: '',
      showInAuthor: true,
      isActive: false,
      maxPostChar: '',
      outbound: '',
      messageDisplay: '',
      replyDisplay: ''
    },

    initialize: function() {
    },

    parse: function(response) {
      response.name = response.type;
      response.type = Utils.isValid(response.type, '').toLowerCase();
      response.maxPostChar = parseInt(Utils.isValid(response.maxPostChar, '140'), 10);
      response.outbound = (parseInt(Utils.isValid(response.outbound, '0'), 10) == 1);
      response.messageDisplay = Utils.isValid(response.messageDisplay, null);
      response.replyDisplay = Utils.isValid(response.replyDisplay, null);

      response.showInAuthor = (mediasInAuthor.indexOf(response.type) > -1);

      if (!_.isString(response.id)) {
        Utils.reportIncorrectFormat('medias', 'id', response.id);
      }
      return response;
    },

    getIcon: function() {
      return './images/media/' + this.get('icon');
    },

    getSourceIcon: function() {
      return './images/sources/' + this.get('icon');
    },

    isFacebook: function() {
      return (this.get('type').indexOf('facebook') === 0);
    },

    isTwitter: function() {
      return (this.get('type').indexOf('twitter') === 0);
    },

    isTelligent: function() {
      return (this.get('type').indexOf('telligent') === 0);
    },

    isNote: function() {
      return ('note' == this.get('type'));
    },

    isPhone: function() {
      return (this.get('type').indexOf('phone') === 0);
    },

    isVoicemail: function() {
      return (this.get('type').indexOf('voicemail') === 0);
    },

    canGetRelation: function() {
      return (this.isFacebook() || this.isTwitter());
    },

    canUpdateAccount: function(_s) {
      return (this.isFacebook() || this.isTwitter());
    },

    canSubmit: function() {
      return (this.isFacebook() || this.isTwitter() || this.isTelligent());
    }

  });
  _.extend(Medias.Model.prototype, FreedomHelpers.ModelMixin);

  Medias.Collection = ServerModels.Collection.extend({
    apiClassType: Medias.apiClassType,

    model: Medias.Model,

    initialize: function(options) {
      /*
       * Add the default media to the set
       */
      this.add({id: '-1', type: 'other', icon: 'unknown.png', url: null, showInAuthor: false, isActive: false, maxPostChar: 140, outbound: 0, messageDisplay: null, replyDisplay: null}, {parse: true});
    },

    comparator: function(item) {
      return [item.get('name')];
    },

    mediasForAuthor: function() {
      return this.where({showInAuthor: true});
    },

    getMediasForAuthor: function(mediaType) {
      var filtered = this.filter(function(model) {
        return (model.get('showInAuthor'));
      });

      var collection = new Medias.Collection();
      collection.reset(filtered);

      return collection;
    },

    search: function(_type) {
      if (_type === null) {
        return this.where({id: '-1'});
      }

      var lvType = _type.toLowerCase();

      var media = this.findWhere({type: lvType});
      if (media) {
        return media;
      }

      /*
       * No match on the type, search to see if it is located starting at position 0 (search for 'facebook' and we have 'facebook telligent')
       */

      var lvMedias = this.models;
      for (var i=0; i<lvMedias.length; i++) {
        if (lvType.indexOf(lvMedias[i].get('type')) === 0) {
          return lvMedias[i];
        }
      }

      return this.where({id: '-1'})[0];
    }
  });
  _.extend(Medias.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Medias;
});

define('models/server/nextBestActions',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var NextBestActions = {
    apiClassType: 'nextbestactions'
  };

  NextBestActions.Model = ServerModels.Model.extend({
    apiClassType: NextBestActions.apiClassType,

    defaults: {
      action: ''
    },

    initialize: function() {
    }
  });
  _.extend(NextBestActions.Model.prototype, FreedomHelpers.ModelMixin);

  NextBestActions.Collection = ServerModels.Collection.extend({
    apiClassType: NextBestActions.apiClassType,

    model: NextBestActions.Model,

    initialize: function(options) {
    },

    comparator: function(item) {
      return [item.get('action')];
    }
  });
  _.extend(NextBestActions.Collection.prototype, FreedomHelpers.CollectionMixin);

  return NextBestActions;
});

define('models/server/rules',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers'
],
function(_, ServerModels, FreedomHelpers) {
  var Rules = {
    apiClassType: 'rules'
  };

  Rules.Model = ServerModels.Model.extend({
    apiClassType: Rules.apiClassType,

    defaults: {
      tag:          '',
      priority:     1
    },

    initialize: function(data) {
      this.tag = data.tag;
      this.priority = data.priority;
    },

    parse: function() {

    }
  });
  _.extend(Rules.Model.prototype, FreedomHelpers.ModelMixin);

  Rules.Collection = ServerModels.Collection.extend({
    apiClassType: Rules.apiClassType,

    model: Rules.Model,

    initialize: function(options) {
    },

    comparator: function(item) {
      return [item.get('priority')];
    }
  });
  _.extend(Rules.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Rules;
});

define('models/server/items',[
  'underscore',
  'server.models.adapter',
  './freedom.helpers',
  'utils',
  'models/server/medias',
  'models/server/attributes',
  'models/server/authors',
  'models/server/customFields',
  'models/server/nextBestActions',
  'models/server/rules',
  'models/server/replies',
  'models/server/clusters',
  'models/server/chatMessages',
  'presentation.models.utils/altocloud.utils'
],
function(_, ServerModels, FreedomHelpers, Utils, Medias, Attributes, Authors, CustomFields, NextBestAction, Rules, Replies, Clusters, ChatMessages, AltocloudUtils) {
  var Items = {
    apiClassType: 'interactions',

    MediaTypes: {
      SOCIAL:                 1,
      NOTE:                   100,
      CHAT:                   1000,
      AGENT_CHAT:             1010,
      EMAIL:                  2000
    }
  };

  var queuedIterator = function(mediaType, model) {
    return ((model.get('mediaType') ===  mediaType) && !model.isLock());
  };

  Items.Model = ServerModels.Model.extend({
    apiClassType: Items.apiClassType,

    defaults: {
      assignedTime:           -1,
      attachments:            null,
      attribs:                null,
      authorId:               -1,
      lockInProgress:       false,
      chatMessages:           null,
      clusterId:              '-1',
      contact:                null,
      conversationTopic:      '',
      conversationTopicData:  '',
      chatCustomFields:       null,
      data:                   '',
      datePublished:          -1,
      description:            '',
      dispositionId:          '-1',
      iconURL:                '',
      id:                     '',
      itemId:                 '',
      groupId:                '-1',
      lang:                   '',
      likeCount:              0,
      linkCaption:            '',
      linkURL:                '',
      lockByName:             '',
      mediaType:              -1,
      nextBestAction:         null,
      parentId:               '',
      persona:                '',
      pictureURL:             '',
      place:                  '',
      profileId:              '-1',
      relevancy:              0,
      replied:                false,
      replies:                null,
      respondedDate:          -1,
      rules:                  null,
      sentiment:              '',
      shortDescription:       '',
      source:                 '',
      spam:                   0,
      startTime:              '',
      telligentId:            '',
      telligentKnowledge:     '',
      title:                  '',
      topicThread:            '',
      topicId:                '',
      url:                    '',
      videoURL:               '',
      workedById:             '-1',
      wasResponded:           false,
      chatTerminated:         false,
      userIds:                [],
      ownerId:                '-1',
      previewChat:            false,
      previewEngaged:         false,
      visitId:                null,
      journeyLink:            null,
      engageMessage:          ''
    },

    parse: function(response) {
      try {
        if (response.mediaType === Items.MediaTypes.CHAT) {
          console.log('Parsing chat', response);
        }

        response.attachments = [];
        response.assignedTime = parseInt(response.assignedTime, 10);
        response.conversationTopic = Utils.isValid(response.conversationName, '');
        response.conversationTopicData = Utils.isValid(response.conversationWordCloud, null);
        response.publishedDate = parseInt(response.datePublished, 10);
        response.description = Utils.isValid(response.description, null);
        response.iconURL = Utils.isValid(response.iconUrl, null);
        response.likeCount = Utils.isValid(response.likeCount, 0);
        response.linkCaption =  Utils.isValid(response.linkCaption, null);
        response.linkURL = Utils.isValid(response.linkURL, null);
        response.parentId = Utils.isValid(response.parentId, null);
        response.pictureURL = Utils.isValid(response.pictureURL, null);
        response.place = Utils.isValid(response.place, null);
        response.respondedDate = parseInt(Utils.isValid(response.respondedDate, '-1'), 10);
        response.source = Utils.isValid(response.Source, null);
        response.startTime = parseInt(response.startTime, 10);
        response.telligentId = Utils.isValid(response.telligentId, '-1');
        response.telligentKnowledge = Utils.isValid(response.telligentKnowledge, null);
        response.url = (_.isUndefined(response.url)) ? '' : response.url;
        response.title = (Utils.isValid(response.title, null) === null) ? response.url : response.title;
        response.topicThread = Utils.isValid(response.topic, null);
        response.topicThreadId = Utils.isValid(response.topicThreadId, '-1');
        response.videoURL = Utils.isValid(response.videoURL, null);
        response.unreadMessages = 0;
        response.wasResponded = (parseInt(response.wasResponded, 10) == 1);
        response.chatTerminated = (parseInt(response.chatTerminated, 10) == 1);
        response.userIds = Utils.safeJSONParse(Utils.isValid(response.userIds, '[]'), []);
        response.ownerId = response.workedById;
        response.attribs = Utils.isValid(response.attributes, []);
        response.chatCustomFields = new CustomFields.Collection(response.chatCustomFields, { parse: true });
        response.nextBestAction = new NextBestAction.Collection(Utils.isValid(response.NBAList, {}), { parse: true });
        response.replies = new Replies.Collection(response.replies, { parse: true });
        response.rules = new Rules.Collection(response.rules, { parse: true });
        response.cc = '';
        response.relevancy = parseFloat(response.relevancy, 10);
        response.sentiment = parseFloat(response.sentiment, 10);
        response.spam = parseFloat(response.spam, 10);

        /**
         * Add the author to the collection of authors
         */
         var authors = Five9.Context.Tenant.Authors();
        authors.push(new Authors.Model(response.author, { parse: true }));
        response.authorId = (response.author) ? response.author.authorId : '-1';
        if (!response.authorId) {
          console.warn(Utils.formatString('SCC_DEBUG: Unable to find author[{0}] for item[{1}]', response.authorId, response.id));
        }

        var author = authors.get(response.authorId);
        if (response.mediaType == Items.MediaTypes.CHAT || response.mediaType == Items.MediaTypes.EMAIL) {
          if (author) {
            var sType = _.invert(Items.MediaTypes)[response.mediaType];
            console.info(Utils.formatString('SCC_DEBUG: {0} [{1}] email[{2}]', sType, response.id, author.get('email')));
          }
          else {
            console.error(Utils.formatString('SCC_DEBUG: No author[{0}] for item[{1}]', response.authorId, response.id));
          }
        }
        delete response.author;

        if (!_.isString(response.workedById)) {
          Utils.reportIncorrectFormat('items', 'workedById', response.workedById);
          response.workedById = response.workedById.toString();
          response.ownerId = response.workedById;
        }
        if (_.isArray(response.userIds)) {
          _.each(response.userIds, function(userId) {
            if (!_.isString(userId)) {
              Utils.reportIncorrectFormat('items', 'userId', userId);
            }
          });
        }
        if (response.profileId && response.profileId !== '0' && !Five9.Context.Tenant.Campaigns().get(response.profileId)) {
          console.warn(Utils.formatString('SCC_DEBUG: Unable to find campaign[{0}] for item[{1}]', response.profileId, response.id));
        }
        if (response.groupId && response.groupId !== '0' && !Five9.Context.Tenant.Skills().get(response.groupId)) {
          console.warn(Utils.formatString('SCC_DEBUG: Unable to find skill[{0}] for item[{1}]', response.groupId, response.id));
        }
        if (response.clusterId && response.clusterId !== '-1' && !Five9.Context.Tenant.Clusters().get(response.clusterId)) {
          console.warn(Utils.formatString('SCC_DEBUG: Unable to find cluster[{0}] for item[{1}]', response.clusterId, response.id));
        }

        switch(response.mediaType) {
          case 1:
            response.media = Five9.Context.Tenant.Medias().search(response.source);
            response.mediaTypeAsString = 'social';
            break;

          case 2:
            response.media = Five9.Context.Tenant.Medias().search('article');
            response.mediaTypeAsString = 'social';
            break;

          case 3:
            response.media = Five9.Context.Tenant.Medias().search('blogger');
            response.mediaTypeAsString = 'social';
            break;

          case 100:
            response.media = Five9.Context.Tenant.Medias().search('note');
            response.mediaTypeAsString = 'note';
            break;

          case 1000:
            response.media = Five9.Context.Tenant.Medias().search('chat');
            response.mediaTypeAsString = 'chat';
            break;

          case 1010:
            response.media = Five9.Context.Tenant.Medias().search('agentchat');
            response.mediaTypeAsString = 'agentchat';
            break;

          case 2000:
            response.media = Five9.Context.Tenant.Medias().search('email');
            response.mediaTypeAsString = 'email';
            if (response.ccAddresses !== undefined)
              response.cc = response.ccAddresses;
            else
              response.cc = '';
            break;

          default:
            response.media = Five9.Context.Tenant.Medias().search('');
            response.mediaTypeAsString = 'social';
            break;
        }

        response.shortDescription = '';

        var i = 0;
        var parsedData = null;
        if ((response.mediaType == Items.MediaTypes.CHAT) || (response.mediaType == Items.MediaTypes.AGENT_CHAT)) {

          if (_.isUndefined(response.data)) {
            parsedData = new ChatMessages.Collection();

            var messages = [];
            var jsonMessages = Utils.safeJSONParse(Utils.isValid(response.itemStartData, []), []);
            for (i=0; i<jsonMessages.length; i++) {
              jsonMessages[i].id = jsonMessages[i].id + '.' + (i + 1);

              messages.push(new ChatMessages.Model(jsonMessages[i], {parse: true, silent: true}));
            }

            parsedData.set(messages, {parse: false, silent: true});
          }
          else if (_.isArray(response.data)) {
            parsedData = new ChatMessages.Collection(response.data, {parse:true, silent:true});
          }


          var question = response.chatCustomFields.findWhere({key: 'Question'});
          if (question) {
            response.shortDescription = question.get('value');
          }
          else {
            response.shortDescription = 'Chat';
          }

          var browser = response.chatCustomFields.findWhere({key: 'f9-browser'});
          if (browser) {
            try {
              response.browser = JSON.parse(browser.get('value'));
            }
            catch(err) {}
          }
          var history = response.chatCustomFields.findWhere({key: 'f9-history'});
          if (history) {
            try {
              response.history = JSON.parse(history.get('value'));
            }
            catch(err) {}
          }

          response.previewChat = (response.previewChat === 1) ? true : false;
          response.previewEngaged = (response.previewEngaged === 1) ? true : false;

          var visitId = response.chatCustomFields.findWhere({key: AltocloudUtils.altoCloudId.visitId});
          if (visitId) {
            visitId = visitId.get('value');
            response.visitId = visitId;
            response.journeyLink = AltocloudUtils.generateCompositeGadgetByVisitIdUrl(visitId);
            console.info(Utils.formatString('Altocloud journey: [{0}] visitId[{1}] link[{2}]', response.id, visitId, response.journeyLink));
          }
          else {
            console.info(Utils.formatString('Altocloud: [{0}] no visitId', response.id));
          }
          var customerId = response.chatCustomFields.findWhere({key: AltocloudUtils.altoCloudId.customerId});
          if (customerId) {
            customerId = customerId.get('value');
            response.customerId = customerId;
            response.summaryLink = AltocloudUtils.generateSummaryUrl(customerId);
            console.info(Utils.formatString('Altocloud summary: [{0}] customerId[{1}] link[{2}]', response.id, customerId, response.cartLink));
            response.cartLink = AltocloudUtils.generateCartUrl(customerId);
            console.info(Utils.formatString('Altocloud cart: [{0}] customerId[{1}] link[{2}]', response.id, customerId, response.cartLink));
          }
          else {
            console.info(Utils.formatString('Altocloud: [{0}] no customerId', response.id));
          }
          var personaIds = response.chatCustomFields.findWhere({key: AltocloudUtils.PersonaKey});
          if (personaIds) {
            try {
              personaIds = JSON.parse(personaIds.get('value'));
            }
            catch (err) {}
            if (_.isArray(personaIds)) {
              response.persona = personaIds;
              for (i = 0; i < personaIds.length; i++) {
                var persona = Five9.Context.Agent.Personas.get(personaIds[i]);
                if (persona) {
                  console.info(Utils.formatString('Altocloud: [{0}] persona [{1}]', response.id, persona.get('displayName')));
                }
              }
            }
          }
          else {
            console.info(Utils.formatString('Altocloud: [{0}] no persona [{1}]', response.id, personaIds));
          }
        }
        else if (response.mediaType == Items.MediaTypes.EMAIL) {
          var itemStartData = Utils.safeJSONParse(Utils.isValid(response.itemStartData, []), []);

          for (i=0; i<itemStartData.length; i++) {
              switch (itemStartData[i].bodyType) {
              case 1: // Text
                response.shortDescription = Utils.linkify(itemStartData[i].textBodyPart.replace(/\n/g, '<br />'));
                parsedData = Utils.linkify(itemStartData[i].textBodyPart.replace(/\n/g, '<br />'));
                break;

              case 2: // HTML
                response.shortDescription = Utils.htmlToText(itemStartData[i].textBodyPart);
                parsedData = $('<div></div>').html(itemStartData[i].textBodyPart.replace(/\n/g, ''));
                parsedData.find('base').remove();
                parsedData = parsedData.html();
                break;

              case 3: // Binary
                /**
                 * Not handing this right now
                 */
                break;

              case 4: // Attachement
                response.attachments.push( { 'url': itemStartData[i].textBodyPart, 'name': itemStartData[i].filename, 'validFile': itemStartData[i].validFile } );
                break;
              }
          }

        } else {

          parsedData = Utils.isValid(response.itemStartData, '').replace(/(<([^>]+)>)/ig, '');
          parsedData = Utils.linkify(parsedData);
          parsedData = parsedData.replace('ORIGINAL POST:', '<br><br>ORIGINAL POST:');

          response.shortDescription = parsedData;
        }

        response.shortDescription = response.shortDescription.trim().substring(0, 80);

        if (_.isUndefined(response.data) || _.isArray(response.data)) {
          response.data = parsedData;
        }

        if (response.source === null) {
          response.source = 'default';
        }

        /*
         * Delete the unneeded fields
         */
        // delete response.chatTerminated;   // Now chatState
        delete response.itemStartData;    // Now data
        delete response.attributes;       // Now attribs
        delete response.datePublished;    // Now publishedDate
        delete response.topic;            // Now topicThread

        return response;
      }
      catch (err) {
        console.error('SCC_DEBUG: error parsing social item', err);
        return undefined;
      }
    },

    path: function(addSocial) {
      if (addSocial && addSocial === true)
        return ('agents/' + Five9.Context.AgentId + '/interactions/' + this.get('mediaTypeAsString') + '/' + this.id);
      else
        return ('agents/' + Five9.Context.AgentId + '/interactions/' + this.id);
    },

    getChannelType: function() {
      return this.get('mediaTypeAsString').toUpperCase();
    },

    missedMessage: function() {
      var unreadMessages = this.get('unreadMessages');
      unreadMessages++;
      this.set({'unreadMessages': unreadMessages});
    },
    hasUnreadMessages: function() {
      return (this.get('unreadMessages') > 0);
    },
    resetUnreadMessages: function() {
      this.set({'unreadMessages': 0});
    },

    canWorkOn: function() {
      if (this.isTerminated()) {
        return false;
      }

      if (this.isLock()) {
        if (this.isLockByMe() || this.inConferenceWithMe()) {
          return true;
        }

        return false;
      }

      return true;
    },

    isAltocloud: function() {
      return Utils.string_nonEmpty(this.get('journeyLink'));
    },

    isACD: function() {
      return (this.get('workedById') == '1');
    },
    isChat: function() {
      return (this.get('mediaType') == 1000);
    },
    isChatPreview: function() {
      return this.isChat() && this.get('previewChat');
    },
    isEngagedChatPreview: function() {
      return this.isChat() && this.get('previewChat') && this.get('previewEngaged');
    },
    isEmail: function() {
      return (this.get('mediaType') == 2000);
    },
    isSocial: function() {
      return ((this.get('mediaType') != 1000) && (this.get('mediaType') != 2000));
    },

    isChatTerminated: function() {
      return this.get('chatTerminated');
    },
    isTerminated: function() {
      return this.get('wasResponded');
    },
    unlockAllowed: function() {
      var isLocked = this.isLock();
      var chat = this.isChat();
      var email = this.isEmail();
      var social = this.isSocial();
      var hasReplies = this.hasReplies();

      if (chat) {
        return false;
      }
      if (email || social) {
        if (this.isClosedDisposition(this.get('dispositionId'))) {
          // Text channel filter is set since that is the only time an interaction
          // with a closed disposition will be displayed. Agent should not be allowed
          // to do anything with this interaction
          return false;
        }
        // disposition must be none or an open disposition
        return hasReplies && isLocked ? false : true;
      }
    },
    dispositionAllowed: function() {
      if (this.isChatPreview()) {
        if (!this.isEngagedChatPreview()) {
          return false;
        }
      }
      if (!this.isLockByMe()) {
        return false;
      }
      if (this.hasDisposition && this.isClosedDisposition(this.get('dispositionId'))) {
        return false;
      }
      else {
        return true;
      }
    },
    transferAllowed: function() {
      var chat = this.isChat();
      var email = this.isEmail();
      var social = this.isSocial();

      if (this.isConference()) {
        return false;
      }
      if (!this.isLockByMe()) {
        return false;
      }

      if (chat && this.isChatTerminated()) {
        return false;
      }
      if (chat && this.isChatPreview()) {
        if (!this.isEngagedChatPreview()) {
          return false;
        }
      }

      if (this.hasDisposition() && this.isClosedDisposition(this.get('dispositionId'))) {
        return false;
      }
      else {
        return true;
      }
    },
    videoAllowed: function() {
      var chat = this.isChat();

      if (!chat) {
        return false;
      }

      if (!this.isLockByMe()) {
        return false;
      }

      if (chat && this.isChatTerminated()) {
        return false;
      }

      if (chat && this.isChatPreview()) {
        if (!this.isEngagedChatPreview()) {
          return false;
        }
      }

      if (this.hasDisposition() && this.isClosedDisposition(this.get('dispositionId'))) {
        return false;
      }
      else {
        return true;
      }
    },
    responseAllowed: function() {
      if (!this.isLockByMe()) {
        return false;
      }

      // social and email
      return true;
    },
    forwardAllowed: function() {
      return this.responseAllowed();
    },
    isPreviewAutoAccept: function() {
      if (!this.isChatPreview()) {
        return false;
      }
      var campaign = this.getCampaign();
      if (campaign) {
        return campaign.get('previewAutoAccept') === 1;
      }
      return false;
    },
    isPreviewAutoEngage: function() {
      if (!this.isChatPreview()) {
        return false;
      }
      var campaign = this.getCampaign();
      if (campaign) {
        return campaign.get('previewAutoEngage') === 1;
      }
      return false;
    },
    isClosedDisposition: function(dispositionId) {
      var disposition = Five9.Context.Tenant.Dispositions().findWhere({id:dispositionId});
      if (disposition) {
        return disposition.isClose();
      }
      else {
        return false;
      }
    },
    hasDisposition: function() {
      return (Number(this.get('dispositionId')) > -1);
    },
    hasAttachments: function() {
      return (this.get('attachments') !== null);
    },

    hasReplies: function() {
      return (this.get('repliesList').length > 0) || this.get('replied');
    },
    hasVideoURL: function() {
      return (this.get('videoURL') !== null && this.get('videoURL').length > 10);
    },
    hasParent: function() {
      return (this.get('parentId') !== null);
    },
    hasPictureURL: function() {
      return (this.get('pictureURL') !== null && this.get('pictureURL').length > 10);
    },
    hasLinkURL: function() {
      return (this.get('linkURL') !== null && this.get('linkURL').length > 10);
    },

    hasTopicThread: function() {
      return (this.get('topicThreadId') != '-1');
    },

    getUserIds: function() {
      var userIds = this.get('userIds');
      return _.clone(userIds);
    },
    addUserIds: function(userIdsToAdd) {
      var userIds = _.clone(this.get('userIds'));
      for (var i = 0; i < userIdsToAdd.length; i++) {
        var userIdToAdd = userIdsToAdd[i];
        if (userIds.indexOf(userIdToAdd) === -1) {
          userIds.push(userIdToAdd);
        }
      }
      ChatMessages.validateUserIds(userIds, this.get('ownerId'));
      this.set('userIds', userIds);
    },
    removeUserIds: function(userIdsToRemove) {
      var userIds = _.clone(this.get('userIds'));
      for (var i = 0; i < userIdsToRemove.length; i++) {
        var userIdToRemove = userIdsToRemove[i];
        var index = userIds.indexOf(userIdToRemove);
        if (index > -1) {
          userIds.splice(index, 1);
        }
      }
      ChatMessages.validateUserIds(userIds, this.get('ownerId'));
      this.set('userIds', userIds);
    },
    validateUserIds: function() {
      var userIds = _.clone(this.get('userIds'));
      ChatMessages.validateUserIds(userIds, this.get('ownerId'));
      this.set('userIds', userIds);
    },
    debugUserIds: function() {
      if (this.has('ownerId') && !_.isString(this.get('ownerId'))) {
        this.set({'ownerId': this.get('ownerId').toString()}, {silent:true});
      }
      if (this.has('workedById') && !_.isString(this.get('workedById'))) {
        this.set({'workedById': this.get('workedById').toString()}, {silent:true});
      }

      var userIds = this.getUserIds();
      userIds.sort();

      var payload = {
        agentId: Five9.Context.AgentId,
        ownerId: this.get('ownerId'),
        userIds: userIds
      };
      console.log('SCC_DEBUG: ' + JSON.stringify(payload));
    },

    isConference: function() {
      return (this.get('userIds').length > 0);
    },
    inConferenceWithMe: function() {
      return (this.get('userIds').indexOf(Five9.Context.Agent.id) > -1);
    },

    isUnlock: function() {
      if (this.get('workedById') === '0') {
        return true;
      }
      return false;
    },
    isLock: function() {
      return !this.isUnlock();
    },
    isLockByMe: function() {
      if (this.isLock()) {
        return (this.get('workedById') == Five9.Context.AgentId);
      }
      return false;
    },

    isClose: function() {
      if (this.get('dispositionId')) {
        var disposition = Five9.Context.Tenant.Dispositions().get({id: this.get('dispositionId')});
        if (disposition) {
          return disposition.isClose();
        }
      }
      return false;
    },

    /***
     * TODO (Need to check if we need this one)
     */
    isOpen: function() {
      if (this.get('dispositionId') > -1) {
        var disposition = Five9.Context.Tenant.Dispositions().get({id: this.get('dispositionId')});
        if (disposition) {
          return !disposition.isClose();
        }
      }
      return true;
    },

    getAuthor: function() {
      return Five9.Context.Tenant.Authors().get(this.get('authorId'));
    },
    setAuthor: function(author) {
      if (author) {
        var authors = Five9.Context.Tenant.Authors();
        authors.remove(author.id);
        authors.push(author);
      }
      this.set('authorId', (author) ? author.id : '-1');
    },

    getAttributes: function() {
      return this.get('attribs');
    },

    getAttributeSize: function() {
      var attributes = this.getAttributes();

      var numberOfAttributes = 0;
      attributes.forEach(function(attribute) {
        if (attribute.valueId != '-1') {
          numberOfAttributes++;
        }
      });

      return numberOfAttributes;
    },

    getCampaign: function() {
      return Five9.Context.Tenant.Campaigns().get(this.get('profileId'));
    },
    getCampaingName: function() {
      if (this.get('profileId') !== '-1') {
        var campaign = Five9.Context.Tenant.Campaigns().get(this.get('profileId'));
        if (campaign && campaign.get('name')) {
          return campaign.get('name');
        }
      }
      return 'None';
    },

    getCluster: function() {
      if (this.get('clusterId') !== '-1') {
        var cluster = Five9.Context.Tenant.Cluster(this.get('clusterId'));
        if (cluster) {
          return cluster;
        }
      }
      return new Clusters.Model({id: '-1', name: 'None'}, { parse: true });
    },

    getDispositionName: function() {
      if (this.get('dispositionId') > -1) {
        var disposition = Five9.Context.Tenant.Disposition(this.get('dispositionId'));
        if (disposition && disposition.get('name')) {
          return disposition.get('name');
        }
      }
      return 'None';
    },

    getConversationTopic: function() {
      return this.get('conversationTopic');
    },

    getConversationTopicData: function() {
      return this.get('conversationTopicData');
    },

    getCustomFields: function() {
      return this.get('chatCustomFields');
    },

    getNextBestActions: function() {
      return this.get('nextBestAction');
    },

    getNumberOfReplies: function() {
      return this.getReplies().length;
    },

    getReplies: function() {
      return this.get('replies');
    },

    getRules: function() {
      return this.get('rules');
    },

    isLockInProgress: function() {
      return this.get("lockInProgress");
    },

    /***
     * Only for Cherry Picking
     */
    lock: function() {
      if (this.isUnlock() && this.collection && this.collection.canAccept(this.get('mediaType'))) {
        var payload = {
          profileId: this.get('profileId'),
          mediaType: this.get('mediaType'),
          type: 1
        };

        console.info('SCC_DEBUG: Send lock for id ' + this.get('id'), payload);
        this.set("lockInProgress", true);
        return this.performAction('accept', payload, undefined, undefined, undefined, undefined, {registerResponse:true}).
          always(_.bind(function() {
            this.set("lockInProgress", false);
          }, this));
      }
    },

    /***
     * Only for Cherry Picking
     */
    unlock: function() {
      if (this.isLockByMe()) {
        console.info('SCC_DEBUG: Send unlock for id ' + this.get('id'));
        this.set("lockInProgress", true);
        this.removeAgentId(Five9.Context.Agent.get('id'));
        return this.transferToGroup(this.get('groupId')).
          always(_.bind(function() {
            this.set("lockInProgress", false);
          }, this));
      }
    },

    // only for ACD
    accept: function() {
      if (this.isACD()) {
        this.stopOfferTimer();

        var payload = {
          profileId: this.get('profileId'),
          mediaType: this.get('mediaType'),
          type: 2
        };
        console.info('SCC_DEBUG: Send accept for id ' + this.get('id'), payload);
        return this.performAction('accept', payload, undefined, undefined, undefined, undefined, {registerResponse:true});
      }
    },
    reject: function(type) {
      if (this.isACD()) {
        console.info('SCC_DEBUG: Send reject for id ' + this.get('id'));
        this.stopOfferTimer();
        Five9.vent.trigger('scc:' + this.get('mediaTypeAsString') + ':acd:rejected', this);
        return this.performAction('reject', undefined, undefined, undefined, undefined, undefined, {registerResponse:true});
      }
    },

    // only for Preview
    acceptPreview: function() {
      if (this.isChatPreview()) {
        this.stopOfferTimer();

        var payload = {
          profileId: this.get('profileId'),
          mediaType: this.get('mediaType'),
          type: 2
        };
        console.info('SCC_DEBUG: Send accept for preview id ' + this.get('id'), payload);
        return this.performAction('accept_preview', payload, undefined, undefined, undefined, undefined, {registerResponse:true});
      }
      else {
        console.error('acceptPreview can only be used with preview chats');
      }
    },
    rejectPreview: function() {
      if (this.isChatPreview()) {
        console.info('SCC_DEBUG: Send reject for preview id ' + this.get('id'));
        this.stopOfferTimer();
        Five9.vent.trigger('scc:' + this.get('mediaTypeAsString') + ':preview:rejected', this);
        return this.performAction('reject_preview', undefined, undefined, undefined, undefined, undefined, {registerResponse:true});
      }
      else {
        console.error('rejectPreview can only be used with preview chats');
      }
    },
    engagePreview: function(message, engageTimeout) {
      if (this.isChatPreview() && this.isLockByMe() && !this.engageTimerId) {
        this.startEngageTimer(engageTimeout);

        var payload = {
          question: message
        };
        console.info('SCC_DEBUG: Send engage for id ' + this.get('id'), payload);
        return this.performAction('engage_preview', payload, undefined, undefined, undefined, undefined, {registerResponse:true});
      }
      else {
        console.error('engagePreview can only be used with locked preview chats');
      }
    },
    withdrawPreview: function() {
      if (this.isChatPreview() && this.isLockByMe() && !this.withdrawTimerId) {
        this.startWithdrawTimer();

        var payload = {
          question: '',
          yes: false
        };
        console.info('SCC_DEBUG: Send withdraw for id ' + this.get('id'), payload);
        return this.performAction('engage_preview', payload, undefined, undefined, undefined, undefined, {registerResponse:true});
      }
      else {
        console.error('withdrawPreview can only be used with locked preview chats');
      }
    },

    parents: function() {
      if (this.isLockByMe()) {
        return this.performAction('parents');
      }
    },

    history: function(history) {
      if (this.isLockByMe()) {
        history.authorName = this.getAuthor().get('name');
        console.log('Send history for id ' + this.get('id'), history);
        return this.performAction('history', history, undefined, undefined, undefined, undefined, undefined, true, {registerResponse:true});
      }
    },

    reply: function(reply) {
      if (this.isLockByMe()) {
        if (reply.authorName === undefined || reply.authorName === '') {
          reply.authorName = Five9.Context.Tenant.Authors().get(this.get('authorId')).get('name');
        }

        if (this.isSocial()) {
          reply.mediaType = this.get('media').get('id');
          reply.socialItemId = this.get('socialItemId');
          reply.url = this.get('url');
          reply.authorId = this.get('authorId');
          reply.parentId = this.get('parentId');
        }

        console.info('SCC_DEBUG: Send reply for id ' + this.get('id'), reply);
        return this.performAction('reply', reply, undefined, undefined, undefined, undefined, undefined, true, {registerResponse:true});
      }
    },

    addDraft: function(draft) {
      var deferred = new $.Deferred();

      var newDraft;

      if (Five9.Context.SocialDrafts) {
        newDraft = Five9.Context.SocialDrafts.add(draft);
      }

      this._saveDrafts().done(_.bind(function(){
        deferred.resolve(newDraft);
        this.trigger('add:draft');
      },this));

      return deferred;
    },
    deleteDraft: function() {
      var deferred = new $.Deferred();

      var deletedDraft;
      var draftToDelete = this.getDraft();

      if (draftToDelete) {
        deletedDraft = Five9.Context.SocialDrafts.remove(draftToDelete);

        this._saveDrafts().done(function(){
          deferred.resolve(deletedDraft);
        });
      } else {
        deferred.resolve(null);
      }

      return deferred;
    },
    getDraft: function() {
      var draft;

      if (Five9.Context.SocialDrafts) {
        draft = Five9.Context.SocialDrafts.findWhere({socialItemId:this.id});
      }
      return draft;
    },
    _saveDrafts: function() {
      var data = Five9.Context.SocialDrafts.toJSON();

      Five9.Settings.setValue('agent.social.drafts', data);
      return Five9.Settings.saveSettings();
    },
    _deleteAllDrafts: function() {
      Five9.Settings.setValue('agent.social.drafts', null);
      return Five9.Settings.saveSettings();
    },

    transferToAgent: function(agentId) {
      if (this.isLockByMe()) {
        var payload = {
          mediaType: this.get('mediaType'),
          agentId: agentId
        };

        console.info('SCC_DEBUG: Send transferToAgent for id ' + this.get('id'), payload);
        return this.performAction('transfer_to_agent', payload, undefined, undefined, undefined, undefined, {registerResponse:true});
      }
    },
    transferToGroup: function(groupId) {
      if (this.isLockByMe()) {
        var fields = {
          'workedById': '0',
          'lockByName': '',
          'userIds': []
        };
        this.set(fields);

        var payload = {
          mediaType: this.get('mediaType'),
          groupId: groupId
        };

        console.info('SCC_DEBUG: Send transferToGroup for id ' + this.get('id'), payload);
        return this.performAction('transfer_to_group', payload, undefined, undefined, undefined, undefined, {registerResponse:true});
      }
    },

    addAgentId: function(agentId) {
      if (agentId == this.get('ownerId')) {
        return ;
      }
      this.addUserIds([agentId]);
    },
    removeAgentId: function(agentId) {
      this.removeUserIds([agentId]);
    },

    addNote: function(authorId, note) {
      var payload = {
        authorId: authorId,
        note: note
      };

      console.log('Send add note for id ' + this.get('id'), payload);

      this.performAction('note', payload, 'PUT', undefined, undefined, undefined, {registerResponse:true})
        .done(_.bind(function(response) {
          console.log('Send add note for id ' + this.get('id') + ' success', response);
        }, this))
        .fail(_.bind(function(response) {
          console.log('Send add note for id ' + this.get('id') + ' error', response);
        }, this));
    },

    assignTopic: function(id, topic) {
      if (this.isLockByMe()) {
        var lvTopicThreadId = this.get('topicThreadId');
        var lvTopicThread = this.get('topicThread');

        var payload = {
          topicId: id
        };

        console.info('SCC_DEBUG: Send assignTopic for id ' + this.get('id'), payload);

        /**
         * Change the model right away
         */
        this.set({'topicThreadId': id, 'topicThread': topic});

        /**
         * Send message and process in fail if an error
         */
        this.performAction('topic', payload, 'PUT', undefined, undefined, undefined, {registerResponse:true})
          .done(_.bind(function(response) {
            console.log('Send assignTopic for id ' + this.get('id') + ' success', response);
            /**
             * Nothing else to do, topic has been assigned correctly
             */
          }, this))
          .fail(_.bind(function(response) {
            this.set('topicThreadId', lvTopicThreadId);
            this.set('topicThread', lvTopicThread);

            console.error('Send assignTopic for id ' + this.get('id') + ' failed', response);
          }, this));
      }
    },

    createTopic: function(topic) {
      if (this.isLockByMe()) {
        var lvTopicThreadId = this.get('topicThreadId');
        var lvTopicThread = this.get('topicThread');

        var payload = {
          topicName: topic
        };

        console.info('SCC_DEBUG: Send createTopic for id ' + this.get('id'), payload);

        /**
         * Change the model right away
         */
        this.set('topicThread', topic);

        /**
         * Send message and process in fail if an error
         */
        this.performAction('topic', payload, 'POST', false, null, true, {registerResponse:true})
          .done(_.bind(function(response) {
            console.log('Send createTopic for id ' + this.get('id') + ' success', response);
            this.set('topicThreadId', response.attrs.topicId);
          }, this))
          .fail(_.bind(function(response) {
            this.set('topicThreadId', lvTopicThreadId);
            this.set('topicThread', lvTopicThread);

            console.error('Send createTopic for id ' + this.get('id') + ' failed', response);
          }, this));
      }
    },

    updateTopic: function(topic) {
      if (this.isLockByMe()) {
        var lvTopicThreadId = this.get('topicThreadId');
        var lvTopicThread = this.get('topicThread');

        var payload = {
          topicName: topic
        };

        console.info('SCC_DEBUG: Send updateTopic for id ' + this.get('id'), payload);

        /**
         * Change the model right away
         */
        this.set('topicThread', topic);

        /**
         * Send message and process in fail if an error
         */
        this.performAction('topic/' + lvTopicThreadId, payload, 'POST', undefined, undefined, undefined, {registerResponse:true})
          .done(_.bind(function(response) {
            console.log('Send updateTopic for id ' + this.get('id') + ' success', response);
            /**
             * TODO (1. Need to update all items currently in memory with that updated topic, 2. If getting back an id, need to assign it to the interaction)
             */
          }, this))
          .fail(_.bind(function(response) {
            this.set('topicThreadId', lvTopicThreadId);
            this.set('topicThread', lvTopicThread);

            console.error('Send updateTopic for id ' + this.get('id') + ' failed', response);
          }, this));
      }
    },

    setAttribute: function(attributeId, valueId) {
      if (this.isLockByMe()) {
        try {
          var payload = {
            attributeId: attributeId,
            valueId: valueId
          };

          console.info('SCC_DEBUG: Send set setAttribute for id ' + this.get('id'), payload);

          /**
           * Keep the current one in case of error so we can roll back
           */
          var saved = [];
          this.getAttributes().forEach(function(attribute) {
            saved.push( { attributeId: attribute.attributeId, valueId: attribute.valueId } );
          });

          var found = false;
          var newAttributes = [];
          this.getAttributes().forEach(function(attribute) {
            if (attribute.attributeId == attributeId) {
              found = true;

              newAttributes.push( { attributeId: attribute.attributeId, valueId: valueId } );
            } else {
              newAttributes.push( { attributeId: attribute.attributeId, valueId: attribute.valueId } );
            }
          });

          if (!found) {
            newAttributes.push( { attributeId: attributeId, valueId: valueId } );
          }

          this.set('attribs', newAttributes);
          this.trigger('change:attribs');


          /**
           * Send message and process in fail if an error
           */
          this.performAction('attributes', payload)
            .fail(_.bind(function(response) {
              this.set('attribs', saved);

              this.trigger('change:attribs');

              console.error('SCC_DEBUG: Send set setAttribute for id ' + this.get('id') + ' failed');
            }, this));
        } catch (err) {
          console.error('SCC_DEBUG: Can\'t set setAttribute for id ' + this.get('id') + ' and attribute ' + payload);
        }
      }
    },

    setCluster: function(clusterId) {
      if (this.isLockByMe()) {
        var lvClusterId = this.get('clusterId');

        var payload = {
          clusterId: clusterId
        };

        console.info('SCC_DEBUG: Send set cluster for id ' + this.get('id'), payload);

        /**
         * Change the model right away
         */
        this.set('clusterId', clusterId);

        /**
         * Send message and process in fail if an error
         */
        this.performAction('cluster', payload)
          .fail(_.bind(function(response) {
            this.set('clusterId', lvClusterId);

            console.error('Send set cluster for id ' + this.get('id') + ' failed', response);
          }, this));
      }
    },

    setDisposition: function(dispositionId) {
      var d = $.Deferred();

      if (this.isLockByMe()) {
        try {
          var lvDispositionId = this.get('dispositionId');

          var payload = {
            mediaType: this.get('mediaType'),
            profileId: this.get('profileId'),
            dispositionId: dispositionId,
            isClose: ((Five9.Context.Tenant.Dispositions().get(dispositionId).get('flags').indexOf('SOCIAL_CLOSED') > -1) ? 1 : 0)
          };

          console.info('SCC_DEBUG: Send set disposition for id ' + this.get('id'), payload);
          this.validateUserIds();
          this.debugUserIds();

          /**
           * Change the model right away
           */
          this.set({'dispositionId': dispositionId});

          /**
           * Send message and process in fail if an error
           */
          this.performAction('disposition', payload, undefined, undefined, undefined, undefined, {registerResponse:true})
            .done(_.bind(function() {
              console.info('SCC_DEBUG: Send set disposition completed for id ' + this.get('id'));
              d.resolve();
            }, this))
            .fail(_.bind(function(response) {
              this.set('dispositionId', lvDispositionId);

              console.error('SCC_DEBUG: Send set disposition failed for id ' + this.get('id') + ' failed', response);
              d.reject();
            }, this));
        } catch (err) {
          console.error('SCC_DEBUG: Can\'t set disposition failed for id ' + this.get('id') + ' and dispositionId ' + dispositionId);
        }
      }
      else{
        d.reject();
      }
      return d.promise();
    },

    setSentiment: function(sentiment) {
      if (this.isLockByMe()) {
        var lvSentiment = this.get('sentiment');

        var payload = {
          sentiment: sentiment
        };

        console.info('SCC_DEBUG: Send set sentiment for id ' + this.get('id'), payload);

        /**
         * Change the model right away
         */
        this.set('sentiment', sentiment);

        /**
         * Send message and process in fail if an error
         */
        this.performAction('sentiment', payload)
          .fail(_.bind(function() {
            this.set('sentiment', lvSentiment);

            console.error('SCC_DEBUG: Send set sentiment failed for id ' + this.get('id') + ' failed', response);
          }, this));
      }
    },

    setSpam: function(spam) {
      if (this.isLockByMe()) {
        var lvSpam = this.get('spam');

        var payload = {
          spam: spam
        };

        console.info('SCC_DEBUG: Send set spam for id ' + this.get('id'), payload);

        /**
         * Change the model right away
         */
        this.set('spam', spam);

        /**
         * Send message and process in fail if an error
         */
        this.performAction('spam', payload)
          .fail(_.bind(function(response) {
            this.set('spam', lvSpam);

            console.error('Send set spam for id ' + this.get('id') + ' failed', response);
          }, this));
      }
    },

    stopTimers: function() {
      this.stopOfferTimer();
      this.stopEngageTimer();
      this.stopWithdrawTimer();
    },
    startOfferTimer: function() {
      if (this.isACD() && !this.offerTimerId) {
        console.log('SCC_DEBUG start offer timer', this.id);
        this.set('offerTimer', 30);
        this.offerTimerId = setInterval(_.bind(this.onOfferTimerInterval, this), 1000);
      }
    },
    stopOfferTimer: function() {
      if (this.offerTimerId) {
        clearInterval(this.offerTimerId);
        delete this.offerTimerId;
      }
    },
    onOfferTimerInterval: function() {
      var timer = this.get('offerTimer');
      if ((timer--) < 0) {
        console.info(Utils.formatString('SCC_DEBUG Offer timer expired for id [{0}]', this.get('id')));

        timer = 0;
        this.stopOfferTimer();

        if (this.isChatPreview()) {
          this.rejectPreview();
        }
        else {
          this.reject();
        }
      }
      this.set('offerTimer', timer);
    },
    startEngageTimer: function(engageTimeout) {
      if (this.isChatPreview() && !this.engageTimerId) {
        console.log('SCC_DEBUG start engage timer', this.id);
        this.set('engageTimer', engageTimeout);
        this.engageTimerId = setInterval(_.bind(this.onEngageTimerInterval, this), 1000);
        Five9.vent.trigger('scc:' + this.get('mediaTypeAsString') + ':engage:timer:start', this);
      }
    },
    stopEngageTimer: function() {
      if (this.engageTimerId) {
        clearInterval(this.engageTimerId);
        delete this.engageTimerId;
      }
    },
    onEngageTimerInterval: function() {
      var timer = this.get('engageTimer');
      if ((timer--) < 0) {
        console.info(Utils.formatString('SCC_DEBUG Engage timer expired for id [{0}]', this.get('id')));

        timer = 0;
        this.unset('engageTimer');
        this.stopEngageTimer();

        Five9.vent.trigger('scc:' + this.get('mediaTypeAsString') + ':engage:timer:expired', this);
        return;
      }
      this.set('engageTimer', timer);
    },
    startWithdrawTimer: function() {
      if (this.isChatPreview() && !this.withdrawTimerId) {
        console.log('SCC_DEBUG start withdraw timer', this.id);
        this.set('withdrawTimer', 30);
        this.withdrawTimerId = setInterval(_.bind(this.onWithdrawTimerInterval, this), 1000);
        Five9.vent.trigger('scc:' + this.get('mediaTypeAsString') + ':withdraw:timer:start', this);
      }
    },
    stopWithdrawTimer: function() {
      if (this.withdrawTimerId) {
        this.unset('withdrawTimer');
        clearInterval(this.withdrawTimerId);
        delete this.withdrawTimerId;
      }
    },
    onWithdrawTimerInterval: function() {
      var timer = this.get('withdrawTimer');
      if ((timer--) < 0) {
        console.info(Utils.formatString('SCC_DEBUG Withdraw timer expired for id [{0}]', this.get('id')));

        timer = 0;
        this.unset('withdrawTimer');
        this.stopWithdrawTimer();

        Five9.vent.trigger('scc:' + this.get('mediaTypeAsString') + ':withdraw:timer:expired', this);
        return;
      }
      this.set('withdrawTimer', timer);
    },

    isContactLoaded: function(){
      var contact = this.get('contact');
      if (!contact) {
        return false;
      }
      return contact.isFetched();
    },
    loadContact: function(contactModelType) {
      var authorId = this.get('authorId');
      var url = location.protocol + '//' + location.host + '/appsvcs/rs/svc/orgs/' + Five9.Context.TenantId + '/contacts/' + authorId;
      var contact = this.get('contact');
      if (!contact) {
        contact = new contactModelType({id:authorId});
        this.set('contact', contact);
      }
      var ret = contact.fetch({url:url});
      ret
        .done(function(attrs) {
          if (!attrs) {
            // keep in mind - the API returns 204 "success" when no SCC contact is found.  435 for VCC contacts (this can only occur when a VCC contact was initially matched)
            // there is an open API defect to resolve this inconsistency
            console.info('No data found for social contact');
            this.unset('contact');
          }
        }.bind(this))
        .fail(function() {
          console.error('Error retrieving social contact');
          this.unset('contact');
        }.bind(this));
      return ret;
    },

    toJSON: function() {
      var data = ServerModels.Model.prototype.toJSON.apply(this, arguments);
      var author = this.getAuthor();
      if (author) {
        data.author = author.toJSON();
      }
      return data;
    }
  });
  _.extend(Items.Model.prototype, FreedomHelpers.ModelMixin);


  Items.Collection = ServerModels.Collection.extend({
    apiClassType: Items.apiClassType,
    model: Items.Model,

    sortCapabilities: {
      ascending: function(item) {
        return item.get('publishedDate');
      },
      descending: function(item) {
        return (item.get('publishedDate') * -1);
      }
    },

    initialize: function(options) {
      this.sortOrder = 'ascending';
      this.comparator = this.sortCapabilities[this.sortOrder];

      this.on('remove', this.onItemRemoved, this);
    },
    onItemRemoved: function(model) {
      model.stopTimers();
    },

    canAccept: function(mediaType) {
      var assigned = this.getAssignedAndInProgressCount(mediaType);
      var max = Five9.Context.Agent.Settings().get('maxSocial');

      if (mediaType == Items.MediaTypes.CHAT) {
        max = Five9.Context.Agent.Settings().get('maxChat');
      }
      if (mediaType == Items.MediaTypes.EMAIL) {
        max = Five9.Context.Agent.Settings().get('maxEmail');
      }

      if (max == -1 || assigned < max) {
        return true;
      }

      return false;
    },

    changeSortOrder: function(sortOrder) {
      this.sortOrder = sortOrder;
      this.comparator = this.sortCapabilities[this.sortOrder];
      this.sort();
    },

    getSortOrder: function() {
      return this.sortOrder;
    },

    getQueued: function(mediaType) {
      var filtered = this.filter(_.partial(queuedIterator, mediaType));

      var collection = new Items.Collection();
      collection.setComparator(this.comparator);
      collection.reset(filtered);

      console.log('Items - getQueued Type [' + mediaType + '] Count [' + collection.length + ']', collection);

      return collection;
    },
    getQueuedCount: function(mediaType) {
      var items = this.filter(_.partial(queuedIterator, mediaType));

      console.log('Items - getQueuedCount Type [' + mediaType + '] Count [' +  items.length + ']');
      return items.length;
    },

    getAssigned: function(mediaType) {
      // note: assigned includes preview chats before they are locked
      var assignedIterator = function(mediaType, model) {
        if (model.get('mediaType') === mediaType && model.isChat() && model.isChatPreview()) {
          return true;
        }
        return ((model.get('mediaType') ===  mediaType) && (model.isLockByMe() || model.inConferenceWithMe()));
      };
      var filtered = this.filter(_.partial(assignedIterator, mediaType));

      var collection = new Items.Collection();
      collection.setComparator(this.comparator);
      collection.reset(filtered);
      console.log('Items - getAssigned Type [' + mediaType + '] Count [' + collection.length + ']', collection);
      return collection;
    },
    getAssignedCount: function(mediaType) {
      // note: assigned count ignores preview chats until they are locked
      var count = 0;
      this.models.forEach(function(model) {
        if ((model.get('mediaType') ===  mediaType) && (model.isLockByMe() || model.inConferenceWithMe())) {
          count++;
        }
      });

      console.log('Items - getAssignedCount Type [' + mediaType + '] Count [' +  count + ']');
      return count;
    },

    getAssignedAndInProgressCount: function(mediaType) {
      // note: assigned count ignores preview chats until they are locked
      var count = 0;
      this.models.forEach(function(model) {
        if ((model.get('mediaType') ===  mediaType) && (model.isLockByMe() || model.inConferenceWithMe() || model.get('lockInProgress'))) {
          count++;
        }
      });

      console.log('Items - getAssignedAndInProgressCount Type [' + mediaType + '] Count [' +  count + ']');
      return count;
    },
    getAssignedChats: function() {
      return this.getAssigned(Items.MediaTypes.CHAT);
    },
    getAssignedEmails: function() {
      return this.getAssigned(Items.MediaTypes.EMAIL);
    },
    getAssignedSocials: function() {
      return this.getAssigned(Items.MediaTypes.SOCIAL);
    },

    setComparator: function(comparator) {
      this.comparator = comparator;
    }
  });
  _.extend(Items.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Items;
});

define('models/server/phoneNumberFormatInfo',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var NumberFormatInfo = {
    apiClassType: 'phone_number/format',

    FormatTypes: {
      E164: 'E164',
      NANP: 'NORTH_AMERICAN'
    }
  };

  NumberFormatInfo.Model = ServerModels.Model.extend({
    apiClassType: NumberFormatInfo.apiClassType,
    defaults: {
      format: NumberFormatInfo.FormatTypes.E164,
      locale: null
    },

    isE164Enabled: function() {
      return this.get('format') === NumberFormatInfo.FormatTypes.E164;
    }
  });

  _.extend(NumberFormatInfo.Model.prototype, FreedomHelpers.ModelMixin);

  return NumberFormatInfo;
});

define('models/server/phoneNumberLocOptionsInfo',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var OptionsInfo = {
    apiClassType: 'phone_number/localization_options'
  };

  OptionsInfo.Model = ServerModels.Model.extend({
    apiClassType: OptionsInfo.apiClassType,
    defaults: {
      localizeNumberDisplay: false,
      localizeContactsAndConnectors: false,
      locale: null
    }
  });

  _.extend(OptionsInfo.Model.prototype, FreedomHelpers.ModelMixin);

  return OptionsInfo;
});

define('models/server/phoneNumberLocales',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {
  var Locales = {
    apiClassType: 'phone_number/locales'
  };

  Locales.Model = ServerModels.Model.extend({
      apiClassType: Locales.apiClassType,
      defaults: {
        countryCode: '',
        countryName: '',
        internationalPrefix: '',
        nationalPrefix: ''
      }
    }
  );

  Locales.Collection = ServerModels.Collection.extend({
    apiClassType: Locales.apiClassType,
    model: Locales.Model,

    comparator: function(item) {
      return item.get('countryName');
    },
    isCodeAllowed: function(countryCode) {
      var found = false;
      this.each(function(locale) {
        if ( '+' + locale.get('countryCode') === countryCode ) {found=true; return false;}
      });
      return found;
    },
    getLocaleByPrefix: function(prefix) {
      var result;
      this.each(function(locale) {
        if ( '+' + locale.get('countryCode') === prefix) {
          result = {countryName: locale.get('countryName'), prefix: '+' + locale.get('countryCode')};
          return false;
        }
      });
      return result;
    }
  });

  _.extend(Locales.Model.prototype, FreedomHelpers.CollectionMixin);

  return Locales;
});

define('models/server/callLoggingConfig',[
    'underscore',
    'server.models.adapter',
    'server.models.storage',
    './freedom.helpers'
  ],
  function(_, ServerModels, ModelStorage, FreedomHelpers) {
    var Config = {
      apiClassType: 'logging_config',
      resourceId: ModelStorage.Resources.CallLoggingConfig
    };

    Config.Model = ServerModels.Model.extend({
      apiClassType: Config.apiClassType,
      defaults: {
        enhancedLoggingEnabled: false
      }
    });
    _.extend(Config.Model.prototype, FreedomHelpers.ModelMixin);

    return Config;
  });

define('models/server/tenantUsers',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, FreedomHelpers) {

  var Users = {
    apiClassType: 'users'
  };

  Users.Role = {
    Agent: 'Agent',
    Supervisor: 'DomainSupervisor',
    Admin: 'DomainAdmin'
  };

  Users.Model = ServerModels.Model.extend({
    apiClassType:Users.apiClassType,
    defaults: {
    },

    parse: function(response) {
      response.userId = response.id;
      if (response.role) {
        response.id += response.role;
      }
      return response;
    },

    getId: function() {
      return this.get('userId');
    },

    getName: function() {
      return this.get('name');
    },

    getFullName: function() {
      return this.get('fullName');
    },

    getRole: function() {
      return this.get('role');
    },

    getLoggedIn: function() {
      return this.get('loggedIn');
    },

    getEmail: function() {
      return this.get('email');
    },

    getExtension: function() {
      return this.get('extension');
    },

    getTimeZoneId: function() {
      return this.get('timeZoneID');
    }
  });
  _.extend(Users.Model.prototype, FreedomHelpers.ModelMixin);

  Users.Collection = ServerModels.Collection.extend({
    apiClassType: Users.apiClassType,
    model: Users.Model
  });
  _.extend(Users.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Users;
});

define('models/server/timeZones',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function(_, ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
  var API = DataAdapter.API;

  var TimeZones = {
    apiClassType: 'time_zones',
    resourceId: ModelStorage.Resources.TimeZones
  };

  TimeZones.Model = ServerModels.Model.extend({
    apiClassType: TimeZones.apiClassType,
    defaults: {
    },

    parse: function(response) {
      var items = response.split('|');
      return {id:items[0],info:response};
    }
  });
  _.extend(TimeZones.Model.prototype, FreedomHelpers.ModelMixin);

  TimeZones.Collection = ServerModels.Collection.extend({
    apiClassType: TimeZones.apiClassType,
    model: TimeZones.Model,

    toJSON: function() {
      var data = ServerModels.Collection.prototype.toJSON.apply(this, arguments);

      var temp = _.map(data, function(zone) {
        return zone.info;
      });

      return temp;
    }
  });
  _.extend(TimeZones.Collection.prototype, FreedomHelpers.CollectionMixin);

  return TimeZones;
});

define('models/server/ucSettings',[
    'underscore',
    'server.models.adapter',
    'server.models.storage',
    './freedom.helpers'
  ],
  function(_, ServerModels, ModelStorage, FreedomHelpers) {
    var UCSettings = {
      apiClassType: 'uc_settings',
      resourceId: ModelStorage.Resources.UCSettings
    };

    UCSettings.Model = ServerModels.Model.extend({
      apiClassType:UCSettings.apiClassType,
      defaults: {
        ucDomain: '',
        usedForInternalMessaging: false,
        type: 'NONE'
      }
    });
    _.extend(UCSettings.Model.prototype, FreedomHelpers.ModelMixin);
    return UCSettings;
  });
define('models/server/tenants',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers',
  'models/server/contacts',
  'models/server/contacts-noFullTextSearch',
  'models/server/contactFields',
  'models/server/notReadyReasonCodes',
  'models/server/speedDials',
  'models/server/agentsPresence',
  'models/server/logoutReasonCodes',
  'models/server/campaigns',
  'models/server/skills',
  'models/server/callVariables',
  'models/server/passwordPolicies',
  'models/server/noneCampaignDispositionInfo',
  'models/server/assistances',
  'models/server/attributes',
  'models/server/clusters',
  'models/server/medias',
  'models/server/items',
  'models/server/authors',
  'models/server/dispositions',
  'models/server/phoneNumberFormatInfo',
  'models/server/phoneNumberLocOptionsInfo',
  'models/server/phoneNumberLocales',
  'models/server/callLoggingConfig',
  'models/server/tenantUsers',
  'models/server/timeZones',
  'models/server/ucSettings'
],
function(_, ServerModels, ModelStorage, FreedomHelpers, Contacts, ContactsNoFullTextSearch, ContactFields, NotReadyReasonCodes, SpeedDials,
         AgentsPresence, LogoutReasonCodes, Campaigns, Skills, CallVariables, PasswordPolicies, NoneCampaignDispositionInfo,
         Assistances, Attributes, Clusters, Medias, Items, Authors, Dispositions, NumFormatInfo, NumLocInfo, NumLocales,
         CallLoggingConfig, Users, TimeZones, UCSettings) {

  var Tenants = {
    apiClassType: 'orgs'
  };

  /**
   * @class Tenants
   * @extends ServerModel
   * @classdesc
   * <pre>
   * Represents Freedom API {@link {@substitute apiBaseUrl}#!/tenants tenants endpoint}
   * </pre>
   */
  Tenants.Model = ServerModels.Model.extend({
    apiClassType:Tenants.apiClassType,
    defaults: {
    },

    Assistances: function() {
      return ModelStorage.get(this.path(), Assistances);
    },
    Assistance: function(id) {
      return ModelStorage.get(this.path(), Assistances, id);
    },
    Attributes: function() {
      return ModelStorage.get(this.path(), Attributes);
    },
    Attribute: function(id) {
      return ModelStorage.get(this.path(), Attributes, id);
    },
    Authors: function() {
      return ModelStorage.get(this.path(), Authors);
    },
    Author: function(id) {
      return ModelStorage.get(this.path(), Authors, id);
    },
    Clusters: function() {
      return ModelStorage.get(this.path(), Clusters);
    },
    Cluster: function(id) {
      return ModelStorage.get(this.path(), Clusters, id);
    },

    /**
     * @memberof Tenants
     * @returns {Contacts}
     */
    Contacts: function() {
      return ModelStorage.get(this.path(), Contacts);
    },
    /**
     * @memberof Tenants
     * @returns {Contacts}
     */
    Contact: function(id) {
      return ModelStorage.get(this.path(), Contacts, id);
    },
    ContactNoFullTextSearch: function(id) {
      return ModelStorage.get(this.path(), ContactsNoFullTextSearch, id);
    },

    /**
     * @memberof Tenants
     * @returns {Campaigns}
     */
    Campaigns: function() {
      return ModelStorage.get(this.path(), Campaigns);
    },

    /**
     * @memberof Tenants
     * @returns {Campaigns}
     */
    Campaign: function(id) {
      return ModelStorage.get(this.path(), Campaigns, id);
    },
    ContactFields: function() {
      return ModelStorage.get(this.path(), ContactFields);
    },
    ContactField: function(id) {
      return ModelStorage.get(this.path(), ContactFields, id);
    },

    /**
     * @memberof Tenants
     * @returns {CallVariables}
     */
    CallVariables: function() {
      return ModelStorage.get(this.path(), CallVariables);
    },

    /**
     * @memberof Tenants
     * @returns {CallVariables}
     */
    CallVariable: function(id) {
      return ModelStorage.get(this.path(), CallVariables, id);
    },

    /**
     * @memberof Tenants
     * @returns {Dispositions}
     */
    Dispositions: function() {
      return ModelStorage.get(this.path(), Dispositions);
    },

    /**
     * @memberof Tenants
     * @returns {Dispositions}
     */
    Disposition: function(id) {
      return ModelStorage.get(this.path(), Dispositions, id);
    },
    Items: function() {
      return ModelStorage.get(this.path(), Items);
    },
    Item: function(id) {
      return ModelStorage.get(this.path(), Items, id);
    },
    Medias: function() {
      return ModelStorage.get(this.path(), Medias);
    },
    Media: function(id) {
      return ModelStorage.get(this.path(), Medias, id);
    },

    /**
     * @memberof Tenants
     * @returns {LogoutReasonCodes}
     */
    LogoutReasonCodes: function() {
      return ModelStorage.get(this.path(), LogoutReasonCodes);
    },

    /**
     * @memberof Tenants
     * @returns {NotReadyReasonCodes}
     */
    NotReadyReasonCodes: function() {
      return ModelStorage.get(this.path(), NotReadyReasonCodes);
    },

    /**
     * @memberof Tenants
     * @param {string} id
     * @returns {NotReadyReasonCodes}
     */
    NotReadyReasonCode: function(id) {
      return ModelStorage.get(this.path(), NotReadyReasonCodes, id);
    },

    /**
     * @memberof Tenants
     * @returns {SpeedDials}
     */
    SpeedDials: function() {
      return ModelStorage.get(this.path(), SpeedDials);
    },
    CallLoggingConfig: function() {
      return ModelStorage.get(this.path(), CallLoggingConfig);
    },

    /**
     * @memberof Tenants
     * @returns {PasswordPolicies}
     */
    PasswordPolicies: function(){
      return ModelStorage.get(this.path(), PasswordPolicies);
    },

    /**
     * @memberof Tenants
     * @returns {AgentPresence}
     */
    Presence: function() {
      return ModelStorage.get(this.path(), AgentsPresence);
    },

    /**
     * @memberof Tenants
     * @returns {Skills}
     */
    Skills: function() {
      return ModelStorage.get(this.path(), Skills);
    },
    TimeZones: function() {
      return ModelStorage.get(this.path(), TimeZones);
    },

    /**
     * @memberof Tenants
     * @returns {NoneCampaignDispositionInfo}
     */
    NoneCampaignDispositionInfo: function() {
      return ModelStorage.get(this.path(), NoneCampaignDispositionInfo);
    },

    NumberFormatInfo: function() {
      return ModelStorage.get(this.path(), NumFormatInfo);
    },

    NumberLocaleOptions: function() {
      return ModelStorage.get(this.path(), NumLocInfo);
    },

    NumberLocales: function() {
      return ModelStorage.get(this.path(), NumLocales);
    },

    UCSettings: function() {
      return ModelStorage.get(this.path(), UCSettings);
    },

    Users: function() {
      return ModelStorage.get(this.path(), Users);
    }
  });
  _.extend(Tenants.Model.prototype, FreedomHelpers.ModelMixin);

  Tenants.Collection = ServerModels.Collection.extend({
    apiClassType:Tenants.apiClassType,
    model: Tenants.Model
  });
  _.extend(Tenants.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Tenants;
});

define('models/server/userSettings',[
  'underscore',
  'jquery',
  'server.models.adapter',
  'server.models.storage',
  'dataAdapter',
  './freedom.helpers'
],
function(_, $, ServerModels, ModelStorage, DataAdapter, FreedomHelpers) {
  var API = DataAdapter.API;

  var UserSettings = {
    apiClassType: 'ui_options',
    Version: 2,
    VersionKey: 'UserSettings-version'
  };

  UserSettings.Model = ServerModels.Model.extend({
    apiClassType: UserSettings.apiClassType,
    defaults: {
      key: '',
      value: {}
    }
  });
  _.extend(UserSettings.Model.prototype, FreedomHelpers.ModelMixin);

  UserSettings.Collection = ServerModels.Collection.extend({
    apiClassType: UserSettings.apiClassType,
    model: UserSettings.Model,

    _getValueByKey: function(itemKey) {
      var settings = this.where({key: itemKey});

      var retVal = null;
      if (settings.length) {
        retVal = settings[0].get('value');
      }
      return retVal;
    },
    _setValueByKey: function(key, val) {
      var setting = this.where({key: key});

      if (setting.length) {
        setting[0].set('value', val);
      }
      else {
        this._addModel(key, val);
      }
    },
    getValue: function(key, defaultValue) {
      var setting = this._getValueByKey(key);
      if (!_.isArray(setting) && _.isObject(setting)) {
        setting = $.extend(true, {}, defaultValue, setting);
      }
      return (setting === null) ? _.clone(defaultValue) : setting;
    },
    setValue: function(key, val) {
      return this._setValueByKey(key, val);
    },

    clearSettings: function() {
      this.reset();
    },
    saveSettings: function() {
      var d = $.Deferred();

      if (this.length) {
        // update version (add if not already present)
        this._setValueByKey(UserSettings.VersionKey, UserSettings.Version);

        // save models
        var url = 'users/' + Five9.Context.AgentId + '/ui_options';
        var payload = this.toJSON();
        return API.performAction(url, 'PUT', null, null, payload);
      }
      d.resolve();
      return d.promise();
    },
    settingsExist: function() {
      return (this.length === 0) ? false : true;
    },

    fetch: function() {
      var d = $.Deferred();
      ServerModels.Collection.prototype.fetch.apply(this, arguments)
        .done(_.bind(function() {
          // if incorrect version, remove all entries
          var version = this._getVersion();
          if (version) {
            console.log('UserSettings:version [' + version + ']');
          }
          if (version !== UserSettings.Version) {
            if (version) {
              console.warn('UserSettings old version - resetting');
            }
            this.reset();
          }
          d.resolve();
        }, this))
        .fail(function(errors) {
          d.reject(errors);
        });
      return d.promise();
    },

    _getVersion: function() {
      return this._getValueByKey(UserSettings.VersionKey);
    },
    _addModel: function(key, val) {
      return this.add(new UserSettings.Model({key:key,value:val}));
    }
  });
  _.extend(UserSettings.Collection.prototype, FreedomHelpers.CollectionMixin);

  return UserSettings;
});

define('models/server/users',[
  'underscore',
  'server.models.adapter',
  'server.models.storage',
  './freedom.helpers',
  'models/server/userSettings'
],
function(_, ServerModels, ModelStorage, FreedomHelpers, UserSettings) {

  var Users = {
    apiClassType: 'users'
  };

  Users.Model = ServerModels.Model.extend({
    apiClassType:Users.apiClassType,
    defaults: {
    },

    Settings: function() {
      return ModelStorage.get(this.path(), UserSettings);
    }
  });
  _.extend(Users.Model.prototype, FreedomHelpers.ModelMixin);

  Users.Collection = ServerModels.Collection.extend({
    apiClassType:Users.apiClassType,
    model: Users.Model
  });
  _.extend(Users.Collection.prototype, FreedomHelpers.CollectionMixin);

  return Users;
});

define('models/server/keyStoreWrapper',[
    'backbone',
    'jquery',
    'underscore',
    'dataAdapter-api',
    'local.storage',
    'server.models.adapter'
  ],
  function (Backbone, $, _, API, LocalStorage, ServerModels) {
    var KeyStoreWrapper = {
      apiClassType: 'client_tools/key_store'
    };

    KeyStoreWrapper.Model = ServerModels.Model.extend({
      apiClassType: KeyStoreWrapper.apiClassType,

      _init: function () {
        ServerModels.Model.prototype._init.apply(this, arguments);
        LocalStorage.on(this.path(), this.onStateChanged, this);
      },

      onStateChanged: function(keyInfo) {
        this.set(JSON.parse(keyInfo.value));
      },

      parse: function (response) {
        if (!response){
          //204 No Content
          return this.attributes;
        }
        else if (response.value) {
          return JSON.parse(response.value);
        }
        return {};
      },
      save: function () {
        var keyInfo = {
          value: JSON.stringify(this.attributes)
        };
        return this.performAction(null, keyInfo, 'PUT').done(_.bind(function() {
          // no websocket event for key_store.
          LocalStorage.triggerOtherPages(this.path(), keyInfo);
        }, this));
      },

      destroy: function() {
        LocalStorage.off(this.path(), this.onStateChanged, this);
      }
    });

    return KeyStoreWrapper;
  });

define('models/server/skypeContacts',[
  'server.models.adapter',
  'server.models.storage',
  'utils',
],

function(ServerModels, ModelStorage, Utils) {
  var SkypeContacts = {
    apiClassType: 'skype',
    resourceId: ModelStorage.Resources.SkypeContact,

    SkypeStatusTypes: {
      BUSY: "Busy",
      ONLINE: "Online",
      OFFLINE: "Offline",
      DO_NOT_DISTURB: "DoNotDisturb",
      NONE: "None"
    },

    ConnectionStatus: {
      NotConnected: 0,
      DataLoadInProgress: 1,
      ConnectedAndLoaded: 2
    }
  };

  SkypeContacts.Model = ServerModels.Model.extend({
    apiClassType: SkypeContacts.apiClassType,
    defaults: {
      skypeId: '-',
      groupName: '',
      fullName: '-',
      title: '-',
      phone: '',
      email: '-',
      company: '-',
      department: '-',
      location: '-',
      status: '',
      avatarUrl: 'images/avatar-generic.png'
    }
  });

  SkypeContacts.Collection = ServerModels.Collection.extend({
    apiClassType: SkypeContacts.apiClassType,
    model: SkypeContacts.Model,

    parse: function(response) {
      if (response.items) {
        this.cursor = response.cursor;
        response = response.items;
      }
      return response;
    },

    checkIfSkypeContactsAreLoaded: function() {
      var skypeContactsReady = false;
      this.getCounter--;
      if (this.allGetInvoked && this.getCounter === 0) {
        skypeContactsReady = true;
        Five9.SkypeLoggedIn = SkypeContacts.ConnectionStatus.ConnectedAndLoaded;
        Five9.vent.trigger (ModelStorage.InternalEvents.SkypeContactsUploaded, this.models, {eventId: ModelStorage.InternalEvents.SkypeContactsUploaded});
      }
      return skypeContactsReady;
    },

    fetch: function() {
      // dummy fetch, fetchData() is the actual fetch implementation directly from the Lync server, does not go
      // through Five9 servers
      return $.Deferred().resolve().promise();
    },

    checkIfNameIsPhoneNumber: function (name) {
      var phoneNumber = null;
      var pattern = /^\+\d*\s*\((\d{3})\) (\d{3})-(\d{4})$/;
      if (pattern.test(name)) {
        phoneNumber = name.replace(pattern, '$1$2$3');
      }
      return phoneNumber;
    },

    fetchData: function() {
      var d = $.Deferred();
      var allGroups = window.SkypeApp.personsAndGroupsManager.all.groups;
      var thisPtr = this;
      this.getCounter = 0;
      this.allGetInvoked = false;
      allGroups.get().then(function(groups) {
        Five9.Logger.debug ('Total groups = ' + groups.length);
        groups.forEach (function(group) {
          var groupName = group.name();
          Five9.Logger.debug ('Group name = ' + group.name());
          if (!groupName) {
            return;
          }
          group.persons.get().then(function(persons) {
            persons.forEach (function(person) {
              var freedomId = Utils.generateGuid();
              thisPtr.add ({id: freedomId, groupName: groupName}, {silent: true});
              Five9.Logger.debug ('Id ' + freedomId + '; group ' + groupName);

              person.id.get().then(function(id) {
                thisPtr.set({id: freedomId, skypeId: id}, {remove: false, silent: true});
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function (error) {
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));

              person.displayName.get().then(function(displayName) {
                if (displayName) {
                  thisPtr.set({id: freedomId, fullName: displayName}, {remove: false, silent: true});
                  var phoneNumber = thisPtr.checkIfNameIsPhoneNumber (displayName);
                  if (phoneNumber) {
                    thisPtr.set({id: freedomId, phone: phoneNumber}, {remove: false, silent: true});
                  }
                }
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function(error) {
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));

              person.title.get().then(function(title) {
                if (title) {
                  thisPtr.set({id: freedomId, title: title}, {remove: false, silent: true});
                }
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function(error) {
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));

              person.workPhone.get().then(function(phoneNumber) {
                phoneNumber = phoneNumber || '-';
                if (phoneNumber.length > 6) {
                  phoneNumber = phoneNumber.substr(6);
                }
                var model = thisPtr.get(freedomId);
                var phoneNumberAlreadyStoredFromName = model.get('phone');
                if (!phoneNumberAlreadyStoredFromName) {
                  thisPtr.set({id: freedomId, phone: phoneNumber}, {remove: false, silent: true});
                }
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function(error) {
                thisPtr.set({id: freedomId, phone: '-'}, {remove: false, silent: true});
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));

              person.company.get().then(function(value) {
                if (value) {
                  thisPtr.set({id: freedomId, company: value}, {remove: false, silent: true});
                }
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function(error) {
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));

              person.department.get().then(function(value) {
                if (value) {
                  thisPtr.set({id: freedomId, department: value}, {remove: false, silent: true});
                }
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function(error) {
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));

              person.location.get().then(function(value) {
                if (value) {
                  thisPtr.set({id: freedomId, location: value}, {remove: false, silent: true});
                }
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function(error) {
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));

              person.emails.get().then(function(emailList) {
                if (emailList.length > 0) {
                  var emailAddress = emailList[0].emailAddress._value;
                  thisPtr.set({id: freedomId, email: emailAddress}, {remove: false, silent: true});
                }
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function(error){
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));

              person.avatarUrl.get().then(function(urlString) {
                if (urlString) {
                  thisPtr.set({id: freedomId, avatarUrl: urlString}, {remove: false, silent: true});
                }
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function(error){
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));

              person.status.get().then(function(status) {
                thisPtr.set({id: freedomId, status: status}, {remove: false, silent: true});
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr), function(error) {
                thisPtr.set({id: freedomId, status: SkypeContacts.SkypeStatusTypes.NONE}, {remove: false, silent: true});
                if (thisPtr.checkIfSkypeContactsAreLoaded()) {
                  return d.resolve();
                }
              }.bind(thisPtr));
              person.status.changed(function(status) {
                var options = (thisPtr.getCounter === 0) ? {remove: false} : {remove: false, silent: true};
                thisPtr.set({id: freedomId, status: status}, options);
              });
              person.status.subscribe();

              thisPtr.getCounter += 10;
            });
          }, function (error) {
            Five9.Logger.error ('Failed to fetch persons for group ' + group.name());
          });
        });
        thisPtr.allGetInvoked = true;
      }, function (error) {
        Five9.Logger.error ('Failed to fetch a list of all groups');
        return d.reject(errors);
      });
      return d.promise();
    }
  });

  return SkypeContacts;
});

define('models/server/root',[
  'server.models.storage',
  'models/server/agents',
  'models/server/tenants',
  'models/server/users',
  'models/server/keyStoreWrapper',
  'models/server/skypeContacts'
],
function(ModelStorage, Agents, Tenants, Users, KeyStoreWrapper, SkypeContacts) {
  var Root = {
    Agents: function() {
      return ModelStorage.get('', Agents);
    },
    Agent: function(id) {
      return ModelStorage.get('', Agents, id);
    },
    Tenant: function(id) {
      return ModelStorage.get('', Tenants, id);
    },
    Users: function() {
      return ModelStorage.get('', Users);
    },
    User: function(id) {
      return ModelStorage.get('', Users, id);
    },
    KeyStoreWrapper: function(key, defaultAttr) {
      return ModelStorage.get('', KeyStoreWrapper, key, defaultAttr);
    },
    SkypeContacts: function() {
      return ModelStorage.get('', SkypeContacts);
    },
    SkypeContact: function() {
      return ModelStorage.get('', SkypeContacts, id);
    }
  };

  return Root;
});

/**
 * @license
 * lodash 3.3.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern exports="amd" -d -o ./modern/main.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.3.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    CURRY_RIGHT_FLAG = 16,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64,
    REARG_FLAG = 128,
    ARY_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
    DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
    HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 0,
    LAZY_MAP_FLAG = 1,
    LAZY_WHILE_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
    reUnescapedHtml = /[&<>"'`]/g,
    reHasEscapedHtml = RegExp(reEscapedHtml.source),
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
    reEvaluate = /<%([\s\S]+?)%>/g,
    reInterpolate = /<%=([\s\S]+?)%>/g;

  /**
   * Used to match ES template delimiters.
   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)
   * for more details.
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect named functions. */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to detect hexadecimal string values. */
  var reHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /**
   * Used to match `RegExp` special characters.
   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
   * for more details.
   */
  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to detect functions containing a `this` reference. */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
      lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to detect and test for whitespace. */
  var whitespace = (
    // Basic whitespace characters.
  ' \t\x0b\f\xa0\ufeff' +

    // Line terminators.
  '\n\r\u2028\u2029' +

    // Unicode category "Zs" space separators.
  '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    'window', 'WinRTError'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
        typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
          typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dateTag] = typedArrayTags[errorTag] =
        typedArrayTags[funcTag] = typedArrayTags[mapTag] =
          typedArrayTags[numberTag] = typedArrayTags[objectTag] =
            typedArrayTags[regexpTag] = typedArrayTags[setTag] =
              typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
    cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
      cloneableTags[dateTag] = cloneableTags[float32Tag] =
        cloneableTags[float64Tag] = cloneableTags[int8Tag] =
          cloneableTags[int16Tag] = cloneableTags[int32Tag] =
            cloneableTags[numberTag] = cloneableTags[objectTag] =
              cloneableTags[regexpTag] = cloneableTags[stringTag] =
                cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
    cloneableTags[mapTag] = cloneableTags[setTag] =
      cloneableTags[weakMapTag] = false;

  /** Used as an internal `_.debounce` options object by `_.throttle`. */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it is the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare to `other`.
   * @param {*} other The value to compare to `value`.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsReflexive = value === value,
        othIsReflexive = other === other;

      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
        return 1;
      }
      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = (fromIndex || 0) - 1,
      length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`
   * to define the sort order of `array` and replaces criteria objects with their
   * corresponding values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * Converts `value` to a string if it is not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.max` and `_.min` as the default callback for string values.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the code unit of the first character of the string.
   */
  function charAtCallback(string) {
    return string.charCodeAt(0);
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
      length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByAll` to compare multiple properties of each element
   * in a collection and stable sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultipleAscending(object, other) {
    var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        return result;
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   * If `fromRight` is provided elements of `array` are iterated from right to left.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} [fromIndex] The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
      index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return (value && typeof value == 'object') || false;
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
    (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
      length = array.length,
      resIndex = -1,
      result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
      index = -1,
      length = array.length,
      resIndex = -1,
      result = [];

    while (++index < length) {
      var value = array[index],
        computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
      length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'add': function(a, b) { return a + b; } });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'sub': function(a, b) { return a - b; } });
   *
   * _.isFunction(_.add);
   * // => true
   * _.isFunction(_.sub);
   * // => false
   *
   * lodash.isFunction(lodash.add);
   * // => false
   * lodash.isFunction(lodash.sub);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
      Date = context.Date,
      Error = context.Error,
      Function = context.Function,
      Math = context.Math,
      Number = context.Number,
      Object = context.Object,
      RegExp = context.RegExp,
      String = context.String,
      TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
      objectProto = Object.prototype;

    /** Used to detect DOM support. */
    var document = (document = context.window) && document.document;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to the length of n-tuples for `_.unzip`. */
    var getLength = baseProperty('length');

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = context._;

    /** Used to detect if a method is native. */
    var reNative = RegExp('^' +
      escapeRegExp(objToString)
        .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
      bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
      ceil = Math.ceil,
      clearTimeout = context.clearTimeout,
      floor = Math.floor,
      getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
      push = arrayProto.push,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      Set = isNative(Set = context.Set) && Set,
      setTimeout = context.setTimeout,
      splice = arrayProto.splice,
      Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
      WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;

    /** Used to clone array buffers. */
    var Float64Array = (function() {
      // Safari 5 errors when using an array buffer to initialize a typed array
      // where the array buffer's `byteLength` is not a multiple of the typed
      // array's `BYTES_PER_ELEMENT`.
      try {
        var func = isNative(func = context.Float64Array) && func,
          result = new func(new ArrayBuffer(10), 0, 1) && func;
      } catch(e) {}
      return result;
    }());

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
      nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
      nativeIsFinite = context.isFinite,
      nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeNow = isNative(nativeNow = Date.now) && nativeNow,
      nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
      nativeParseInt = context.parseInt,
      nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
      POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
      MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /** Used as the size, in bytes, of each `Float64Array` element. */
    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

    /**
     * Used as the maximum length of an array-like value.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
     * for more details.
     */
    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that return a boolean or single value will
     * automatically end the chain returning the unwrapped value. Explicit chaining
     * may be enabled using `_.chain`. The execution of chained methods is lazy,
     * that is, execution is deferred until `_#value` is implicitly or explicitly
     * called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization that merges iteratees to avoid creating intermediate
     * arrays and reduce the number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
     * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`, `merge`,
     * `mixin`, `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `splice`, `spread`,
     * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,
     * `thru`, `times`, `toArray`, `toPlainObject`, `transform`, `union`, `uniq`,
     * `unshift`, `unzip`, `values`, `valuesIn`, `where`, `without`, `wrap`, `xor`,
     * `zip`, and `zipObject`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
     * `identity`, `includes`, `indexOf`, `isArguments`, `isArray`, `isBoolean`,
     * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`,
     * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
     * `startCase`, `startsWith`, `template`, `trim`, `trimLeft`, `trimRight`,
     * `trunc`, `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, n) {
     *   return sum + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    (function(x) {

      /**
       * Detect if functions can be decompiled by `Function#toString`
       * (all but Firefox OS certified apps, older Opera mobile browsers, and
       * the PlayStation 3; forced `false` for Windows 8 apps).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

      /**
       * Detect if `Function#name` is supported (all but IE).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcNames = typeof Function.name == 'string';

      /**
       * Detect if the DOM is supported.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.dom = document.createDocumentFragment().nodeType === 11;
      } catch(e) {
        support.dom = false;
      }

      /**
       * Detect if `arguments` object indexes are non-enumerable.
       *
       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
       * checks for indexes that exceed their function's formal parameters with
       * associated values of `0`.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
      } catch(e) {
        support.nonEnumArgs = true;
      }
    }(0, 0));

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = null;
      this.__dir__ = 1;
      this.__dropCount__ = 0;
      this.__filtered__ = false;
      this.__iteratees__ = null;
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = null;
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var actions = this.__actions__,
        iteratees = this.__iteratees__,
        views = this.__views__,
        result = new LazyWrapper(this.__wrapped__);

      result.__actions__ = actions ? arrayCopy(actions) : null;
      result.__dir__ = this.__dir__;
      result.__dropCount__ = this.__dropCount__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = views ? arrayCopy(views) : null;
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value();
      if (!isArray(array)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var dir = this.__dir__,
        isRight = dir < 0,
        view = getView(0, array.length, this.__views__),
        start = view.start,
        end = view.end,
        length = end - start,
        dropCount = this.__dropCount__,
        takeCount = nativeMin(length, this.__takeCount__),
        index = isRight ? end : start - 1,
        iteratees = this.__iteratees__,
        iterLength = iteratees ? iteratees.length : 0,
        resIndex = 0,
        result = [];

      outer:
        while (length-- && resIndex < takeCount) {
          index += dir;

          var iterIndex = -1,
            value = array[index];

          while (++iterIndex < iterLength) {
            var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              computed = iteratee(value, index, array),
              type = data.type;

            if (type == LAZY_MAP_FLAG) {
              value = computed;
            } else if (!computed) {
              if (type == LAZY_FILTER_FLAG) {
                continue outer;
              } else {
                break outer;
              }
            }
          }
          if (dropCount) {
            dropCount--;
          } else {
            result[resIndex++] = value;
          }
        }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Adds `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
        result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
        length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
        length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
        length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
        length = array.length,
        result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * A specialized version of `_.max` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     */
    function arrayMax(array) {
      var index = -1,
        length = array.length,
        result = NEGATIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value > result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.min` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     */
    function arrayMin(array) {
      var index = -1,
        length = array.length,
        result = POSITIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value < result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
        length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
        length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return typeof objectValue == 'undefined' ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This method is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize assigning values.
     * @returns {Object} Returns the destination object.
     */
    function baseAssign(object, source, customizer) {
      var props = keys(source);
      if (!customizer) {
        return baseCopy(source, object, props);
      }
      var index = -1,
        length = props.length;

      while (++index < length) {
        var key = props[index],
          value = object[key],
          result = customizer(value, source[key], key, object, source);

        if ((result === result ? result !== value : value === value) ||
          (typeof value == 'undefined' && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.at` without support for strings and individual
     * key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
        length = collection.length,
        isArr = isLength(length),
        propsLength = props.length,
        result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          key = parseFloat(key);
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = collection[key];
        }
      }
      return result;
    }

    /**
     * Copies the properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Array} props The property names to copy.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, object, props) {
      if (!props) {
        props = object;
        object = {};
      }
      var index = -1,
        length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.bindAll` without support for individual
     * method name arguments.
     *
     * @private
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {string[]} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     */
    function baseBindAll(object, methodNames) {
      var index = -1,
        length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return (typeof thisArg != 'undefined' && isBindable(func))
          ? bindCallback(func, thisArg, argCount)
          : func;
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return typeof thisArg == 'undefined'
        ? baseProperty(func + '')
        : baseMatchesProperty(func + '', thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (typeof result != 'undefined') {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
          isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseCopy(value, result, keys(value));
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function Object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object;
          Object.prototype = null;
        }
        return result || context.Object();
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The `arguments` object to slice and provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args, fromIndex) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
        result = [];

      if (!length) {
        return result;
      }
      var index = -1,
        indexOf = getIndexOf(),
        isCommon = indexOf == baseIndexOf,
        cache = (isCommon && values.length >= 200) ? createCache(values) : null,
        valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
        while (++index < length) {
          var value = array[index];

          if (isCommon && value === value) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === value) {
                continue outer;
              }
            }
            result.push(value);
          }
          else if (indexOf(values, value) < 0) {
            result.push(value);
          }
        }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    function baseEach(collection, iteratee) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        return baseForOwn(collection, iteratee);
      }
      var index = -1,
        iterable = toObject(collection);

      while (++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    }

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    function baseEachRight(collection, iteratee) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        return baseForOwnRight(collection, iteratee);
      }
      var iterable = toObject(collection);
      while (length--) {
        if (iteratee(iterable[length], length, iterable) === false) {
          break;
        }
      }
      return collection;
    }

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end >>> 0;
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
        length = array.length,
        resIndex = -1,
        result = [];

      while (++index < length) {
        var value = array[index];

        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            value = baseFlatten(value, isDeep, isStrict);
          }
          var valIndex = -1,
            valLength = value.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[++resIndex] = value[valIndex];
          }
        } else if (!isStrict) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iterator functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    function baseFor(object, iteratee, keysFunc) {
      var index = -1,
        iterable = toObject(object),
        props = keysFunc(object),
        length = props.length;

      while (++index < length) {
        var key = props[index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    function baseForRight(object, iteratee, keysFunc) {
      var iterable = toObject(object),
        props = keysFunc(object),
        length = props.length;

      while (length--) {
        var key = props[length];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
        length = props.length,
        resIndex = -1,
        result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invoke` which requires additional arguments
     * to be provided as an array of arguments rather than individually.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {Array} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     */
    function baseInvoke(collection, methodName, args) {
      var index = -1,
        isFunc = typeof methodName == 'function',
        length = collection ? collection.length : 0,
        result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? methodName : (value != null && value[methodName]);
        result[++index] = func ? func.apply(value, args) : undefined;
      });
      return result;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
      // Exit early for identical values.
      if (value === other) {
        // Treat `+0` vs. `-0` as not equal.
        return value !== 0 || (1 / value == 1 / other);
      }
      var valType = typeof value,
        othType = typeof other;

      // Exit early for unlike primitive values.
      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
        value == null || other == null) {
        // Return `false` unless both values are `NaN`.
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = arrayTag,
        othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (valWrapped || othWrapped) {
        return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The source property names to match.
     * @param {Array} values The source values to match.
     * @param {Array} strictCompareFlags Strict comparison flags for source values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      var index = -1,
        noCustomizer = !customizer;

      while (++index < length) {
        if ((noCustomizer && strictCompareFlags[index])
            ? values[index] !== object[props[index]]
            : !hasOwnProperty.call(object, props[index])
        ) {
          return false;
        }
      }
      index = -1;
      while (++index < length) {
        var key = props[index];
        if (noCustomizer && strictCompareFlags[index]) {
          var result = hasOwnProperty.call(object, key);
        } else {
          var objValue = object[key],
            srcValue = values[index];

          result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (typeof result == 'undefined') {
            result = baseIsEqual(srcValue, objValue, customizer, true);
          }
        }
        if (!result) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var result = [];
      baseEach(collection, function(value, key, collection) {
        result.push(iteratee(value, key, collection));
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var props = keys(source),
        length = props.length;

      if (length == 1) {
        var key = props[0],
          value = source[key];

        if (isStrictComparable(value)) {
          return function(object) {
            return object != null && object[key] === value && hasOwnProperty.call(object, key);
          };
        }
      }
      var values = Array(length),
        strictCompareFlags = Array(length);

      while (length--) {
        value = source[props[length]];
        values[length] = value;
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return function(object) {
        return baseIsMatch(object, props, values, strictCompareFlags);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not coerce `key`
     * to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(key, value) {
      if (isStrictComparable(value)) {
        return function(object) {
          return object != null && object[key] === value;
        };
      }
      return function(object) {
        return object != null && baseIsEqual(value, object[key], null, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns the destination object.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = typeof result == 'undefined';

        if (isCommon) {
          result = srcValue;
        }
        if ((isSrcArr || typeof result != 'undefined') &&
          (isCommon || (result === result ? result !== value : value === value))) {
          object[key] = result;
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
        srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
        result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
        isCommon = typeof result == 'undefined';

      if (isCommon) {
        result = srcValue;
        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (value ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? result !== value : value === value) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` which does not coerce `key` to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     */
    function basePullAt(array, indexes) {
      var length = indexes.length,
        result = baseAt(array, indexes);

      indexes.sort(baseCompareAscending);
      while (length--) {
        var index = parseFloat(indexes[length]);
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands or `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
        length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end - start) >>> 0;
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
        indexOf = getIndexOf(),
        length = array.length,
        isCommon = indexOf == baseIndexOf,
        isLarge = isCommon && length >= 200,
        seen = isLarge ? createCache() : null,
        result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

          if (isCommon && value === value) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          }
          else if (indexOf(seen, computed) < 0) {
            if (iteratee || isLarge) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * returned by `keysFunc`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
        length = props.length,
        result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved unwrapped value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
        length = actions.length;

      while (++index < length) {
        var args = [result],
          action = actions[index];

        push.apply(args, action.args);
        result = action.func.apply(action.thisArg, args);
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest, instead
     *  of the lowest, index at which a value should be inserted into `array`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
        high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
            computed = array[mid];

          if (retHighest ? (computed <= value) : (computed < value)) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest, instead
     *  of the lowest, index at which a value should be inserted into `array`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
        high = array ? array.length : 0,
        valIsNaN = value !== value,
        valIsUndef = typeof value == 'undefined';

      while (low < high) {
        var mid = floor((low + high) / 2),
          computed = iteratee(array[mid]),
          isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || typeof computed != 'undefined');
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (typeof thisArg == 'undefined') {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      return bufferSlice.call(buffer, 0);
    }
    if (!bufferSlice) {
      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
        var byteLength = buffer.byteLength,
          floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
          offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
          result = new ArrayBuffer(byteLength);

        if (floatLength) {
          var view = new Float64Array(result, 0, floatLength);
          view.set(new Float64Array(buffer, 0, floatLength));
        }
        if (byteLength != offset) {
          view = new Uint8Array(result, offset);
          view.set(new Uint8Array(buffer, offset));
        }
        return result;
      };
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
        argsIndex = -1,
        argsLength = nativeMax(args.length - holdersLength, 0),
        leftIndex = -1,
        leftLength = partials.length,
        result = Array(argsLength + leftLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
        holdersLength = holders.length,
        argsIndex = -1,
        argsLength = nativeMax(args.length - holdersLength, 0),
        rightIndex = -1,
        rightLength = partials.length,
        result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var pad = argsIndex;
      while (++rightIndex < rightLength) {
        result[pad + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[pad + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an accumulator
     * object composed from the results of running each element in the collection
     * through an iteratee.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
            length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that assigns properties of source object(s) to a given
     * destination object.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return function() {
        var length = arguments.length,
          object = arguments[0];

        if (length < 2 || object == null) {
          return object;
        }
        if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
          length = 2;
        }
        // Juggle arguments.
        if (length > 3 && typeof arguments[length - 2] == 'function') {
          var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
        } else if (length > 2 && typeof arguments[length - 1] == 'function') {
          customizer = arguments[--length];
        }
        var index = 0;
        while (++index < length) {
          var source = arguments[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
      return new SetCache(values);
    };

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
          array = words(deburr(string)),
          length = array.length,
          result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        var thisBinding = baseCreate(Ctor.prototype),
          result = Ctor.apply(thisBinding, arguments);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that gets the extremum value of a collection.
     *
     * @private
     * @param {Function} arrayFunc The function to get the extremum value from an array.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,
     *  extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(arrayFunc, isMin) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = null;
        }
        var func = getCallback(),
          noIteratee = iteratee == null;

        if (!(func === baseCallback && noIteratee)) {
          noIteratee = false;
          iteratee = func(iteratee, thisArg, 3);
        }
        if (noIteratee) {
          var isArr = isArray(collection);
          if (!isArr && isString(collection)) {
            iteratee = charAtCallback;
          } else {
            return arrayFunc(isArr ? collection : toIterable(collection));
          }
        }
        return extremumBy(collection, iteratee, isMin);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
        isBind = bitmask & BIND_FLAG,
        isBindKey = bitmask & BIND_KEY_FLAG,
        isCurry = bitmask & CURRY_FLAG,
        isCurryBound = bitmask & CURRY_BOUND_FLAG,
        isCurryRight = bitmask & CURRY_RIGHT_FLAG;

      var Ctor = !isBindKey && createCtorWrapper(func),
        key = func;

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
          index = length,
          args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
            argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : null,
              newArity = nativeMax(arity - length, 0),
              newsHolders = isCurry ? argsHolders : null,
              newHoldersRight = isCurry ? null : argsHolders,
              newPartials = isCurry ? args : null,
              newPartialsRight = isCurry ? null : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this;
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the pad required for `string` based on the given padding length.
     * The `chars` string may be truncated if the number of padding characters
     * exceeds the padding length.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPad(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
        Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
          argsLength = arguments.length,
          leftIndex = -1,
          leftLength = partials.length,
          args = Array(argsLength + leftLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = null;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
          holdersRight = holders;

        partials = holders = null;
      }
      var data = !isBindKey && getData(func),
        newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data && data !== true) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var index = -1,
        arrLength = array.length,
        othLength = other.length,
        result = true;

      if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
        return false;
      }
      // Deep compare the contents, ignoring non-numeric properties.
      while (result && ++index < arrLength) {
        var arrValue = array[index],
          othValue = other[index];

        result = undefined;
        if (customizer) {
          result = isWhere
            ? customizer(othValue, arrValue, index)
            : customizer(arrValue, othValue, index);
        }
        if (typeof result == 'undefined') {
          // Recursively compare arrays (susceptible to call stack limits).
          if (isWhere) {
            var othIndex = othLength;
            while (othIndex--) {
              othValue = other[othIndex];
              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
              if (result) {
                break;
              }
            }
          } else {
            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
          }
        }
      }
      return !!result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} value The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            // But, treat `-0` vs. `+0` as not equal.
            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;

      if (objLength != othLength && !isWhere) {
        return false;
      }
      var hasCtor,
        index = -1;

      while (++index < objLength) {
        var key = objProps[index],
          result = hasOwnProperty.call(other, key);

        if (result) {
          var objValue = object[key],
            othValue = other[key];

          result = undefined;
          if (customizer) {
            result = isWhere
              ? customizer(othValue, objValue, key)
              : customizer(objValue, othValue, key);
          }
          if (typeof result == 'undefined') {
            // Recursively compare objects (susceptible to call stack limits).
            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
          }
        }
        if (!result) {
          return false;
        }
        hasCtor || (hasCtor = key == 'constructor');
      }
      if (!hasCtor) {
        var objCtor = object.constructor,
          othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments; (value, index, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the
     *  maximum, extremum value.
     * @returns {*} Returns the extremum value.
     */
    function extremumBy(collection, iteratee, isMin) {
      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
        computed = exValue,
        result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = iteratee(value, index, collection);
        if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} [transforms] The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
        length = transforms ? transforms.length : 0;

      while (++index < length) {
        var data = transforms[index],
          size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
        result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
        var buffer = object.buffer;
        return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Checks if `func` is eligible for `this` binding.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
     */
    function isBindable(func) {
      var support = lodash.support,
        result = !(support.funcNames ? func.name : support.funcDecomp);

      if (!result) {
        var source = fnToString.call(func);
        if (!support.funcNames) {
          result = !reFuncName.test(source);
        }
        if (!result) {
          // Check if `func` references the `this` keyword and store the result.
          result = reThis.test(source) || isNative(func);
          baseSetData(func, result);
        }
      }
      return result;
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = +value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number') {
        var length = object.length,
          prereq = isLength(length) && isIndex(index, length);
      } else {
        prereq = type == 'string' && index in object;
      }
      if (prereq) {
        var other = object[index];
        return value === value ? value === other : other !== other;
      }
      return false;
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on ES `ToLength`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
     * for more details.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
        srcBitmask = source[1],
        newBitmask = bitmask | srcBitmask;

      var arityFlags = ARY_FLAG | REARG_FLAG,
        bindFlags = BIND_FLAG | BIND_KEY_FLAG,
        comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

      var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
        isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
        argPos = (isRearg ? data : source)[7],
        ary = (isAry ? data : source)[8];

      var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
        !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

      var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
        (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties specified
     * by the `props` array.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
        length = props.length,
        result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
        length = nativeMin(indexes.length, arrLength),
        oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
        lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
          remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `_.isPlainObject` which checks if `value`
     * is an object created by the `Object` constructor or has a `[[Prototype]]`
     * of `null`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var Ctor,
        support = lodash.support;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
        (!hasOwnProperty.call(value, 'constructor') &&
        (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
        propsLength = props.length,
        length = propsLength && object.length,
        support = lodash.support;

      var allowIndexes = length && isLength(length) &&
        (isArray(object) || (support.nonEnumArgs && isArguments(object)));

      var index = -1,
        result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isLength(value.length)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(+size || 1, 1);
      }
      var index = 0,
        length = array ? array.length : 0,
        resIndex = -1,
        result = Array(ceil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
        length = array ? array.length : 0,
        resIndex = -1,
        result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    function difference() {
      var index = -1,
        length = arguments.length;

      while (++index < length) {
        var value = arguments[index];
        if (isArray(value) || isArguments(value)) {
          break;
        }
      }
      return baseDifference(value, baseFlatten(arguments, false, true, ++index));
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': pebbles, 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      predicate = getCallback(predicate, thisArg, 3);
      while (length-- && predicate(array[length], length, array)) {}
      return baseSlice(array, 0, length + 1);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var index = -1;
      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length && predicate(array[index], index, array)) {}
      return baseSlice(array, index);
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, thisArg) {
      var index = -1,
        length = array ? array.length : 0;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      predicate = getCallback(predicate, thisArg, 3);
      while (length--) {
        if (predicate(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]];
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4];
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4];
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
     * it is used as the offset from the end of `array`. If `array` is sorted
     * providing `true` for `fromIndex` performs a faster binary search.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      } else if (fromIndex) {
        var index = binaryIndex(array, value),
          other = array[index];

        return (value === value ? value === other : other !== other) ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values in all provided arrays using `SameValueZero`
     * for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    function intersection() {
      var args = [],
        argsIndex = -1,
        argsLength = arguments.length,
        caches = [],
        indexOf = getIndexOf(),
        isCommon = indexOf == baseIndexOf;

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
        }
      }
      argsLength = args.length;
      var array = args[0],
        index = -1,
        length = array ? array.length : 0,
        result = [],
        seen = caches[0];

      outer:
        while (++index < length) {
          value = array[index];
          if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {
            argsIndex = argsLength;
            while (--argsIndex) {
              var cache = caches[argsIndex];
              if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(value);
            }
            result.push(value);
          }
        }
      return result;
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        return (value === value ? value === other : other !== other) ? index : -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using `SameValueZero` for equality
     * comparisons.
     *
     * **Notes:**
     *  - Unlike `_.without`, this method mutates `array`.
     *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,
     *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     *    for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var array = arguments[0];
      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
        indexOf = getIndexOf(),
        length = arguments.length;

      while (++index < length) {
        var fromIndex = 0,
          value = arguments[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    function pullAt(array) {
      return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
    }

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var index = -1,
        length = array ? array.length : 0,
        result = [];

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This function is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    function sortedIndex(array, value, iteratee, thisArg) {
      var func = getCallback(iteratee);
      return (func === baseCallback && iteratee == null)
        ? binaryIndex(array, value)
        : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    function sortedLastIndex(array, value, iteratee, thisArg) {
      var func = getCallback(iteratee);
      return (func === baseCallback && iteratee == null)
        ? binaryIndex(array, value, true)
        : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      predicate = getCallback(predicate, thisArg, 3);
      while (length-- && predicate(array[length], length, array)) {}
      return baseSlice(array, length + 1);
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var index = -1;
      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length && predicate(array[index], index, array)) {}
      return baseSlice(array, 0, index);
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, false, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using `SameValueZero`
     * for equality comparisons. Providing `true` for `isSorted` performs a faster
     * search algorithm for sorted arrays. If an iteratee function is provided it
     * is invoked for each value in the array to generate the criterion by which
     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1]);
     * // => [1, 2]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
        isSorted = false;
      }
      var func = getCallback();
      if (!(func === baseCallback && iteratee == null)) {
        iteratee = func(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-`_.zip`
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      var index = -1,
        length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
        result = Array(length);

      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * Creates an array excluding all provided values using `SameValueZero` for
     * equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    function without(array) {
      return baseDifference(array, baseSlice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Symmetric_difference) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
        length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseDifference(result, array).concat(baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var length = arguments.length,
        array = Array(length);

      while (length--) {
        array[length] = arguments[length];
      }
      return unzip(array);
    }

    /**
     * Creates an object composed from arrays of property names and values. Provide
     * either a single two dimensional array, e.g. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of property names and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
        length = props ? props.length : 0,
        result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _([1, 2, 3])
     *  .last()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => [3]
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapper = wrapper.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapper.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapper = wrapper.plant(other);
     *
     * otherWrapper.value();
     * // => [9, 16]
     *
     * wrapper.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
        parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        if (this.__actions__.length) {
          value = new LazyWrapper(this);
        }
        return new LodashWrapper(value.reverse(), this.__chain__);
      }
      return this.thru(function(value) {
        return value.reverse();
      });
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var length = collection ? collection.length : 0;
      if (isLength(length)) {
        collection = toIterable(collection);
      }
      return baseAt(collection, baseFlatten(arguments, false, false, 1));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    function find(collection, predicate, thisArg) {
      if (isArray(collection)) {
        var index = findIndex(collection, predicate, thisArg);
        return index > -1 ? collection[index] : undefined;
      }
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(collection, predicate, baseEach);
    }

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(collection, predicate, baseEachRight);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Iterator functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    function forEach(collection, iteratee, thisArg) {
      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
        ? arrayEach(collection, iteratee)
        : baseEach(collection, bindCallback(iteratee, thisArg, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).join(',');
     * // => logs each value from right to left and returns the array
     */
    function forEachRight(collection, iteratee, thisArg) {
      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
        ? arrayEachRight(collection, iteratee)
        : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using `SameValueZero` for equality
     * comparisons. If `fromIndex` is negative, it is used as the offset from
     * the end of `collection`.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (!length) {
        return false;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      } else {
        fromIndex = 0;
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
        : (getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in `collection`,
     * returning an array of the results of each invoked method. Any additional
     * arguments are provided to each invoked method. If `methodName` is a function
     * it is invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      return baseInvoke(collection, methodName, baseSlice(arguments, 2));
    }

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
     * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,
     * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,
     * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     *  create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 };
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 };
     */
    var max = createExtremum(arrayMax);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 };
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 };
     */
    var min = createExtremum(arrayMin, true);

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1, 3], [2]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the value of `key` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} key The key of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, key) {
      return map(collection, baseProperty(key));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `merge`, and `sortAllBy`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator, thisArg) {
      var func = isArray(collection) ? arrayReduce : baseReduce;
      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator, thisArg) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce;
      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      collection = toIterable(collection);

      var index = -1,
        length = collection.length,
        result = Array(length);

      while (++index < length) {
        var rand = baseRandom(0, index);
        if (index != rand) {
          result[index] = result[rand];
        }
        result[rand] = collection[index];
      }
      return result;
    }

    /**
     * Gets the size of `collection` by returning `collection.length` for
     * array-like values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity] The function
     *  invoked per iteration. If a property name or an object is provided it is
     *  used to create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      var index = -1,
        length = collection ? collection.length : 0,
        result = isLength(length) ? Array(length) : [];

      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = null;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      baseEach(collection, function(value, key, collection) {
        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it sorts by property names
     * instead of an iteratee function.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(string|string[])} props The property names to sort by,
     *  specified as individual property names or arrays of property names.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 26 },
     *   { 'user': 'fred',   'age': 30 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortByAll(collection) {
      var args = arguments;
      if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {
        args = [collection, args[1]];
      }
      var index = -1,
        length = collection ? collection.length : 0,
        props = baseFlatten(args, false, false, 1),
        result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var length = props.length,
          criteria = Array(length);

        while (length--) {
          criteria[length] = value == null ? undefined : value[props[length]];
        }
        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };
      });
      return baseSortBy(result, compareMultipleAscending);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
        return new Date().getTime();
      };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = null;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, null, null, null, null, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        } else {
          func = null;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the `length`
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    function bind(func, thisArg) {
      var bitmask = BIND_FLAG;
      if (arguments.length > 2) {
        var partials = baseSlice(arguments, 2),
          holders = replaceHolders(partials, bind.placeholder);

        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the `length` property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    function bindAll(object) {
      return baseBindAll(object,
        arguments.length > 1
          ? baseFlatten(arguments, false, false, 1)
          : functions(object)
      );
    }

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (arguments.length > 2) {
        var partials = baseSlice(arguments, 2),
          holders = replaceHolders(partials, bindKey.placeholder);

        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    }

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      if (guard && isIterateeCall(func, arity, guard)) {
        arity = null;
      }
      var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      if (guard && isIterateeCall(func, arity, guard)) {
        arity = null;
      }
      var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a function that delays invoking `func` until after `wait` milliseconds
     * have elapsed since the last time it was invoked. The created function comes
     * with a `cancel` method to cancel delayed invocations. Provide an options
     * object to indicate that `func` should be invoked on the leading and/or
     * trailing edge of the `wait` timeout. Subsequent calls to the debounced
     * function return the result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
        maxTimeoutId,
        result,
        stamp,
        thisArg,
        timeoutId,
        trailingCall,
        lastCalled = 0,
        maxWait = false,
        trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
            isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      return baseDelay(func, 1, arguments, 1);
    }

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      return baseDelay(func, wait, arguments, 2);
    }

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function add(x, y) {
     *   return x + y;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(add, square);
     * addSquare(1, 2);
     * // => 9
     */
    function flow() {
      var funcs = arguments,
        length = funcs.length;

      if (!length) {
        return function() { return arguments[0]; };
      }
      if (!arrayEvery(funcs, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var index = 0,
          result = funcs[index].apply(this, arguments);

        while (++index < length) {
          result = funcs[index].call(this, result);
        }
        return result;
      };
    }

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function add(x, y) {
     *   return x + y;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, add);
     * addSquare(1, 2);
     * // => 9
     */
    function flowRight() {
      var funcs = arguments,
        fromIndex = funcs.length - 1;

      if (fromIndex < 0) {
        return function() { return arguments[0]; };
      }
      if (!arrayEvery(funcs, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var index = fromIndex,
          result = funcs[index].apply(this, arguments);

        while (index--) {
          result = funcs[index].call(this, result);
        }
        return result;
      };
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the ES `Map` method interface
     * of `get`, `has`, and `set`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var cache = memoized.cache,
          key = resolver ? resolver.apply(this, arguments) : arguments[0];

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, arguments);
        cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(func, 2);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    function partial(func) {
      var partials = baseSlice(arguments, 1),
        holders = replaceHolders(partials, partial.placeholder);

      return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
    }

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    function partialRight(func) {
      var partials = baseSlice(arguments, 1),
        holders = replaceHolders(partials, partialRight.placeholder);

      return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
    }

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    function rearg(func) {
      var indexes = baseFlatten(arguments, false, false, 1);
      return createWrapper(func, REARG_FLAG, null, null, null, indexes);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and the array of arguments provided to the created
     * function much like [Function#apply](http://es5.github.io/#x15.3.4.3).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {*} Returns the new function.
     * @example
     *
     * var spread = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * spread(['Fred', 'hello']);
     * // => 'Fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a function that only invokes `func` at most once per every `wait`
     * milliseconds. The created function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the throttled function return the result of the last
     * `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
        trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = +wait;
      debounceOptions.trailing = trailing;
      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the structured clone algorithm.
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, isDeep, customizer);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the structured clone algorithm.
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, true, customizer);
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      var length = isObjectLike(value) ? value.length : undefined;
      return (isLength(length) && objToString.call(value) == argsTag) || false;
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
        return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
      };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return (value && value.nodeType === 1 && isObjectLike(value) &&
        objToString.call(value).indexOf('Element') > -1) || false;
    }
    // Fallback for environments without DOM support.
    if (!support.dom) {
      isElement = function(value) {
        return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
      };
    }

    /**
     * Checks if a value is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      var length = value.length;
      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
        (isObjectLike(value) && isFunction(value.splice)))) {
        return !length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments; (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
        return value === other;
      }
      var result = customizer ? customizer(value, other) : undefined;
      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on ES `Number.isFinite`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    var isFinite = nativeNumIsFinite || function(value) {
        return typeof value == 'number' && nativeIsFinite(value);
      };

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return objToString.call(value) == funcTag;
    };

    /**
     * Checks if `value` is the language type of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return type == 'function' || (value && type == 'object') || false;
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments; (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      var props = keys(source),
        length = props.length;

      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && length == 1) {
        var key = props[0],
          value = source[key];

        if (isStrictComparable(value)) {
          return object != null && value === object[key] && hasOwnProperty.call(object, key);
        }
      }
      var values = Array(length),
        strictCompareFlags = Array(length);

      while (length--) {
        value = values[length] = source[props[length]];
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return baseIsMatch(object, props, values, strictCompareFlags, customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as native `isNaN` which returns `true`
     * for `undefined` and other non-numeric values. See the [ES5 spec](https://es5.github.io/#x15.1.2.4)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (objToString.call(value) == funcTag) {
        return reNative.test(fnToString.call(value));
      }
      return (isObjectLike(value) && reHostCtor.test(value)) || false;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && objToString.call(value) == objectTag)) {
        return false;
      }
      var valueOf = value.valueOf,
        objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? value.length : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments;
     * (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return typeof value == 'undefined' ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(baseAssign);

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = null;
      }
      return properties ? baseCopy(properties, result, keys(properties)) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property are ignored.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    function defaults(object) {
      if (object == null) {
        return object;
      }
      var args = arrayCopy(arguments);
      args.push(assignDefaults);
      return assign.apply(undefined, args);
    }

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element `predicate` returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(object, predicate, baseForOwn, true);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(object, predicate, baseForOwnRight, true);
    }

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments; (value, key, object). Iterator functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    function forIn(object, iteratee, thisArg) {
      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
        iteratee = bindCallback(iteratee, thisArg, 3);
      }
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    function forInRight(object, iteratee, thisArg) {
      iteratee = bindCallback(iteratee, thisArg, 3);
      return baseForRight(object, iteratee, keysIn);
    }

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments; (value, key, object). Iterator functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    function forOwn(object, iteratee, thisArg) {
      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
        iteratee = bindCallback(iteratee, thisArg, 3);
      }
      return baseForOwn(object, iteratee);
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    function forOwnRight(object, iteratee, thisArg) {
      iteratee = bindCallback(iteratee, thisArg, 3);
      return baseForRight(object, iteratee, keys);
    }

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Checks if `key` exists as a direct property of `object` instead of an
     * inherited property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {string} key The key to check.
     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 3 };
     *
     * _.has(object, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = null;
      }
      var index = -1,
        props = keys(object),
        length = props.length,
        result = {};

      while (++index < length) {
        var key = props[index],
          value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (object) {
        var Ctor = object.constructor,
          length = object.length;
      }
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
        (typeof object != 'function' && (length && isLength(length)))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
      (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

      var Ctor = object.constructor,
        index = -1,
        isProto = typeof Ctor == 'function' && Ctor.prototype === object,
        result = Array(length),
        skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
          !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee, thisArg) {
      var result = {};
      iteratee = getCallback(iteratee, thisArg, 3);

      baseForOwn(object, function(value, key, object) {
        result[key] = iteratee(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments; (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If `predicate` is provided it is invoked for each property
     * of `object` omitting the properties `predicate` returns truthy for. The
     * predicate is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    function omit(object, predicate, thisArg) {
      if (object == null) {
        return {};
      }
      if (typeof predicate != 'function') {
        var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      predicate = bindCallback(predicate, thisArg, 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    }

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      var index = -1,
        props = keys(object),
        length = props.length,
        result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    function pick(object, predicate, thisArg) {
      if (object == null) {
        return {};
      }
      return typeof predicate == 'function'
        ? pickByCallback(object, bindCallback(predicate, thisArg, 3))
        : pickByArray(object, baseFlatten(arguments, false, false, 1));
    }

    /**
     * Resolves the value of property `key` on `object`. If the value of `key` is
     * a function it is invoked with the `this` binding of `object` and its result
     * is returned, else the property value is returned. If the property value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to resolve.
     * @param {*} [defaultValue] The value returned if the property value
     *  resolves to `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'user': 'fred', 'age': _.constant(40) };
     *
     * _.result(object, 'user');
     * // => 'fred'
     *
     * _.result(object, 'age');
     * // => 40
     *
     * _.result(object, 'status', 'busy');
     * // => 'busy'
     *
     * _.result(object, 'status', _.constant('busy'));
     * // => 'busy'
     */
    function result(object, key, defaultValue) {
      var value = object == null ? undefined : object[key];
      if (typeof value == 'undefined') {
        value = defaultValue;
      }
      return isFunction(value) ? value.call(object) : value;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments; (accumulator, value, key, object). Iterator functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it defaults to `start` with `start` becoming `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (typeof end === 'undefined') {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= start && value < end;
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = null;
      }
      var noMin = min == null,
        noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to camel case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/CamelCase) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting latin-1 supplementary letters to basic latin letters.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter);
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and '`', in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't require escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
     *
     * When working with HTML you should always quote attribute values to reduce
     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
     * "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, '\\$&')
        : string;
    }

    /**
     * Converts `string` to kebab case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it is shorter then the given
     * padding length. The `chars` string may be truncated if the number of padding
     * characters can't be evenly divided by the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
        leftLength = floor(mid),
        rightLength = ceil(mid);

      chars = createPad('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    function padLeft(string, length, chars) {
      string = baseToString(string);
      return string && (createPad(string, length, chars) + string);
    }

    /**
     * Pads `string` on the right side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    function padRight(string, length, chars) {
      string = baseToString(string);
      return string && (string + createPad(string, length, chars));
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the ES5 implementation of `parseInt`.
     * See the [ES5 spec](https://es5.github.io/#E) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard && isIterateeCall(string, radix, guard)) {
        radix = 0;
      }
      return nativeParseInt(string, radix);
    }
    // Fallback for environments with pre-ES5 implementations.
    if (nativeParseInt(whitespace + '08') != 8) {
      parseInt = function(string, radix, guard) {
        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
        // Chrome fails to trim leading <BOM> whitespace characters.
        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        string = trim(string);
        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
      };
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = floor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to snake case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Snake_case) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to start case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes sourceURLs for easier debugging.
     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for more details.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = null;
      }
      string = baseToString(string);
      options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
        importsKeys = keys(imports),
        importsValues = baseValues(imports, importsKeys);

      var isEscaping,
        isEvaluating,
        index = 0,
        interpolate = options.interpolate || reNoMatch,
        source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
        , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
      (variable
        ? ''
        : 'obj || (obj = {});\n'
      ) +
      "var __t, __p = ''" +
      (isEscaping
        ? ', __e = _.escape'
        : ''
      ) +
      (isEvaluating
        ? ', __j = Array.prototype.join;\n' +
      "function print() { __p += __j.call(arguments, '') }\n"
        : ';\n'
      ) +
      source +
      'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar]
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it is longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * //=> 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = null;
      }
      var length = DEFAULT_TRUNC_LENGTH,
        omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? +options.length || 0 : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
            newEnd,
            substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = null;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    function attempt() {
      var length = arguments.length,
        func = arguments[0];

      try {
        var args = Array(length ? length - 1 : 0);
        while (--length > 0) {
          args[length - 1] = arguments[length];
        }
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = null;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function which performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function which compares the property value of `key` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred', 'age': 40 }
     */
    function matchesProperty(key, value) {
      return baseMatchesProperty(key + '', baseClone(value, true));
    }

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=this] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * // use `_.runInContext` to avoid potential conflicts (esp. in Node.js)
     * var _ = require('lodash').runInContext();
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
          props = isObj && keys(source),
          methodNames = props && props.length && baseFunctions(source, props);

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
        index = -1,
        isFunc = isFunction(object),
        length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
          func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__);
                (result.__actions__ = arrayCopy(this.__actions__)).push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              var args = [this.value()];
              push.apply(args, arguments);
              return func.apply(object, args);
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function which returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function which returns the property value of `key` on a given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'barney' }
     * ];
     *
     * var getName = _.property('user');
     *
     * _.map(users, getName);
     * // => ['fred', barney']
     *
     * _.pluck(_.sortBy(users, getName), 'user');
     * // => ['barney', 'fred']
     */
    function property(key) {
      return baseProperty(key + '');
    }

    /**
     * The inverse of `_.property`; this method creates a function which returns
     * the property value of a given key on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to inspect.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'a': 3, 'b': 1, 'c': 2 };
     *
     * _.map(['a', 'c'], _.propertyOf(object));
     * // => [3, 2]
     *
     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));
     * // => ['b', 'c', 'a']
     */
    function propertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it
     * defaults to `start` with `start` becoming `0`. If `start` is less than
     * `end` a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = null;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
        length = nativeMax(ceil((end - start) / (step || 1)), 0),
        result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = +n;

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
        result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var isFilter = index == LAZY_FILTER_FLAG || index == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone(),
          iteratees = result.__iteratees__ || (result.__iteratees__ = []);

        result.__filtered__ = result.__filtered__ || isFilter;
        iteratees.push({ 'iteratee': getCallback(iteratee, thisArg, 3), 'type': index });
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      var countName = '__' + methodName + 'Count__',
        whileName = methodName + 'While';

      LazyWrapper.prototype[methodName] = function(n) {
        n = n == null ? 1 : nativeMax(floor(n) || 0, 0);

        var result = this.clone();
        if (result.__filtered__) {
          var value = result[countName];
          result[countName] = index ? nativeMin(value, n) : (value + n);
        } else {
          var views = result.__views__ || (result.__views__ = []);
          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };

      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
        return this.reverse()[whileName](predicate, thisArg).reverse();
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
        createCallback = index ? baseMatches : baseProperty;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.dropWhile = function(predicate, thisArg) {
      var done,
        lastIndex,
        isRight = this.__dir__ < 0;

      predicate = getCallback(predicate, thisArg, 3);
      return this.filter(function(value, index, array) {
        done = done && (isRight ? index < lastIndex : index > lastIndex);
        lastIndex = index;
        return done || (done = !predicate(value, index, array));
      });
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return this.filter(function(value, index, array) {
        return !predicate(value, index, array);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);
      var result = start < 0 ? this.takeRight(-start) : this.drop(start);

      if (typeof end != 'undefined') {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.toArray = function() {
      return this.drop(0);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName],
        retUnwrapped = /^(?:first|last)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
          args = arguments,
          chainAll = this.__chain__,
          isHybrid = !!this.__actions__.length,
          isLazy = value instanceof LazyWrapper,
          onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          return onlyLazy
            ? func.call(value)
            : lodashFunc.call(lodash, this.value());
        }
        var interceptor = function(value) {
          var otherArgs = [value];
          push.apply(otherArgs, args);
          return lodashFunc.apply(lodash, otherArgs);
        };
        if (isLazy || isArray(value)) {
          var wrapper = onlyLazy ? value : new LazyWrapper(this),
            result = func.apply(wrapper, args);

          if (!retUnwrapped && (isHybrid || result.__actions__)) {
            var actions = result.__actions__ || (result.__actions__ = []);
            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
          }
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array.prototype` functions to `lodash.prototype`.
    arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
        chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
        retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define('lodash',[],function() {
      return _;
    });
  }
}.call(this));

/**
 * machina - A library for creating powerful and flexible finite state machines. Loosely inspired by Erlang/OTP's gen_fsm behavior.
 * Author: Jim Cowart (http://ifandelse.com)
 * Version: v1.1.2
 * Url: http://machina-js.org/
 * License(s): MIT, GPL
 */

( function( root, factory ) {
  /* istanbul ignore if  */
  if ( typeof define === "function" && define.amd ) {
    // AMD. Register as an anonymous module.
    define( 'machina',[ "lodash" ], function( _ ) {
      return factory( _, root );
    } );
    /* istanbul ignore else  */
  } else if ( typeof module === "object" && module.exports ) {
    // Node, or CommonJS-Like environments
    module.exports = factory( require( "lodash" ) );
  } else {
    // Browser globals
    root.machina = factory( root._, root );
  }
}( this, function( _, global, undefined ) {
  var slice = [].slice;
  var NEXT_TRANSITION = "transition";
  var HANDLING = "handling";
  var HANDLED = "handled";
  var NO_HANDLER = "nohandler";
  var TRANSITION = "transition";
  var INVALID_STATE = "invalidstate";
  var DEFERRED = "deferred";
  var NEW_FSM = "newfsm";

  function getDefaultBehavioralOptions() {
    return {
      initialState: "uninitialized",
      eventListeners: {
        "*": []
      },
      states: {},
      namespace: utils.makeFsmNamespace(),
      useSafeEmit: false,
      hierarchy: {},
      pendingDelegations: {}
    };
  }

  function getDefaultClientMeta() {
    return {
      inputQueue: [],
      targetReplayState: "",
      state: undefined,
      priorState: undefined,
      priorAction: "",
      currentAction: "",
      currentActionArgs: undefined,
      inExitHandler: false
    };
  }

  function getLeaklessArgs( args, startIdx ) {
    var result = [];
    for ( var i = ( startIdx || 0 ); i < args.length; i++ ) {
      result[ i ] = args[ i ];
    }
    return result;
  }

  function getChildFsmInstance( config ) {
    if ( !config ) {
      return;
    }
    var childFsmDefinition = {};
    if ( typeof config === "object" ) {
      // is this a config object with a factory?
      if ( config.factory ) {
        childFsmDefinition = config;
      } else {
        // assuming this is a machina instance
        childFsmDefinition.factory = function() {
          return config;
        };
      }
    } else if ( typeof config === "function" ) {
      childFsmDefinition.factory = config;
    }
    childFsmDefinition.instance = childFsmDefinition.factory();
    return childFsmDefinition;
  }

  function listenToChild( fsm, child ) {
    return child.on( "*", function( eventName, data ) {
      switch ( eventName ) {
        case "nohandler":
          if ( !data.ticket && !data.delegated && data.namespace !== fsm.namespace ) {
            // Ok - we're dealing w/ a child handling input that should bubble up
            data.args[ 1 ].bubbling = true;
          }
          // we do NOT bubble _reset inputs up to the parent
          if ( data.inputType !== "_reset" ) {
            fsm.handle.apply( fsm, data.args );
          }
          break;
        case "handling" :
          var ticket = data.ticket;
          if ( ticket && fsm.pendingDelegations[ ticket ] ) {
            delete fsm.pendingDelegations[ ticket ];
          }
          fsm.emit( eventName, data ); // possibly transform payload?
          break;
        default:
          fsm.emit( eventName, data ); // possibly transform payload?
          break;
      }
    } );
  }

  // _machKeys are members we want to track across the prototype chain of an extended FSM constructor
  // Since we want to eventually merge the aggregate of those values onto the instance so that FSMs
  // that share the same extended prototype won't share state *on* those prototypes.
  var _machKeys = [ "states", "initialState" ];
  var extend = function( protoProps, staticProps ) {
    var parent = this;
    var fsm; // placeholder for instance constructor
    var machObj = {}; // object used to hold initialState & states from prototype for instance-level merging
    var Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if ( protoProps && protoProps.hasOwnProperty( "constructor" ) ) {
      fsm = protoProps.constructor;
    } else {
      // The default machina constructor (when using inheritance) creates a
      // deep copy of the states/initialState values from the prototype and
      // extends them over the instance so that they'll be instance-level.
      // If an options arg (args[0]) is passed in, a states or intialState
      // value will be preferred over any data pulled up from the prototype.
      fsm = function() {
        var args = slice.call( arguments, 0 );
        args[ 0 ] = args[ 0 ] || {};
        var blendedState;
        var instanceStates = args[ 0 ].states || {};
        blendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );
        blendedState.initialState = args[ 0 ].initialState || this.initialState;
        _.extend( args[ 0 ], blendedState );
        parent.apply( this, args );
      };
    }

    // Inherit class (static) properties from parent.
    _.merge( fsm, parent );

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    Ctor.prototype = parent.prototype;
    fsm.prototype = new Ctor();

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if ( protoProps ) {
      _.extend( fsm.prototype, protoProps );
      _.merge( machObj, _.transform( protoProps, function( accum, val, key ) {
        if ( _machKeys.indexOf( key ) !== -1 ) {
          accum[ key ] = val;
        }
      } ) );
    }

    // Add static properties to the constructor function, if supplied.
    if ( staticProps ) {
      _.merge( fsm, staticProps );
    }

    // Correctly set child's `prototype.constructor`.
    fsm.prototype.constructor = fsm;

    // Set a convenience property in case the parent's prototype is needed later.
    fsm.__super__ = parent.prototype;
    return fsm;
  };

  function createUUID() {
    var s = [];
    var hexDigits = "0123456789abcdef";
    for ( var i = 0; i < 36; i++ ) {
      s[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );
    }
    s[ 14 ] = "4"; // bits 12-15 of the time_hi_and_version field to 0010

    s[ 19 ] = hexDigits.substr( ( s[ 19 ] & 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01

    s[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = "-";
    return s.join( "" );
  }

  var utils = {
    makeFsmNamespace: ( function() {
      var machinaCount = 0;
      return function() {
        return "fsm." + machinaCount++;
      };
    } )(),
    listenToChild: listenToChild,
    getLeaklessArgs: getLeaklessArgs,
    getDefaultOptions: getDefaultBehavioralOptions,
    getDefaultClientMeta: getDefaultClientMeta,
    createUUID: createUUID
  };

  var emitter = {

    emit: function( eventName ) {
      var args = getLeaklessArgs( arguments );
      if ( this.eventListeners[ "*" ] ) {
        _.each( this.eventListeners[ "*" ], function( callback ) {
          if ( !this.useSafeEmit ) {
            callback.apply( this, args );
          } else {
            try {
              callback.apply( this, args );
            } catch ( exception ) {
              /* istanbul ignore else  */
              if ( console && typeof console.log !== "undefined" ) {
                console.log( exception.stack );
              }
            }
          }
        }, this );
      }
      if ( this.eventListeners[ eventName ] ) {
        _.each( this.eventListeners[ eventName ], function( callback ) {
          if ( !this.useSafeEmit ) {
            callback.apply( this, args.slice( 1 ) );
          } else {
            try {
              callback.apply( this, args.slice( 1 ) );
            } catch ( exception ) {
              /* istanbul ignore else  */
              if ( console && typeof console.log !== "undefined" ) {
                console.log( exception.stack );
              }
            }
          }
        }, this );
      }
    },

    on: function( eventName, callback ) {
      var self = this;
      self.eventListeners = self.eventListeners || { "*": [] };
      if ( !self.eventListeners[ eventName ] ) {
        self.eventListeners[ eventName ] = [];
      }
      self.eventListeners[ eventName ].push( callback );
      return {
        eventName: eventName,
        callback: callback,
        off: function() {
          self.off( eventName, callback );
        }
      };
    },

    off: function( eventName, callback ) {
      this.eventListeners = this.eventListeners || { "*": [] };
      if ( !eventName ) {
        this.eventListeners = {};
      } else {
        if ( callback ) {
          this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
        } else {
          this.eventListeners[ eventName ] = [];
        }
      }
    }
  };

  var MACHINA_PROP = "__machina__";

  function BehavioralFsm( options ) {
    _.extend( this, options );
    _.defaults( this, getDefaultBehavioralOptions() );
    this.initialize.apply( this, arguments );
    machina.emit( NEW_FSM, this );
  }

  _.extend( BehavioralFsm.prototype, {
    initialize: function() {},

    initClient: function initClient( client ) {
      var initialState = this.initialState;
      if ( !initialState ) {
        throw new Error( "You must specify an initial state for this FSM" );
      }
      if ( !this.states[ initialState ] ) {
        throw new Error( "The initial state specified does not exist in the states object." );
      }
      this.transition( client, initialState );
    },

    ensureClientMeta: function ensureClientMeta( client ) {
      if ( typeof client !== "object" ) {
        throw new Error( "An FSM client must be an object." );
      }
      client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
      if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
        client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );
        this.initClient( client );
      }
      return client[ MACHINA_PROP ][ this.namespace ];
    },

    buildEventPayload: function( client, data ) {
      if ( _.isPlainObject( data ) ) {
        return _.extend( data, { client: client, namespace: this.namespace } );
      } else {
        return { client: client, data: data || null, namespace: this.namespace };
      }
    },

    getHandlerArgs: function( args, isCatchAll ) {
      // index 0 is the client, index 1 is inputType
      // if we're in a catch-all handler, input type needs to be included in the args
      // inputType might be an object, so we need to just get the inputType string if so
      var _args = args.slice( 0 );
      var input = _args[ 1 ];
      if ( typeof input === "object" ) {
        _args.splice( 1, 1, input.inputType );
      }
      return isCatchAll ?
        _args :
        [ _args[ 0 ] ].concat( _args.slice( 2 ) );
    },

    handle: function( client, input ) {
      var inputDef = input;
      if ( typeof input === "undefined" ) {
        throw new Error( "The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?" );
      }
      if ( typeof input === "string" ) {
        inputDef = { inputType: input, delegated: false, ticket: undefined };
      }
      var clientMeta = this.ensureClientMeta( client );
      var args = getLeaklessArgs( arguments );
      if ( typeof input !== "object" ) {
        args.splice( 1, 1, inputDef );
      }
      clientMeta.currentActionArgs = args.slice( 1 );
      var currentState = clientMeta.state;
      var stateObj = this.states[ currentState ];
      var handlerName;
      var handler;
      var isCatchAll = false;
      var child;
      var result;
      var action;
      if ( !clientMeta.inExitHandler ) {
        child = stateObj._child && stateObj._child.instance;
        if ( child && !this.pendingDelegations[ inputDef.ticket ] && !inputDef.bubbling ) {
          inputDef.ticket = ( inputDef.ticket || utils.createUUID() );
          inputDef.delegated = true;
          this.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };
          // WARNING - returning a value from `handle` on child FSMs is not really supported.
          // If you need to return values from child FSM input handlers, use events instead.
          result = child.handle.apply( child, args );
        } else {
          if ( inputDef.ticket && this.pendingDelegations[ inputDef.ticket ] ) {
            delete this.pendingDelegations[ inputDef.ticket ];
          }
          handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : "*";
          isCatchAll = ( handlerName === "*" );
          handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ "*" ];
          action = clientMeta.state + "." + handlerName;
          clientMeta.currentAction = action;
          var eventPayload = this.buildEventPayload(
            client,
            { inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
          );
          if ( !handler ) {
            this.emit( NO_HANDLER, _.extend( { args: args }, eventPayload ) );
          } else {
            this.emit( HANDLING, eventPayload );
            if ( typeof handler === "function" ) {
              result = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );
            } else {
              result = handler;
              this.transition( client, handler );
            }
            this.emit( HANDLED, eventPayload );
          }
          clientMeta.priorAction = clientMeta.currentAction;
          clientMeta.currentAction = "";
        }
      }
      return result;
    },

    transition: function( client, newState ) {
      var clientMeta = this.ensureClientMeta( client );
      var curState = clientMeta.state;
      var curStateObj = this.states[ curState ];
      var newStateObj = this.states[ newState ];
      var child;
      if ( !clientMeta.inExitHandler && newState !== curState ) {
        if ( newStateObj ) {
          if ( newStateObj._child ) {
            newStateObj._child = getChildFsmInstance( newStateObj._child );
            child = newStateObj._child && newStateObj._child.instance;
          }
          if ( curStateObj && curStateObj._onExit ) {
            clientMeta.inExitHandler = true;
            curStateObj._onExit.call( this, client );
            clientMeta.inExitHandler = false;
          }
          if ( curStateObj && curStateObj._child && curStateObj._child.instance && this.hierarchy[ curStateObj._child.instance.namespace ] ) {
            this.hierarchy[ curStateObj._child.instance.namespace ].off();
          }
          clientMeta.targetReplayState = newState;
          clientMeta.priorState = curState;
          clientMeta.state = newState;
          if ( child ) {
            this.hierarchy[ child.namespace ] = utils.listenToChild( this, child );
          }
          var eventPayload = this.buildEventPayload( client, {
            fromState: clientMeta.priorState,
            action: clientMeta.currentAction,
            toState: newState
          } );
          this.emit( TRANSITION, eventPayload );
          if ( newStateObj._onEnter ) {
            newStateObj._onEnter.call( this, client );
          }
          if ( child ) {
            child.handle( client, "_reset" );
          }

          if ( clientMeta.targetReplayState === newState ) {
            this.processQueue( client, NEXT_TRANSITION );
          }
          return;
        }
        this.emit( INVALID_STATE, this.buildEventPayload( client, {
          state: clientMeta.state,
          attemptedState: newState
        } ) );
      }
    },

    deferUntilTransition: function( client, stateName ) {
      var clientMeta = this.ensureClientMeta( client );
      if ( clientMeta.currentActionArgs ) {
        var queued = {
          type: NEXT_TRANSITION,
          untilState: stateName,
          args: clientMeta.currentActionArgs
        };
        clientMeta.inputQueue.push( queued );
        var eventPayload = this.buildEventPayload( client, {
          state: clientMeta.state,
          queuedArgs: queued
        } );
        this.emit( DEFERRED, eventPayload );
      }
    },

    deferAndTransition: function( client, stateName ) {
      this.deferUntilTransition( client, stateName );
      this.transition( client, stateName );
    },

    processQueue: function( client ) {
      var clientMeta = this.ensureClientMeta( client );
      var filterFn = function( item ) {
        return ( ( !item.untilState ) || ( item.untilState === clientMeta.state ) );
      };
      var toProcess = _.filter( clientMeta.inputQueue, filterFn );
      clientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );
      _.each( toProcess, function( item ) {
        this.handle.apply( this, [ client ].concat( item.args ) );
      }, this );
    },

    clearQueue: function( client, name ) {
      var clientMeta = this.ensureClientMeta( client );
      if ( !name ) {
        clientMeta.inputQueue = [];
      } else {
        var filter = function( evnt ) {
          return ( name ? evnt.untilState !== name : true );
        };
        clientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );
      }
    },

    compositeState: function( client ) {
      var clientMeta = this.ensureClientMeta( client );
      var state = clientMeta.state;
      var child = this.states[state]._child && this.states[state]._child.instance;
      if ( child ) {
        state += "." + child.compositeState( client );
      }
      return state;
    }
  }, emitter );

  BehavioralFsm.extend = extend;

  var Fsm = {
    constructor: function() {
      BehavioralFsm.apply( this, arguments );
      this.ensureClientMeta();
    },
    initClient: function initClient() {
      var initialState = this.initialState;
      if ( !initialState ) {
        throw new Error( "You must specify an initial state for this FSM" );
      }
      if ( !this.states[ initialState ] ) {
        throw new Error( "The initial state specified does not exist in the states object." );
      }
      this.transition( initialState );
    },
    ensureClientMeta: function ensureClientMeta() {
      if ( !this._stamped ) {
        this._stamped = true;
        _.defaults( this, _.cloneDeep( getDefaultClientMeta() ) );
        this.initClient();
      }
      return this;
    },

    ensureClientArg: function( args ) {
      var _args = args;
      // we need to test the args and verify that if a client arg has
      // been passed, it must be this FSM instance (this isn't a behavioral FSM)
      if ( typeof _args[ 0 ] === "object" && !( "inputType" in _args[ 0 ] ) && _args[ 0 ] !== this ) {
        _args.splice( 0, 1, this );
      } else if ( typeof _args[ 0 ] !== "object" || ( typeof _args[ 0 ] === "object" && ( "inputType" in _args[ 0 ] ) ) ) {
        _args.unshift( this );
      }
      return _args;
    },

    getHandlerArgs: function( args, isCatchAll ) {
      // index 0 is the client, index 1 is inputType
      // if we're in a catch-all handler, input type needs to be included in the args
      // inputType might be an object, so we need to just get the inputType string if so
      var _args = args;
      var input = _args[ 1 ];
      if ( typeof inputType === "object" ) {
        _args.splice( 1, 1, input.inputType );
      }
      return isCatchAll ?
        _args.slice( 1 ) :
        _args.slice( 2 );
    },
    // "classic" machina FSM do not emit the client property on events (which would be the FSM itself)
    buildEventPayload: function() {
      var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
      var data = args[ 1 ];
      if ( _.isPlainObject( data ) ) {
        return _.extend( data, { namespace: this.namespace } );
      } else {
        return { data: data || null, namespace: this.namespace };
      }
    }
  };

  _.each( [
    "handle",
    "transition",
    "deferUntilTransition",
    "processQueue",
    "clearQueue"
  ], function( methodWithClientInjected ) {
    Fsm[methodWithClientInjected] = function() {
      var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
      return BehavioralFsm.prototype[methodWithClientInjected].apply( this, args );
    };
  } );

  Fsm = BehavioralFsm.extend( Fsm );

  var machina = _.merge( emitter, {
    Fsm: Fsm,
    BehavioralFsm: BehavioralFsm,
    utils: utils,
    eventListeners: {
      newFsm: []
    }
  } );

  return machina;
} ) );

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/browser',[
  'underscore'
],
function(_) {
  var browser = {
    isFirefox: _(window.InstallTrigger).isObject(),
    isIE: _(document.documentMode).isNumber(),
    isChrome: _(window.chrome).isObject() && _(window.chrome.webstore).isObject(),
    isSafari: Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0,
    // IE 11 doesn't provide window.location.origin
    origin: window.location.protocol + '//' + window.location.hostname +
                (window.location.port ? ':' + window.location.port: '')
  };

  if (browser.isFirefox) {
    browser.info = "Firefox";
  }
  else if (browser.isIE) {
    browser.info = "Internet Explorer";
  }
  else if (browser.isChrome) {
    browser.info = "Chrome";
  }
  else if (browser.isSafari) {
    browser.info = "Safari";
  }

  browser.info = (browser.info ? browser.info + ' [' + navigator.userAgent + ']' : 'unknown');

  return browser;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/object',[
  'underscore'
],
function(_) {
  var Object = function () {
    this._destructors = [];

    if (_(this._init).isFunction()) {
      this._init.apply(this, arguments);
    }
  };

  Object.extend = function (protoProps, staticProps) {
    var Super = this;
    var Sub = function () { Super.apply(this, arguments); };

    _(Sub).extend(Super, staticProps);

    var SuperClone = function () {};
    SuperClone.prototype = Super.prototype;
    Sub.prototype = new SuperClone();

    _(Sub.prototype).extend(protoProps);
    Sub.prototype._super = Super.prototype;

    return Sub;
  };

  Object.mixin = function (protoProps, staticProps) {
    _(this.prototype).extend(protoProps);
    _(this).extend(staticProps || {});
  };

  Object.mixin({
    bind: function (f) {
      return _.bind(f, this);
    },

    cb: function (f) {
      return this.bind(function () {
        return (this._destroyed ? undefined : f.apply(this, arguments));
      });
    },

    destroy: function () {
      _.each(this._destructors, function (destructor) {
        destructor();
      });
    }
  });

  return Object;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/message',[
  'f9phone/object',
  'underscore'
],
function(Object, _) {
  var MessageType = {
    isResponse: function (raw) {
      return !_(raw.response).isUndefined();
    },

    isEvent: function (raw) {
      return !_(raw.event).isUndefined();
    },

    isError: function (raw) {
      return !_(raw.error).isUndefined();
    },

    isCommunicatonError: function (raw) {
      return !_(raw.communicationError).isUndefined();
    },

    isConnected: function (raw) {
      return _.isString(raw) && raw.indexOf('connected:') === 0;
    }
  };

  var Message = Object.extend({
    _init: function (raw) {
      this._type = 'unknown';

      if (MessageType.isResponse(raw)) {
        this._type = 'response';
        this._id = raw.id;
        this._data = raw.response;
      }
      else if (MessageType.isEvent(raw)) {
        this._type = 'event';
        this._data = raw.event;
      }
      else if (MessageType.isError(raw)) {
        this._type = 'error';
        this._id = raw.id;
        this._data = raw.error;
      }
      else if (MessageType.isCommunicatonError(raw)) {
        this._type = 'communication:error';
        this._data = raw.communicationError;
      }
      else if (MessageType.isConnected(raw)) {
        this._type = 'connected';
        this._data = raw.slice('connected:'.length);
      }
    },

    data: function () {
      return this._data;
    },

    id: function () {
      return this._id;
    },

    type: function () {
      return this._type;
    }
  });

  return Message;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/events',[
  'underscore'
],
function(_) {
  var isCallbackEqualToFn = function (cb, fn) {
    return (cb.fn === fn || (cb.fn.originalFn && cb.fn.originalFn === fn));
  };

  var isCallbackInContext = function (cb, ctx) {
    return cb.ctx === ctx;
  };

  var removeCallbacks = function (callbacks, name, fn, ctx) {
    var liveCallbacks = [];
    var eventCallbacks = callbacks[name];

    if (fn || ctx) {
      for (var it = 0; it < eventCallbacks.length; ++it) {
        var cb = eventCallbacks[it];
        var sameFn = isCallbackEqualToFn(cb,fn);
        var sameCtx = isCallbackInContext(cb, ctx);
        var isCbForRemoval = (fn && ctx && sameFn && sameCtx) || (fn && !ctx && sameFn) || (!fn && ctx && sameCtx);

        if (!isCbForRemoval) {
          liveCallbacks.push(cb);
        }
      }
    }

    if (liveCallbacks.length === 0) {
      delete  callbacks[name];
    }
    else {
      callbacks[name] = liveCallbacks;
    }
  };

  var callbackExists = function (callbacks, fn, ctx) {
    var ret = false;

    for (var it = 0; !ret && it < callbacks.length; ++it) {
      var cb = callbacks[it];
      ret = isCallbackEqualToFn(cb, fn) && isCallbackInContext(cb, ctx);
    }

    return ret;
  };

  var contextExists = function(callbacks, ctx) {
    var ret = false;

    for (var it = 0; !ret && it < callbacks.length; ++it) {
      ret = isCallbackInContext(callbacks[it], ctx);
    }

    return ret;
  };

  var createEventsQueue = function () {
    return {
      queue: [],
      callbacks: {}
    };
  };

  var registerListenedObject = function (listener, listened) {
    var listeningTo = listener._listeningTo = listener._listeningTo || {};
    var id = listened._listenerId = listened._listenerId || _.uniqueId('f9listener');
    listeningTo[id] = listened;
  };

  var Events = {};

  Events.on = function (name, fn, ctx) {
    var events = this._events = this._events || createEventsQueue();
    var eventCallbacks = events.callbacks[name] = events.callbacks[name] || [];

    if (!callbackExists(eventCallbacks, fn, ctx)) {
      eventCallbacks.push({
        fn: fn,
        ctx: ctx
      });
    }

    return this;
  };

  Events.once = function (name, fn, ctx) {
    var that = this;
    var wrappedFn = function () {
      that.off(name, fn, ctx);
      fn.apply(ctx, arguments);
    };

    wrappedFn.originalFn = fn;

    return this.on(name, wrappedFn, ctx);
  };

  Events.off = function (name, fn, ctx) {
    var events = this._events;

    if (events) {
      if (!name && !fn && !ctx) {
        delete this._events;
      }
      else if (name && events.callbacks[name]) {
        removeCallbacks(events.callbacks, name, fn, ctx);
      }
      else if (!name) {
        var keys = Object.keys(events.callbacks);

        for (var it = 0; it < keys.length; ++it) {
          removeCallbacks(events.callbacks, keys[it], fn, ctx);
        }
      }
    }
  };

  Events.trigger = function (name) {
    var events = this._events;

    if (events && events.callbacks[name]) {
      var args = [];

      for(var it = 1; it < arguments.length; ++it) {
        args.push(arguments[it]);
      }

      events.queue.push({
        name: name,
        args: args
      });

      if (!events.timer) {
        var that = this;

        events.timer = setTimeout(function () {
          var events = that._events || createEventsQueue();
          delete events.timer;

          var queue = events.queue;
          events.queue = [];

          for (var it = 0; it < queue.length; ++it) {
            var queuedEvent = queue[it];
            var callbacks = _.clone(events.callbacks[queuedEvent.name]);

            if (callbacks) {
              for (var cbIt = 0; cbIt < callbacks.length; ++cbIt) {
                var cb = callbacks[cbIt];
                cb.fn.apply(cb.ctx, queuedEvent.args);
              }
            }
          }
        }, 0);
      }
    }
  };

  Events.listenTo = function(obj, name, fn) {
    registerListenedObject(this, obj);
    obj.on(name, fn, this);

    return this;
  };

  Events.listenToOnce = function(obj, name, fn) {
    registerListenedObject(this, obj);
    obj.once(name, fn, this);

    return this;
  };

  Events.stopListening = function(obj, name, fn) {
    var listeningTo = this._listeningTo;

    if (obj && listeningTo) {
      (listeningTo = {})[obj._listenerId] = obj;
    }

    if (listeningTo) {
      var remove = !name && !fn;
      var keys = Object.keys(listeningTo);

      for (var it = 0; it < keys.length; ++it) {
        var id = keys[it];

        obj = listeningTo[id];
        obj.off(name, fn, this);

        if (remove || !contextExists(obj._events.callbacks, this)) {
          delete this._listeningTo[id];
        }
      }
    }
  };

  return Events;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/window-port',[
  'f9phone/object'
],
function(Object) {
  var WindowPort = Object.extend({
    postMessage: function (data) {
      this._targetWindow.postMessage(data, this._targetOrigin);
    },

    onMessage: function (fn) {
      this._sourceWindow.addEventListener('message', this.bind(function (event) {
        if (event.source === this._targetWindow) {
          fn(event);
        }
      }), false);
    },

    updateTarget: function (event) {
      this._targetOrigin = event.origin;
    },

    _init: function () {
      this._targetWindow = window.top;
      this._targetOrigin = '*';
      this._sourceWindow = window;
    }
  });

  return WindowPort;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/window-io',[
  'f9phone/object',
  'f9phone/events',
  'f9phone/window-port',
  'underscore'
],
function(Object, Events, WindowPort, _) {
  var WindowIO = Object.extend({
    connect: function () {
      this.send('connect');
    },

    send: function(message) {
      this._port.postMessage(this._pack(message));
    },

    onMessage: function(fn) {
      this.on('message', fn);
    },

    _init: function () {
      this._port = new WindowPort();
      this._name = 'Page';
      this._port.onMessage(this.bind(this._onPortMessage));
    },

    _onPortMessage: function (event) {
      var data = event.data;

      if (_.isObject(data) && data.sender !== this._name && this._fromExpectedSource(data)) {
        this._port.updateTarget(event);
        this._triggerMessage(data.message);
      }
    },

    _pack: function (message) {
      return {
        message: message,
        sender: this._name
      };
    },

    _triggerMessage: function (msg) {
      this.trigger('message', msg);
    }
  });

  WindowIO.mixin(Events);

  return WindowIO;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/deferred',[
  'f9phone/object',
  'jquery',
  'underscore'
],
function(Object, $, _) {
  var Deferred = Object.extend({
    _init: function() {
      this._deferred = new $.Deferred();
    },

    resolve: function () {
      var args = arguments;

      _.defer(_.bind(function () {
        this._deferred.resolve.apply(this._deferred, args);
      }, this));
    },

    reject: function () {
      var args = arguments;

      _.defer(_.bind(function () {
        this._deferred.reject.apply(this._deferred, args);
      }, this));
    },

    promise: function () {
      return this._deferred.promise();
    }
  });

  return Deferred;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/channel',[
  'f9phone/object',
  'f9phone/message',
  'f9phone/window-io',
  'f9phone/deferred',
  'f9phone/events',
  'underscore'
],
function(Object, Message, WindowIO, Deferred, Events, _) {
  var Dispatcher = Object.extend(Events);

  var Channel = Object.extend({
    connect: function () {
      console.log('f9phone js: connecting...');

      this._io.connect();

      return this._savePendingRequest('connect', 15000);
    },

    send: function (request) {
      var msg = {
        hostId: this._hostId,
        id: _.uniqueId(),
        request: request
      };

      console.log('f9phone js: sending request:', request, ', id:', msg.id);

      this._io.send(msg);

      return this._savePendingRequest(msg.id);
    },

    onEvent: function (fn) {
      this._dispatcher.on('event', fn);
    },

    offEvent: function (fn) {
      this._dispatcher.off('event', fn);
    },

    onCommunicationError: function (fn) {
      this._dispatcher.on('communication:error', fn);
    },

    _init: function (io) {
      this._io = io;
      this._pendingRequests = {};
      this._timeout = 60000;
      this._dispatcher = new Dispatcher();
      this._io.onMessage(this.bind(this._dispatch));
      this._dispatcher.on('connected', this.bind(this._onConnected));
      this._dispatcher.on('response', this.bind(this._resolvePendingRequest));
      this._dispatcher.on('error', this.bind(this._rejectPendingRequest));
      this._dispatcher.on('communication:error', this.bind(this._rejectAllPendingRequests));
    },

    _dispatch: function (raw) {
      if (_(raw.hostId).isUndefined() || raw.hostId === this._hostId) {
        var msg = new Message(raw);

        console.log('f9phone js: received', msg.type() + ':', msg.data(), (msg.id() ? ', id: ' + msg.id() : ''));

        this._dispatcher.trigger(msg.type(), msg.data(), msg.id());
      }
    },

    _onConnected: function (hostId) {
      this._hostId = hostId;
      this._resolvePendingRequest(undefined, 'connect');
    },

    _savePendingRequest: function (msgId, timeout) {
      timeout = timeout || this._timeout;

      if (!_(this._pendingRequests[msgId]).isObject()) {
        var timerId = setTimeout(this.bind(function () {
          console.error('f9phone js: timeout for request with id:', msgId);

          this._rejectPendingRequest('Timeout', msgId);
        }), timeout);

        this._pendingRequests[msgId] = {
          deferred: new Deferred(),
          timerId: timerId
        };
      }

      return this._pendingRequests[msgId].deferred.promise();
    },

    _resolvePendingRequest: function (response, msgId) {
      this._handlePendingRequest('resolve', response, msgId);
    },

    _rejectPendingRequest: function (error, msgId) {
      this._handlePendingRequest('reject', error, msgId);
    },

    _handlePendingRequest: function (method, msg, msgId) {
      var pending = this._pendingRequests[msgId];

      if (!_(pending).isUndefined()) {
        pending.deferred[method](msg);
        clearTimeout(pending.timerId);
        delete this._pendingRequests[msgId];
      }
    },

    _rejectAllPendingRequests: function (error) {
      var msgIds = _(this._pendingRequests).keys();

      _(msgIds).each(this.bind(function (msgId) {
        this._rejectPendingRequest(error, msgId);
      }));
    }
  });

  return Channel;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/firebreath-io',[
  'f9phone/object',
  'f9phone/events',
  'f9phone/browser',
  'underscore',
  'jquery'
],
function(Object, Events, Browser, _, $) {
  var addEvent = function (obj, name, func) {
    if (window.attachEvent) {
      obj.attachEvent("on" + name, func);
    }
    else if (Browser.isIE) {
      // IE11 has no attachEvent method and addEventListener doesn't work properly with FB events
      //   thus we have to use a trick

      var eventName = "on" + name;
      var eventListeners = name + "_listeners";

      if (!obj[eventName]) {
        obj[eventListeners] = [];
        obj[eventName] = function() {
          var args = arguments;
          _(obj[eventListeners]).forEach(_.bind(function(fn) {
            fn.apply(this, args);
          }, this));
        };
      }

      obj[eventListeners].push(func);
    }
    else if (obj.addEventListener) {
      obj.addEventListener(name, func, false);
    } else {
      throw new Error("Object does not support events");
    }
  };

  var FireBreathIO = Object.extend ({
    connect: function() {
      if (this.isConnected() && this.browserRestartRequired()) {
        this._sendBrowserRestartRequired();
      }
      else if (this.isConnected()) {
        this._sendConnected();
      }
      else {
        this._destroyPort();
        this._createPort();
      }
    },

    browserRestartRequired: function() {
      return this._port.shouldRestartBrowser;
    },

    isConnected: function () {
      return this._port && this._port.valid;
    },

    send: function (data) {
      try {
        this._port.postMessage(JSON.stringify(data));
      }
      catch (err) {
        this._onPluginCrash(err);
      }
    },

    onMessage: function (fn) {
      this.on('message', fn);
    },

    _onConnected: function () {
      this._port = document.getElementById(this._f9phoneObjectId);

      if (this.isConnected() && this.browserRestartRequired()) {
        this._sendBrowserRestartRequired();
      }
      else if (this.isConnected()) {
        addEvent(this._port, 'message', this.bind(function(data) {
          this._triggerMessage(JSON.parse(data));
        }));

        addEvent(this._port, 'proxyError', this.bind(function(data) {
          this._triggerMessage({
            communicationError: data
          });
        }));

        this._sendConnected();
      }
      else {
        this._destroyPort();
      }
    },

    _triggerMessage: function (msg) {
      this.trigger('message', msg);
    },

    _sendConnected: function () {
      this._triggerMessage('connected:' + this._port.hostId);
    },

    _sendBrowserRestartRequired: function () {
      this._triggerMessage({
        communicationError: {
          what: 'browser restart required'
        }
      });
    },

    _sendPluginNotFound: function () {
      this._triggerMessage({
        communicationError: {
          what: 'plugin not found'
        }
      });
    },

    _createPort: function () {
      if (this._isPluginInstalled()) {
        this._f9phoneObjectId = _.uniqueId('f9phone-api-');
        var f9phoneSelector = '#f9phone';
        var f9phoneObject = '' +
          '<object id="' + this._f9phoneObjectId + '" type="application/x-five9phone" style="width:0; height:0;">' +
          '<param name="onload" value="onF9PhoneLoaded" />' +
          '</object>';

        window.onF9PhoneLoaded = this.bind(this._onConnected);

        $(f9phoneSelector).append(f9phoneObject);
      }
      else {
        this._sendPluginNotFound();
      }
    },

    _destroyPort: function () {
      $('#' + this._f9phoneObjectId).remove();
      delete this._port;
      delete this._f9phoneObjectId;
    },

    _isPluginInstalled: function () {
      navigator.plugins.refresh(false);

      var f9plugin;

      if (Browser.isIE) {
        try {
          f9plugin = new ActiveXObject('Five9.Five9Softphone');
        }
        catch (e) {}
      }
      else {
        f9plugin = _.find(navigator.plugins, function (plugin) {
          return _.isObject(_.findWhere(plugin, {type: 'application/x-five9phone'}));
        });
      }

      return _.isObject(f9plugin);
    },

    _onPluginCrash: function (err) {
      this._destroyPort();

      this._triggerMessage({
        communicationError: {
          what: 'plugin crashed',
          details: err
        }
      });
    }
  });

  FireBreathIO.mixin(Events);

  return FireBreathIO;
});

define('f9phone/chrome-io',[
  'f9phone/window-io'
],
function(WindowIO) {
  var ChromeIO = WindowIO.extend({
    _init: function (extensionId) {
      this._extensionId = extensionId;
      this._super._init.call(this);
    },

    _pack: function (message) {
      var pkg = this._super._pack.call(this, message);
      pkg.extensionId = this._extensionId;

      return pkg;
    },

    _fromExpectedSource: function (data) {
      return data.extensionId === this._extensionId;
    }
  });

  return ChromeIO;
});

define('f9phone/safari-io',[
  'f9phone/window-io',
  'underscore'
],
function(WindowIO, _) {
  var SafariIO = WindowIO.extend({
    _init: function (minVersion) {
      this._minVersion = minVersion;
      this._extensionId = 'f53ae0f26b0344baa7d6aac2f2d1db4e';
      this._super._init.call(this);
    },

    _pack: function (message) {
      var pkg = this._super._pack.call(this, message);
      pkg.extensionId = this._extensionId;

      return pkg;
    },

    _fromExpectedSource: function (data) {
      var fromSoftphoneExtension = (data.extensionId === this._extensionId);
      var versionCompatible = _.isString(data.version) && this._compareSemVer(this._minVersion, data.version) <= 0;

      if (fromSoftphoneExtension && !versionCompatible) {
        this._triggerMessage({
          communicationError: {
            what: 'safari extension version mismatch',
            details: 'expected min version is ' + this._minVersion + ', reply from version ' + data.version
          }
        });
      }

      return fromSoftphoneExtension && versionCompatible;
    },

    _compareSemVer: function (v1, v2) {
      var toInts = function (version) {
        return _.map(version.split('.'), function (versionPart) {
          return parseInt(versionPart, 10);
        });
      };

      var ver1 = toInts(v1);
      var ver2 = toInts(v2);

      var res = 0;
      var length = Math.min(ver1.length, ver2.length);

      for (var i = 0; i < length; ++i) {
        res = ver1[i] - ver2[i];

        if (res !== 0) break;
      }

      if (res === 0) {
        res = ver1.length - ver2.length;
      }

      return res;
    }
  });

  return SafariIO;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/call',[
  'f9phone/object',
  'f9phone/events'
],
function(Object, Events) {
  var Call = Object.extend({
    _init: function (api, apiFactory) {
      this._api = apiFactory.defineApi(api);

      this.caller = apiFactory.defineSimpleProperty('caller');
      this.callee = apiFactory.defineSimpleProperty('callee');
      this.state = apiFactory.defineSimpleProperty('state');
      this.duration = apiFactory.defineSimpleProperty('duration');
      this.direction = apiFactory.defineSimpleProperty('direction');
      this.error = apiFactory.defineSimpleProperty('error');

      this.accept = apiFactory.defineSimpleMethod('accept', false);
      this.decline = apiFactory.defineSimpleMethod('decline', false);
      this.hangup = apiFactory.defineSimpleMethod('hangup', false);
      this.dtmf = apiFactory.defineSimpleMethod('dtmf', false);

      apiFactory.defineEvent(this, 'state', 'stateChanged');

      this._destructors.push(this.bind(this.off));
    }
  });

  Call.mixin(Events);

  return Call;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/account',[
  'f9phone/object',
  'f9phone/events',
  'f9phone/call'
],
function(Object, Events, Call) {
  var Account = Object.extend({
    _init: function (api, apiFactory) {
      this._api = apiFactory.defineApi(api);

      this.username = apiFactory.defineSimpleProperty('username');
      this.domain = apiFactory.defineSimpleProperty('domain');
      this.proxy = apiFactory.defineSimpleProperty('proxy');
      this.state = apiFactory.defineSimpleProperty('state');
      this.error = apiFactory.defineSimpleProperty('error');
      this.lastCall = apiFactory.defineApiProperty('lastCall', Call);

      this.register = apiFactory.defineSimpleMethod('register', false);
      this.deregister = apiFactory.defineSimpleMethod('deregister', false);
      this.dial = apiFactory.defineApiMethod('dial', Call);
      this.heartbeat = apiFactory.defineSimpleMethod('heartbeat', false);

      apiFactory.defineEvent(this, 'heartbeat', 'heartbeat');
      apiFactory.defineEvent(this, 'state', 'stateChanged');
      apiFactory.defineEvent(this, 'incomingCall', Call);

      this.on('heartbeat', this.bind(this.heartbeat));
      this.heartbeat();

      this._destructors.push(this.bind(this.off));
    }
  });

  Account.mixin(Events);

  return Account;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/device',[
  'f9phone/object',
  'f9phone/events'
],
function(Object, Events) {
  var Device = Object.extend({
    _init: function (api, apiFactory) {
      this._api = apiFactory.defineApi(api);

      this.type = apiFactory.defineSimpleProperty('type');
      this.description = apiFactory.defineSimpleProperty('description');
      this.isActive = apiFactory.defineSimpleProperty('isActive');
      this.error = apiFactory.defineSimpleProperty('error');
      this.isMuted = apiFactory.defineSimpleProperty('isMuted');
      this.volume = apiFactory.defineSimpleProperty('volume');

      this.activate = apiFactory.defineSimpleMethod('activate', false);
      this.mute = apiFactory.defineSimpleMethod('mute', false);
      this.setVolume = apiFactory.defineSimpleMethod('setVolume', false);

      apiFactory.defineEvent(this, 'volumeChanged');

      this._destructors.push(this.bind(this.off));
    }
  });

  Device.mixin(Events);

  return Device;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/phone',[
  'f9phone/object',
  'f9phone/events',
  'f9phone/account',
  'f9phone/device',
  'underscore'
],
function(Object, Events, Account, Device, _) {
  var Phone = Object.extend({
    _init: function (api, apiFactory) {
      this._api = api;

      this.state = apiFactory.defineSimpleProperty('state');
      this.logFilename= apiFactory.defineSimpleProperty('logFilename');
      this.error = apiFactory.defineSimpleProperty('error');

      this.captureDevices= apiFactory.defineApiArrayProperty('captureDevices', Device);
      this.playbackDevices= apiFactory.defineApiArrayProperty('playbackDevices', Device);

      this.account = apiFactory.defineApiMethod('account', Account);
      this.refreshDevices = apiFactory.defineSimpleMethod('refreshDevices');

      this.setLogLevel = apiFactory.defineSimpleMethod('setLogLevel');
      this.logPhoneDetails = apiFactory.defineSimpleMethod('logPhoneDetails');
      this.enableFileLogger = apiFactory.defineSimpleMethod('enableFileLogger');
      this.disableFileLogger = apiFactory.defineSimpleMethod('disableFileLogger');

      this.codecs = apiFactory.defineSimpleProperty('codecs');
      this.setCodecPriority = apiFactory.defineSimpleMethod('setCodecPriority');

      this.ptime = apiFactory.defineSimpleProperty('ptime');
      this.setPtime = apiFactory.defineSimpleMethod('setPtime');

      this.silenceSupression = apiFactory.defineSimpleProperty('silenceSupression');
      this.setSilenceSupression = apiFactory.defineSimpleMethod('setSilenceSupression');

      this.autoEchoCancellation = apiFactory.defineSimpleProperty('autoEchoCancellation');
      this.setAutoEchoCancellation = apiFactory.defineSimpleMethod('setAutoEchoCancellation');

      this.autoGainControl = apiFactory.defineSimpleProperty('autoGainControl');
      this.setAutoGainControl = apiFactory.defineSimpleMethod('setAutoGainControl');

      apiFactory.defineEvent(this, 'devicesRefreshed');
      apiFactory.defineEvent(this, 'activeDeviceChanged');

      this._destructors.push(this.bind(this.off));
    },

    setOptions: function (options) {
      if (_(options).isObject()) {
        if (_(options.logLevel).isString() || _(options.engineLogLevel).isString()) {
          this.setLogLevel({logLevel: options.logLevel, engineLogLevel: options.engineLogLevel});
        }

        if (_(options.enableFileLogger).isBoolean()) {
          var fn = options.enableFileLogger ? this.enableFileLogger : this.disableFileLogger;
          fn.call(this);
        }
      }
    }
  });

  Phone.mixin(Events);

  return Phone;
});


/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/version',[
],
function() {
  return '92.5066.0';
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/softphone',[
  'f9phone/browser',
  'f9phone/object',
  'f9phone/events',
  'f9phone/phone',
  'f9phone/deferred',
  'f9phone/version',
  'underscore'
],
function(Browser, Object, Events, Phone, Deferred, version, _) {
  var Softphone = Object.extend({
    jsVersion: version,

    instance: function () {
      this._setEvents();
      return this;
    },

    createPhone: function(contextId, options) {
      var deferred = new Deferred();

      var phone = this._phones[options.engine + ':' + contextId];

      if (_(phone).isObject()) {
        phone.setOptions(options);
        deferred.resolve(phone);
      }
      else {
        options = this._addDefaultOptions(options);

        this._afterConnected(this._createPhone, deferred)(_.extend({contextId: contextId}, options))
          .done(this.bind(function (phone) {
            this._phones[contextId] = phone;
          }));
      }

      return deferred.promise();
    },

    _init: function (apiFactory) {
      this._apiFactory = apiFactory;
      this._api = 'softphone';
      this._isConnected = false;

      this._binaryVersion = apiFactory.defineSimpleProperty('version');
      this._createPhone = apiFactory.defineApiMethod('createPhone', Phone);
      this._download = apiFactory.defineSimpleMethod('download');
      this._switchTo = apiFactory.defineSimpleMethod('switchTo', false);

      this.binaryVersion = this._afterConnected(this._binaryVersion);
      this.download = this._afterConnected(this._download);
      this.switchTo = this._afterConnected(this._switchTo);

      this._eventsSet = false;
      this._setEvents();

      this._destructors.push(this.bind(function () {
        this.off();
        this._reset();
      }));

      this._phones = {};

      this._apiFactory.channel().onCommunicationError(this.bind(function (error) {
        this._reset();
        this.trigger('communication:error', error);
      }));
    },

    _reset: function () {
      this._isConnected = false;
      this._phones = {};
      this._apiFactory.resetEvents();
      this._eventsSet = false;
    },

    _connect: function () {
      var deferred = new Deferred();

      if (this._isConnected) {
        deferred.resolve();
      }
      else {
        this._apiFactory.channel().connect()
          .done(this.bind(function () {
            this._isConnected = true;
            deferred.resolve();
          }))
          .fail(function (msg) {
            var err = { what: 'application not found' };

            if (msg && msg.what === 'browser restart required') {
              err.what = msg.what;
            }
            else if (Browser.isChrome) {
              err.details = 'chrome extension required';
            }
            else if (Browser.isSafari) {
              err.details = 'safari extension required';
            }

            deferred.reject(err);
          });
      }

      return deferred.promise();
    },

    _afterConnected: function (fn, def) {
      return this.bind(function () {
        var deferred = def || new Deferred();

        var handleDone = function () { deferred.resolve.apply(deferred, arguments); };
        var handleFail = function () { deferred.reject.apply(deferred, arguments); };

        var args = arguments;

        this._connect()
          .done(this.bind(function () {
            fn.apply(this, args)
              .done(handleDone)
              .fail(handleFail);
          }))
          .fail(handleFail);

        return deferred.promise();
      });
    },


    _setEvents: function () {
      if (!this._eventsSet) {
        this._apiFactory.defineEvent(this, 'ready');
        this._apiFactory.defineEvent(this, 'downloadProgress');
        this._apiFactory.defineEvent(this, 'downloadFinished');
        this._eventsSet = true;
      }
    },

    _addDefaultOptions: function (options) {
      return _(options || {}).defaults({
        version: version,
        logLevel: 'trace',
        engineLogLevel: 'trace',
        enableFileLogger: true,
        enableConsoleLogger: false,
        engine: 'pjsip',
        browser: Browser.info,
        date: (new Date()).toString()
      });
    }
  });

  Softphone.mixin(Events);

  return Softphone;
});


/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/event-dispatcher',[
  'f9phone/object',
  'f9phone/events'
],
function(Object, Events) {
  var EventDispatcher = Object.extend({
    _init: function (channel) {
      var eventHandler = this.bind(function (event) {
        var args = [EventDispatcher.eventId(event.objectId, event.name)].concat(event.data);
        this.trigger.apply(this, args);
      });

      channel.onEvent(eventHandler);

      this._destructors.push(this.bind(function () {
        this.off();
        channel.offEvent(eventHandler);
      }));
    }
  }, {
    eventId: function (objectId, eventName) {
      return objectId + ':' + eventName;
    }
  });

  EventDispatcher.mixin(Events);

  return EventDispatcher;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/api-factory',[
  'f9phone/browser',
  'f9phone/channel',
  'f9phone/firebreath-io',
  'f9phone/chrome-io',
  'f9phone/safari-io',
  'f9phone/object',
  'f9phone/deferred',
  'f9phone/softphone',
  'f9phone/event-dispatcher',
  'underscore'
],
function(Browser, Channel, FireBreathIO, ChromeIO, SafariIO, F9Object, Deferred, Softphone, EventDispatcher, _) {
  var apiFactory = F9Object.extend({
    channel: function () {
      return this._channel;
    },

    softphone: function () {
      return this._softphone.instance();
    },

    defineApi: function (apiId) {
      return apiId;
    },

    definePropertyOrMethod: function (verb, name, mapData) {
      var factory = this;
      return function (options) {
        var deferred = new Deferred();
        var objectId = this._api;

        factory.channel().send({
          objectId: objectId,
          verb: verb,
          attrName: name,
          args: options
        })
          .done(function (data) {
            var result = mapData(data);

            if (result.success) {
              deferred.resolve(result.data);
            }
            else {
              factory.channel().send({
                objectId: objectId,
                verb: 'get',
                attrName: 'error'
              })
                .done(function (err) {
                  deferred.reject(err);
                })
                .fail(function (err) {
                  deferred.reject({what: 'CommunicationError', details: err});
                });
            }
          })
          .fail(function (err) {
            deferred.reject({what: 'CommunicationError', details: err});
          });

        return deferred.promise();
      };
    },

    defineSimpleProperty: function (name) {
      return this.definePropertyOrMethod('get', name, function (data) {
        return {success: true, data: data};
      });
    },

    defineApiProperty: function (name, Wrapper) {
      var factory = this;
      return this.definePropertyOrMethod('get', name, function (data) {
        var ret = data;

        if (_(data).isString()) {
          ret = new Wrapper(data, factory);
        }

        return {success: true, data: ret};
      });
    },

    defineApiArrayProperty: function (name, Wrapper) {
      var factory = this;
      return this.definePropertyOrMethod('get', name, function (data) {
        var ret = _(data).map(function (d) {
          return new Wrapper(d, factory);
        });

        return {success: true, data: ret};
      });
    },

    defineSimpleMethod: function (name, failIndicator) {
      return this.definePropertyOrMethod('post', name, function (data) {
        var ok = true;

        if (!_(failIndicator).isUndefined()) {
          ok = (data !== failIndicator);
        }

        return {success: ok, data: data};
      });
    },

    defineApiMethod: function (name, Wrapper) {
      var factory = this;
      return this.definePropertyOrMethod('post', name, function (data) {
        var ok = false;
        var ret;

        if (_(data).isString()) {
          ok = true;
          ret = new Wrapper(data, factory);
        }

        return {success: ok, data: ret};
      });
    },


    defineEvent: function() {
      var that = this;
      var addCommonListener = function (obj, name, commonListener) {
        var objectId = obj._api;
        obj.listenTo(that._eventDispatcher, EventDispatcher.eventId(objectId, name), commonListener);
      };

      var removeCommonListener = function (obj) {
        obj.stopListening();
      };

      this._defineEventTemplate(arguments, addCommonListener, removeCommonListener);
    },

    resetEvents: function () {
      this._eventDispatcher.off();
    },


    _init: function(chromeExtensionId, safariMinVersion) {
      this._initChannel(chromeExtensionId, safariMinVersion);
      this._eventDispatcher = new EventDispatcher(this.channel());

      this.channel().onCommunicationError(this.bind(function () {
        this._eventDispatcher.off();
      }));

      this._softphone = new Softphone(this);
    },

    _initChannel: function (chromeExtensionId, safariMinVersion) {
      var io = Browser.isChrome? new ChromeIO(chromeExtensionId):
               Browser.isSafari ? new SafariIO(safariMinVersion) : new FireBreathIO();

      this._channel = new Channel (io);
    },

    _defineEventTemplate: function (args, addCommonListener, removeCommonListener) {
      args = _(args).toArray();
      var obj = args.shift();
      var name = args.shift();
      var originalName = _(args[0]).isString() ? args.shift() : name;
      var factory = this;

      var commonListener = function () {
        var wrappers = _(args).clone();

        var rawEventArgs = _(arguments).toArray();
        var eventArgs = _(rawEventArgs).map(function (eventArg) {
          var Wrapper = wrappers.shift();
          return _(Wrapper).isUndefined() ? eventArg : new Wrapper(eventArg, factory);
        });

        var eventArgsStr = _(rawEventArgs).reduce(function (acc, eventArg) {
          return acc + ':' + eventArg;
        }, '');

        if (!_(eventArgs).isEmpty()) {
          obj.trigger.apply(obj, [name + eventArgsStr].concat(eventArgs));
        }

        obj.trigger.apply(obj, [originalName].concat(eventArgs));
      };

      obj._destructors.push(function () {
        removeCommonListener(obj, originalName, commonListener);
      });

      addCommonListener(obj, originalName, commonListener);
    }
  });

  return apiFactory;
});

/// @copyright Five9, Inc. The content presented herein may not, under
/// any circumstances, be reproduced in whole or in any part or form without
/// written permission from Five9, Inc.

define('f9phone/f9phone',[
  'f9phone/api-factory',
  'underscore'
],
function(apiFactory, _) {
  var factory;

  var createSoftphone = function (chromeExtensionId, safariMinVersion) {
    if (!_(factory).isObject()) {
      factory = new apiFactory(chromeExtensionId, safariMinVersion);
    }

    return factory.softphone();
  };

  return createSoftphone;
});


define('websoftphone/shared.result',[
  'f9phone/object',
  'local.storage',
  'underscore'
],
function(Object, LocalStorage, _) {
  var LOCK_TIMEOUT = 1000;
  var FUTURE = 5 * LOCK_TIMEOUT;

  var uuid = function () {
    var d = _.now();

    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16); //NOSONAR: useful bitwise operator
    });
  };

  var SharedResult = Object.extend({
    lock: function () {
      if (this.isLocked()) {
        if(this._lockInfo().ownerId === this._id) {
          this._notify('ALREADY_LOCKED');
        }
        else {
          this._waitForUnlock();
        }
      }
      else {
        this._lockById();
        this._lockByTimestamp();

        if (this._isLockedById()) {
          this._cleanResult();
          this._keepLocked();
          this._notify('LOCKED');
        }
        else {
          this._waitForUnlock();
        }
      }
    },

    unlock: function (result) {
      if (this._lockTimerId) {
        console.info('Softphone shared result: UNLOCK ---', this._id);
        this._setResult(result);
        this._clearLockTimer();
        this._unlockByTimestamp();
        this._unlockById();
      }
    },

    isLocked: function () {
      return this._lockInfo().locked === true;
    },

    _init: function (name, fn) {
      var namespace = 'f9-phone-websoftphone-shared-result-';
      this._resultKey =  namespace + name;
      this._idLockKey = this._resultKey + '-id-lock';
      this._timestampLockKey = this._resultKey + '-timestamp-lock';
      this._id = uuid();
      this._callback = fn;
      this._onStateChanged = this.cb(this._onStateChangedHandler);
      LocalStorage.on(this._timestampLockKey, this._onStateChanged);

      this._destructors.push(this.bind(function () {
        LocalStorage.off(this._timestampLockKey, this._onStateChanged);
      }));
    },

    _lockById: function () {
      LocalStorage.setRaw(this._idLockKey, this._id);
    },

    _lockByTimestamp: function () {
      var nearFuture = _.now() + FUTURE;
      LocalStorage.set(this._timestampLockKey, {id: this._id, timestamp: nearFuture});
    },

    _unlockById: function () {
      LocalStorage.remove(this._idLockKey);
    },

    _unlockByTimestamp: function () {
      LocalStorage.remove(this._timestampLockKey);
    },

    _result: function () {
      return LocalStorage.get(this._resultKey);
    },

    _setResult: function (result) {
      LocalStorage.set(this._resultKey, result);
    },

    _cleanResult: function () {
      LocalStorage.remove(this._resultKey);
    },

    _renewLock: function () {
      this._lockById();
      this._lockByTimestamp();
    },

    _isLockedById: function () {
      return (this._id === LocalStorage.getRaw(this._idLockKey));
    },

    _lockInfo: function () {
      var res = {locked: false};
      var timestampLock = LocalStorage.get(this._timestampLockKey);

      if (timestampLock) {
        res.locked = (timestampLock.timestamp > _.now());
        res.ownerId = timestampLock.id;
      }

      return res;
    },

    _waitForUnlock: function () {
      if (!this._waitTimerId) {
        console.info('Softphone shared result: WAIT UNLOCK ---', this._id);
        this._waitTimerId = setInterval(this._onStateChanged, FUTURE);
        this._notify('WAIT_UNLOCK');
      }
    },

    _onStateChangedHandler: function () {
      if (this.isLocked()){
        this._waitForUnlock();
      }
      else {
        this._clearWaitTimer();
        this._notify('UNLOCKED', this._result());
      }
    },

    _clearWaitTimer: function () {
      if (this._waitTimerId) {
        clearInterval(this._waitTimerId);
        delete this._waitTimerId;
      }
    },

    _keepLocked: function () {
      if (!this._lockTimerId) {
        this._lockTimerId = setInterval(this.cb(this._renewLock), LOCK_TIMEOUT);
      }
    },

    _clearLockTimer: function () {
      if (this._lockTimerId) {
        clearInterval(this._lockTimerId);
        delete this._lockTimerId;
      }
    },

    _notify: function (arg1, arg2) {
      console.info('Softphone shared result:', arg1, arg2, '---', this._id);
      _.defer(this._callback, arg1, arg2);
    }
  });

  return SharedResult;
});

define('websoftphone/flow',[
  'f9phone/object',
  'f9phone/events',
  'f9phone/deferred',
  'websoftphone/shared.result',
  'async',
  'underscore'
],
function (Object, Events, Deferred, SharedResult, async, _) {
  var FlowState = {
    NotDone: 'state:not-done',
    InProgress: 'state:in-progress',
    Done: 'state:done',
    Canceled: 'state:cancelled',
    Failed: 'state:failed'
  };

  var Flow = Object.extend({
    _init: function (steps, context, options) {
      options = _.defaults(options || {}, {rerun: false});

      if (_.isString(options.globalName)) {
        this._sharedResult = new SharedResult(options.globalName, this.cb(this._onSharedResultChanged));

        this._destructors.push(this.bind(function () {
          this._sharedResult.destroy();
          delete this._sharedResult;
        }));
      }

      this._rerun = options.rerun;
      this._state = Flow.State.NotDone;
      this._steps = _.map(steps, this.bind(function (step) {
        return this.cb(function (next) {
          var done = _.once(next);

          this.reset = function () {
            done(Flow.State.NotDone);
            this._setState(Flow.State.NotDone);
            this._process();
          };

          this.fail = function (error) {
            error = error || Flow.State.Failed;
            done(error);
          };

          context[step](done);
        });
      }));

      this._destructors.push(this.bind(this.off));
    },

    isInProgress: function () {
      return this._sharedResult && this._sharedResult.isLocked() || this.state() === Flow.State.InProgress;
    },

    state: function () {
      return this._state;
    },

    _setState: function (value) {
      this._state = value;
      this.trigger(value);
      this.trigger('state:changed', value);
    },

    _process: function () {
      this._unlock();

      if (this._deferred) {
        var state = this.state();

        if (state === Flow.State.Done) {
          this._deferred.resolve();
        } else if (state === Flow.State.Canceled) {
          this._deferred.reject(state);
        } else if (state === Flow.State.Failed) {
          this._deferred.reject(this._error);
        }

        if (state !== Flow.State.InProgress) {
          delete this.reset;
          delete this.fail;
          delete this._deferred;
          delete this._error;
        }
      }
    },

    cancel: function () {

      if (this.state() !== Flow.State.NotDone) {
        this.fail(Flow.State.Canceled);
        this._setState(Flow.State.Canceled);
      }
    },

    reset: function () {
      this._setState(Flow.State.NotDone);
      this._unlock();
    },

    fail: function () {
      this._setState(Flow.State.Failed);
      this._unlock();
    },

    replace: function (flow) {
      var otherDeferred = flow._deferred;
      flow.reset();

      if (!_.isUndefined(otherDeferred)) {
        if (_.isUndefined(this._deferred)) {
          this._deferred = otherDeferred;
        } else {
          this._deferred.promise()
            .done(_.bind(otherDeferred.resolve, otherDeferred))
            .fail(_.bind(otherDeferred.reject, otherDeferred));
        }
      }
    },

    run: function () {
      if (_.isUndefined(this._deferred)) {
        this._deferred = new Deferred();
      }

      var promise = this._deferred.promise();

      var actionRequiredStates = [
        Flow.State.NotDone,
        Flow.State.Canceled,
        Flow.State.Failed
      ];

      if(this._rerun) {
        actionRequiredStates.push(Flow.State.Done);
      }

      if (_.contains(actionRequiredStates, this.state())) {
        this._setState(Flow.State.InProgress);
        this._lockAndRun();
      }
      else {
        this._process();
      }

      return promise;
    },

    _lockAndRun: function () {
      if (this._sharedResult) {
        this._sharedResult.lock();
      }
      else {
        this._doRun();
      }
    },

    _onSharedResultChanged: function (lockState, result) {
      if (lockState === 'LOCKED') {
        this._doRun();
      }
      else if (lockState === 'WAIT_UNLOCK') {
        this._setState(Flow.State.InProgress);
      }
      else if (lockState === 'UNLOCKED') {
        if (result) {
          this._error = result.error;
          this._setState(result.state);
          this._process();
        }
        else {
          _.defer(this.cb(this._lockAndRun));
        }
      }
      else {
        console.error('Softphone flow: unexpected shared result: lockState =', lockState, 'result =', result);
      }
    },

    _unlock: function () {
      var state = this.state();

      if (state !== Flow.State.InProgress && this._sharedResult) {
        this._sharedResult.unlock({
          state: state,
          error: this._error
        });
      }
    },

    _doRun: function () {
      async.series(this._steps, this.cb(function (err) {
        if (_.isNull(err) || _.isUndefined(err)) {
          this._setState(Flow.State.Done);
        } else if (err === Flow.State.Canceled) {
          this._setState(Flow.State.Canceled);
        } else if (err === Flow.State.NotDone) {
          this._setState(Flow.State.NotDone);
        } else {
          console.error('Softphone flow failed: ', err);
          this._setState(Flow.State.Failed);
          this._error = err;
        }

        this._process();
      }));
    }
  }, {
    State: FlowState
  });

  Flow.mixin(Events);

  return Flow;
});

define('websoftphone/error.codes',[
],
function() {
  return {
    ApplicationNotFound: 'application not found',
    ExtensionDisconnected: 'extension disconnected',
    PluginNotFound: 'plugin not found',
    ApplicationDisconnected: 'native app disconnected',
    SafariExtensionVersionMismatch: 'safari extension version mismatch',
    UpdateDownloadFailed: 'update download failed',
    UpdateFailed: 'update failed',
    RegistrationFailed: 'registration failed',
    BrowserRestartRequired: 'browser restart required',
    ICAConnectionNotFound: 'ica connection not found',
    ConnectingToVDIClientFailed: 'unable to connect to vdi client'
  };
});

define('websoftphone/account',[
  'f9phone/object',
  'f9phone/events',
  'websoftphone/flow',
  'websoftphone/error.codes'
],
function(Object, Events, Flow, ErrorCodes) {
  var registrationFailed = function (details) {
    return {what: ErrorCodes.RegistrationFailed, details: details};
  };

  var isCallActive = function (callState) {
    return _.contains(['ringing', 'accepting', 'accepted'], callState);
  };

  var isCallNonActive = function (callState) {
    return _.contains(['finished', 'failed'], callState);
  };

  var Account = Object.extend({
    create: function () {
      return this._creationFlow.run();
    },

    register: function () {
      return this._registrationFlow.run();
    },

    deregister: function () {
      this._destroyCall();
      this._destroyAccount();

      this._acceptCallFlow.cancel();
      this._retryFlow.cancel();
      this._registrationFlow.cancel();
    },

    isRegistered: function () {
      return this._hasAccount() && (this._accountState === 'registered');
    },

    hasActiveCall: function () {
      return this._hasCall() && isCallActive(this._callState);
    },

    sendDtmf: function (tones) {
      return this._call.dtmf(tones);
    },

    toString: function () {
      return 'Softphone account "' + this._options.username + '@' + this._options.domain + '":';
    },

    _init: function (phone, options) {
      this._phone = phone;
      this._options = options;
      this._hadActiveCall = false;
      this._wasRegistered = false;

      this._creationFlow = new Flow([
        '_prepareRegistration',
        '_getAccount',
        '_getAccountState',
        '_trackAccountState',
        '_getLastCall',
        '_getCallState',
        '_trackCallState'
      ], this);

      this._registrationFlow = new Flow([
        '_prepareRegistration',
        '_getAccount',
        '_getAccountState',
        '_trackAccountState',
        '_registerAccount',
        '_getLastCall',
        '_getCallState',
        '_trackCallState'
      ], this, {rerun: true});

      this._acceptCallFlow = new Flow ([
        '_acceptIncomingCall',
        '_getCallState',
        '_trackCallState'
      ], this);

      this._retryFlow = new Flow([
        '_waitForTimeout',
        '_retryRegistration'
      ], this);

      this._retryTimeout = 0;

      this._destructors.push(this.bind(function () {
        this.off();
        this._resetAccount();
        this._resetCall();
        delete this._callState;
        this._creationFlow.reset();
        this._creationFlow.destroy();
        this._registrationFlow.reset();
        this._registrationFlow.destroy();
        this._acceptCallFlow.reset();
        this._acceptCallFlow.destroy();
        this._retryFlow.cancel();
        this._retryFlow.destroy();
        delete this._retryFlow;
      }));
    },

    _destroyCall: function () {
      if (this._hasCall()) {
        this._call.hangup();
        this._call.decline();
        this._call.destroy();
        delete this._call;
        delete this._callState;

        this._triggerHasActiveCall();
      }
    },

    _destroyAccount: function () {
      if (this._hasAccount()) {
        this._account.deregister();
        this._account.destroy();
        delete this._account;
        delete this._accountState;

        this._triggerIsRegistered();
      }
    },

    _resetAccount: function () {
      if (this._hasAccount()) {
        this._account.destroy();
        delete this._account;
        delete this._accountState;
      }
    },

    _resetCall: function () {
      if (this._hasCall()) {
        this._call.destroy();
        delete this._call;
      }
    },

    _hasCall: function () {
      return _.isObject(this._call);
    },

    _hasAccount: function () {
      return _.isObject(this._account);
    },

    _triggerHasActiveCall: function () {
      var hasActiveCall = this.hasActiveCall();

      if (this._hadActiveCall !== hasActiveCall) {
        this.trigger('hasActiveCall', hasActiveCall);
        this._hadActiveCall = hasActiveCall;
      }
    },

    _triggerIsRegistered: function () {
      var isRegistered = this.isRegistered();

      if (this._wasRegistered !== isRegistered) {
        this.trigger('isRegistered', this.isRegistered());
        this._wasRegistered = isRegistered;
      }
    },

    _acceptCall: function () {
      return this._acceptCallFlow.run();
    },

    _retry: function (error) {
      console.warn('' + this, 'retry registration due to error:', error);

      this._resetAccount();
      this._registrationFlow.fail(error);
      this._triggerIsRegistered();

      if (this._retryFlow) {
        this._retryFlow.fail(error);
        this._retryFlow.run();
      }
    },

    _prepareRegistration: function (next) {
      console.info('' + this, 'prepare registration');

      this._resetAccount();
      this._retryFlow.cancel();
      this._acceptCallFlow.cancel();
      next();
    },

    _getAccount: function (next) {
      console.info('' + this, 'get');

      this._phone.account(this._options)
        .done(this.cb(function (account) {
          this._account = account;
          next();
        }))
        .fail(function (details) {
          next(registrationFailed(details));
        });
    },

    _getAccountState: function (next) {
      console.info('' + this, 'get state');

      this._account.state()
        .done(this.cb(function (state) {
          console.info('' + this, 'account state is', state);

          this._accountState = state;

          this._account.on('stateChanged', this.cb(function (state) {
            console.info('' + this, 'account state changed to', state);

            this._accountState = state;
          }));

          next();
        }))
        .fail(function (details) {
          next(registrationFailed(details));
        });
    },

    _trackAccountState: function (next) {
      console.info('' + this, 'track state');

      var trackState = this.cb(function () {
        this._account.once('state:unregistered', this.cb(function () {
          console.info('' + this, 'unregistered');

          this._account.error()
            .done(this.cb(function (details) {
              details = details || 'normal deregistration';
              var error = registrationFailed(details);
              this._retry(error);
            }))
            .fail(this.cb(function () {
              this._retry(registrationFailed('can\'t get error details'));
            }));
        }));

        this._account.once('incomingCall', this.cb(function (call) {
          console.info('' + this, 'incoming call from VCC');

          this._resetCall();
          this._call = call;
          this._acceptCall();
        }));
      });

      if (this._accountState === 'registered' || this._accountState === 'registering') {
        trackState();
      } else {
        this._account.once('state:registering', trackState);
      }

      this._triggerIsRegistered();

      next();
    },

    _registerAccount: function (next) {
      console.info('' + this, 'register');

      if (this._accountState === 'registered') {
        this._account.off('stateChanged');
        this._retryTimeout = 0;
        next();
      } else {
        this._account.once('state:registered', this.cb(function (state) {
          console.info('' + this, 'registered');

          this._account.off('stateChanged');
          this._accountState = state;
          this._retryTimeout = 0;

          this._triggerIsRegistered();
          next();
        }));

        this._account.register()
          .fail(function (details) {
            next(registrationFailed(details));
          });
      }
    },

    _getLastCall: function (next) {
      console.info('' + this, 'get last call');

      this._account.lastCall()
        .done(this.cb(function (call) {
          this._resetCall();

          if (!_.isNull(call)) {
            this._call = call;
          }

          next();
        }))
        .fail(function (details) {
          next(registrationFailed(details));
        });
    },

    _getCallState: function (next) {
      console.info('' + this, 'get call state');

      if (this._hasCall()) {
        this._call.state()
          .done(this.cb(function (state) {
            console.info('' + this, 'call state is', state);

            this._callState = state;
            next();
          }))
          .fail(this.cb(function (error) {
            console.error('' + this, 'error on getting call state:', error);

            delete this._callState;
            next();
          }));
      } else {
        next();
      }
    },

    _acceptIncomingCall: function (next) {
      console.info('' + this, 'accept incoming call');

      this._call.once('state:accepted', this.cb(function (state) {
        this._callState = state;
        next();
      }));

      this._call.accept()
        .fail(this.cb(function (error) {
          if (error) {
            console.error('' + this, 'error on accepting call:', error);
          }

          next();
        }));
    },

    _trackCallState: function (next) {
      console.info('' + this, 'track call state');

      if (this._hasCall()) {
        var call = this._call;

        call.off(null, null, this);
        call.on('stateChanged', this.cb(function (state) {
          console.info('' + this, 'call state changed to:', state);

          this._callState = state;
          this._triggerHasActiveCall();

          if (isCallNonActive(state)) {
            call.error()
              .done(this.cb(function (reason) {
                reason = reason || 'normal hangup';
                console.warn('' + this, 'call dropped, reason:', reason);
              }))
              .fail(this.cb(function () {
                console.warn('' + this, 'call dropped, but can\'t get error details');
              }));
          }
        }), this);

        if (this._callState === 'ringing') {
          this._acceptCall();
        }
      }

      this._triggerHasActiveCall();

      next();
    },

    _waitForTimeout: function (next) {
      console.info('' + this, 'wait for timeout: ', this._retryTimeout);

      _.delay(next, this._retryTimeout);
    },

    _retryRegistration: function (next) {
      console.info('' + this, 'retry registration');

      this.register()
        .done(next)
        .fail(this.cb(function (error) {
          next(error);

          _.defer(this.cb(function () {
            this._retryTimeout = 30000;
            this._retry(error);
          }));
        }));
    }
  });

  Account.mixin(Events);

  return Account;
});

define('websoftphone/media.devices',[
  'f9phone/object',
  'f9phone/deferred',
  'f9phone/events',
  'async',
  'underscore'
],
function(Object, Deferred, Events, async, _) {
  var MediaDevices= Object.extend({
    type: function () {
      return this._type;
    },

    devices: function () {
      var devices = [];

      if (_.size(this._properties) === _.size(this._propertyNames) && _.size(this._methodNames) === _.size(this._methods)) {
        var deviceKeys = this._propertyNames.concat(this._methodNames);
        var zippedValues = _.zip.apply(null, this._properties.concat(this._methods));

        devices = _.map(zippedValues, function (deviceValues) {
          return _.object(deviceKeys, deviceValues);
        });
      }

      return devices;
    },

    activeDevice: function () {
      return _.findWhere(this.devices(), {isActive: true});
    },

    hasActiveDevice: function () {
      return _.isObject(this.activeDevice());
    },

    create: function () {
      this.listenTo(this._phone(), 'devicesRefreshed', this._retrieveDevices);
      this.listenTo(this._phone(), 'activeDeviceChanged', function (type) {
        if (type === this.type()) {
          this._retrieveDevices();
        }
      });

      return this._retrieveDevices();
    },

    reset: function () {
      this.stopListening();

      this._destroyDevices();
      this._properties = [];
      this._methods = [];

      this._triggerDeviceRefreshed();
    },

    restoreActiveDevice: function () {
      var activeDeviceName = this._settings().get(this._settingName());

      var device = _.isString(activeDeviceName)? _.findWhere(this.devices(), {description: activeDeviceName}):
        _.findWhere(this.devices(), {isActive: true});

      if (_.isObject(device)) {
        device.activate();
      }
    },

    isValid: function () {
      return _.isObject(this._softphone);
    },

    _init: function (softphone, type) {
      this._softphone = softphone;
      this._type = type;
      this._propertyNames = ['description', 'isActive', 'isMuted', 'volume'];
      this._methodNames = ['activate', 'mute', 'setVolume'];
      this._rawDevices = [];
      this._hadActiveDevice = false;

      var debounceTimeout = 300;

      this._triggerDeviceRefreshed = _.throttle(this.cb(function () {
        this.trigger('devices:refreshed');
      }), debounceTimeout);

      this.reset();

      this._destructors.push(this.bind(function () {
        this._destroyDevices();
        this.off();
        this.stopListening();
        delete this._softphone;
      }));
    },

    _phone: function () {
      return this._softphone._phone;
    },

    _settings: function () {
      return this._softphone._settings;
    },

    _settingName: function () {
      return 'active' + this._typeName() + 'Device';
    },

    _loggerPrefix: function () {
      return 'Softphone ' + this._typeName() + ' Devices:';
    },

    _typeName: function () {
      var type = this.type();
      return type.charAt(0).toUpperCase() + type.substr(1);
    },

    _checkActiveDevice: function () {
      var hasActiveDevice = this.hasActiveDevice();

      if (this._hadActiveDevice !== hasActiveDevice) {
        var event = hasActiveDevice? 'appears': 'disappears';
        this.trigger('active:device:' + event);
        this._hadActiveDevice = hasActiveDevice;

        if (!hasActiveDevice) {
          console.warn(this._loggerPrefix(), 'no active device!');
        }
      }
    },

    _destroyDevices: function () {
      _.each(this._rawDevices, function (device) {
        device.destroy();
      });

      this._rawDevices = [];
    },

    _retrieveDevices: function () {
      var deferred = new Deferred();

      var deviceGetter = this.type() + 'Devices';
      this._phone()[deviceGetter]()
        .done(this.cb(function (devices) {
          var retrievingError;

          this._destroyDevices();
          this._rawDevices = devices;

          var properties = [];
          var methods = [];

          var retrievingDone = _.after(_.size(this._propertyNames), this.cb(function () {
            if (retrievingError) {
              this._properties = [];
              this._methods = [];
            }
            else {
              console.info(this._loggerPrefix(), 'properties retrieved successfully:', properties);

              this._properties = properties;
              this._methods = methods;
              this._checkActiveDevice();

              _.each(this._rawDevices, this.bind(function (device, deviceIndex) {
                var isMutedIndex = this._propertyNames.indexOf('isMuted');
                var volumeIndex = this._propertyNames.indexOf('volume');

                device.on('volumeChanged', this.cb(function(volume, isMuted) {
                  this._properties[isMutedIndex][deviceIndex] = isMuted;
                  this._properties[volumeIndex][deviceIndex] = volume;

                  this._triggerDeviceRefreshed();
                }));
              }));
            }

            this._triggerDeviceRefreshed();
            deferred.resolve();
          }));

          _.map(this._propertyNames, this.bind(function (propertyName, propertyIndex) {
            async.map(devices, this.cb(function (device, next) {
              device[propertyName]()
                .done(function (value) {
                  next(null, value);
                })
                .fail(next);
            }), this.cb(function (err, result) {
              if (err) {
                retrievingError = err;
                console.error(this._loggerPrefix(), 'cannot get device "' + propertyName +'" due to error:', err);
              } else {
                properties[propertyIndex] = result;
              }

              retrievingDone();
            }));
          }));

          var settings = this._settings();
          var settingName = this._settingName();

          methods = _.map(this._methodNames, this.bind(function (methodName) {
            return _.map(devices, function (device) {
              var activateFn = function () {
                settings.set(settingName, this.description);
                return device[methodName]();
              };

              var commonFn = function (arg) {
                return device[methodName](arg);
              };

              return (methodName === 'activate')? activateFn: commonFn;
            });
          }));
        }))
        .fail(this.cb(function (err) {
          console.error(this._loggerPrefix(), 'cannot get devices due to error:', err);

          deferred.reject(err);
        }));

      return deferred.promise();
    }
  });

  MediaDevices.mixin(Events);

  return MediaDevices;
});

define('websoftphone/settings',[
  'f9phone/object',
  'f9phone/deferred',
  'local.storage',
  'underscore'
],
function(Object, Deferred, LocalStorage, _) {
  var Settings = Object.extend({
    get: function (name) {
      return this._settings[name];
    },

    set: function (name, value) {
      this._settings[name] = value;
      LocalStorage.set(this._localStorageName(), this._settings);

      var data = JSON.stringify(this._settings);
      this._agent.KeyStore().putItem(this._name, {value: data, category: 'StationSettings'});
    },

    restore: function () {
      var deferred = new Deferred();

      this._settings = LocalStorage.get(this._localStorageName());

      if (_.isObject(this._settings)) {
        console.info('Softphone settings: restored value:', this._settings);
        deferred.resolve();
      }
      else {
        this._agent.KeyStore().getItem(this._name)
          .always(this.cb(function(xhr, status, error){
            if (status === 'success') {
              this._settings = JSON.parse(xhr.value);
              console.info('Softphone settings: restored value:', this._settings);
            } else {
              xhr.disableGlobalHandler = (xhr.status === 435);
              this._settings = {};
              console.info('Softphone settings: restore error:', error);
            }

            deferred.resolve();
          }));
      }

      return deferred.promise();
    },

    resetAgent: function (agent) {
      this._agent = agent;
    },

    _init: function (agent, name) {
      this.resetAgent(agent);
      this._name = name;
      this._settings = {};
      this._onSettingsChanged = this.cb(this._onSettingsChangedHandler);

      LocalStorage.on(this._localStorageName(), this._onSettingsChanged);

      this._destructors.push(this.bind(function () {
        LocalStorage.off(this._localStorageName());
      }));
    },

    _localStorageName: function () {
      return this._name + 'For' + _.result(this._agent, 'id');
    },

    _onSettingsChangedHandler: function (data) {
      this._settings = data;
    }
  });

  return Settings;
});

define('websoftphone/mock',[
  'f9phone/object',
  'f9phone/events',
  'f9phone/deferred'
],
function(Object, Events, Deferred) {
  var FakeMediaDevices = Object.extend({
    _init: function (type, descriptions) {
      this._type = type;

      var devices = _.map(descriptions, this.bind(function (description) {
        var device = {
          description: description,
          isActive: false,
          isMuted: false,
          volume: 100
        };

        device.activate = this.cb(function () {
          _.each(devices, function (d) {
            d.isActive = false;
          });

          device.isActive = true;

          this.trigger('devices:refreshed');
        });

        device.mute = this.cb(function (flag) {
          device.isMuted = flag;
          this.trigger('devices:refreshed');
        });

        device.setVolume = this.cb(function (volume) {
          volume = volume < 0? 0: volume;
          volume = volume > 100? 100: volume;
          device.volume = volume;
          this.trigger('devices:refreshed');
        });

        return device;
      }));

      devices[0].isActive = true;
      this._devices = devices;
    },

    type: function () {
      return this._type;
    },

    devices: function () {
      return this._devices;
    },

    activeDevice: function () {
      return _.findWhere(this.devices(), {isActive: true});
    }
  });

  FakeMediaDevices.mixin(Events);

  var enableMockApi = function (softphone) {
    var run = function () {
      var deferred = new Deferred();
      deferred.resolve();
      return deferred.promise();
    };

    softphone._creationFlow.run = run;
    softphone._registrationFlow.run = run;

    softphone.captureDevices = function () {
      return new FakeMediaDevices('capture', ['Headset microphone', 'Built-in microphone']);

    };

    softphone.playbackDevices = function () {
      return new FakeMediaDevices('playback', ['Headset', 'Built-in audio', 'Speaker']);

    };

    softphone.hasActiveCall = function () {
      return true;
    };
  };

  return enableMockApi;
});

define('softphone',[
  'f9phone/f9phone',
  'f9phone/object',
  'f9phone/events',
  'f9phone/deferred',
  'f9phone/browser',
  'websoftphone/flow',
  'websoftphone/account',
  'websoftphone/media.devices',
  'websoftphone/settings',
  'websoftphone/error.codes',
  'websoftphone/mock',
  'async',
  'jquery',
  'underscore'
],
function(createSoftphone, Object, Events, Deferred, Browser, Flow, Account, MediaDevices, Settings, ErrorCodes, enableMock, async, $, _) {
  var f9phoneAttr = function (attrName) {
    return $('#f9phone').attr(attrName);
  };

  var createDownloadError = function (error) {
    var ret;

    if (error) {
      ret = {what: ErrorCodes.UpdateDownloadFailed, details: error};
    }

    return ret;
  };

  var Softphone = Object.extend({
    resetAgent: function (agent) {
      this._agent = agent;
      this._settings.resetAgent(agent);
    },

    captureDevices: function () {
      return this._captureDevices;
    },

    playbackDevices: function () {
      return this._playbackDevices;
    },

    whatInstall: function () {
      return this._whatInstall;
    },

    isRegistered: function () {
      return _.any(this._accounts, function (account) {
        return account.isRegistered();
      });
    },

    hasActiveCall: function () {
      return _.any(this._accounts, function (account) {
        return account.hasActiveCall();
      });
    },

    sendDtmf: function (tones) {
      return this._safeActiveAccount('sendDtmf').sendDtmf(tones);
    },

    autoGainControl: function () {
      return this._safePhone('autoGainControl').autoGainControl();
    },

    setAutoGainControl: function (value) {
      this._settings.set('autoGainControl', value);
      return this._safePhone('setAutoGainControl').setAutoGainControl(value);
    },

    autoEchoCancellation: function () {
      return this._safePhone('autoEchoCancellation').autoEchoCancellation();
    },

    setAutoEchoCancellation: function (value) {
      this._settings.set('autoEchoCancellation', value);
      return this._safePhone('setAutoEchoCancellation').setAutoEchoCancellation(value);
    },

    isCreated: function () {
      return this._creationFlow.state() === Flow.State.Done;
    },

    isOutdated: function () {
      return this.isCreated() && (this._binaryVersion !== this._softphone.jsVersion);
    },

    binaryVersion: function() {
      return this.isCreated() ? this._binaryVersion: '';
    },

    jsVersion: function() {
      return this.isCreated() ? this._softphone.jsVersion: '';
    },

    create: function () {
      return this._creationFlow.run()
        .done(this.cb(this._onCreationFlowDone));
    },

    download: function () {
      return this._downloadFlow.run()
        .done(this.cb(function () {
          delete this._whatInstall;
        }))
        .fail(this.cb(this._createWhatInstall));
    },

    update: function () {
      return this._updateFlow.run();
    },

    register: function () {
      return this._registrationFlow.run();
    },

    deregister: function () {
      this._registrationFlow.reset();

      _.map(this._accounts, function (account) {
        account.deregister();
        account.destroy();
      });

      delete this._accounts;
      this._triggerIsRegistered();
      this._triggerHasActiveCall();
    },

    _init: function (agent, tenantId, useMock) {
      this._tenantId = tenantId;
      this._settings = new Settings(agent, 'MediaSettings');

      this.resetAgent(agent);

      this._creationFlow = new Flow([
        '_restoreSettings',
        '_getSoftphoneConfig',
        '_createSoftphone',
        '_getVersion',
        '_createPhone',
        '_createMediaDevices',
        '_setPtime',
        '_setSilenceSuppression',
        '_getCodecs',
        '_setCodecs',
        '_restoreAutoGainControl',
        '_restoreAutoEchoCancellation',
        '_afterSoftphoneCreated'
      ], this);

      this._downloadFlow = new Flow([
        '_downloadUpdate'
      ], this, {rerun: true});

      this._updateFlow = new Flow([
        '_switchToUpdatedVersion'
      ], this, {rerun: true});

      this._registrationFlow = new Flow([
        '_createAccounts',
        '_registerAccounts'
      ], this, {rerun: true});

      if (useMock) {
        enableMock(this);
      }

      this._triggerIsRegistered = _.debounce(this.cb(function () {
        this.trigger('isRegistered', this.isRegistered());
      }), 500);

      this._captureDevices = new MediaDevices(this, 'capture');
      this._playbackDevices = new MediaDevices(this, 'playback');

      this._destructors.push(this.bind(function () {
        this._captureDevices.destroy();
        this._playbackDevices.destroy();
        this._settings.destroy();

        this.off();
        this.stopListening();

        this._creationFlow.cancel();
        this._creationFlow.destroy();

        this._registrationFlow.cancel();
        this._registrationFlow.destroy();

        this._downloadFlow.cancel();
        this._downloadFlow.destroy();

        this._updateFlow.cancel();
        this._updateFlow.destroy();

        this.deregister();

        if (_.isObject(this._phone)) {
          this._phone.destroy();
          delete this._phone;
        }

        if (_.isObject(this._softphone)) {
          this._softphone.destroy();
          delete this._softphone;
        }

        delete this._softphoneConfig;
        delete this._binaryVersion;
        delete this._onCreationFlowDone;
        delete this._whatInstall;
      }));
    },

    _binaryBaseUrl: function () {
      return Browser.origin + f9phoneAttr('data-base-url');
    },

    _binaryUrl: function (name) {
      return this._binaryBaseUrl() + '/' + name;
    },

    _createChromeExtensionInstaller: function () {
      var chromeExtensionId = f9phoneAttr('data-chrome-extension-id');
      var url = 'https://chrome.google.com/webstore/detail/' + chromeExtensionId;

      if ($('head link[rel="chrome-webstore-item"]').length === 0) {
        $('head').append('<link rel="chrome-webstore-item" href="' + url + '">');
      }

      var install = function () {
        console.info("Softphone: trying to install Chrome extension");

        var onSuccess = function () {
          console.info("Softphone: Chrome extension installed");

          window.location.reload(false);
        };

        var onError = function (error) {
          console.info('Softphone: error during Chrome extension inline installation:', error);

          if (error !== 'User cancelled install') {
            window.open(url, '_blank');
          }
        };

        chrome.webstore.install(url, onSuccess, onError);
      };

      return {
        url: url,
        install: install
      };
    },

    _createSafariExtensionInstaller: function () {
      var url = this._binaryUrl('Five9Softphone.safariextz');

      var install = function () {
        console.info("Softphone: trying to install Safari extension");

        window.open(url, '_self');
      };

      return {
        url: url,
        install: install
      };
    },

    _createWhatInstall: function (error) {
      delete this._whatInstall;

      var appNotFoundErrors = [
        ErrorCodes.ApplicationNotFound,
        ErrorCodes.PluginNotFound,
        ErrorCodes.ApplicationDisconnected,
        ErrorCodes.SafariExtensionVersionMismatch,
        ErrorCodes.UpdateDownloadFailed
      ];

      if (_.contains(appNotFoundErrors, error.what)) {
        var platform = navigator.platform.toLowerCase();
        var supportedPlatforms = ['macintel', 'win32'];

        if (!_.contains(supportedPlatforms, platform)) {
          platform = 'unsupported';
        }

        var isChromeExtension = (error.details === 'chrome extension required');
        var isSafariExtension = (error.details === 'safari extension required' ||
                                 error.what === 'safari extension version mismatch');

        var installer;
        var extension;

        if (platform === 'macintel') {
          installer = 'Five9Softphone.dmg';
        } else if (platform === 'win32') {
          installer = 'Five9Softphone.msi';
        }

        if (isChromeExtension) {
          extension = this._createChromeExtensionInstaller();
        }

        if (isSafariExtension) {
          extension = this._createSafariExtensionInstaller();
        }

        if (_.isString(installer)) {
          this._whatInstall = {
            installer: this._binaryUrl(installer),
            extension: extension
          };
        }
      }
    },

    _safeApi: function (api, method, error) {
      if (!_.isObject(api)) {
        api = {};

        api[method] = function () {
          var deferred = new Deferred();
          deferred.reject({what: error});
          return deferred.promise();
        };
      }

      return api;
    },

    _safePhone: function (method) {
      return this._safeApi(this._phone, method, 'softphone is not created');
    },

    _safeActiveAccount: function (method) {
      var activeAccount = _.find(this._accounts, function (account) {
        return account.hasActiveCall();
      });

      return this._safeApi(activeAccount, method, 'softphone is not connected');
    },

    _triggerHasActiveCall: function () {
      this.trigger('hasActiveCall', this.hasActiveCall());
    },

    _reset: function (error) {
      console.info('Softphone: reset softphone');

      this.stopListening();
      this._createWhatInstall(error);

      this._creationFlow.fail(error);
      this._registrationFlow.fail(error);
      this._downloadFlow.fail(error);

      this._captureDevices.reset();
      this._playbackDevices.reset();

      _.map(this._accounts, function (account) {
        account.destroy();
      });

      delete this._accounts;
      delete this._softphoneConfig;
      delete this._binaryVersion;
      delete this._onCreationFlowDone;

      if(_.isObject(this._phone)) {
        this._phone.destroy();
        delete this._phone;
      }

      if(_.isObject(this._softphone)) {
        this._softphone.destroy();
        delete this._softphone;
      }

      this._triggerIsRegistered();
      this._triggerHasActiveCall();
      this.trigger('softphone:reset');
    },

    _restoreSettings: function (next) {
      console.info('Softphone: restore settings');

      this._settings.restore()
        .always(next);
    },

    _createSoftphone: function (next) {
      console.info('Softphone: create softphone');

      var chromeExtensionId = f9phoneAttr('data-chrome-extension-id');
      var safariExtensionMinVersion = f9phoneAttr('data-safari-extension-min-version');

      if (!_.isObject(this._softphone)) {
        this._softphone = createSoftphone(chromeExtensionId, safariExtensionMinVersion);
        this.listenTo(this._softphone, 'communication:error', this._reset);
      }

      next();
    },

    _createPhone: function (next) {
      console.info('Softphone: create phone api');

      var options = {
        engine: this._softphoneConfig.softphoneType(),
        engineOptions: {
          counterPathLicense: this._softphoneConfig.licence()
        }
      };

      this._softphone.createPhone(this._tenantId, options)
        .done(this.cb(function (phone) {
          delete this._whatInstall;
          this._phone = phone;
          next();
        }))
        .fail(this.cb(function (error) {
          this._createWhatInstall(error);
          next();
        }));
    },

    _enableDownloadEvents: function (next) {
      var marker = {};

      this._softphone.on('downloadProgress', this.cb(function(current, total) {
        var progress = 0;

        if (total) {
          progress = parseInt(100 * current / total, 10);
        }

        this.trigger('download:progress', progress);
      }), marker);

      this._softphone.on('downloadFinished', this.cb(function(error) {
        this.trigger('download:progress', 100);
        this._disableEventsByMarker(marker);
        next(createDownloadError(error));
      }), marker);

      return marker;
    },

    _disableEventsByMarker: function (marker) {
      if (this._softphone) {
        this._softphone.off(null, null, marker);
      }
    },

    _downloadUpdate: function (next) {
      console.info('Softphone:  download softphone');

      var marker = this._enableDownloadEvents(next);

      this._softphone.download({
        url: this._binaryBaseUrl(),
        version: this._softphone.jsVersion
      })
        .fail(this.cb(function(error) {
          this._disableEventsByMarker(marker);
          next(createDownloadError(error));
        }));
    },

    _switchToUpdatedVersion: function (next) {
      var marker = {};

      this._softphone.on('ready', this.cb(function(version) {
        console.info('Softphone: switched to: ', version);
        this._disableEventsByMarker(marker);
        next();
      }), marker);

      this._softphone.switchTo(this._softphone.jsVersion)
        .fail(this.cb(function(error) {
          this._disableEventsByMarker(marker);
          var updateError;

          if (error) {
            updateError = {what: ErrorCodes.UpdateFailed, details: error};
          }

          next(updateError);
        }));
    },

    _getVersion: function (next) {
      console.info('Softphone: get version');

      this._softphone.binaryVersion()
        .done(this.cb(function (binaryVersion) {
          console.info('Softphone: f9 phone version (js library, binary): (' +
                      this._softphone.jsVersion + ', '+ binaryVersion + ')');
          this._binaryVersion = binaryVersion;
          next();
        }))
        .fail(this.cb(function (error) {
          this._createWhatInstall(error);
          next(error);
        }));
    },

    _createMediaDevices: function (next) {
      console.info('Softphone: create media devices');

      var mediaDevices = [this._playbackDevices, this._captureDevices];

      async.all(mediaDevices, this.cb(function (devices, done) {
        devices.create()
          .done(function () {
            devices.restoreActiveDevice();
            done(true);
          })
          .fail(function (error) {
            console.error('Softphone: failed to to create', devices.type(), 'due to', error);
            done(false);
            next(error);
          });
      }), function (allSet) {
        if (allSet) {
          next();
        }
      });
    },

    _afterSoftphoneCreated: function (next) {
      this.listenTo(this._softphone, 'ready', this._reset);
      next();
    },

    _onCreationFlowDone: function () {
      this.trigger('softphone:created');

      if (this.isOutdated()) {
        this.trigger('softphone:outdated');
      }

      this._onCreationFlowDone = function () {};
    },

    _getSoftphoneConfig: function (next) {
      console.info('Softphone: get softphone config');

      var softphoneConfig = this._agent.SoftphoneConfig();
      delete this._softphoneConfig;

      softphoneConfig.fetch({cache: false})
        .done(this.cb(function() {
          this._softphoneConfig = softphoneConfig.clone();
          next();
        }))
        .fail(function () {
          next('Softphone: config fetch failed');
        });
    },

    _setPtime: function (next) {
      console.info('Softphone: set ptime');

      this._phone.setPtime(this._softphoneConfig.ptime())
        .done(function () {
          next();
        })
        .fail(function (error) {
          next(error);
        });
    },

    _setSilenceSuppression: function (next) {
      console.info('Softphone: set silence suppression');

      this._phone.setSilenceSupression(this._softphoneConfig.silenceSuppression())
        .done(function () {
          next();
        })
        .fail(function (error) {
          next(error);
        });
    },

    _getCodecs: function (next) {
      console.info('Softphone: get codecs');

      this._phone.codecs()
        .done(this.cb(function (availableCodecs) {
          var requestedCodecs = this._softphoneConfig.codecs();

          if (this._softphoneConfig.softphoneType() === 'COUNTERPATH') {
            var codecMap = {
              'PCMU/8000/1': 'G711 uLaw',
              'PCMA/8000/1': 'G711 aLaw',
              'G729/8000/1': 'G.729'
            };

            requestedCodecs = _.compact(_.map(requestedCodecs, function (codec){
              return codecMap[codec];
            }));
          }

          this._codecs = _.map(availableCodecs, function (codec) {
            var codecIndex = requestedCodecs.indexOf(codec.name);
            var ret = {name: codec.name};
            ret.priority = (codecIndex === -1) ? 0 : (128 - codecIndex);
            return ret;
          });

          next();
        }))
        .fail(function (error) {
          next(error);
        });
    },

    _setCodecs: function (next) {
      console.info('Softphone: set codecs');

      async.all(this._codecs, this.cb(function (codec, done) {
        this._phone.setCodecPriority(codec)
          .done(function () {
            done(true);
          })
          .fail(function (error) {
            console.error('Softphone: failed to set codec priority for', codec, 'due to', error);
            done(false);
            next(error);
          });
      }), function (allSet) {
        if (allSet) {
          next();
        }
      });
    },

    _restoreAutoGainControl: function (next) {
      console.info('Softphone: restore auto gain control');

      var agc;

      if (!this._softphoneConfig.overrideUserSettings()) {
        agc = this._settings.get('autoGainControl');
      }

      if (!_.isBoolean(agc)) {
        agc = this._softphoneConfig.agc();
      }

      this.setAutoGainControl(agc)
        .always(function () {
          next();
        });
    },

    _restoreAutoEchoCancellation: function (next) {
      console.info('Softphone: restore auto echo cancellation');

      var aec;

      if (!this._softphoneConfig.overrideUserSettings()) {
        aec = this._settings.get('autoEchoCancellation');
      }

      if (!_.isBoolean(aec)) {
        aec = this._softphoneConfig.aec();
      }

      this.setAutoEchoCancellation(aec)
        .always(function () {
          next();
        });
    },

    _createAccounts: function (next) {
      console.info('Softphone: create accounts ...');

      var protocol = this._softphoneConfig.protocol();

      if (!this._accounts) {
        async.map(this._softphoneConfig.domains(), this.cb(function (domain, done) {
          if (protocol === 'tls') {
            var parts = domain.split(/:(\d+)$/, 2);

            if (parts.length === 2) {
              parts[1] = +parts[1] + 1;
            }

            domain = parts.join(':');
          }

          var account = new Account(this._phone, {
            username: this._softphoneConfig.username(),
            password: this._softphoneConfig.password(),
            domain: domain,
            protocol: protocol,
            sip: {port: this._softphoneConfig.sipPort(), range: this._softphoneConfig.sipPortRange()},
            rtp: {port: this._softphoneConfig.rtpPort(), range: this._softphoneConfig.rtpPortRange()}
          });

          account.on('isRegistered', this._triggerIsRegistered, this);
          account.on('hasActiveCall', this._triggerHasActiveCall, this);

          account.create()
            .done(function () {
              done(null, account);
            })
            .fail(done);
        }), this.cb(function (error, result) {
          if (!error) {
            this._accounts = result;
          }

          next(error);
        }));
      }
      else {
        next();
      }
    },

    _registerAccounts: function (next) {
      console.info('Softphone: register accounts ...');

      var registrationError;

      async.any(this._accounts, function (account, done) {
        account.register()
          .done(function () {
            done(true);
          })
          .fail(function (error) {
            registrationError = error;
            done(false);
          });
      }, function (registered) {
        next(registered? undefined: registrationError);
      });
    }
  });

  Softphone.mixin(Events);

  return Softphone;
});

define('agent.station',[
  'f9phone/object',
  'f9phone/events',
  'softphone',
  'websoftphone/flow',
  'models/server/station',
  'underscore'
],
function(Object, Events, Softphone, Flow, StationModel, _) {
  var AgentStation = Object.extend({
    isSoftphone: function () {
      return this._agent.Station().stationType() === StationModel.Types.SOFTPHONE;
    },

    isEmpty: function () {
      return this._agent.Station().stationType() === StationModel.Types.EMPTY;
    },

    state: function () {
      return this._state;
    },

    restoreState: function () {
      console.info('Agent Station: restoring state...');

      var restoreStateFlow;

      if (this.isSoftphone()) {
        restoreStateFlow = this._softphoneRestoreStateFlow;

        var state = this._softphoneRestartFlow.state();

        if (state === Flow.State.Done || state === Flow.State.InProgress) {
          restoreStateFlow = this._softphoneRestartFlow;
        }
      }
      else {
        restoreStateFlow = this._commonRestoreStateFlow;
      }

      return this._runFlow(restoreStateFlow);
    },

    restart: function () {
      console.info('Agent Station: restarting...');

      var restartFlow = this._restartFlow();

      if (_.isObject(this._currentFlow)) {
        restartFlow.replace(this._currentFlow);
      }

      return this._runFlow(restartFlow);
    },

    resetAgent: function (agent) {
      if (_.isObject(this._agent)) {
        this._agent.Station().off(null, null, this);
      }

      this._agent = agent;

      if (!this.isSoftphone()) {
        this._agent.Station().on('change:state', this._updateState, this);
        this._updateState();
      }
    },

    _init: function (agent, getSoftphone) {
      this._commonRestoreStateFlow = new Flow ([
      ], this);

      this._softphoneRestoreStateFlow = new Flow ([
        '_initSoftphone',
        '_registerSoftphone'
      ], this);

      this._softphoneForcedRestoreStateFlow = new Flow ([
        '_registerSoftphone'
      ], this, {rerun: true});

      this._commonRestartFlow = new Flow([
        '_destroySoftphone',
        '_restartStation'
      ], this, {globalName: 'common-restart', rerun: true});

      this._softphoneRestartFlow = new Flow([
        '_initSoftphone',
        '_unmuteAudioDevices',
        '_deregisterSoftphone',
        '_registerSoftphone',
        '_restartStation'
      ], this, {globalName: 'softphone-restart'});

      this._commonRestartFlow.on('state:changed', this.cb(this._onRestartFlowStateChanged));
      this._softphoneRestartFlow.on('state:changed', this.cb(this._onRestartFlowStateChanged));

      this._emptyRestartFlow = new Flow ([
      ], this);

      this._updateState = _.debounce(this.cb(this._updateStateHandler), 500);

      this._getSoftphone = getSoftphone;
      this.resetAgent(agent);

      this._destructors.push(this.bind(function () {
        var flows = [
          this._commonRestoreStateFlow,
          this._softphoneRestoreStateFlow,
          this._softphoneForcedRestoreStateFlow,
          this._commonRestartFlow,
          this._softphoneRestartFlow,
          this._emptyRestartFlow
        ];

        _.each(flows, function (flow) {
          flow.cancel();
          flow.destroy();
        });

        this._disableSoftphone();
        this._agent.Station().off(null, null, this);
      }));
    },

    _restartFlow: function () {
      return this.isSoftphone()? this._softphoneRestartFlow:
        this.isEmpty()? this._emptyRestartFlow: this._commonRestartFlow;
    },

    _restoreFlow: function () {
      return this.isSoftphone()? this._softphoneRestoreStateFlow: this._commonRestoreStateFlow;
    },

    _forcedRestoreStateFlow: function () {
      return this.isSoftphone() && this._softphone().isCreated()? this._softphoneForcedRestoreStateFlow: this._restoreFlow();
    },

    _setState: function (newState) {
      if (this._state !== newState) {
        console.info('Agent Station: state changed from', this._state, 'to', newState);

        this._state = newState;
        this.trigger(newState);
        this.trigger('stateChanged', newState);
      }
    },

    _updateStateHandler: function () {
      var newState = AgentStation.State.Disconnected;

      if (!this.isEmpty()) {
        var hasActiveCall = this.isSoftphone() ? this._softphone().hasActiveCall() : true;
        var modelConnected = this.isSoftphone()? true: this._agent.Station().stationState() === StationModel.States.Connected;
        var restartInProgress = this._restartInProgress();
        var restoreInProgress = this._restoreFlow().isInProgress();


        if (restartInProgress) {
          newState = AgentStation.State.Connecting;
        }
        else if (hasActiveCall && modelConnected) {
          newState = AgentStation.State.Connected;
        }
        else if (restoreInProgress) {
          newState = AgentStation.State.Restoring;
        }
      }

      this._setState(newState);
    },

    _restartInProgress: function () {
      return this._restartFlow().isInProgress() || this._softphoneForcedRestoreStateFlow.isInProgress();
    },

    _softphone: function () {
      if (!_.isObject(this._sf)) {
        this._sf = this._getSoftphone();
      }

      return this._sf;
    },

    _disableSoftphone: function () {
      if (_.isObject(this._sf)) {
        if (this._softphoneAutoRestartTimeout) {
          clearTimeout(this._softphoneAutoRestartTimeout);
          delete this._softphoneAutoRestartTimeout;
        }

        this._sf.off(null, null, this);
        this._sf.deregister();
        delete this._sf;
      }
    },

    _onSoftphoneReset: function () {
      this._softphoneRestartFlow.reset();
      this._softphoneRestoreStateFlow.reset();
    },

    _onRestartFlowStateChanged: function (state) {
      console.info('Agent Station: restart flow state:', state);

      if (this._restartFlow().isInProgress()) {
        this._softphoneForcedRestoreStateFlow.reset();
        this._setState(AgentStation.State.Connecting);
      }
      else {
        this._forcedRestoreState();
      }
    },

    _forcedRestoreState: function () {
      this._forcedRestoreStateFlow().run()
        .always(this.cb(this._updateState));

      this._updateState();
    },

    _softphoneAutoRestart: function () {
      var wasRestarted = !this._restartInProgress() &&
                         (this._softphoneRestartFlow.state() !== Flow.State.NotDone);
      var wasNotScheduled = _.isUndefined(this._softphoneAutoRestartTimeout);

      if (this.isSoftphone() && wasRestarted && wasNotScheduled &&
          this._softphone().isRegistered() && !this._softphone().hasActiveCall()) {
        this.restart()
          .done(this.cb(function () {
            delete this._softphoneAutoRestartTimeout;
          }))
          .fail(this.cb(function () {
            this._softphoneAutoRestartTimeout = setTimeout(this.cb(function () {
              delete this._softphoneAutoRestartTimeout;
              this._softphoneAutoRestart();
            }), 15000);
          }));
      }
    },

    _runFlow: function (flow) {
      var promise = flow.run();
      this._updateState();
      promise.always(this.cb(this._updateState));
      this._currentFlow = flow;
      return promise;
    },

    _initSoftphone: function (next) {
      console.info('Agent Station: init softphone');

      var softphone = this._softphone();

      softphone.off('isRegistered', this._softphoneAutoRestart, this);
      softphone.on('isRegistered', this._softphoneAutoRestart, this);

      softphone.off('hasActiveCall', this._updateState, this);
      softphone.on('hasActiveCall', this._updateState, this);

      softphone.off('softphone:reset', this._onSoftphoneReset, this);
      softphone.on('softphone:reset', this._onSoftphoneReset, this);

      softphone.create()
        .done(next)
        .fail(function (err) {
          next(err);
        });
    },

    _unmuteAudioDevices: function (next) {
      console.info('Agent Station: unmute audio devices');

      var activeDevices = [
        this._softphone().playbackDevices().activeDevice(),
        this._softphone().captureDevices().activeDevice()
      ];

      _.each(activeDevices, function (activeDevice) {
        if (activeDevice) {
          activeDevice.mute(false);
        }
      });

      next();
    },

    _deregisterSoftphone: function (next) {
      console.info('Agent Station: deregister softphone');

      this._softphone().deregister();
      next();
    },

    _registerSoftphone: function (next) {
      console.info('Agent Station: register softphone');

      this._softphone().register()
        .done(next)
        .fail(this.cb(function (err) {
          if (err.what && err.what === 'plugin crashed') {
            this.restart();
          }
          else {
            next(err);
          }
        }));
    },

    _restartStation: function (next) {
      console.info('Agent Station: restart station');

      this._agent.Station().restart()
        .done(function () {
          next();
        })
        .fail(this.cb(function (error) {
          next(error);
        }));
    },

    _destroySoftphone: function (next) {
      console.info('Agent Station: destroy softphone');

      this._disableSoftphone();
      next();
    }
  }, {
    State: {
      Restoring: 'state:restoring',
      Disconnected: 'state:disconnected',
      Connecting: 'state:connecting',
      Connected: 'state:connected',
      Failed: 'state:failed'
    }
  });

  AgentStation.mixin(Events);

  return AgentStation;
});

define('workflows/wf-utils',[
    'five9',
    'underscore',
    'jquery',
    'models/server/root',
    'dataAdapter-api',
    'agent.station',
    'softphone',
    'local.storage',
    'server.models.storage'
  ],
  function(Five9, _, $, Root, API, AgentStation, Softphone, LocalStorage, ModelStorage) {
    var WorkFlowUtil = {};
    var SESSION_DATA_STORAGE_KEY = 'SESSION_DATA_STORAGE_KEY';
    var SLEEP_DETECTING_INTERVAL = 120000;

    WorkFlowUtil.setupAgentStation = function(){
      var station = Root.Agent(Five9.Context.AgentId).Station();
      return station.fetch().done(
        function() {
          var agent = Root.Agent(Five9.Context.AgentId);

          if (Five9.Context.Softphone) {
            Five9.Context.Softphone().resetAgent(agent);
          }
          else {
            Five9.Context.Softphone = function () {
              if (_.isUndefined(Five9.Context.Softphone._softphone)) {
                Five9.Context.Softphone._softphone = new Softphone(agent, Five9.Context.TenantId, Five9.Context.FakeSoftphone);
              }
              return Five9.Context.Softphone._softphone;
            };

            Five9.Context.Softphone.destroy = function () {
              if (_.isObject(Five9.Context.Softphone._softphone)) {
                Five9.Context.Softphone._softphone.destroy();
                delete Five9.Context.Softphone._softphone;
              }
            };
          }

          if (Five9.Context.AgentStation) {
            Five9.Context.AgentStation.resetAgent(agent);
          }
          else {
            Five9.Context.AgentStation = new AgentStation(agent, Five9.Context.Softphone);
          }
        });
    };

   WorkFlowUtil.destroyAgentStation = function () {
     if (Five9.Context.AgentStation) {
       Five9.Context.AgentStation.destroy();
       delete Five9.Context.AgentStation;
     }

     if (Five9.Context.Softphone) {
       Five9.Context.Softphone.destroy();
       delete Five9.Context.Softphone;
     }
    };

    WorkFlowUtil.saveSessionData = function(sessionData) {
      LocalStorage.set(SESSION_DATA_STORAGE_KEY, sessionData);
    };

    WorkFlowUtil.initContextSessionData = function (sessionData) {
      Five9.Context.AgentId = sessionData.userId;
      Five9.Context.TenantId = "" + sessionData.orgId;
      Five9.Context.authToken = sessionData.tokenId;
    };

    WorkFlowUtil.initContext = function (sessionData) {
      this.initContextSessionData(sessionData);

      Five9.Context.Agent = Root.Agent(Five9.Context.AgentId);
      Five9.Context.Tenant = Root.Tenant(Five9.Context.TenantId);

      if (sessionData.context) {
        Five9.Context.pwdExpiryDays = sessionData.context.pwdExpiryDays;
      }
    };

    WorkFlowUtil.loadSessionData = function () {
      return LocalStorage.get(SESSION_DATA_STORAGE_KEY);
    };

    WorkFlowUtil.clearSessionData = function () {
      return LocalStorage.remove(SESSION_DATA_STORAGE_KEY);
    };

    WorkFlowUtil.initApiBaseURL = function (sessionData) {
      var apiBaseURL = WorkFlowUtil.retrieveApiBaseURL(sessionData);
      if (apiBaseURL) {
        Five9.Properties.setApiBaseURL(apiBaseURL);
      }
      else {
        Five9.Properties.resetApiBaseURL();
      }
    };
    WorkFlowUtil.isApiBaseURLchanged = function (sessionData) {
      var apiBaseURL = WorkFlowUtil.retrieveApiBaseURL(sessionData);
      if (apiBaseURL) {
        return Five9.Properties.getApiBaseURL() !== apiBaseURL;
      }
      return false;
    };

    WorkFlowUtil.retrieveApiBaseURL = function (sessionData) {
      var apiBaseURL = null;
      if (sessionData && _.isObject(sessionData.metadata) && _.isArray(sessionData.metadata.dataCenters)) {
        var activeDC = _.findWhere(sessionData.metadata.dataCenters, {active: true});
        if (activeDC && _.isArray(activeDC.apiUrls)) {
          var firstDC = _.first(activeDC.apiUrls);
          if (_.isObject(firstDC)) {
            apiBaseURL = window.location.protocol + '//' + firstDC.host + ':' + firstDC.port;
          }
        }
      }
      return apiBaseURL;
    };

    WorkFlowUtil.retrieveAgentMetadata = function (dfd, sessionData) {
      var deferred = dfd || $.Deferred();
      WorkFlowUtil.initApiBaseURL(sessionData);
      API.performAction('auth', 'GET', null, 'metadata')
          .done(function (sessionData) {
            if (WorkFlowUtil.isApiBaseURLchanged(sessionData)) {
              WorkFlowUtil.retrieveAgentMetadata(deferred, sessionData);
            }
            else {
              WorkFlowUtil.saveSessionData(sessionData);
              deferred.resolve(sessionData);
            }
          })
          .fail(function (jqXHR) {
            WorkFlowUtil.clearSessionData();
            deferred.reject(jqXHR);
          });
      return deferred.promise();
    };

    WorkFlowUtil.PingPongHandler = function (pingInterval, pongWaitCount, failCallback) {
      this.destroy = function () {
        clearInterval(this.pingTimer);
        Five9.vent.off(ModelStorage.WebSocketEvents.PongEvent, this.pongCallback);
      };
      this.start = function () {
        var self = this;
        var lastPingTime = _.now();
        var lastPongTime = lastPingTime + 1;
        self.pongCallback = function () {
          lastPongTime = _.now();
        };
        var failPingPong = function () {
          self.destroy();
          failCallback();
        };
        Five9.vent.on(ModelStorage.WebSocketEvents.PongEvent, self.pongCallback);
        self.pingTimer = setInterval(function () {
          var currentTime = _.now();
          if (currentTime - lastPingTime > pingInterval + SLEEP_DETECTING_INTERVAL) {
            /* Perhaps we was waked up after sleep. Socket connection and UI stat is not valid anymore */
            Five9.Logger.warn('PingPongHandler: Waked up after sleep');
            failPingPong();
            return;
          }

          if (lastPingTime - lastPongTime >= pingInterval * pongWaitCount) {
            // No pong for several pings
            Five9.Logger.error('PingPongHandler: No pong for ' + (lastPingTime - lastPongTime) + ' ms');
            failPingPong();
            return;
          }
          lastPingTime = _.now();
          Root.Agent(Five9.Context.AgentId).ping()
              .fail(function (jqXHR) {
                jqXHR.disableGlobalHandler = true;
                failPingPong();
              });
        }, pingInterval);
      };
    };

    return WorkFlowUtil;
  });

define('modules/rest-api-client/five9ClientEvents',[], function () {
  return {
    NEED_CREDENTIALS: "five9LibNeedCredentials",
    MAINTENANCE_MODE: 'Five9ClientMaintenanceMode',
    MODEL_LOAD: 'five9ClientSocketConnected',
    MODEL_UNLOAD: 'Five9ClientSocketDisconnected'
  };
});
define('modules/rest-api-client/stateMachineUtils',[
  'five9',
  'machina'
], function (Five9, Machina) {
  var stateMachineUtils = {};

  stateMachineUtils.LoggedFsm = Machina.Fsm.extend({
    handle: function (event) {
      Five9.Logger.debug(this.logName + ': handle event: ' + event + ' in state: ' + this.state);
      Machina.Fsm.prototype.handle.apply(this, arguments);
    },
    transition: function (newState) {
      Five9.Logger.debug(this.logName + ': transition from ' + this.state + ' to ' + newState);
      Machina.Fsm.prototype.transition.apply(this, arguments);
    }
  });

  return stateMachineUtils;
});
define('modules/rest-api-client/five9ClientSocketFsm',[
  'five9',
  'underscore',
  'socketAdapter',
  'machina',
  './five9ClientEvents',
  './stateMachineUtils'
], function (Five9, _, SocketAdapter, Machina, ClientEvents, StateMachineUtils) {

  var socketFsm = new StateMachineUtils.LoggedFsm({
    initialState: 'uninitialized',
    logName: 'Five9Client socketFsm',
    states: {
      uninitialized: {
        init: function (vent) {
          this.vent = vent;
          SocketAdapter.initialize(vent);
          vent.on(SocketAdapter.Events.Connected, _.bind(this.onSocketConnected, this));
          vent.on(SocketAdapter.Events.Disconnected, _.bind(this.onSocketDisconnected, this));
          this.transition('disconnected');
        }
      },
      disconnected: {
        connect: function () {
          this.transition('connecting');
        }
      },
      connecting: {
        _onEnter: function () {
          SocketAdapter.connect();
        },
        onSocketConnected: function () {
          this.transition('connected');
        },
        onSocketDisconnected: function () {
          this.reconnectTimeout = setTimeout(function() {
            SocketAdapter.connect();
          }, 5000);
        },
        disconnect: function () {
          this.transition('disconnected');
        },

        _onExit: function() {
          clearTimeout(this.reconnectTimeout);
        }
      },
      connected: {
        _onEnter: function () {
          this.vent.trigger(ClientEvents.MODEL_LOAD);
        },
        onSocketDisconnected: function () {
          this.transition('connecting');
        },
        disconnect: function () {
          this.transition('disconnected');
        },
        _onExit: function () {
          this.vent.trigger(ClientEvents.MODEL_UNLOAD);
        }
      }
    },

    onSocketConnected: function () {
      this.handle('onSocketConnected');
    },

    onSocketDisconnected: function () {
      this.handle('onSocketDisconnected');
    },

    init: function (vent) {
      this.handle('init', vent);
    },

    connect: function (){
      this.handle('connect');
    },

    disconnect: function () {
      this.handle('disconnect');
    },

    destroy: function () {
      this.vent.off(SocketAdapter.Events.Connected, this.onSocketConnected);
      this.vent.off(SocketAdapter.Events.Disconnected, this.onSocketDisconnected);
    }
  });

  return socketFsm;
});

define('modules/rest-api-client/five9ClientFsm',[
  'five9',
  'underscore',
  'machina',
  'dataAdapter',
  'dataAdapter-api',
  'models/server/root',
  'workflows/wf-utils',
  './five9ClientSocketFsm',
  './five9ClientEvents',
  './stateMachineUtils'
], function (Five9, _, Machina, DataAdapter, API, Root, WfUtils, SocketFsm, ClientEvents, StateMachineUtils) {

  var appKey = '3RD_PARTY_INTEGRATION';

  function login (login, password, options) {
    options = options || {};

    var payload = {
        passwordCredentials: {
          username: login,
          password: password
        },

        appKey: appKey
      }
      ;
    if (options.forceLogin === true) {
      payload.policy = "ForceIn";
    } else {
      payload.policy = 'AttachExisting';
    }
    return API.performAction('auth', 'POST', null, 'login', payload);
  }

  function logout () {
    return API.performAction('auth', 'POST', null, 'logout');
  }

  var clientFsm = new StateMachineUtils.LoggedFsm({
    initialState: 'uninitialized',
    logName: 'Five9ClientFsm',
    states: {
      uninitialized: {
        start: function (vent) {
          var self = this;
          this.vent = vent;
          SocketFsm.init(this.vent);

          return WfUtils.retrieveAgentMetadata().then(function (sessionData) {
            self.sessionData = sessionData;
            WfUtils.initContext(sessionData);
            return self.transition('loggedIn');
          }, function () {
            return self.transition('notLoggedIn');
          });
        }
      },

      notLoggedIn: {
        _onEnter: function () {
          SocketFsm.disconnect();
          this.vent.trigger(ClientEvents.NEED_CREDENTIALS);
        },
        login: function (username, password, options) {
          return login(username, password, options)
            .then(function () {
              return WfUtils.retrieveAgentMetadata();
            })
            .then(_.bind(function (sessionData) {
              WfUtils.initContext(sessionData);
              return this.transition('loggedIn');
            }, this))
            .fail(function (error) {
              Five9.Logger.error(error);
            });
        },

        start: function (vent) {
          /* Force uninitialized state to get metadata again
           * for case when login was requested somewhere else
           */
          this.transition('uninitialized');
          return this.handle('start', vent);
        }
      },
      loggedIn: {
        _onEnter: function () {
          SocketFsm.connect();

          var loginStateModel = Five9.Context.Agent.LoginState();
          loginStateModel.fetch();

          loginStateModel.on('change:state', _.bind(function (model, newState) {
            if (newState === 'RELOGIN') {
              this.handle('onReloginState');
            }
          }, this));
        },
        logout: function () {
          return logout().then(_.bind(function () {
            this.transition('notLoggedIn');
          }, this));
        },

        onReloginState: function () {
          this.transition('maintenance');
        },

        start: function (vent) {
          this.transition('uninitialized');
          this.handle('start', vent);
          Five9.Logger.error("Can't start in logged in state");
        }
      },

      maintenance: {
        _onEnter: function () {
          SocketFsm.disconnect();
          var self = this;
          function pollSessionRestart(){
            Five9.Context.Agent.restartSession()
              .done(function () {
                self.handle('onSessionRestarted');
              })
              .fail(function () {
                _.delay(pollSessionRestart, 10000);
              });
          }
          pollSessionRestart();
          this.vent.trigger(ClientEvents.MAINTENANCE_MODE);
        },

        onSessionRestarted: function () {
          this.transition('uninitialized');
          this.handle('start');
        }
      }
    },

    login: function (username, password, options) {
      return this.handle('login', username, password, options);
    },

    logout: function (){
      return this.handle('logout');
    },

    start: function (vent) {
      this.handle('start', vent);
    }
  });

  return clientFsm;
});
/*!
 * Five9 REST client Javascript library
 * version:
 *
 * Copyright (c)2016 Five9, Inc.
 */
define('five9.rest.api',[
  'five9',
  'jquery',
  'dataAdapter',
  'dataAdapter-api',
  'socketAdapter',
  'underscore',
  'backbone',
  'local.storage',
  'app/five9.properties',
  'models/server/root',
  'server.models.adapter',
  'server.models.storage',
  'modules/rest-api-client/five9ClientFsm',
  'modules/rest-api-client/five9ClientEvents'
],
function (Five9, $, DataAdapter, API, SocketAdapter, _, Backbone, LocalStorage,
          Properties, Root, ServerModels, ModelStorage, ClientFsm, ClientEvents) {

  $.noConflict(true);
  _.noConflict(true);

  Five9.RestApi = {};

  var baseUrl = 'https://app.five9.com';

  Properties.setApiBaseURL(baseUrl);

  Properties.resetApiBaseURL = function () {
    Properties.apiBaseURL = baseUrl;
  };

  Properties.getWebSocketURL = function() {
    var wsApiBaseURL = this.apiBaseURL.replace(/^http(s?)/, 'ws$1');
    return wsApiBaseURL + '/appsvcs/ws/' + '3rdParty' + LocalStorage.getPageId();
  };

  function replaceLogging(logger, methods) {
    _.each(methods, function (method) {
      var origMethod = logger[method];
      logger[method] = function () {
        if (Five9.RestApi.loggingEnabled) {
          origMethod.apply(logger, arguments);
        }
      };
    });
  }

  replaceLogging(Five9.Logger, ['log', 'debug', 'info', 'error', 'warn']);

  function hideMethods() {

    var excludedMethods = {
      calls: {
        Contact: true,
        Contacts: true,
        AuxData: true
      },

      tenants: {
        CallLoggingConfig: true
      },

      campaigns: {
        fetch: true
      }
    };

    _.each(excludedMethods, function (methods, fileName){
      var serverModel = require('models/server/' + fileName);
      _.each(methods, function (excluded, methodName) {
        serverModel.Model.prototype[methodName] = undefined;
      });
    });
  }

  $.ajaxSetup({
    xhrFields: {
      withCredentials: true
    },
    cache: false,
    timeout: 2 * 60 * 1000
  });

  var internalVent = _.extend({}, Backbone.Events);

  SocketAdapter.initialize(internalVent);
  ModelStorage.initialize(internalVent);
  hideMethods(Root);

  Five9.RestApi.vent = _.extend({}, Backbone.Events);

  Five9.RestApi.login = function (username, password, options) {
    ClientFsm.login(username, password, options);
  };

  Five9.RestApi.logout = function () {
    return ClientFsm.logout();
  };

  Five9.RestApi.getAgent = function () {
    var agentId = Five9.Context.AgentId;
    if (!agentId){
      throw 'Looks like agent is not logged in';
    }
    return Root.Agent(agentId);
  };

  Five9.RestApi.getTenant = function () {
    var orgId = Five9.Context.TenantId;
    if (!orgId) {
      throw 'Looks like agent is not logged in';
    }
    return Root.Tenant(orgId);
  };

  var defaultParams = {
    apiBaseUrl: 'https://app.five9.com'
  };

  Five9.RestApi.start = function (options) {
    options = _.extend(defaultParams, options);
    baseUrl = options.apiBaseUrl;
    Properties.setApiBaseURL(options.apiBaseUrl);
    ClientFsm.start(Five9.RestApi.vent);
  };

  Five9.RestApi.events = ClientEvents;

  return Five9.RestApi;
});
  return require('five9.rest.api');
}));
//static-content-hash-trigger-GCC