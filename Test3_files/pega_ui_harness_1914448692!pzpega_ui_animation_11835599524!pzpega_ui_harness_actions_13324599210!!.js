/* ChangeTrackerMap maintains list of ChangeTracker objects */

/*



PLEASE DO NOT COPY PASTE THIS FILE INTO EDITORS LIKE NOTEPAD++ AS THIS FILE INCLUDES TURKISH CHARACTERS WHICH

WHEN PASTED TO NOTEPAD++ CAN GET CONVERTED TO THEIR ENGLISH EQUAVALENTS AND RESULT IN ISSUES FOR TURKISH LOCALE USERS.

( THE LINES OF CODE IN parseForChangeTrackerDiv FUNCTION. )

REFER : http://stackoverflow.com/questions/7256049/notepad-converting-ansi-encoded-file-to-utf-8


*/

pega.ui.ChangeTrackerMap = new (function() {
	/* private variable used to store ChangeTracker objects with associated ThreadName */
	var trackerMap = {};
	/* private variable used to store the primary tracker */
	var primaryTracker = null;
	/*A dummy tracker to avoid JS errors in case primary tracker is not created */
	var dummyTracker = null;
	/* Public api to get the Tracker object by thread name */
	this.getTrackerByThread = function(threadName) {
		return trackerMap[threadName];
	}
	/* public api to add a tracker object to the map collection */
	this.addTracker = function(threadName, tracker) {
      trackerMap[threadName] = tracker;
      if(primaryTracker == null) {
        primaryTracker = tracker;
        tracker.isPrimary = true;
      } else {
        tracker.isPrimary = false;
      }
    }
	/* public api
	   returns true if we have a single tracker */
	this.isSingleTracker = function() {
        var len =0;
        for (var prop in trackerMap) {
          if (Object.prototype.hasOwnProperty.call(trackerMap, prop)) {
            len++;
          }
        }
        return len === 1;
	}
	/* public api
	 * returns the currently active tracker based on active thread store in pega.u.d.url */
    this.getTracker = function() {
      if(primaryTracker != null)
        return this.isSingleTracker() ? primaryTracker : trackerMap[pega.u.d.getThreadName()];
      else {
        if(pega.u.d && pega.u.d.ServerProxy && pega.u.d.ServerProxy.isHybridClient()){
          var ctObj = new pega.ui.ChangeTracker();
          this.addTracker(pega.u.d.getThreadName(),ctObj);
          return ctObj;
        }
        dummyTracker = dummyTracker || new pega.ui.ChangeTracker();
        return dummyTracker;
      }
    }
	/* returns the dummyTracker */
	this.getDummyTracker = function(){
		dummyTracker = dummyTracker || new pega.ui.ChangeTracker();
		return dummyTracker;
	}
	/* public api
	 * returns the collection of trackers */
	this.getTrackers = function() {
		return trackerMap;
	}
  /* public api
	 * returns the primary tracker from the trackers */
  this.getPrimaryTracker = function(){
    for(var tracker in trackerMap){
      var trackerObj = trackerMap[tracker];
      if(trackerObj.isPrimary) {return trackerObj;}
    }
  }
})();
/* Main ChangeTracker class */
pega.ui.ChangeTracker = function() {
	/*Used to store the corresponding changetracker ID*/
	this.id = null;
	/*Used to store threadName to which the tracker object is associated */
	this.threadName = "";
	/* used to store if the tracker is primary */
	this.isPrimary = true;
	/*Contains properties which have been changed at the server due to server interaction relating to change tracker*/
	this.changedPropertiesList = new Array();
	/*Contains Pages which have addRemove operations at the server due to server interaction relating to change tracker*/
	this.addRemovePagesList = new Array();
	/* Contains collection of the properties with updated values that are currently being tracked */
	this.trackedPropertiesList = new Object();
	/* Contains collection of the non-thread properties that are currently being tracked */
	this.nonThreadTrackedPropertiesList = "";
}
/* This api is used to initialize the change tracker object
*  @jsonDivObj - Change Tracker Div Element
*  @thread - thread name on which tracker is registered
*/
pega.ui.ChangeTracker.prototype.init = function(jsonDivObj, thread) {
	if(jsonDivObj) {
		var jsondata = jsonDivObj.getAttribute("data-json");
		jsondata = pega.tools.Security.decodeCrossScriptingFilter(jsondata, true);
		if( typeof jsondata != 'undefined' && jsondata != null) {
			var temp_trackedPropertiesList = JSON.parse(jsondata);
			var originalValues = temp_trackedPropertiesList.Values;
			temp_trackedPropertiesList.Values = temp_trackedPropertiesList.Initial;
			if(temp_trackedPropertiesList.Values.pxThread != null) {
				var initialTrackedTxnId = temp_trackedPropertiesList.Values.pxThread.pxClientExchange;
				var pudURLTxnId = SafeURL_createFromURL(pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty("url")).get("pzTransactionId");
				/*
				 * These variables are no longer needed as the code using these earlier is commented below
				 *
				var initialFrameName = temp_trackedPropertiesList.Values.pxThread.pxClientFrame;
				var pudURLFrameName = SafeURL_createFromURL(pega.u.d.url).get("pzFromFrame");
				 */
				/* sometimes it is observed that the server is returning different initial value
				 * for pxThread.pxClientExchange than that present in pega.u.d.url populated using <pega:url/>;
				 * it may come even empty String for a New Harness.
				 * In these cases, fix the initial value in the AJAX change tracker by setting it to that in the pega.u.d.url.
				 */
				if(pudURLTxnId && initialTrackedTxnId !== pudURLTxnId) {
					if(temp_trackedPropertiesList.Values && temp_trackedPropertiesList.Values.pxThread) {
						temp_trackedPropertiesList.Values.pxThread.pxClientExchange = pudURLTxnId;
					}
				}
				/*
				 * Commenting the code to set the value of pxClientFrame in the tracker from the pega.u.d.url.
				 * On Clipboard, pxThread.pxClientFrame will have the value of the frame name which did the last COMMIT in the current PRThread.
				 * We want to track this property so that we know on the client which frame did the last commit and hence responsible
				 * for the current value of property pxThread.pxClientExchange.
				 * The pega.u.d.url will have the frame name of the current harness that will be used in interaction with the server.
				 * This may not be same as that in the change tracker if some other frame has already done a COMMIT in the curretn PRThread.
				 * We need the other frame name so that if later the same other frame again COMMITs, change tracker will not respond any
				 * change in the property pxThread.pxClientFrame and in absence of the other frame name in tracker,
				 * we may end up consuming the latest value of pxThread.pxClientExchange.
				 *
				if(pudURLFrameName && initialFrameName !== pudURLFrameName) {
					if(temp_trackedPropertiesList.Values && temp_trackedPropertiesList.Values.pxThread) {
						temp_trackedPropertiesList.Values.pxThread.pxClientFrame = pudURLFrameName;
					}
				}
				 */
			}
			this.id = temp_trackedPropertiesList.ID;
			this.trackedPropertiesList = {};
          	this.merge(this.trackedPropertiesList, temp_trackedPropertiesList.Values, null, false, false);
			this.threadName = thread || pega.u.d.getThreadName();

			pega.ui.ChangeTrackerMap.addTracker(this.threadName, this);
			/*calling merge method to update the non-thread properties list - nonThreadTrackedPropertiesList*/
			this.mergeOnlyNonThread = true;
			this.merge(this.trackedPropertiesList, temp_trackedPropertiesList.Values, null, false, false);
			this.mergeOnlyNonThread = null;
			/* handle cross-thread changes during on load for other active documents*/
			this.currentCTJSONObj = temp_trackedPropertiesList;
			this.currentCTJSONObj.Values = originalValues;
      
      //BUG-411286 IE11 slowness.
      if(pega.util.Event.isIE){
        setTimeout(this.handleXThreadChanges.bind(this),0);
      } else {
         this.handleXThreadChanges();
      }
		}
	}
}
/* This api is used to parse the ajax response to find the changetracker div
 * calls merge if div is detected
 * calls evaluateClientCondition if called from a declare expression response.
 * @newStream - ajax response stream
 * @declareExpression - true if called from declare expression response
 */
pega.ui.ChangeTracker.prototype.parseForChangeTrackerDiv = function(newStream, declareExpression) {
	var ctJSON;
	var searchStartsAt = 0;
      /* HFix-27285/HFix-28263- support turkish characters starts here */
		var isChromeOrSafariOrFF = (navigator.userAgent.indexOf("Chrome/") >= 0) || (navigator.userAgent.indexOf("Safari/")>= 0) || (navigator.userAgent.indexOf("Firefox/")>= 0) ? true : false;
        if(isChromeOrSafariOrFF)
        {
            String.prototype.changeToLower = function(){
							var string = this;
							/* HFix-22661: Removed I from the list which converting ct div id which contains "IAC" in thread name to "1ac" which causing issue in parsing ct div */
							var letters = { "İ": "i", "Ş": "ş", "Ğ": "ğ", "Ü": "ü", "Ö": "ö", "Ç": "ç" };
							string = string.replace(/(([İŞĞÜÇÖ]))/g, function(letter){ return letters[letter]; })
							return string.toLowerCase();
							}
           var lowerCaseNewStream = newStream.changeToLower();
        }
        else
		var lowerCaseNewStream = newStream.toLowerCase();
         /* SR-122860 - support turkish characters  ends here : karij*/

		/* used in case of file upload */
			if(pega.util.Event.isIE) {
				var ctDivBegin1 = "<div style=\"display: none\" id=\"ajaxct_" + this.id +"_"+this.threadName.toLowerCase() + "\">";
			} else {
				var ctDivBegin1 = "<div style=\"display:none\" id=\"ajaxct_" + this.id +"_"+this.threadName.toLowerCase() + "\">";
			}

			while(true) {
				var ctDivBegin = "<div style='display:none' id='ajaxct_" + this.id +"_"+this.threadName.toLowerCase() + "'>";
				var len = ctDivBegin.length;
				var ctDivStartsAt = lowerCaseNewStream.indexOf(ctDivBegin, searchStartsAt);
				if(ctDivStartsAt < 0) {
					ctDivStartsAt = lowerCaseNewStream.indexOf(ctDivBegin1, searchStartsAt);
					len = ctDivBegin1.length;
					if(ctDivStartsAt < 0) {
						/* BUG-82131: In IE sometimes below string is found in response. So added one more check on lowerCaseNewStream */
						ctDivBegin1 = "<div style=\"display: none\" id=ajaxct_" + this.id +"_"+this.threadName.toLowerCase() + ">";
						len = ctDivBegin1.length;
						ctDivStartsAt = lowerCaseNewStream.indexOf(ctDivBegin1, searchStartsAt);
						if(ctDivStartsAt < 0){
							ctDivBegin1 = "<div id=ajaxct_" + this.id +"_"+this.threadName.toLowerCase() + " style=\"display: none\">";
							len = ctDivBegin1.length;
							ctDivStartsAt = lowerCaseNewStream.indexOf(ctDivBegin1, searchStartsAt);
							if(ctDivStartsAt < 0){
								ctDivBegin1 = '<div id="ajaxct_' + this.id +"_"+this.threadName.toLowerCase() + '" style="display: none;">';
								len = ctDivBegin1.length;
								ctDivStartsAt = lowerCaseNewStream.indexOf(ctDivBegin1, searchStartsAt);
								if(ctDivStartsAt < 0){
									ctDivBegin1 = '<div style="display: none;" id="ajaxct_'+ this.id +"_"+this.threadName.toLowerCase() +'">';
									len = ctDivBegin1.length;
									ctDivStartsAt = lowerCaseNewStream.indexOf(ctDivBegin1, searchStartsAt);
                                  	/* BUG-232623: Fix for IE Edge */
                                  	if(ctDivStartsAt < 0){
                                    	ctDivBegin1 = '<div id="ajaxct_' + this.id +"_"+this.threadName.toLowerCase() + '" style="display:none">';
										len = ctDivBegin1.length;
										ctDivStartsAt = lowerCaseNewStream.indexOf(ctDivBegin1, searchStartsAt);
                                    }
								}
							}
						}
						if(ctDivStartsAt < 0) return;
					}
				}
				var ctDivEndsAt = lowerCaseNewStream.indexOf("</div>", ctDivStartsAt);
				if(ctDivEndsAt < ctDivStartsAt) {
					return;
				}
				ctJSON = newStream.substring(ctDivStartsAt + len, ctDivEndsAt);
				this.mergeChangesToMasterList(ctJSON);
        // BUG-620675
        if(declareExpression && this.changedPropertiesList.length > 0) {
			    pega.u.d.evaluateClientConditions('TCL');
	    	}
				searchStartsAt = ctDivEndsAt;
			}
}

/* This api is used to handle cross-thread changes for other active documents
	by merging the non-thread(requestor and node) changes into other trackers and triggering condition evaluation.
 */
pega.ui.ChangeTracker.prototype.handleXThreadChanges = function() {

    var bGlobalExists = false;
    if(!this.currentCTJSONObj) return;
    
    if(this.currentCTJSONObj.RequestorChangeSet) {
      var changedValues = this.currentCTJSONObj.RequestorChangeSet.Values || [];
      bGlobalExists = (changedValues.length > 0);
    }

    if(bGlobalExists){
      var pegaDesktopWin =  pega.desktop.support.getDesktopWindow();
      var pegaDesktopApp = pega.desktop.support.getDesktopApplication();
      
      //trigger evaluation on portal / current window (mashup)
      this.evaluateConditionsOnXThread(pegaDesktopWin || window);
      
      //trigger evaluation on all opened popup windows
      if(pegaDesktopApp && pegaDesktopApp.openedWindows) {
        pegaDesktopApp.openedWindows.forEach(function(openedWin){
          var pegaObj = null;
          if(openedWin){
            try{
              pegaObj = openedWin.pega;
              // skip for closed popups, and launched portal windows
              if(!openedWin.closed && !(pegaObj && pegaObj.ctx && pegaObj.ctx.topHarness)){
                this.evaluateConditionsOnXThread(openedWin);
              }
            }
            catch(e){}
          }
        }.bind(this));
      }
      
      //trigger evaluation on all portal child windows      
      if(pegaDesktopWin) {
        this.trackXThreadChanges(pegaDesktopWin.document);
      }
    }
    this.currentCTJSONObj = null;
}

pega.ui.ChangeTracker.prototype.handlePendingCTChanges = function() {

  if(window.pegaDefer && window.pegaDefer.pendingCTList && window.pegaDefer.pendingCTList.length >0 ){
    var pendintCTCount = window.pegaDefer.pendingCTList.length;
    var changeTracker = pega.ui.ChangeTrackerMap.getTracker();
    if(changeTracker){
      changeTracker.mergeOnlyNonThread = true;
      for(var index =0; index < pendintCTCount; index++){
        var currentCTJSONObj = window.pegaDefer.pendingCTList[index];
          changeTracker.merge(changeTracker.trackedPropertiesList, currentCTJSONObj.Initial, null, true, false);
          var changedValues = currentCTJSONObj.Values;
          if(currentCTJSONObj.proxy){
            changedValues = currentCTJSONObj.proxy.Values;
          }
          changeTracker.merge(changeTracker.trackedPropertiesList, changedValues, null, true, false);
      }
      changeTracker.mergeOnlyNonThread = null;
      if (changeTracker.changedPropertiesList.length > 0) {
        pega.u.d.evaluateClientConditions('TCL', null, true, true);
      }
    }
    delete window.pegaDefer.pendingCTList;
  }
  delete window.pegaDefer;
}

/* This api is used to iterate over all active iframes and trigger condition evaluation.
 * @portalDocument - document where the changes are reported by AJAX response.
 */
pega.ui.ChangeTracker.prototype.trackXThreadChanges = function(portalDocument) {
	var iframes = portalDocument.getElementsByTagName("IFRAME");
	var len = iframes.length;
	for (var i=0; i<len ; i++){
      var currentIframe = iframes[i];
      /* BUG-207118: Added try catch to avoid evaluating cross domain IFRAMES */
      try {
        if(!currentIframe.contentWindow.pega){
          try{
            var ifrName = (currentIframe.name && currentIframe.id == currentIframe.name)? (currentIframe.name.match(/^PegaGadget\d*Ifr$/)): null;
            if(ifrName && ifrName.length == 1){
              currentIframe.contentWindow.pegaDefer = currentIframe.contentWindow.pegaDefer || {};
              currentIframe.contentWindow.pegaDefer.pendingCTList = currentIframe.contentWindow.pegaDefer.pendingCTList || []; 
              currentIframe.contentWindow.pegaDefer.pendingCTList.push(this.currentCTJSONObj);
            }
          }catch(e){}
          continue;
        }
      } catch(e){
        continue;
      }
      if(currentIframe.contentWindow.pega.u && currentIframe.contentWindow.pega.u.d && currentIframe.contentWindow.pega.ui.ChangeTrackerMap.getTracker()){
        this.evaluateConditionsOnXThread(currentIframe.contentWindow);
      }
	}
}

/* This api is used to merge the non-thread changes and evaluate condition on the window object provided.
 * @windowObj - window object where the evaluation has to happen.
 */
pega.ui.ChangeTracker.prototype.evaluateConditionsOnXThread = function(windowObj) {
  
  var pegaObj = null;
  if(windowObj){
    try{
      pegaObj = windowObj.pega;
    }
    catch(e){}
  }
  if(!pegaObj){
     return;
  }

  if(!( windowObj && windowObj.pega && windowObj.pega.u && windowObj.pega.u.d && windowObj.pega.u.d.isHarnessInitialized && windowObj.pega.u.d.isHarnessInitialized() )) {
    windowObj.pegaDefer = windowObj.pegaDefer || {};
    windowObj.pegaDefer.pendingCTList = windowObj.pegaDefer.pendingCTList || [];
    windowObj.pegaDefer.pendingCTList.push(this.currentCTJSONObj);
    return;
  }

    // run through all the trackers in the current document.

    var changeTrackers = windowObj.pega.ui.ChangeTrackerMap.getTrackers();
    var currentCtx = windowObj.pega.ctx;
    for(var threadName in changeTrackers) {
        var changeTracker = changeTrackers[threadName];
        var threadRequestorChangeSet = this.getRequestorChangeSet(changeTracker.threadName, changeTracker.id);

        // continue, if there is no RequestorChangeSet for this given thread and id
        if (!threadRequestorChangeSet) continue;


        changeTracker.mergeOnlyNonThread = true;
        changeTracker.merge(changeTracker.trackedPropertiesList, this.currentCTJSONObj.Initial, null, true, false);


        changeTracker.merge(changeTracker.trackedPropertiesList, threadRequestorChangeSet, null, true, false);
        changeTracker.mergeOnlyNonThread = null;
        
        try{
        // skip evaluation on inactive documents, and popups, just merge.
          if(windowObj.frameElement && windowObj.frameElement.offsetHeight == 0){
            continue;
          }
        //if(windowObj.opener && windowObj.opener != window) continue;
        }catch(e){
        }

        if (changeTracker.changedPropertiesList.length > 0) {
          windowObj.pega.ctxmgr.setContext(windowObj.pega.ctxmgr.getContextByThreadName(threadName));
          var gSectionReloaded = windowObj.pega.ctx.gSectionReloaded;
          windowObj.pega.u.d.evaluateClientConditions('TCL', null, true, true);
          windowObj.pega.ctx.gSectionReloaded = gSectionReloaded;
          windowObj.pega.ctxmgr.resetContext();  
        }
       windowObj.pega.ctxmgr.setContext(currentCtx);
    }
}


/* 
 * @private
 * This api is used to get the requestor change set in the current ct json object, for given thread and trackerid.
 * @threadName - threadname for which RequestorChangeSet should be returned.
 * @trackerId - trackerId of a thread for which RequestorChangeSet should be returned.
 */
pega.ui.ChangeTracker.prototype.getRequestorChangeSet = function(threadName, trackerId) {

    if(!this.currentCTJSONObj.RequestorChangeSet) return;

    var changedValues = this.currentCTJSONObj.RequestorChangeSet.Values || [];

    for (var i = 0; i < changedValues.length; i++) {
        var changeValueObj = changedValues[i];

        var threadObj = changeValueObj[threadName];

        if(!threadObj) continue;

        return threadObj[trackerId];
    }
}

/* This api is used check if the current change list contains the properties involved in the passed expression
 *  @configuredListName the expression in which the check is to be performed
 *  @addDelete is true incase of a addDelete expression
 *  @gridAddDelete is true if the operation that caused the evaluation is a Grid Add/Delete on client
 */
pega.ui.ChangeTracker.prototype.isExpressionMatchingWithTrackedProps = function(configuredListName, addDelete, gridAddDelete) {
	var matched = false;
	var sourceChangeList;
	if(addDelete) {
		sourceChangeList = this.addRemovePagesList;
	} else if(gridAddDelete) {
		sourceChangeList = this.changedPropertiesList;
	} else {
		var propHandle = pega.u.property.toHandle(configuredListName);
		if(pega.u.d.ct_postedProp != propHandle){
			if(this.tempPropMap && this.tempPropMap[configuredListName]) {
				if(this.tempPropMap[configuredListName] === 'dom')
					return false;
			}
			else {
				var domElem = pega.u.d.getCorrectPropertyElemFromDOM(propHandle,this);
				if(domElem && domElem.length > 0 && domElem[0].id != 'CV') {
					this.tempPropMap[configuredListName] === 'dom'
				/* return false if element present on dom, if the element is editable on client then the tracker changes are ignored */
					return false;
				}
			}
		}
		sourceChangeList = this.changedPropertiesList;

	}
	configuredListName = configuredListName.replace(/\(\)/ig, "");
	var confArray = configuredListName.split('.');
	if(sourceChangeList && sourceChangeList.length >= 1) {
		for(var propIdx = 0; propIdx < sourceChangeList.length; propIdx++) {
			if(sourceChangeList[propIdx] == configuredListName) {
				matched = true;
				break;
			} else {
				var sourceArray = sourceChangeList[propIdx].split('.');
				if(sourceArray.length == confArray.length) {
					var matching = true;
					for(var i = 0; i < sourceArray.length; i++) {
						if(sourceArray[i] != confArray[i]) {
							if(confArray[i].lastIndexOf(')') != confArray[i].length - 1) {
								if(sourceArray[i].replace(/\([\w]*\)/ig, "") != confArray[i]) {
									matching = false;
									break
								}
							} else {
								matching = false;
								break
							}
						}
					}
					if(matching) {
						matched = true;
						break;
					}
				}
			}
		}
	}
	return matched;
}
/* This api is used to merge the tracker changes that are return in an ajax to the master list
*  @ctJSON - changelist JSON that is returned in ajax response
*/
pega.ui.ChangeTracker.prototype.mergeChangesToMasterList = function(ctJSON) {
    if (ctJSON) {
        ctJSON = pega.tools.Security.decodeCrossScriptingFilter(ctJSON, true);
        var ctJSONObj = JSON.parse(ctJSON);
        this.currentCTJSONObj = ctJSONObj;
        if (ctJSONObj.Initial) {
            this.merge(this.trackedPropertiesList, ctJSONObj.Initial, null, false, false);
        }
 
        // Removing forceReload tempaltes before merge if it has pyForceReloadTemplates property 
        if (ctJSONObj.Initial.D_UITemplateMeta && ctJSONObj.Initial.D_UITemplateMeta.pyForceReloadTemplates) {
            // Remove forceReload templates 
            pega.ui.TemplateEngine.removeForceReloadTemplates(ctJSONObj.Initial.D_UITemplateMeta.pyForceReloadTemplates);
            delete ctJSONObj.Initial.D_UITemplateMeta.pyForceReloadTemplates;
        }
 
        if (ctJSONObj.AddRemove && ctJSONObj.AddRemove.length > 0)
            this.addRemovePagesList = this.addRemovePagesList.concat(ctJSONObj.AddRemove);
 
        if (ctJSONObj.Values.pxThread) {
            if (pega.u.d.bIsDCSPA) {
                if ("pxClientFrame" in ctJSONObj.Values.pxThread || this.threadName === pega.u.d.getThreadName()) {
                    this.trackedPropertiesList.pxThread.pxClientFrame = ctJSONObj.Values.pxThread.pxClientFrame;
                    delete ctJSONObj.Values.pxThread.pxClientFrame;
                    pega.ctx.baseFrameName = this.trackedPropertiesList.pxThread.pxClientFrame;
                }
            } else {
                if (ctJSONObj.Values.pxThread.pxClientFrame) {
                    this.trackedPropertiesList.pxThread.pxClientFrame = ctJSONObj.Values.pxThread.pxClientFrame;
                    delete ctJSONObj.Values.pxThread.pxClientFrame;
                }
            }
 
            if (ctJSONObj.Values.pxThread.pxClientExchange) {
              if ((typeof ctJSONObj.Values.pxThread.pxClientFrame === 'undefined' || ctJSONObj.Values.pxThread.pxClientFrame != '') &&
                  (this.trackedPropertiesList.pxThread.pxClientFrame == pega.ctx.baseFrameName  || (pega.ctx.isMDC && this.trackedPropertiesList.pxThread.pxClientFrame == pega.ctx.baseFrameName))){
                this.trackedPropertiesList.pxThread.pxClientExchange = ctJSONObj.Values.pxThread.pxClientExchange;
              }

              delete ctJSONObj.Values.pxThread.pxClientExchange;
            }
        }
        this.merge(this.trackedPropertiesList, ctJSONObj.Values, null, true, false);
    }
}
/* Utility api that is used by mergeChangesToMasterList to merge
*  @masterJSONList - the master collection of tracked properties
*  @changedJSONList - list of currently changed properties with values
*  @path - temp variable used in recursion for storing the current path
*  @noteChanges - if true changes are noted in changedPropertiesList else changes are ignored
*  @globalPath - for cross thread communication - using while merging other thread changes to current thread.
*				 true  : this means merge will treat the path as global i.e. non Thread
*				 false : this means merge will treat the path as local i.e. Thread scoped
*/
pega.ui.ChangeTracker.prototype.merge = function(masterJSONList, changedJSONList, path, noteChanges, globalPath) {
                    var topLevel = false;
  					var n = 1;
                    for(var key in changedJSONList) {
                                    var currKey = key;
                                    var changedJSONListObj = changedJSONList[key];
                                    if (noteChanges && globalPath) {
                                                    /*
                                                    * the path passed is global. Need to decide whether this global path.key is being tracked by this tracker or not;
                                                    * if this tracker is not tracking the global path.key, no need to continue with merging the changes.
                                                    */
                                                    if(!this.isThisGlobalPathTrackedByMe(path ? (path + "." + key) : key)) {
                                                                    continue;
                                                    }
                                    }
                                    if(Object.prototype.toString.call(changedJSONListObj) === "[object Object]" && changedJSONListObj != null) {
                                                    /*
                                                    * The path explored till now is local;
                                                    * Figure out if the value for the key in changedJSONList i.e. changedJSONListObj is global or not;
                                                    * Requestor and Node scoped pages are treated as global;
                                                    * This scenario happens only when the merge API is invoked first time from outside i.e. not in recursion from within this API.
                                                    */
                                                    if (!globalPath && (changedJSONListObj.pzPageScope == "Requestor" || changedJSONListObj.pzPageScope == "Node")) {
                                                                    topLevel = true; /* topLevel means the path refers a Top Level Page in global scope*/
                                                                    globalPath = true;
                                                    }
                                                    if (this.mergeOnlyNonThread && !globalPath) {
                                                                    /*
                                                                    * mergeOnlyNonThread means mergeOnlyGlobal; since this property is not in global path, we avoid merging the key and hence continue;
                                                                    */
                                                                    continue;
                                                    }
                                                                                                var pattern = /\(([^)]+)\)/;
                                                    var result = key.match(pattern);
                                                    if(result){
                                                        result = result[0];
                                                        var index = result.substring(result.indexOf("(")+1,result.length-1);
                                                        var keyNew = key.substring(0, key.indexOf("("));
                                                        if(!isNaN(index)){
                                                                index -= 1;
                                                                 masterJSONList[keyNew] = masterJSONList[keyNew] || [];
                                                                 if(!masterJSONList[keyNew][index]) {
                                                                                masterJSONList[keyNew][index] = {};

                                                                 }
                                                           key = keyNew;
                                                                 //masterJSON = masterJSONList[keyNew][index];
                                                        }else{
                                                                masterJSONList[keyNew] = masterJSONList[keyNew] || {};
                                                                if(!masterJSONList[keyNew][index]) {
                                                                    masterJSONList[keyNew][index] = {};
                                                                  	masterJSONList[keyNew][index]["pxSubscript"] = index;
                                                                }
                                                          key = keyNew;
                                                        }
                                                                                                                                                                                                                this.merge(masterJSONList[key][index], changedJSONListObj, ( path ? (path + "." + currKey) : currKey), noteChanges, globalPath);
                                             if(Object.keys(masterJSONList[key][index]).length === 0){
                                               if(index == masterJSONList[key].length-1){
                                                    masterJSONList[key].splice(-n);
                                               }else{
                                                    n = n+1;
                                               }
                                             }
                                                    }else{
                                                                if(!masterJSONList[key]) {
                                                                                                                                                                                                                                                masterJSONList[key] = {};
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                this.merge(masterJSONList[key], changedJSONListObj, ( path ? (path + "." + currKey) : currKey), noteChanges, globalPath);
                                                    }


                                    } else if(changedJSONListObj == null) {
                                                    delete masterJSONList[key];
                                    } else if( typeof changedJSONListObj != "undefined") {
                                                    /*BUG-256129 : HFIX:Interaction Header refreshes multiple times
                                                    * start
                                                    */
                                                    if(masterJSONList[key] != changedJSONListObj){
                                                      /*end*/
                                                      masterJSONList[key] = changedJSONListObj;
                                                      /* BUG-276893: Removed the D_UITemplateMeta check as metadata tree is no longer being change tracked. */
                                                      if(noteChanges) {
                                                          this.changedPropertiesList.push(path + "." + key);
                                                      } else if (globalPath) {
                                                          this.nonThreadTrackedPropertiesList += "$" + path + "." + key;
                                                      }
                                                    }
                                    }
                                    if (topLevel) {
                                                    globalPath = false;
                                    }
                    }
    }

/* This api is used to check whether the non-thread path provided is being tracked by current tracker . */
pega.ui.ChangeTracker.prototype.isThisGlobalPathTrackedByMe = function(path) {
	if (this.nonThreadTrackedPropertiesList.indexOf("$" + path) != -1) {
			return true;
	}
	return false;
}

/* This api is used to clear the changes in the tracker*/
pega.ui.ChangeTracker.prototype.clearChanges = function() {
	this.changedPropertiesList = new Array();
	this.addRemovePagesList = new Array();
}
/* This api is used to get the Value of any property from tracker
*  @propertyReference - fully qualified property reference
*/
pega.ui.ChangeTracker.prototype.getPropertyValue = function(propertyReference, skipResolveReference) {
	var propValue = null;
	var _skipResolveReference = false;
	if(typeof(skipResolveReference) != "undefined" && skipResolveReference != null) {
		_skipResolveReference = skipResolveReference;
	}
  	/*US-103800 : In case of autopopulated properties,changing the value of propertyReference to the value returned by ClientCache.find(propertyReference)*/
  	if(!_skipResolveReference && (pega && pega.u && pega.u.d && pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal())) {
    	propertyReference = pega.ui.AutopopulateSupport.resolveReference(propertyReference, this);
    }
	var propSplit = propertyReference.split(".");
	if(propSplit && propSplit.length >= 1) {
		propValue = this.trackedPropertiesList;
		for(var propSplitIdx = 0; propSplitIdx < propSplit.length; propSplitIdx++) {
			var currentProp = propSplit[propSplitIdx];
          	if(propValue && typeof propValue[currentProp] != 'undefined' && propValue[currentProp] != null) {
				propValue = propValue[currentProp];
			} else {
               	var propDetails = this.returnListOrGroupProp(currentProp, true);
                if(propValue && propDetails != currentProp){
                    var index = propDetails.index;
                    var keyNew = propDetails.key;
                    if(index == 0){
                      if(propValue[keyNew] && propValue[keyNew].length == 0){
                        propValue = propValue[keyNew];
                      }else{
                        propValue = null;
                      }
                    }else if(!isNaN(index)){
                      index -= 1;
                      propValue = propValue[keyNew] ? propValue[keyNew][index] : propValue[keyNew];
                    }else{
                      propValue = propValue[keyNew] ? propValue[keyNew][index] : propValue[keyNew];
                    }
                } else {
                    propValue = null;
                    break;
                }
            }
		}
	}

	return propValue;
}
pega.ui.ChangeTracker.prototype.replaceCTTokensWithValue = function(strvalue) {
	var retValue = "";
   if(strvalue){
      var ct = this;
      retValue = strvalue.replace(/(#|\^)~([a-z.0-9_()$]+)~(#|\^)/gi, function(){
        var propValue = null;
        if(pega.ui.ClientCache){
          var ccprop = pega.ui.ClientCache.find(arguments[2]);
           if(ccprop && ccprop.getValue){
             propValue = ccprop.getValue();
           }

        } else {
          	propValue = ct.getPropertyValue(arguments[2]);
        }
        if(typeof propValue != "undefined" && propValue != null)
          return propValue;
        else
          return "";

      });
   	}

	return retValue;
}

/* This api is used to check if the current tracker is a dummy tracker */
pega.ui.ChangeTracker.prototype.isDummy = function() {
	return (this === pega.ui.ChangeTrackerMap.getDummyTracker());
}

pega.ui.ChangeTracker.prototype.returnListOrGroupProp = function(propName, oneIndexed){
   var pattern = /\(([^)]+)\)/;
      var result =  propName.match(pattern);
      if(result){
        result = result[0];
        var index = result.substring(result.indexOf("(")+1,result.length-1);
        if(index){
          var keyNew = propName.substring(0, propName.indexOf("("));
          if(!isNaN(index)){
            if(!oneIndexed){
            	index -= 1;
            }
            return {"key":keyNew,"index":index,"type":"list"};
          }else{
            return {"key":keyNew,"index":index,"type":"group"};
          }
        }
    }
  	return propName;
};
//static-content-hash-trigger-GCC
/* ClientDataProvider.js */

;(function() {
	var clientDataProvider = function () {

		// Constants
		var BASE_THREAD = "STANDARD";
        //JSUnit Testing environment
        var isUnitTesting = pega.isUnitTesting;
		
		var _currentTrackerObject;
		// Map of ClientDataProviderTrackers || ClientCacheTrackers per thread
		var _ClientCacheTrackers = {};
		
		// Initialize ClientCacheTracker
		var _init = function(thread) {
			if(!thread)
				return;
			if(!_ClientCacheTrackers[thread])
				_ClientCacheTrackers[thread] = {};
			if(!_ClientCacheTrackers[thread].getPropertyValue)
				_ClientCacheTrackers[thread].getPropertyValue = _getPropertyValue;	
			if(!_ClientCacheTrackers[thread].returnListOrGroupProp)
				_ClientCacheTrackers[thread].returnListOrGroupProp = _returnListOrGroupProp;		
			if(!_ClientCacheTrackers[thread].isDummy)
				_ClientCacheTrackers[thread].isDummy = _isDummy;
			if(!_ClientCacheTrackers[thread].trackedPropertiesList)
				_ClientCacheTrackers[thread].trackedPropertiesList = {};
			_ClientCacheTrackers[thread].threadName = thread;
		};		
		
		// Metadata caches
		// var _MetadataStores = {};

		// Initialize ClientCacheTracker
		var _initMetadataStore = function(type) {
      if(!pega.ctx._MetadataStores) {
        pega.ctx._MetadataStores = {};
      }
			if(!type)
				return;
			if(!pega.ctx._MetadataStores[type])
				pega.ctx._MetadataStores[type] = {};
			return pega.ctx._MetadataStores[type];
		};
    
    //BUG-377045 Added _cleanMetadataStore definition
		var _cleanMetadataStore =  function(type) {
			if(!type)
				return;
			if(_MetadataStores[type])
				_MetadataStores[type] = null;			
		};
    
		/* Method to switch the thread context */
		// TODO: Handle pega.u.d.url cases - create a getter
		var _switchContext = function(thread) {

			_init(thread);
			// Set the marker on this thread
			_currentTrackerObject = _ClientCacheTrackers[thread];	
          	// Init ContextObject
			pega.ui.TemplateEngine.ContextObject.initTracker();
          	pega.clientTools.init && pega.clientTools.init(thread);/* BUG-331393: Even after invoking switchThread or switchContext client cache is not pointing to the switched thread. */
        };
		
		// Initialize with base thread
		//_switchContext(BASE_THREAD);
		
		// Current tracker
		var _getTracker = function() {
			return _currentTrackerObject;
		};
		
		// Multiple trackers
		var _getTrackers = function() {
			return _ClientCacheTrackers;
		};
		
		// Tracker by thread
		var _getTrackerByThread = function(thread) {
			_init(thread);
			return _ClientCacheTrackers[thread];
		};
		
		var _getMetadataStoreByType = function(type) {
			return _initMetadataStore(type);
		};
		
		var _initChangeTracker = function(threadName) {
            if(!threadName){
              threadName = pega.u.d.getThreadName();
            }
			_switchContext(threadName);
			//pega.ui.TemplateEngine.ContextObject.initTracker();
		};		
		/* istanbul ignore next */
		var _isDummy = function() {
			return;
		};
		
		var _getBaseThread = function() {
			return BASE_THREAD;
		};
		
		// TODO:
		// Remove get APIs when internal ClientCache usage is replaced
		var _getPropertyValue = function(propertyReference, skipResolveReference) {
			
			var propValue = null;
			var _skipResolveReference = false;
			if(typeof(skipResolveReference) != "undefined" && skipResolveReference != null) {
				_skipResolveReference = skipResolveReference;
			}

			var propSplit = propertyReference.split(".");
			if(propSplit && propSplit.length >= 1) {
				//propValue = this.trackedPropertiesList;
				propValue = this.trackedPropertiesList;
				
				for(var propSplitIdx = 0; propSplitIdx < propSplit.length; propSplitIdx++) {
					var currentProp = propSplit[propSplitIdx];
					if(propValue && typeof propValue[currentProp] != 'undefined' && propValue[currentProp] != null) {
						propValue = propValue[currentProp];
					} else {
						var propDetails = _returnListOrGroupProp(currentProp, true);
						if(propValue && propDetails != currentProp){
							var index = propDetails.index;
							var keyNew = propDetails.key; 
							if(index == 0){
							  if(propValue[keyNew] && propValue[keyNew].length == 0){
								propValue = propValue[keyNew];
							  }else{
								propValue = null;
							  }
							}else if(!isNaN(index)){
							  index -= 1;
							  propValue = propValue[keyNew] ? propValue[keyNew][index] : propValue[keyNew];
							}else{
							  propValue = propValue[keyNew] ? propValue[keyNew][index] : propValue[keyNew];
							}
						} else {
							propValue = null;
							break;
						}              
					}
				}
			}
			return propValue;
		};
		
		var _returnListOrGroupProp = function(propName, oneIndexed){
		   var pattern = /\(([^)]+)\)/;
			  var result =  propName.match(pattern);
			  if(result){
				result = result[0];
				var index = result.substring(result.indexOf("(")+1,result.length-1);
				if(index){
				  var keyNew = propName.substring(0, propName.indexOf("("));
				  if(!isNaN(index)){
					if(!oneIndexed){
						index -= 1;
					}
					return {"key":keyNew,"index":index,"type":"list"};
				  }else{
					return {"key":keyNew,"index":index,"type":"group"};
				  }
				}
			}
			return propName;
		};
		
		/* Expose public APIs */	
		var returnObject = {
			getTracker: _getTracker,
			getTrackers: _getTrackers,
			getTrackerByThread: _getTrackerByThread,
			switchThread: _switchContext,
			getMetadataStoreByType: _getMetadataStoreByType,
			initChangeTracker: _initChangeTracker,
      cleanMetadataStore: _cleanMetadataStore,
			getBaseThread: _getBaseThread
			/*
			isDummy: _isDummy,
			getPropertyValue: _getPropertyValue
			*/
		};
        if(isUnitTesting){ // Exposed the private functions in case of JSUnit running environment.
          returnObject["returnListOrGroupProp"]=_returnListOrGroupProp;
          returnObject["getPropertyValue"]=_getPropertyValue;
          returnObject["init"]=_init;
        }
		return returnObject;
	};
	
	// The public interface
	pega.ui.ClientDataProvider =  new clientDataProvider();
})();
//static-content-hash-trigger-GCC
if (!pega.capabilityList) {
    pega.cl = pega.namespace("pega.capabilityList");
}

(function () {
  // BUG-544577 : Added maxTouchPoints check for chrome
	var isTouch = !!(('ontouchstart' in window) || navigator.maxTouchPoints || window.DocumentTouch && document instanceof DocumentTouch);
	pega.cl.isTouchAble = function(){
		return isTouch;
	};	
})();

/*Polyfill for remove method.*/
(function (arr) {
    arr.forEach(function (item) {
        item.remove = item.remove || function () {
            this.parentNode.removeChild(this);
        };
    });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);



if (typeof Object.assign != 'function') {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, "assign", {
    value: function assign(target, varArgs) { // .length of function is 2
      if (target == null) { // TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
      }
      var to = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];
        if (nextSource != null) { // Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
if (!String.prototype.endsWith) {
	String.prototype.endsWith = function(search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}
		return this.substring(this_len - search.length, this_len) === search;
	};
}
//static-content-hash-trigger-GCC
pega.namespace("pega.tools");

		
pega.tools.Security = {
  
   decodeCrossScriptingFilter : function(jsonString, escapeFlag) { 
  
   /* XSS decoder */
    
        var crossScriptCodes = {
            "&#61;": "=",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": "\"",
            "&#39;": "'",
            "&#37;": "%",
            "&#59;": ";",
            "&#40;": "(",
            "&#41;": ")",
            "&#43;": "+",
            "&amp;": "&"
        }
        if (typeof escapeFlag != 'undefined' && escapeFlag != null) crossScriptCodes["&quot;"] = "\\\"";
        for (var prop in crossScriptCodes) {
            var re = new RegExp(prop, "ig");
            jsonString = jsonString.replace(re, crossScriptCodes[prop]);
        }
        return jsonString;
    }
}
//static-content-hash-trigger-GCC
/* 
 * pzpega_ui_doc_definition.js 
 * Initializaton of pega.ui.Doc object
 */
var count = 0;

pega.ui.Doc = function() {

};

/*
@protected - Explorer Form Get Form Data
@param $Object$  dataObject
@return $Object$
 */

function InstanceInfo(insKey, workId, label) {
	this.pzInsKey = insKey;
	this.workId = workId;
	this.label = label;
}

pega.ui.Doc.prototype = {
	myDesktop: null,
	modalCallback: [],
	bModalRendered: false,
	bModalDialogOpen: false,
	usesModalTemplate: false,
	editorIndex: 0,
	bFocused: false,
	isOrientationRTL: false,
	throbberLoadingCompletedText: "",
	throbberAnnouncementDelay: 0,
	harnessElements: [],
	gSectionReloaded: false,
	portal: null,
	MODALDIALOG_ADJUSTMENT: 50,
	MODALDIALOG_MIN_WIDTH: 320,
	MODALDIALOG_MIN_HEIGHT: 0,
	MODALDIALOG_MAX_WIDTH: 0,
	MODALDIALOG_BUTTONS_HEIGHT: 0,
	fieldValuesList: new Hashtable(),
	submitModalDlgParam: null,
	forceAJAX: false,
	bResizeModalDlg: true,
	/* set to the dom element which is being refreshed by the previous AJAX*/
	autoCompList: new Hashtable(),
	/*Used while removing the listeners attached to the autoComplete*/
	harnessLabel: null,
	formEncodingType: null,
	bIsModelessDialog: false,
	/* Flag to use native dirty confirmation dialog. True: Use native. False: Use PRPC modal. */
	bUseNativeDirtyConfirm: false,
	/* whether to retain the lock on WO when closing the tab */
	overLaySubmit: false,
	gSubmitIdx: -1,
	onSubmits: [],
	contextObjects: [],
	reloadAllSectionsByName: true,
	/*flag to revert back to previous refresh other section behavior*/
	redirectingToLoginScreen: false,
	/* Flag to skip onbeforeharness load execution */

	/* Start for Benchmark Timer */
	bRecordEvent: false,
	/*
	userStartTime : 0,
	submitTime : 0,
	serverTime : 0,
	clientStartTime : 0,
	topLevelPageErrors : false,
	 */

	timerTimeoutId: null,
	/* End for Benchmark Timer */
	bCallModalClose: false,
	modalBtnElem: null,
	isInitialHarnessContentHeight: true,
	initialHarnessContentHeight: null,
	/*
	@Public - Calls all functions when document get loaded (harness)
	@param $Object$  event
	@return $void$
	 */
	initialize: function(event) {
		if (pega.offline) {
			/* US-324619: In PMC Offline MultiWebView app with ajax container, HCLoadmanager won't be loaded in the child webview so adding safe check.
			   Note: If required other API's might need to be called by creating a lighter version of HCLoadManager.
			*/
			if (this.HCLoadManager) {
				console.info("Initializing HCLoadManager");
				this.HCLoadManager.init(event);
			} else if (typeof pmcRuntimeFeatures !== "undefined" && pmcRuntimeFeatures.pxUsesMultiWebView === "true") {
				console.info("Initializing WebViewManager");
				this.WebViewManager.init(event);
			}
		} else {
			if (pega.ui.JitJLoader) {
				// If the JitJLoader has been initialized, load the pxOnLoad component before calling initializeInner
				// pxOnLoad component pulls in minimal needed subset before onloads are processed
				pega.ui.JitJLoader.loadComponent("Action", "pxOnLoad", null, "runtime", function(error, category, componentName, feature) {
					if (error != null) {
						console.error(error);
					} else {
						this.initializeInner(event);
					}
				}.bind(this))
			} else {
				this.initializeInner(event);
			}
		}
	}
};

pega.u = pega.namespace("pega.ui");

pega.u.d = new pega.ui.Doc();
pega.util.Event.addListener(window, "load", pega.u.d.initialize, pega.u.d, true);

// BUG - 121662 - FIX for jQuery ui memory leak in DatePicker
pega.util.Event.addListener(window, "unload", function() {
	window && window.$ && $.datepicker && $.datepicker.dpDiv && $.datepicker.dpDiv.undelegate();
}, pega.u.d, true);
//static-content-hash-trigger-GCC
(function () {
    var getPegaCtxNSObject = function (propsKey) {
        if (propsKey === void 0) { propsKey = ""; }
        var nsObject = pega.ctx;
        var propsNSList = propsKey.split(".");
        var propsNSLen = propsNSList.length;
        var pegactxPropName = propsNSList[propsNSLen - 1];
        //only return till last namespace
        for (var idx = 0; idx < (propsNSLen - 1); idx++) {
            var propToken = propsNSList[idx];
            nsObject[propToken] = nsObject[propToken] || {};
            nsObject = nsObject[propToken];
        }
        return {
            ns: nsObject,
            propName: pegactxPropName
        };
    };
    var buildPegaCtxSetterGetter = function (setgetObjList) {
        if (setgetObjList === void 0) { setgetObjList = []; }
        setgetObjList.forEach(function (configObj) {
            var ns = configObj.ns;
            var propsObj = configObj.propsObj;
            if (ns && propsObj) {
                var _loop_1 = function(propOldKey) {
                    var propNewKey = propsObj[propOldKey];
                    try {
                        Object.defineProperty(ns, propOldKey, {
                            configurable: true,
                            get: function () {
                                var pegaCtxNSObj = getPegaCtxNSObject(propNewKey);
                                //console && console.warn(pegaCtxNSObj.propName + " - should be moved to harness context API. Refer to mesh DOC-131386.");
                                return pegaCtxNSObj.ns[pegaCtxNSObj.propName];
                            },
                            set: function (propVal) {
                                var pegaCtxNSObj = getPegaCtxNSObject(propNewKey);
                                pegaCtxNSObj.ns[pegaCtxNSObj.propName] = propVal;
                            }
                        });
                    }
                    catch (err) {
                    }
                };
                for (var propOldKey in propsObj) {
                    _loop_1(propOldKey);
                } //for
            } //if
        }); //forEach
    };
    // during page load
    var initialDeferredVars = [
        {
            ns: window,
            propsObj: {
                "pxReqURI": "pxReqURI",
                "bIsTemplateEnabled": "bIsTemplateEnabled",
                "bClientValidation": "bClientValidation",
                "bExpressionCalculation": "bExpressionCalculation",
                "AppDynamicsAppKey": "AppDynamicsAppKey",
                "gStrWindowName": "gStrWindowName",
                "gStrWinNameDefault": "gStrWinNameDefault",
                "strHarnessMode": "strHarnessMode",
                "inDeveloperDesktop": "inDeveloperDesktop",
                "pyPerformThreadWindowCheck": "pyPerformThreadWindowCheck",
                "topHarness": "topHarness",
                "isDesignViewIframe": "isDesignViewIframe",
                "bFlowAction": "bFlowAction",
                "strPyID": "strPyID",
                "strPyLabel": "strPyLabel",
                "desktopAvailableSpacesList": "desktopAvailableSpacesList",
                "isUITemplatized": "isUITemplatized",
                "bReadOnly": "bReadOnly",
                "strHarnessPurpose": "strHarnessPurpose",
                "strHarnessClass": "strHarnessClass"
            }
        },
        {
            ns: pega.d,
            propsObj: {
                "pxReqURI": "pxReqURI"
            }
        }
    ];
    if (pega.u && pega.u.d) {
        initialDeferredVars.push({
            ns: pega.u.d,
            propsObj: {
                "baseThreadName": "baseThreadName",
                "gDirtyOverride": "gDirtyOverride",
                "topHarness": "topHarness",
                "url": "url",
                "activeGrid": "activeGrid",
                "gSectionReloaded": "gSectionReloaded",
                "KeepPageMessages": "KeepPageMessages",
                "ignoreDirtyState": "ignoreDirtyState",
                "baseFrameName": "baseFrameName"
            }
        });
    }
    buildPegaCtxSetterGetter(initialDeferredVars);
    /**
     * On window load,
     * Add setter getter for harness properties in custom scripts
     */
    window.addEventListener('load', function () {
        // post page laod
        var bottomVars = [
            {
                ns: window,
                propsObj: {
                    "strDisplayHarnessParms": "strDisplayHarnessParms",
                    "bClientValidation": "bClientValidation",
                    "bActionIframe": "bActionIframe",
                    "bEncryptURLs": "bEncryptURLs",
                    "strKey": "strKey",
                    "strPageName": "strPageName"
                }
            }
        ];
        buildPegaCtxSetterGetter(bottomVars);
    }); //window onload
})();
//static-content-hash-trigger-GCC
//<!-- HTML -->
//<script>

/* @package pega.ui.Doc constructor added a note
Harness client runtime infrastructure included in the harness and action Iframe that provides
facilities to:
@asismarkSectionTabErrors
- Submit forms
- Reload Sections
- Interface with Portal
- Expand/collapse headers and tabs
- insert/delete rows in repeating layout
- supports the  cross browser functionalhity
@endasis
 */

/*
@protected - Explorer Form Get Form Data
@param $Object$  dataObject
@return $Object$
 */

var docMethods = {
	/*
	@protected - Explorer Form Get Form Data
	@param $Object$  dataObject
	@return $Object$
	 */
	explorerFormGetFormData : function (dataObject) {
		dataObject.pzInsKey = pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty('strKey');
		dataObject.descr = strPyLabel; //DEPRECATED in favor of "label"
		dataObject.label = strPyLabel;
		dataObject.workId = strPyID;
		return dataObject;
	},

	/* @public
	This function returns false when form is dirty
	@return $boolean$
	 */

	explorerFormIsBusy : function () {
		return false;
	},

	/* @public
	This function resizes the action IFrame to show content and scroll bars.  Invoke this 	function whenever the HTML size changes and is
	automatically invoked:
	@asis
	- Onload of new flow action.
	- Show/hide element based on client side event
	- HTML propery that changes document size such as text area expand/contract
	@endasis
	@return $void$
	 */
	resizeActionIFrame : function (bResize) {
      	var harCtxMgr = pega.ui.HarnessContextMgr;
		var hcDiv = document.getElementById("HARNESS_CONTENT");
		if (!hcDiv) {
			/* We need to resize the iframe using the iframe body and not the harness content div. Bug-65236 */
			hcDiv = document.getElementsByTagName("body")[0];
		}
		if (hcDiv) {
			/* Style auto was made for non-IE browsers to avoid scrollbars in  Performscreenflow
			and if we add for IE the modalwindow also gets blurred in perform harness */

			if (!pega.util.Event.isIE) {
				hcDiv.style.overflow = "auto";
			}
			var scrollHeight = hcDiv.scrollHeight;
			var clientHeight = hcDiv.clientHeight;
			var offsetHeight = hcDiv.offsetHeight;
			var newHeight = scrollHeight;
			if (pega.util.Event.isIE) {
				/*IE is not returning clientWidth properly. So checking for body*/
				if (document.body.scrollWidth > document.body.clientWidth) {
					newHeight = newHeight + pega.u.d.SCROLL_ADJUSTMENT;
				}
			} else if (hcDiv.scrollWidth > hcDiv.clientWidth) {
				newHeight = newHeight + pega.u.d.SCROLL_ADJUSTMENT;
			}

			/*BUG - 21610 : calculate the padding and margin of body and add it to newHeight*/
			var padDiff = 0;
			var padTop = parseInt(pega.util.Dom.getStyle(document.body, 'paddingTop'));
			if (padTop)
				padDiff += padTop;
			var padBot = parseInt(pega.util.Dom.getStyle(document.body, 'paddingBottom'));
			if (padBot)
				padDiff += padBot;
			newHeight += padDiff;

			var marginDiff = 0;
			var marginTop = parseInt(pega.util.Dom.getStyle(document.body, 'marginTop'));
			if (marginTop)
				marginDiff += marginTop;
			var marginBottom = parseInt(pega.util.Dom.getStyle(document.body, 'marginBottom'));
			if (marginBottom)
				marginDiff += marginBottom;
			newHeight += marginDiff;

			if (pega.u.d.bModalDialogOpen) {
				var modalDialogBodySH = 0;
				var initialHt = this.modalDialog.body.style.height;
				modalDialogBodySH = pega.u.d.getDivScrollHeight(this.modalDialog.body, false);
				if (initialHt != "") {
					this.modalDialog.body.style.height = initialHt;
				}
				if (newHeight < parseInt(modalDialogBodySH)) {
					newHeight += parseInt(modalDialogBodySH);
				}
				if (document.getElementById("modaldialog_mask")) {
					document.getElementById("modaldialog_mask").style.width = pega.desktop.support.getFrameElement().offsetWidth + 'px';
				}
			}

			/*resize iframe after error tables are shown*/
			//BUG-59756 KODUC 1/12/2012 Scroll bar is coming since ERRORTABLE height is not calculated
			var errorDivTable = document.getElementById('FormErrorMarker_Div');
			var errorTableHt = errorDivTable ? errorDivTable.offsetHeight : 0;
			errorDivTable = document.getElementById('ERRORTABLE');
			errorTableHt += errorDivTable ? errorDivTable.offsetHeight : 0;
			if (errorDivTable) {
				//newHeight = errorTableHt + newHeight + parseInt(ERRORTABLE.style.marginTop) + parseInt(ERRORTABLE.style.marginBottom);
				//Bug-116377 porting of Hfix-7813 handling NaN return of parseInt
				newHeight = errorTableHt + newHeight+((errorDivTable.style.marginTop =="")?0: parseInt(errorDivTable.style.marginTop))+((errorDivTable.style.marginBottom =="")?0:parseInt(errorDivTable.style.marginBottom));
			}
			//End of BUG-59576
			if ((clientHeight == scrollHeight)) {
				/*When there is no scroll bar clientHeight and scrollHeight are same. So, check for frame height also*/
				if (pega.desktop.support.getFrameElement().height == (newHeight)) {
					return;
				}
			}
			//BUG-74750 cherj	start
			var hcDivScrollHeight = hcDiv.scrollHeight;
			if (hcDivScrollHeight > newHeight) {
				newHeight = hcDivScrollHeight;
			}
			//BUG-74750 cherj	start
			if (pega.desktop.support.getFrameElement().style) {
				pega.desktop.support.getFrameElement().style.height = newHeight + "px";
			} else {
				pega.desktop.support.getFrameElement().height = newHeight;
			}
			if (pega.util.Event.isIE && pega.util.Event.isIE <= 9) {
				hcDiv.style.height = scrollHeight + 'px';
			}
			/* // BUG-78572 - Commented piece of code was causing horizontal resize issues
			var newWidth  = hcDiv.scrollWidth;
			var padDiff = 0;
			var padLeft = parseInt(pega.util.Dom.getStyle(document.body,'paddingLeft'));
			if(padLeft)
			padDiff+=padLeft;
			var padRight = parseInt(pega.util.Dom.getStyle(document.body,'paddingRight'));
			if(padRight)
			padDiff+=padRight;
			newWidth += padDiff;

			var marginDiff = 0;
			var marginLeft = parseInt(pega.util.Dom.getStyle(document.body,'marginLeft'));
			if(marginLeft)
			marginDiff+=marginLeft;
			var marginRight = parseInt(pega.util.Dom.getStyle(document.body,'marginRight'));
			if(marginRight)
			marginDiff+=marginRight;
			newWidth += marginDiff;
			if(window.frameElement.style) {
			window.frameElement.style.width=newWidth + "px";
			} else {
			window.frameElement.width = newWidth + "px";
			}
			 */

		} else {
			/*Old code for backward compatibility*/
			var newHeight = 0;
			var frameDocument = window.frames.document;
			var offsetHeight = frameDocument.body.offsetHeight;
			var clientHeight = frameDocument.body.clientHeight;
			var scrollHeight = frameDocument.body.scrollHeight;
			var adjustFactor = offsetHeight - clientHeight;
			if ((clientHeight == scrollHeight)) {
				return;
			}
			if (pega.util.Event.isIE) {
				newHeight = frameDocument.body.scrollHeight + adjustFactor + 8;
				/* To add extra space after the Submit button */
			} else {
				if (!pega.util.Event.isSafari) {
					window.frames.document.defaultView.sizeToContent();
				}
				newHeight = frameDocument.documentElement.scrollHeight;
				if (pega.u.d.bModalDialogOpen)
					newHeight += this.modalDialog.body.scrollHeight;
			}
			if (pega.util.Event.isIE && frameDocument.body.scrollWidth > frameDocument.body.offSetWidth) {
				newHeight = newHeight + pega.u.d.SCROLL_ADJUSTMENT;
			}
          
            // bug-269056, x-domain script errors
            var window_parent_doc = null;
            try {
                window_parent_doc = window.parent.document ;
            }
            catch (e) {}
            if (window_parent_doc != null) {
                if (newHeight > 0 && window_parent_doc.getElementById("iframeDiv") != null) {
                    window_parent_doc.getElementById("iframeDiv").style.height = newHeight + 'px';
                }
                var frames = window_parent_doc.getElementsByTagName("iframe");
                for (var i = 0; i < frames.length; i++) {
                    if (newHeight > 0 && frames[i].name == "actionIFrame") {
                        frames[i].height = newHeight;
                    }
                }
            }
		}
		if (arguments.length > 0) {
			if (bResize) {
				pega.u.d.resizeHarnessCallback();
			}
		} else {
			pega.u.d.resizeHarnessCallback();
		}

	},

	/*
	@Private - This wrapper function will open a form in a new window
	@param $String$ oUrl -  A string specifying the URL to open in the new window.
	@param $String$ sName - A string specifying the window name to use in the TARGET attribute of a FORM or A tag. windowName can contain only alphanumeric or underscore(_) characters.
	@param $String$ sOptions - A string containing a comma-separated list determining whether or not to create various standard window features.
	@param $boolean$ bReplace - A Boolean parameter that specifies whether the sURL creates a new entry or replaces the current entry in the window's history list.
	@return $object$
	 */

	openUrlInWindow : function (oUrl, sName, sOptions, bReplace, event, isAlternateUrlBase,isNoEncodingURL) {
		/* This is to avoid calling activity when URL is empty*/
		if (oUrl === "?") {
			oUrl = '';
		}

		event = event == undefined ? window.event : event;
		if (event != null) {
			//BUG-53318 : replaced stopEvent with preventDefault to fix this bug.
			pega.util.Event.preventDefault(event);
		}
		return desktopwrappersupport_openUrlInWindow(oUrl, sName, sOptions, bReplace, isAlternateUrlBase,isNoEncodingURL);
	},

	/*
	function to open the Custom Activity in a PopUp. Those calls the standard
	desktopwrapper openUrlInWindow method
	 */
	customActivityInPopup : function (url, windowHeight, windowWidth, event) {
		event = event == undefined ? window.event : event;
		pega.util.Event.stopEvent(event);

		var nWndHeight = (window.screen.height * (parseInt(windowHeight))) / 100;
		var nWndWidth = (window.screen.width * (parseInt(windowWidth))) / 100;
		var customWindowSize = "left=0,top=0,height=" + nWndHeight + ",width=" + nWndWidth;
		var PopupWindowFeatures = "status=yes,toolbar=no,menubar=no,location=no,scrollbars=yes,resizable=yes";
		var sOptions = customWindowSize + PopupWindowFeatures;
		openUrlInWindow(url, "pyWorkPagePopup", sOptions, '', event);
	},

	/*
	Function is used to replace the contents of current window.
	 */
	replace: function(strAction, event) {
        var oSafeURL = SafeURL_createFromURL(strAction);
        var options = {
            excludes: {
                'enumerateDevices': true,
                'sessionStorage': true,
                'colorDepth': true,
                'indexedDb': true,
                'canvas': true,
                'hasLiedLanguages': true,
                'touchSupport': true,
                'plugins': true,
                'hasLiedResolution': true,
                'adBlock': true,
                'hasLiedBrowser': true,
                'audio': true,
                'hasLiedOs': true,
                'fonts': true,
                'addBehavior': true,
                'openDatabase': true,
                'pixelRatio': true,
                'doNotTrack': true,
                'fontsFlash': true,
                'screenResolution': true,
                'availableScreenResolution': true,
                'webglVendorAndRenderer': true,
                'webgl': true
            }
        };
        var components = {};
        Fingerprint2.get(options, function(components) {
            var values = components.map(function(component) {
                return component.value;
            });
            fingerprintToken = Fingerprint2.x64hash128(values.join(''), 31);
            pega.d.browserFingerprint = '{v2}' + fingerprintToken;
        });
        oSafeURL.put("pzCTkn", pega.ctx.activeCSRFToken);
        oSafeURL.put("pzBFP", pega.d.browserFingerprint);
        strAction = oSafeURL.toURL();

        if (typeof(strAction) != "undefined" && strAction.indexOf("pyActivity=LogOff") == 0) {
            var parentWindow = pega.desktop.support.getDesktopWindow();
            if (parentWindow != null)
                parentWindow.logout = true;
        }
		event = event == undefined ? window.event : event;
		if (event)
			pega.util.Event.stopEvent(event);
		/*BUG-174089:setting target to popup only if it exists in current url and activity is AutoClose*/
		var oSafeURL = SafeURL_createFromURL(strAction),
			href = window.location.href,
			NameValuePairs = SafeURL_getNameValuePairsAsObject(href);
		if(NameValuePairs && NameValuePairs.target && NameValuePairs.target == "popup" && oSafeURL.get("pyActivity") == "AutoClose"){
			oSafeURL.put("target","popup");
		}

		// flag navigate in flight to test tools and performance measure
        if (pega && pega.ui && pega.ui.statetracking) pega.ui.statetracking.setNavigationBusy("abc?"+oSafeURL.toUnencodedQueryString());
    
		if ((document.forms && document.forms[0]) || pega.ctx.isMDC) {
      if (document.forms[0].name == "actionForm") {
        parent.location.href = oSafeURL.toURL();
      } else {
          var newformEle = document.createElement("form");
          newformEle.setAttribute("method", "post");
        if (pega.ctx.recordId && document.querySelector("[data-mdc-recordid='" + pega.ctx.recordId + "']")) {
          document.querySelector("[data-mdc-recordid='" + pega.ctx.recordId + "']").appendChild(newformEle);
        } else {
          document.body.appendChild(newformEle);
        }
        
          /* BUG-708531 changes start here*/
          var formactionURL = SafeURL_createFromURL(pega.ctx.url);
          formactionURL.put("pyActivity", "@baseclass.doUIAction");
          newformEle.setAttribute("action", formactionURL.toURL());
          //newformEle.setAttribute("action", pega.ctx.url + "&pyActivity=%40baseclass.doUIAction");
          /* BUG-708531 changes end here*/
        
          var paramArray = oSafeURL.keys();
          for (var i = 0; i < paramArray.length; i++) {
            var keyParam = paramArray[i];
            var value = oSafeURL.get(keyParam);
            if (typeof value === "undefined") {
              value = "";
            }
            // BUG-525291 : Fix for issue when we have nested JSON like : '{"pyModelReportDetails":"{\"ruleLabel\":\"Sales Model\"}"}'
            if (keyParam === "preActivityParams" || keyParam === "preActivityDynamicParams" || keyParam === "pyDataTransformDynamicParams") {
              var escapeRegex = new RegExp('\\\\"', 'g');
              var doubleEscapeStr = '\\\\\"';
              // BUG-525291 : Replace \" with \\" so that when we submit form correct values will be sent.
              value = value.replace(escapeRegex, doubleEscapeStr);
            }
            // If any exceptions occur while decoding, ignore and continue;
            try {
              value = decodeURIComponent(value);
            } catch (e) {}
            var input = document.createElement("input");
            input.setAttribute("name", keyParam);
            input.setAttribute("value", value);
            input.setAttribute("type", "hidden");
            newformEle.appendChild(input); 
          }
        if (strAction.includes('pyActivity=LogOff')) {
          newformEle.submit();
          return;
        }
        var newURL = SafeURL_createFromEncryptedURL(newformEle.getAttribute("action"));
        if (newURL) {
          /*delete newURL.hashtable["pzTransactionId"];*/
          /* BUG-218280: Skip hidden elements when Refresh is called without Submit */
          var queryString = pega.u.d.getHiddenEltsAsSafeURL(document, true);
          newURL.copy(queryString);
          newformEle.setAttribute("action", newURL.toURL());
        }
        pega.ctx.gDirtyOverride = false;
        if (pega.ctx.isMDC) {
          var postSubmitData = pega.u.d.getQueryString(newformEle);
          pega.ui.MDCUtil.microDCRenderer(newURL, postSubmitData, true);
        } else if (pega.ctx.bIsDCSPA) {
          newURL.put("isURLReady", "true");
          newURL.put("skipHistoryUpdation", "true");
          pega.u.d.UIActionRouter.singlePageRenderer(newURL);
        } else {
          newformEle.submit();
        }
      }
		} else {
			try {
        //BUG-674759 Safari specific issue: moved the href updation inside settimeout
        setTimeout(function(){
          self.location.href = oSafeURL.toURL();
        },200)
				
			} catch (e) {
				/* Fix for I.E as it was throwing Unspecified error
				on setting the location.href value and clicking 'cancel' on the
				confirm dialog that follows.*/
			}
		}

	},

	/*
	@public handleActionEvent call the apis that are required to perform when the FA drop down is selected  or back button is clicked on the perform harness
	@Handler
	@param $String$actionType contains the action that is to be perfomed
	@param $String$prevTaskIndex contains the prevTaskIndex
	@return $void$
	 */
	handleActionEvent : function (actionType, prevTaskIndex, event, key) {
		pega.util.Event.stopEvent(event);

		var harnessContext = pega.ui.HarnessContextMgr.getCurrentHarnessContext();
		var popOver  = pega.u.d.getPopOver();
		if(popOver){
		  popOver.close();
		}
		var actionURL = SafeURL_createFromURL(harnessContext.getProperty('url'));
        	var strHarnessMode = harnessContext.getProperty('strHarnessMode');
		//actionURL.put("HarnessMode",strHarnessMode); BUG-126174, Back button functionality not working for FlowAction as HarnessMode is empty it should be "ACTION"
		if(strHarnessMode == "" && document.getElementById("HarnessMode"))
			actionURL.put("HarnessMode",document.getElementById("HarnessMode").value);
		else
			actionURL.put("HarnessMode",strHarnessMode);
		actionURL.put("FieldError", pega.u.d.fieldErrorType);
		actionURL.put("FormError", pega.u.d.formErrorType);
		actionURL.put("pyCustomError", pega.u.d.pyCustomError);
		actionURL.put("bExcludeLegacyJS", pega.u.d.bExcludeLegacyJS);
		switch (actionType) {
		case "ActionChange":
			key = key?key:'';
			if (typeof pega.u.d.bWarnBeforeChangingWindow != undefined && pega.u.d.bWarnBeforeChangingWindow == true && !showDialogForWindowChange())
				return;
			var strTaskIndex = document.getElementById("ActionOptions").value;
			if (!(strTaskIndex == null || strTaskIndex == "")) {
				actionURL.put("NewTaskStatus", document.getElementById(key+''+strTaskIndex).value);
				actionURL.put("PrevTaskIndex", prevTaskIndex);
				actionURL.put("TaskIndex", strTaskIndex);
				pega.u.d.processActionDefault(actionURL, event);
			} else {
				var actionContainerDiv = document.getElementById("actionContainer");
				if (actionContainerDiv) {
					actionContainerDiv.style.visibility = "hidden";
				}
			}
			break;
		case "GoBack":
			var newActionSection = pega.u.d.getSectionByName(actionSection, "", document);
			if (newActionSection) {
				actionURL.put("bReload", "false");
				actionURL.put("ActionMode", "");
				actionURL.put("TaskIndex", "1");
				pega.u.d.reloadSection(newActionSection, "GoBack", actionURL.toQueryString(), false, false, "");
				break;
			}
		case "ActionScreenFlow":
			actionURL.put("previousEntryPoint", true);
			if (pega.u.d.modalDialogLoaded()) {
				pega.u.d.launchFlow.handleModalActionEvent("GoToPreviousTask", actionURL.toQueryString());
			} else {
				pega.u.d.submitWhenFail("GoToPreviousTask", actionURL.toQueryString());
			}
			break;
		}
	},

	/*
	@protected Called when user clicks Update button.
	If action iframe is present, calls its switchToUpdate function, else calls standard Update function.
	@return $void$
	 */
	handleUpdate : function (event) {
		event = (event == undefined) ? window.event : event;
		pega.util.Event.stopPropagation(event);
		pega.util.Event.preventDefault(event);
		var actionFrame = window.frames.actionIFrame;
		if (actionFrame != null && actionFrame.switchToUpdate != null) {
			actionFrame.switchToUpdate();
		} else {
			this.submit('pyActivity=DoUpdate', pega.util.Event.getTarget(event), 'Submitting...', event);
		}
	},

	/*
	@protected InterceptPrint event from from spaceTitelBar
	@return $void$
	 */
	interceptPrint : function () {
		pega.u.d.doPrintDiv("HARNESS_CONTENT");
		return true;
	},

	/* @Handler @api
	Saves the read/write contents of the harness to the clipboard and saves the work object to the database.
	@param $boolean$bSaveAndContinue  If true the contents  are saved and the flow action is reloaded otherwise return a confirm harness.  Default is false.
	@return $void$
	 */
	doSave : function (bSaveAndContinue, event, closeAfterSave) {
		// var strAction="";
      	
		event = (event == undefined) ? window.event : event;
		pega.util.Event.stopEvent(event);
		var oSafeUrl = new SafeURL();
		if (bSaveAndContinue) {
			oSafeUrl.put("pyActivity", "SaveAndContinue");
			if (typeof(actionSection) != 'undefined') {
				oSafeUrl.put("ActionSection", actionSection);
			}
			if(closeAfterSave) {
				oSafeUrl.put("CloseAfterSave", "true");
			}
		} else if (closeAfterSave) {
			oSafeUrl.put("pyActivity", "SaveAndContinue");
			oSafeUrl.put("CloseAfterSave", "true");
		} else {
			oSafeUrl.put("pyActivity", "DoSave");
		}
      	var docElem = pega.u.d.getDocumentElement();
      	var formElem = pega.u.d.getFormElement();
        		
		// find the action section (are we in perform harness ?)
		var actionIframe = window.frames.actionIFrame;
		// if action found invoke processAction in action section
		if (actionIframe != 'undefined' && actionIframe != null) {
			actionIframe.doSave(true, event, closeAfterSave);
		} else {
			// if the button is in action section
			var isNewActionArea = document.getElementById('pyActionArea');
            if(!isNewActionArea) {
              // when not including pzActionAreaContent, the pyActionArea will not be defined */
              if(docElem.querySelector("#HarnessMode") && docElem.querySelector("#HarnessPurpose") && 
                 docElem.querySelector("#HarnessPurpose").value=="Perform") {
                isNewActionArea = true;
              }
            }
			if (formElem && formElem.name == "actionForm") {
				reSubmit(oSafeUrl.toQueryString());
			} else if (typeof(actionSection) != 'undefined' && isNewActionArea && !closeAfterSave) {
              	if(pega.offline && !pega.u.d.ServerProxy.isDestinationRemote()){
                  	doFormSubmit(oSafeUrl, event, strSaveText, event);
                }
              	else{
                	pega.u.d.submitWhenFail("SaveAndContinue", "",undefined,undefined,undefined,undefined,undefined,event);
             	}

			} else {
				doFormSubmit(oSafeUrl, event, strSaveText, event);
			}
		}
	},

	isActive : function () {
		if (typeof(printView) != 'undefined' && printView) {
			return false;
		}
		return true;
	},

	isReadOnly : function () {
      	var bReadOnly = pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty('bReadOnly');
      	
		if (typeof(bReadOnly) != 'undefined' && bReadOnly == -1) {
			return true;
		}
		return false;
	},

	/* @api
	Register the complex object as a harness element to get/set enable/disable highlight/unhighlight
	@param $Object$element - Element to be registered as the complex object
	@param $String$sectionID - Section ID
	@return $void$
	 */

	registerAsHarnessElement : function (element, sectionID) {
		var complexObject = new Object();
		complexObject.element = element;
		complexObject.sectionID = sectionID;
		complexObject.type = "complex";
		this.harnessElements.push(complexObject);
		if (typeof element.onLoad == "function") {
			pega.u.d.attachOnload(element.onLoad, true);
		}
		if (typeof element.onBeforeSubmit == "function") {
			pega.u.d.registerOnBeforeSubmit(element.onBeforeSubmit, element);
		}

	},

	/* @api
	Return the document height
	@param
	@return $String$
	 */

	getDocHeight : function () {
		var docBody = document.body;
		if (pega.util.Event.isIE) {
			var dh = docBody.offsetHeight;
		} else {
			var dh = docBody.clientHeight;
		}
		return dh;
	},

	/* @api
	Return the document width
	@param
	@return $String$
	 */

	getDocWidth : function () {
		var docBody = document.body;
		var dw = docBody.offsetWidth;
		return dw;
	},

	/* @api
	Return the strKey
	@param
	@return $String$
	 */

	getHandle : function () {
		return pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty('strKey');
	},

	/* @api
	Return the strPyID
	@param
	@return $String$
	 */

	getID : function () {
		return pega.ui.HarnessContextMgr.get('strPyID');
	},

	/* @api
	Return the documentKey
	@param
	@return $String$
	 */

	getDocumentKey : function () {
		if (this.hasOwnProperty('documentKey') === true)
			return this.documentKey;
		else
			return '';
	},

	/* TASK-157928 GUJAS1 04/29/2013 Added getDocumentTitle & getDocumentTooltip methods. */

	/* @api
	Return the document title to be used in tabs etc.
	@param
	@return $String$
	 */

	getDocumentTitle : function () {
		if (this.hasOwnProperty('documentTitle') === true)
			return this.documentTitle;
		else
			return '';
	},

	/* @api
	Return the document tooltip to be used in tabs etc.
	@param
	@return $String$
	 */

	getDocumentTooltip : function () {
		if (this.hasOwnProperty('documentTooltip') === true)
			return this.documentTooltip;
		else
			return '';
	},

	/* @api
	Return the Sysstem Node ID
	@param
	@return $String$
	 */

	getSystemNodeID : function () {
		return systemNodeID;
	},

	/* @api
	Return the label
	@param
	@return $String$
	 */
	getLabel : function () {
		return this.harnessLabel;
	},

	setLabel : function (label) {
		this.harnessLabel = label;
	},

	/* @Handler @api
	Closes the current work item. If dirty checking is enabled and the form is dirty a warning prompt is displayed.
	@param $object$ event
	@param $bool$ dcCleanup
	@param $object$ dcCleanupCallback
	@return $void$
	 */

	doClose : function (event, dcCleanup, dcCleanupCallback, ignoreDirty, fromReplaceDocument) {
		var isrequiredtoclose = pega.u.d.closeWork(event, dcCleanup, dcCleanupCallback, ignoreDirty, fromReplaceDocument);
		var isNativeSDK = (navigator.userAgent.toLowerCase().indexOf('pegamobilesdk') != -1);

		if (isrequiredtoclose && isNativeSDK) {
			// below call is required by HC and NativeSDK @deltatouch @yellk
			setTimeout(function(){window.close();}, 0);
		}

		return isrequiredtoclose;
	},

	/* @Handler
	Closes the current work item. If dirty checking is enabled and the form is dirty a warning prompt is displayed.
	@param $object$ event
	@return $void$
	 */

	notifyComplexObjStatus : function (bContainErrors) {
		if (bContainErrors == true) {
			this.hideErrorBox();
		}
	},

	/* @Handler @api
	Get the label of the harness class.
	@param
	@return $String$ -Label of the harness class
	 */

	getClassLabel : function () {
		return pega.u.d.workLabel;
	},

	/* @Handler @api
	Get the pyLabel .
	@param
	@return $String$ -short description
	 */

	getPyLabel : function () {
		return strPyLabel;
	},

	/* @Handler @api
	Get the HarnessClass (pxObjClass) .
	@param
	@return $String$ -short description
	 */

	getHarnessClass : function () {
		return strHarnessClass;
	},

	/* @Handler @api
	Get the Harness Name (pyPurpose) .
	@param
	@return $String$ -short description
	 */

	getHarnessPurpose : function () {
		return pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty("strHarnessPurpose");
	},

	/* @Handler @api
	Get the name of the System.
	@param
	@return $String$ -Name of the System
	 */

	getSystemName : function () {
		return systemName;
	},

	/* @Handler @api
	Get the name of the Application.
	@param
	@return $String$ -Name of the Application
	 */

	getApplicationName : function () {
		return applicationName;
	},

	/* @Handler @api
	Checks if the harness is used for portal layout.
	@param
	@return true-if harness is used for creating portals.

	 */
	isPortal : function () {
		return (pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty('topHarness') === 'yes');
	},
	/*@protected
	Display Help.
	@return $void$
	 */
	displayHelp : function (event) {
		event = (event == undefined) ? parent.window.event : event;
		pega.util.Event.stopPropagation(event);
		pega.util.Event.preventDefault(event);
		var strHelpType = "";
		if (pega.u.d.bModalDialogOpen) {
			if (document.getElementsByName("ModalTaskHelpType")[0]) {
				strHelpType = document.getElementsByName("ModalTaskHelpType")[0].value;
			}
		} else if (document.getElementsByName("TaskHelpType")[0]) {
			strHelpType = document.getElementsByName("TaskHelpType")[0].value;
		}
		if (trim(strHelpType) == "DEFINE") {
			pega.u.d.loadInstructionFromFlowAction();
		} else {
			pega.u.d.loadInstructions();
		}
	},

	/*@private
	Function which load instructions
	@return $void$
	 */
	loadInstructions : function () {
      	var harCtxMgr = pega.ui.HarnessContextMgr;
		/* call the appropriate stream*/
		var strActionInstructions = "";
		if (pega.u.d.bModalDialogOpen) {
			if (document.getElementsByName("ModalTaskInstr")[0]) {
				strActionInstructions = document.getElementsByName("ModalTaskInstr")[0].value;
			}
		} else if (document.getElementsByName("TaskInstructions")[0]) {
			strActionInstructions = document.getElementsByName("TaskInstructions")[0].value;
		}
		if (strActionInstructions != "") {
			var strUrlSF = new SafeURL(pega.desktop.pzLoadHelpInstruction);
			strUrlSF.put("StreamName", strActionInstructions);
			var strUrl = harCtxMgr.get('url') +"&"+ strUrlSF.toQueryString();
			window.open(strUrl, 'Instructions', 'width=500,height=500,resizable,scrollbars');
		}
	},

	/* @public @Handler
	loadInstructionFromFlowAction() called when we click the help icon in a  flow action
	@return $void$
	 */
	loadInstructionFromFlowAction : function () {
		/* call the appropriate activity*/
		var strActionName = "";

		if (pega.u.d.bModalDialogOpen && pega.u.d.submitModalDlgParam) {
			strActionName = pega.u.d.submitModalDlgParam.taskStatus;
		} else {
			var taskStatus = document.getElementsByName("TaskStatus");
			if (taskStatus && taskStatus.length == 1) {
				strActionName = taskStatus[0].value;
			} else if (taskStatus && taskStatus.length > 0) {
				for (var i = 0; i < taskStatus.length; i++) {
					if (taskStatus[i].value != "") {
						strActionName = taskStatus[i].value;
						break;
					}
				}
			}
		}
		if (strActionName != "") {
			var strUrlSF = new SafeURL(pega.desktop.pzLoadHelpFromFlowAction);
			strUrlSF.put("ActionName", strActionName);
			var strUrl = pxReqURI + "?" + strUrlSF.toQueryString();
			window.open(strUrl, 'Instructions', 'width=500,height=500,resizable,scrollbars');
		}
	},
  
    /*API to handle loading of DOM - Created to fix the flow of DOM load across all API
     *Sample implementation done in callback created in loadTabContents
     *Accepts an obj as a parameter with properties onlyOnceEle(for handleOnlyOnce),
     *domObj, newHTML,callback,partialParams (for loadDOMObject)
     * Note : domObj and newHTML are required params to run loadDOMObject API and onlyOnceEle is required for handleOnlyOnce API
     */
    handleDOMLoad: function(params) {
      if (params) {
        /*handle onlyOnce content*/
        if (params.onlyOnceEle && params.onlyOnceEle[0]) {
          pega.u.d.handleOnlyOnce(params.onlyOnceEle[0]);
        }
        /*handle DOM load*/
        if (params.domObj && params.newHTML) {
          if (params.callback) {
            pega.u.d.loadDOMObject(params.domObj, params.newHTML, params.callback);
          } else if (params.callback && params.partialParams) {
            pega.u.d.loadDOMObject(params.domObj, params.newHTML, params.callback, params.partialParams);
          } else {
            pega.u.d.loadDOMObject(params.domObj, params.newHTML);
          }
        }

      }
    },
  
  /*
  * - Checks if the current thread is dcspa thread.
  */
  isDCSPAThread: function(threadName) {
    // startsWith is not supported in IE11, hence using indexOf here.
    return (threadName && threadName.indexOf("DCSPA") === 0);
  },

	/* @public @Handler
	getThreadName() Returns the current thread name.
  @param otherctx - get the thread in the given other pega.ctx context,
                  - if not provided, default to current pega.ctx context.
	@return $String$ threadName
	 */
	getThreadName : function (otherpegactx) {
		var url = otherpegactx ? otherpegactx.url : (pega.ctx.url || "");
    var threadName;
		var csrfToken = url.indexOf("/!@");
		if (csrfToken > -1) {
			var threadNamewithCSRFToken = url.substring(csrfToken + 3);
			var bangIndx = threadNamewithCSRFToken.indexOf("!")
			var endIndex = threadNamewithCSRFToken.indexOf('?');
			threadName = threadNamewithCSRFToken.substring(bangIndx + 1, endIndex);
		} else {
			 /*changes related to MobileClient URL*/
			var startIndex = url.indexOf('!') + 1;
			var endIndex = url.indexOf('?');
      if(endIndex>1){
			  threadName = url.substring(startIndex, endIndex);
      }else{
        threadName = url.substring(startIndex,url.length );
      }
		}
    return threadName;
	},
  
  /* @public @Handler
	getPortalThreadName() Returns the portal thread name, by looking up "portalThreadName" parameter in the url. Otherwise returns "STANDARD"
	@return $String$ portalThreadName
	 */
  getPortalThreadName : function () {
    var desktopWin = pega.desktop.support.getDesktopWindow();
    var portalThreadName = "STANDARD";
    if(desktopWin){
        //from desktop window
      var currentCtx = desktopWin.pega.ctx;
      desktopWin.pega.ctxmgr.setContext(desktopWin.pega.ctxmgr.getRootDocumentContext());
      portalThreadName = desktopWin.pega.u.d.getThreadName();
      desktopWin.pega.ctxmgr.setContext(currentCtx);
  } else {
      //from primary tracker (mashup)
      portalThreadName = pega.ui.ChangeTrackerMap.getPrimaryTracker().threadName;
    }
    return portalThreadName;
  },

  /*
  This method returns portal level pxReqURI.
  */
  getPortalReqURI: function() {
    var desktopWin = pega.desktop.support.getDesktopWindow();
    if (!desktopWin) {
      desktopWin = window;
    }
    if (desktopWin) {
      return desktopWin.pega.ctx.pxReqURI;
    }
  },

	/* @public @Handler
	disablePasswordReload() If a section has password field and if it is refreshed then we do harness reload. Call this api to force section refresh when we have password field.
	@return $void$
	 */
	disablePasswordReload : function () {
		pega.u.d.forceAJAX = true;
	},

	/* @public @Handler
	isSafeToReload : Returns true if safe to reload the passed argument
	@return boolean
	 */
	isSafeToReload : function (reloadElement) {
		if (this.preReloadEle && ((this.preReloadEle === reloadElement) || (pega.util.Dom.isAncestor(this.preReloadEle, reloadElement)))) {
			/* the preReloadEle is already set and is either same as reloadElement or its ancestor which signifies
			 * that the reloadElement is already waiting to be reloaded due to some previous AJAX;
			 * hence not safe to reload.
			 */
			/*if a grid action is executed and inCall is true, then make it false and re-initialize the eventsArray to avoid hang of grid in further operations*/
			if (pega.u.d.inCall) {
				pega.u.d.inCall = false;
				if (pega.u.d.changeInEventsArray) {
					pega.u.d.changeInEventsArray.fire();
				}
			}
			return false;
		}

		return true;
	},

	/*
	Generic method to prevent propagation of Enter key
	 */
	stopEnterKeyPropagation : function (event) {
		event = event || window.event;
		if (event.keyCode == 13) {
			pega.util.Event.stopPropagation(event);
		}
	},

	switchThread : function (threadName) {
    var harnessContext = pega.ui.HarnessContextMgr.getCurrentHarnessContext(),
		url = harnessContext.getProperty('url');
    //commented the pxReqURI code to fix the BUG-568912 
    var pxReqURI = harnessContext.getProperty('pxReqURI');
		threadName = threadName.replace(/^([\s]+)|([\s]+)$/g, "");
    var originalThreadName = threadName;
		var csrfTokenIndx = url.indexOf("/!@");
		if (csrfTokenIndx > -1) {
			var csrfToken = url.substring(csrfTokenIndx + 3, url.indexOf("!", csrfTokenIndx + 3));
			threadName = "@" + csrfToken + "!" + threadName;
		}
		url = url.replace(/\!.+\?/, "!" + threadName + "?");
    pxReqURI = pxReqURI.replace(/\!.+/, "!" + threadName);
    harnessContext.setProperty('url', url);
    harnessContext.setProperty('pxReqURI', pxReqURI);
      	
        /* BUG-226582: Initialize ClientCache with the new thread */
        /* BUG-245578: We cannot simply depend on pega.u.d.switchThread to initialize ClientCache, sometimes pega.u.d.url is directly modified */
        // pega.ui.ClientCache.init();
		
		// Initialize ClientDataProvider with the new thread
		if(pega.ui.ClientDataProvider)
	        pega.ui.ClientDataProvider.switchThread(originalThreadName);
	},

  	setPrimaryPage : function (pageName) {
	    var harnessContext = pega.ui.HarnessContextMgr.getCurrentHarnessContext(),
		    url = harnessContext.getProperty('url');


		var pudURL = SafeURL_createFromURL(url);
		var currPgNm = pudURL.get('pzPrimaryPageName');

		if (pageName == currPgNm || (pageName != "pyDisplayHarness" && currPgNm != "pyDisplayHarness" && pageName != "pyPortalHarness" && currPgNm != "pyPortalHarness")) {
			return;
		}
		pudURL.put('pzPrimaryPageName', pageName);
		url = pudURL.toURL();
      	harnessContext.setProperty('url', url);

		/* these variables are set in WorkFormStandard; so setting them here too */
		this.primaryPageName = pageName;
		strPrimaryPage = pageName;
    },

	switchPrimaryPage : function (pageName) {
		/* allow to switch primary page only if the harness has panel sets and
		 * either pageName or pzPrimaryPageName in this.url is equal to
		 * "pyDisplayHarness" which is the primary page name in portals and harness with panel sets
		 */
		if (!pageName || !this.isPanelSetHarness()) {
			return;
		}
      	this.setPrimaryPage(pageName);
	},

	/* Autobots 6.2 Sprint 11 - WorkArea Icons Story - kumar4 - Start */
	getWorkIcon : function () {
		var iconObj = document.getElementById('WAIcon');
		if (iconObj)
			return iconObj.attributes['data-WAIcon'].value;
		else
			return "";
	},
	/* Autobots 6.2 Sprint 11 - WorkArea Icons Story - kumar4 - End */

	checkEnterKey : function (event) {
		if (pega.u && pega.u.d && (pega.u.d.isAccessible || pega.u.d.bModalDialogOpen))
			return;
		if (event.keyCode == 13) {
			var srcObj = pega.util.Event.getTarget(event);
			/* HFix-28377: START - If enter triggered from a overlay, it should not submit the form */
			try {
				if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.bIsOverlay == "true") {
					var __popOverContrainer = document.getElementById("_popOversContainer");
					if (__popOverContrainer && srcObj && pega.util.Dom.isAncestor(__popOverContrainer, srcObj)) {
						return;
					}
				}
			} catch(e) { }
			/* HFix-28377: END */
			if ((srcObj.tagName != 'TEXTAREA' && srcObj.tagName != 'A' && srcObj.tagName != 'SELECT' && srcObj.id != 'ActionLink' && srcObj.type != 'button') || (srcObj.type == 'button' && srcObj.onclick == doSubmit)) {
				pega.u.d.submit('pyActivity=FinishAssignment', null, '', event);
				pega.util.Event.stopPropagation(event);
				pega.util.Event.preventDefault(event);
			}
		}
	},

	checkEnterKeyNoSubmit : function (event) {
		if (pega.u && pega.u.d && (pega.u.d.isAccessible || pega.u.d.bModalDialogOpen))
			return;
		if (event.keyCode == 13) {
			var srcObj = pega.util.Event.getTarget(event);
			if ((srcObj.tagName != 'TEXTAREA' && srcObj.tagName != 'A' && srcObj.tagName != 'SELECT' && srcObj.id != 'ActionLink' && srcObj.type != 'button') || (srcObj.type == 'button' && srcObj.onclick == doSubmit)) {
				pega.util.Event.preventDefault(event);
			}
		}
	},

	/*
	@api registerModalListener Register the callback function for modal window open/close callback - moved from modal dialog JS as it is loaded at the bottom
	@param $Function$modalCallbackFunc Function name to be called back
	 */
	registerModalListener : function (modalCallbackFunc) {
		var modalCallbackLength = this.modalCallback.length;
		for (var i = 0; i < modalCallbackLength; i++) {
			if (this.modalCallback[i] == modalCallbackFunc)
				return;
		}
		this.modalCallback.push(modalCallbackFunc);
	},

	/*
	@api specialtyComponent is namespace provided with a bunch of functionalities for Third Party Components
	 */
	specialtyComponent : (function () {
		return {
			/*
			@api getClipboardData is used to get data from the clipboard to third party component
			@param $componentId is unique id generated per component instance to identify it
			@return $jsonData gives json object with all the properties of third party component from clipboard
			 */
			getClipboardData : function (componentId) {
				return eval("pzComponentData_" + componentId);
			},

			/*
			@api setClipboardData is used to set data to the clipboard to third party component
			@param $componentId is unique id generated per component instance to identify it
			@param $jsonData is json object with all the properties of third party component to set to clipboard properties
			@return $void
			 */
			setClipboardData : function (componentId, jsonData) {
				var data;
				if (typeof jsonData === 'string') {
					if (jsonData != null && jsonData != undefined && jsonData.length > 0) {
						data = JSON.parse(jsonData);
					}
				} else if (typeof jsonData === 'object' && jsonData != null) {
					data = jsonData;
				} else {
					throw new Error("Data of invalid type passed into setComponentData!");
				}
				var entryhandleJSON = eval("pzEntryHandles_" + componentId);
				var resQString = pega.u.d.jsonToQuery(data, entryhandleJSON);
				var pySpecialtyDataInput = document.getElementById("pySpecialtyComponentData");
				var componentFieldDiv = document.getElementById("speciality_" + componentId);
				if (pySpecialtyDataInput) {
					window.pzSpecialityComponentDataInputName = pySpecialtyDataInput.name;
				} else {
					var tempInput = document.createElement('input');
					tempInput.setAttribute("name", window.pzSpecialityComponentDataInputName);
					tempInput.setAttribute("type", "hidden");
					tempInput.setAttribute("id", "pySpecialtyComponentData");
					if (document.forms[0]) {
						document.forms[0].appendChild(tempInput);
					} else {
						document.body.appendChild(tempInput);
					}
					pySpecialtyDataInput = tempInput;
				}
				if (componentFieldDiv) {
					componentFieldDiv.appendChild(pySpecialtyDataInput);
				}
				pySpecialtyDataInput.value = (pySpecialtyDataInput.value ? (pySpecialtyDataInput.value + "&") : "") + resQString;
			}
		};
	}
		()),


	/*
	Validates all the input fields in the container and returns false if any of the field values are not valid otherwise returns true
	@param $Function$container The container in which the field values should be validated, it can be a section or null/undefined, in which case all the harness field values will be validated
	 */
	areInputsValid : function (event, container) {
		if (typeof(bClientValidation) != "undefined") {
			if (bClientValidation && (typeof(validation_validate) == "function")) {
				var valid;
				if (typeof(container) != "undefined")
					valid = validation_validate(container);
				else
					valid = validation_validate();
				if (!valid) {
					if (typeof(customClientErrorHandler) != "undefined") {
						var exit = customClientErrorHandler();
						if (exit) {
							pega.util.Event.stopEvent(event);
              docFocus.focusToFirstInvalidField();
							return false;
						}
					} else {
            // reset uiperf tracking
            pega.ui.statetracking.resetBusyTotalizer();

            // If modal dialog is open, errors will be handled in shouldSubmitProceed. So, we can skip here.
            if (!pega.u.d.bModalDialogOpen) {
              alert(form_submitCantProceed);
            }
						pega.util.Event.stopEvent(event);
            docFocus.focusToFirstInvalidField();
						return false;
					}
				}
			}
		}
		return true;
	},

	/**
	 * Returns harness type
	 * @returns - boolean
	 */
	getProcessType : function () {
		return this.processHarnessType;
	},

	/**
	 * Returns true if harness type is Confirm
	 * @returns - boolean
	 */
	isConfirm : function () {
		if (this.processHarnessType.toLowerCase() == "confirm") {
			return true;
		} else {
			return false;
		}
	},

	/**
	 * Returns true if harness type is Review
	 * @returns - boolean
	 */
	isReview : function () {

		if (this.processHarnessType.toLowerCase() == "review") {
			return true;
		} else {
			return false;
		}
	},

	/**
	 * Returns true if harness type is New
	 * @returns - boolean
	 */
	isNew : function () {

		if (this.processHarnessType.toLowerCase() == "new") {
			return true;
		} else {
			return false;
		}
	},

	/**
	 * Returns true if harness type is Peform
	 * @returns - boolean
	 */
	isPerform : function () {

		if (this.processHarnessType.toLowerCase() == "display") {
			return true;
		} else {
			return false;
		}
	},

	/**
	 * Returns true if harness type is Display
	 * @returns - boolean
	 */
	isDisplay : function () {

		if (this.processHarnessType.toLowerCase() == "display") {
			return true;
		} else {
			return false;
		}
	},

	/* @Handler @api
	Set the gSectionReloaded to false to clear out marker that section was reloaded
	@param
	@return null
	 */
	clearReloadedStatus : function () {
		pega.ctx.gSectionReloaded = false;
	},

	/*
	@Private - After clicking and before submitting the data this function get called
	@param $Object$  event
	@param $Object$ contextobject
	@return $void$
	 */
	registerOnBeforeSubmit : function (onSubmitFunction, contextObject) {
		var len = pega.u.d.onSubmits.length;
		for (var i = 0; i < len; i++) {
			if (pega.u.d.onSubmits[i] == onSubmitFunction && pega.u.d.contextObjects[i] == contextObject)
				return;
		}
		pega.u.d.gSubmitIdx++;
		pega.u.d.onSubmits[pega.u.d.gSubmitIdx] = onSubmitFunction;
		pega.u.d.contextObjects[pega.u.d.gSubmitIdx] = contextObject;
	},
  isAppOfflineEnabled : function(){
        return (pega && pega.offline);
    },
  
  /*removes all non decimal characters in a given number, this is used in pxCurrencyInternational control*/
  	removeNonDecimalCharacters : function(event){ 
    	var srcElement = pega.util.Event.getTarget(event)
    	if(srcElement && srcElement.value){
    		srcElement.value = srcElement.value.replace(/[^\d.,-]/g,"");
    	}
    },
    getCRC32LpadHash : function(s, len, chr){
        var L = len - s.length, C = chr || " ";
        if(L <= 0) return s;
        return new Array(L+1).join(C) + s;
    },
    getCRC32HashId : function(propName){
        if(bEnableUniqueId == "true"){
        var threadPrefix = "";
        var threadName = "";
        var crc32Hash = "";
        if(pega.ctx && pega.ctx.isMDC){
          threadName = pega.u.d.getThreadName();
          if(threadName.indexOf("/")>0){
            threadPrefix = threadName.substring(threadName.indexOf("/")+1);
          }
        }
        crc32Hash = CRC32.str(threadPrefix+propName);
        return pega.u.d.getCRC32LpadHash((crc32Hash>>>0).toString(16),8,'0');
        }else{
          return propName.substring(propName.lastIndexOf(".")+1);
        }
    },
  
    isAjaxContainerExists: function(){
      
      //if (pega.u.d.isDcExists()) return false;
      
      var isACExists = !!document.querySelector("div[data-mdc-id]");

      if(!isACExists){
        var desktopWin = pega.desktop.support.getDesktopWindow();

        if(desktopWin && desktopWin !== window) {
          isACExists = !!desktopWin.document.querySelector("div[data-mdc-id]");
        }
      }

      return isACExists;
    },
  
    /**
     * Get the AjaxContainer name dynamically based on pega.ctx / event / Dom
     * This should be ideally invoked from the AjaxContainer context
     * 
     * @method getTargetACName
     * @param {DOMEvent} event the DOM event object (Optional)
     * @returns {String} the AjaxContainer name
     */
    getTargetACName : function (event) {

      var acTargetName="";
      // get the name from closest acName from the event target
      if (event && pega.ui.hasAjaxContainer) {

        var target = pega.util.Event.getTarget(event);
        
        if(target){
          var acTargetDiv = target.closest("div[data-mdc-id]");
          if(acTargetDiv) {
            var acName = acTargetDiv.getAttribute("data-mdc-id");
            if(acName){
              acTargetName = acName;
            }
          }
        }

      }

      return acTargetName;
    },
	/**
   * @api - get the section div in whcich this element is present
	 * @param
	 * @return $HTMLElement$
	**/
	getSectionDiv : function (element) {
		if (element) {
			while ((element.id != "RULE_KEY") || (element.getAttribute("node_type") != "MAIN_RULE")) {
				element = element.parentNode;
				if (element == null || element == document.body) {
					break;
				}
			}
		}
		return element;
	},
    
  /**
	 * @protected Holds common functionality for reloading a section/repeatlayout
	 * @param $Object$oArgs - this object has paramters to be passed to this function
	 * @return $boolean$
	 **/
	getSectionId : function (element) {
		var id = element.getAttribute("uniqueID");
		if (id == null || id.indexOf("SID") != 0) {
			return "";
		} else {
			return id;
		}
	},
  
  addListenersToSecurityWarning: function(){

    var warningDiv = document.querySelector("#security-warnings");
    if(warningDiv){
      warningDiv.addEventListener("mouseover", function() {
        var securityBody = document.querySelector("#security-warnings-body");
        if(securityBody){
           securityBody.style.display = "block";
        }
      });

      var timeoutset = 0;
      warningDiv.addEventListener("mouseout", function() {
        if(!timeoutset) {
          timeoutset = setTimeout(function() {
            timeoutset = 0;
            var securityBody = document.querySelector("#security-warnings-body");
            if(securityBody){
              securityBody.style.display = "none";
            }
          }, 5000);
        }
      });
    }
  },
  
  showURLTamperFailures: function (respObject, safeURL) {
    var retHTML = respObject.responseText;
    var securityWarningStart = "||" + "SecurityWarningStart" + "||";
    var securityWarningEnd = "||" + "SecurityWarningEnd" + "||";
    if(retHTML.indexOf(securityWarningStart) !== -1) {
      if(respObject.argument && safeURL) {
        console.warn("URL Tamper debug logs - pyActivity: " + safeURL.get("pyActivity") + ", DOM element: ");
        console.dir(respObject.argument[0]);
      } else if(respObject.argument) {
        console.warn("URL Tamper debug logs - " + "DOM element: ");
        console.dir(respObject.argument[0]);
      } else if(safeURL) {
        console.warn("URL Tamper debug logs - pyActivity: " + safeURL.get("pyActivity"));
        if(window.event){
          console.log("Source element: ")
          console.dir(window.event.target);
        }
      }
      var response = retHTML.substring(0, retHTML.indexOf(securityWarningStart));
      respObject.responseText = response;

      var securityWarnings = retHTML.substring(retHTML.indexOf(securityWarningStart) + securityWarningStart.length, retHTML.indexOf(securityWarningEnd));
      var securityWarningDiv = document.querySelector("#security-warnings");
      if(!securityWarningDiv) {
        securityWarningDiv = document.createElement("div");
        securityWarningDiv.setAttribute("id", "security-warnings");
        securityWarningDiv.setAttribute("class", "error-table");
        securityWarningDiv.style.position = "absolute";
        securityWarningDiv.style.zIndex = "10";
        securityWarningDiv.style.border = "2px solid #E94B35";
        securityWarningDiv.style.cursor = "pointer";
        securityWarningDiv.innerHTML = "<div id='security-warnings-body' style='display:none'>" + securityWarnings + "</div>";
        
        var error_div = document.querySelector("#FormErrorMarker_Div");
        if(error_div) {
          error_div.appendChild(securityWarningDiv);
          error_div.style.display = "block";
          this.addListenersToSecurityWarning();
        }

        /*var header = document.createElement("h2");
        header.innerHTML = "<span id='expand-arrow' class='expand-arrow-right expand-arrow1'></span>URL tampering vulnerability detected (<a href=''>What is this?</a>)";
        securityWarningDiv.appendChild(header);

        var body = document.createElement("div");
        body.setAttribute("id", "security-warnings-body");
        body.style.display = "none";
        securityWarningDiv.appendChild(body);
        var styles = "<style>" +
          ".expand-arrow-right {" +
            "border-top: 10px solid transparent;" +
            "border-bottom: 10px solid transparent;" +
            "border-left: 10px solid #000;" +
          "}" +
        ".expand-arrow-bottom {" +
          "border-left: 10px solid transparent;" +
          "border-right: 10px solid transparent;" +
          "border-top: 10px solid #000;" +
        "}" +
        ".expand-arrow-right," +
          ".expand-arrow-bottom{" +
           " width: 0 !important;" +
            "height: 0 !important;" +
            "margin: 15px;" +
            "font-size: 0;" +
            "vertical-align: middle;" +
          "}" +
         "</style>";
        
        securityWarningDiv.innerHTML += styles;

        var container = document.body.querySelector("main");
        if(!container) {
          container = document.body;
        }
        container.appendChild(securityWarningDiv);*/

      }

      /*var securityWarningBody = document.querySelector("#security-warnings-body");
      securityWarningBody.innerHTML += securityWarnings;
      // var warningsCount = securityWarningBody.querySelectorAll(".warning").length;
      // securityWarningDiv.querySelector("#count").innerHTML = warningsCount;

      var arrowSpan = document.querySelector(".expand-arrow1");
      if(arrowSpan) {
        arrowSpan.addEventListener("click", function() {
          var securityWarningBody = document.querySelector("#security-warnings-body");
          var expandCollapse = securityWarningBody.parentNode.querySelector("#expand-arrow");
          if(!securityWarningBody.style.display) {
            securityWarningBody.style.display='none';
            expandCollapse.setAttribute("class", "expand-arrow-right");
          } else {
            securityWarningBody.style.display='';
            expandCollapse.setAttribute("class", "expand-arrow-bottom");
          }

        });
        arrowSpan.classList.remove("expand-arrow1");
      }*/
    }
  },
  closeURLTamperFailures: function() {
    var securityWarningDiv = document.querySelector("#security-warnings");
    if(securityWarningDiv) {
      securityWarningDiv.parentNode.removeChild(securityWarningDiv);
    }
  },
  isRdlInMiddle: function(clickedElement, containerElement) {
    var rdlParentIfAny = clickedElement && clickedElement.closest && clickedElement.closest('[data-repeat-source]');
    var rdlInMiddle = rdlParentIfAny && containerElement.contains(rdlParentIfAny);
    return !!rdlInMiddle;
  }
}

pega.lang.augmentObject(pega.ui.Doc.prototype, docMethods);
docMethods = null;
//static-content-hash-trigger-GCC
var onloadMethods = {  
  onAJAXLoads: [],
  onUnloads: [],
  initialOnloads: [],
  dummyFunction: function(){},

  /*
  @public attachOnLoad adds the function as a window onload event handler.
  This is useful to register any function as an onload event handler in our harness like in case of DynamicSelect code.
  @param skipOnce - This is set when invoked from pega.u.d.harness_execute API, to skip onloadFunction execution once during processOnHarnessloads.
  */
  attachOnload : function(onloadFunction, bInvokeOnReload, scopeObj, skipOnce) {
    var thisObj = this;
   
    thisObj.initialOnloads.push({ "onloadFunction": onloadFunction, "scope": scopeObj, "bInvokeOnReload": bInvokeOnReload, "skipOnce": skipOnce });

    if(bInvokeOnReload){
      for (var i = 0; i < thisObj.onAJAXLoads.length; i++) {
        if (this.onAJAXLoads[i].fn == onloadFunction)
          return;
      }
      thisObj.onAJAXLoads.push({ fn: onloadFunction });
    }
  },

  /*
  @public detachOnLoad is used for orderly removal of custom harness onload call backs
  */
  detachOnload : function(onloadFunction) {
    var thisObj = this;

    for (var i = 0; i < thisObj.onAJAXLoads.length; i++) {
      if (thisObj.onAJAXLoads[i].fn == onloadFunction) {
        if (thisObj.processOnloadsActive) {
          thisObj.onAJAXLoads[i].fn = this.dummyFunction;
          thisObj.cleanDetachedFunctions = true;
        } else {
          thisObj.onAJAXLoads.splice(i, 1);
        }
        return;
      }
    }
  },

  /*
  @public attachOnUnload adds the function as a window on unload event handler.
  This is useful to register any function as an on unload event handler in our harness.
  */
  attachOnUnload : function(onUnloadFunction) {
    var thisObj = this;

    for (var i = 0; i < thisObj.onUnloads.length; i++) {
      if (thisObj.onUnloads[i] == onUnloadFunction)
        return;
    }
    thisObj.onUnloads.push(onUnloadFunction);
  },

  /*
  @public detachOnUnload detachOnLoad is used for orderly removal of custom harness on unload call backs
  */
  detachOnUnload : function(onUnloadFunction) {
    var thisObj = this;
    for (var i = 0; i < thisObj.onUnloads.length; i++) {
      if (thisObj.onUnloads[i] == onUnloadFunction) {
        thisObj.onUnloads.splice(i, 1);
        return;
      }
    }
  },

  /*
  @This is for internal purpose
  * @param container (or) event
  * - container, in case of AJAX, Reload scenarios
  * - event, in case of inital window load
  */
  processOnHarnessloads : function(container) {
    var thisObj = this;
    try {
      var onloadsLength = thisObj.initialOnloads.length;
      for (var i = 0; i < onloadsLength; i++) {
        var onloadObj = thisObj.initialOnloads[i],
            onloadFunction = onloadObj.onloadFunction;

        if(onloadObj.skipOnce) {
          delete onloadObj.skipOnce;
          continue;
        }

        if (onloadObj.scope) {
          onloadFunction.call(onloadObj.scope, container);
        } else {
          onloadFunction(container);
        }
        
      }
      
      // invoke method to remove harness onloads from initialOnloads.
      this._removeOnHarnessloads(container);
    }
    catch(e) {
      console.log(e);
    }
  },
  
  /*
  @This is to remove harness specfic onloads from 'initialOnloads', when initialOnloads processing is complete.
  * @param container (or) event
  * - container, in case of AJAX, Reload scenarios
  * - event, in case of inital window load
  */  
  _removeOnHarnessloads : function() {
    var thisObj = this;
    var i = thisObj.initialOnloads.length;

    while(i--){
      var onloadObj = thisObj.initialOnloads[i];
      if(!onloadObj.bInvokeOnReload) {
        thisObj.initialOnloads.splice(i, 1);
      }        
    }
    
  },

  /*
  @protected- This function is called to execute the onload functions after reload.
  @param $Object$container - The container object
  @return $void$
  */
  processAJAXOnloads : function(container) {
    if(null == container) {
      container = document;
    }
    var thisObj = this;
    thisObj.processOnloadsActive = true;
    for (var i = 0; i < thisObj.onAJAXLoads.length; i++) {
      var onloadFunction = thisObj.onAJAXLoads[i].fn;
      if(onloadFunction) {
        onloadFunction(container);
      }
    }
    if (thisObj.cleanDetachedFunctions) {
      var j = thisObj.onAJAXLoads.length;
      while (j--) {
        if (thisObj.onAJAXLoads[j].fn == thisObj.dummyFunction) {
          thisObj.onAJAXLoads.splice(j, 1);
        }
      }
      thisObj.cleanDetachedFunctions = false;
    }
    thisObj.processOnloadsActive = false;
  },

  /*
  @protected- This function is called to execute the onload functions after reload.
  @param $Object$container - The container object
  @return $void$
  */
  processOnloads : function(container) {
    this.processAJAXOnloads(container);
  },

  /*
  @protected- This function is called to execute the unload functions.
  @param $Object$container - The container object
  @return $void$
  */
  processOnUnloads : function(container) {
    var thisObj = this;
    if (!thisObj.onUnloads)
      return;

    if (null == container) {
      container = document;
    }
    for (var i = 0; i < thisObj.onUnloads.length; i++) {
      var onUnloadFunction = thisObj.onUnloads[i];
      onUnloadFunction(container);
    }
  }
};
pega.lang.augmentObject(pega.ui.Doc.prototype, onloadMethods);
//static-content-hash-trigger-GCC
var docLifecycle = {
	CHECK_READYSTATE_TIMER: 100,
	CHECK_DONERENDER_TIMER: 500,
	gIsLoadingCounter: 0,
	gIsLoading: false,
	resizeFunctions: new Array(),
	harnessInitialized: false,
	/* harnessInitialized is to know if harness is initialized */
    /*
     *  the array to hold functions to be invoked in order of registration for every IFrame available in the document
     */


	onFrameLoads: new Array(),
    /*
     *  The total number of iframes found as direct children of current document to which 'processOnFrameLoads' is attached.
     *  This also include the current document incase it is inside a Frame/IFrame
     */
	totalFrames: 0,
	/***/
	_tmpasyncRequestQueue: new Array(),
    /*
      @Public - Calls all functions when document get loaded (harness)
      @param $Object$  event
      @return $void$
    */
	initializeInner: function(event) {

		// var harnessContext = pega.ui.HarnessContextMap.getCurrentHarnessContext(),
		var isUITemplatized = pega.ctx.isUITemplatized,
			harCtxMgr = pega.ui.HarnessContextMgr;

		// stamp harnessid to the harness container(body in this case) as early as possible
		document.body.setAttribute("data-harness-id", pega.ctx.pzHarnessID);

		// publish state for test tooling - order important
		pega.ui.statetracking.setDocumentBusy("initialising");
		pega.ui.statetracking.setNavigationDone(window);

		pega.u.d.harnessInit = true;
		this.harness_execute(this.registerOnFrameLoads, true, event);

		if (typeof pega.ui.property == 'function') {
			pega.u.property = new pega.ui.property();
		}

		/*if harness type layout, initialize it first*/
		if (this.harnessType && this.harnessType == "layout") {
			this.portal = initLayout();
			var units = this.portal.unitConfig;
			var len = units.length;
			for (var i = 0; i < len; i++) {
				var eachUnit = units[i];
				var bResizeAttr = (eachUnit["tempResize"] === 'true');
				var positionAttr = eachUnit["position"];
				var gutterAttr = eachUnit["tempGutter"];
				this.portal.layoutObj.getUnitByPosition(positionAttr).set('resize', bResizeAttr);
				this.portal.layoutObj.getUnitByPosition(positionAttr).set('gutter', gutterAttr);
			}
			document.getElementById("layout-doc").style.display = "block";
			this.portal.customizeLayout();
			this.portal.stretchLayoutsToContent();
		}

		pega.u.d.tabsOrAccorInit = false;
		pega.u.d.focusCount = 0;
		var tabsList = pega.util.Dom.getElementsById("PEGA_TABBED");
		if (tabsList != null) {
			pega.u.d.tabsOrAccorInit = true;
			pega.u.d.focusCount = pega.u.d.focusCount + tabsList.length;
		}

		var accordionList = pega.util.Dom.getElementsById("PEGA_ACCORDION");
		if (accordionList != null) {
			pega.u.d.tabsOrAccorInit = true;
			pega.u.d.focusCount = pega.u.d.focusCount + accordionList.length;
		}

		/* update client-side onceonly list (moved from inline US-135506) */
		var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", document);
		if (onlyOnceEle && onlyOnceEle[0]) {
			pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
		}

		/*Call initliaze Change Tracker */
		this.initChangeTracker();
        /*
        if(pega.ui.ClientCache) {
            
            //var metadataTree = pega.ui.ClientCache.find("D_UITemplateMeta");
            // TODO: Temporarily set metadata tree
            var D_UITemplateMeta = pega.ui.ChangeTrackerMap.getTracker().trackedPropertiesList["D_UITemplateMeta"];
            if(D_UITemplateMeta)
                pega.ui.TemplateEngine.setMetadataTree(D_UITemplateMeta);

            // Read metadata
            var metadataTree = pega.ui.TemplateEngine.getMetadataTree();
            
            if(metadataTree) {
                pega.ui.template.RenderingEngine.beginRendering(
                    document,
                    function(){
                        pega.ui.template.DataBinder.bindData(document);
                    }
                );
            }
        }
        */

		/* This will add listener to popup window to get changes list on focus of the window. */
		this.getChangesInCurrentPopup();

		// Invoke Rendering Engine
		//this.harness_execute(pega.ui.TemplateEngine.renderUI, false, event);
		this.harness_execute(pega.ui.TemplateEngine.renderAsyncStreams, true, event);

		if (typeof this.loadSmartInfo === 'function') {
			this.harness_execute(this.loadSmartInfo, true, event);
		}

		this.harness_execute(this.attachAccessKeys, true, event, 10);

		if (typeof this.initTabs === 'function') {
			this.harness_execute(this.initTabs, false, event);
		}

		if (typeof this.getFocusOnNewRow === 'function') {
			this.harness_execute(this.getFocusOnNewRow, false, event);
		}

		this.harness_execute(this.modalDialogInit, false, event);

		if (typeof this.initializeTabs === 'function') {
			this.harness_execute(this.initializeTabs, true, event);
		}

		if (typeof this.initializeAccor === 'function') {
			this.harness_execute(this.initializeAccor, true, event);
		}

		this.harness_execute(this.showErrors, true, event);
		this.harness_execute(this.doLazyLoad, true, event);

		this.harness_execute(this.initializeGrids, true, event);

		// Initailzie timeline
		this.harness_execute(this.initializeTimeline, true, event);



		this.harness_execute(this.initializeCharts, true, event);
		this.harness_execute(this.setAriaLabelForAC, true, event);
		this.harness_execute(this.resetDateTimeHidden, true, event);
        /*part 2 of 2 fixes for BUG-214825 : UHG Pega: expressions don't hide elements in RDL
        evaluateAllVisibleWhens seems to depend on a hidden input element with value custom data bound to e.g., "D_SomePage.pxResults(1).pySomeProperty" to get the value of the when-expression-operands - therefore custom databinder needs to run first on the hidden fields and evaluateAllVisibleWhens later*/
		this.harness_execute(this.invokeDataBinder, true, event);
		//Trigger in non-template case or template case where it also has expressions in non-template component
		if (!isUITemplatized || (isUITemplatized && pega.ui.ExpressionEvaluator.getNTExpressionStatus())) {
			this.harness_execute(this.evaluateAllVisibleWhens, true, event);
		}
		//this.harness_execute(this.evaluateAllVisibleWhens,true,event);
		/*this.harness_execute(this.attachFocusToElements,true,event);*/
		this.resetBusyState();
		this.removeClass(document.body, "busyBody");

		this.processOnHarnessloads(event);

		if (this.portal && this.portal.accorIndex != null && this.portal.accorObj != null) {
			registerEventListener("DesktopAction", this.portal.doBeforeOpen, null, pega.ui.Layout);
		}

		this.harness_execute(this.doHarnessResize, false, event, 10);
		this.harness_execute(this.doOnceOnInit, true, event);
		if (typeof bRecordEvent != "undefined" && bRecordEvent) {
			/* end the client time outside the current JS execution thread so as to yield to other onLoad functions, if any */
			window.setTimeout(function() {
				pega.u.d.Timer.updateClientEndTime();
				pega.u.d.Timer.endCurrentTimer();
			}, 10);
		}

		/* BUG-220331 Accesibilty Issue : Confirmation message is not read out by JAWS -- Start */
		/* Creating div with role=status */
		this.harness_execute(function() {
			var confirmMsgDiv = $("div.sectionDivStyle[node_name='pyConfirmMessage']");
			var harCtxMgr = pega.ui.HarnessContextMgr;
			pega.u.d.confirmMsgText = "";
			if (confirmMsgDiv.length) {
				pega.u.d.confirmMsgText = $(confirmMsgDiv).text(); /* Getting the confirm message string */
				var oWnd = pega.desktop.support.getDesktopWindow();
				if (!oWnd) {
					oWnd = window;
				}
				/* Removing existing divs with role=status in invisible iframes */
				var containers = oWnd.document.querySelectorAll(".iframe-wrapper");
				for (var i = 0; i < containers.length; i++) {
					if (containers[i].querySelector("iframe") != null && containers[i].style.display == "none") {
						var statusDiv = containers[i].querySelector("iframe").contentDocument.getElementById("statusDiv");
						if (statusDiv != null) {
							statusDiv.parentNode.removeChild(statusDiv);
						}
					}
				}

				/* Appending a div with role=status to body so that msg is read by AT products */
				var statusDiv = $("body").find("#statusDiv");
				if ($(statusDiv).length > 0)
					$(statusDiv).text("");
				else if (!($('html').hasClass('phone') || $('html').hasClass('tablet'))) /* BUG-228518 : statusDiv injects 1px white line in UI */
					$("body").prepend("<div id='statusDiv' role='status' aria-live='polite' aria-atomic='true' class='pzPegaThrobberLiveRegion'></div>");

			}
		}, false, event);

		/* Putting the content in status div */
		this.harness_execute(function() {
			if ($("#statusDiv").length)
				$("#statusDiv").text(pega.u.d.confirmMsgText);
		}, false, event, 1200);

		/* BUG-220331 Accesibilty Issue : Confirmation message is not read out by JAWS -- End */

		if (!pega.u.d.tabsOrAccorInit)
			this.harness_execute(this.initFocusOnFirstInput, false, event);

		//Restart session timeout timer whenever server activity is encountered
		this.harness_execute(pega.desktop.support.restartTimeoutWarningTimer, true, event);
		if (window == top && !document.getElementById("workarea")) {
			this.harness_execute(this.rollBackElementUpdate);

		}
		this.harness_execute(this.initGeolocationWatch);
		this.harness_execute(this.cleanRequiredAttr, true, event);
		this.harness_execute(pega.tools.EvalDomUtils_globals.cleanup, true, event);

		pega.u.d.harnessInit = false;
		harCtxMgr.set("baseThreadName", this.getThreadName());
		pega.ctx.baseFrameName = SafeURL_createFromURL(harCtxMgr.get("url")).get('pzFromFrame');
		pega.u.d.basePrimaryPageName = this.primaryPageName;

		/*Bug-63391: Forcing Reflow in IE */
		document.body.className = document.body.className;
		/*harness initialization is set to true*/
		this.harnessInitialized = true;

		pega.ui.EventsEmitter.publish("HarnessInitialized");

		/* calling processBehavior is we have back up event*/
		if (pega.c && pega.c.ControlBehaviorExecutor) {
			var be = pega.c.ControlBehaviorExecutor.getBackupEvent();
			if (be) {
				pega.c.ControlBehaviorExecutor.processBehavior(be.e, be.ed);
				pega.c.ControlBehaviorExecutor.clearBackupEvent();
			}
		}

		/*US-102774. Toggle configure links for review harness for Pega express portals */

		var addConfigureLinks = function() {
			setTimeout(function() {
				// Only when the composer is ON.   
				if (pega.ui.composer && typeof pega.ui.composer.isComposerOn === 'function') {
					if (pega.ui.composer.isComposerOn()) {
						pega.ui.inspector.expressedit.loadConfigureLinks();
					}
				}
			}, 1000);
		};

		if (pega.u.d.primaryPageName == 'pyWorkPage' && $("div[node_name='pyCaseActionArea']").length == 0) {
			this.harness_execute(addConfigureLinks, false, event);
		}

		var changeTracker = pega.ui.ChangeTrackerMap.getTracker();
		if (changeTracker) {
			changeTracker.handlePendingCTChanges();
		}

		/*BUG-198290 */
		this.fireDeferredAsyncRequests();

		// publish state for test tooling; set document modification complete - ajax in flight counter will cover lazy loading
		pega.ui.statetracking.setDocumentDone(window);
		var bIsIe = window.navigator.userAgent.indexOf('Trident/') > 0 ? true : false;
		if (bIsIe) {
			if (pega.ctx.pyStreamNameForGadget == "PrintView") return;
			var isGridScroll = function(harnessContent, harnessClientWidth) {
				var _grids = harnessContent.find(".repeatContainer");
				if (_grids && _grids.length > 0) {
					for (var i = 0; i < _grids.length; i++) {
						if (pega.ctx.dom.$(_grids[i]).is(":visible") && (pega.ctx.dom.$(_grids[i]).width() > harnessClientWidth || pega.ctx.dom.$(_grids[i]).closest('div[class*="column-1"]'))) {
							return true;
						}
					}
				}
			}

			var flexResize = function() {
				var isFlexBased, harnessClientWidth, harnessWidth;
				var $containerBody = pega.ctx.dom.$(".containerBody");
				var $Container = pega.ctx.dom.$(".harnessContent #harness-container");
				var $hContent = pega.ctx.dom.$(".harnessContent");
				var $ieTable = pega.ctx.dom.$(".harnessContent #harness-container.ie-table-fix");

				$containerBody.removeClass("ie-table-fix");
				$Container.removeClass("ie-table-fix");
				$Container.css("width", "");
				if ($hContent.length > 0)
					isFlexBased = $hContent[0].querySelectorAll(".flex");

				if (isFlexBased && isFlexBased.length > 0 && $hContent.length > 0 && $Container.length > 0) {

					/* BUG-384507 - This is to avoid resizing in the hidden documents */
					if (!($hContent && $hContent[0] && $hContent[0].scrollWidth > 0)) {
						return;
					}

					harnessClientWidth = $hContent[0].clientWidth;
					if (isGridScroll($hContent, harnessClientWidth)) {
						harnessWidth = $hContent[0].scrollWidth;
						if (harnessWidth < 3000) {
							$Container.css("width", harnessWidth);
						} else {
							$Container.css("width", harnessClientWidth);
						}
						$Container.addClass("ie-table-fix");
						$containerBody.addClass("ie-table-fix");

						setTimeout(function() {
							if (harnessWidth < 3000) {
								$ieTable.css("width", $hContent[0].scrollWidth);
							}
						}, 10);

					} else {
						$Container.css("width", harnessClientWidth);
						$containerBody.css("width", harnessClientWidth);
						$Container.addClass("ie-table-fix");
						$containerBody.addClass("ie-table-fix");
					}
				}
			};
			if (!pega.u.d.DISABLE_FLEX_RESIZE) {
				this.harness_execute(function() {
					flexResize();

				}, true, event);
			}
			//HFIX-42824
			if (!pega.u.d.DISABLE_FLEX_RESIZE) {
				pega.u.d.registerResize(flexResize);
			}
		}

	},

	/*BUG-198290 */

	deferAsyncRequest: function(scope, args) {
		this._tmpasyncRequestQueue.push({
			scope: scope,
			args: args
		});
	},
	fireDeferredAsyncRequests: function() {
		if (!pega.offline && typeof pega.d.browserFingerprint === "undefined") {
			var _this = this;
			setTimeout(function() {
				_this.fireDeferredAsyncRequests();
			}, 0);
			return;
		}
		if (this._tmpasyncRequestQueue && this._tmpasyncRequestQueue.length > 0) {
			for (var i = 0; i < this._tmpasyncRequestQueue.length; i++) {
				var asyncReq = this._tmpasyncRequestQueue[i];
				pega.u.d.asyncRequest.apply(asyncReq.scope, asyncReq.args);
			}
			this._tmpasyncRequestQueue = new Array();
		}
	},
	/* api to return harness initialization status */
	isHarnessInitialized: function() {
		return this.harnessInitialized;
	},
    /*
    @Handler
    @protected Rollback element updates caused by popups launched from tabs.
    @return $void$
     */
	rollBackElementUpdate: function() {
		var winObj = pega.desktop.support.getDesktopWindow();
		if (winObj && winObj.document && winObj.document.getElementById('workarea')) {
			var oSafeURL = SafeURL_createFromURL(pega.u.d.url);
			oSafeURL.put("pyActivity", "pzUpdateElementModel");
			/*BUG-206143: Sending pzKeepPageMessages as true to retain the errors displayed after the request */
			oSafeURL.put("pzKeepPageMessages", "true");
			oSafeURL.put("elementAction", "ROLLBACK");

			pega.u.d.asyncRequest("GET", oSafeURL);
		}
	},

    /*
    @Handler
    @protected Initialize harness grids
    @return $void$
     */
	initializeGrids: function(event) {

		if (pega.ui.initGrids) {
			pega.ui.initGrids();
		}
	},

	initializeTimeline: function(container) {
		if (pega.ui.Timeline)
			pega.ui.Timeline.initialize(container);
	},

	initGeolocationWatch: function() {
		var pyLatitude = pega.util.Dom.getElementsById("pxRequestorPyLatitude", document.forms[0], "INPUT");
		var pyLongitude = pega.util.Dom.getElementsById("pxRequestorPyLongitude", document.forms[0], "INPUT");

		var initGeolocation = function() {
			if (navigator.geolocation && pyLatitude && pyLatitude.length == 1 && pyLongitude && pyLongitude.length == 1) {
				var options = {
					enableHighAccuracy: true,
					timeout: 5000,
					maximumAge: 0
				};
				var successCallback = function(position) {
					try {
						pega.util.Dom.getElementsById("pxRequestorPyLatitude", document.forms[0], "INPUT")[0].value = position.coords.latitude;
						pega.util.Dom.getElementsById("pxRequestorPyLongitude", document.forms[0], "INPUT")[0].value = position.coords.longitude;
					} catch (e) {}
				};
				var failureCallback = function(error) {

				};
				navigator.geolocation.watchPosition(successCallback, failureCallback, options);
			}
		};

		if (pega.mobile && pega.mobile.isHybridClient) {
			pega.mobile.hybrid.callWhenLaunchboxLoaded(initGeolocation);
		} else {
			initGeolocation();
		}
	},
    /*
    @Handler
    @protected Initialize harness charts
    @return $void$
     */
	initializeCharts: function(event) {

		if (window.Charts) {
			Charts.initCharts();
		}
	},

    /*
    @Handler
    @protected Will send ajax request to the server when ever there is no ajax request to is in progress. This request will get all the changes from the tracker and it will evaluate client conditions.
    @return $void$
     */
	getTrackerChanges: function(event) {
		/*BUG-184419 : Added target check and if it is not window then return else perform change tracking.*/
		if (pega.u.d.isAjaxInProgress() || pega.util.Event.getTarget(event) != window) {
			return;
		}
		var strUrlSF = SafeURL_createFromURL(pega.u.d.url);
		strUrlSF.put("pyActivity", "pzGetTrackerChanges");
		/*BUG-211107: HFix-23105, Page Error Messages are not getting displayed on the section. Adding pzKeepPageMessages to avoid the issue*/
		strUrlSF.put("pzKeepPageMessages", "true");
		pega.u.d.asyncRequest('GET', strUrlSF);
	},

	/*
  @Handler
  @protected This request will evaluate client conditions, whenever window receives a focus, and also invokes getTrackerChanges to get any tracker changes.
  @return $void$
   */
	triggerEvaluateClientConditions: function(event) {
		var changeTracker = pega.ui.ChangeTrackerMap.getTracker();
		if (changeTracker.changedPropertiesList.length > 0) {
			pega.u.d.evaluateClientConditions('TCL', null, true, true);
		}
		pega.u.d.getTrackerChanges(event);
	},

    /*
    @Handler
    @protected This is to reset hidden input for datetime dropdowns when it has invalid datetime error.
    @return $void$
     */
	/*BUG-199016*/
	resetDateTimeHidden: function() {
		var datetimeElems = pega.util.Dom.getElementsByAttribute("data-calendar", "Calendar", "input");
		if (datetimeElems) {
			for (var i = 0; i < datetimeElems.length; i++) {
				var calElem = datetimeElems[i];
				var calName = calElem.name;
				var calErrorName = calName + "Error";
				var errorDiv = document.getElementById(calErrorName);
				if (errorDiv) {
					var checkSelectHasValue = false;
					var parentSpan = calElem.parentElement;
					var datetimeSelElems = parentSpan ? parentSpan.getElementsByTagName("select") : null;
					if (datetimeSelElems && datetimeSelElems.length > 0) {
						for (var k = 0; k < datetimeSelElems.length; k++) {
							var selectElem = datetimeSelElems[k];
							if (selectElem.selectedIndex && selectElem.selectedIndex > 0) {
								checkSelectHasValue = true;
								break;
							}
						}
						if (!checkSelectHasValue && datetimeSelElems && datetimeSelElems.length > 0) {
							calElem.value = "";
						}
					}
					/* Added this else if SE- 31722 & BUG-285155*/
                    /*else if(!checkSelectHasValue && errorDiv.style.display != "none"){
                            calElem.value = ""; 
                    }*/
				}
			}
		}
	},


    /*  @Handler
        @protected Set aria label for non auto autocomplete
        @return $void$
         */
	/*HFix-9911 start*/
	setAriaLabelForAC: function(event) {
		var ACElems = pega.util.Dom.getElementsByAttribute("bAriaLabel", "true", "input");
		for (var i = 0; i < ACElems.length; i++) {
			if (ACElems[i].getAttribute("aria-label") == null || ACElems[i].getAttribute("aria-label") == "") {
				var parentTable = ACElems[i];
				var parentTdEle = "";
				while ((parentTable != null) && (parentTable.tagName != "TABLE")) {
					parentTable = parentTable.parentNode;
				}
				parentTdEle = parentTable;
				while ((parentTdEle != null) && (parentTdEle.tagName != "TD") && !(parentTdEle.tagName == "DIV" && pega.util.Dom.hasClass(parentTdEle, "field-item"))) {
					parentTdEle = parentTdEle.parentNode;
				}
				if (!parentTable || !parentTdEle) continue;
				var propRef = pega.ui.property.toReference(ACElems[i].getAttribute("name"));
				var previousTd = pega.util.Dom.getPreviousSibling(parentTdEle);
				var ariaLabelText = "";
				var labelEle = "";
				if (previousTd) {
					if (previousTd.tagName == "LABEL") {
						labelEle = previousTd;
					} else {
						labelEle = previousTd.getElementsByTagName("LABEL")[0];
					}
					if (labelEle && propRef.indexOf(labelEle.htmlFor) == -1) {
						var nextTd = pega.util.Dom.getNextSibling(parentTdEle);
						if (nextTd) {
							if (nextTd.tagName == "LABEL") {
								labelEle = nextTd;
							} else {
								labelEle = nextTd.getElementsByTagName("LABEL")[0];
							}
						}
					}

				} else {
					var nextTd = pega.util.Dom.getNextSibling(parentTdEle);
					if (nextTd) {
						if (nextTd.tagName == "LABEL") {
							labelEle = nextTd;
						} else {
							labelEle = nextTd.getElementsByTagName("LABEL")[0];
						}
					}
					if (labelEle && propRef.indexOf(labelEle.htmlFor) == -1) continue;
				}
				if (labelEle && labelEle.firstChild) {
					if (labelEle.firstChild.nodeType == 3) {
						ariaLabelText = labelEle.firstChild.nodeValue;
					} else if (labelEle.firstChild.tagName == "SPAN") {
						var spanText = labelEle.firstChild;
						ariaLabelText = spanText.innerText ? spanText.innerText : spanText.textContent;
					}

					ACElems[i].setAttribute('aria-label', ariaLabelText);
				}
                /*if(labelEle){
                    ariaLabelText += labelEle.innerText ? labelEle.innerText : labelEle.textContent;
                    ACElems[i].setAttribute('aria-label',ariaLabelText);
                }*/
			}
		}

	},
	/*HFix-9911 end*/


    /*
    @Handler
    @protected It will add listener to the window to evaluate conditions based on recent changes. Here it does only if the popup and its base window are using the same thread.
    @return $void$
     */
	getChangesInCurrentPopup: function() {
		try {
			var isOpenerFromSameDomain = !!(window.opener && window.opener.location.href);
		} catch (e) {}

		/* BUG-567585 : In multiwebview offline app, webview opened from hidden webview are treated as popup window and resistering for the focus event below which call triggerEvaluateClientConditions and makes ajax call which shouldn't happen for offline application. Returning here as this is not popup window */
		if (!isOpenerFromSameDomain || (pega && pega.offline && pega.mobile.isChildWebView && pega.mobile.isMultiWebViewOfflinePegaMobileClient)) {
			return;
		}
		/* This is to avoid adding listener in the portal window, also here we don't need to add listener if it used different thread */
		var parentWindowThreadName;
		if (window.opener && window.opener.pega && window.opener.pega.u && window.opener.pega.u.d) {
			parentWindowThreadName = window.opener.pega.u.d.getThreadName();
		}
		if (this.getThreadName() !== parentWindowThreadName) {
			return;
		}
		/* Here it is to avoid adding listener when we have DC in popup. This will avoid sending multiple request when we click on frame and out side the frame */
		if (!this.isDcExists()) {
			/* This is to avoid sending ajax request when we don't have tracker */
			if (pega.ui.ChangeTrackerMap.getTracker() != pega.ui.ChangeTrackerMap.getDummyTracker()) {
				pega.util.Event.addListener(window, "focus", pega.u.d.triggerEvaluateClientConditions);
			}
		}
	},

    /*
    @Handler
    @protected Used to initialize the Chnage Tracker

    @return threadName
     */
	initChangeTracker: function(doc) {
		if (!doc) doc = pega.ctx.dom.getContextRoot();
		var jsonDivObj;
		if (doc.getElementById) {
			jsonDivObj = doc.getElementById("AJAXCT");
		} else if (doc.hasAttribute && doc.hasAttribute("data-mdc-recordid")) {
			jsonDivObj = pega.ctx.dom.querySelector("[id='AJAXCT']");
		} else {
			jsonDivObj = doc.querySelector("[id='AJAXCT']");
		}

		if (jsonDivObj) {
			var ct = new pega.ui.ChangeTracker();

			var threadName = jsonDivObj.getAttribute("CTTHREAD");
			ct.init(jsonDivObj, threadName);
			pega.clientTools.init(ct.threadName);
			jsonDivObj.parentNode.removeChild(jsonDivObj);
		}

		return threadName;
	},

    /*
        Extract scripts fromm div.template-scripts
        Arguments: callback -> Signal scripts loaded callback
        
        Algorithm: 
            - Inside template-scripts, pick all the script tags.
            - Pick danglig script tags (first class children of pxSection, caused by moveToEnd in pega:static tag) 
        
        <div template-scripts>
            <script src="src1.js"></script>
            <script src="src2.js"></script>
            <script>                            
                function abc() {
                    
                }
            </script>
        ... 
        </div>
        
    */
	extractTemplateScripts: function(responseNode, callback) {

		var templateScripts;
		var isHCOffline = pega.u.d.ServerProxy.isHybridClient();
		if (!isHCOffline)
			templateScripts = responseNode.querySelectorAll("div[template-scripts] script, div[data-template-name='pxSection']>script[src]");
		else
			templateScripts = responseNode.querySelectorAll("div[template-scripts] script:not([src])");


		if (templateScripts.length == 0) {
			// No template scripts found, invoke callback immediately
			callback();
			return;
		}

		var scriptsLoadHandler = function() {
			scriptsLoadedCounter--;
			if (scriptsLoadedCounter == 0) {
				// Delete the template-scripts wrapper
				$("div[template-scripts]", responseNode).remove();
				//$("script[src]").remove();

				// All scripts are loaded, invoke callback
				callback();
				return;
			}
		};

		var scriptsLoadedCounter = templateScriptsLength = templateScripts.length;
		for (var i = 0; i < templateScriptsLength; i++) {
			var bInlineScript = false;

			var templateScript = templateScripts[i];
			// create new script tag
			var script = document.createElement("script");
			var src = templateScript.src;
			if (src) {
				/* BUG-294989: Inline scrips are processed below so moved onload and onerror into if block */
				script.onload = scriptsLoadHandler;
				script.onerror = scriptsLoadHandler;
				script.src = src;
			} else {
				/* SE-50169 skip process metadatatree inline script which will be aleady done in pega.ui.TemplateEngine.renderUI for ajax usecases, to avoid timing issues. */
				if (templateScript.innerHTML.indexOf("pega.ui.jittemplate.addMetadataTree") != -1) {
					scriptsLoadHandler();
					continue;
				}
				// Inline script
				script.innerHTML = templateScript.innerHTML;
				bInlineScript = true;
			}
			script.setAttribute("data-to-remove", "true");
			var head = document.getElementsByTagName("head")[0];
			head.appendChild(script);
			/* BUG-294989: Same processing for inline scripts in all browsers */
			if (bInlineScript /*&& (navigator.userAgent.indexOf("Edge") == -1 && navigator.userAgent.indexOf("rv:11.0") == -1)*/) // Edge, IE11 fire onload event even for inline scripts 
				scriptsLoadHandler();
		}
	},

	/**
	  * Added for SE-50169, Moved to here as part of BUG-548097
	  * Private API to parse the metadatatree inline script from response, load it and return the metadatatree object. 
	  */
	parseAndGetMetaDataTree: function(responseNode) {
		if (!responseNode) return;

		var responseText;

		if (typeof responseNode == "string") {
			responseText = responseNode;
		} else if (responseNode.nodeType == 1) {
			responseText = responseNode.innerHTML;
		} else {
			return;
		}

		if (!(pega.ctx.isUITemplatized) || responseText.lastIndexOf("{EndReloadCell}") != -1 || responseText.indexOf("data-template-instance-id") == -1) {
			return;
		}

		var tempDiv = document.createElement("div");
		tempDiv.innerHTML = responseText;

		var templateScripts;
		var isHCOffline = pega.u.d.ServerProxy.isHybridClient && pega.u.d.ServerProxy.isHybridClient();
		if (!isHCOffline)
			templateScripts = tempDiv.querySelectorAll("div[template-scripts] script, div[data-template-name='pxSection']>script[src]");
		else
			templateScripts = tempDiv.querySelectorAll("div[template-scripts] script:not([src])");

		for (var i = 0; i < templateScripts.length; i++) {
			var scriptEle = templateScripts[i];
			if (!scriptEle.src) {
				if (scriptEle.innerHTML.indexOf("pega.ui.jittemplate.addMetadataTree") != -1) {
					var script = document.createElement("script");
					script.innerHTML = scriptEle.innerHTML;
					script.setAttribute("data-to-remove", "true");

					var head = document.getElementsByTagName("head")[0];
					head.appendChild(script);

				}
			}
		}//for

		return pega.ui.TemplateEngine.getMetadataTree();

	},


    /*
    Prepares the environment and invokes beginRendering() for AJAX scenarios
    @return $void$
    */

	initRenderingEngine: function(respObject, callback) {

		if (!pega.ui.ClientCache)
			return;
		var responseText = respObject.responseText;
		if (responseText.indexOf("data-template-instance-id") == -1) { /* If there are not root markers then invoke callback() and return. BeginRendering needn't be invoked. */
			callback();
			return;
		}
		var documentFrag1 = document.createDocumentFragment();
		var dummydiv = document.createElement("div");
		dummydiv.innerHTML = responseText;
		documentFrag1.appendChild(dummydiv);
		// creating new tracker if tracker div present in response
		/* invokes initChangeTracker() by passing temp document fragment so that changes are merged */
		var threadName = this.initChangeTracker(documentFrag1);
		/* If the response markup is generated on a new thread then set the proper context to ClientCache API's by invoking initClientCacheTracker() */
		pega.ui.ClientCache.init(threadName);

		var metadataTree = pega.ui.ClientCache.find("D_UITemplateMeta");
		var bRootMarkersInStream = false;
		if (documentFrag1.querySelector) {
			var firstRootMarker = documentFrag1.querySelector("div[data-template-instance-id]");
			bRootMarkersInStream = firstRootMarker != null;
		} else {
			var arrOfRootMarkers = pega.util.Dom.getElementsByAttribute("data-template-instance-id", "*", "div", documentFrag1);
			bRootMarkersInStream = arrOfRootMarkers.length > 0;
		}
		if (metadataTree && bRootMarkersInStream) {

			if (pega.u.d.ServerProxy.isDestinationLocal()) {
				$(dummydiv).find('[data-only-once]').remove();
				pega.ui.template.RenderingEngine.beginRendering(
					documentFrag1,
					function(status, element) {
						callback(status, element);
						pega.ui.template.DataBinder.bindData(documentFrag1);
						//memory leak fix
						var tempUIMeta = pega.ui.ClientCache.find("D_UITemplateMeta");
						tempUIMeta.adoptJSON("{}");
					}
				);
			} else {
				pega.ui.template.RenderingEngine.beginRendering(
					documentFrag1, //Swordfish : whatever gets passed here as a document reference, needs to be sent to the databinder below*
					function(status, element) {
						callback(status, element);
						//Swordfish : This callback runs after RE.beginRendering() is completed. RE.beginRendering() function is async with setTimeout(...) calls. Therefore, need a callback to know //when it's complete. Alternative is for RE to fire a custom event to let us know that it has finished running.
						pega.ui.template.DataBinder.bindData(documentFrag1);
					});
                /* BUG-332906: This code is no longer needed -- START  
                //US-81389 : scripts are pre-loaded commented below code
                //BUG-189286: Storing and passing the current roots to the callback, so that beginRendering can be invoked on the intended roots
                var currRoots = pega.ui.ClientCache.find("D_UITemplateMeta.pyCurrentRoots").getValue();
                this.processScriptsToLoad(dummydiv, function(roots) {
                    return function(tempDiv) {
                        // Write the response string to a temp document fragment 
                        var documentFrag = document.createDocumentFragment();
                        documentFrag.appendChild(dummydiv);
                        if (tempDiv && tempDiv.getAttribute("data-script-div")) {
                            pega.u.d.gIsScriptsLoading = false;
                        }
                        // Storing the current value of pyCurrentRoots
                        // var newCurrentRoots =  pega.ui.ClientCache.find("D_UITemplateMeta")._model.pyCurrentRoots;
                        var uiMetaData = pega.ui.ClientCache.find("D_UITemplateMeta");
                        var tempUIMetaData = JSON.parse(uiMetaData.getJSON());
                        var newCurrentRoots = tempUIMetaData.pyCurrentRoots;
                        // changing it to the value on which it was supposed to run, when processScriptsToLoad was called
                        // pega.ui.ClientCache.find("D_UITemplateMeta")._model.pyCurrentRoots = roots;
                        tempUIMetaData.pyCurrentRoots = roots;
                        uiMetaData.adoptJSON(JSON.stringify(tempUIMetaData));
                        // Invoke beginRendering() writes into the document fragment 
                        pega.ui.template.RenderingEngine.beginRendering(
                            documentFrag, //Swordfish : whatever gets passed here as a document reference, needs to be sent to the databinder below*
                            function(status, element) {
                                // pega.ui.ClientCache.find("D_UITemplateMeta")._model.pyCurrentRoots = newCurrentRoots;
                                var dUIMetaData = pega.ui.ClientCache.find("D_UITemplateMeta");
                                var tempDUIMetaData = JSON.parse(dUIMetaData.getJSON());
                                tempDUIMetaData.pyCurrentRoots = newCurrentRoots;
                                dUIMetaData.adoptJSON(JSON.stringify(tempDUIMetaData));
                                callback(status, element);
                                //Swordfish : This callback runs after RE.beginRendering() is completed. RE.beginRendering() function is async with setTimeout(...) calls. Therefore, need a callback to know //when it's complete. Alternative is for RE to fire a custom event to let us know that it has finished running.
                                pega.ui.template.DataBinder.bindData(documentFrag);
                            });
                    }
                }(currRoots)); BUG-332906: This code is no longer needed -- END */
			}
		} else {
			callback();
		}
		if (documentFrag1.firstChild) {
			documentFrag1.removeChild(documentFrag1.firstChild);
		}

		documentFrag1 = null;
	},
	/* US-81389 : scripts are pre-loaded commented below code*/
    /* BUG-332906: This function is no longer needed 
    processScriptsToLoad: function(dummydiv, callback) {
        var scriptsToLoad = pega.ui.ClientCache.find("D_UITemplateMeta.pyScriptsToLoad");
        var bNoScriptsToLoad = true;
        //var dummydiv = document.createElement("div");
        //dummydiv.innerHTML = respObject.responseText;
        if (scriptsToLoad) {
            var scriptsToLoadStr = scriptsToLoad.getValue();
            //var objDOMLoader = new DOMScriptLoader();
            //pega.tools.EvalDomUtils_globals.scriptCntr = 0;
            if (scriptsToLoadStr != "") {
                //var globalsRef = pega.tools.EvalDomUtils_globals;
                //globalsRef.callbackFunction = callback;
                //globalsRef.orgDomObj = dummydiv;
                var scriptsToLoadArr = scriptsToLoadStr.split(",");
                var scriptDiv = document.createElement("div");
                for (var i = 0; i < scriptsToLoadArr.length; i++) {
                    var scriptInsId = scriptsToLoadArr[i];
                    var scriptPlaceHolder = dummydiv.querySelector("[data-only-once='" + scriptInsId + "']");
                    if (scriptPlaceHolder) {
                        var scripts = scriptPlaceHolder.getElementsByTagName("script");
                        while (scripts.length != 0) {
                            var script = scripts[0];
                            scriptDiv.appendChild(script);
                            //pega.tools.EvalDomUtils_globals.scriptCntr++;
                            //objDOMLoader.addFileToHeader(script, null, dummydiv);
                            bNoScriptsToLoad = false;
                        }
                        scriptPlaceHolder.parentNode.removeChild(scriptPlaceHolder);
                    }
                }
                if (i > 0) { // BUG-187927: Use legacy loadDOMObject to load scripts 
                    var tempDiv = document.createElement("div");
                    tempDiv.setAttribute("data-script-div", "true");
                    pega.u.d.loadDOMObject(tempDiv, scriptDiv, callback, null);
                }
            }
        }

        if (bNoScriptsToLoad) {
            callback();
        }
    },*/

    /*
    @private Attach callback that is invoked when any defer load container is loded.
    Initial implementation used to
    signal dynamic selects to to reload their content.  The called function - onloadFunction - is responsible for
    setting state for all objects on the document (ID of specific defer loaded container is not returned).
    @param $function$ onloadFunction Called when harness defer load section is loaded
    @param $boolean$  bInvokeOnReload Register function for defer load callback
    @param timeOut if 'true' then defer by 100ms otherwise defer by it's value
    @return $void$
     */

	harness_execute: function(onloadFunction, bInvokeOnReload, event, timeOut) {
		event = (event == undefined) ? window.event : event;
		if (timeOut) {
			var timeoutVal;
			if ((typeof timeOut) == 'number')
				timeoutVal = timeOut;
			else
				timeoutVal = 100;
			window.setTimeout(onloadFunction, timeoutVal);
		} else {
			onloadFunction(event);
		}
		// pass 'skipOnce' as true, so that this onloadFunction is not invoked again during processOnHarnessloads.
		pega.u.d.attachOnload(onloadFunction, bInvokeOnReload, null, true);
	},

    /*
    @Handler
    @protected Function Unload routine
    @return $void$
     */
	harnessOnUnload: function() {
		pega.ui.EventsEmitter.publishSync("onHarnessUnload");
		this.processOnUnloads();
		if (!pega.u.d.skipCleanup) {
			this.cleanUp();
		}
		delete pega.u.d.skipCleanup;
		if (window.frames.actionIFrame)
			this.cleanUp(window.frames.actionIFrame);

		// update test tooling - Immediate is needed for popup windows to complete cleanup before js exits
		// bug-349618 reduce from immediate, should no longer be active dst in pop-up windows
		//pega.ui.statetracking.setDocumentDone();
	},

	harnessOnBeforeUnload: function(event, formToSubmit) {
		if (pega.u.d.deletedDocuments) {
			pega.u.d.deletedDocuments = false;
			return;
		}
    if(document.getElementById("modalOverlay") !== undefined && document.getElementById("modalOverlay") !== null){
		var iconDiv = document.getElementById("modalOverlay").querySelector(".iconErrorDiv");
		if (pega.u.d.bModalDialogOpen && iconDiv && iconDiv.style.display !== "none") {
            doModalAction("", event);
        }
    }
		if (pega.ctx.ignoreDirty != "true" && pega.u.NavigateTopHandler && !pega.u.NavigateTopHandler.formSubmit) {
			var strDirty = pega.u.d.isFormDirty(true, false, event); /* check for dirty when browser refreshes - exclusive for noIframe DC. kumad1 */
			//BUG-156365 : Updated strDirty check to return in Safari.
			if (strDirty && strDirty != "") {
				pega.u.d.gBusyInd.hide();
				return strDirty;
			}
		}
		if (pega.u.d.skipDeleteDoumentPg) {
			delete pega.u.d.skipDeleteDoumentPg;
			return;
		}
		if (pega.u.NavigateTopHandler) {
			if (pega.u.d.bModalDialogOpen && pega.u.d.bIsFlowInModal) { /* Check for existence of modal dialog to purge its thread on F5 and browser navigation for noIframe DC. krvbs */
				var MODAL_THREAD_NAME = pega.u.d.getThreadName();
				MODAL_THREAD_NAME = MODAL_THREAD_NAME.replace("//", "/");

				if (MODAL_THREAD_NAME.indexOf('/$FlowModalProcess') === -1) {
					MODAL_THREAD_NAME = MODAL_THREAD_NAME + "/$FlowModalProcess";
				}

				if (!pega.u.d.baseThreadName) {
					pega.u.d.baseThreadName = pega.u.d.getThreadName();
				}
				pega.u.d.switchThread(pega.u.d.baseThreadName);
				var safeURL = SafeURL_createFromURL(pega.u.d.url);
				safeURL.put("pyActivity", "removeThead");
				safeURL.put("threadName", MODAL_THREAD_NAME);
				httpRequestAsynch(safeURL.toURL());
			}
		}
		if (pega.desktop.support.getDesktopWindow() && pega.desktop.support.getDesktopWindow().MWReloading == 'true') {
			return;
		}
		if (pega.u.NonBlockingAjax)
			pega.u.NonBlockingAjax.cleanPendingRequests();
		if (pega.u.d.redirectingToLoginScreen) {
			return;
		} else {
			try {
				var oWnd = pega.desktop.support.getDesktopWindow();
				if (!oWnd) {
					oWnd = window;
				}
				if (oWnd.pega.u.d.redirectingToLoginScreen) {
					return;
				}
			} catch (e) {}
		}

		var pagesToRemove = "";

		/* BUG-109795 - Added by Delta Touch*/
		var parentWindow = pega.desktop.support.getDesktopWindow();
		if (parentWindow != null && (parentWindow.logout == true || parentWindow.gLoggedOff == true)) {
			return;
		}
		/*BUG-249043: when getDesktopWindow returns null, check for window.logout, for not to send pzdeletedocumentpg request when window.logout is true*/
		if (window.logout == true) {
			delete window.logout;
			return;
		}
		if (!pega.u.d.pyDeleteDocumentPgCompleted) {
			/*Add D_UITemplateMeta page to the list of pages to be removed on harness unload*/
			pagesToRemove += (pagesToRemove == "") ? "D_UITemplateMeta" : "&" + "D_UITemplateMeta";
			/*Remove the top level pages created for grid's filter criteria*/
			if (typeof Grids != "undefined" && Grids && pega.ctx.Grid) {
				var gridsMap = Grids.getAllGrids();
				for (var i in gridsMap) {
					if (gridsMap[i].bFilterable) {
						pagesToRemove += (pagesToRemove == "") ? gridsMap[i].gridFilterPage : "&" + gridsMap[i].gridFilterPage;
					}
					/* get SummaryReport pages bound to a tree grid */
					if (gridsMap[i].bTreegrid && gridsMap[i].RDContPage) {
						/* the page to which tree grid is bound  */
						var summaryPages = gridsMap[i].RDContPage;
						/* the page populated by executing summary report in RUF  UIEngine • populateSummaryView  */
						summaryPages += "&pgRepPg" + summaryPages.substring(6);

						pagesToRemove += (pagesToRemove == "") ? summaryPages : "&" + summaryPages;
					}
				}
			}
			if (typeof Charts != 'undefined') {
				/*delete cahrt pages*/
				var chartsMap = Charts.getAllCharts();
				var chartPageToRemove = '';
				for (var i in chartsMap) {
					var obj = $(chartsMap[i]);
					chartPageToRemove = 'D_pzRuntimeChart[ChartID:"' + obj.attr('id') + '"]';
					pagesToRemove += (pagesToRemove == "") ? chartPageToRemove : "&" + chartPageToRemove;
					$(chartsMap[i]).chart('destroy');
				}
			}
			/*get and append list of to be removed pages added by components*/
			var utility = pega.u.template && pega.u.template.utility;
			if (utility) {
				for (var key in utility.pagesToRemoveMap) {
					if (key.indexOf("HID") === 0) {
						//Fixed - Pages to remove was going with comma delimeter but it shoudl go with "&" delimeter
						pagesToRemove += utility.pagesToRemoveMap[key] ? "&" + utility.pagesToRemoveMap[key].toString().replace(/,/g, "&") : "";
						utility.pagesToRemoveMap = {};
						utility.childsOfASection = {};
						break;
					}
				}
			}
            /*
            var gridNodes = document.querySelectorAll(".layout-grid-wrapper.template-component");
            for(var i=0; i<gridNodes.length; i++)
            {
                var gridNode = gridNodes[i];
                if(gridNode && gridNode.id){
                    gridNodeToRemove = 'D_pzGridMetadata[gridUniqueId:"'+gridNode.id+'"]';
                    pagesToRemove += (pagesToRemove == "") ? gridNodeToRemove : "&" + gridNodeToRemove;
                }
            }
            */
			var skipUnLoadRequest = false;
			var dcDiv = document.getElementById("workarea");
			if (dcDiv) {
				var data_multiview = dcDiv.getAttribute("data-multiview")
				if (data_multiview == "1" || data_multiview == "0") {
					skipUnLoadRequest = true;
				}
			} else if (pega.u && pega.u.NavigateTopHandler && !pega.u.d.SubmitInProgress) {
				skipUnLoadRequest = true;
			}


			//if in a pop up (window == top) don't make ajax request HFIX-5207, as IE doesn't always close the ajax properly
			var bExpressionCalculation = pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty('bExpressionCalculation');

			if ((window != top || !skipUnLoadRequest) && (document.getElementById("PEGAGADGET") || pagesToRemove != "" || bExpressionCalculation)) {
				var postData = new SafeURL();
				var oSafeURL = SafeURL_createFromURL(pega.u.d.url);
				delete oSafeURL.hashtable["pzTransactionId"];
				if (bExpressionCalculation) {
					oSafeURL.put("pyRemCtlExpProp", "true");
				}
				var hID = document.getElementById("pzHarnessID");
				if (hID) {
					oSafeURL.put("pzHarnessID", hID.value);
				}
				if (pega.u.d.GET_REQUEST_DELETEDOCUMENT) {
					pagesToRemove = pagesToRemove.substring(0, 1500); /* In order to support old browsers, the whole URL should be less than 2000 characters */
					oSafeURL.put("pyPagesToRemove", pagesToRemove);
				} else {
					postData.put("pyPagesToRemove", pagesToRemove); /* BUG-271051: Send "pyPagesToRemove" in post body to avoid long param values. */
				}
				//oSafeURL.put("pyPagesToRemove", pagesToRemove);
				oSafeURL.put("pyActivity", "pyDeleteDocumentPg");
				oSafeURL.put("pzKeepPageMessages", "true");
				var tracker = pega.ui.ChangeTrackerMap.getTracker();
				if (tracker && tracker.id) {
					oSafeURL.put("AJAXTrackID", tracker.id);
				}

				// invoke close call on a stable window, HFIX-5207, ENG-5564
				var oWnd = pega.desktop.support.getDesktopWindow();
				if (!oWnd) {
					oWnd = window;
				}
				var strURL;
        if(oWnd.gIsMultiTenantPortal && typeof pega.u.d.getAbsoluteURL == "function"){
          strURL = pega.u.d.getAbsoluteURL(oSafeURL);
        }else{
          strURL = oSafeURL.toURL();
        }
				//to avoid invalid sax parse errors,HFix-46699
				if (postData && postData.size() > 0) {
					postData = postData.toEncodedPostBody();
				} else {
					postData = null;
				}

				/* BUG-589019 : Incase of multiwebview PIMC, when the document is closed using cancel action, this method is making ajax request which shouldn't be done for offline applications. */
				if (pega.mobile.isMultiWebViewOfflinePegaMobileClient && pega.u.d.ServerProxy.isDestinationLocal()) {
					return;
				}

				if (formToSubmit) {
					var callbackForFormSubmit = function(respObject) {
						//pega.ui.statetracking.setBusy("formSubmit");
						if (pega.u.d.showLoginScreen(respObject.responseText)) {
							return;
						}
						pega.u.d.deletedDocuments = true;
						pega.u.d.disableMDCFieldSets(formToSubmit);
						formToSubmit.submit();
						pega.u.d.deletedDocuments = false;

						pega.ui.HarnessContextMgr.set("gDirtyOverride", null);
					};
					var onFailure = function(response) {
						var hcm = pega.ui.HarnessContextMap;
						if (hcm) {
							hcm.set("SubmitInProgress", false);
						}
						pega.u.d.resetBusyState();
					};
					if (pega.u.d.GET_REQUEST_DELETEDOCUMENT) {
						oWnd.pega.util.Connect.asyncRequest('GET', strURL, {
							success: callbackForFormSubmit,
							failure: onFailure
						});
					} else {
						oWnd.pega.util.Connect.asyncRequest('POST', strURL, {
							success: callbackForFormSubmit,
							failure: onFailure
						}, postData);
					}
				} else {
					var deleteDocumentPgCallback = function(respObject) {
						//pega.ui.statetracking.setBusy("formSubmit");
						if (pega.u.d.showLoginScreen(respObject.responseText)) {
							return;
						}
					};
					if (pega.u.d.GET_REQUEST_DELETEDOCUMENT) {
						oWnd.pega.util.Connect.asyncRequest('GET', strURL, {success: deleteDocumentPgCallback});
					} else {
						oWnd.pega.util.Connect.asyncRequest('POST', strURL, {success: deleteDocumentPgCallback}, postData);
					}
				}
				pega.u.d.pyDeleteDocumentPgCompleted = true;
			} else if (formToSubmit) {
				pega.ui.statetracking.setBusy("formSubmit");
				pega.u.d.deletedDocuments = true;
				pega.u.d.disableMDCFieldSets(formToSubmit);
				formToSubmit.submit();
				pega.u.d.deletedDocuments = false;

				pega.ui.HarnessContextMgr.set("gDirtyOverride", null);
			}
      else {
        if(pagesToRemove != "" && !pega.ctx.isMDC){
          var url = new SafeURL("pzPagesToRemove");
          url.put("PagesToRemove", pagesToRemove.replaceAll('&', ','));
          pega.u.d.convertToRunActivityAction(url);
          pega.u.d.asyncRequest('POST', url);
        }
      }
		} else if (formToSubmit) {
			pega.ui.statetracking.setBusy("formSubmit");
			pega.u.d.deletedDocuments = true;
			pega.u.d.disableMDCFieldSets(formToSubmit);
			formToSubmit.submit();
			pega.u.d.deletedDocuments = false;

			pega.ui.HarnessContextMgr.set("gDirtyOverride", null);
		}
		//If the portal harness is unloaded , relaese all the locks related to current requestor session
		if (pega.u.d.isPortal()) {
			if (!pega.u.NavigateTopHandler && pega.u.d.getHarnessPurpose() != "pzLiveComposer") {
				var oSafeURL = SafeURL_createFromURL(pega.u.d.url);
				oSafeURL.put("pyActivity", "pyOnbeforeWindowClose");
				oSafeURL.put("pzAuth", "guest");
				var strURL = oSafeURL.toURL();
				var oWnd = pega.desktop.support.getDesktopWindow();
				if (!oWnd) {
					oWnd = window;
				}
				oWnd.pega.util.Connect.asyncRequest('GET', strURL, null, null, true);
			}
		}
		if (!pega.u.d.dirtyCloseApproved) {
			if (pega.u.d.explorerFormIsDirty && pega.u.d.explorerFormIsDirty()) {
				if (!event)
					event = window.event;
				if (event && event.clientY < 0) {
					event.returnValue = getLocalString("pyMessageLabel", "Exiting will discard all outstanding changes", null);
				}
			}
		}
    
		// update test tooling bug-338168 - leave busy, onunload will clear
		// pega.ui.statetracking.setDocumentDone();
	},

    /* @Handler @API
     * The API to attach a function as OnLoad event listener to all IFrames. Stored in the array onFrameLoads
     * @param $function$ onFrameLoadFunction - the function pointer to be added as onLoad listener to IFrames
     */
	attachOnFrameLoads: function(onFrameLoadFunction) {
		for (var i = 0; i < pega.u.d.onFrameLoads.length; i++) {
			if (pega.u.d.onFrameLoads[i] == onFrameLoadFunction)
				return;
		}
		this.onFrameLoads.push(onFrameLoadFunction);
	},

    /*
     *  The function to process all functions in the array onFrameLoads registered as OnLoad event listener to all IFrames in the current document.
     *  'registerOnFrameLoads' attaches this function as onLoad event listener to all IFrames in the document and also to the current document incase it is inside a Frame/IFrame
     *  @param $Event$ event - the onLoad event raised on load of IFrame
     */
	processOnFrameLoads: function(event) {
		event.totalFrames = pega.u.d.totalFrames;
		for (var i = 0; i < pega.u.d.onFrameLoads.length; i++) {
			var onFrameLoadFunction = pega.u.d.onFrameLoads[i];
			onFrameLoadFunction(event);
		}
	},

    /*
     *  The function attaches the 'processOnFrameLoads' function ONLY ONCE as OnLoad event listener to all IFrames in the current document.
     *  also if the current document is itself in a frame/iframe, it attaches the 'processOnFrameLoads' function to itself
     */
	registerOnFrameLoads: function() {
		pega.u.d.totalFrames = 0
		var iFrames = document.getElementsByTagName("IFRAME");
		if (iFrames && iFrames.length > 0) {
			pega.u.d.totalFrames += iFrames.length;
			for (var i = 0; i < iFrames.length; i++) {
				if (!pega.u.d.isAddedOnLoad(iFrames[i], pega.u.d.processOnFrameLoads))
					pega.util.Event.addListener(iFrames[i], "load", pega.u.d.processOnFrameLoads);
			}
		}
		/*if current document is in a frame/iframe*/
		try {
			if (window.frameElement) {
				if (!pega.u.d.isAddedOnLoad(window.frameElement, pega.u.d.processOnFrameLoads) &&
					(parent.pega && parent.pega.u && parent.pega.u.d && !parent.pega.u.d.isAddedOnLoad(window.frameElement, parent.pega.u.d.processOnFrameLoads))) {
					pega.util.Event.addListener(window.frameElement, "load", pega.u.d.processOnFrameLoads);
					pega.u.d.totalFrames += 1;
				}
			}
		} catch (e) {}
	},

    /*
     *  checks if the function 'func' has been added to the DOM element 'elt' as load event listener by current window
     *  @param $HTMLElement$ elt - the DOM element for which onLoad listeners will be investigated
     *  @param $Event$ func - the onLoad listener to be verified being added to the DOM element 'elt'
     *  @return $boolean$ - true if 'func' is onLoad listener to 'elt', else false
     */
	isAddedOnLoad: function(elt, func) {
		if (!func)
			return false;
		if (!elt)
			elt = document;
		var listeners = null;
		listeners = pega.util.Event.getListeners(elt, "load");
		if (listeners) {
			for (var i = 0; i < listeners.length; i++) {
				if (listeners[i].fn == func) {
					return true;
				}
			}
		}
		return false;
	},

    /* @Handler @api
    Closes the current work item. If dirty checking is enabled and the form is dirty a warning prompt is displayed.
    @param $object$ event
    @param $bool$ dcCleanup
    @param $object$ dcCleanupCallback
    @return $void$
     */
	closeWork: function(event, dcCleanup, dcCleanupCallback, ignoreDirty, fromReplaceDocument) {
		if (pega.offline) {
			pega.u.d.closeDoc(event);
			return;

		}

		// BUG-328302
		// Maintaining dcCleanup, dcCleanupCallback at pega.u.d level to use them
		// when closeWork is invoked from DirtyModalDialog (Discard) case
		// for openWorkByHandle case
		if (!dcCleanup && pega.u.d.dcCleanup) {
			dcCleanup = pega.u.d.dcCleanup;
			delete pega.u.d.dcCleanup;
		}

		if (!dcCleanupCallback && pega.u.d.dcCleanupCallback) {
			dcCleanupCallback = pega.u.d.dcCleanupCallback;
			delete pega.u.d.dcCleanupCallback;
		}

		// inform test tooling
		//pega.ui.statetracking.setDocumentBusy();
		if (pega.u.MessagingManager) {
			var threadName = pega.u.d.getThreadName();
			if (pega.ctx.isMDC || (pega.ctx.bIsDCSPA && pega.u.d.isDCSPAThread(threadName))) {
				pega.u.MessagingManager.unregisterAll(window, threadName);
			}
			else {
				pega.u.MessagingManager.unregisterAll(window);
			}

		}

		var fromCloseWork = true;
		if (ignoreDirty) {

			pega.ui.HarnessContextMgr.set("gDirtyOverride", false);
		}
		if (pega.u.d.bWarnBeforeChangingWindow == true && !showDialogForWindowChange())
			return;
		event = event == undefined ? window.event : event;
		//HFIX - 4486. Invoke dirty check only when close is fired from some event.
		if (event != null) {
			pega.util.Event.stopEvent(event);
			this.setBusyState(null, "", null, event);
		}
		//BUG-124788:If this call is from replaceDocument and action is openWizard then suppress isFormDirtyCall.-- JAINB1
		if ((dcCleanup == null && dcCleanupCallback == null) || (dcCleanupCallback && dcCleanupCallback.action != "openWizard")) {
			if (pega.ctx.ignoreDirty != "true" && this.isFormDirty(true, fromCloseWork, event)) {
				this.resetBusyState();
				window.setTimeout("pega.u.d.resetBusyState()", 10);
				if (pega.u.d.focusElement && pega.u.d.focusElement.tagName)
					/*Added to support close icon for harnessViewTabs*/
					try {
						if (pega.u.d.bModalDialogOpen && pega.u.d.focusElement.tagName == "BODY") {
							//Don't blur. BUG-121318
						} else {
							pega.u.d.focusElement.blur();
							pega.u.d.focusElement = null;
						}
					} catch (e) {}

				// inform test tooling
				//pega.ui.statetracking.setDocumentDone();

				// BUG-328302
				if (fromReplaceDocument === true) {
					pega.u.d.dcCleanup = dcCleanup;
					pega.u.d.dcCleanupCallback = dcCleanupCallback;

					var cleardcCleanupProps = function() {
						delete pega.u.d.dcCleanup;
						delete pega.u.d.dcCleanupCallback
						pega.u.d.modalDialog.unsubscribe("hide", cleardcCleanupProps);
					};
					pega.u.d.modalDialog.subscribe("hide", cleardcCleanupProps);
				}

				return false;
			}
		}
    
    this.resetBusyState();
		var name = "pega_none";
		if (desktopenvironmentscript_isInDesignerDesktop()) {
			name = "Work";
		}

		/*In case closeWork is closed before onload happens ( in which case intiialize has not yet been called).*/
		if (!pega.u.d.baseThreadName)
			pega.u.d.baseThreadName = pega.u.d.getThreadName();

		this.switchThread(pega.u.d.baseThreadName);
		if (dcCleanup) {
			var isContextModified = false;
      pega.ctx.bIsCTXUnloading = true;
			var actualContext = pega.ctx;
			var tabCloseCleanup = (function() {
				if (isContextModified) {
					pega.ctxmgr.resetContext(actualContext);
				}
				pega.desktop.sendEvent('DCDocumentBeforeClose', {"docObj": pega.u.d}, "SYNC");
				this.cleanupForDC(dcCleanupCallback);

				// inform test tooling
				//pega.ui.statetracking.setDocumentDone();
			}).bind(this);
			if (pega.ui.hasAjaxContainer) {
				var acNames = pega.redux.Utils.getACNames();
				// If no ajax container document is created yet, simply return.
				if (acNames.length === 0) {
					tabCloseCleanup();
					return;
				}
				var outerHarnessCtx = pega.u.d.getOuterDocumentContext();
				if (outerHarnessCtx && typeof outerHarnessCtx == 'object') {
					pega.ctxmgr.setContext(outerHarnessCtx);
					isContextModified = true;
				}
				var oSafeURL = SafeURL_createFromURL(pega.u.d.url);
				var actionObj = {
					"closeAllDocsCallback": tabCloseCleanup,
					"pzPrimaryPageName": oSafeURL.get("pzPrimaryPageName"),
					"forceClose": true,
					"closeSynchronously": true,
					"isOuterDocClose": true
				};
				pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.CLOSEALL, actionObj));
                /*if (isContextModified) {
                    pega.ctxmgr.resetContext();
                }*/
			} else {
				tabCloseCleanup();
			}

			return true;
		}
		var oSafeURL = SafeURL_createFromURL(pega.u.d.url);
		oSafeURL.put("pyActivity", "DoClose");
		oSafeURL.put("retainLock", pega.u.d.retainLock);
		/*Bug-129889 : pzFromFrame and Transaction ID is not needed in safeURL for GET request : kumad1*/
		oSafeURL.put("pzFromFrame", "");
		oSafeURL.put("pzTransactionId", "");
		if (pega.ui.ChangeTrackerMap.getTracker().id) {
			oSafeURL.put("AJAXTrackID", pega.ui.ChangeTrackerMap.getTracker().id);
		}

		if (event != null && pega.util.Event.getTarget(event) && pega.util.Event.getTarget(event).id == "close") {
			/* BUG-78128 FIX */
			var oWnd = pega.desktop.support.getDesktopWindow();
			if (!oWnd) {
				oWnd = window;
			}
			var strURL;
      if(oWnd.gIsMultiTenantPortal && typeof pega.u.d.getAbsoluteURL == "function"){
        strURL = pega.u.d.getAbsoluteURL(oSafeURL);
      }else{
        strURL = oSafeURL.toURL();
      }
			oWnd.pega.util.Connect.asyncRequest('GET', strURL, dcCleanupCallback);
			// pega.u.d.asyncRequest('GET', oSafeURL);

			return true;
		} else {
      pega.ctx.bIsCTXUnloading = true;
			if (pega.u.d.ct_ID != null) {
				oSafeURL.put("AJAXTrackID", pega.u.d.ct_ID);
			}
			if (pega.ctx.isMDC) {
				oSafeURL.put("isMDC", true);
				oSafeURL.put("recordId", pega.ctx.recordId);
				pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.CLOSE, oSafeURL));
				pega.ui.statetracking.setPALInteraction(oSafeURL.toURL());
			} else if (pega.ui.hasAjaxContainer) {
				var oSafeURLBackup = oSafeURL.toURL();
				var actionObj = {
					"closeAllDocsCallback": function() {
						pega.desktop.sendEvent('DCDocumentBeforeClose', {"docObj": pega.u.d}, "SYNC");
						window.location.href = oSafeURLBackup;
					},
					"pzPrimaryPageName": oSafeURL.get("pzPrimaryPageName"),
					"forceClose": true,
					"isOuterDocClose": true
				};
				pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.CLOSEALL, actionObj));
				pega.ui.statetracking.setPALInteraction(oSafeURL.toURL());
			} else if (pega.mobile && pega.mobile.support && pega.mobile.support.getPMCRedux()) {
				// In case of PMC in multi-webview it's enough to just close the window.
				// Event listener registered in pzpega_pmc_close_listener will do the cleanup.
				window.close();
			} else {
				pega.desktop.sendEvent('DCDocumentBeforeClose', {"docObj": pega.u.d}, "SYNC");
				window.location.href = oSafeURL.toURL();
				pega.ui.statetracking.setNavigationBusy(oSafeURL.toURL());
			}
			return true;
		}
	},

    /* @Private -   Closes the current document.
    @param $object$ event
    @return $void$
     */

	closeDoc: function(event) {
		console.info("lifecycle: closeDoc");

		//NOTE: it is currently assumed that this is ONLY called when OFFLINE is enabled!!!!

		// Call cancel action of pega.process.engine (does cleanup on temp work item)
		pega.process.engine.cancel(
			null,
			function(result) {
				// success
				event = event == undefined ? window.event : event;
				pega.util.Event.stopEvent(event);

				// Refresh the Worklist
				pega.desktop.activateDocument("0");

				/* BUG-524557: Logic to refresh the window from which current webview is opened. */
				if (pega.mobile.isMultiWebViewOfflinePegaMobileClient) {
					var urlParams = SafeURL_createFromURL(window.location.href);
					var openerWindowName = urlParams.get("openerWindowName");
					if (openerWindowName) {
						var parentWindow = pega.mobile.support.getPortalWindow();
						parentWindow.pega.redux.PMC.windows.forEach(function(window) {
							if (openerWindowName === window.name) {
								// Not a good solution but we don't have an API to refresh harness in offline
								window.location.reload();
							}
						});
					}
				}

				if (pega.ui.hasAjaxContainer) {
					var acTargetDiv = event.target.closest("div[data-mdc-recordid]");
					if (acTargetDiv) {
						var recordId = acTargetDiv.getAttribute("data-mdc-recordid");
					}
					var threadName = "STANDARD/" + recordId;
					var tracker = pega.ui.ChangeTrackerMap.getTrackers();
					delete tracker[threadName.toUpperCase()];
				}

				if (window.opener) { //Its a popup.
					window.close();
				} else {
					if (!pega.offline) {
						// bug-269087 x-domain script references
						var window_parent_frames = null;
						try {
							window_parent_frames = window.parent.frames;
						} catch (e) {}
						if (window_parent_frames != null) {
							if (desktopenvironmentscript_isInDesignerDesktop())
								window.location.href = window_parent_frames["HOMEFRAME"].location.href;
							else
								window.location.href = window_parent_frames["SPACEFRAME"].location.href; // user desktop
						}
					}
				}


			},
			function() {
				// failure
			});

	},


    /*
    @Handler
    @protected Function onload routine
    @return $void$
     */
	harnessOnLoad: function() {

		/*Change starts - Removing show hide of busy indicator as this method now called from inside intialize */
		/*this.setBusyIndicator();*/
		/*Change ends*/

		var iframeList = document.getElementsByTagName("iframe");
		var harnessContext = pega.ui.HarnessContextMgr.getCurrentHarnessContext();
		for (var i = 0; i < iframeList.length; i++) {
			if (iframeList[i].name == "actionIFrame"
				//          && ! pega.u.d.actionIFrameReadyState) {
				&&
				typeof (iframeList[i].contentWindow.document.readyState) != "undefined" && iframeList[i].contentWindow.document.readyState != "complete") {

				this.gIsLoading = true;
				break;
			} else {
				this.gIsLoading = false;
			}
		}

		if (this.gIsLoading) {
			window.setTimeout("pega.u.d.harnessOnLoad()", this.CHECK_READYSTATE_TIMER);
		} else {
			try {
				pega.desktop.support.loadedGadget();
			} catch (e) {
				if (typeof (pega) != "undefined" && pega.u != null && pega.u.d != null && pega.u.d.gBusyInd != null)
					pega.u.d.gBusyInd.hide();

			}
		}
		var strKey = harnessContext.getProperty('strKey');
		var strPyID = harnessContext.getProperty('strPyID');
		var strPyLabel = harnessContext.getProperty('strPyLabel');
		var objEventData = new InstanceInfo(strKey, strPyID, strPyLabel);
		var strPageName = pega.ui.HarnessContextMgr.get('strPageName') || "";
		var bFromRuleForm = strPageName.match('^RH_') ? true : false;
		if (!bFromRuleForm)
			sendEvent(DesktopAddRecentWork, objEventData);

		// SpaceTitlebar Toolbar hooks - $$ need to add Back, REFRESH (MARTT)
		// Do not add hook if window is in a popup
		if (desktopenvironmentscript_isWindowTheDesignerDesktop(top)) {
			attachIntercept("PRINT", pega.u.d.interceptPrint);
		}

		/*Progress Bar fix for IE 8 and below, Remove once IE 8 is no longer supported */
		if (pega.env.ua.ie && pega.env.ua.ie < 9) {
			var pegaDesktop = pega.desktop.support.getDesktopWindow();
			if (pegaDesktop != null) {
				/* fix for BUG-87123 DOCTYPE: Script error on loading PMF harness starts */
				var iframeElem = pegaDesktop.document.createElement("iframe");

				iframeElem.setAttribute("id", "garbageFrame");
				iframeElem.style.display = "none";
				iframeElem.style.width = 0;
				iframeElem.style.height = 0;
				pegaDesktop.document.body.appendChild(iframeElem);
				var garbageFrame = pegaDesktop.document.getElementById("garbageFrame");
				if (garbageFrame && garbageFrame.document)
					garbageFrame.document.close();
				pegaDesktop.document.body.removeChild(iframeElem);

			}
		}
		/* End Progress Bar fix for IE 8 */

		/*Change starts - Removing show hide of busy indicator as this method now called from inside intialize */
		/* pega.u.d.gBusyInd.hide(); */
		/*Change ends*/
		if (document.compatMode !== 'CSS1Compat' && navigator.userAgent.indexOf("MSIE") != -1) {
			setTimeout(function() {
				document.body.className = document.body.className;
			}, 1000); /*BUG-113688: Reflow is required in case browser is running in Quirks mode.*/
		}


		// register harness context switching
		pega.ctxmgr.registerContextSwitching(document.body, pega.ctxmgr.harnessContextSwitchHandler);

	},

    /* @Handler @api
    nullifies any global reference
     */
	cleanUp: function(oWindow) {
		try {
			if (!oWindow)
				oWindow = window;

			/* clean up grids */
			try {
				if (Grids && pega.ctx.Grid) {
					Grids.deleteAllGridObjects();
				}
			} catch (exp) {

			}

			if (pega.ui.Timeline) { /* TASK-565789: Clean all timelines. */
				pega.ui.Timeline.destroyAllTimelines();
			}

			if (oWindow.pega.u.d.gBusyInd != null)
				oWindow.pega.u.d.gBusyInd.nullify();
			oWindow.pega.u.d.gBusyInd = null;
			oWindow.pega.u.d.myDesktop = null;
			oWindow.pega.u.d.onloads = null;
			oWindow.pega.u.d.onUnloads = null;
			oWindow.pega.u.d.initialOnloads = null;
			oWindow.pega.u.d.CHECK_READYSTATE_TIMER = null;
			oWindow.pega.u.d.CHECK_DONERENDER_TIMER = null;
			oWindow.pega.u.d.gIsLoadingCounter = null;
			oWindow.pega.u.d.gIsLoading = null;
			oWindow.pega.u.d.gCurrTotalHeight = null;
			oWindow.pega.u.d.gDoGadgetResize = null;
			oWindow.pega.u.d.gSmartInfoPopUpHarness = null;
			oWindow.pega.ui.HarnessContextMgr.set("gDirtyOverride", null);
			oWindow.pega.u.d.onSubmits = null;
			oWindow.pega.u.d.contextObjects = null;
			oWindow.pega.u.d.bModalRendered = null;
			oWindow.pega.u.d.usesModalTemplate = null;
			oWindow.pega.u.d.gSubmitIdx = null;
			oWindow.pega.u.d.tabViewIndex = null;
			oWindow.pega.u.d.editorIndex = null;
			oWindow.pega.u.d.bFocused = null;
			oWindow.pega.u.d.focusElement = null;
			oWindow.pega.u.d.tabsLen = null;
			oWindow.pega.u.d.AccLen = null;
			oWindow.pega.u.d.harnessElements = null;
			oWindow.pega.u.d.resizeFunctions = null;
			oWindow.pega.u.d.gIsScriptsLoading = null;
			oWindow.pega.u.d.topGutter = null;
			oWindow.pega.u.d.leftGutter = null;
			oWindow.pega.u.d.rightGutter = null;
			oWindow.pega.u.d.bottomGutter = null;
			oWindow.pega.u.d.modalDialog = null;
			oWindow.pega.u.d.ClientEventAPI = null;
			oWindow.pega.u.d.ServerEventAPI = null;
			oWindow.pega.u.d.modalCallback = null;
			oWindow.pega.u.d.panelAccorHeight = null;
			oWindow.pega.u.d.fieldValuesList = null;
			oWindow.pega.u.d.autoCompList = null;
			oWindow.pega.u.d.onFrameLoads = null;
			oWindow.pega.u.d.ServerProxy = null;
			oWindow.pega.ui.TabView.activeTabView = null;
			oWindow.pega.c.actionSequencer = null;
			oWindow.pega.c = null;
			oWindow.pega.control = null;

			if (oWindow.pega.u.d.harnessElements) {
				for (var c = 0; c < pega.u.d.harnessElements.length; c++) {
					pega.u.d.harnessElements[c] = null;
				}
				oWindow.pega.u.d.harnessElements = null;
			}

			if (oWindow.pega.u.d.ajaxParams && oWindow.pega.u.d.ajaxParams.callback) {
				oWindow.pega.u.d.ajaxParams.callback.success = null;
				oWindow.pega.u.d.ajaxParams.callback.failure = null;
				oWindow.pega.u.d.ajaxParams.callback.upload = null;
				oWindow.pega.u.d.ajaxParams.callback = null;
			}
			oWindow.pega.u.d.ajaxParams = null;
			if (oWindow.pega.u.d.AJAXStatus != null) {
				oWindow.pega.u.d.AJAXStatus.nullify();
				oWindow.pega.u.d.AJAXStatus = null;
			}

			// 05/30/2013 GUJAS1 Remove DC CT notify callback handle and other variables.
			oWindow.pega.u.d.dcctNotifyCallback = oWindow.pega.u.d.dcctNotifyTriggerPropertyList = oWindow.pega.u.d.dcctNotifyCallbackData = oWindow.pega.u.d.dcctNotifyCallbackContext = null;
		} catch (exp) {}
		try {
			if (this.portal) {
				pega.desktop.cancelEventListener("DesktopAction", this.portal.doBeforeOpen);
			}
		} catch (exp) {}

        /*try {
            pega.util.Event.removeListener(button, "click", pega.u.d.submitSection);
        } catch (exp) {}

        try {
            pega.util.Event.removeListener(oElem, "focus", pega.u.d.setFocusElement);
        } catch (exp) {}
        */
		try {
			pega.util.Event.removeListener(this.closeBtn, "click", pega.u.d.showhideErrorFloat);
		} catch (exp) {}

        /*try {
            pega.util.Event.removeListener(reloadElement, "keydown", pega.u.d.preventKeyAction);
        } catch (exp) {}
        */
		try {
			pega.util.Event.removeListener(document, "keydown", pega.u.d.hideSmartInfoHarness);
		} catch (exp) {}


		try {
			pega.util.Event.removeListener(document.getElementsByTagName("BODY")[0], "mousewheel", pega.u.d.hideSmartInfoHarness);
		} catch (exp) {}

        /*try {
            pega.util.Event.removeListener(smartInfoElements[i], "mouseover", pega.u.d.showSmartInfoHarness);
        } catch (exp) {}

        try {
            pega.util.Event.removeListener(smartInfoElements[i], "mouseout", pega.u.d.hideSmartInfoHarness);
        } catch (exp) {}

        try {
            pega.util.Event.removeListener(smartInfoElements, "mouseover", pega.u.d.showSmartInfoHarness);
        } catch (exp) {}

        try {
            pega.util.Event.removeListener(smartInfoElements, "mouseout", pega.u.d.hideSmartInfoHarness);
        } catch (exp) {}*/


		try {
			pega.util.Event.removeListener(window, "load", pega.u.d.initialize);
		} catch (exp) {}


		try {
			pega.util.Event.removeListener(window.frameElement, "load", pega.u.d.processOnFrameLoads);
		} catch (exp) {}

        /*try {
            pega.util.Event.removeListener(iFrames[i], "load", pega.u.d.processOnFrameLoads);
        } catch (exp) {}*/

		try {
			// Clear out the jQuery element cache in the current window and the desktop window if needed
			oWindow.pega.u.d.purgeJQuery();
			// causes mouse events to fail
			//if (oWindow !== pega.desktop.support.getDesktopWindow()) {
			//    pega.desktop.support.getDesktopWindow().pega.u.d.purgeJQuery();
			//}
		} catch (exp) {}

		try {
			pega.util.Event.removeListener(this.closeBtn, "click", pega.u.d.showhideErrorFloat);

		} catch (exp) {}
		try {
			oWindow.jQuery(oWindow).off();
			oWindow.jQuery = null;
			oWindow.OldJQuery = null;
			oWindow.Handlebars = null;
			oWindow._ = null;
			oWindow.ajaxengine = null;
			oWindow.docLifecycle = null;
			oWindow.tabSupport = null;
			oWindow.busyIndicator = null;
		} catch (exp) {}

		try {
			if (oWindow.pega.ui.menubar) {
				oWindow.pega.ui.menubar.trNode = null;
				oWindow.pega.ui.menubar.tableNode = null;
				oWindow.pega.ui.menubar.tbodyNode = null;
				oWindow.pega.ui.menubar.tdNode = null;
				oWindow.pega.ui.menubar.spanNode = null;
				oWindow.pega.ui.menubar.divNode = null;
				oWindow.pega.ui.menubar.aNode = null;
				oWindow.pega.ui.menubar.eventNode = null;
			}

			if (oWindow.pega.tools && oWindow.pega.tools.EvalDomUtils_globals) {
				oWindow.pega.tools.EvalDomUtils_globals.objDocFragElemDOM = null;
				oWindow.pega.tools.EvalDomUtils_globals.objDocFragDOM = null;
				oWindow.pega.tools.EvalDomUtils_globals.orgDomObj = null;
			}

			if (pega.u.d.tabViewMap) {
				pega.u.d.tabViewMap = null;
			}
		} catch (exp) {}
	},

    /*
    @api
    This function is used to clear the jQuery cache of elements 
    */
	purgeJQuery: function() {
		for (var x in jQuery.cache) {
			jQuery.cache[x] = null;
			delete jQuery.cache[x];
		}
	},

    /*
    @api
    This function will close all closeable dynamic container documents - in both tabbed and tabless modes
    @param $Object$event – Javascript event object that triggered this call
    @return $void$
     */
	closeAllDocuments: function(event) {
		var oSafeURL = new SafeURL();
		oSafeURL.put('api', 'CloseAllDocuments');
		oSafeURL.put('event', event);
		pega.desktop.sendEvent('DesktopAction', oSafeURL, 'SYNC');
	},

    /* @api
    Register the function which are needed to call whenever the harness is resized.
    @param $Object$resizeFunction - Function which should be called whenever the harness is resized.
    
    */
	registerResize: function(resizeFunction) {
		var resizeFunsLength = pega.u.d.resizeFunctions.length;
		for (var i = 0; i < resizeFunsLength; i++) {
			if (pega.u.d.resizeFunctions[i] == resizeFunction)
				return;
		}
		pega.u.d.resizeFunctions.push(resizeFunction);
	},


    /* @api
    Unregisters the function which was needed to be called whenever the harness is resized.
    @param $Object$resizeFunction - Function which used to be called whenever the harness is resized.
    */
	unregisterResize: function(resizeFunction) {
		var resizeFunsLength = pega.u.d.resizeFunctions.length;
		for (var i = 0; i < resizeFunsLength; i++) {
			if (pega.u.d.resizeFunctions[i] == resizeFunction) {
				pega.u.d.resizeFunctions.splice(i, 1);
				return;
			}
		}
	},

    /**
    * This method is used to create associate requestor DC tab data model in main requestor.
    */
	createDataModelInMainReq: function() {

		var ARDataModel = document.getElementById("associateRequestorDataModel");
		if (ARDataModel) {
			pega.ctx.isAssociateReqThread = true;
			var ARDataModelJSON = JSON.parse(ARDataModel.textContent);
			var winObj = pega.desktop.support.getDesktopWindow();
			if (!winObj) {
				winObj = window;
			}
			var oSafeURL = SafeURL_createFromURL(winObj.pega.ctx.url);
			oSafeURL.put("pyActivity", "pzUpdateAssociateReqModel");

			var paramsToRemove = ["pyActivity", "AJAXTrackID", "PRXML", "pzTransactionId", "shouldCreateAssociateRequestor"];
			for (var i = 0; i < paramsToRemove.length; ++i) {
				delete ARDataModelJSON[paramsToRemove[i]];
			}
			var postData = new SafeURL();
			for (var param in ARDataModelJSON) {
				postData.put(param, ARDataModelJSON[param]);
			}
			winObj.pega.u.d.asyncRequest("POST", oSafeURL, undefined, postData.toEncodedPostBody());
			ARDataModel.parentNode.removeChild(ARDataModel);
		}
	},

  /**
  ** toURL returns relative URL. getAbsoluteURL similar to toURL but returns absolute URL 
  **/
  getAbsoluteURL: function(oSafeURL){
    var absURL;
    if (typeof oSafeURL == "object" && oSafeURL.name == "safeURL") {
      absURL = oSafeURL.toAbsoluteURL();
      if (absURL.indexOf("!" + pega.u.d.getThreadName()) == -1) {
        if(absURL.indexOf("!") > -1){
          absURL = absURL.substr(0, absURL.indexOf("!"));
        }
        absURL += "/"+ "!" + pega.u.d.getThreadName();
      }
      var delim = "?";
      var index = absURL.indexOf("?");
      if (index > -1){		
        delim = "&";  
      }
      absURL +=   delim + oSafeURL.toQueryString(false, true);
    }
    return absURL;
  },
  
  
	/* set up global variables, that would have been evaluated in clientDynamicData and clientDynamicDataBottom */
	dynamicSetUp: function() {

		var harnessContext = pega.ui.HarnessContextMgr.getCurrentHarnessContext(),
			isUITemplatized = pega.ctx.isUITemplatized,
			gStrWindowName = harnessContext.getProperty('gStrWindowName'),
			inDeveloperDesktop = harnessContext.getProperty('inDeveloperDesktop'),
			topHarness = harnessContext.getProperty('topHarness'),
			isDesignViewIframe = harnessContext.getProperty('isDesignViewIframe'),
			strPyID = harnessContext.getProperty('strPyID'),
			bFlowAction = harnessContext.getProperty('bFlowAction'),
			pyPerformThreadWindowCheck = harnessContext.getProperty('pyPerformThreadWindowCheck'),
			desktopAvailableSpacesList = harnessContext.getProperty('desktopAvailableSpacesList');

		if (typeof (gStrWindowName) != "undefined") {
			window.windowName = gStrWindowName;
		}

		if ((inDeveloperDesktop == "false") && (pyPerformThreadWindowCheck == "true") && (topHarness == "yes")) {
			window.setUpWindowName();
		}

		if (isDesignViewIframe != "true") {
			pega.util.Event.addListener(window, "beforeunload", pega.u.d.harnessOnBeforeUnload);

			if (bFlowAction != "true") {
				pega.u.d.attachOnload(pega.u.d.harnessOnLoad, false, pega.u.d);
				pega.util.Event.addListener(window, "unload", pega.u.d.harnessOnUnload, pega.u.d, true);
			}
		}

		pega.u.d.attachOnload(this.createDataModelInMainReq, false);

		if (strPyID != "") {
			var htmlEntityDecoder = document.createElement('div');
			htmlEntityDecoder.innerHTML = strPyID;
			harnessContext.setProperty("strPyID", htmlEntityDecoder.innerText || htmlEntityDecoder.textContent);
		}

		if (desktopAvailableSpacesList) {
			pega.desktop.availableSpaces = new Array();
			pega.desktop.availableSpaces = desktopAvailableSpacesList.split(",");
			// always have a trailing ",", need to remove
			pega.desktop.availableSpaces.pop();

		}

		// normalize bIsTemplateEnabled string to boolean       
		//harnessContext.setProperty('bIsTemplateEnabled', bIsTemplateEnabled == "true" ? true : "");

	}

};
pega.lang.augmentObject(pega.ui.Doc.prototype, docLifecycle);

/* call dynamic set up*/
docLifecycle.dynamicSetUp();
//static-content-hash-trigger-GCC
var domUtils = {
	firstBaseRefElement: null,

	/**
	* @getOuterHeight
	* Returns the outerHeight (including margin) of HTML Element
	* @param el HTML Element
	* @param type Type of the height which should be considered. Defaults to offsetHeight.
	**/
	getOuterHeight: function(el, type) {
		var height = el.offsetHeight;
		if (type == "scroll") {
			height = el.scrollHeight;
		}

		var style = getComputedStyle(el);
https://lu-85-hyd.eng.pega.com/prweb/app/MySample_/FFCSmrL1S7ekVFPr6Iu7VI70NiBUZstW*/!TABTHREAD3?pzTransactionId=&pzFromFrame=&pzPrimaryPageName=RH_1&pyActivity=%40baseclass.doUIAction#
		height += parseInt(style.marginTop) + parseInt(style.marginBottom);
		return height;
	},

	isDisplayNone: function() {
		return $(this).css('display') != 'none';
	},

	getSectionByName: function(sectionName, usingPage, container) {
		if (typeof (usingPage) == "undefined") {
			var usingPage = "";
		}
		var ruleKeyArray = pega.util.Dom.getElementsById("RULE_KEY", container, "div");
		if (ruleKeyArray) {
			var arrLength = ruleKeyArray.length;
			var foundIndex = -1;
			for (var index = 0; index < arrLength; index++) {
				if (ruleKeyArray[index].getAttribute("node_type") == "MAIN_RULE") {
					if (ruleKeyArray[index].parentNode && (ruleKeyArray[index].parentNode.id == "RULE_KEY")) {
						if (ruleKeyArray[index].parentNode.getAttribute("node_name") == sectionName) {
							if (this.getRelativeBaseRef(ruleKeyArray[index]) == usingPage) {
								foundIndex = index;
								break;
							}
						}
					}
					if (ruleKeyArray[index].getAttribute("node_name") == sectionName) {
						if (this.getRelativeBaseRef(ruleKeyArray[index]) == usingPage) {
							foundIndex = index;
							break;
						}
						if (foundIndex == -1) {
							foundIndex = index;
						}
					}
				}
			}
			if (foundIndex > -1) {
				return ruleKeyArray[foundIndex];
			}
		}
		return null;
	},

	getSectionsByName: function(sectionsName, container) {
		var sectionArr = [];
		var ruleKeyArray = pega.util.Dom.getElementsById("RULE_KEY", container, "div");
		if (ruleKeyArray) {
			var arrLength = ruleKeyArray.length;
			for (var index = 0; index < arrLength; index++) {
				if (ruleKeyArray[index].getAttribute("node_type") == "MAIN_RULE") {
					if (ruleKeyArray[index].getAttribute("node_name") == sectionsName) {
						sectionArr.push(ruleKeyArray[index]);
					}
				}
			}
		}
		if (sectionArr.length > 0) {
			return sectionArr;
		} else {
			return null;
		}
	},

	/*
	@protected Find Parent Named
	This function will find the parent element by climbing up the DOM and search for the given name parentName
	@param $Object$srcElement - Source Element
	@param $String$parentName - name of the parent element to be returned
	@return $Object$
	 */
	findParentNamed: function(srcElement, parentName) {
		var parent = srcElement.parentNode;
		/* Skip when you go all the way till document or reach HARNESS_CONTENT */
		while (parent && !parent.getElementById && parent.id != "HARNESS_CONTENT" && parent.id != "PEGA_HARNESS" && !parent.getAttribute("data-mdc-recordid")) {
			if (parent.getAttribute("NAME") == parentName)
				return parent;
			parent = parent.parentNode;
		}
		return null;
	},

	/*
@protected Find Parent with attribute
This function will find the parent element by climbing up the DOM and search for the given name parentName
@param $Object$srcElement - Source Element
@param $String$attrName - name of the attribute to be checked
@return $Object$
 */
	findParentWithAtrribute: function(srcElement, attrName) {
		var parent = srcElement.parentNode;
		while (parent && !parent.getElementById) {
			if (parent.getAttribute(attrName))
				return parent;
			parent = parent.parentNode;
		}
		return null;
	},

	getRelativeBaseRef: function(element) {
		if (!element) {
			element = event.srcElement;
		}
		var baseRef = (element.BASE_REF) ? element.BASE_REF : "";
		if (baseRef == "") {
			var brElement = this.findParentNamed(element, "BASE_REF");
			baseRef = (brElement) ? brElement.getAttribute("BASE_REF") : "";
		}
		return (brElement && (baseRef == "")) ? this.getRelativeBaseRef(brElement) : baseRef;
	},

	getPanelDiv: function() {
		var gadgetDiv = window.frameElement.parentNode;
		var panelDiv = gadgetDiv.parentNode;
		while (panelDiv && panelDiv != window.parent.document.body) {
			var id = panelDiv.id;
			if (id == "PEGA_LU_C" || id == "PEGA_LU_B" || id == "PEGA_LU_L" || id == "PEGA_LU_T" || id == "PEGA_LU_R") {
				return panelDiv;

			}
			panelDiv = panelDiv.parentNode;
		}
	},

	getRowAndEntryHandle: function(elementInCell) {
		var rowEntryHandle = null;
		var row = null;
		if (elementInCell) {
			var temp_gridObj;
			if (typeof (Grids) != "undefined")
				temp_gridObj = Grids.getElementsGrid(elementInCell);
			if (temp_gridObj) {
				/* elementInCell is inside a Grid */
				var target = elementInCell;
				var container;
				if (pega.util.Dom.isAncestor(temp_gridObj.leftBodyUL, target))
					container = temp_gridObj.leftBodyUL;
				else if (pega.util.Dom.isAncestor(temp_gridObj.rightBodyTbl, target))
					container = temp_gridObj.rightBodyTbl;
				if (container) {
					var cell = temp_gridObj.findCell(null, container, elementInCell);
					/*HFix-38627 : incase of expand pane tree grid, there are 2 tr elements for every row*/
					var index;
					/*BUG-355184: Reverted the changes made for BUG-335528 */
					if (cell) {
						index = temp_gridObj.getRowIndex(cell);
					}
					if (index != -1) {
						rowEntryHandle = temp_gridObj.getEntryHandle(index);
						row = temp_gridObj.getRightRow(index);
					}
				}
			}
			/* elementInCell may or may not be inside a Grid. Check for Repeating Layouts now. */
			var repeatRow = pega.u.d.getRepeatRow(elementInCell, true);
			if (row && repeatRow) {
				if (pega.util.Dom.isAncestor(row, repeatRow)) {
					row = repeatRow;
				}
			} else if (repeatRow) {
				row = repeatRow;
			}
			if (row) {
				rowEntryHandle = (row.getAttribute("hPref") || row.id);
			}
		}
		return {
			"row": row,
			"rowEntryHandle": rowEntryHandle
		};
	},

	getEnclosingSection: function(object) {
		while ((object.id != "RULE_KEY")) {

			object = object.parentNode;
			if (object.getElementById) {
				/* If reload element is not found set the reloadFail to true to set form submit*/
				return null;
			} else if ((object.id == "RULE_KEY") && ((object.getAttribute("node_type") == "MAIN_RULE") || (object.getAttribute("node_type") != "SECTION")))
				break;

		}
		if (object.getAttribute("node_type") == "SECTION")
			return this.getIncludedSection(object);
		else
			return object;

	},

	getIncludedSection: function(object) {
		var ruleKeyArray = pega.util.Dom.getElementsById("RULE_KEY", object, "div");
		if (ruleKeyArray) {
			var length = ruleKeyArray.length;
			for (var index = 0; index < length; index++) {
				if (ruleKeyArray[index].getAttribute("node_type") == "MAIN_RULE")
					return ruleKeyArray[index];
			}

		} else
			return null;

	},

	/*
	@protected Get Base Reference
	This function is used to get the base reference in order to reload the streams
	@param $Object$element
	@return $Object$
	 */

	getBaseRef: function(element, event, gridObj) {
		var baseRef = "";
		if (!element)
			element = pega.util.Event.getTarget(event);
		/*After base ref div and section main div, the main div will contain the base reference information*/
		if (element.id == "RULE_KEY" && element.getAttribute("node_type") == "MAIN_RULE" && element.getAttribute("BASE_REF"))
			baseRefElement = element;
		else {
			var gridElem = null;
			if (gridObj) {
				gridElem = gridObj.gridDiv;
			}
			var baseRefElement = this.findParentNamed(element, "BASE_REF");
			if (gridElem && pega.util.Dom.isAncestor(baseRefElement, gridElem)) {
				if (element.getAttribute("sec_baseref")) element.setAttribute("sec_baseref", "");
				return "";
			}
		}

		var firstBaseRefElement = baseRefElement;
		//BUG-340645
		if (baseRefElement == null && pega.util.Event.isIE && element.tagName) {
			var queryElement = document.querySelectorAll(element.tagName.toLowerCase() + "[name='" + element.getAttribute('name') + "']");
			if (queryElement.length == 1) {
				element = queryElement[0];
				baseRefElement = this.findParentNamed(element, "BASE_REF");
			}
		}
		/*Added to check the BaseRef element in the palce where it is called */
		if (firstBaseRefElement && firstBaseRefElement.getAttribute("FULL_BASE_REF")) {
			var fullbaseRef = firstBaseRefElement.getAttribute("FULL_BASE_REF"),
				baseRefAttr = firstBaseRefElement.getAttribute("BASE_REF");

			// if baseRefAttr is empty string, return fullBaseRef
			if (baseRefAttr && baseRefAttr.length != 0 && fullbaseRef.indexOf(baseRefAttr, fullbaseRef.length - baseRefAttr.length) !== -1) {
				firstBaseRefElement = null;
				return fullbaseRef;
			}
		}
		while (baseRefElement != null) {
			baseRef = baseRefElement.getAttribute("BASE_REF") + baseRef;
			if (baseRefElement.getAttribute("BASE_REF") != "" && baseRefElement.getAttribute("BASE_REF").indexOf(".") != 0) { // if this is a top level page do not look for more
				break;
			} else {
				baseRefElement = this.findParentNamed(baseRefElement, "BASE_REF");
			}
		}
		if (baseRef.indexOf(".") == 0) {
			baseRef = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName') + baseRef;
		}
		// BUG-134243 bug fix
		if (firstBaseRefElement && firstBaseRefElement != null) {
			var curBaseRef = firstBaseRefElement.getAttribute("FULL_BASE_REF");
			if (curBaseRef !== baseRef)
				firstBaseRefElement.setAttribute("FULL_BASE_REF", baseRef);
			//    this.firstBaseRefElement.setAttribute("FULL_BASE_REF", baseRef);
		}
		firstBaseRefElement = null;
		return baseRef;
	},

	/* This function is used to get the full template path in order to reload the streams */
	getTemplatePath: function(reloadElement) {
		var tempPath = "";
		var attrName = "data-rel-path";
		if (!reloadElement) return "";

		/* In case of Post Value, we will get reload element as control object,
			initiating reloadElement with the corresponding cell object */
		var relativePath = reloadElement.getAttribute(attrName);
		if (relativePath == null || typeof (relativePath) == "undefined") {
			reloadElement = this.findParentWithAtrribute(reloadElement, attrName);
		}

		if (reloadElement != null) {
			var reloadElementObj = reloadElement;
			if (reloadElementObj && reloadElementObj.getAttribute("FULL_TEMPLATE_PATH")) {
				var tempPath = reloadElementObj.getAttribute("FULL_TEMPLATE_PATH");
			} else {
				while (reloadElementObj != null) {
					relativePath = reloadElementObj.getAttribute(attrName);
					if (relativePath != null && typeof (relativePath) != "undefined") {
						tempPath = relativePath + tempPath;
					} else {
						tempPath = "";
						break;
					}
					reloadElementObj = this.findParentWithAtrribute(reloadElementObj, attrName);
				}

				if (tempPath != "") {
					reloadElement.setAttribute("FULL_TEMPLATE_PATH", tempPath);
				}
			}
		}
		return tempPath;
	},

	/*
	@protected This is a Helper fuction for expandIt()
	This function returns the parent table of the given element
	@param $Object$childElement - the source element to find the parent table
	@return $Object$
	 */

	findParentTable: function(childElement) {
		return this.findParentWithTagName(childElement, "TABLE");
	},

	findParentAnchor: function(childElement) {
		return this.findParentWithTagName(childElement, "A");
	},

	/*
	@protected This function returns the parent div of the given element
	@param $Object$childElement - the source element to find the parent div
	@return $Object$
	 */

	findParentDiv: function(childElement) {
		return this.findParentWithTagName(childElement, "DIV");
	},

	findParentWithTagName: function(childElement, tagName) {
		var theParent = childElement.parentNode;
		while (theParent != null) {
			if (theParent.tagName == tagName)
				return (theParent);
			else
				theParent = theParent.parentNode;
		}

		return (theParent);
	},
	/*
	Calculates the BaseRef of a ctDiv and stores the same on the div after first calculation
	returns - 'nosection' if the ctDiv is empty, without section. Else, returns the Base Reference (which can be empty if the element is on the primary page) - Autobots
	 */
	calcAndAttachSectionBaseRef: function(ctDiv, rcw) {
		var sectionBaseRef = '';
		/* rcw flag is using to find the section outside(at parent level) ctDiv dom */
		var includedSection = null;
		if (rcw) {
			includedSection = pega.u.d.getSectionDiv(ctDiv);
		} else {
			includedSection = pega.u.d.getIncludedSection(ctDiv);
		}
		if (!includedSection)
			return {
				'sectionBaseRef': 'nosection'
			};
		//BEGIN: Calculate BaseRef of the section under condition evaluation.

		//Check if baseRef was already calculated and attached to CT DIV
		var ctDiv_baseRef = ctDiv.getAttribute("sec_baseRef");
		var isInGrid = false;
		if (!ctDiv_baseRef) {
			var gridObj = null;
			if (typeof (Grids) != 'undefined') {
				gridObj = Grids.getElementsGrid(ctDiv);
			}
			if (gridObj && pega.u.d.getBaseRef(ctDiv, null, gridObj) == "") {
				isInGrid = true;
			} else {
				sectionBaseRef = pega.u.d.getBaseRef(includedSection);
			}

			/* For auto reload cell bahavior, there is no active row in grids. Henace fetching row context */
			if (rcw) {
				if (sectionBaseRef == "") { //Element might be a repeat layout
					var rowEntryHandle = pega.u.d.getRowAndEntryHandle(ctDiv).rowEntryHandle;
					if (rowEntryHandle != null && typeof (rowEntryHandle) != 'undefined') {
						sectionBaseRef = pega.u.property.toReference(rowEntryHandle);
					}
				}
				if (!sectionBaseRef) {
					sectionBaseRef = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName');
				} else if (sectionBaseRef.charAt(0) == ".") {
					sectionBaseRef = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName') + sectionBaseRef;
				}
			}

			//Attach baseRef to the section ct div
			if (!sectionBaseRef)
				ctDiv.setAttribute("sec_baseRef", "PEGA_NA");
			else
				ctDiv.setAttribute("sec_baseRef", sectionBaseRef);
			if (isInGrid)
				ctDiv.setAttribute("sec_baseRef", "");

		} else {
			if (ctDiv_baseRef == "PEGA_NA")
				sectionBaseRef = "";
			else
				sectionBaseRef = ctDiv_baseRef;
		}
		/*BUG-63803 autobots the baseRef4ConditionEval used for condition evaluation*/
		var sectionRelativeBaseRef = includedSection.getAttribute("BASE_REF");
		var baseRef4ConditionEval = sectionBaseRef
		/* BUG-119457 added condition !rcw as cascading doesn't configure with usingPage.property */
		if (sectionRelativeBaseRef && !rcw) {
			var myreg = new RegExp(sectionRelativeBaseRef + "$");
			baseRef4ConditionEval = sectionBaseRef.replace(myreg, "");
		}
		return {
			'includedSec': includedSection,
			'sectionBaseRef': sectionBaseRef,
			'baseRef4ConditionEval': baseRef4ConditionEval
		};
	},

	/*
	@protected This function returns the source index for FireFox
	@param $String$element - Element to get the source index
	 */

	getSourceIndex: function(element, reloadElement) {
		if (reloadElement == null) {
			reloadElement = document;
		}
		var allElements = reloadElement.getElementsByTagName('*');
		for (var i = 0; i < allElements.length; i++) {
			if (allElements[i] == element) {
				return i;
			}
		}
	},

	/*
	@Private - This function finds the parent Td of the element
	@param $Object$  childElement
	@return $object$
	 */

	findParentTD: function(childElement) {
		var theParent = childElement.parentNode;
		while (!theParent.getElementById) {
			if (theParent.tagName == "TD")
				return (theParent);
			else
				theParent = theParent.parentNode;
		}
		return null;
	},

	/*
	@Private - When we submit the form without entering the mandatory fields it shows the errors from error table
	@return $void$
	 */

	showErrors: function() {
		var tableElements = null;
		var errorMarkers = new Array();
		var errorTables = new Array();
		// find all error markers (id="PegaRULESErrorFlag"), and array them
		errorMarkers = pega.util.Dom.getElementsById("PegaRULESErrorFlag", document);
		var errorMarkersLength = 0;
		if (errorMarkers) {
			errorMarkersLength = errorMarkers.length;
			var shadeErrorRef = pega.u.d.shadeError;
			var expandItRef = pega.u.d.expandIt;
		}
		for (var i = 0; i < errorMarkersLength; i++) {
			var objCurrent = errorMarkers[i].parentNode;
			if (pega.u.d.fieldErrorType == "ERRORTEXT")
				shadeErrorRef(objCurrent);

			// show the parent element if it is hidden
			while (!objCurrent.getElementById) {
				if (objCurrent.style.display == "none") {
					//checking if the expand div is available which is collapsed as we need to expandit only when collapsed
					var expandDiv = pega.util.Dom.getElementsById("EXPAND-INNERDIV", objCurrent);
					if (expandDiv != null) {
						// if more than one, select the first one
						if (expandDiv.length != null)
							expandDiv = expandDiv[0];
						if (pega.util.Dom.getStyle(expandDiv, "display") == "none") {
							if (typeof expandItRef === "function") {
								expandItRef(objCurrent);
							}
						}
					}

				}
				// Get the parent of current element and make it the new current element
				objCurrent = objCurrent.parentNode;
			}
		}
		//When accessible, skip this function
		if (typeof (h_displayErrorTable) == "function") {
			return;
		}

		if (pega.u.d.formErrorType != "NONE") {
			// If there *are* errorMarkers on the page, do not show the error boxes.
			// If there are *no* errorMarkers, show the boxes only if they have content.
			if (pega.u.d.alwaysShowFormLevelErrors != "true" && errorMarkersLength > 0) {
				pega.u.d.hideErrorBox();
			} else {
				// If the elements in the error tables have content
				// (innerHTML != ""), make the error tables visible.
				try {
					var errMsgAll = pega.ctx.dom.getElementById("ERRORMESSAGES_ALL");
					if (errMsgAll != null)
						pega.u.d.displayFormErrors(errMsgAll.innerHTML);
				} catch (e) {}

			}
			if (typeof markTabErrors === 'function') {
				pega.u.d.markTabErrors();
			}
		}
	},

	hideErrorBox: function() {
		var errorTables = pega.util.Dom.getElementsById("ERRORTABLE", document);
		var errorTablesLength = 0;
		if (errorTables)
			errorTablesLength = errorTables.length;
		// make sure error tables are not visible
		if (errorTablesLength > 0) {
			for (var t = 0; t < errorTablesLength; t++) {
				pega.util.Dom.setStyle(errorTables[t], "display", "none");
			}
		}
		if (pega.u.d.formErrorType == "FLOAT") {
			var errorTableSpacers = pega.util.Dom.getElementsById("ErrorTableSpacer", document),
				errorTableSpacersLength = 0;
			if (errorTableSpacers)
				errorTableSpacersLength = errorTableSpacers.length;
			if (errorTableSpacersLength > 0) {
				for (var t = 0; t < errorTableSpacersLength; t++) {
					pega.util.Dom.setStyle(errorTableSpacers[t], "display", "none");
				}
			}

		}
	},

	/*
	@protected This function is used to display the full error text and  to shade the fields
	@return $void$
	 */
	shadeError: function(objCurrent) {
		var relInput = null;
		var relInputId = objCurrent.id.substring(0, objCurrent.id.lastIndexOf("Error"));
		var addClassRef = pega.u.d.addClass;
		var getElementsByNameRef = pega.util.Dom.getElementsByName;
		while (!objCurrent.getElementById) {
			objCurrent = objCurrent.parentNode;
			relInput = getElementsByNameRef(relInputId, objCurrent);
			if (relInput) {
				var relInputLength = relInput.length;
				for (var errInp = 0; errInp < relInputLength; errInp++) {
					if (relInput[errInp].type != "hidden") {
						// porting of hfix-6852 - special case for the textarea control
						var firstChildElem = pega.util.Dom.getFirstChild(relInput[errInp].parentNode);
						var parentElemNode = relInput[errInp].parentNode.nodeName.toLowerCase();
						if ((parentElemNode == "span" || parentElemNode == "td") &&
							(firstChildElem.className.indexOf("textAreaStyle") > -1 || firstChildElem.className.indexOf("TextAreaEC") > -1)) {
							/* case to handle the old textarea expanded control */
							if (parentElemNode != "td") {
								addClassRef(relInput[errInp].parentNode, "errorShade");
							} else {
								addClassRef(pega.util.Dom.getAncestorByTagName(relInput[errInp], "TABLE"), "errorShade");
							}
						} else {
							addClassRef(relInput[errInp], "errorShade");
						}
					}
				}
				break;
			}
		}
	},

	addClass: function(el, classname) {
		pega.util.Dom.addClass(el, classname);
	},

	removeClass: function(el, classname) {
		pega.util.Dom.removeClass(el, classname);
	},


	/*
	@public Do button Action
	@param $String$name
	@param $String$action - Action Name to be performed
	@return $void$
	 */
	doButtonAction: function(name, action) {
		for (var count = 0; count < document.getElementsByTagName("Button").length; count++) {
			if (document.getElementsByTagName("Button")[count].className == "iconClose") {
				if (action == "hide")
					document.getElementsByTagName("Button")[count].style.display = "none";
				else if (action == "show")
					document.getElementsByTagName("Button")[count].style.display = "block";
			}
		}
	},

	/*
	@Handler
	@protected This function swap CSS class names for an icon/button when it fires mouseover event.
	Requires that 'buttonClass' attribute has a valid value, and that classes have been named [name] and [name_on] for mouseout and mouseover, respectively.
	@return $void$
	 */
	doButtonMouseOver: function(event) {
		event = (event == undefined) ? window.event : event;
		var el = pega.util.Event.getTarget(event);
		try {
			el.className = el.className += "_on";
		} catch (exception) {}
	},

	/*
	@Handler
	@protected This function swap CSS class names for an icon/button when it fires mouseout event.
	@return $void$
	 */
	doButtonMouseOut: function(event) {
		event = (event == undefined) ? window.event : event;
		var el = pega.util.Event.getTarget(event);
		try {
			el.className = el.buttonClass;
		} catch (exception) {}
	},

	/*
	@protected Find Parent Named
	This function will find the parent element by climbing up the DOM and search for the 	given name parentName
	@param $Object$srcElement - Source Element
	@param $String$parentName - name of the parent element to be returned
	@return $Object$
	 */

	findParent: function(srcElement, parentid) {
		var parent = srcElement.parentNode;
		while (parent != null) {
			if (parent.id == parentid)
				return parent;
			parent = parent.parentNode;
		}
		return null;
	},

	/*
	@Private - Moves the styles from parent frame document to current document(workobject)
	@return $void$
	 */

	moveStyles: function() {
		try {
			var theDoc = parent.frames.document;
			var linkList = theDoc.getElementsByTagName("LINK");
			var headList = document.getElementsByTagName("HEAD");
			var theHead = headList.item(0);
			for (var el = 0; el < linkList.length; el++) {
				var strRef = linkList.item(el).href;
				var currentLinkList = document.getElementsByTagName("LINK");
				var currentCount = currentLinkList.length;
				var bFound = false;
				for (var curEl = 0; curEl < currentCount; curEl++) {
					if (currentLinkList.item(curEl).href == strRef) {
						bFound = true;
					}
				}

				// only move if doesn't exist
				if (!bFound) {
					// document.createStyleSheet doesn't work here

					// create a link element and add the style sheet
					var styleSheet = document.createElement("LINK");
					styleSheet.rel = "Stylesheet";
					styleSheet.type = "text/css";
					styleSheet.href = strRef;
					theHead.appendChild(styleSheet);
				}
			}
		} catch (e) {}
	},

	/*
	Searches for input and gives the id for input in the modaldialog
	@return $Object$
	 */

	getFirstInputElement: function(elementID, container) {
		if (container == undefined && (elementID == undefined || elementID == 'pyActionArea')) {
			var firstForm = document.forms[0];
			var allElements = [];
			if (!firstForm) {
				/*BUG-412118: considering all actionable elements from the harness if there are no forms*/
				var iframeBody = document.getElementsByTagName("BODY")[0];
				if (iframeBody.hasAttribute("data-harness-id")) {
					var harness = iframeBody.getElementsByClassName("screen-layout")[0];
					if (harness) {
						var mainDiv = harness.getElementsByTagName("main")[0];
						if (mainDiv)
							allElements = mainDiv.getElementsByTagName("*");
					}
				}
			}
			else {
				allElements = firstForm.getElementsByTagName("*");
			}
			/*BUG-174420(HFIX PORT): HFIX-10176: Changed to getElementsByTagName from firstForm.elements as elements attribute does not include Anchor tags*/

			var totalCount = allElements.length;
			for (var i = 0; i < totalCount; i++) {
				var firstEle = allElements[i];
				/*BUG-196529: Added condition to return the first div element (with tabindex attribute 0) when accessibility is enabled*/
				if ((firstEle != null && firstEle.type != "hidden" && firstEle.style && firstEle.style.display != "none" && firstEle.offsetHeight > 0 && firstEle.disabled != true && (firstEle.readOnly != true || firstEle.hasAttribute("data-editable"))) && (firstEle.nodeName == "INPUT" || firstEle.nodeName == "SELECT" || firstEle.nodeName == "TEXTAREA" || (firstEle.nodeName == "A" && firstEle.getAttribute("data-focusable") !== "false" ) || (pega.u && pega.u.d && pega.u.d.isAccessible && firstEle.nodeName == "DIV" && firstEle.getAttribute("tabindex") == "0")))
					if (firstEle.id != 'ActionOptions')
						return firstEle;
			}
		} else {
			elementID = (elementID == undefined) ? 'PEGA_HARNESS' : elementID;
			container = (container == undefined) ? document : container;
			var elemArray = pega.util.Dom.getElementsById(elementID, container);
			var obj = null;
			if (elemArray) {
				var elem = elemArray[0];
				if (elem) {
					obj = this.parseChildNodes(elem);
				}
			}
			if (obj == null)
				return;
			return obj;
		}

	},

	/*
	Searches for input, select and radio in modaldialog
	@return $object$
	 */

	parseChildNodes: function(obj) {
		if (obj.hasChildNodes()) {
			var collection = obj.getElementsByTagName('*');
			for (var i = 0; i < collection.length; i++) {
				var obj = collection[i];

				if (obj != null && (obj.nodeName == "INPUT" || obj.nodeName == "SELECT" || obj.nodeName == "TEXTAREA") && (obj.type != "hidden" && obj.style.display != "none"))
					return obj;
			}
		} else {
			//no children, check if nodeName is input
			if (obj.nodeName == "INPUT") {
				if (obj.type != null && obj.type == "radio" && obj.checked)
					return obj;
				else if (obj.type != null && obj.type != "radio")
					return obj;
			}
		}
	},

	getScrollObj: function(obj) {
		var obj = obj.parentNode;
		var currWindow = window;
		var top = 0;
		while (obj) {
			/*if the current object has scrollbar*/
			var overflow = '';
			overflow = window.getComputedStyle ? (window.getComputedStyle(obj, null)["overflow"] || obj.style.overflow)
				: (obj.currentStyle ? obj.currentStyle["overflow"] : obj.style.overflow || 0);

			if (obj.offsetHeight < obj.scrollHeight && overflow != 'hidden' && overflow != 'visible')
				return [obj, currWindow, top];

			obj = obj.parentNode;
			overflow = window.getComputedStyle ? (window.getComputedStyle(obj, null)["overflow"] || obj.style.overflow)
				: (obj.currentStyle ? obj.currentStyle["overflow"] : obj.style.overflow || 0);

			if (obj == currWindow.document.body) {
				try {
					if (currWindow.frameElement) {
						overflow = window.getComputedStyle ? (window.getComputedStyle(currWindow.frameElement, null)["overflow"] || currWindow.frameElement.style.overflow)
							: (currWindow.frameElement.currentStyle ? currWindow.frameElement.currentStyle["overflow"] : currWindow.frameElement.style.overflow || 0);
					}
					if (obj.offsetHeight < obj.scrollHeight && overflow != 'hidden' && overflow != 'visible') {
						/*if this frame has the scrollbar*/
						return [obj, currWindow, top];
					} else if (!currWindow.frameElement) {
						/*if this is the outermost window/frame then return;*/
						return null;
					} else {
						obj = currWindow.frameElement;
						top += getAbsoluteTop(obj);
						currWindow = currWindow.parent;
					}
				} catch (e) {
					return [currWindow.document.body, currWindow, top];
				}
			}
		}
	},

	/* @api
	Get all the input element from the harness input/select/textarea
	@return $Object$
	 */
	getInputElements: function() {
		var inputElements = new Array();
		var inputTypes = new Array("input", "select", "textarea");
		for (var i = 0; i < inputTypes.length; i++) {
			var inputElementArray = document.getElementsByTagName(inputTypes[i]);
			for (var j = 0; j < inputElementArray.length; j++) {
				if (inputElementArray[j].type != 'hidden') {
					inputElements.push(inputElementArray[j]);
				}
			}
		}
		return inputElements;
	},

	/* @api
	Get all the button/url elements from the harness
	@return $Object$
	 */

	getOtherElements: function() {
		var inputElements = new Array();
		var elementTypes = new Array("button", "a");
		for (var i = 0; i < elementTypes.length; i++) {
			var inputElementArray = document.getElementsByTagName(elementTypes[i]);
			for (var j = 0; j < inputElementArray.length; j++) {
				inputElements.push(inputElementArray[j]);
			}
		}
		return inputElements;
	},

	/* @api
	Get all the harness elements (inputs/buttons/urls/complex elements)
	@return $Object$
	 */

	getHarnessElements: function(bInput, bOther, bComplex, sectionIds) {
		var allHarnessElements = new Array();
		if (bInput)
			allHarnessElements = allHarnessElements.concat(this.getInputElements());
		if (bOther)
			allHarnessElements = allHarnessElements.concat(this.getOtherElements());
		if (bComplex) {
			if (sectionIds && sectionIds.length) {
				var harnessElement = this.harnessElements.filter(function(harElement) {
					return sectionIds.indexOf(harElement.sectionID) != -1;
				});
				allHarnessElements = allHarnessElements.concat(harnessElement);
			}
			else {
				allHarnessElements = allHarnessElements.concat(this.harnessElements);
			}
		}
		return allHarnessElements;
	},

	/* @Handler
	Gets the tag  object and returns the firstChild which is not empty.
	@param - tag object.
	@return firstChild Object.
	 */
	getFirstChildObj: function(tagObject) {
		var firstChildDiv = tagObject.firstChild;
		//if(!pega.util.Event.isIE){
		while (firstChildDiv != null) {
			if (firstChildDiv.nodeType == 3 || (firstChildDiv.tagName.toLowerCase() == "input" && firstChildDiv.type == "hidden")) {
				firstChildDiv = firstChildDiv.nextSibling;
			} else {
				break;
			}
		}
		//}
		return firstChildDiv;
	},
  
  
  formatNumberAsPerLocale : function(val){
    if(!val)
       return val;
    if(val == "")
       return val;
    var localeDecmicalSep = window.decimal_separator;
    var locale = pega.u.d.Locale.replace("_", "-");
    if(localeDecmicalSep!=="."){
      var decimalPos = val.indexOf(".");
      var numTobeForamatted="";
      var generalDecSep = ".";
      if(decimalPos >=0 ){
        var numericPart = val.substring(0, decimalPos);
        var decimalPart = val.substring(decimalPos+1);
        numericPart = numericPart.replace(/\D/g, "");
        decimalPart = decimalPart.replace(/\D/g, "");
        numTobeForamatted = numericPart+localeDecmicalSep+decimalPart;
      } else {
        numTobeForamatted = val.replace(/\D/g, "");
      }
      //return new Intl.NumberFormat(locale).format(numTobeForamatted);
      return numTobeForamatted;
    }
    return val;
  },
  
  formatNumberWithSeparators : function(value) {
  if(!value)
       return value;
    if(value == "")
       return value;
     var localeDecimalSeparator = window.decimal_separator;
     var localeNumericSep = window.numeric_separator;
     var localeDecimalIndex = value.indexOf(localeDecimalSeparator);
     var formattedValue = "";
     var isnegative = false;
     if (value.indexOf("-") >= 0) {
        isnegative = true;
      }
     if (localeDecimalIndex != -1) {
       var integerPart = value.slice(0, localeDecimalIndex);
       var decimalPart = value.slice(localeDecimalIndex + 1);
       integerPart = integerPart.replace(/\D/g, "");
       integerPart = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, localeNumericSep);
       decimalPart = decimalPart.replace(/\D/g, "");
       formattedValue = integerPart + localeDecimalSeparator + decimalPart;
     } else {
       value = value.replace(/\D/g, "");
       formattedValue = value.replace(/\B(?=(\d{3})+(?!\d))/g, localeNumericSep);
     }
    if(isnegative){
      formattedValue = "-"+formattedValue;
    }
    return formattedValue;
  },
  
  formatNumberWithOutSeparators : function(value) {
  if(!value)
       return value;
    if(value == "")
       return value;
     var localeDecimalSeparator = window.decimal_separator;
     var localeDecimalIndex = value.indexOf(localeDecimalSeparator);
     var formattedValue = "";
     var isnegative = false;
     if (value.indexOf("-") >= 0) {
        isnegative = true;
      }
     if (localeDecimalIndex != -1) {
       var integerPart = value.slice(0, localeDecimalIndex);
       var decimalPart = value.slice(localeDecimalIndex + 1);
       integerPart = integerPart.replace(/\D/g, "");
       decimalPart = decimalPart.replace(/\D/g, "");
       formattedValue = integerPart + localeDecimalSeparator + decimalPart;
     } else {
       value = value.replace(/\D/g, "");
       formattedValue = value;
     }
    if(isnegative){
      formattedValue = "-"+formattedValue;
    }
    return formattedValue;
  },
  
	/* @api
	Set the property value
	@param $String$propertyName - Property name
	@param $String$newValue - Property value
	@return $void$
	 */

	setProperty: function(propertyName, newValue, pageName, customTimezone) {
		var propertyEntryHandle = null;
		if (pageName) {
			propertyEntryHandle = pega.u.property.toHandle(propertyName, pageName);
		} else {
			propertyEntryHandle = pega.u.property.toHandle(propertyName);
		}
		var elements = pega.ctx.dom.getElementsByName(propertyEntryHandle);
		try {
			if (!elements && navigator.userAgent.toLowerCase().indexOf("outlook") != -1) {
				elements = document.getElementsByName(propertyEntryHandle);
			}
		} catch (e) {}
    
    var isduplAcNumProp = false;
    if(elements.length > 1){
      for(var ind = 0; ind < elements.length; ind++ ){
        if(elements[ind].getAttribute("data-ac-numeric-prop") && elements[ind].getAttribute("data-ac-numeric-prop") === "true" ){
          isduplAcNumProp = true;
          break;
        }
      }
    }
    if(isduplAcNumProp){
      for(var ind = 0; ind < elements.length; ind++ ){
        if(!elements[ind].getAttribute("data-ac-numeric-prop")){
          elements[ind].setAttribute("data-ac-numeric-prop", true);
        }
      }
    }
		var radioButtonElement;
		if (elements) {
			for (var i = 0; i < elements.length; i++) {
				if (elements[i].type == "complex") {
					if (elements[i].element.setProperty)
						elements[i].element.setProperty(propertyName, newValue);
					else
						elements[i].value = newValue;
					if (!pega.util.Event.isSafari) {
						pega.util.Event.fireEvent(elements[i], "onmousedown");
					} else {
						//specific to safari if you do not prevent default dropdowns open and will stop execution of code until a user clicks outside the dropdown
						var Event = document.createEvent("MouseEvents");
						Event.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
						Event.preventDefault();
						elements[i].dispatchEvent(Event);
					}
					pega.u.d.fromSetValue = true;
					if (pega.env.ua.ie) {
						pega.util.Event.fireEvent(elements[i], "onfocusin");
					} else {
						pega.util.Event.fireEvent(elements[i], "onfocus");
					}
					pega.control.actionSequencer.fireTopPriorityEvent(elements[i], "change");
					pega.util.Event.fireEvent(elements[i], "onblur");
					if (pega.env.ua.ie) {
						pega.util.Event.fireEvent(elements[i], "onfocusout");
					}
					pega.u.d.fromSetValue = false;
				} else {
					var eleType = elements[i].type;

					/*BUG-281094:if element is hidden input of checkbox ignoring the element*/
					if ($(elements[i]).siblings(".checkbox") && $(elements[i]).siblings("input[type='checkbox']").get(0) && $(elements[i]).siblings("input[type='checkbox']").get(0).getAttribute("name") == elements[i].getAttribute("name")) {
						continue;
					}
					if (eleType == "checkbox") {
						var oldValue = elements[i].checked;

						if ((oldValue && (newValue == false || newValue == 'false')) ||
							(!oldValue && (newValue == true || newValue == 'true'))) {
							pega.control.actionSequencer.fireTopPriorityEvent(elements[i], "click");
						}
						//pega.util.Event.fireEvent(elements[i], "onclick");

					} else if (eleType == "textarea" && elements[i].id.startsWith("PEGACKEDITOR")) {
						var ed = CKEDITOR.instances[elements[i].id];
						ed.setData(newValue);
						pega.control.actionSequencer.fireTopPriorityEvent(elements[i], "change");
					} else {
						if (eleType == "radio") {
							if (newValue == elements[i].value) {
								elements[i].checked = true;
								radioButtonElement = elements[i];
							} else {
								elements[i].checked = false;
							}
						} else {
							var bReadonlyFormatting = elements[i].getAttribute && elements[i].getAttribute('data-formatting') && document.activeElement != elements[i];
							if (bReadonlyFormatting) {
								if (elements[i].getAttribute('data-format-method') || elements[i].getAttribute("data-template") == "") {
									elements[i].setAttribute('data-formatting', 'yes');
									elements[i].setAttribute("data-display-value", elements[i].value);
								}
								else {
									elements[i].setAttribute('data-value', newValue);
								}
							}
							if (customTimezone) { // set value bug fix : on date time control 
								newValue = pega.u.d.CalendarUtil.convertDateTimeBtwnTimezones(newValue, customTimezone, elements[i].getAttribute("data-custom-timezone") || pega.u.d.TimeZone);
							}
              if(elements[i].getAttribute("data-ac-numeric-prop") === "true" ){
                pega.control.PlaceHolder.setValue(elements[i], this.formatNumberAsPerLocale(newValue));
              } else {
                pega.control.PlaceHolder.setValue(elements[i], newValue);
              }
							
							if (customTimezone && elements[i].type == "hidden") { // Because we use data-value in buildDate() to pick the user selected value.
								elements[i].setAttribute("data-value", newValue);
							}

							if (!pega.util.Event.isSafari) {
								pega.util.Event.fireEvent(elements[i], "onmousedown");
							} else {
								//specific to safari if you do not prevent default dropdowns open and will stop execution of code until a user clicks outside the dropdown
								var Event = document.createEvent("MouseEvents");
								Event.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
								Event.preventDefault();
								elements[i].dispatchEvent(Event);
							}
						}
						pega.u.d.fromSetValue = true;
						if (!radioButtonElement || (radioButtonElement && elements[i].checked)) {
							if (document.activeElement != elements[i]) {
								if (bReadonlyFormatting) {
									pega.util.Event.fireEvent(elements[i], "onfocus");
								} else if (pega.env.ua.ie) {
									pega.util.Event.fireEvent(elements[i], "onfocusin");
								}
							}
							if (eleType !== "radio" || radioButtonElement) {
								pega.control.actionSequencer.fireTopPriorityEvent(elements[i], "change");
							}
							if (document.activeElement != elements[i]) {
								if (bReadonlyFormatting) {
									pega.util.Event.fireEvent(elements[i], "onblur");
								} else if (pega.env.ua.ie) {
									pega.util.Event.fireEvent(elements[i], "onfocusout");
								}
							}
							pega.u.d.fromSetValue = false;
						}
					}
				}
			}
			/*if (radioButtonElement) {
				pega.control.actionSequencer.fireTopPriorityEvent(radioButtonElement, "click");
			} */
		}
	},

	/* @api
	Get the property value
	@param $String$propertyName - Property name
	@return $String$
	 */

	getProperty: function(propertyName, pageName) {
		var propertyEntryHandle = null;
		if (pageName) {
			propertyEntryHandle = pega.u.property.toHandle(propertyName, pageName);
		} else {
			propertyEntryHandle = pega.u.property.toHandle(propertyName);
		}
		/*BUG-436440 : updated pega.util.Dom.getElementsByName to pega.ctx.dom.getElementsByName as existing one was failing in MDC case*/
		var elements = pega.ctx.dom.getElementsByName(propertyEntryHandle);
		if (elements) {
			for (var i = 0; i < elements.length; i++) {
				if (elements[i].type == "complex") {
					if (elements[i].element.getProperty)
						elements[i].element.getProperty(propertyName);
					else
						return elements[i].value;
				} else {
					if (elements[i].type && elements[i].type.toUpperCase() == "TEXTAREA" && elements[i].id && elements[i].id.indexOf("PEGAEDITOR") != -1) {
						var complexElements = pega.u.d.getHarnessElements(false, false, true);
						var len = complexElements.length;
						for (var k = 0; k < len; k++) {
							var complexObject = complexElements[k];
							var ele = complexObject.element;
							if (ele && typeof ele.isRichTextEditor != undefined && ele.isRichTextEditor == true && ele.myEditor != undefined) {
								if (ele.myEditor.get('element').name == propertyEntryHandle) {
									return ele.myEditor.getEditorHTML();
								}
							}
						}
					}
					if (elements[i].name && elements[i].name == propertyEntryHandle && elements[i].type && elements[i].type.toUpperCase() == "TEXTAREA" && elements[i].id && elements[i].id.indexOf("PEGACKEDITOR") != -1) {
						if (CKEDITOR && CKEDITOR.instances[elements[i].id] && CKEDITOR.instances[elements[i].id].getData) {
							return CKEDITOR.instances[elements[i].id].getData();
						}
					}
					for (var j = 0; j < elements.length; j++) {
						var eleType = elements[j].type;
						if (eleType == "checkbox") {
							if (elements[j].checked)
								return true;
							else
								return false;
						} else if (eleType == "radio") {
							if (elements[j].checked)
								return elements[j].value;
						}
					}
					if (elements[i].type === "radio") {
						return "";
					}
					return pega.control.PlaceHolder.getValue(elements[i]);
				}
			}
		}
	},

	getDOMElementValue: function(DOMElement) {
		var elementValue = "";
		if (DOMElement.type == "checkbox") {
			elementValue = DOMElement.checked;
		} else if (DOMElement.type == "radio") {
			var inputElt = document.getElementsByName(DOMElement.name);
			/* BUG-508963 if document is referring to outer html document instead of inner iframe document, issues occur.
			   So, in that case getting the elements By Name from DOMElement.ownerDocument */
			if (inputElt && inputElt.length === 0) {
				inputElt = DOMElement.ownerDocument.getElementsByName(DOMElement.name);
			}
			for (var i = 0; i < inputElt.length; i++) {
				if (inputElt[i].checked) {
					elementValue = inputElt[i].value;
					break;
				}
			}
		}
		/*Fliped the order of value extraction for Dynamic Select - BUG-76105*/
		else if (DOMElement.tagName.toLowerCase() == "select") {
			if (DOMElement.length > 0 && DOMElement.selectedIndex != -1) {
				var elemSelected = DOMElement.options[DOMElement.selectedIndex];
				var elemValue = pega.util.Dom.getInnerText(elemSelected);
				var selValueObj = DOMElement.options[DOMElement.selectedIndex].getAttributeNode("value");
				if (selValueObj != null && selValueObj.specified)
					elemValue = elemSelected.value;
				elementValue = elemValue;
			}
			if (!elementValue && DOMElement.getAttribute("DSSource")) {

				if (!(DOMElement.selectedIndex == 0 && DOMElement.options.length > 1))
					/* BUG-76635 */
					elementValue = DOMElement.getAttribute("DSDefault");
			}
		} else {
			elementValue = pega.control.PlaceHolder.getValue(DOMElement);
		}
		return elementValue;
	},
	/*
	@api getContainerSectionElement fetch Section UniqueId from given element id which can be used for refresh section
	@param $elementId id of the element for which u want to get section id
	 */
	getContainerSectionElement: function(elementId) {
		if (elementId == null || elementId == undefined) {
			return null;
		} else {
			var elementDiv = document.getElementById(elementId);
			return pega.u.d.getSectionId(pega.u.d.getSectionDiv(elementDiv));
		}
	},

	/*
	 * returns true if current harness has panel set instead of containers;
	 * panels are implemented using YUI layout component;
	 */

	isPanelSetHarness: function() {
		return (this.harnessType && this.harnessType == "layout");
	},
	getSectionIds: function(reloadElement) {
		if (!reloadElement)
			return new Array();
		if (reloadElement.length > 0)
			reloadElement = reloadElement[0];
		var mainNodes = pega.util.Dom.getElementsByAttribute("node_type", "MAIN_RULE", "DIV", reloadElement);
		var len = mainNodes.length;
		var sectionIds = new Array();
		sectionIds.push(reloadElement.getAttribute("uniqueID"));
		for (var i = 0; i < len; i++) {
			var node = mainNodes[i];
			var uniqueId = mainNodes[i].getAttribute("uniqueID");
			if (node && node.id == "RULE_KEY" && uniqueId && uniqueId != "") {
				sectionIds.push(uniqueId);

			}
		}
		return sectionIds;

	},

	/*
	@protected Create a new window with a new DIV
	Since a Harness cannot be properly printed due to its scrollable DIV, it's content has to be put into another window to be printed.
	This function opens a new window containing the contents of the HARNESS_CONTENT div, enables it to be printed.
	@param $String$ strDiv - The ID of the enclosed DIV tag of the harness to be printed (HARNESS_CONTENT)
	@return $void$
	 */
	doPrintDiv: function(strDiv) {
		var strDivContent = null;
		var linksList = null;
		var scriptsList = null;
		var hiddenInputList = "";

		var tempScriptTagsArray = new Array();
		var tempLinkArray = new Array();
		var hiddenInputArray = new Array();

		var scriptString;
		var scriptTagsString;
		var linkString;
		var hiddenInputString;

		var startIndex;
		var stopIndex;
		var functionIndex;

		if (strDiv == null) {
			return;
		} else {
			try {

				strDivContent = document.getElementById(strDiv).innerHTML;
				linksList = document.getElementsByTagName("LINK");
				scriptsList = document.getElementsByTagName("SCRIPT");
				hiddenInputList = document.getElementsByTagName("INPUT");
			} catch (e) {
				var valueHash = new Array();
				valueHash["$(strDiv)"] = strDiv;
				alert(getLocalString("pyMessageLabel", "Function doPrintDiv($(strDiv)) Error Element $(strDiv) does not exist.", valueHash));
				return;
			}
		}

		var win = window.open('', 'thePrintWindow', 'toolbar=no,scrollbars=yes');
		var d = win.document;

		var finalHtml = '';
		d.write('<html><head>');

		for (i = 0; i < hiddenInputList.length; i++) {
			if ((hiddenInputList[i].type == "hidden") && (hiddenInputList[i].id != "EXPAND-INDICATOR")) {
				hiddenInputArray.push(hiddenInputList[i].outerHTML);
				hiddenInputString = hiddenInputArray.join(' ');
			}
		}

		d.write(hiddenInputString);

		for (var i = 0; i < linksList.length; i++) {
			tempLinkArray.push("<link href='" + linksList[i].href + "' rel='stylesheet' type='text/css'>");
			linkString = tempLinkArray.join(' ');

		}

		var len = scriptsList.length;
		for (var j = 0; j < len; j++) {
			if (scriptsList[j].src != "") {
				var head = d.getElementsByTagName("head")[0];
				var script = d.createElement('script');
				script.type = 'text/javascript';
				script.src = scriptsList[j].src;
				head.appendChild(script);
			} else {
				var head = d.getElementsByTagName("head")[0];
				var script = d.createElement('script');
				script.type = 'text/javascript';
				script.text = scriptsList[j].innerHTML;
				head.appendChild(script);
			}
		}
		d.write("<SCRIPT>var gClosePrintWindow=true; var printView=true;<\/SCRIPT>");
		d.write(linkString);
		d.write('</head>');
		finalHtml += '<body class="forPrinting" onafterprint="window.opener" onload="">';
		finalHtml += '<div style="position:absolute; width:100%; height:100%">';
		finalHtml += strDivContent;
		finalHtml += '</div>';
		finalHtml += '<div style="position:absolute; width:100%; height:100%; z-index:1000">';
		finalHtml += '</div>';
		finalHtml += '<script>';
		finalHtml += 'var arrBodyElements = document.getElementsByTagName("body");';
		finalHtml += 'if ( typeof(arrBodyElements ) != "undefined") arrBodyElements[0].onload="";';
		finalHtml += '<\/script>';
		finalHtml += "<SCRIPT src='harness_print.js' type='text/javascript'><\/script>";
		finalHtml += '</body>';
		finalHtml += '</html>';
		d.write(finalHtml);
		d.close();
	},

	/* @Handler
	Gets the BUTTON tag reference and fires ONCLICK event on that object.
	@param - this object.
	 */

	fireButtonClick: function(tableRef) {
		var allButtonsRef = tableRef.getElementsByTagName("BUTTON");
		if (allButtonsRef[0].onclick != null)
			pega.util.Event.fireEvent(allButtonsRef[0], "click");
	},

	getCoordinates: function(element) {

		var tempEl = element;
		var leftValue = 0;
		var topValue = 0;
		var modalHeaderCorrection = 0;
		while (tempEl && typeof tempEl.offsetParent != "unknown") {
			if (pega.u.d && pega.u.d.modalDialog && pega.u.d.modalDialog.body) {
				if (tempEl.id == pega.u.d.modalDialog.body.id) {
					break;
				}
				modalHeaderCorrection = tempEl.offsetTop;
			}

			var panelId = "";
			if (tempEl.offsetParent && tempEl.offsetParent.offsetParent) {
				panelId = tempEl.offsetParent.offsetParent.id;
			}
			if (panelId == "PEGA_LU_L" || panelId == "PEGA_LU_R" || panelId == "PEGA_LU_C" || panelId == "PEGA_LU_T" || panelId == "PEGA_LU_B") {
				break;
			}
			leftValue += tempEl.offsetLeft;
			topValue += tempEl.offsetTop;
			tempEl = tempEl.offsetParent;
		}
		/*Top coordinate calculated thus far has included header height too but spellchecker div is positioned according to content and not body(header+body)*/
		if (!pega.u.d.inStandardsMode) {
			topValue -= modalHeaderCorrection;
		}
		return [leftValue, topValue];
	},

	/* @public @Handler
	getReadOnlyValue() called from the Defer Load api's while setting the readonly values
	@return $String$
	 */
	getReadOnlyValue: function(event, elem) {
		var harCtxMgr = pega.ui.HarnessContextMgr;

		if ((event == undefined || !event) && (elem == undefined && !elem)) {
			event = pega.util.Event.getEvent(event);
		}

		var testElem = elem;
		while (testElem && testElem.getAttribute) {
			if (testElem.getAttribute("readonly") == 'true') {
				return "-1";
			} else if (testElem.getAttribute("readonly") == 'false') {
				return "0";
			}
			testElem = testElem.parentNode;
		}
		if (harCtxMgr.get('strHarnessMode') == "ACTION" || (document.getElementById("HarnessMode") && document.getElementById("HarnessMode").value == "ACTION")) {
			/*If in perform harness */
			var actionSec = pega.util.Dom.getElementsById("pyActionArea");
			var actionIFrame = window.frames.actionIFrame;
			/*will be non null for iframe based outer perform harness*/
			var bFlowAction = harCtxMgr.get('bActionIframe');
			/*will be true for flowactions*/
			var bIframePerfHarness = false;
			if ((actionIFrame && actionIFrame != null) || bFlowAction)
				bIframePerfHarness = true;
			if (actionSec || !bIframePerfHarness) {
				/*if the new ActionArea section is used or if it is non iframe based perfrom harness( for e.g when using flowActionSimple)*/
				if ((elem == undefined || !elem) && event) {
					elem = pega.util.Event.getTarget(event);
				}
				while (elem) {
					if (elem.id == "pyActionArea" || elem.id == "pyFlowActionHTML") {
						return "0";
					}
					elem = elem.parentNode;
				}
				return "-1";
			} else {
				/* if old action area section is used */
				return harCtxMgr.get('bReadOnly');
			}
		} else {
			/*If not in perfom harness */
			return harCtxMgr.get('bReadOnly');
		}
	},

	getGroupElementValue: function(elementArray) {
		var value = pega.u.d.getDOMElementValue(elementArray[0]); //this is default setting for non-checkbox and non-radio values
		if (elementArray.length > 1) {
			if (elementArray[1].type == "checkbox") { //identify if its a checkbox property
				value = pega.u.d.getDOMElementValue(elementArray[1]);
			}
		}
		return value;
	},

	getCaretPosition: function(elem) {
		try {
			if (elem != undefined && /^(text|textarea|number|password|email|tel|url)$/.test(elem.type)) {
				if ('selectionStart' in elem) {
					return elem.selectionStart || document.getElementsByName(elem.name)[0].selectionStart;
				} else if (document.selection) {
					var r = document.selection.createRange();
					if (r == null) {
						return 0;
					}
					if (elem.createTextRange != undefined) {
						var re,
							rc;
						try {
							re = elem.createTextRange();
						} catch (e) {
							elem = document.getElementsByName(elem.name)[0];
							re = elem.createTextRange();
						}
						rc = re.duplicate();
						re.moveToBookmark(r.getBookmark());
						rc.setEndPoint('EndToStart', re);
						return rc.text.length;
					}
				}
			}
		} catch (e) {}
		return 0;
	},

	setCaretPosition: function(elem, pos) {
		try {
			if (elem != undefined && /^(text|textarea|number|password|email|tel|url)$/.test(elem.type)) {
				if (elem.setSelectionRange) {
					elem.setSelectionRange(pos, pos);
				} else if (elem.createTextRange) {
					var range = elem.createTextRange();
					range.collapse(true);
					range.moveEnd('character', pos);
					range.moveStart('character', pos);
					range.select();
				}
			}
		} catch (e) {}
	},

	getTrackedPagePointer: function(node, pageName) {
		var metadataPage = node.getAttribute(pageName);
		var trackedPropertiesList = pega.ui.ChangeTrackerMap.getTracker().trackedPropertiesList;
		return trackedPropertiesList[metadataPage];
	},

	/* Serves as a polyfill for Object.keys */
	getObjectKeys: function(object) {
		if (!object || typeof object != "object")
			return;
		if (Object.keys) {
			return Object.keys(object);
		} else {
			var keys = [];
			for (var k in object) {
				if (object.hasOwnProperty(k)) {
					keys.push(k);
				}
			}
			return keys;
		}
	},

	registerSinglePageNav: function(elementWithAnchors, container) {
		var $container = container ? jQuery(container) : jQuery(document);

		jQuery(elementWithAnchors).find("a[href^='#']").filter(function() {
			return this.href.match(/#[a-zA-Z]/);
		}).click(function() {
			var $target = $container.find("a[id='" + this.hash.substring(1) + "']").first();
			/* BUG-248057: Fix for Firefox - hidden anchors have height overlapping with the previous element */
			$target = $target.next();

			var scrollObj = pega.u.d.getScrollObj($target.get(0));

			if (scrollObj) {
				var $scrollObj = jQuery(scrollObj[0]);
			} else {
				var $scrollObj = jQuery("body");
			}

			var toScroll = $scrollObj.scrollTop() + $target.offset().top - $scrollObj.offset().top;
			/* BUG-355813: Extending the fix done for BUG-249588 for chrome */
			if ($scrollObj.prop("tagName").toUpperCase() === "BODY" && (pega.util.Dom.hasClass(document.documentElement, "ff") || pega.util.Dom.hasClass(document.documentElement, "chrome") || pega.util.Dom.hasClass(document.documentElement, "ie"))) {
				/* BUG-249588: In Firefox and IE, body doesn't scroll, html scrolls */
				jQuery(document.documentElement).animate({scrollTop: toScroll}, 250);
			} else {
				$scrollObj.animate({scrollTop: toScroll}, 250);
			}
			return false;
		});
	},

	setRequestAnimationFrame: function(method) {
		if (window.requestAnimationFrame) {
			window.requestAnimationFrame(method);
		} else {
			setTimeout(method, 0);
		}
	},

    /*
     @protected This function checks the given element is inside a repeat layout
     return the status to the handleClientEvent() function
     @param $Object$element - The element to be checked whether inside the repeat or not
     @return $boolean$
    */

	isInRepeat: function(element) {

		var parent = element.parentNode;
		while (parent != null) {
			if (parent.getAttribute && (parent.getAttribute("PL_PROP") != null || parent.getAttribute("PG_PROP") != null)) {
				return true;
			}
			else {
				parent = parent.parentNode;
			}
		}
		return false;
	},

    /*
     @protected This function Returns the parent element associated with this element in a repeat layout
     @param $Object$element - The element inside repeat
     @param $boolean$stopAtSection- If the search should be limited to the section in which the element is present
     @return $Object$ html element 
    */
	getRepeatObject: function(element, stopAtSection) {

		var parentEle = element.parentNode;
		if (stopAtSection && ((element.getAttribute && element.getAttribute("node_type") == "MAIN_RULE") || (parentEle && parentEle.getAttribute && parentEle.getAttribute("node_type") == "MAIN_RULE"))) {
			return null;
		}
		while (parentEle && parentEle != document.body) {
			if (parentEle.getAttribute && (parentEle.getAttribute("PL_PROP") != null || parentEle.getAttribute("PG_PROP") != null)) {
				return parentEle;
			}
			else {
				parentEle = parentEle.parentNode;
				if (parentEle != null & stopAtSection && parentEle.getAttribute && parentEle.getAttribute("node_type") == "MAIN_RULE") {
					break;
				}
			}
		}
		return null;
	},

	getDocumentElement: function() {
		var doc = document;
		if (pega && pega.ui && pega.ui.HarnessContextMgr && pega.ui.HarnessContextMgr.get("isMDC")) {
			var mdcName = pega.ui.HarnessContextMgr.get("mdcName");
			var recordId = pega.ui.HarnessContextMgr.get("recordId");
			var mdcContent;
			if (recordId) {
				mdcContent = document.querySelector("div[data-mdc-id='" + mdcName + "'] div[data-mdc-recordid='" + recordId + "']");
			} else {
				mdcContent = document.querySelector("div[data-mdc-id='" + mdcName + "']");
			}
			if (mdcContent) {
				doc = mdcContent;
			}
		}
		return doc;
	},

	getFormElement: function() {
		var docForm = document.forms[0];
		if (pega && pega.ui && pega.ui.HarnessContextMgr && pega.ui.HarnessContextMgr.get("isMDC")) {
			var mdcName = pega.ui.HarnessContextMgr.get("mdcName");
			var recordId = pega.ui.HarnessContextMgr.get("recordId");
			var mdcForm;
			if (recordId) {
				mdcForm = document.querySelector("div[data-mdc-id='" + mdcName + "'] div[data-mdc-recordid='" + recordId + "'] fieldset.mdc-fieldset");
			} else {
				mdcForm = document.querySelector("div[data-mdc-id='" + mdcName + "'] fieldset.mdc-fieldset");
			}
			if (mdcForm) {
				docForm = mdcForm;
			}
		}
		return docForm;
	},

	scrollIntoViewIfOutOfView: function(el) {
		var topOfPage = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
		var heightOfPage = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
		var elY = 0;
		var elH = 0;
		if (document.layers) {
			elY = el.y;
			elH = el.height;
		} else {
			for (var p = el; p && p.tagName != 'BODY'; p = p.offsetParent) {
				elY += p.offsetTop;
			}
			elH = el.offsetHeight;
		}
		if ((topOfPage + heightOfPage) < (elY + elH)) {
			el.scrollIntoView(true);
		} else if (elY < topOfPage) {
			el.scrollIntoView(false);
		}
	},


	getMDCFieldSets: function() {
		return document.querySelectorAll("fieldset.mdc-fieldset");
	},

	getAllMDCContainers: function() {
		var mainTag = document.getElementsByTagName("main");
		var acDivList = [];
		if (mainTag && mainTag.length == 1) {
			// DC SPA scenario.
			acDivList = mainTag[0].querySelectorAll("div[data-mdc-id]");
		} else {
			acDivList = document.querySelectorAll("div[data-mdc-id]");
		}
		return acDivList;
	},

	getMicroDCDocs: function(mdcName) {
		var microDCDocs = [];
		var mdcDiv = document.querySelector("div[data-mdc-id='" + mdcName + "']");
		if (mdcDiv) {
			microDCDocs = mdcDiv.children;
		}
		return microDCDocs;
	},

	closeOnlyMDCDocs: function(event, forceClose, closeSynchronously, ignoreDirty, paramACName) {
		if (!pega.ui.hasAjaxContainer) {
			return;
		}
		var isAnyMdcDocDirty = false;
		  
    function closeOnlyMDCDocsCallback(){
			var oSafeURL = SafeURL_createFromURL(pega.u.d.url);
			if (forceClose) {
				oSafeURL.put("forceClose", forceClose);
			}
			if (closeSynchronously) {
				oSafeURL.put("closeSynchronously", closeSynchronously);
			}
			var mdcName = paramACName || pega.ctx.mdcName;
			if (event && null != event) {
				var target = pega.util.Event.getTarget(event);
				/* Open section MDC code */
				if (target) {
					var mdcTarget = target.closest("div[data-mdc-recordid]");
					if (mdcTarget && mdcTarget.getAttribute("action") === "openSection") {
						mdcName = mdcTarget.closest("div[data-mdc-id]").getAttribute("data-mdc-id");
					}
				}
			}
			if (mdcName) {
				oSafeURL.put("mdcTarget", mdcName);
			}
			// During outer document close we need to close documents in all Ajax Containers.
			oSafeURL.put("isOuterDocClose", (mdcName ? false : true));
			pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.CLOSEALL, oSafeURL));
		
		return isAnyMdcDocDirty;
    }
    if (!ignoreDirty && pega.u.d.isFormDirty(true, null, null, true, closeOnlyMDCDocsCallback)) {
			isAnyMdcDocDirty = pega.u.d.isFormDirty(true, null, null, true, closeOnlyMDCDocsCallback);
		}else{
      closeOnlyMDCDocsCallback();
    }
	},

	getOuterDocumentContext: function() {
		var harnessContextmap = pega.ctxmgr.getHarnessContextMap();
		for (var key in harnessContextmap) {
			if (harnessContextmap.hasOwnProperty(key)) {
				var currentHarnessctx = harnessContextmap[key];
				if (!currentHarnessctx.isMDC && !currentHarnessctx.isStatic) {
					return currentHarnessctx;
				}
			}
		}
		return null;
	},

	getScrollParent: function(node) {
		if (!node)
			return null;

		if (node.scrollHeight > node.clientHeight) {
			return node;
		} else {
			return this.getScrollParent(node.parentNode);
		}
	},
	filterRichText: function(strVal) {
		return strVal;
	},
	extendObj: function(out) {
		/* recursive deep copy
		   usage: jQuery.extend(true, {}, sectionStore); --> pega.u.d.extendObj({}, sectionStore);
		*/
		out = out || {};

		for (var i = 1; i < arguments.length; i++) {
			var obj = arguments[i];

			if (!obj)
				continue;

			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					if (typeof obj[key] === 'object') {
						if (Array.isArray(obj[key]) && !out[key]) {
							out[key] = this.extendObj([], obj[key]);
						}
						else {
							out[key] = this.extendObj(out[key], obj[key]);
						}
					} else {
						out[key] = obj[key];
					}
				}
			}
		}

		return out;
	},
	deepExtendObj: function(out) {
        /* recursive deep copy
           usage: jQuery.extend(true, {}, sectionStore); --> pega.u.d.deepExtendObj({}, sectionStore);
           deepExtendObj API does not work in case object is HTML element. 
        */
		out = out || {};

		for (var i = 1; i < arguments.length; i++) {
			var obj = arguments[i];

			if (!obj)
				continue;

			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					// BUG-554390 : Fixed merging arrays properly 
					if (obj[key] && typeof obj[key] === 'object' && (obj[key].constructor === Object || obj[key].constructor === Array)) {  /*in case HTML element do not call deepExtendObj again as hasOwnProperty() fails */
						out[key] = this.deepExtendObj(out[key], obj[key]);
					} else {
						out[key] = obj[key];
					}
				}
			}
		}
		return out;
	}
};

pega.lang.augmentObject(pega.ui.Doc.prototype, domUtils);
//static-content-hash-trigger-GCC
/*
Extract deferred vars/evals here, when called through a chain of functions
starting with "deferredFieldValues()"
*/

function deferredAdditionalDynamic() {
	processDynamicData(deferredVars);

	/*
		TASK-906101 : In multiwebview PIMC, harness context is packaged with STANDARD thread for all the harnesses. But for Parent WebView (Portal WEbView/ Hidden WebView) it should be STANDARD in the url but for other harnesses which are launched in the child webview it should be STANDARD/ACPRIMARY_0 etc. As during packaging we cannot set the url so setting it here properly.
	   typeof pmcPortalConfiguration === "undefined" for children webview. pmcPortalConfiguration will be loaded only in hidden webview.
	*/
  /* BUG-567585: Setting pega.ctx.url with proper value. It holds on pathname rather than location href. pega.ctx.url should be set here as this function will be called when the new webview is loaded. */
  // Eg: /prweb/PRAuth/app/MySample/FFCSmrL1S7cAhlCpbFMhAA*/!STANDARD/ACPRIMARY_12
  
	if (pega && pega.offline && pega.mobile.isChildWebView && pega.mobile.isMultiWebViewOfflinePegaMobileClient) {
		pega.ctx.url = window.location.pathname;
	}
}

/* This function is defined in pzHarnessInlineScripts, but must be executed in pzHarnessStaticScripts. */
deferredFieldValues();

//static-content-hash-trigger-GCC
/*
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.5.2
Bug-3440 : Updated "Center()" API to calculate TOP style property appropiately. Retain this API when upgrading to next higher version.
BUG-44845 : Code marked with bug id

*/
(function () {

    /**
    * Config is a utility used within an Object to allow the implementer to
    * maintain a list of local configuration properties and listen for changes 
    * to those properties dynamically using CustomEvent. The initial values are 
    * also maintained so that the configuration can be reset at any given point 
    * to its initial state.
    * @namespace pega.util
    * @class Config
    * @constructor
    * @param {Object} owner The owner Object to which this Config Object belongs
    */
    pega.util.Config = function (owner) {

        if (owner) {
            this.init(owner);
        }


    };


    var Lang = pega.lang,
        CustomEvent = pega.util.CustomEvent,
        Config = pega.util.Config;


    /**
     * Constant representing the CustomEvent type for the config changed event.
     * @property pega.util.Config.CONFIG_CHANGED_EVENT
     * @private
     * @static
     * @final
     */
    Config.CONFIG_CHANGED_EVENT = "configChanged";
    
    /**
     * Constant representing the boolean type string
     * @property pega.util.Config.BOOLEAN_TYPE
     * @private
     * @static
     * @final
     */
    Config.BOOLEAN_TYPE = "boolean";
    
    Config.prototype = {
     
        /**
        * Object reference to the owner of this Config Object
        * @property owner
        * @type Object
        */
        owner: null,
        
        /**
        * Boolean flag that specifies whether a queue is currently 
        * being executed
        * @property queueInProgress
        * @type Boolean
        */
        queueInProgress: false,
        
        /**
        * Maintains the local collection of configuration property objects and 
        * their specified values
        * @property config
        * @private
        * @type Object
        */ 
        config: null,
        
        /**
        * Maintains the local collection of configuration property objects as 
        * they were initially applied.
        * This object is used when resetting a property.
        * @property initialConfig
        * @private
        * @type Object
        */ 
        initialConfig: null,
        
        /**
        * Maintains the local, normalized CustomEvent queue
        * @property eventQueue
        * @private
        * @type Object
        */ 
        eventQueue: null,
        
        /**
        * Custom Event, notifying subscribers when Config properties are set 
        * (setProperty is called without the silent flag
        * @event configChangedEvent
        */
        configChangedEvent: null,
    
        /**
        * Initializes the configuration Object and all of its local members.
        * @method init
        * @param {Object} owner The owner Object to which this Config 
        * Object belongs
        */
        init: function (owner) {
    
            this.owner = owner;
    
            this.configChangedEvent = 
                this.createEvent(Config.CONFIG_CHANGED_EVENT);
    
            this.configChangedEvent.signature = CustomEvent.LIST;
            this.queueInProgress = false;
            this.config = {};
            this.initialConfig = {};
            this.eventQueue = [];
        
        },
        
        /**
        * Validates that the value passed in is a Boolean.
        * @method checkBoolean
        * @param {Object} val The value to validate
        * @return {Boolean} true, if the value is valid
        */ 
        checkBoolean: function (val) {
            return (typeof val == Config.BOOLEAN_TYPE);
        },
        
        /**
        * Validates that the value passed in is a number.
        * @method checkNumber
        * @param {Object} val The value to validate
        * @return {Boolean} true, if the value is valid
        */
        checkNumber: function (val) {
            return (!isNaN(val));
        },
        
        /**
        * Fires a configuration property event using the specified value. 
        * @method fireEvent
        * @private
        * @param {String} key The configuration property's name
        * @param {value} Object The value of the correct type for the property
        */ 
        fireEvent: function ( key, value ) {
            var property = this.config[key];
        
            if (property && property.event) {
                property.event.fire(value);
            } 
        },
        
        /**
        * Adds a property to the Config Object's private config hash.
        * @method addProperty
        * @param {String} key The configuration property's name
        * @param {Object} propertyObject The Object containing all of this 
        * property's arguments
        */
        addProperty: function ( key, propertyObject ) {
            key = key.toLowerCase();
        
            this.config[key] = propertyObject;
        
            propertyObject.event = this.createEvent(key, { scope: this.owner });
            propertyObject.event.signature = CustomEvent.LIST;
            
            
            propertyObject.key = key;
        
            if (propertyObject.handler) {
                propertyObject.event.subscribe(propertyObject.handler, 
                    this.owner);
            }
        
            this.setProperty(key, propertyObject.value, true);
            
            if (! propertyObject.suppressEvent) {
                this.queueProperty(key, propertyObject.value);
            }
            
        },
        
        /**
        * Returns a key-value configuration map of the values currently set in  
        * the Config Object.
        * @method getConfig
        * @return {Object} The current config, represented in a key-value map
        */
        getConfig: function () {
        
            var cfg = {},
                prop,
                property;
                
            for (prop in this.config) {
                property = this.config[prop];
                if (property && property.event) {
                    cfg[prop] = property.value;
                }
            }
            
            return cfg;
        },
        
        /**
        * Returns the value of specified property.
        * @method getProperty
        * @param {String} key The name of the property
        * @return {Object}  The value of the specified property
        */
        getProperty: function (key) {
            var property = this.config[key.toLowerCase()];
            if (property && property.event) {
                return property.value;
            } else {
                return undefined;
            }
        },
        
        /**
        * Resets the specified property's value to its initial value.
        * @method resetProperty
        * @param {String} key The name of the property
        * @return {Boolean} True is the property was reset, false if not
        */
        resetProperty: function (key) {
    
            key = key.toLowerCase();
        
            var property = this.config[key];
    
            if (property && property.event) {
    
                if (this.initialConfig[key] && 
                    !Lang.isUndefined(this.initialConfig[key])) {
    
                    this.setProperty(key, this.initialConfig[key]);

                    return true;
    
                }
    
            } else {
    
                return false;
            }
    
        },
        
        /**
        * Sets the value of a property. If the silent property is passed as 
        * true, the property's event will not be fired.
        * @method setProperty
        * @param {String} key The name of the property
        * @param {String} value The value to set the property to
        * @param {Boolean} silent Whether the value should be set silently, 
        * without firing the property event.
        * @return {Boolean} True, if the set was successful, false if it failed.
        */
        setProperty: function (key, value, silent) {
        
            var property;
        
            key = key.toLowerCase();
        
            if (this.queueInProgress && ! silent) {
                // Currently running through a queue... 
                this.queueProperty(key,value);
                return true;
    
            } else {
                property = this.config[key];
                if (property && property.event) {
                    if (property.validator && !property.validator(value)) {
                        return false;
                    } else {
                        property.value = value;
                        if (! silent) {
                            this.fireEvent(key, value);
                            this.configChangedEvent.fire([key, value]);
                        }
                        return true;
                    }
                } else {
                    return false;
                }
            }
        },
        
        /**
        * Sets the value of a property and queues its event to execute. If the 
        * event is already scheduled to execute, it is
        * moved from its current position to the end of the queue.
        * @method queueProperty
        * @param {String} key The name of the property
        * @param {String} value The value to set the property to
        * @return {Boolean}  true, if the set was successful, false if 
        * it failed.
        */ 
        queueProperty: function (key, value) {
        
            key = key.toLowerCase();
        
            var property = this.config[key],
                foundDuplicate = false,
                iLen,
                queueItem,
                queueItemKey,
                queueItemValue,
                sLen,
                supercedesCheck,
                qLen,
                queueItemCheck,
                queueItemCheckKey,
                queueItemCheckValue,
                i,
                s,
                q;
                                
            if (property && property.event) {
    
                if (!Lang.isUndefined(value) && property.validator && 
                    !property.validator(value)) { // validator
                    return false;
                } else {
        
                    if (!Lang.isUndefined(value)) {
                        property.value = value;
                    } else {
                        value = property.value;
                    }
        
                    foundDuplicate = false;
                    iLen = this.eventQueue.length;
        
                    for (i = 0; i < iLen; i++) {
                        queueItem = this.eventQueue[i];
        
                        if (queueItem) {
                            queueItemKey = queueItem[0];
                            queueItemValue = queueItem[1];

                            if (queueItemKey == key) {
    
                                /*
                                    found a dupe... push to end of queue, null 
                                    current item, and break
                                */
    
                                this.eventQueue[i] = null;
    
                                this.eventQueue.push(
                                    [key, (!Lang.isUndefined(value) ? 
                                    value : queueItemValue)]);
    
                                foundDuplicate = true;
                                break;
                            }
                        }
                    }
                    
                    // this is a refire, or a new property in the queue
    
                    if (! foundDuplicate && !Lang.isUndefined(value)) { 
                        this.eventQueue.push([key, value]);
                    }
                }
        
                if (property.supercedes) {

                    sLen = property.supercedes.length;

                    for (s = 0; s < sLen; s++) {

                        supercedesCheck = property.supercedes[s];
                        qLen = this.eventQueue.length;

                        for (q = 0; q < qLen; q++) {
                            queueItemCheck = this.eventQueue[q];

                            if (queueItemCheck) {
                                queueItemCheckKey = queueItemCheck[0];
                                queueItemCheckValue = queueItemCheck[1];

                                if (queueItemCheckKey == 
                                    supercedesCheck.toLowerCase() ) {

                                    this.eventQueue.push([queueItemCheckKey, 
                                        queueItemCheckValue]);

                                    this.eventQueue[q] = null;
                                    break;

                                }
                            }
                        }
                    }
                }


                return true;
            } else {
                return false;
            }
        },
        
        /**
        * Fires the event for a property using the property's current value.
        * @method refireEvent
        * @param {String} key The name of the property
        */
        refireEvent: function (key) {
    
            key = key.toLowerCase();
        
            var property = this.config[key];
    
            if (property && property.event && 
    
                !Lang.isUndefined(property.value)) {
    
                if (this.queueInProgress) {
    
                    this.queueProperty(key);
    
                } else {
    
                    this.fireEvent(key, property.value);
    
                }
    
            }
        },
        
        /**
        * Applies a key-value Object literal to the configuration, replacing  
        * any existing values, and queueing the property events.
        * Although the values will be set, fireQueue() must be called for their 
        * associated events to execute.
        * @method applyConfig
        * @param {Object} userConfig The configuration Object literal
        * @param {Boolean} init  When set to true, the initialConfig will 
        * be set to the userConfig passed in, so that calling a reset will 
        * reset the properties to the passed values.
        */
        applyConfig: function (userConfig, init) {
        
            var sKey,
                oConfig;

            if (init) {
                oConfig = {};
                for (sKey in userConfig) {
                    if (Lang.hasOwnProperty(userConfig, sKey)) {
                        oConfig[sKey.toLowerCase()] = userConfig[sKey];
                    }
                }
                this.initialConfig = oConfig;
            }

            for (sKey in userConfig) {
                if (Lang.hasOwnProperty(userConfig, sKey)) {
                    this.queueProperty(sKey, userConfig[sKey]);
                }
            }
        },
        
        /**
        * Refires the events for all configuration properties using their 
        * current values.
        * @method refresh
        */
        refresh: function () {
        
            var prop;
        
            for (prop in this.config) {
                this.refireEvent(prop);
            }
        },
        
        /**
        * Fires the normalized list of queued property change events
        * @method fireQueue
        */
        fireQueue: function () {
        
            var i, 
                queueItem,
                key,
                value,
                property;
        
            this.queueInProgress = true;
            for (i = 0;i < this.eventQueue.length; i++) {
                queueItem = this.eventQueue[i];
                if (queueItem) {
        
                    key = queueItem[0];
                    value = queueItem[1];
                    property = this.config[key];
        
                    property.value = value;
        
                    this.fireEvent(key,value);
                }
            }
            
            this.queueInProgress = false;
            this.eventQueue = [];
        },
        
        /**
        * Subscribes an external handler to the change event for any 
        * given property. 
        * @method subscribeToConfigEvent
        * @param {String} key The property name
        * @param {Function} handler The handler function to use subscribe to 
        * the property's event
        * @param {Object} obj The Object to use for scoping the event handler 
        * (see CustomEvent documentation)
        * @param {Boolean} override Optional. If true, will override "this"  
        * within the handler to map to the scope Object passed into the method.
        * @return {Boolean} True, if the subscription was successful, 
        * otherwise false.
        */ 
        subscribeToConfigEvent: function (key, handler, obj, override) {
    
            var property = this.config[key.toLowerCase()];
    
            if (property && property.event) {
                if (!Config.alreadySubscribed(property.event, handler, obj)) {
                    property.event.subscribe(handler, obj, override);
                }
                return true;
            } else {
                return false;
            }
    
        },
        
        /**
        * Unsubscribes an external handler from the change event for any 
        * given property. 
        * @method unsubscribeFromConfigEvent
        * @param {String} key The property name
        * @param {Function} handler The handler function to use subscribe to 
        * the property's event
        * @param {Object} obj The Object to use for scoping the event 
        * handler (see CustomEvent documentation)
        * @return {Boolean} True, if the unsubscription was successful, 
        * otherwise false.
        */
        unsubscribeFromConfigEvent: function (key, handler, obj) {
            var property = this.config[key.toLowerCase()];
            if (property && property.event) {
                return property.event.unsubscribe(handler, obj);
            } else {
                return false;
            }
        },
        
        /**
        * Returns a string representation of the Config object
        * @method toString
        * @return {String} The Config object in string format.
        */
        toString: function () {
            var output = "Config";
            if (this.owner) {
                output += " [" + this.owner.toString() + "]";
            }
            return output;
        },
        
        /**
        * Returns a string representation of the Config object's current 
        * CustomEvent queue
        * @method outputEventQueue
        * @return {String} The string list of CustomEvents currently queued 
        * for execution
        */
        outputEventQueue: function () {

            var output = "",
                queueItem,
                q,
                nQueue = this.eventQueue.length;
              
            for (q = 0; q < nQueue; q++) {
                queueItem = this.eventQueue[q];
                if (queueItem) {
                    output += queueItem[0] + "=" + queueItem[1] + ", ";
                }
            }
            return output;
        },

        /**
        * Sets all properties to null, unsubscribes all listeners from each 
        * property's change event and all listeners from the configChangedEvent.
        * @method destroy
        */
        destroy: function () {

            var oConfig = this.config,
                sProperty,
                oProperty;


            for (sProperty in oConfig) {
            
                if (Lang.hasOwnProperty(oConfig, sProperty)) {

                    oProperty = oConfig[sProperty];

                    oProperty.event.unsubscribeAll();
                    oProperty.event = null;

                }
            
            }
            
            this.configChangedEvent.unsubscribeAll();
            
            this.configChangedEvent = null;
            this.owner = null;
            this.config = null;
            this.initialConfig = null;
            this.eventQueue = null;
        
        }

    };
    
    
    
    /**
    * Checks to determine if a particular function/Object pair are already 
    * subscribed to the specified CustomEvent
    * @method pega.util.Config.alreadySubscribed
    * @static
    * @param {pega.util.CustomEvent} evt The CustomEvent for which to check 
    * the subscriptions
    * @param {Function} fn The function to look for in the subscribers list
    * @param {Object} obj The execution scope Object for the subscription
    * @return {Boolean} true, if the function/Object pair is already subscribed 
    * to the CustomEvent passed in
    */
    Config.alreadySubscribed = function (evt, fn, obj) {
    
        var nSubscribers = evt.subscribers.length,
            subsc,
            i;

        if (nSubscribers > 0) {
            i = nSubscribers - 1;
            do {
                subsc = evt.subscribers[i];
                if (subsc && subsc.obj == obj && subsc.fn == fn) {
                    return true;
                }
            }
            while (i--);
        }

        return false;

    };

    pega.lang.augmentProto(Config, pega.util.EventProvider);

}());

(function () {

    /**
    * The Container family of components is designed to enable developers to 
    * create different kinds of content-containing modules on the web. Module 
    * and Overlay are the most basic containers, and they can be used directly 
    * or extended to build custom containers. Also part of the Container family 
    * are four UI controls that extend Module and Overlay: Tooltip, Panel, 
    * Dialog, and SimpleDialog.
    * @module container
    * @title Container
    * @requires yahoo, dom, event 
    * @optional dragdrop, animation, button
    */
    
    /**
    * Module is a JavaScript representation of the Standard Module Format. 
    * Standard Module Format is a simple standard for markup containers where 
    * child nodes representing the header, body, and footer of the content are 
    * denoted using the CSS classes "hd", "bd", and "ft" respectively. 
    * Module is the base class for all other classes in the YUI 
    * Container package.
    * @namespace pega.widget
    * @class Module
    * @constructor
    * @param {String} el The element ID representing the Module <em>OR</em>
    * @param {HTMLElement} el The element representing the Module
    * @param {Object} userConfig The configuration Object literal containing 
    * the configuration that should be set for this module. See configuration 
    * documentation for more details.
    */
    pega.widget.Module = function (el, userConfig) {
        if (el) {
            this.init(el, userConfig);
        } else {
        }
    };

    var Dom = pega.util.Dom,
        Config = pega.util.Config,
        Event = pega.util.Event,
        CustomEvent = pega.util.CustomEvent,
        Module = pega.widget.Module,

        m_oModuleTemplate,
        m_oHeaderTemplate,
        m_oBodyTemplate,
        m_oFooterTemplate,

        /**
        * Constant representing the name of the Module's events
        * @property EVENT_TYPES
        * @private
        * @final
        * @type Object
        */
        EVENT_TYPES = {
            "BEFORE_INIT": "beforeInit",
            "INIT": "init",
            "APPEND": "append",
            "BEFORE_RENDER": "beforeRender",
            "RENDER": "render",
            "CHANGE_HEADER": "changeHeader",
            "CHANGE_BODY": "changeBody",
            "CHANGE_FOOTER": "changeFooter",
            "CHANGE_CONTENT": "changeContent",
            "DESTORY": "destroy",
            "BEFORE_SHOW": "beforeShow",
            "SHOW": "show",
            "BEFORE_HIDE": "beforeHide",
            "HIDE": "hide"
        },
            
        /**
        * Constant representing the Module's configuration properties
        * Pega_NOTE: Modified Monitor_RESIZE default setting to false
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {
        
            "VISIBLE": { 
                key: "visible", 
                value: true, 
                validator: pega.lang.isBoolean 
            },
        
            "EFFECT": { 
                key: "effect", 
                suppressEvent: true, 
                supercedes: ["visible"] 
            },

            "MONITOR_RESIZE": { 
                key: "monitorresize", 
                value: false  
            },

            "APPEND_TO_DOCUMENT_BODY": { 
                key: "appendtodocumentbody", 
                value: false
            }
        };
    
    /**
    * Constant representing the prefix path to use for non-secure images
    * @property pega.widget.Module.IMG_ROOT
    * @static
    * @final
    * @type String
    */
    Module.IMG_ROOT = null;
    
    /**
    * Constant representing the prefix path to use for securely served images
    * @property pega.widget.Module.IMG_ROOT_SSL
    * @static
    * @final
    * @type String
    */
    Module.IMG_ROOT_SSL = null;
    
    /**
    * Constant for the default CSS class name that represents a Module
    * @property pega.widget.Module.CSS_MODULE
    * @static
    * @final
    * @type String
    */
    Module.CSS_MODULE = "yui-module";
    
    /**
    * Constant representing the module header
    * @property pega.widget.Module.CSS_HEADER
    * @static
    * @final
    * @type String
    */
    Module.CSS_HEADER = "hd";

    /**
    * Constant representing the module body
    * @property pega.widget.Module.CSS_BODY
    * @static
    * @final
    * @type String
    */
    Module.CSS_BODY = "bd";
    
    /**
    * Constant representing the module footer
    * @property pega.widget.Module.CSS_FOOTER
    * @static
    * @final
    * @type String
    */
    Module.CSS_FOOTER = "ft";
    
    /**
    * Constant representing the url for the "src" attribute of the iframe 
    * used to monitor changes to the browser's base font size
    * @property pega.widget.Module.RESIZE_MONITOR_SECURE_URL
    * @static
    * @final
    * @type String
    */
    Module.RESIZE_MONITOR_SECURE_URL = "javascript:false;";
    
    /**
    * Singleton CustomEvent fired when the font size is changed in the browser.
    * Opera's "zoom" functionality currently does not support text 
    * size detection.
    * @event pega.widget.Module.textResizeEvent
    */
    Module.textResizeEvent = new CustomEvent("textResize");

    function createModuleTemplate() {

        if (!m_oModuleTemplate) {
            m_oModuleTemplate = document.createElement("div");
            
            m_oModuleTemplate.innerHTML = ("<div class=\"" + 
                Module.CSS_HEADER + "\"></div>" + "<div class=\"" + 
                Module.CSS_BODY + "\"></div><div class=\"" + 
                Module.CSS_FOOTER + "\"></div>");

            m_oHeaderTemplate = m_oModuleTemplate.firstChild;
            m_oBodyTemplate = m_oHeaderTemplate.nextSibling;
            m_oFooterTemplate = m_oBodyTemplate.nextSibling;
        }

        return m_oModuleTemplate;
    }

    function createHeader() {
        if (!m_oHeaderTemplate) {
            createModuleTemplate();
        }
        return (m_oHeaderTemplate.cloneNode(false));
    }

    function createBody() {
        if (!m_oBodyTemplate) {
            createModuleTemplate();
        }
        return (m_oBodyTemplate.cloneNode(false));
    }

    function createFooter() {
        if (!m_oFooterTemplate) {
            createModuleTemplate();
        }
        return (m_oFooterTemplate.cloneNode(false));
    }

    Module.prototype = {

        /**
        * The class's constructor function
        * @property contructor
        * @type Function
        */
        constructor: Module,
        
        /**
        * The main module element that contains the header, body, and footer
        * @property element
        * @type HTMLElement
        */
        element: null,

        /**
        * The header element, denoted with CSS class "hd"
        * @property header
        * @type HTMLElement
        */
        header: null,

        /**
        * The body element, denoted with CSS class "bd"
        * @property body
        * @type HTMLElement
        */
        body: null,

        /**
        * The footer element, denoted with CSS class "ft"
        * @property footer
        * @type HTMLElement
        */
        footer: null,

        /**
        * The id of the element
        * @property id
        * @type String
        */
        id: null,

        /**
        * A string representing the root path for all images created by
        * a Module instance.
        * @deprecated It is recommend that any images for a Module be applied
        * via CSS using the "background-image" property.
        * @property imageRoot
        * @type String
        */
        imageRoot: Module.IMG_ROOT,

        /**
        * Initializes the custom events for Module which are fired 
        * automatically at appropriate times by the Module class.
        * @method initEvents
        */
        initEvents: function () {

            var SIGNATURE = CustomEvent.LIST;

            /**
            * CustomEvent fired prior to class initalization.
            * @event beforeInitEvent
            * @param {class} classRef class reference of the initializing 
            * class, such as this.beforeInitEvent.fire(Module)
            */
            this.beforeInitEvent = this.createEvent(EVENT_TYPES.BEFORE_INIT);
            this.beforeInitEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after class initalization.
            * @event initEvent
            * @param {class} classRef class reference of the initializing 
            * class, such as this.beforeInitEvent.fire(Module)
            */  
            this.initEvent = this.createEvent(EVENT_TYPES.INIT);
            this.initEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the Module is appended to the DOM
            * @event appendEvent
            */
            this.appendEvent = this.createEvent(EVENT_TYPES.APPEND);
            this.appendEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired before the Module is rendered
            * @event beforeRenderEvent
            */
            this.beforeRenderEvent = this.createEvent(EVENT_TYPES.BEFORE_RENDER);
            this.beforeRenderEvent.signature = SIGNATURE;
        
            /**
            * CustomEvent fired after the Module is rendered
            * @event renderEvent
            */
            this.renderEvent = this.createEvent(EVENT_TYPES.RENDER);
            this.renderEvent.signature = SIGNATURE;
        
            /**
            * CustomEvent fired when the header content of the Module 
            * is modified
            * @event changeHeaderEvent
            * @param {String/HTMLElement} content String/element representing 
            * the new header content
            */
            this.changeHeaderEvent = this.createEvent(EVENT_TYPES.CHANGE_HEADER);
            this.changeHeaderEvent.signature = SIGNATURE;
            
            /**
            * CustomEvent fired when the body content of the Module is modified
            * @event changeBodyEvent
            * @param {String/HTMLElement} content String/element representing 
            * the new body content
            */  
            this.changeBodyEvent = this.createEvent(EVENT_TYPES.CHANGE_BODY);
            this.changeBodyEvent.signature = SIGNATURE;
            
            /**
            * CustomEvent fired when the footer content of the Module 
            * is modified
            * @event changeFooterEvent
            * @param {String/HTMLElement} content String/element representing 
            * the new footer content
            */
            this.changeFooterEvent = this.createEvent(EVENT_TYPES.CHANGE_FOOTER);
            this.changeFooterEvent.signature = SIGNATURE;
        
            /**
            * CustomEvent fired when the content of the Module is modified
            * @event changeContentEvent
            */
            this.changeContentEvent = this.createEvent(EVENT_TYPES.CHANGE_CONTENT);
            this.changeContentEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the Module is destroyed
            * @event destroyEvent
            */
            this.destroyEvent = this.createEvent(EVENT_TYPES.DESTORY);
            this.destroyEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired before the Module is shown
            * @event beforeShowEvent
            */
            this.beforeShowEvent = this.createEvent(EVENT_TYPES.BEFORE_SHOW);
            this.beforeShowEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after the Module is shown
            * @event showEvent
            */
            this.showEvent = this.createEvent(EVENT_TYPES.SHOW);
            this.showEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired before the Module is hidden
            * @event beforeHideEvent
            */
            this.beforeHideEvent = this.createEvent(EVENT_TYPES.BEFORE_HIDE);
            this.beforeHideEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after the Module is hidden
            * @event hideEvent
            */
            this.hideEvent = this.createEvent(EVENT_TYPES.HIDE);
            this.hideEvent.signature = SIGNATURE;
        }, 

        /**
        * String representing the current user-agent platform
        * @property platform
        * @type String
        */
        platform: function () {
            var ua = navigator.userAgent.toLowerCase();

            if (ua.indexOf("windows") != -1 || ua.indexOf("win32") != -1) {
                return "windows";
            } else if (ua.indexOf("macintosh") != -1) {
                return "mac";
            } else {
                return false;
            }
        }(),
        
        /**
        * String representing the user-agent of the browser
        * @deprecated Use pega.env.ua
        * @property browser
        * @type String
        */
        browser: function () {
            var ua = navigator.userAgent.toLowerCase();
            /*
                 Check Opera first in case of spoof and check Safari before
                 Gecko since Safari's user agent string includes "like Gecko"
            */
            if (ua.indexOf('opera') != -1) { 
                return 'opera';
            } else if (ua.indexOf('msie 7') != -1) {
                return 'ie7';
            } else if (ua.indexOf('msie') != -1) {
                return 'ie';
            } else if (ua.indexOf('safari') != -1) { 
                return 'safari';
            } else if (ua.indexOf('gecko') != -1) {
                return 'gecko';
            } else {
                return false;
            }
        }(),
        
        /**
        * Boolean representing whether or not the current browsing context is 
        * secure (https)
        * @property isSecure
        * @type Boolean
        */
        isSecure: function () {
            if (window.location.href.toLowerCase().indexOf("https") === 0) {
                return true;
            } else {
                return false;
            }
        }(),
        
        /**
        * Initializes the custom events for Module which are fired 
        * automatically at appropriate times by the Module class.
        */
        initDefaultConfig: function () {
            // Add properties //
            /**
            * Specifies whether the Module is visible on the page.
            * @config visible
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.VISIBLE.key, {
                handler: this.configVisible, 
                value: DEFAULT_CONFIG.VISIBLE.value, 
                validator: DEFAULT_CONFIG.VISIBLE.validator
            });

            /**
            * Object or array of objects representing the ContainerEffect 
            * classes that are active for animating the container.
            * @config effect
            * @type Object
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.EFFECT.key, {
                suppressEvent: DEFAULT_CONFIG.EFFECT.suppressEvent, 
                supercedes: DEFAULT_CONFIG.EFFECT.supercedes
            });

            /**
            * Specifies whether to create a special proxy iframe to monitor 
            * for user font resizing in the document
            * @config monitorresize
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.MONITOR_RESIZE.key, {
                handler: this.configMonitorResize,
                value: DEFAULT_CONFIG.MONITOR_RESIZE.value
            });

            /**
            * Specifies if the module should be rendered as the first child 
            * of document.body or appended as the last child when render is called
            * with document.body as the "appendToNode".
            * <p>
            * Appending to the body while the DOM is still being constructed can 
            * lead to Operation Aborted errors in IE hence this flag is set to 
            * false by default.
            * </p>
            * 
            * @config appendtodocumentbody
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.APPEND_TO_DOCUMENT_BODY.key, {
                value: DEFAULT_CONFIG.APPEND_TO_DOCUMENT_BODY.value
            });
        },

        /**
        * The Module class's initialization method, which is executed for
        * Module and all of its subclasses. This method is automatically 
        * called by the constructor, and  sets up all DOM references for 
        * pre-existing markup, and creates required markup if it is not 
        * already present.
        * @method init
        * @param {String} el The element ID representing the Module <em>OR</em>
        * @param {HTMLElement} el The element representing the Module
        * @param {Object} userConfig The configuration Object literal 
        * containing the configuration that should be set for this module. 
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {

            var elId, child;

            this.initEvents();
            this.beforeInitEvent.fire(Module);

            /**
            * The Module's Config object used for monitoring 
            * configuration properties.
            * @property cfg
            * @type pega.util.Config
            */
            this.cfg = new Config(this);

            if (this.isSecure) {
                this.imageRoot = Module.IMG_ROOT_SSL;
            }

            if (typeof el == "string") {
                elId = el;
                el = document.getElementById(el);
                if (! el) {
                    el = (createModuleTemplate()).cloneNode(false);
                    el.id = elId;
                }
            }

            this.element = el;

            if (el.id) {
                this.id = el.id;
            }

            child = this.element.firstChild;

            if (child) {
                var fndHd = false, fndBd = false, fndFt = false;
                do {
                    // We're looking for elements
                    if (1 == child.nodeType) {
                        if (!fndHd && Dom.hasClass(child, Module.CSS_HEADER)) {
                            this.header = child;
                            fndHd = true;
                        } else if (!fndBd && Dom.hasClass(child, Module.CSS_BODY)) {
                            this.body = child;
                            fndBd = true;
                        } else if (!fndFt && Dom.hasClass(child, Module.CSS_FOOTER)){
                            this.footer = child;
                            fndFt = true;
                        }
                    }
                } while ((child = child.nextSibling));
            }

            this.initDefaultConfig();

            Dom.addClass(this.element, Module.CSS_MODULE);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            /*
                Subscribe to the fireQueue() method of Config so that any 
                queued configuration changes are excecuted upon render of 
                the Module
            */ 

            if (!Config.alreadySubscribed(this.renderEvent, this.cfg.fireQueue, this.cfg)) {
                this.renderEvent.subscribe(this.cfg.fireQueue, this.cfg, true);
            }

            this.initEvent.fire(Module);
        },

        /**
        * Initialize an empty IFRAME that is placed out of the visible area 
        * that can be used to detect text resize.
        * @method initResizeMonitor
        */
        initResizeMonitor: function () {

            var isGeckoWin = (pega.env.ua.gecko && this.platform == "windows");
            if (isGeckoWin) {
                // Help prevent spinning loading icon which 
                // started with FireFox 2.0.0.8/Win
                var self = this;
                setTimeout(function(){self._initResizeMonitor();}, 0);
            } else {
                this._initResizeMonitor();
            }
        },

        /**
         * Create and initialize the text resize monitoring iframe.
         * Pega_Note: Modified resize monitor top, left location to be fixed
         * @protected
         * @method _initResizeMonitor
         */
        _initResizeMonitor : function() {

            var oDoc, 
                oIFrame, 
                sHTML;

            function fireTextResize() {
                Module.textResizeEvent.fire();
            }

            if (!pega.env.ua.opera) {
                oIFrame = Dom.get("_yuiResizeMonitor");

                var supportsCWResize = this._supportsCWResize();

                if (!oIFrame) {
                    oIFrame = document.createElement("iframe");

                    if (this.isSecure && Module.RESIZE_MONITOR_SECURE_URL && pega.env.ua.ie) {
                        oIFrame.src = Module.RESIZE_MONITOR_SECURE_URL;
                    }

                    if (!supportsCWResize) {
                        // Can't monitor on contentWindow, so fire from inside iframe
                        sHTML = ["<html><head><script ",
                                 "type=\"text/javascript\">",
                                 "window.onresize=function(){window.parent.",
                                 "pega.widget.Module.textResizeEvent.",
                                 "fire();};<",
                                 "\/script></head>",
                                 "<body></body></html>"].join('');

                        oIFrame.src = "data:text/html;charset=utf-8," + encodeURIComponent(sHTML);
                    }

                    oIFrame.id = "_yuiResizeMonitor";
                    /*
                        Need to set "position" property before inserting the 
                        iframe into the document or Safari's status bar will 
                        forever indicate the iframe is loading 
                        (See SourceForge bug #1723064)
                    */
                    oIFrame.style.position = "absolute";
                    oIFrame.style.visibility = "hidden";

                    var db = document.body,
                        fc = db.firstChild;
		if (fc) {
                        db.insertBefore(oIFrame, fc);
                    } else {
                        db.appendChild(oIFrame);
                    }

                  
                    

                    oIFrame.style.width = "10em";
                    oIFrame.style.height = "10em";
                    oIFrame.style.top = "-500px";
                    oIFrame.style.left = "-500px";
                    oIFrame.style.borderWidth = "0";
                    oIFrame.style.visibility = "visible";

		   /*
                       Don't open/close the document for Gecko like we used to, since it
                       leads to duplicate cookies. (See SourceForge bug #1721755)
                    */
                    if (pega.env.ua.webkit) {
                        oDoc = oIFrame.contentWindow.document;
                        oDoc.open();
                        oDoc.close();
                    }
                }

                if (oIFrame && oIFrame.contentWindow) {
                    Module.textResizeEvent.subscribe(this.onDomResize, this, true);

                    if (!Module.textResizeInitialized) {
                        if (supportsCWResize) {
                            if (!Event.on(oIFrame.contentWindow, "resize", fireTextResize)) {
                                /*
                                     This will fail in IE if document.domain has 
                                     changed, so we must change the listener to 
                                     use the oIFrame element instead
                                */
                                Event.on(oIFrame, "resize", fireTextResize);
                            }
                        }
                        Module.textResizeInitialized = true;
                    }
                    this.resizeMonitor = oIFrame;
                }
            }
        },

        /**
         * Text resize monitor helper method.
         * Determines if the browser supports resize events on iframe content windows.
         * 
         * @private
         * @method _supportsCWResize
         */
        _supportsCWResize : function() {
            /*
                Gecko 1.8.0 (FF1.5), 1.8.1.0-5 (FF2) won't fire resize on contentWindow.
                Gecko 1.8.1.6+ (FF2.0.0.6+) and all other browsers will fire resize on contentWindow.

                We don't want to start sniffing for patch versions, so fire textResize the same
                way on all FF, until 1.9 (3.x) is out
             */
            var bSupported = true;
            if (pega.env.ua.gecko && pega.env.ua.gecko <= 1.8) {
                bSupported = false;
                /*
                var v = navigator.userAgent.match(/rv:([^\s\)]*)/); // From pega.env.ua
                if (v && v[0]) {
                    var sv = v[0].match(/\d\.\d\.(\d)/);
                    if (sv && sv[1]) {
                        if (parseInt(sv[1], 10) > 0) {
                            bSupported = true;
                        }
                    }
                }
                */
            }
            return bSupported;
        },

        /**
        * Event handler fired when the resize monitor element is resized.
        * @method onDomResize
        * @param {DOMEvent} e The DOM resize event
        * @param {Object} obj The scope object passed to the handler
        */
        onDomResize: function (e, obj) {

            var nLeft = -1 * this.resizeMonitor.offsetWidth,
                nTop = -1 * this.resizeMonitor.offsetHeight;
        
            this.resizeMonitor.style.top = nTop + "px";
            this.resizeMonitor.style.left =  nLeft + "px";

        },

        /**
        * Sets the Module's header content to the string specified, or appends 
        * the passed element to the header. If no header is present, one will 
        * be automatically created. An empty string can be passed to the method
        * to clear the contents of the header.
        * 
        * @method setHeader
        * @param {String} headerContent The string used to set the header.
        * As a convenience, non HTMLElement objects can also be passed into 
        * the method, and will be treated as strings, with the header innerHTML
        * set to their default toString implementations.
        * <em>OR</em>
        * @param {HTMLElement} headerContent The HTMLElement to append to 
        * <em>OR</em>
        * @param {DocumentFragment} headerContent The document fragment 
        * containing elements which are to be added to the header
        */
        setHeader: function (headerContent) {
            var oHeader = this.header || (this.header = createHeader());

            if (headerContent.nodeName) {
                oHeader.innerHTML = "";
                oHeader.appendChild(headerContent);
            } else {
                oHeader.innerHTML = headerContent;
            }

            this.changeHeaderEvent.fire(headerContent);
            this.changeContentEvent.fire();

        },

        /**
        * Appends the passed element to the header. If no header is present, 
        * one will be automatically created.
        * @method appendToHeader
        * @param {HTMLElement | DocumentFragment} element The element to 
        * append to the header. In the case of a document fragment, the
        * children of the fragment will be appended to the header.
        */
        appendToHeader: function (element) {
            var oHeader = this.header || (this.header = createHeader());

            oHeader.appendChild(element);

            this.changeHeaderEvent.fire(element);
            this.changeContentEvent.fire();

        },

        /**
        * Sets the Module's body content to the HTML specified, or appends the
        * passed element to the body. If no body is present, one will be 
        * automatically created. An empty string can be passed to the method
        * to clear the contents of the body.
        * @method setBody
        * @param {String} bodyContent The HTML used to set the body. 
        * As a convenience, non HTMLElement objects can also be passed into 
        * the method, and will be treated as strings, with the body innerHTML
        * set to their default toString implementations.
        * <em>OR</em>
        * @param {HTMLElement} bodyContent The HTMLElement to append to the body
        * <em>OR</em>
        * @param {DocumentFragment} bodyContent The document fragment 
        * containing elements which are to be added to the body
        */
        setBody: function (bodyContent) {
            var oBody = this.body || (this.body = createBody());

            if (bodyContent.nodeName) {
                oBody.innerHTML = "";
                oBody.appendChild(bodyContent);
            } else {
                oBody.innerHTML = bodyContent;
            }

            this.changeBodyEvent.fire(bodyContent);
            this.changeContentEvent.fire();
        },

        /**
        * Appends the passed element to the body. If no body is present, one 
        * will be automatically created.
        * @method appendToBody
        * @param {HTMLElement | DocumentFragment} element The element to 
        * append to the body. In the case of a document fragment, the
        * children of the fragment will be appended to the body.
        * 
        */
        appendToBody: function (element) {
            var oBody = this.body || (this.body = createBody());
        
            oBody.appendChild(element);

            this.changeBodyEvent.fire(element);
            this.changeContentEvent.fire();

        },
        
        /**
        * Sets the Module's footer content to the HTML specified, or appends 
        * the passed element to the footer. If no footer is present, one will 
        * be automatically created. An empty string can be passed to the method
        * to clear the contents of the footer.
        * @method setFooter
        * @param {String} footerContent The HTML used to set the footer 
        * As a convenience, non HTMLElement objects can also be passed into 
        * the method, and will be treated as strings, with the footer innerHTML
        * set to their default toString implementations.
        * <em>OR</em>
        * @param {HTMLElement} footerContent The HTMLElement to append to 
        * the footer
        * <em>OR</em>
        * @param {DocumentFragment} footerContent The document fragment containing 
        * elements which are to be added to the footer
        */
        setFooter: function (footerContent) {

            var oFooter = this.footer || (this.footer = createFooter());

            if (footerContent.nodeName) {
                oFooter.innerHTML = "";
                oFooter.appendChild(footerContent);
            } else {
                oFooter.innerHTML = footerContent;
            }

            this.changeFooterEvent.fire(footerContent);
            this.changeContentEvent.fire();
        },

        /**
        * Appends the passed element to the footer. If no footer is present, 
        * one will be automatically created.
        * @method appendToFooter
        * @param {HTMLElement | DocumentFragment} element The element to 
        * append to the footer. In the case of a document fragment, the
        * children of the fragment will be appended to the footer
        */
        appendToFooter: function (element) {

            var oFooter = this.footer || (this.footer = createFooter());

            oFooter.appendChild(element);

            this.changeFooterEvent.fire(element);
            this.changeContentEvent.fire();

        },

        /**
        * Renders the Module by inserting the elements that are not already 
        * in the main Module into their correct places. Optionally appends 
        * the Module to the specified node prior to the render's execution. 
        * <p>
        * For Modules without existing markup, the appendToNode argument 
        * is REQUIRED. If this argument is ommitted and the current element is 
        * not present in the document, the function will return false, 
        * indicating that the render was a failure.
        * </p>
        * <p>
        * NOTE: As of 2.3.1, if the appendToNode is the document's body element
        * then the module is rendered as the first child of the body element, 
        * and not appended to it, to avoid Operation Aborted errors in IE when 
        * rendering the module before window's load event is fired. You can 
        * use the appendtodocumentbody configuration property to change this 
        * to append to document.body if required.
        * </p>
        * @method render
        * @param {String} appendToNode The element id to which the Module 
        * should be appended to prior to rendering <em>OR</em>
        * @param {HTMLElement} appendToNode The element to which the Module 
        * should be appended to prior to rendering
        * @param {HTMLElement} moduleElement OPTIONAL. The element that 
        * represents the actual Standard Module container.
        * @return {Boolean} Success or failure of the render
        */
        render: function (appendToNode, moduleElement) {

            var me = this,
                firstChild;

            function appendTo(parentNode) {
                if (typeof parentNode == "string") {
                    parentNode = document.getElementById(parentNode);
                }

                if (parentNode) {
                    me._addToParent(parentNode, me.element);
                    me.appendEvent.fire();
                }
            }

            this.beforeRenderEvent.fire();

            if (! moduleElement) {
                moduleElement = this.element;
            }

            if (appendToNode) {
                appendTo(appendToNode);
            } else { 
                // No node was passed in. If the element is not already in the Dom, this fails
                if (! Dom.inDocument(this.element)) {
                    return false;
                }
            }

            // Need to get everything into the DOM if it isn't already
            if (this.header && ! Dom.inDocument(this.header)) {
                // There is a header, but it's not in the DOM yet. Need to add it.
                firstChild = moduleElement.firstChild;
                if (firstChild) {
                    moduleElement.insertBefore(this.header, firstChild);
                } else {
                    moduleElement.appendChild(this.header);
                }
            }

            if (this.body && ! Dom.inDocument(this.body)) {
                // There is a body, but it's not in the DOM yet. Need to add it.		
                if (this.footer && Dom.isAncestor(this.moduleElement, this.footer)) {
                    moduleElement.insertBefore(this.body, this.footer);
                } else {
                    moduleElement.appendChild(this.body);
                }
            }

            if (this.footer && ! Dom.inDocument(this.footer)) {
                // There is a footer, but it's not in the DOM yet. Need to add it.
                moduleElement.appendChild(this.footer);
            }

            this.renderEvent.fire();
            return true;
        },

        /**
        * Removes the Module element from the DOM and sets all child elements 
        * to null.
        * @method destroy
        */
        destroy: function () {

            var parent,
                e;

            if (this.element) {
                Event.purgeElement(this.element, true);
                parent = this.element.parentNode;
            }

            if (parent) {
                parent.removeChild(this.element);
            }
        
            this.element = null;
            this.header = null;
            this.body = null;
            this.footer = null;

            Module.textResizeEvent.unsubscribe(this.onDomResize, this);

            this.cfg.destroy();
            this.cfg = null;

            this.destroyEvent.fire();
        
            for (e in this) {
                if (e instanceof CustomEvent) {
                    e.unsubscribeAll();
                }
            }

        },

        /**
        * Shows the Module element by setting the visible configuration 
        * property to true. Also fires two events: beforeShowEvent prior to 
        * the visibility change, and showEvent after.
        * @method show
        */
        show: function () {
            this.cfg.setProperty("visible", true);
        },

        /**
        * Hides the Module element by setting the visible configuration 
        * property to false. Also fires two events: beforeHideEvent prior to 
        * the visibility change, and hideEvent after.
        * @method hide
        */
        hide: function () {
            this.cfg.setProperty("visible", false);
        },
        
        // BUILT-IN EVENT HANDLERS FOR MODULE //
        /**
        * Default event handler for changing the visibility property of a 
        * Module. By default, this is achieved by switching the "display" style 
        * between "block" and "none".
        * This method is responsible for firing showEvent and hideEvent.
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        * @method configVisible
        */
        configVisible: function (type, args, obj) {
            var visible = args[0];
            if (visible) {
                this.beforeShowEvent.fire();
                Dom.setStyle(this.element, "display", "block");
                this.showEvent.fire();
            } else {
                this.beforeHideEvent.fire();
                Dom.setStyle(this.element, "display", "none");
                this.hideEvent.fire();
            }
        },
        
        /**
        * Default event handler for the "monitorresize" configuration property
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        * @method configMonitorResize
        */
        configMonitorResize: function (type, args, obj) {
            var monitor = args[0];
            if (monitor) {
                this.initResizeMonitor();
            } else {
                Module.textResizeEvent.unsubscribe(this.onDomResize, this, true);
                this.resizeMonitor = null;
            }
        },

        /**
         * This method is a protected helper, used when constructing the DOM structure for the module 
         * to account for situations which may cause Operation Aborted errors in IE. It should not 
         * be used for general DOM construction.
         * <p>
         * If the parentNode is not document.body, the element is appended as the last element.
         * </p>
         * <p>
         * If the parentNode is document.body the element is added as the first child to help
         * prevent Operation Aborted errors in IE.
         * </p>
         *
         * @param {parentNode} The HTML element to which the element will be added
         * @param {element} The HTML element to be added to parentNode's children
         * @method _addToParent
         * @protected
         */
        _addToParent: function(parentNode, element) {
            if (!this.cfg.getProperty("appendtodocumentbody") && parentNode === document.body && parentNode.firstChild) {
                parentNode.insertBefore(element, parentNode.firstChild);
            } else {
                parentNode.appendChild(element);
            }
        },

        /**
        * Returns a String representation of the Object.
        * @method toString
        * @return {String} The string representation of the Module
        */
        toString: function () {
            return "Module " + this.id;
        }
    };

    pega.lang.augmentProto(Module, pega.util.EventProvider);

}());

(function () {

    /**
    * Overlay is a Module that is absolutely positioned above the page flow. It 
    * has convenience methods for positioning and sizing, as well as options for 
    * controlling zIndex and constraining the Overlay's position to the current 
    * visible viewport. Overlay also contains a dynamicly generated IFRAME which 
    * is placed beneath it for Internet Explorer 6 and 5.x so that it will be 
    * properly rendered above SELECT elements.
    * @namespace pega.widget
    * @class Overlay
    * @extends pega.widget.Module
    * @param {String} el The element ID representing the Overlay <em>OR</em>
    * @param {HTMLElement} el The element representing the Overlay
    * @param {Object} userConfig The configuration object literal containing 
    * the configuration that should be set for this Overlay. See configuration 
    * documentation for more details.
    * @constructor
    */
    pega.widget.Overlay = function (el, userConfig) {
        pega.widget.Overlay.superclass.constructor.call(this, el, userConfig);
    };

    var Lang = pega.lang,
        CustomEvent = pega.util.CustomEvent,
        Module = pega.widget.Module,
        Event = pega.util.Event,
        Dom = pega.util.Dom,
        Config = pega.util.Config,
        Overlay = pega.widget.Overlay,

        m_oIFrameTemplate,

        /**
        * Constant representing the name of the Overlay's events
        * @property EVENT_TYPES
        * @private
        * @final
        * @type Object
        */
        EVENT_TYPES = {
            "BEFORE_MOVE": "beforeMove",
            "MOVE": "move"
        },

        /**
        * Constant representing the Overlay's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "X": { 
                key: "x", 
                validator: Lang.isNumber, 
                suppressEvent: true, 
                supercedes: ["iframe"]
            },

            "Y": { 
                key: "y", 
                validator: Lang.isNumber, 
                suppressEvent: true, 
                supercedes: ["iframe"]
            },

            "XY": { 
                key: "xy", 
                suppressEvent: true, 
                supercedes: ["iframe"] 
            },

            "CONTEXT": { 
                key: "context", 
                suppressEvent: true, 
                supercedes: ["iframe"] 
            },

            "FIXED_CENTER": { 
                key: "fixedcenter", 
                value: false, 
                validator: Lang.isBoolean, 
                supercedes: ["iframe", "visible"] 
            },

            "WIDTH": { 
                key: "width", 
                suppressEvent: true, 
                supercedes: ["context", "fixedcenter", "iframe"] 
            }, 

            "HEIGHT": { 
                key: "height", 
                suppressEvent: true, 
                supercedes: ["context", "fixedcenter", "iframe"] 
            },

            "ZINDEX": { 
                key: "zindex", 
                value: null 
            },

            "CONSTRAIN_TO_VIEWPORT": { 
                key: "constraintoviewport", 
                value: false, 
                validator: Lang.isBoolean, 
                supercedes: ["iframe", "x", "y", "xy"]
            }, 

            "IFRAME": { 
                key: "iframe", 
                value: (pega.env.ua.ie == 6 ? true : false), 
                validator: Lang.isBoolean, 
                supercedes: ["zindex"] 
            }
        };

    /**
    * The URL that will be placed in the iframe
    * @property pega.widget.Overlay.IFRAME_SRC
    * @static
    * @final
    * @type String
    */
    Overlay.IFRAME_SRC = "javascript:false;";

    /**
    * Number representing how much the iframe shim should be offset from each 
    * side of an Overlay instance, in pixels.
    * @property pega.widget.Overlay.IFRAME_SRC
    * @default 3
    * @static
    * @final
    * @type Number
    */
    Overlay.IFRAME_OFFSET = 3;

    /**
    * Number representing the minimum distance an Overlay instance should be 
    * positioned relative to the boundaries of the browser's viewport, in pixels.
    * @property pega.widget.Overlay.VIEWPORT_OFFSET
    * @default 10
    * @static
    * @final
    * @type Number
    */
    Overlay.VIEWPORT_OFFSET = 10;

    /**
    * Constant representing the top left corner of an element, used for 
    * configuring the context element alignment
    * @property pega.widget.Overlay.TOP_LEFT
    * @static
    * @final
    * @type String
    */
    Overlay.TOP_LEFT = "tl";

    /**
    * Constant representing the top right corner of an element, used for 
    * configuring the context element alignment
    * @property pega.widget.Overlay.TOP_RIGHT
    * @static
    * @final
    * @type String
    */
    Overlay.TOP_RIGHT = "tr";

    /**
    * Constant representing the top bottom left corner of an element, used for 
    * configuring the context element alignment
    * @property pega.widget.Overlay.BOTTOM_LEFT
    * @static
    * @final
    * @type String
    */
    Overlay.BOTTOM_LEFT = "bl";

    /**
    * Constant representing the bottom right corner of an element, used for 
    * configuring the context element alignment
    * @property pega.widget.Overlay.BOTTOM_RIGHT
    * @static
    * @final
    * @type String
    */
    Overlay.BOTTOM_RIGHT = "br";

    /**
    * Constant representing the default CSS class used for an Overlay
    * @property pega.widget.Overlay.CSS_OVERLAY
    * @static
    * @final
    * @type String
    */
    Overlay.CSS_OVERLAY = "yui-overlay";

    /**
    * A singleton CustomEvent used for reacting to the DOM event for 
    * window scroll
    * @event pega.widget.Overlay.windowScrollEvent
    */
    Overlay.windowScrollEvent = new CustomEvent("windowScroll");

    /**
    * A singleton CustomEvent used for reacting to the DOM event for
    * window resize
    * @event pega.widget.Overlay.windowResizeEvent
    */
    Overlay.windowResizeEvent = new CustomEvent("windowResize");

    /**
    * The DOM event handler used to fire the CustomEvent for window scroll
    * @method pega.widget.Overlay.windowScrollHandler
    * @static
    * @param {DOMEvent} e The DOM scroll event
    */
    Overlay.windowScrollHandler = function (e) {

        if (pega.env.ua.ie) {

            if (! window.scrollEnd) {
                window.scrollEnd = -1;
            }

            clearTimeout(window.scrollEnd);
    
            window.scrollEnd = setTimeout(function () { 
                Overlay.windowScrollEvent.fire(); 
            }, 1);
    
        } else {
            Overlay.windowScrollEvent.fire();
        }
    };

    /**
    * The DOM event handler used to fire the CustomEvent for window resize
    * @method pega.widget.Overlay.windowResizeHandler
    * @static
    * @param {DOMEvent} e The DOM resize event
    */
    Overlay.windowResizeHandler = function (e) {

        if (pega.env.ua.ie) {
            if (! window.resizeEnd) {
                window.resizeEnd = -1;
            }

            clearTimeout(window.resizeEnd);

            window.resizeEnd = setTimeout(function () {
                Overlay.windowResizeEvent.fire(); 
            }, 100);
        } else {
            Overlay.windowResizeEvent.fire();
        }
    };

    /**
    * A boolean that indicated whether the window resize and scroll events have 
    * already been subscribed to.
    * @property pega.widget.Overlay._initialized
    * @private
    * @type Boolean
    */
    Overlay._initialized = null;

    if (Overlay._initialized === null) {
        Event.on(window, "scroll", Overlay.windowScrollHandler);
        Event.on(window, "resize", Overlay.windowResizeHandler);
    
        Overlay._initialized = true;
    }

    pega.extend(Overlay, Module, {

        /**
        * The Overlay initialization method, which is executed for Overlay and  
        * all of its subclasses. This method is automatically called by the 
        * constructor, and  sets up all DOM references for pre-existing markup, 
        * and creates required markup if it is not already present.
        * @method init
        * @param {String} el The element ID representing the Overlay <em>OR</em>
        * @param {HTMLElement} el The element representing the Overlay
        * @param {Object} userConfig The configuration object literal 
        * containing the configuration that should be set for this Overlay. 
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {
    
            /*
                 Note that we don't pass the user config in here yet because we
                 only want it executed once, at the lowest subclass level
            */
    
            Overlay.superclass.init.call(this, el/*, userConfig*/);  

            this.beforeInitEvent.fire(Overlay);
            
            Dom.addClass(this.element, Overlay.CSS_OVERLAY);
            
            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            if (this.platform == "mac" && pega.env.ua.gecko) {

                if (! Config.alreadySubscribed(this.showEvent,
                    this.showMacGeckoScrollbars, this)) {

                    this.showEvent.subscribe(this.showMacGeckoScrollbars, 
                        this, true);

                }

                if (! Config.alreadySubscribed(this.hideEvent, 
                    this.hideMacGeckoScrollbars, this)) {

                    this.hideEvent.subscribe(this.hideMacGeckoScrollbars, 
                        this, true);

                }
            }

            this.initEvent.fire(Overlay);
        },
        
        /**
        * Initializes the custom events for Overlay which are fired  
        * automatically at appropriate times by the Overlay class.
        * @method initEvents
        */
        initEvents: function () {
    
            Overlay.superclass.initEvents.call(this);
            
            var SIGNATURE = CustomEvent.LIST;
            
            /**
            * CustomEvent fired before the Overlay is moved.
            * @event beforeMoveEvent
            * @param {Number} x x coordinate
            * @param {Number} y y coordinate
            */
            this.beforeMoveEvent = this.createEvent(EVENT_TYPES.BEFORE_MOVE);
            this.beforeMoveEvent.signature = SIGNATURE;
            
            /**
            * CustomEvent fired after the Overlay is moved.
            * @event moveEvent
            * @param {Number} x x coordinate
            * @param {Number} y y coordinate
            */
            this.moveEvent = this.createEvent(EVENT_TYPES.MOVE);
            this.moveEvent.signature = SIGNATURE;
        
        },
        
        /**
        * Initializes the class's configurable properties which can be changed 
        * using the Overlay's Config object (cfg).
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {
    
            Overlay.superclass.initDefaultConfig.call(this);
            
            
            // Add overlay config properties //
            
            /**
            * The absolute x-coordinate position of the Overlay
            * @config x
            * @type Number
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.X.key, { 
    
                handler: this.configX, 
                validator: DEFAULT_CONFIG.X.validator, 
                suppressEvent: DEFAULT_CONFIG.X.suppressEvent, 
                supercedes: DEFAULT_CONFIG.X.supercedes
    
            });

            /**
            * The absolute y-coordinate position of the Overlay
            * @config y
            * @type Number
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.Y.key, {

                handler: this.configY, 
                validator: DEFAULT_CONFIG.Y.validator, 
                suppressEvent: DEFAULT_CONFIG.Y.suppressEvent, 
                supercedes: DEFAULT_CONFIG.Y.supercedes

            });
    
            /**
            * An array with the absolute x and y positions of the Overlay
            * @config xy
            * @type Number[]
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.XY.key, {
            
                handler: this.configXY, 
                suppressEvent: DEFAULT_CONFIG.XY.suppressEvent, 
                supercedes: DEFAULT_CONFIG.XY.supercedes
            
            });
    
            /**
            * The array of context arguments for context-sensitive positioning.  
            * The format is: [id or element, element corner, context corner]. 
            * For example, setting this property to ["img1", "tl", "bl"] would 
            * align the Overlay's top left corner to the context element's 
            * bottom left corner.
            * @config context
            * @type Array
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.CONTEXT.key, {
            
                handler: this.configContext, 
                suppressEvent: DEFAULT_CONFIG.CONTEXT.suppressEvent, 
                supercedes: DEFAULT_CONFIG.CONTEXT.supercedes
            
            });

            /**
            * True if the Overlay should be anchored to the center of 
            * the viewport.
            * @config fixedcenter
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.FIXED_CENTER.key, {
            
                handler: this.configFixedCenter,
                value: DEFAULT_CONFIG.FIXED_CENTER.value, 
                validator: DEFAULT_CONFIG.FIXED_CENTER.validator, 
                supercedes: DEFAULT_CONFIG.FIXED_CENTER.supercedes
            
            });
    
            /**
            * CSS width of the Overlay.
            * @config width
            * @type String
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.WIDTH.key, {

                handler: this.configWidth, 
                suppressEvent: DEFAULT_CONFIG.WIDTH.suppressEvent, 
                supercedes: DEFAULT_CONFIG.WIDTH.supercedes

            });

            /**
            * CSS height of the Overlay.
            * @config height
            * @type String
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.HEIGHT.key, {

                handler: this.configHeight, 
                suppressEvent: DEFAULT_CONFIG.HEIGHT.suppressEvent, 
                supercedes: DEFAULT_CONFIG.HEIGHT.supercedes
            
            });
            
            /**
            * CSS z-index of the Overlay.
            * @config zIndex
            * @type Number
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.ZINDEX.key, {

                handler: this.configzIndex,
                value: DEFAULT_CONFIG.ZINDEX.value

            });

            /**
            * True if the Overlay should be prevented from being positioned 
            * out of the viewport.
            * @config constraintoviewport
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.key, {

                handler: this.configConstrainToViewport, 
                value: DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.value, 
                validator: DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.validator, 
                supercedes: DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.supercedes

            });

            /**
            * @config iframe
            * @description Boolean indicating whether or not the Overlay should 
            * have an IFRAME shim; used to prevent SELECT elements from 
            * poking through an Overlay instance in IE6.  When set to "true", 
            * the iframe shim is created when the Overlay instance is intially
            * made visible.
            * @type Boolean
            * @default true for IE6 and below, false for all other browsers.
            */
            this.cfg.addProperty(DEFAULT_CONFIG.IFRAME.key, {

                handler: this.configIframe, 
                value: DEFAULT_CONFIG.IFRAME.value, 
                validator: DEFAULT_CONFIG.IFRAME.validator, 
                supercedes: DEFAULT_CONFIG.IFRAME.supercedes

            });
        },

        /**
        * Moves the Overlay to the specified position. This function is  
        * identical to calling this.cfg.setProperty("xy", [x,y]);
        * @method moveTo
        * @param {Number} x The Overlay's new x position
        * @param {Number} y The Overlay's new y position
        */
        moveTo: function (x, y) {
            this.cfg.setProperty("xy", [x, y]);
        },

        /**
        * Adds a CSS class ("hide-scrollbars") and removes a CSS class 
        * ("show-scrollbars") to the Overlay to fix a bug in Gecko on Mac OS X 
        * (https://bugzilla.mozilla.org/show_bug.cgi?id=187435)
        * @method hideMacGeckoScrollbars
        */
        hideMacGeckoScrollbars: function () {
    
            Dom.removeClass(this.element, "show-scrollbars");
            Dom.addClass(this.element, "hide-scrollbars");
    
        },

        /**
        * Adds a CSS class ("show-scrollbars") and removes a CSS class 
        * ("hide-scrollbars") to the Overlay to fix a bug in Gecko on Mac OS X 
        * (https://bugzilla.mozilla.org/show_bug.cgi?id=187435)
        * @method showMacGeckoScrollbars
        */
        showMacGeckoScrollbars: function () {
    
            Dom.removeClass(this.element, "hide-scrollbars");
            Dom.addClass(this.element, "show-scrollbars");
    
        },

        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        /**
        * The default event handler fired when the "visible" property is 
        * changed.  This method is responsible for firing showEvent
        * and hideEvent.
        * @method configVisible
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configVisible: function (type, args, obj) {

            var visible = args[0],
                currentVis = Dom.getStyle(this.element, "visibility"),
                effect = this.cfg.getProperty("effect"),
                effectInstances = [],
                isMacGecko = (this.platform == "mac" && pega.env.ua.gecko),
                alreadySubscribed = Config.alreadySubscribed,
                eff, ei, e, i, j, k, h,
                nEffects,
                nEffectInstances;

            if (currentVis == "inherit") {
                e = this.element.parentNode;

                while (e.nodeType != 9 && e.nodeType != 11) {
                    currentVis = Dom.getStyle(e, "visibility");

                    if (currentVis != "inherit") { 
                        break; 
                    }

                    e = e.parentNode;
                }

                if (currentVis == "inherit") {
                    currentVis = "visible";
                }
            }

            if (effect) {
                if (effect instanceof Array) {
                    nEffects = effect.length;

                    for (i = 0; i < nEffects; i++) {
                        eff = effect[i];
                        effectInstances[effectInstances.length] = 
                            eff.effect(this, eff.duration);

                    }
                } else {
                    effectInstances[effectInstances.length] = 
                        effect.effect(this, effect.duration);
                }
            }


            if (visible) { // Show
                if (isMacGecko) {
                    this.showMacGeckoScrollbars();
                }

                if (effect) { // Animate in
                    if (visible) { // Animate in if not showing
                        if (currentVis != "visible" || currentVis === "") {
                            this.beforeShowEvent.fire();
                            nEffectInstances = effectInstances.length;

                            for (j = 0; j < nEffectInstances; j++) {
                                ei = effectInstances[j];
                                if (j === 0 && !alreadySubscribed(
                                        ei.animateInCompleteEvent, 
                                        this.showEvent.fire, this.showEvent)) {

                                    /*
                                         Delegate showEvent until end 
                                         of animateInComplete
                                    */

                                    ei.animateInCompleteEvent.subscribe(
                                     this.showEvent.fire, this.showEvent, true);
                                }
                                ei.animateIn();
                            }
                        }
                    }
                } else { // Show
                    if (currentVis != "visible" || currentVis === "") {
                        this.beforeShowEvent.fire();

                        Dom.setStyle(this.element, "visibility", "visible");
						Dom.setStyle(this.innerElement, "display", "block");
						
                        this.cfg.refireEvent("iframe");
                        this.showEvent.fire();
                    }
                }
            } else { // Hide

                if (isMacGecko) {
                    this.hideMacGeckoScrollbars();
                }
                    
                if (effect) { // Animate out if showing
                    if (currentVis == "visible") {
                        this.beforeHideEvent.fire();

                        nEffectInstances = effectInstances.length;
                        for (k = 0; k < nEffectInstances; k++) {
                            h = effectInstances[k];
    
                            if (k === 0 && !alreadySubscribed(
                                h.animateOutCompleteEvent, this.hideEvent.fire, 
                                this.hideEvent)) {
    
                                /*
                                     Delegate hideEvent until end 
                                     of animateOutComplete
                                */
    
                                h.animateOutCompleteEvent.subscribe(
                                    this.hideEvent.fire, this.hideEvent, true);
    
                            }
                            h.animateOut();
                        }

                    } else if (currentVis === "") {
                        Dom.setStyle(this.element, "visibility", "hidden");
                    }

                } else { // Simple hide

                    if (currentVis == "visible" || currentVis === "") {
                        this.beforeHideEvent.fire();
                        Dom.setStyle(this.element, "visibility", "hidden");
						Dom.setStyle(this.innerElement, "display", "none");
                        this.hideEvent.fire();
                    }
                }
            }
        },

        /**
        * Center event handler used for centering on scroll/resize, but only if 
        * the Overlay is visible
        * @method doCenterOnDOMEvent
        */
        doCenterOnDOMEvent: function () {
            if (this.cfg.getProperty("visible")) {
	       //Added if condition to stop modal dialog being centered in IE8 when dragged and dropped (Desktop event issue)
                //BUG-44845
	       if(!(pega && pega.u && pega.u.d && pega.u.d.isModalLoaded() && this.id=="modaldialog"))	
                	this.center();
            }
        },

        /**
        * The default event handler fired when the "fixedcenter" property 
        * is changed.
        * @method configFixedCenter
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configFixedCenter: function (type, args, obj) {

            var val = args[0],
                alreadySubscribed = Config.alreadySubscribed,
                windowResizeEvent = Overlay.windowResizeEvent,
                windowScrollEvent = Overlay.windowScrollEvent;

            if (val) {
                this.center();

                if (!alreadySubscribed(this.beforeShowEvent, this.center, this)) {
                    this.beforeShowEvent.subscribe(this.center);
                }

                if (!alreadySubscribed(windowResizeEvent, this.doCenterOnDOMEvent, this)) {
                    windowResizeEvent.subscribe(this.doCenterOnDOMEvent, this, true);
                }

                if (!alreadySubscribed(windowScrollEvent, this.doCenterOnDOMEvent, this)) {
                    windowScrollEvent.subscribe(this.doCenterOnDOMEvent, this, true);
                }

            } else {
                this.beforeShowEvent.unsubscribe(this.center);

                windowResizeEvent.unsubscribe(this.doCenterOnDOMEvent, this);
                windowScrollEvent.unsubscribe(this.doCenterOnDOMEvent, this);
            }
        },
        
        /**
        * The default event handler fired when the "height" property is changed.
        * @method configHeight
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configHeight: function (type, args, obj) {

            var height = args[0],
                el = this.element;

            Dom.setStyle(el, "height", height);
            this.cfg.refireEvent("iframe");
        },

        /**
        * The default event handler fired when the "width" property is changed.
        * @method configWidth
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configWidth: function (type, args, obj) {

            var width = args[0],
                el = this.element;
    
            Dom.setStyle(el, "width", width);
            this.cfg.refireEvent("iframe");
        },
        
        /**
        * The default event handler fired when the "zIndex" property is changed.
        * @method configzIndex
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configzIndex: function (type, args, obj) {

            var zIndex = args[0],
                el = this.element;

            if (! zIndex) {
                zIndex = Dom.getStyle(el, "zIndex");
                if (! zIndex || isNaN(zIndex)) {
                    zIndex = 0;
                }
            }

            if (this.iframe || this.cfg.getProperty("iframe") === true) {
                if (zIndex <= 0) {
                    zIndex = 1;
                }
            }

            Dom.setStyle(el, "zIndex", zIndex);
            this.cfg.setProperty("zIndex", zIndex, true);

            if (this.iframe) {
                this.stackIframe();
            }
        },

        /**
        * The default event handler fired when the "xy" property is changed.
        * @method configXY
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configXY: function (type, args, obj) {

            var pos = args[0],
                x = pos[0],
                y = pos[1];

            this.cfg.setProperty("x", x);
            this.cfg.setProperty("y", y);

            this.beforeMoveEvent.fire([x, y]);

            x = this.cfg.getProperty("x");
            y = this.cfg.getProperty("y");


            this.cfg.refireEvent("iframe");
            this.moveEvent.fire([x, y]);
        },

        /**
        * The default event handler fired when the "x" property is changed.
        * @method configX
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configX: function (type, args, obj) {

            var x = args[0],
                y = this.cfg.getProperty("y");

            this.cfg.setProperty("x", x, true);
            this.cfg.setProperty("y", y, true);

            this.beforeMoveEvent.fire([x, y]);

            x = this.cfg.getProperty("x");
            y = this.cfg.getProperty("y");
            
            Dom.setX(this.element, x, true);

            this.cfg.setProperty("xy", [x, y], true);

            this.cfg.refireEvent("iframe");
            this.moveEvent.fire([x, y]);
        },

        /**
        * The default event handler fired when the "y" property is changed.
        * @method configY
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configY: function (type, args, obj) {

            var x = this.cfg.getProperty("x"),
                y = args[0];

            this.cfg.setProperty("x", x, true);
            this.cfg.setProperty("y", y, true);

            this.beforeMoveEvent.fire([x, y]);

            x = this.cfg.getProperty("x");
            y = this.cfg.getProperty("y");

            Dom.setY(this.element, y, true);

            this.cfg.setProperty("xy", [x, y], true);

            this.cfg.refireEvent("iframe");
            this.moveEvent.fire([x, y]);
        },
        
        /**
        * Shows the iframe shim, if it has been enabled.
        * @method showIframe
        */
        showIframe: function () {

            var oIFrame = this.iframe,
                oParentNode;

            if (oIFrame) {
                oParentNode = this.element.parentNode;

                if (oParentNode != oIFrame.parentNode) {
                    this._addToParent(oParentNode, oIFrame);
                }
                oIFrame.style.display = "block";
            }
        },

        /**
        * Hides the iframe shim, if it has been enabled.
        * @method hideIframe
        */
        hideIframe: function () {
            if (this.iframe) {
                this.iframe.style.display = "none";
            }
        },

        /**
        * Syncronizes the size and position of iframe shim to that of its 
        * corresponding Overlay instance.
        * @method syncIframe
        */
        syncIframe: function () {

            var oIFrame = this.iframe,
                oElement = this.element,
                nOffset = Overlay.IFRAME_OFFSET,
                nDimensionOffset = (nOffset * 2),
                aXY;

            if (oIFrame) {
                // Size <iframe>
                oIFrame.style.width = (oElement.offsetWidth + nDimensionOffset + "px");
                oIFrame.style.height = (oElement.offsetHeight + nDimensionOffset + "px");

                // Position <iframe>
                aXY = this.cfg.getProperty("xy");

                if (!Lang.isArray(aXY) || (isNaN(aXY[0]) || isNaN(aXY[1]))) {
                    this.syncPosition();
                    aXY = this.cfg.getProperty("xy");
                }
                Dom.setXY(oIFrame, [(aXY[0] - nOffset), (aXY[1] - nOffset)]);
            }
        },

        /**
         * Sets the zindex of the iframe shim, if it exists, based on the zindex of
         * the Overlay element. The zindex of the iframe is set to be one less 
         * than the Overlay element's zindex.
         * 
         * <p>NOTE: This method will not bump up the zindex of the Overlay element
         * to ensure that the iframe shim has a non-negative zindex.
         * If you require the iframe zindex to be 0 or higher, the zindex of 
         * the Overlay element should be set to a value greater than 0, before 
         * this method is called.
         * </p>
         * @method stackIframe
         */
        stackIframe: function () {
            if (this.iframe) {
                var overlayZ = Dom.getStyle(this.element, "zIndex");
                if (!pega.lang.isUndefined(overlayZ) && !isNaN(overlayZ)) {
                    Dom.setStyle(this.iframe, "zIndex", (overlayZ - 1));
                }
            }
        },

        /**
        * The default event handler fired when the "iframe" property is changed.
        * @method configIframe
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configIframe: function (type, args, obj) {

            var bIFrame = args[0];

            function createIFrame() {

                var oIFrame = this.iframe,
                    oElement = this.element,
                    oParent;

                if (!oIFrame) {
                    if (!m_oIFrameTemplate) {
                        m_oIFrameTemplate = document.createElement("iframe");

                        if (this.isSecure) {
                            m_oIFrameTemplate.src = Overlay.IFRAME_SRC;
                        }

                        /*
                            Set the opacity of the <iframe> to 0 so that it 
                            doesn't modify the opacity of any transparent 
                            elements that may be on top of it (like a shadow).
                        */

                        if (pega.env.ua.ie) {
                            m_oIFrameTemplate.style.filter = "alpha(opacity=0)";
                            /*
                                 Need to set the "frameBorder" property to 0 
                                 supress the default <iframe> border in IE.  
                                 Setting the CSS "border" property alone 
                                 doesn't supress it.
                            */
                            m_oIFrameTemplate.frameBorder = 0;
                        }
                        else {
                            m_oIFrameTemplate.style.opacity = "0";
                        }

                        m_oIFrameTemplate.style.position = "absolute";
                        m_oIFrameTemplate.style.border = "none";
                        m_oIFrameTemplate.style.margin = "0";
                        m_oIFrameTemplate.style.padding = "0";
                        m_oIFrameTemplate.style.display = "none";
                    }

                    oIFrame = m_oIFrameTemplate.cloneNode(false);
                    oParent = oElement.parentNode;

                    var parentNode = oParent || document.body;

                    this._addToParent(parentNode, oIFrame);
                    this.iframe = oIFrame;
                }

                /*
                     Show the <iframe> before positioning it since the "setXY" 
                     method of DOM requires the element be in the document 
                     and visible.
                */
                this.showIframe();

                /*
                     Syncronize the size and position of the <iframe> to that 
                     of the Overlay.
                */
                this.syncIframe();
                this.stackIframe();

                // Add event listeners to update the <iframe> when necessary
                if (!this._hasIframeEventListeners) {
                    this.showEvent.subscribe(this.showIframe);
                    this.hideEvent.subscribe(this.hideIframe);
                    this.changeContentEvent.subscribe(this.syncIframe);

                    this._hasIframeEventListeners = true;
                }
            }

            function onBeforeShow() {
                createIFrame.call(this);
                this.beforeShowEvent.unsubscribe(onBeforeShow);
                this._iframeDeferred = false;
            }

            if (bIFrame) { // <iframe> shim is enabled

                if (this.cfg.getProperty("visible")) {
                    createIFrame.call(this);
                } else {
                    if (!this._iframeDeferred) {
                        this.beforeShowEvent.subscribe(onBeforeShow);
                        this._iframeDeferred = true;
                    }
                }

            } else {    // <iframe> shim is disabled
                this.hideIframe();

                if (this._hasIframeEventListeners) {
                    this.showEvent.unsubscribe(this.showIframe);
                    this.hideEvent.unsubscribe(this.hideIframe);
                    this.changeContentEvent.unsubscribe(this.syncIframe);

                    this._hasIframeEventListeners = false;
                }
            }
        },

        /**
         * Set's the container's XY value from DOM if not already set.
         * 
         * Differs from syncPosition, in that the XY value is only sync'd with DOM if 
         * not already set. The method also refire's the XY config property event, so any
         * beforeMove, Move event listeners are invoked.
         * 
         * @method _primeXYFromDOM
         * @protected
         */
        _primeXYFromDOM : function() {
            if (pega.lang.isUndefined(this.cfg.getProperty("xy"))) {
                // Set CFG XY based on DOM XY
                this.syncPosition();
                // Account for XY being set silently in syncPosition (no moveTo fired/called)
                this.cfg.refireEvent("xy");
                this.beforeShowEvent.unsubscribe(this._primeXYFromDOM);
            }
        },

        /**
        * The default event handler fired when the "constraintoviewport" 
        * property is changed.
        * @method configConstrainToViewport
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for 
        * the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configConstrainToViewport: function (type, args, obj) {
            var val = args[0];

            if (val) {
                if (! Config.alreadySubscribed(this.beforeMoveEvent, this.enforceConstraints, this)) {
                    this.beforeMoveEvent.subscribe(this.enforceConstraints, this, true);
                }
                if (! Config.alreadySubscribed(this.beforeShowEvent, this._primeXYFromDOM)) {
                    this.beforeShowEvent.subscribe(this._primeXYFromDOM);
                }
            } else {
                this.beforeShowEvent.unsubscribe(this._primeXYFromDOM);
                this.beforeMoveEvent.unsubscribe(this.enforceConstraints, this);
            }
        },

         /**
        * The default event handler fired when the "context" property 
        * is changed.
        * @method configContext
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configContext: function (type, args, obj) {
    
            var contextArgs = args[0],
                contextEl,
                elementMagnetCorner,
                contextMagnetCorner;

            if (contextArgs) {
                contextEl = contextArgs[0];
                elementMagnetCorner = contextArgs[1];
                contextMagnetCorner = contextArgs[2];
                
                if (contextEl) {
                    if (typeof contextEl == "string") {
                        this.cfg.setProperty("context", 
                            [document.getElementById(contextEl), 
                                elementMagnetCorner, contextMagnetCorner], 
                                true);
                    }
                    
                    if (elementMagnetCorner && contextMagnetCorner) {
                        this.align(elementMagnetCorner, contextMagnetCorner);
                    }
                }
            }
        },

        // END BUILT-IN PROPERTY EVENT HANDLERS //
        /**
        * Aligns the Overlay to its context element using the specified corner 
        * points (represented by the constants TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, 
        * and BOTTOM_RIGHT.
        * @method align
        * @param {String} elementAlign  The String representing the corner of 
        * the Overlay that should be aligned to the context element
        * @param {String} contextAlign  The corner of the context element 
        * that the elementAlign corner should stick to.
        */
        align: function (elementAlign, contextAlign) {

            var contextArgs = this.cfg.getProperty("context"),
                me = this,
                context,
                element,
                contextRegion;

            function doAlign(v, h) {
    
                switch (elementAlign) {
    
                case Overlay.TOP_LEFT:
                    me.moveTo(h, v);
                    break;
    
                case Overlay.TOP_RIGHT:
                    me.moveTo((h - element.offsetWidth), v);
                    break;
    
                case Overlay.BOTTOM_LEFT:
                    me.moveTo(h, (v - element.offsetHeight));
                    break;
    
                case Overlay.BOTTOM_RIGHT:
                    me.moveTo((h - element.offsetWidth), 
                        (v - element.offsetHeight));
                    break;
                }
            }
    
    
            if (contextArgs) {
            
                context = contextArgs[0];
                element = this.element;
                me = this;
                
                if (! elementAlign) {
                    elementAlign = contextArgs[1];
                }
                
                if (! contextAlign) {
                    contextAlign = contextArgs[2];
                }
                
                if (element && context) {
                    contextRegion = Dom.getRegion(context);

                    switch (contextAlign) {
    
                    case Overlay.TOP_LEFT:
                        doAlign(contextRegion.top, contextRegion.left);
                        break;
    
                    case Overlay.TOP_RIGHT:
                        doAlign(contextRegion.top, contextRegion.right);
                        break;
    
                    case Overlay.BOTTOM_LEFT:
                        doAlign(contextRegion.bottom, contextRegion.left);
                        break;
    
                    case Overlay.BOTTOM_RIGHT:
                        doAlign(contextRegion.bottom, contextRegion.right);
                        break;
                    }
    
                }
    
            }
            
        },

        /**
        * The default event handler executed when the moveEvent is fired, if the 
        * "constraintoviewport" is set to true.
        * @method enforceConstraints
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        enforceConstraints: function (type, args, obj) {
            var pos = args[0];
            var cXY = this.getConstrainedXY(pos[0], pos[1]);
            this.cfg.setProperty("x", cXY[0], true);
            this.cfg.setProperty("y", cXY[1], true);
            this.cfg.setProperty("xy", cXY, true);
        },

        /**
         * Given x, y coordinate values, returns the calculated coordinates required to 
         * position the Overlay if it is to be constrained to the viewport, based on the 
         * current element size, viewport dimensions and scroll values.
         *
         * @param {Number} x The X coordinate value to be constrained
         * @param {Number} y The Y coordinate value to be constrained
         * @return {Array} The constrained x and y coordinates at index 0 and 1 respectively;
         */
        getConstrainedXY: function(x, y) {

            var nViewportOffset = Overlay.VIEWPORT_OFFSET,
                viewPortWidth = Dom.getViewportWidth(),
                viewPortHeight = Dom.getViewportHeight(),
                offsetHeight = this.element.offsetHeight,
                offsetWidth = this.element.offsetWidth,
                scrollX = Dom.getDocumentScrollLeft(),
                scrollY = Dom.getDocumentScrollTop();

            var xNew = x;
            var yNew = y;

            if (offsetWidth + nViewportOffset < viewPortWidth) {

                var leftConstraint = scrollX + nViewportOffset;
                var rightConstraint = scrollX + viewPortWidth - offsetWidth - nViewportOffset;

                if (x < leftConstraint) {
                    xNew = leftConstraint;
                } else if (x > rightConstraint) {
                    xNew = rightConstraint;
                }
            } else {
                xNew = nViewportOffset + scrollX;
            }

            if (offsetHeight + nViewportOffset < viewPortHeight) {

                var topConstraint = scrollY + nViewportOffset;
                var bottomConstraint = scrollY + viewPortHeight - offsetHeight - nViewportOffset;

                if (y < topConstraint) {
                    yNew  = topConstraint;
                } else if (y  > bottomConstraint) {
                    yNew  = bottomConstraint;
                }
            } else {
                yNew = nViewportOffset + scrollY;
            }

            return [xNew, yNew];
        },

        /**
        * Centers the container in the viewport.
        * @method center
        */
        center: function () {
            var nViewportOffset = Overlay.VIEWPORT_OFFSET,
                elementWidth = this.element.offsetWidth,
                elementHeight = this.element.offsetHeight,
                viewPortWidth = Dom.getViewportWidth(),
                viewPortHeight = Dom.getViewportHeight(),
                x,
                y;
	
            if (elementWidth < viewPortWidth) {
                x = (viewPortWidth / 2) - (elementWidth / 2) + Dom.getDocumentScrollLeft();
            } else {
                x = nViewportOffset + Dom.getDocumentScrollLeft();
            }

            if (elementHeight < viewPortHeight) {
                y = (viewPortHeight / 2) - (elementHeight / 2) + Dom.getDocumentScrollTop();
            } else {
                y = nViewportOffset + Dom.getDocumentScrollTop();
            }
            this.cfg.setProperty("xy", [parseInt(x, 10), parseInt(y, 10)]);
            this.cfg.refireEvent("iframe");
        },

        /**
        * Synchronizes the Panel's "xy", "x", and "y" properties with the 
        * Panel's position in the DOM. This is primarily used to update  
        * position information during drag & drop.
        * @method syncPosition
        */
        syncPosition: function () {

            var pos = Dom.getXY(this.element);

            this.cfg.setProperty("x", pos[0], true);
            this.cfg.setProperty("y", pos[1], true);
            this.cfg.setProperty("xy", pos, true);

        },

        /**
        * Event handler fired when the resize monitor element is resized.
        * @method onDomResize
        * @param {DOMEvent} e The resize DOM event
        * @param {Object} obj The scope object
        */
        onDomResize: function (e, obj) {

            var me = this;

            Overlay.superclass.onDomResize.call(this, e, obj);

            setTimeout(function () {
                me.syncPosition();
                me.cfg.refireEvent("iframe");
                me.cfg.refireEvent("context");
            }, 0);
    
        },

        /**
        * Places the Overlay on top of all other instances of 
        * pega.widget.Overlay.
        * @method bringToTop
        */
        bringToTop: function () {

            var aOverlays = [],
                oElement = this.element;

            function compareZIndexDesc(p_oOverlay1, p_oOverlay2) {

                var sZIndex1 = Dom.getStyle(p_oOverlay1, "zIndex"),
                    sZIndex2 = Dom.getStyle(p_oOverlay2, "zIndex"),

                    nZIndex1 = (!sZIndex1 || isNaN(sZIndex1)) ? 0 : parseInt(sZIndex1, 10),
                    nZIndex2 = (!sZIndex2 || isNaN(sZIndex2)) ? 0 : parseInt(sZIndex2, 10);

                if (nZIndex1 > nZIndex2) {
                    return -1;
                } else if (nZIndex1 < nZIndex2) {
                    return 1;
                } else {
                    return 0;
                }
            }

            function isOverlayElement(p_oElement) {

                var oOverlay = Dom.hasClass(p_oElement, Overlay.CSS_OVERLAY),
                    Panel = pega.widget.Panel;

                if (oOverlay && !Dom.isAncestor(oElement, oOverlay)) {
                    if (Panel && Dom.hasClass(p_oElement, Panel.CSS_PANEL)) {
                        aOverlays[aOverlays.length] = p_oElement.parentNode;
                    } else {
                        aOverlays[aOverlays.length] = p_oElement;
                    }
                }
            }

            Dom.getElementsBy(isOverlayElement, "DIV", document.body);

            aOverlays.sort(compareZIndexDesc);

            var oTopOverlay = aOverlays[0],
                nTopZIndex;

            if (oTopOverlay) {
                nTopZIndex = Dom.getStyle(oTopOverlay, "zIndex");

                if (!isNaN(nTopZIndex)) {
                    var bRequiresBump = false;

                    if (oTopOverlay != oElement) {
                        bRequiresBump = true;
                    } else if (aOverlays.length > 1) {
                        var nNextZIndex = Dom.getStyle(aOverlays[1], "zIndex");
                        // Don't rely on DOM order to stack if 2 overlays are at the same zindex.
                        if (!isNaN(nNextZIndex) && (nTopZIndex == nNextZIndex)) {
                            bRequiresBump = true;
                        }
                    }
                    if (bRequiresBump) {
                        this.cfg.setProperty("zindex", (parseInt(nTopZIndex, 10) + 2));
                    }
                }
            }
        },

        /**
        * Removes the Overlay element from the DOM and sets all child 
        * elements to null.
        * @method destroy
        */
        destroy: function () {

            if (this.iframe) {
                this.iframe.parentNode.removeChild(this.iframe);
            }

            this.iframe = null;
        
            Overlay.windowResizeEvent.unsubscribe(
                this.doCenterOnDOMEvent, this);
    
            Overlay.windowScrollEvent.unsubscribe(
                this.doCenterOnDOMEvent, this);
        
            Overlay.superclass.destroy.call(this);
        },
        
        /**
        * Returns a String representation of the object.
        * @method toString
        * @return {String} The string representation of the Overlay.
        */
        toString: function () {
            return "Overlay " + this.id;
        }

    });
}());

(function () {
    
    /**
    * OverlayManager is used for maintaining the focus status of 
    * multiple Overlays.
    * @namespace pega.widget
    * @namespace pega.widget
    * @class OverlayManager
    * @constructor
    * @param {Array} overlays Optional. A collection of Overlays to register 
    * with the manager.
    * @param {Object} userConfig  The object literal representing the user 
    * configuration of the OverlayManager
    */
    pega.widget.OverlayManager = function (userConfig) {
        this.init(userConfig);
    };

    var Overlay = pega.widget.Overlay,
        Event = pega.util.Event,
        Dom = pega.util.Dom,
        Config = pega.util.Config,
        CustomEvent = pega.util.CustomEvent,
        OverlayManager = pega.widget.OverlayManager;
    
    /**
    * The CSS class representing a focused Overlay
    * @property OverlayManager.CSS_FOCUSED
    * @static
    * @final
    * @type String
    */
    OverlayManager.CSS_FOCUSED = "focused";
    
    OverlayManager.prototype = {
    
        /**
        * The class's constructor function
        * @property contructor
        * @type Function
        */
        constructor: OverlayManager,
        
        /**
        * The array of Overlays that are currently registered
        * @property overlays
        * @type pega.widget.Overlay[]
        */
        overlays: null,
        
        /**
        * Initializes the default configuration of the OverlayManager
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {
        
            /**
            * The collection of registered Overlays in use by 
            * the OverlayManager
            * @config overlays
            * @type pega.widget.Overlay[]
            * @default null
            */
            this.cfg.addProperty("overlays", { suppressEvent: true } );
        
            /**
            * The default DOM event that should be used to focus an Overlay
            * @config focusevent
            * @type String
            * @default "mousedown"
            */
            this.cfg.addProperty("focusevent", { value: "mousedown" } );

        },

        /**
        * Initializes the OverlayManager
        * @method init
        * @param {Overlay[]} overlays Optional. A collection of Overlays to 
        * register with the manager.
        * @param {Object} userConfig  The object literal representing the user 
        * configuration of the OverlayManager
        */
        init: function (userConfig) {

            /**
            * The OverlayManager's Config object used for monitoring 
            * configuration properties.
            * @property cfg
            * @type Config
            */
            this.cfg = new Config(this);

            this.initDefaultConfig();

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }
            this.cfg.fireQueue();

            /**
            * The currently activated Overlay
            * @property activeOverlay
            * @private
            * @type pega.widget.Overlay
            */
            var activeOverlay = null;

            /**
            * Returns the currently focused Overlay
            * @method getActive
            * @return {Overlay} The currently focused Overlay
            */
            this.getActive = function () {
                return activeOverlay;
            };

            /**
            * Focuses the specified Overlay
            * @method focus
            * @param {Overlay} overlay The Overlay to focus
            * @param {String} overlay The id of the Overlay to focus
            */
            this.focus = function (overlay) {
                var o = this.find(overlay);
                if (o) {
                    if (activeOverlay != o) {
                        if (activeOverlay) {
                            activeOverlay.blur();
                        }
                        this.bringToTop(o);

                        activeOverlay = o;

                        Dom.addClass(activeOverlay.element, 
                            OverlayManager.CSS_FOCUSED);

                        o.focusEvent.fire();
                    }
                }
            };
        
            /**
            * Removes the specified Overlay from the manager
            * @method remove
            * @param {Overlay} overlay The Overlay to remove
            * @param {String} overlay The id of the Overlay to remove
            */
            this.remove = function (overlay) {
                var o = this.find(overlay), 
                        originalZ;
                if (o) {
                    if (activeOverlay == o) {
                        activeOverlay = null;
                    }

                    var bDestroyed = (o.element === null && o.cfg === null) ? true : false;

                    if (!bDestroyed) {
                        // Set it's zindex so that it's sorted to the end.
                        originalZ = Dom.getStyle(o.element, "zIndex");
                        o.cfg.setProperty("zIndex", -1000, true);
                    }

                    this.overlays.sort(this.compareZIndexDesc);
                    this.overlays = this.overlays.slice(0, (this.overlays.length - 1));

                    o.hideEvent.unsubscribe(o.blur);
                    o.destroyEvent.unsubscribe(this._onOverlayDestroy, o);

                    if (!bDestroyed) {
                        Event.removeListener(o.element, 
                                    this.cfg.getProperty("focusevent"), 
                                    this._onOverlayElementFocus);

                        o.cfg.setProperty("zIndex", originalZ, true);
                        o.cfg.setProperty("manager", null);
                    }

                    o.focusEvent.unsubscribeAll();
                    o.blurEvent.unsubscribeAll();

                    o.focusEvent = null;
                    o.blurEvent = null;

                    o.focus = null;
                    o.blur = null;
                }
            };

            /**
            * Removes focus from all registered Overlays in the manager
            * @method blurAll
            */
            this.blurAll = function () {
    
                var nOverlays = this.overlays.length,
                    i;

                if (nOverlays > 0) {
                    i = nOverlays - 1;

                    do {
                        this.overlays[i].blur();
                    }
                    while(i--);
                }
            };
        
            this._onOverlayBlur = function (p_sType, p_aArgs) {
                activeOverlay = null;
            };
        
            var overlays = this.cfg.getProperty("overlays");
        
            if (! this.overlays) {
                this.overlays = [];
            }
        
            if (overlays) {
                this.register(overlays);
                this.overlays.sort(this.compareZIndexDesc);
            }
        },
        
        
        /**
        * @method _onOverlayElementFocus
        * @description Event handler for the DOM event that is used to focus 
        * the Overlay instance as specified by the "focusevent" 
        * configuration property.
        * @private
        * @param {Event} p_oEvent Object representing the DOM event 
        * object passed back by the event utility (Event).
        */
        _onOverlayElementFocus: function (p_oEvent) {
        
            var oTarget = Event.getTarget(p_oEvent),
                oClose = this.close;
            
            if (oClose && (oTarget == oClose || Dom.isAncestor(oClose, oTarget))) {
                this.blur();
            } else {
                this.focus();
            }
        },
        
        
        /**
        * @method _onOverlayDestroy
        * @description "destroy" event handler for the Overlay.
        * @private
        * @param {String} p_sType String representing the name of the event  
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event 
        * was fired.
        * @param {Overlay} p_oOverlay Object representing the menu that 
        * fired the event.
        */
        _onOverlayDestroy: function (p_sType, p_aArgs, p_oOverlay) {
            this.remove(p_oOverlay);
        },
        
        /**
        * Registers an Overlay or an array of Overlays with the manager. Upon 
        * registration, the Overlay receives functions for focus and blur, 
        * along with CustomEvents for each.
        * @method register
        * @param {Overlay} overlay  An Overlay to register with the manager.
        * @param {Overlay[]} overlay  An array of Overlays to register with 
        * the manager.
        * @return {Boolean} True if any Overlays are registered.
        */
        register: function (overlay) {
        
            var mgr = this,
                zIndex,
                regcount,
                i,
                nOverlays;
        
            if (overlay instanceof Overlay) {

                overlay.cfg.addProperty("manager", { value: this } );

                overlay.focusEvent = overlay.createEvent("focus");
                overlay.focusEvent.signature = CustomEvent.LIST;

                overlay.blurEvent = overlay.createEvent("blur");
                overlay.blurEvent.signature = CustomEvent.LIST;
        
                overlay.focus = function () {
                    mgr.focus(this);
                };
        
                overlay.blur = function () {
                    if (mgr.getActive() == this) {
                        Dom.removeClass(this.element, OverlayManager.CSS_FOCUSED);
                        this.blurEvent.fire();
                    }
                };
        
                overlay.blurEvent.subscribe(mgr._onOverlayBlur);
                overlay.hideEvent.subscribe(overlay.blur);
                
                overlay.destroyEvent.subscribe(this._onOverlayDestroy, overlay, this);
        
                Event.on(overlay.element, this.cfg.getProperty("focusevent"), 
                            this._onOverlayElementFocus, null, overlay);
        
                zIndex = Dom.getStyle(overlay.element, "zIndex");

                if (!isNaN(zIndex)) {
                    overlay.cfg.setProperty("zIndex", parseInt(zIndex, 10));
                } else {
                    overlay.cfg.setProperty("zIndex", 0);
                }

                this.overlays.push(overlay);
                this.bringToTop(overlay);

                return true;

            } else if (overlay instanceof Array) {

                regcount = 0;
                nOverlays = overlay.length;

                for (i = 0; i < nOverlays; i++) {
                    if (this.register(overlay[i])) {
                        regcount++;
                    }
                }

                if (regcount > 0) {
                    return true;
                }
            } else {
                return false;
            }
        },

        /**
        * Places the specified Overlay instance on top of all other 
        * Overlay instances.
        * @method bringToTop
        * @param {pega.widget.Overlay} p_oOverlay Object representing an 
        * Overlay instance.
        * @param {String} p_oOverlay String representing the id of an 
        * Overlay instance.
        */        
        bringToTop: function (p_oOverlay) {

            var oOverlay = this.find(p_oOverlay),
                nTopZIndex,
                oTopOverlay,
                aOverlays;

            if (oOverlay) {

                aOverlays = this.overlays;
                aOverlays.sort(this.compareZIndexDesc);

                oTopOverlay = aOverlays[0];

                if (oTopOverlay) {
                    nTopZIndex = Dom.getStyle(oTopOverlay.element, "zIndex");

                    if (!isNaN(nTopZIndex)) {

                        var bRequiresBump = false;

                        if (oTopOverlay !== oOverlay) {
                            bRequiresBump = true;
                        } else if (aOverlays.length > 1) {
                            var nNextZIndex = Dom.getStyle(aOverlays[1].element, "zIndex");
                            // Don't rely on DOM order to stack if 2 overlays are at the same zindex.
                            if (!isNaN(nNextZIndex) && (nTopZIndex == nNextZIndex)) {
                                bRequiresBump = true;
                            }
                        }

                        if (bRequiresBump) {
                            oOverlay.cfg.setProperty("zindex", (parseInt(nTopZIndex, 10) + 2));
                        }
                    }
                    aOverlays.sort(this.compareZIndexDesc);
                }
            }
        },

        /**
        * Attempts to locate an Overlay by instance or ID.
        * @method find
        * @param {Overlay} overlay  An Overlay to locate within the manager
        * @param {String} overlay  An Overlay id to locate within the manager
        * @return {Overlay} The requested Overlay, if found, or null if it 
        * cannot be located.
        */
        find: function (overlay) {

            var aOverlays = this.overlays,
                nOverlays = aOverlays.length,
                i;

            if (nOverlays > 0) {
                i = nOverlays - 1;

                if (overlay instanceof Overlay) {
                    do {
                        if (aOverlays[i] == overlay) {
                            return aOverlays[i];
                        }
                    }
                    while(i--);

                } else if (typeof overlay == "string") {
                    do {
                        if (aOverlays[i].id == overlay) {
                            return aOverlays[i];
                        }
                    }
                    while(i--);
                }
                return null;
            }
        },
        
        /**
        * Used for sorting the manager's Overlays by z-index.
        * @method compareZIndexDesc
        * @private
        * @return {Number} 0, 1, or -1, depending on where the Overlay should 
        * fall in the stacking order.
        */
        compareZIndexDesc: function (o1, o2) {

            var zIndex1 = (o1.cfg) ? o1.cfg.getProperty("zIndex") : null, // Sort invalid (destroyed)
                zIndex2 = (o2.cfg) ? o2.cfg.getProperty("zIndex") : null; // objects at bottom.

            if (zIndex1 === null && zIndex2 === null) {
                return 0;
            } else if (zIndex1 === null){
                return 1;
            } else if (zIndex2 === null) {
                return -1;
            } else if (zIndex1 > zIndex2) {
                return -1;
            } else if (zIndex1 < zIndex2) {
                return 1;
            } else {
                return 0;
            }
        },
        
        /**
        * Shows all Overlays in the manager.
        * @method showAll
        */
        showAll: function () {
        
            var aOverlays = this.overlays,
                nOverlays = aOverlays.length,
                i;

            if (nOverlays > 0) {
                i = nOverlays - 1;
                do {
                    aOverlays[i].show();
                }
                while(i--);
            }
        },

        /**
        * Hides all Overlays in the manager.
        * @method hideAll
        */
        hideAll: function () {
        
            var aOverlays = this.overlays,
                nOverlays = aOverlays.length,
                i;

            if (nOverlays > 0) {
                i = nOverlays - 1;
                do {
                    aOverlays[i].hide();
                }
                while(i--);
            }
        },

        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the OverlayManager
        */
        toString: function () {
            return "OverlayManager";
        }
    };

}());

(function () {

    /**
    * Tooltip is an implementation of Overlay that behaves like an OS tooltip, 
    * displaying when the user mouses over a particular element, and 
    * disappearing on mouse out.
    * @namespace pega.widget
    * @class Tooltip
    * @extends pega.widget.Overlay
    * @constructor
    * @param {String} el The element ID representing the Tooltip <em>OR</em>
    * @param {HTMLElement} el The element representing the Tooltip
    * @param {Object} userConfig The configuration object literal containing 
    * the configuration that should be set for this Overlay. See configuration 
    * documentation for more details.
    */
    pega.widget.Tooltip = function (el, userConfig) {
        pega.widget.Tooltip.superclass.constructor.call(this, el, userConfig);
    };

    var Lang = pega.lang,
        Event = pega.util.Event,
        CustomEvent = pega.util.CustomEvent,
        Dom = pega.util.Dom,
        Tooltip = pega.widget.Tooltip,

        m_oShadowTemplate,

        /**
        * Constant representing the Tooltip's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "PREVENT_OVERLAP": { 
                key: "preventoverlap", 
                value: true, 
                validator: Lang.isBoolean, 
                supercedes: ["x", "y", "xy"] 
            },

            "SHOW_DELAY": { 
                key: "showdelay", 
                value: 200, 
                validator: Lang.isNumber 
            }, 

            "AUTO_DISMISS_DELAY": { 
                key: "autodismissdelay", 
                value: 5000, 
                validator: Lang.isNumber 
            }, 

            "HIDE_DELAY": { 
                key: "hidedelay", 
                value: 250, 
                validator: Lang.isNumber 
            }, 

            "TEXT": { 
                key: "text", 
                suppressEvent: true 
            }, 

            "CONTAINER": { 
                key: "container"
            },

            "DISABLED": {
                key: "disabled",
                value: false,
                suppressEvent: true
            }
        },

        /**
        * Constant representing the name of the Tooltip's events
        * @property EVENT_TYPES
        * @private
        * @final
        * @type Object
        */
        EVENT_TYPES = {
            "CONTEXT_MOUSE_OVER": "contextMouseOver",
            "CONTEXT_MOUSE_OUT": "contextMouseOut",
            "CONTEXT_TRIGGER": "contextTrigger"
        };

    /**
    * Constant representing the Tooltip CSS class
    * @property pega.widget.Tooltip.CSS_TOOLTIP
    * @static
    * @final
    * @type String
    */
    Tooltip.CSS_TOOLTIP = "yui-tt";

    /* 
        "hide" event handler that sets a Tooltip instance's "width"
        configuration property back to its original value before 
        "setWidthToOffsetWidth" was called.
    */
    function restoreOriginalWidth(p_sType, p_aArgs, p_oObject) {

        var sOriginalWidth = p_oObject[0],
            sNewWidth = p_oObject[1],
            oConfig = this.cfg,
            sCurrentWidth = oConfig.getProperty("width");

        if (sCurrentWidth == sNewWidth) {
            oConfig.setProperty("width", sOriginalWidth);
        }

        this.unsubscribe("hide", this._onHide, p_oObject);
    }

    /* 
        "beforeShow" event handler that sets a Tooltip instance's "width"
        configuration property to the value of its root HTML 
        elements's offsetWidth
    */

    function setWidthToOffsetWidth(p_sType, p_aArgs) {

        var oBody = document.body,
            oConfig = this.cfg,
            sOriginalWidth = oConfig.getProperty("width"),
            sNewWidth,
            oClone;

        if ((!sOriginalWidth || sOriginalWidth == "auto") && 
            (oConfig.getProperty("container") != oBody || 
            oConfig.getProperty("x") >= Dom.getViewportWidth() || 
            oConfig.getProperty("y") >= Dom.getViewportHeight())) {

            oClone = this.element.cloneNode(true);
            oClone.style.visibility = "hidden";
            oClone.style.top = "0px";
            oClone.style.left = "0px";

            oBody.appendChild(oClone);

            sNewWidth = (oClone.offsetWidth + "px");

            oBody.removeChild(oClone);
            oClone = null;

            oConfig.setProperty("width", sNewWidth);
            oConfig.refireEvent("xy");

            this.subscribe("hide", restoreOriginalWidth, [(sOriginalWidth || ""), sNewWidth]);
        }
    }

    // "onDOMReady" that renders the ToolTip

    function onDOMReady(p_sType, p_aArgs, p_oObject) {
        this.render(p_oObject);
    }

    //  "init" event handler that automatically renders the Tooltip

    function onInit() {
        Event.onDOMReady(onDOMReady, this.cfg.getProperty("container"), this);
    }

    pega.extend(Tooltip, pega.widget.Overlay, { 

        /**
        * The Tooltip initialization method. This method is automatically 
        * called by the constructor. A Tooltip is automatically rendered by 
        * the init method, and it also is set to be invisible by default, 
        * and constrained to viewport by default as well.
        * @method init
        * @param {String} el The element ID representing the Tooltip <em>OR</em>
        * @param {HTMLElement} el The element representing the Tooltip
        * @param {Object} userConfig The configuration object literal 
        * containing the configuration that should be set for this Tooltip. 
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {


            Tooltip.superclass.init.call(this, el);

            this.beforeInitEvent.fire(Tooltip);

            Dom.addClass(this.element, Tooltip.CSS_TOOLTIP);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            this.cfg.queueProperty("visible", false);
            this.cfg.queueProperty("constraintoviewport", true);

            this.setBody("");

            this.subscribe("beforeShow", setWidthToOffsetWidth);
            this.subscribe("init", onInit);
            this.subscribe("render", this.onRender);

            this.initEvent.fire(Tooltip);
        },

        /**
        * Initializes the custom events for Tooltip
        * @method initEvents
        */
        initEvents: function () {

            Tooltip.superclass.initEvents.call(this);
            var SIGNATURE = CustomEvent.LIST;

            /**
            * CustomEvent fired when user mouses over a context element. Returning false from
            * a subscriber to this event will prevent the tooltip from being displayed for
            * the current context element.
            * 
            * @event contextMouseOverEvent
            * @param {HTMLElement} context The context element which the user just moused over
            * @param {DOMEvent} e The DOM event object, associated with the mouse over
            */
            this.contextMouseOverEvent = this.createEvent(EVENT_TYPES.CONTEXT_MOUSE_OVER);
            this.contextMouseOverEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the user mouses out of a context element.
            * 
            * @event contextMouseOutEvent
            * @param {HTMLElement} context The context element which the user just moused out of
            * @param {DOMEvent} e The DOM event object, associated with the mouse out
            */
            this.contextMouseOutEvent = this.createEvent(EVENT_TYPES.CONTEXT_MOUSE_OUT);
            this.contextMouseOutEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired just before the tooltip is displayed for the current context.
            * <p>
            *  You can subscribe to this event if you need to set up the text for the 
            *  tooltip based on the context element for which it is about to be displayed.
            * </p>
            * <p>This event differs from the beforeShow event in following respects:</p>
            * <ol>
            *   <li>
            *    When moving from one context element to another, if the tooltip is not
            *    hidden (the <code>hidedelay</code> is not reached), the beforeShow and Show events will not
            *    be fired when the tooltip is displayed for the new context since it is already visible.
            *    However the contextTrigger event is always fired before displaying the tooltip for
            *    a new context.
            *   </li>
            *   <li>
            *    The trigger event provides access to the context element, allowing you to 
            *    set the text of the tooltip based on context element for which the tooltip is
            *    triggered.
            *   </li>
            * </ol>
            * <p>
            *  It is not possible to prevent the tooltip from being displayed
            *  using this event. You can use the contextMouseOverEvent if you need to prevent
            *  the tooltip from being displayed.
            * </p>
            * @event contextTriggerEvent
            * @param {HTMLElement} context The context element for which the tooltip is triggered
            */
            this.contextTriggerEvent = this.createEvent(EVENT_TYPES.CONTEXT_TRIGGER);
            this.contextTriggerEvent.signature = SIGNATURE;
        },

        /**
        * Initializes the class's configurable properties which can be 
        * changed using the Overlay's Config object (cfg).
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {

            Tooltip.superclass.initDefaultConfig.call(this);

            /**
            * Specifies whether the Tooltip should be kept from overlapping 
            * its context element.
            * @config preventoverlap
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.PREVENT_OVERLAP.key, {
                value: DEFAULT_CONFIG.PREVENT_OVERLAP.value, 
                validator: DEFAULT_CONFIG.PREVENT_OVERLAP.validator, 
                supercedes: DEFAULT_CONFIG.PREVENT_OVERLAP.supercedes
            });

            /**
            * The number of milliseconds to wait before showing a Tooltip 
            * on mouseover.
            * @config showdelay
            * @type Number
            * @default 200
            */
            this.cfg.addProperty(DEFAULT_CONFIG.SHOW_DELAY.key, {
                handler: this.configShowDelay,
                value: 200, 
                validator: DEFAULT_CONFIG.SHOW_DELAY.validator
            });

            /**
            * The number of milliseconds to wait before automatically 
            * dismissing a Tooltip after the mouse has been resting on the 
            * context element.
            * @config autodismissdelay
            * @type Number
            * @default 5000
            */
            this.cfg.addProperty(DEFAULT_CONFIG.AUTO_DISMISS_DELAY.key, {
                handler: this.configAutoDismissDelay,
                value: DEFAULT_CONFIG.AUTO_DISMISS_DELAY.value,
                validator: DEFAULT_CONFIG.AUTO_DISMISS_DELAY.validator
            });

            /**
            * The number of milliseconds to wait before hiding a Tooltip 
            * on mouseover.
            * @config hidedelay
            * @type Number
            * @default 250
            */
            this.cfg.addProperty(DEFAULT_CONFIG.HIDE_DELAY.key, {
                handler: this.configHideDelay,
                value: DEFAULT_CONFIG.HIDE_DELAY.value, 
                validator: DEFAULT_CONFIG.HIDE_DELAY.validator
            });

            /**
            * Specifies the Tooltip's text. 
            * @config text
            * @type String
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.TEXT.key, {
                handler: this.configText,
                suppressEvent: DEFAULT_CONFIG.TEXT.suppressEvent
            });

            /**
            * Specifies the container element that the Tooltip's markup 
            * should be rendered into.
            * @config container
            * @type HTMLElement/String
            * @default document.body
            */
            this.cfg.addProperty(DEFAULT_CONFIG.CONTAINER.key, {
                handler: this.configContainer,
                value: document.body
            });

            /**
            * Specifies whether or not the tooltip is disabled. Disabled tooltips
            * will not be displayed. If the tooltip is driven by the title attribute
            * of the context element, the title attribute will still be removed for 
            * disabled tooltips, to prevent default tooltip behavior.
            * 
            * @config disabled
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.DISABLED.key, {
                handler: this.configContainer,
                value: DEFAULT_CONFIG.DISABLED.value,
                supressEvent: DEFAULT_CONFIG.DISABLED.suppressEvent
            });

            /**
            * Specifies the element or elements that the Tooltip should be 
            * anchored to on mouseover.
            * @config context
            * @type HTMLElement[]/String[]
            * @default null
            */ 

            /**
            * String representing the width of the Tooltip.  <em>Please note:
            * </em> As of version 2.3 if either no value or a value of "auto" 
            * is specified, and the Toolip's "container" configuration property
            * is set to something other than <code>document.body</code> or 
            * its "context" element resides outside the immediately visible 
            * portion of the document, the width of the Tooltip will be 
            * calculated based on the offsetWidth of its root HTML and set just 
            * before it is made visible.  The original value will be 
            * restored when the Tooltip is hidden. This ensures the Tooltip is 
            * rendered at a usable width.  For more information see 
            * SourceForge bug #1685496 and SourceForge 
            * bug #1735423.
            * @config width
            * @type String
            * @default null
            */
        
        },
        
        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
        * The default event handler fired when the "text" property is changed.
        * @method configText
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configText: function (type, args, obj) {
            var text = args[0];
            if (text) {
                this.setBody(text);
            }
        },
        
        /**
        * The default event handler fired when the "container" property 
        * is changed.
        * @method configContainer
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For 
        * configuration handlers, args[0] will equal the newly applied value 
        * for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configContainer: function (type, args, obj) {
            var container = args[0];

            if (typeof container == 'string') {
                this.cfg.setProperty("container", document.getElementById(container), true);
            }
        },
        
        /**
        * @method _removeEventListeners
        * @description Removes all of the DOM event handlers from the HTML
        *  element(s) that trigger the display of the tooltip.
        * @protected
        */
        _removeEventListeners: function () {
        
            var aElements = this._context,
                nElements,
                oElement,
                i;

            if (aElements) {
                nElements = aElements.length;
                if (nElements > 0) {
                    i = nElements - 1;
                    do {
                        oElement = aElements[i];
                        Event.removeListener(oElement, "mouseover", this.onContextMouseOver);
                        Event.removeListener(oElement, "mousemove", this.onContextMouseMove);
                        Event.removeListener(oElement, "mouseout", this.onContextMouseOut);
                    }
                    while (i--);
                }
            }
        },
        
        /**
        * The default event handler fired when the "context" property 
        * is changed.
        * @method configContext
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configContext: function (type, args, obj) {
        
            var context = args[0],
                aElements,
                nElements,
                oElement,
                i;

            if (context) {

                // Normalize parameter into an array
                if (! (context instanceof Array)) {
                    if (typeof context == "string") {
                        this.cfg.setProperty("context", [document.getElementById(context)], true);
                    } else { // Assuming this is an element
                        this.cfg.setProperty("context", [context], true);
                    }
                    context = this.cfg.getProperty("context");
                }

                // Remove any existing mouseover/mouseout listeners
                this._removeEventListeners();

                // Add mouseover/mouseout listeners to context elements
                this._context = context;

                aElements = this._context;

                if (aElements) {
                    nElements = aElements.length;
                    if (nElements > 0) {
                        i = nElements - 1;
                        do {
                            oElement = aElements[i];
                            Event.on(oElement, "mouseover", this.onContextMouseOver, this);
                            Event.on(oElement, "mousemove", this.onContextMouseMove, this);
                            Event.on(oElement, "mouseout", this.onContextMouseOut, this);
                        }
                        while (i--);
                    }
                }
            }
        },

        // END BUILT-IN PROPERTY EVENT HANDLERS //

        // BEGIN BUILT-IN DOM EVENT HANDLERS //

        /**
        * The default event handler fired when the user moves the mouse while 
        * over the context element.
        * @method onContextMouseMove
        * @param {DOMEvent} e The current DOM event
        * @param {Object} obj The object argument
        */
        onContextMouseMove: function (e, obj) {
            obj.pageX = Event.getPageX(e);
            obj.pageY = Event.getPageY(e);
        },

        /**
        * The default event handler fired when the user mouses over the 
        * context element.
        * @method onContextMouseOver
        * @param {DOMEvent} e The current DOM event
        * @param {Object} obj The object argument
        */
        onContextMouseOver: function (e, obj) {
            var context = this;

            if (context.title) {
                obj._tempTitle = context.title;
                context.title = "";
            }

            // Fire first, to honor disabled set in the listner
            if (obj.fireEvent("contextMouseOver", context, e) !== false 
                    && !obj.cfg.getProperty("disabled")) {

                // Stop the tooltip from being hidden (set on last mouseout)
                if (obj.hideProcId) {
                    clearTimeout(obj.hideProcId);
                    obj.hideProcId = null;
                }

                Event.on(context, "mousemove", obj.onContextMouseMove, obj);

                /**
                * The unique process ID associated with the thread responsible 
                * for showing the Tooltip.
                * @type int
                */
                obj.showProcId = obj.doShow(e, context);
            }
        },

        /**
        * The default event handler fired when the user mouses out of 
        * the context element.
        * @method onContextMouseOut
        * @param {DOMEvent} e The current DOM event
        * @param {Object} obj The object argument
        */
        onContextMouseOut: function (e, obj) {
            var el = this;

            if (obj._tempTitle) {
                el.title = obj._tempTitle;
                obj._tempTitle = null;
            }

            if (obj.showProcId) {
                clearTimeout(obj.showProcId);
                obj.showProcId = null;
            }

            if (obj.hideProcId) {
                clearTimeout(obj.hideProcId);
                obj.hideProcId = null;
            }

            obj.fireEvent("contextMouseOut", el, e);

            obj.hideProcId = setTimeout(function () {
                obj.hide();
            }, obj.cfg.getProperty("hidedelay"));
        },

        // END BUILT-IN DOM EVENT HANDLERS //

        /**
        * Processes the showing of the Tooltip by setting the timeout delay 
        * and offset of the Tooltip.
        * @method doShow
        * @param {DOMEvent} e The current DOM event
        * @return {Number} The process ID of the timeout function associated 
        * with doShow
        */
        doShow: function (e, context) {

            var yOffset = 25,
                me = this;

            if (pega.env.ua.opera && context.tagName && 
                context.tagName.toUpperCase() == "A") {
                yOffset += 12;
            }

            return setTimeout(function () {

                var txt = me.cfg.getProperty("text");

                // title does not over-ride text
                if (me._tempTitle && (txt === "" || pega.lang.isUndefined(txt) || pega.lang.isNull(txt))) {
                    me.setBody(me._tempTitle);
                } else {
                    me.cfg.refireEvent("text");
                }

                me.moveTo(me.pageX, me.pageY + yOffset);

                if (me.cfg.getProperty("preventoverlap")) {
                    me.preventOverlap(me.pageX, me.pageY);
                }

                Event.removeListener(context, "mousemove", me.onContextMouseMove);

                me.contextTriggerEvent.fire(context);

                me.show();

                me.hideProcId = me.doHide();

            }, this.cfg.getProperty("showdelay"));
        },

        /**
        * Sets the timeout for the auto-dismiss delay, which by default is 5 
        * seconds, meaning that a tooltip will automatically dismiss itself 
        * after 5 seconds of being displayed.
        * @method doHide
        */
        doHide: function () {

            var me = this;


            return setTimeout(function () {

                me.hide();

            }, this.cfg.getProperty("autodismissdelay"));

        },
        
        /**
        * Fired when the Tooltip is moved, this event handler is used to 
        * prevent the Tooltip from overlapping with its context element.
        * @method preventOverlay
        * @param {Number} pageX The x coordinate position of the mouse pointer
        * @param {Number} pageY The y coordinate position of the mouse pointer
        */
        preventOverlap: function (pageX, pageY) {
        
            var height = this.element.offsetHeight,
                mousePoint = new pega.util.Point(pageX, pageY),
                elementRegion = Dom.getRegion(this.element);
        
            elementRegion.top -= 5;
            elementRegion.left -= 5;
            elementRegion.right += 5;
            elementRegion.bottom += 5;
        
        
            if (elementRegion.contains(mousePoint)) {
                this.cfg.setProperty("y", (pageY - height - 5));
            }
        },


        /**
        * @method onRender
        * @description "render" event handler for the Tooltip.
        * @param {String} p_sType String representing the name of the event  
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event 
        * was fired.
        */
        onRender: function (p_sType, p_aArgs) {
    
            function sizeShadow() {
    
                var oElement = this.element,
                    oShadow = this._shadow;
            
                if (oShadow) {
                    oShadow.style.width = (oElement.offsetWidth + 6) + "px";
                    oShadow.style.height = (oElement.offsetHeight + 1) + "px"; 
                }
            
            }

            function addShadowVisibleClass() {
                Dom.addClass(this._shadow, "yui-tt-shadow-visible");
            }
            

            function removeShadowVisibleClass() {
                Dom.removeClass(this._shadow, "yui-tt-shadow-visible");
            }

            function createShadow() {
    
                var oShadow = this._shadow,
                    oElement,
                    Module,
                    nIE,
                    me;
    
                if (!oShadow) {
    
                    oElement = this.element;
                    Module = pega.widget.Module;
                    nIE = pega.env.ua.ie;
                    me = this;

                    if (!m_oShadowTemplate) {
                        m_oShadowTemplate = document.createElement("div");
                        m_oShadowTemplate.className = "yui-tt-shadow";
                    }

                    oShadow = m_oShadowTemplate.cloneNode(false);

                    oElement.appendChild(oShadow);

                    this._shadow = oShadow;

                    addShadowVisibleClass.call(this);

                    this.subscribe("beforeShow", addShadowVisibleClass);
                    this.subscribe("beforeHide", removeShadowVisibleClass);

                    if (nIE == 6 || (nIE == 7 && document.compatMode == "BackCompat")) {
                        window.setTimeout(function () { 
                            sizeShadow.call(me); 
                        }, 0);
    
                        this.cfg.subscribeToConfigEvent("width", sizeShadow);
                        this.cfg.subscribeToConfigEvent("height", sizeShadow);
                        this.subscribe("changeContent", sizeShadow);

                        Module.textResizeEvent.subscribe(sizeShadow, this, true);
                        this.subscribe("destroy", function () {
                            Module.textResizeEvent.unsubscribe(sizeShadow, this);
                        });
                    }
                }
            }

            function onBeforeShow() {
                createShadow.call(this);
                this.unsubscribe("beforeShow", onBeforeShow);
            }

            if (this.cfg.getProperty("visible")) {
                createShadow.call(this);
            } else {
                this.subscribe("beforeShow", onBeforeShow);
            }
        
        },
        
        /**
        * Removes the Tooltip element from the DOM and sets all child 
        * elements to null.
        * @method destroy
        */
        destroy: function () {
        
            // Remove any existing mouseover/mouseout listeners
            this._removeEventListeners();

            Tooltip.superclass.destroy.call(this);  
        
        },
        
        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the Tooltip
        */
        toString: function () {
            return "Tooltip " + this.id;
        }
    
    });

}());

(function () {

    /**
    * Panel is an implementation of Overlay that behaves like an OS window, 
    * with a draggable header and an optional close icon at the top right.
    * @namespace pega.widget
    * @class Panel
    * @extends pega.widget.Overlay
    * @constructor
    * @param {String} el The element ID representing the Panel <em>OR</em>
    * @param {HTMLElement} el The element representing the Panel
    * @param {Object} userConfig The configuration object literal containing 
    * the configuration that should be set for this Panel. See configuration 
    * documentation for more details.
    */
    pega.widget.Panel = function (el, userConfig) {
        pega.widget.Panel.superclass.constructor.call(this, el, userConfig);
    };

    var Lang = pega.lang,
        DD = pega.util.DD,
        Dom = pega.util.Dom,
        Event = pega.util.Event,
        Overlay = pega.widget.Overlay,
        CustomEvent = pega.util.CustomEvent,
        Config = pega.util.Config,
        Panel = pega.widget.Panel,

        m_oMaskTemplate,
        m_oUnderlayTemplate,
        m_oCloseIconTemplate,

        /**
        * Constant representing the name of the Panel's events
        * @property EVENT_TYPES
        * @private
        * @final
        * @type Object
        */
        EVENT_TYPES = {
            "SHOW_MASK": "showMask",
            "HIDE_MASK": "hideMask",
            "DRAG": "drag"
        },

        /**
        * Constant representing the Panel's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "CLOSE": { 
                key: "close", 
                value: true, 
                validator: Lang.isBoolean, 
                supercedes: ["visible"] 
            },

            "DRAGGABLE": { 
                key: "draggable", 
                value: (DD ? true : false), 
                validator: Lang.isBoolean, 
                supercedes: ["visible"]  
            },

            "DRAG_ONLY" : {
                key: "dragonly",
                value: false,
                validator: Lang.isBoolean,
                supercedes: ["draggable"]
            },

            "UNDERLAY": { 
                key: "underlay", 
                value: "shadow", 
                supercedes: ["visible"] 
            },

            "MODAL": { 
                key: "modal", 
                value: false, 
                validator: Lang.isBoolean, 
                supercedes: ["visible", "zindex"]
            },

            "KEY_LISTENERS": {
                key: "keylisteners",
                suppressEvent: true,
                supercedes: ["visible"]
            }
        };

    /**
    * Constant representing the default CSS class used for a Panel
    * @property pega.widget.Panel.CSS_PANEL
    * @static
    * @final
    * @type String
    */
    Panel.CSS_PANEL = "yui-panel";
    
    /**
    * Constant representing the default CSS class used for a Panel's 
    * wrapping container
    * @property pega.widget.Panel.CSS_PANEL_CONTAINER
    * @static
    * @final
    * @type String
    */
    Panel.CSS_PANEL_CONTAINER = "yui-panel-container";

    /**
     * Constant representing the default set of focusable elements 
     * on the pagewhich Modal Panels will prevent access to, when
     * the modal mask is displayed
     * 
     * @property pega.widget.Panel.FOCUSABLE
     * @static
     * @type Array
     */
    Panel.FOCUSABLE = [
        "a",
        "button",
        "select",
        "textarea",
        "input"
    ];

    // Private CustomEvent listeners

    /* 
        "beforeRender" event handler that creates an empty header for a Panel 
        instance if its "draggable" configuration property is set to "true" 
        and no header has been created.
    */

    function createHeader(p_sType, p_aArgs) {
        if (!this.header && this.cfg.getProperty("draggable")) {
            this.setHeader("&#160;");
        }
    }

    /* 
        "hide" event handler that sets a Panel instance's "width"
        configuration property back to its original value before 
        "setWidthToOffsetWidth" was called.
    */
    
    function restoreOriginalWidth(p_sType, p_aArgs, p_oObject) {

        var sOriginalWidth = p_oObject[0],
            sNewWidth = p_oObject[1],
            oConfig = this.cfg,
            sCurrentWidth = oConfig.getProperty("width");

        if (sCurrentWidth == sNewWidth) {
            oConfig.setProperty("width", sOriginalWidth);
        }

        this.unsubscribe("hide", restoreOriginalWidth, p_oObject);
    }

    /* 
        "beforeShow" event handler that sets a Panel instance's "width"
        configuration property to the value of its root HTML 
        elements's offsetWidth
    */

    function setWidthToOffsetWidth(p_sType, p_aArgs) {

        var nIE = pega.env.ua.ie,
            oConfig,
            sOriginalWidth,
            sNewWidth;

        if (nIE == 6 || (nIE == 7 && document.compatMode == "BackCompat")) {

            oConfig = this.cfg;
            sOriginalWidth = oConfig.getProperty("width");
            
            if (!sOriginalWidth || sOriginalWidth == "auto") {
    
                sNewWidth = (this.element.offsetWidth + "px");
    
                oConfig.setProperty("width", sNewWidth);
                
                this.subscribe("hide", restoreOriginalWidth, 
                    [(sOriginalWidth || ""), sNewWidth]);
            
            }
        }
    }

    pega.extend(Panel, Overlay, {

        /**
        * The Overlay initialization method, which is executed for Overlay and 
        * all of its subclasses. This method is automatically called by the 
        * constructor, and  sets up all DOM references for pre-existing markup, 
        * and creates required markup if it is not already present.
        * @method init
        * @param {String} el The element ID representing the Overlay <em>OR</em>
        * @param {HTMLElement} el The element representing the Overlay
        * @param {Object} userConfig The configuration object literal 
        * containing the configuration that should be set for this Overlay. 
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {
    
            /*
                 Note that we don't pass the user config in here yet because 
                 we only want it executed once, at the lowest subclass level
            */

            Panel.superclass.init.call(this, el/*, userConfig*/);  

            this.beforeInitEvent.fire(Panel);

            Dom.addClass(this.element, Panel.CSS_PANEL);

            this.buildWrapper();

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            this.subscribe("showMask", this._addFocusHandlers);
            this.subscribe("hideMask", this._removeFocusHandlers);
            this.subscribe("beforeRender", createHeader);

            this.initEvent.fire(Panel);
        },

        /**
         * @method _onElementFocus 
         * @private
         * 
         * "focus" event handler for a focuable element. Used to automatically 
         * blur the element when it receives focus to ensure that a Panel 
         * instance's modality is not compromised.
         * 
         * @param {Event} e The DOM event object
         */
        _onElementFocus : function(e){
            this.blur();
        },

        /** 
         *  @method _addFocusHandlers
         *  @protected
         *  
         *  "showMask" event handler that adds a "focus" event handler to all
         *  focusable elements in the document to enforce a Panel instance's 
         *  modality from being compromised.
         *  
         *  @param p_sType {String} Custom event type
         *  @param p_aArgs {Array} Custom event arguments
         */
        _addFocusHandlers: function(p_sType, p_aArgs) {
			var focus = (isIE ? "focusin" : "focus");
			Event.addListener(document.documentElement, focus, this._onElementFocus);
        },

        /** 
         *  @method _removeFocusHandlers
         *  @protected
         *  
         *  "hideMask" event handler that removes all "focus" event handlers added 
         *  by the "addFocusEventHandlers" method.
         *  
         *  @param p_sType {String} Event type
         *  @param p_aArgs {Array} Event Arguments
         */
        _removeFocusHandlers: function(p_sType, p_aArgs) {
					var focus = (isIE ? "focusin" : "focus");
                    Event.removeListener(document.documentElement, focus, this._onElementFocus);
        },

        /**
        * Initializes the custom events for Module which are fired 
        * automatically at appropriate times by the Module class.
        */
        initEvents: function () {
            Panel.superclass.initEvents.call(this);
        
            var SIGNATURE = CustomEvent.LIST;
        
            /**
            * CustomEvent fired after the modality mask is shown
            * @event showMaskEvent
            */
            this.showMaskEvent = this.createEvent(EVENT_TYPES.SHOW_MASK);
            this.showMaskEvent.signature = SIGNATURE;
        
            /**
            * CustomEvent fired after the modality mask is hidden
            * @event hideMaskEvent
            */
            this.hideMaskEvent = this.createEvent(EVENT_TYPES.HIDE_MASK);
            this.hideMaskEvent.signature = SIGNATURE;
        
            /**
            * CustomEvent when the Panel is dragged
            * @event dragEvent
            */
            this.dragEvent = this.createEvent(EVENT_TYPES.DRAG);
            this.dragEvent.signature = SIGNATURE;
        
        },
        
        /**
        * Initializes the class's configurable properties which can be changed 
        * using the Panel's Config object (cfg).
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {
            Panel.superclass.initDefaultConfig.call(this);
        
            // Add panel config properties //
        
            /**
            * True if the Panel should display a "close" button
            * @config close
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.CLOSE.key, { 
                handler: this.configClose, 
                value: DEFAULT_CONFIG.CLOSE.value, 
                validator: DEFAULT_CONFIG.CLOSE.validator, 
                supercedes: DEFAULT_CONFIG.CLOSE.supercedes 
            });
        
            /**
            * Boolean specifying if the Panel should be draggable.  The default 
            * value is "true" if the Drag and Drop utility is included, 
            * otherwise it is "false." <strong>PLEASE NOTE:</strong> There is a 
            * known issue in IE 6 (Strict Mode and Quirks Mode) and IE 7 
            * (Quirks Mode) where Panels that either don't have a value set for 
            * their "width" configuration property, or their "width" 
            * configuration property is set to "auto" will only be draggable by
            * placing the mouse on the text of the Panel's header element.
            * To fix this bug, draggable Panels missing a value for their 
            * "width" configuration property, or whose "width" configuration 
            * property is set to "auto" will have it set to the value of 
            * their root HTML element's offsetWidth before they are made 
            * visible.  The calculated width is then removed when the Panel is   
            * hidden. <em>This fix is only applied to draggable Panels in IE 6 
            * (Strict Mode and Quirks Mode) and IE 7 (Quirks Mode)</em>. For 
            * more information on this issue see:
            * SourceForge bugs #1726972 and #1589210.
            * @config draggable
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.DRAGGABLE.key, { 
                handler: this.configDraggable, 
                value: DEFAULT_CONFIG.DRAGGABLE.value, 
                validator: DEFAULT_CONFIG.DRAGGABLE.validator, 
                supercedes: DEFAULT_CONFIG.DRAGGABLE.supercedes 
            });

            /**
            * Boolean specifying if the draggable Panel should be drag only, not interacting with drop 
            * targets on the page.
            * <p>
            * When set to true, draggable Panels will not check to see if they are over drop targets,
            * or fire the DragDrop events required to support drop target interaction (onDragEnter, 
            * onDragOver, onDragOut, onDragDrop etc.).
            * If the Panel is not designed to be dropped on any target elements on the page, then this 
            * flag can be set to true to improve performance.
            * </p>
            * <p>
            * When set to false, all drop target related events will be fired.
            * </p>
            * <p>
            * The property is set to false by default to maintain backwards compatibility but should be 
            * set to true if drop target interaction is not required for the Panel, to improve performance.</p>
            * 
            * @config dragOnly
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.DRAG_ONLY.key, { 
                value: DEFAULT_CONFIG.DRAG_ONLY.value, 
                validator: DEFAULT_CONFIG.DRAG_ONLY.validator, 
                supercedes: DEFAULT_CONFIG.DRAG_ONLY.supercedes 
            });

            /**
            * Sets the type of underlay to display for the Panel. Valid values 
            * are "shadow," "matte," and "none".  <strong>PLEASE NOTE:</strong> 
            * The creation of the underlay element is deferred until the Panel 
            * is initially made visible.  For Gecko-based browsers on Mac
            * OS X the underlay elment is always created as it is used as a 
            * shim to prevent Aqua scrollbars below a Panel instance from poking 
            * through it (See SourceForge bug #836476).
            * @config underlay
            * @type String
            * @default shadow
            */
            this.cfg.addProperty(DEFAULT_CONFIG.UNDERLAY.key, { 
                handler: this.configUnderlay, 
                value: DEFAULT_CONFIG.UNDERLAY.value, 
                supercedes: DEFAULT_CONFIG.UNDERLAY.supercedes 
            });
        
            /**
            * True if the Panel should be displayed in a modal fashion, 
            * automatically creating a transparent mask over the document that
            * will not be removed until the Panel is dismissed.
            * @config modal
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.MODAL.key, { 
                handler: this.configModal, 
                value: DEFAULT_CONFIG.MODAL.value,
                validator: DEFAULT_CONFIG.MODAL.validator, 
                supercedes: DEFAULT_CONFIG.MODAL.supercedes 
            });
        
            /**
            * A KeyListener (or array of KeyListeners) that will be enabled 
            * when the Panel is shown, and disabled when the Panel is hidden.
            * @config keylisteners
            * @type pega.util.KeyListener[]
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.KEY_LISTENERS.key, { 
                handler: this.configKeyListeners, 
                suppressEvent: DEFAULT_CONFIG.KEY_LISTENERS.suppressEvent, 
                supercedes: DEFAULT_CONFIG.KEY_LISTENERS.supercedes 
            });
        
        },
        
        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
        * The default event handler fired when the "close" property is changed.
        * The method controls the appending or hiding of the close icon at the 
        * top right of the Panel.
        * @method configClose
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configClose: function (type, args, obj) {

            var val = args[0],
                oClose = this.close;
        
            function doHide(e, obj) {
                obj.hide();
            }
        
            if (val) {
                if (!oClose) {
                    if (!m_oCloseIconTemplate) {
                        m_oCloseIconTemplate = document.createElement("span");
                        m_oCloseIconTemplate.innerHTML = "&#160;";
                        m_oCloseIconTemplate.className = "container-close";
                    }

                    oClose = m_oCloseIconTemplate.cloneNode(true);
                    this.innerElement.appendChild(oClose);
                    Event.on(oClose, "click", doHide, this);
                    
                    this.close = oClose;

                } else {
                    oClose.style.display = "block";
                }

            } else {
                if (oClose) {
                    oClose.style.display = "none";
                }
            }

        },

        /**
        * The default event handler fired when the "draggable" property 
        * is changed.
        * @method configDraggable
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configDraggable: function (type, args, obj) {
            var val = args[0];

            if (val) {
                if (!DD) {
                    this.cfg.setProperty("draggable", false);
                    return;
                }

                if (this.header) {
                    Dom.setStyle(this.header, "cursor", "move");
                    this.registerDragDrop();
                }

                this.subscribe("beforeShow", setWidthToOffsetWidth);

            } else {

                if (this.dd) {
                    this.dd.unreg();
                }

                if (this.header) {
                    Dom.setStyle(this.header,"cursor","auto");
                }

                this.unsubscribe("beforeShow", setWidthToOffsetWidth);
            }
        },
      
        /**
        * The default event handler fired when the "underlay" property 
        * is changed.
        * @method configUnderlay
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configUnderlay: function (type, args, obj) {

            var UA = pega.env.ua,
                bMacGecko = (this.platform == "mac" && UA.gecko),
                bIEQuirks = (UA.ie == 6 || (UA.ie == 7 && document.compatMode == "BackCompat")),
                sUnderlay = args[0].toLowerCase(),
                oUnderlay = this.underlay,
                oElement = this.element;
                
            function fixWebkitUnderlay() {
                // Webkit 419.3 (Safari 2.x) does not update
                // it's Render Tree for the Container when content changes. 
                // We need to force it to update using this contentChange 
                // listener

                // Webkit 523.6 doesn't have this problem and doesn't 
                // need the fix
                var u = this.underlay;
                Dom.addClass(u, "yui-force-redraw");
                window.setTimeout(function(){Dom.removeClass(u, "yui-force-redraw");}, 0);
            }

            function createUnderlay() {
                var bNew = false;
                if (!oUnderlay) { // create if not already in DOM

                    if (!m_oUnderlayTemplate) {
                        m_oUnderlayTemplate = document.createElement("div");
                        m_oUnderlayTemplate.className = "underlay";
                    }

                    oUnderlay = m_oUnderlayTemplate.cloneNode(false);
                    this.element.appendChild(oUnderlay);

                    this.underlay = oUnderlay;

                    if (bIEQuirks) {
                        this.sizeUnderlay();
                        this.cfg.subscribeToConfigEvent("width", this.sizeUnderlay);
                        this.cfg.subscribeToConfigEvent("height",this.sizeUnderlay);
                        this.changeContentEvent.subscribe(this.sizeUnderlay);
                        pega.widget.Module.textResizeEvent.subscribe(this.sizeUnderlay, this, true);
                    }

                    if (UA.webkit && UA.webkit < 420) {
                        this.changeContentEvent.subscribe(fixWebkitUnderlay);
                    }
                    bNew = true;
                }
            }

            function onBeforeShow() {
                var bNew = createUnderlay.call(this);
                if (!bNew && bIEQuirks) {
                    this.sizeUnderlay();
                }
                this._underlayDeferred = false;
                this.beforeShowEvent.unsubscribe(onBeforeShow);
            }

            function destroyUnderlay() {
                if (this._underlayDeferred) {
                    this.beforeShowEvent.unsubscribe(onBeforeShow);
                    this._underlayDeferred = false;
                }

                if (oUnderlay) {
                    this.cfg.unsubscribeFromConfigEvent("width", this.sizeUnderlay);
                    this.cfg.unsubscribeFromConfigEvent("height",this.sizeUnderlay);
                    this.changeContentEvent.unsubscribe(this.sizeUnderlay);
                    this.changeContentEvent.unsubscribe(fixWebkitUnderlay);
                    pega.widget.Module.textResizeEvent.unsubscribe(this.sizeUnderlay, this, true);

                    this.element.removeChild(oUnderlay);

                    this.underlay = null;
                }
            }

            switch (sUnderlay) {
                case "shadow":
                    Dom.removeClass(oElement, "matte");
                    Dom.addClass(oElement, "shadow");
                    break;
                case "matte":
                    if (!bMacGecko) {
                        destroyUnderlay.call(this);
                    }
                    Dom.removeClass(oElement, "shadow");
                    Dom.addClass(oElement, "matte");
                    break;
                default:
                    if (!bMacGecko) {
                        destroyUnderlay.call(this);
                    }
                    Dom.removeClass(oElement, "shadow");
                    Dom.removeClass(oElement, "matte");
                    break;
            }

            if ((sUnderlay == "shadow") || (bMacGecko && !oUnderlay)) {
                if (this.cfg.getProperty("visible")) {
                    var bNew = createUnderlay.call(this);
                    if (!bNew && bIEQuirks) {
                        this.sizeUnderlay();
                    }
                } else {
                    if (!this._underlayDeferred) {
                        this.beforeShowEvent.subscribe(onBeforeShow);
                        this._underlayDeferred = true;
                    }
                }
            }
        },
        
        /**
        * The default event handler fired when the "modal" property is 
        * changed. This handler subscribes or unsubscribes to the show and hide
        * events to handle the display or hide of the modality mask.
        * @method configModal
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configModal: function (type, args, obj) {

            var modal = args[0];
            if (modal) {
                if (!this._hasModalityEventListeners) {

                    this.subscribe("beforeShow", this.buildMask);
                    this.subscribe("beforeShow", this.bringToTop);
                    this.subscribe("beforeShow", this.showMask);
                    this.subscribe("hide", this.hideMask);

                    Overlay.windowResizeEvent.subscribe(this.sizeMask, 
                        this, true);

                    this._hasModalityEventListeners = true;
                }
            } else {
                if (this._hasModalityEventListeners) {

                    if (this.cfg.getProperty("visible")) {
                        this.hideMask();
                        this.removeMask();
                    }

                    this.unsubscribe("beforeShow", this.buildMask);
                    this.unsubscribe("beforeShow", this.bringToTop);
                    this.unsubscribe("beforeShow", this.showMask);
                    this.unsubscribe("hide", this.hideMask);

                    Overlay.windowResizeEvent.unsubscribe(this.sizeMask, this);
                    
                    this._hasModalityEventListeners = false;
                }
            }
        },
        
        /**
        * Removes the modality mask.
        * @method removeMask
        */
        removeMask: function () {
        
            var oMask = this.mask,
                oParentNode;
        
            if (oMask) {
                /*
                    Hide the mask before destroying it to ensure that DOM
                    event handlers on focusable elements get removed.
                */
                this.hideMask();
                
                oParentNode = oMask.parentNode;
                if (oParentNode) {
                    oParentNode.removeChild(oMask);
                }

                this.mask = null;
            }
        },
        
        /**
        * The default event handler fired when the "keylisteners" property 
        * is changed.
        * @method configKeyListeners
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configKeyListeners: function (type, args, obj) {

            var listeners = args[0],
                listener,
                nListeners,
                i;
        
            if (listeners) {

                if (listeners instanceof Array) {

                    nListeners = listeners.length;

                    for (i = 0; i < nListeners; i++) {

                        listener = listeners[i];
        
                        if (!Config.alreadySubscribed(this.showEvent, 
                            listener.enable, listener)) {

                            this.showEvent.subscribe(listener.enable, 
                                listener, true);

                        }

                        if (!Config.alreadySubscribed(this.hideEvent, 
                            listener.disable, listener)) {

                            this.hideEvent.subscribe(listener.disable, 
                                listener, true);

                            this.destroyEvent.subscribe(listener.disable, 
                                listener, true);
                        }

                    }

                } else {

                    if (!Config.alreadySubscribed(this.showEvent, 
                        listeners.enable, listeners)) {

                        this.showEvent.subscribe(listeners.enable, 
                            listeners, true);
                    }

                    if (!Config.alreadySubscribed(this.hideEvent, 
                        listeners.disable, listeners)) {

                        this.hideEvent.subscribe(listeners.disable, 
                            listeners, true);

                        this.destroyEvent.subscribe(listeners.disable, 
                            listeners, true);

                    }

                }

            }

        },
        
        /**
        * The default event handler fired when the "height" property is changed.
        * @method configHeight
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configHeight: function (type, args, obj) {
    
            var height = args[0],
                el = this.innerElement;
    
            Dom.setStyle(el, "height", height);
            this.cfg.refireEvent("iframe");
    
        },
        
        /**
        * The default event handler fired when the "width" property is changed.
        * @method configWidth
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configWidth: function (type, args, obj) {
    
            var width = args[0],
                el = this.innerElement;
    
            Dom.setStyle(el, "width", width);
            this.cfg.refireEvent("iframe");
    
        },
        
        /**
        * The default event handler fired when the "zIndex" property is changed.
        * @method configzIndex
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configzIndex: function (type, args, obj) {
            Panel.superclass.configzIndex.call(this, type, args, obj);

            if (this.mask || this.cfg.getProperty("modal") === true) {
                var panelZ = Dom.getStyle(this.element, "zIndex");
                if (!panelZ || isNaN(panelZ)) {
                    panelZ = 0;
                }

                if (panelZ === 0) {
                    // Recursive call to configzindex (which should be stopped
                    // from going further because panelZ should no longer === 0)
                    this.cfg.setProperty("zIndex", 1);
                } else {
                    this.stackMask();
                }
            }
        },

        // END BUILT-IN PROPERTY EVENT HANDLERS //
        /**
        * Builds the wrapping container around the Panel that is used for 
        * positioning the shadow and matte underlays. The container element is 
        * assigned to a  local instance variable called container, and the 
        * element is reinserted inside of it.
        * @method buildWrapper
        */
        buildWrapper: function () {

            var elementParent = this.element.parentNode,
                originalElement = this.element,
                wrapper = document.createElement("div");

            wrapper.className = Panel.CSS_PANEL_CONTAINER;
            wrapper.id = originalElement.id + "_c";

            if (elementParent) {
                elementParent.insertBefore(wrapper, originalElement);
            }

            wrapper.appendChild(originalElement);

            this.element = wrapper;
            this.innerElement = originalElement;

            Dom.setStyle(this.innerElement, "visibility", "inherit");
        },

        /**
        * Adjusts the size of the shadow based on the size of the element.
        * @method sizeUnderlay
        */
        sizeUnderlay: function () {
            var oUnderlay = this.underlay,
                oElement;

            if (oUnderlay) {
                oElement = this.element;
                oUnderlay.style.width = oElement.offsetWidth + "px";
                oUnderlay.style.height = oElement.offsetHeight + "px";
            }
        },

        
        /**
        * Registers the Panel's header for drag & drop capability.
        * @method registerDragDrop
        */
        registerDragDrop: function () {

            var me = this;

            if (this.header) {

                if (!DD) {
                    return;
                }

                var bDragOnly = (this.cfg.getProperty("dragonly") === true);
                this.dd = new DD(this.element.id, this.id, {dragOnly: bDragOnly});

                if (!this.header.id) {
                    this.header.id = this.id + "_h";
                }

                this.dd.startDrag = function () {

                    var offsetHeight,
                        offsetWidth,
                        viewPortWidth,
                        viewPortHeight,
                        scrollX,
                        scrollY;

                    if (pega.env.ua.ie == 6) {
                        Dom.addClass(me.element,"drag");
                    }

                    if (me.cfg.getProperty("constraintoviewport")) {

                        var nViewportOffset = Overlay.VIEWPORT_OFFSET;

                        offsetHeight = me.element.offsetHeight;
                        offsetWidth = me.element.offsetWidth;

                        viewPortWidth = Dom.getViewportWidth();
                        viewPortHeight = Dom.getViewportHeight();

                        scrollX = Dom.getDocumentScrollLeft();
                        scrollY = Dom.getDocumentScrollTop();

                        if (offsetHeight + nViewportOffset < viewPortHeight) {
                            this.minY = scrollY + nViewportOffset;
                            this.maxY = scrollY + viewPortHeight - offsetHeight - nViewportOffset;
                        } else {
                            this.minY = scrollY + nViewportOffset;
                            this.maxY = scrollY + nViewportOffset;
                        }

                        if (offsetWidth + nViewportOffset < viewPortWidth) {
                            this.minX = scrollX + nViewportOffset;
                            this.maxX = scrollX + viewPortWidth - offsetWidth - nViewportOffset;
                        } else {
                            this.minX = scrollX + nViewportOffset;
                            this.maxX = scrollX + nViewportOffset;
                        }

                        this.constrainX = true;
                        this.constrainY = true;
                    } else {
                        this.constrainX = false;
                        this.constrainY = false;
                    }

                    me.dragEvent.fire("startDrag", arguments);
                };

                this.dd.onDrag = function () {
                    me.syncPosition();
                    me.cfg.refireEvent("iframe");
                    if (this.platform == "mac" && pega.env.ua.gecko) {
                        this.showMacGeckoScrollbars();
                    }

                    me.dragEvent.fire("onDrag", arguments);
                };

                this.dd.endDrag = function () {

                    if (pega.env.ua.ie == 6) {
                        Dom.removeClass(me.element,"drag");
                    }

                    me.dragEvent.fire("endDrag", arguments);
                    me.moveEvent.fire(me.cfg.getProperty("xy"));

                };

                this.dd.setHandleElId(this.header.id);
                this.dd.addInvalidHandleType("INPUT");
                this.dd.addInvalidHandleType("SELECT");
                this.dd.addInvalidHandleType("TEXTAREA");
            }
        },
        
        /**
        * Builds the mask that is laid over the document when the Panel is 
        * configured to be modal.
        * @method buildMask
        */
        buildMask: function () {
            var oMask = this.mask;
            if (!oMask) {
                if (!m_oMaskTemplate) {
                    m_oMaskTemplate = document.createElement("div");
                    m_oMaskTemplate.className = "mask";
                    m_oMaskTemplate.innerHTML = "&#160;";
                }
                oMask = m_oMaskTemplate.cloneNode(true);
                oMask.id = this.id + "_mask";

                document.body.insertBefore(oMask, document.body.firstChild);

                this.mask = oMask;

                if (pega.env.ua.gecko && this.platform == "mac") {
                    Dom.addClass(this.mask, "block-scrollbars");
                }

                if(pega.env.ua.ie == 6) {
                  this.mask.style.background = "#cccccc";
                  this.mask.style.filter = "alpha(opacity=50)";
                }

                // Stack mask based on the element zindex
                this.stackMask();
            }
        },

        /**
        * Hides the modality mask.
        * @method hideMask
        */
        hideMask: function () {
            if (this.cfg.getProperty("modal") && this.mask) {
                this.mask.style.display = "none";
                this.hideMaskEvent.fire();
	       if(pega.env.ua.ie == 6){
                	Dom.removeClass(document.body, "masked");
	       }
            }
        },

        /**
        * Shows the modality mask.
        * @method showMask
        */
        showMask: function () {
            if (this.cfg.getProperty("modal") && this.mask) {
	       if(pega.env.ua.ie == 6){
                	Dom.addClass(document.body, "masked");
	       }
                this.sizeMask();
                this.mask.style.display = "block";
                this.showMaskEvent.fire();
            }
        },

        /**
        * Sets the size of the modality mask to cover the entire scrollable 
        * area of the document
        * @method sizeMask
        */
        sizeMask: function () {
            if (this.mask && this.mask.style.display != "none") {
                this.mask.style.height = Dom.getDocumentHeight() + "px";
                this.mask.style.width = Dom.getDocumentWidth() + "px";
            }
        },

        /**
         * Sets the zindex of the mask, if it exists, based on the zindex of 
         * the Panel element. The zindex of the mask is set to be one less 
         * than the Panel element's zindex.
         * 
         * <p>NOTE: This method will not bump up the zindex of the Panel
         * to ensure that the mask has a non-negative zindex. If you require the
         * mask zindex to be 0 or higher, the zindex of the Panel 
         * should be set to a value higher than 0, before this method is called.
         * </p>
         * @method stackMask
         */
        stackMask: function() {
            if (this.mask) {
                var panelZ = Dom.getStyle(this.element, "zIndex");
                if (!pega.lang.isUndefined(panelZ) && !isNaN(panelZ)) {
                    Dom.setStyle(this.mask, "zIndex", panelZ - 1);
                }
            }
        },

        /**
        * Renders the Panel by inserting the elements that are not already in 
        * the main Panel into their correct places. Optionally appends the 
        * Panel to the specified node prior to the render's execution. NOTE: 
        * For Panels without existing markup, the appendToNode argument is 
        * REQUIRED. If this argument is ommitted and the current element is 
        * not present in the document, the function will return false, 
        * indicating that the render was a failure.
        * @method render
        * @param {String} appendToNode The element id to which the Module 
        * should be appended to prior to rendering <em>OR</em>
        * @param {HTMLElement} appendToNode The element to which the Module 
        * should be appended to prior to rendering
        * @return {boolean} Success or failure of the render
        */
        render: function (appendToNode) {

            return Panel.superclass.render.call(this, 
                appendToNode, this.innerElement);

        },
        
        /**
        * Removes the Panel element from the DOM and sets all child elements
        * to null.
        * @method destroy
        */
        destroy: function () {
        
            Overlay.windowResizeEvent.unsubscribe(this.sizeMask, this);
            
            this.removeMask();
        
            if (this.close) {
            
                Event.purgeElement(this.close);
        
            }
        
            Panel.superclass.destroy.call(this);  
        
        },
        
        /**
        * Returns a String representation of the object.
        * @method toString
        * @return {String} The string representation of the Panel.
        */
        toString: function () {
            return "Panel " + this.id;
        }
    
    });

}());

(function () {

    /**
    * <p>
    * Dialog is an implementation of Panel that can be used to submit form 
    * data.
    * </p>
    * <p>
    * Built-in functionality for buttons with event handlers is included. 
    * If the optional YUI Button dependancy is included on the page, the buttons
    * created will be instances of pega.widget.Button, otherwise regular HTML buttons
    * will be created.
    * </p>
    * <p>
    * Forms can be processed in 3 ways -- via an asynchronous Connection utility call, 
    * a simple form POST or GET, or manually. The YUI Connection utility should be
    * included if you're using the default "async" postmethod, but is not required if
    * you're using any of the other postmethod values.
    * </p>
    * @namespace pega.widget
    * @class Dialog
    * @extends pega.widget.Panel
    * @constructor
    * @param {String} el The element ID representing the Dialog <em>OR</em>
    * @param {HTMLElement} el The element representing the Dialog
    * @param {Object} userConfig The configuration object literal containing 
    * the configuration that should be set for this Dialog. See configuration 
    * documentation for more details.
    */
    pega.widget.Dialog = function (el, userConfig) {
        pega.widget.Dialog.superclass.constructor.call(this, el, userConfig);
    };

    var Event = pega.util.Event,
        CustomEvent = pega.util.CustomEvent,
        Dom = pega.util.Dom,
        KeyListener = pega.util.KeyListener,
        Connect = pega.util.Connect,
        Dialog = pega.widget.Dialog,
        Lang = pega.lang,

        /**
        * Constant representing the name of the Dialog's events
        * @property EVENT_TYPES
        * @private
        * @final
        * @type Object
        */
        EVENT_TYPES = {
        
            "BEFORE_SUBMIT": "beforeSubmit",
            "SUBMIT": "submit",
            "MANUAL_SUBMIT": "manualSubmit",
            "ASYNC_SUBMIT": "asyncSubmit",
            "FORM_SUBMIT": "formSubmit",
            "CANCEL": "cancel"
        
        },

        /**
        * Constant representing the Dialog's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "POST_METHOD": { 
                key: "postmethod", 
                value: "async" 
            },

            "BUTTONS": { 
                key: "buttons", 
                value: "none" 
            },

            "HIDEAFTERSUBMIT" : {
                key: "hideaftersubmit",
                value: true
            }
        };

    /**
    * Constant representing the default CSS class used for a Dialog
    * @property pega.widget.Dialog.CSS_DIALOG
    * @static
    * @final
    * @type String
    */
    Dialog.CSS_DIALOG = "yui-dialog";

    function removeButtonEventHandlers() {

        var aButtons = this._aButtons,
            nButtons,
            oButton,
            i;

        if (Lang.isArray(aButtons)) {
            nButtons = aButtons.length;

            if (nButtons > 0) {
                i = nButtons - 1;
                do {
                    oButton = aButtons[i];

                    if (pega.widget.Button && oButton instanceof pega.widget.Button) {
                        oButton.destroy();
                    }
                    else if (oButton.tagName.toUpperCase() == "BUTTON") {
                        Event.purgeElement(oButton);
                        Event.purgeElement(oButton, false);
                    }
                }
                while (i--);
            }
        }
    }
    
    pega.extend(Dialog, pega.widget.Panel, { 

        /**
        * @property form
        * @description Object reference to the Dialog's 
        * <code>&#60;form&#62;</code> element.
        * @default null 
        * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-40002357">HTMLFormElement</a>
        */
        form: null,
    
        /**
        * Initializes the class's configurable properties which can be changed 
        * using the Dialog's Config object (cfg).
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {
            Dialog.superclass.initDefaultConfig.call(this);

            /**
            * The internally maintained callback object for use with the 
            * Connection utility. The format of the callback object is 
            * similar to Connection Manager's callback object and is 
            * simply passed through to Connection Manager when the async 
            * request is made.
            * @property callback
            * @type Object
            */
            this.callback = {

                /**
                * The function to execute upon success of the 
                * Connection submission (when the form does not
                * contain a file input element).
                * 
                * @property callback.success
                * @type Function
                */
                success: null,

                /**
                * The function to execute upon failure of the 
                * Connection submission
                * @property callback.failure
                * @type Function
                */
                failure: null,

                /**
                 *<p>
                * The function to execute upon success of the 
                * Connection submission, when the form contains
                * a file input element.
                * </p>
                * <p>
                * <em>NOTE:</em> Connection manager will not
                * invoke the success or failure handlers for the file
                * upload use case. This will be the only callback
                * handler invoked.
                * </p>
                * <p>
                * For more information, see the <a href="http://developer.yahoo.com/yui/connection/#file">
                * Connection Manager documenation on file uploads</a>.
                * </p>
                * @property callback.upload
                * @type Function
                */

                /**
                * The arbitraty argument or arguments to pass to the Connection 
                * callback functions
                * @property callback.argument
                * @type Object
                */
                argument: null

            };

            // Add form dialog config properties //
            /**
            * The method to use for posting the Dialog's form. Possible values 
            * are "async", "form", and "manual".
            * @config postmethod
            * @type String
            * @default async
            */
            this.cfg.addProperty(DEFAULT_CONFIG.POST_METHOD.key, {
                handler: this.configPostMethod, 
                value: DEFAULT_CONFIG.POST_METHOD.value, 
                validator: function (val) {
                    if (val != "form" && val != "async" && val != "none" && 
                        val != "manual") {
                        return false;
                    } else {
                        return true;
                    }
                }
            });

            /**
            * This property is used to configure whether or not the 
            * dialog should be automatically hidden after submit.
            * 
            * @config hideaftersubmit
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.HIDEAFTERSUBMIT.key, {
                value: DEFAULT_CONFIG.HIDEAFTERSUBMIT.value
            }); 

            /**
            * Array of object literals, each containing a set of properties 
            * defining a button to be appended into the Dialog's footer.
            * 
            * Each button object in the buttons array can have three properties:
            * <dt>text:</dt>
            * <dd>The text that will display on the face of the button. The text can 
            * include HTML, as long as it is compliant with HTML Button specifications.
            * </dd>
            * <dt>handler:</dt>
            * <dd>Can be either:
            *     <ol>
            *         <li>A reference to a function that should fire when the 
            * button is clicked.  (In this case scope of this function is 
            * always its Dialog instance.)</li>
            *         <li>An object literal representing the code to be 
            * executed when the button is clicked.  Format:<br> <code> {<br>
            * <strong>fn:</strong> Function,   &#47;&#47; The handler to call 
            * when  the event fires.<br> <strong>obj:</strong> Object,
            * &#47;&#47; An  object to pass back to the handler.<br> <strong>
            * scope:</strong>  Object &#47;&#47; The object to use for the 
            * scope of the handler. <br> } </code> <br></li>
            *     </ol>
            * </dd>
            * <dt>isDefault:</dt>
            * <dd>An optional boolean value that specifies that a button 
            * should be highlighted and focused by default.</dd>
            * 
            * <em>NOTE:</em>If the YUI Button Widget is included on the page, 
            * the buttons created will be instances of pega.widget.Button. 
            * Otherwise, HTML Buttons (<code>&#60;BUTTON&#62;</code>) will be 
            * created.
            * 
            * @config buttons
            * @type {Array|String}
            * @default "none"
            */
            this.cfg.addProperty(DEFAULT_CONFIG.BUTTONS.key, {
                handler: this.configButtons,
                value: DEFAULT_CONFIG.BUTTONS.value
            }); 

        },

        /**
        * Initializes the custom events for Dialog which are fired 
        * automatically at appropriate times by the Dialog class.
        * @method initEvents
        */
        initEvents: function () {
            Dialog.superclass.initEvents.call(this);

            var SIGNATURE = CustomEvent.LIST;

            /**
            * CustomEvent fired prior to submission
            * @event beforeSubmitEvent
            */ 
            this.beforeSubmitEvent = 
                this.createEvent(EVENT_TYPES.BEFORE_SUBMIT);
            this.beforeSubmitEvent.signature = SIGNATURE;
            
            /**
            * CustomEvent fired after submission
            * @event submitEvent
            */
            this.submitEvent = this.createEvent(EVENT_TYPES.SUBMIT);
            this.submitEvent.signature = SIGNATURE;
        
            /**
            * CustomEvent fired prior to manual submission
            * @event manualSubmitEvent
            */
            this.manualSubmitEvent = 
                this.createEvent(EVENT_TYPES.MANUAL_SUBMIT);
            this.manualSubmitEvent.signature = SIGNATURE;
        
            /**
            * CustomEvent fired prior to asynchronous submission
            * @event asyncSubmitEvent
            */ 
            this.asyncSubmitEvent = this.createEvent(EVENT_TYPES.ASYNC_SUBMIT);
            this.asyncSubmitEvent.signature = SIGNATURE;
        
            /**
            * CustomEvent fired prior to form-based submission
            * @event formSubmitEvent
            */
            this.formSubmitEvent = this.createEvent(EVENT_TYPES.FORM_SUBMIT);
            this.formSubmitEvent.signature = SIGNATURE;
        
            /**
            * CustomEvent fired after cancel
            * @event cancelEvent
            */
            this.cancelEvent = this.createEvent(EVENT_TYPES.CANCEL);
            this.cancelEvent.signature = SIGNATURE;
        
        },
        
        /**
        * The Dialog initialization method, which is executed for Dialog and 
        * all of its subclasses. This method is automatically called by the 
        * constructor, and  sets up all DOM references for pre-existing markup, 
        * and creates required markup if it is not already present.
        * @method init
        * @param {String} el The element ID representing the Dialog <em>OR</em>
        * @param {HTMLElement} el The element representing the Dialog
        * @param {Object} userConfig The configuration object literal 
        * containing the configuration that should be set for this Dialog. 
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {

            /*
                 Note that we don't pass the user config in here yet because 
                 we only want it executed once, at the lowest subclass level
            */

            Dialog.superclass.init.call(this, el/*, userConfig*/); 
        
            this.beforeInitEvent.fire(Dialog);
        
            Dom.addClass(this.element, Dialog.CSS_DIALOG);
        
            this.cfg.setProperty("visible", false);
        
            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }
        
            this.showEvent.subscribe(this.focusFirst, this, true);
            this.beforeHideEvent.subscribe(this.blurButtons, this, true);

            this.subscribe("changeBody", this.registerForm);
        
            this.initEvent.fire(Dialog);
        },
        
        /**
        * Submits the Dialog's form depending on the value of the 
        * "postmethod" configuration property.  <strong>Please note:
        * </strong> As of version 2.3 this method will automatically handle 
        * asyncronous file uploads should the Dialog instance's form contain 
        * <code>&#60;input type="file"&#62;</code> elements.  If a Dialog 
        * instance will be handling asyncronous file uploads, its 
        * <code>callback</code> property will need to be setup with a 
        * <code>upload</code> handler rather than the standard 
        * <code>success</code> and, or <code>failure</code> handlers.  For more 
        * information, see the <a href="http://developer.yahoo.com/yui/
        * connection/#file">Connection Manager documenation on file uploads</a>.
        * @method doSubmit
        */
        doSubmit: function () {
    
            var oForm = this.form,
                bUseFileUpload = false,
                bUseSecureFileUpload = false,
                aElements,
                nElements,
                i,
                sMethod;

            switch (this.cfg.getProperty("postmethod")) {
    
            case "async":

                aElements = oForm.elements;
                nElements = aElements.length;

                if (nElements > 0) {
                    i = nElements - 1;
                    do {
                        if (aElements[i].type == "file") {
                            bUseFileUpload = true;
                            break;
                        }
                    }
                    while(i--);
                }

                if (bUseFileUpload && pega.env.ua.ie && this.isSecure) {
                    bUseSecureFileUpload = true;
                }

                sMethod = (oForm.getAttribute("method") || "POST").toUpperCase();

                Connect.setForm(oForm, bUseFileUpload, bUseSecureFileUpload);
                Connect.asyncRequest(sMethod, oForm.getAttribute("action"), this.callback);

                this.asyncSubmitEvent.fire();

                break;

            case "form":

                oForm.submit();
                this.formSubmitEvent.fire();

                break;

            case "none":
            case "manual":

                this.manualSubmitEvent.fire();

                break;
    
            }
    
        },
        
        
        /**
        * Prepares the Dialog's internal FORM object, creating one if one is
        * not currently present.
        * @method registerForm
        */
        registerForm: function () {
    
            var form = this.element.getElementsByTagName("form")[0],
                me = this,
                firstElement,
                lastElement;


            if (this.form) {
                if (this.form == form && 
                    Dom.isAncestor(this.element, this.form)) {
    
                    return;
                } else {
                    Event.purgeElement(this.form);
                    this.form = null;                
                }
            }

            if (!form) {
                form = document.createElement("form");
                form.name = "frm_" + this.id;

                this.body.appendChild(form);
            }

            if (form) {
                this.form = form;

                Event.on(form, "submit", function (e) {
                    Event.stopEvent(e);
                    this.submit();
                    this.form.blur();
                }, this, true);

                this.firstFormElement = function () {
                    var f, el, nElements = form.elements.length;

                    for (f = 0; f < nElements; f++) {
                        el = form.elements[f];
                        if (el.focus && !el.disabled && el.type != "hidden") {
                            return el;
                        }
                    }
                    return null;
                }();
            
                this.lastFormElement = function () {
                    var f, el, nElements = form.elements.length;
                    
                    for (f = nElements - 1; f >= 0; f--) {
                        el = form.elements[f];
                        if (el.focus && !el.disabled && el.type != "hidden") {
                            return el;
                        }
                    }
                    return null;
                }();
            
                if (this.cfg.getProperty("modal")) {
                    firstElement = this.firstFormElement || this.firstButton;
                    if (firstElement) {
                        this.preventBackTab = new KeyListener(firstElement, 
                            { shift: true, keys: 9 }, 
                            { fn: me.focusLast, scope: me, 
                            correctScope: true });
    
                        this.showEvent.subscribe(this.preventBackTab.enable, 
                            this.preventBackTab, true);
    
                        this.hideEvent.subscribe(this.preventBackTab.disable, 
                            this.preventBackTab, true);
                    }
            
                    lastElement = this.lastButton || this.lastFormElement;
    
                    if (lastElement) {
                        this.preventTabOut = new KeyListener(lastElement, 
                            { shift: false, keys: 9 }, 
                            { fn: me.focusFirst, scope: me, 
                            correctScope: true });
    
                        this.showEvent.subscribe(this.preventTabOut.enable, 
                            this.preventTabOut, true);
    
                        this.hideEvent.subscribe(this.preventTabOut.disable, 
                            this.preventTabOut, true);
                    }
                }
            }
        },
        
        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
        * The default event handler fired when the "close" property is 
        * changed. The method controls the appending or hiding of the close
        * icon at the top right of the Dialog.
        * @method configClose
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For 
        * configuration handlers, args[0] will equal the newly applied value 
        * for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configClose: function (type, args, obj) {
            var val = args[0];
        
            function doCancel(e, obj) {
                obj.cancel();
            }
        
            if (val) {
                if (! this.close) {
                    this.close = document.createElement("div");
                    Dom.addClass(this.close, "container-close");
        
                    this.close.innerHTML = "&#160;";
                    this.innerElement.appendChild(this.close);
                    Event.on(this.close, "click", doCancel, this);
                } else {
                    this.close.style.display = "block";
                }
            } else {
                if (this.close) {
                    this.close.style.display = "none";
                }
            }
        },
        
        /**
        * The default event handler for the "buttons" configuration property
        * @method configButtons
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configButtons: function (type, args, obj) {
    
            var Button = pega.widget.Button,
                aButtons = args[0],
                oInnerElement = this.innerElement,
                oButton,
                oButtonEl,
                oYUIButton,
                nButtons,
                oSpan,
                oFooter,
                i;

            removeButtonEventHandlers.call(this);
            
            this._aButtons = null;

            if (Lang.isArray(aButtons)) {

                oSpan = document.createElement("span");
                oSpan.className = "button-group";

                nButtons = aButtons.length;

                this._aButtons = [];
        
                for (i = 0; i < nButtons; i++) {

                    oButton = aButtons[i];

                    if (Button) {

                        oYUIButton = new Button({ label: oButton.text, 
                                            container: oSpan });

                        oButtonEl = oYUIButton.get("element");

                        if (oButton.isDefault) {

                            oYUIButton.addClass("default");

                            this.defaultHtmlButton = oButtonEl;

                        }
    
                        if (Lang.isFunction(oButton.handler)) {
    
                            oYUIButton.set("onclick", { fn: oButton.handler, 
                                obj: this, scope: this });
            
                        }
                        else if (Lang.isObject(oButton.handler) && 
                            Lang.isFunction(oButton.handler.fn)) {

                            oYUIButton.set("onclick", { fn: oButton.handler.fn, 
                                obj: ((!Lang.isUndefined(oButton.handler.obj)) ? 
                                oButton.handler.obj : this), 
                                scope: (oButton.handler.scope || this) });
    
                        }

                        this._aButtons[this._aButtons.length] = oYUIButton;

                    }
                    else {
        
                        oButtonEl = document.createElement("button");
                        oButtonEl.setAttribute("type", "button");
            
                        if (oButton.isDefault) {
                            oButtonEl.className = "default";
                            this.defaultHtmlButton = oButtonEl;
                        }
    
                        oButtonEl.innerHTML = oButton.text;
    
                        if (Lang.isFunction(oButton.handler)) {
    
                            Event.on(oButtonEl, "click", oButton.handler, 
                                this, true);
            
                        }
                        else if (Lang.isObject(oButton.handler) && 
                            Lang.isFunction(oButton.handler.fn)) {
    
                            Event.on(oButtonEl, "click", oButton.handler.fn, 
                                ((!Lang.isUndefined(oButton.handler.obj)) ? 
                                oButton.handler.obj : this), 
                                (oButton.handler.scope || this));
    
                        }
            
                        oSpan.appendChild(oButtonEl);
                        
                        this._aButtons[this._aButtons.length] = oButtonEl;
                        
                    }

                    oButton.htmlButton = oButtonEl;
        
                    if (i === 0) {
                        this.firstButton = oButtonEl;
                    }
        
                    if (i == (nButtons - 1)) {
                        this.lastButton = oButtonEl;
                    }
        
                }
        
                this.setFooter(oSpan);

                oFooter = this.footer;
                
                if (Dom.inDocument(this.element) && 
                    !Dom.isAncestor(oInnerElement, oFooter)) {
    
                    oInnerElement.appendChild(oFooter);
                
                }

                this.buttonSpan = oSpan;

            } else { // Do cleanup

                oSpan = this.buttonSpan;
                oFooter = this.footer;

                if (oSpan && oFooter) {

                    oFooter.removeChild(oSpan);

                    this.buttonSpan = null;
                    this.firstButton = null;
                    this.lastButton = null;
                    this.defaultHtmlButton = null;

                }

            }

            this.cfg.refireEvent("iframe");
            this.cfg.refireEvent("underlay");
        },

        /**
        * @method getButtons
        * @description Returns an array containing each of the Dialog's 
        * buttons, by default an array of HTML <code>&#60;BUTTON&#62;</code> 
        * elements.  If the Dialog's buttons were created using the 
        * pega.widget.Button class (via the inclusion of the optional Button 
        * dependancy on the page), an array of pega.widget.Button instances 
        * is returned.
        * @return {Array}
        */
        getButtons: function () {
            var aButtons = this._aButtons;
            if (aButtons) {
                return aButtons;
            }
        },
        
        /**
        * Sets focus to the first element in the Dialog's form or the first 
        * button defined via the "buttons" configuration property. Called 
        * when the Dialog is made visible.
        * @method focusFirst
        */
        focusFirst: function (type, args, obj) {
    
            var oElement = this.firstFormElement,
                oEvent;

            if (args) {
                oEvent = args[1];
                if (oEvent) {
                    Event.stopEvent(oEvent);
                }
            }

            if (oElement) {
                /*
                    Place the call to the "focus" method inside a try/catch
                    block to prevent IE from throwing JavaScript errors if
                    the element is disabled or hidden.
                */
                try {
                    oElement.focus();
                }
                catch(oException) {
                }

            } else {
                this.focusDefaultButton();
            }
        },
        
        /**
        * Sets focus to the last element in the Dialog's form or the last 
        * button defined via the "buttons" configuration property.
        * @method focusLast
        */
        focusLast: function (type, args, obj) {
    
            var aButtons = this.cfg.getProperty("buttons"),
                oElement = this.lastFormElement,
                oEvent;
    
            if (args) {
                oEvent = args[1];
                if (oEvent) {
                    Event.stopEvent(oEvent);
                }
            }
            
            if (aButtons && Lang.isArray(aButtons)) {
                this.focusLastButton();
            } else {
                if (oElement) {
                    /*
                        Place the call to the "focus" method inside a try/catch
                        block to prevent IE from throwing JavaScript errors if
                        the element is disabled or hidden.
                    */
    
                    try {
                        oElement.focus();
                    } catch(oException) {
                    }
                }
            }
        },
        
        /**
        * Sets the focus to the button that is designated as the default via 
        * the "buttons" configuration property. By default, this method is 
        * called when the Dialog is made visible.
        * @method focusDefaultButton
        */
        focusDefaultButton: function () {
        
            var oElement = this.defaultHtmlButton;
        
            if (oElement) {

                /*
                    Place the call to the "focus" method inside a try/catch
                    block to prevent IE from throwing JavaScript errors if
                    the element is disabled or hidden.
                */
                try {
                    oElement.focus();
                } catch(oException) {
                }

            }
        },
        
        /**
        * Blurs all the buttons defined via the "buttons" 
        * configuration property.
        * @method blurButtons
        */
        blurButtons: function () {
            
            var aButtons = this.cfg.getProperty("buttons"),
                nButtons,
                oButton,
                oElement,
                i;

            if (aButtons && Lang.isArray(aButtons)) {
            
                nButtons = aButtons.length;
                
                if (nButtons > 0) {
                
                    i = (nButtons - 1);
                    
                    do {
                        oButton = aButtons[i];
                        
                        if (oButton) {

                            oElement = oButton.htmlButton;

                            if (oElement) {
                                /*
                                    Place the call to the "blur" method inside  
                                    a try/catch block to prevent IE from  
                                    throwing JavaScript errors if the element 
                                    is disabled or hidden.
                                */
                                try {
                                    oElement.blur();
                                } catch(oException) {
                                }
                            }
                        }
                    
                    } while(i--);
                }
            }
        },
        
        /**
        * Sets the focus to the first button created via the "buttons"
        * configuration property.
        * @method focusFirstButton
        */
        focusFirstButton: function () {
    
            var aButtons = this.cfg.getProperty("buttons"),
                oButton,
                oElement;

            if (aButtons && Lang.isArray(aButtons)) {

                oButton = aButtons[0];

                if (oButton) {

                    oElement = oButton.htmlButton;
                    
                    if (oElement) {

                        /*
                            Place the call to the "focus" method inside a 
                            try/catch block to prevent IE from throwing 
                            JavaScript errors if the element is disabled 
                            or hidden.
                        */
    
                        try {
                            oElement.focus();
                        }
                        catch(oException) {
                        }
                    }
                }
            }
        },
        
        /**
        * Sets the focus to the last button created via the "buttons" 
        * configuration property.
        * @method focusLastButton
        */
        focusLastButton: function () {
    
            var aButtons = this.cfg.getProperty("buttons"),
                nButtons,
                oButton,
                oElement;

            if (aButtons && Lang.isArray(aButtons)) {

                nButtons = aButtons.length;
                
                if (nButtons > 0) {
                    oButton = aButtons[(nButtons - 1)];
                    
                    if (oButton) {
                        oElement = oButton.htmlButton;
                        if (oElement) {
                            /*
                                Place the call to the "focus" method inside a 
                                try/catch block to prevent IE from throwing 
                                JavaScript errors if the element is disabled
                                or hidden.
                            */
        
                            try {
                                oElement.focus();
                            } catch(oException) {
                            }
                        }
                    }
                }
            }
        },
        
        /**
        * The default event handler for the "postmethod" configuration property
        * @method configPostMethod
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For 
        * configuration handlers, args[0] will equal the newly applied value 
        * for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configPostMethod: function (type, args, obj) {
            this.registerForm();
        },
        
        // END BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
        * Built-in function hook for writing a validation function that will 
        * be checked for a "true" value prior to a submit. This function, as 
        * implemented by default, always returns true, so it should be 
        * overridden if validation is necessary.
        * @method validate
        */
        validate: function () {
            return true;
        },
        
        /**
        * Executes a submit of the Dialog if validation 
        * is successful. By default the Dialog is hidden
        * after submission, but you can set the "hideaftersubmit"
        * configuration property to false, to prevent the Dialog
        * from being hidden.
        * 
        * @method submit
        */
        submit: function () {
            if (this.validate()) {
                this.beforeSubmitEvent.fire();
                this.doSubmit();
                this.submitEvent.fire();

                if (this.cfg.getProperty("hideaftersubmit")) {
                    this.hide();
                }

                return true;
            } else {
                return false;
            }
        },

        /**
        * Executes the cancel of the Dialog followed by a hide.
        * @method cancel
        */
        cancel: function () {
            this.cancelEvent.fire();
            this.hide();
        },
        
        /**
        * Returns a JSON-compatible data structure representing the data 
        * currently contained in the form.
        * @method getData
        * @return {Object} A JSON object reprsenting the data of the 
        * current form.
        */
        getData: function () {
        
            var oForm = this.form,
                aElements,
                nTotalElements,
                oData,
                sName,
                oElement,
                nElements,
                sType,
                sTagName,
                aOptions,
                nOptions,
                aValues,
                oOption,
                sValue,
                oRadio,
                oCheckbox,
                i,
                n;    
    
            function isFormElement(p_oElement) {
            
                var sTag = p_oElement.tagName.toUpperCase();
                
                return ((sTag == "INPUT" || sTag == "TEXTAREA" || 
                        sTag == "SELECT") && p_oElement.name == sName);
    
            }
    
    
            if (oForm) {
        
                aElements = oForm.elements;
                nTotalElements = aElements.length;
                oData = {};
    
        
                for (i = 0; i < nTotalElements; i++) {
        
                    sName = aElements[i].name;
        
                    /*
                        Using "Dom.getElementsBy" to safeguard user from JS 
                        errors that result from giving a form field (or set of 
                        fields) the same name as a native method of a form 
                        (like "submit") or a DOM collection (such as the "item"
                        method). Originally tried accessing fields via the 
                        "namedItem" method of the "element" collection, but 
                        discovered that it won't return a collection of fields 
                        in Gecko.
                    */
        
                    oElement = Dom.getElementsBy(isFormElement, "*", oForm);
                    nElements = oElement.length;
        
                    if (nElements > 0) {
        
                        if (nElements == 1) {
        
                            oElement = oElement[0];
        
                            sType = oElement.type;
                            sTagName = oElement.tagName.toUpperCase();
        
                            switch (sTagName) {
        
                            case "INPUT":
    
                                if (sType == "checkbox") {
    
                                    oData[sName] = oElement.checked;
    
                                }
                                else if (sType != "radio") {
    
                                    oData[sName] = oElement.value;
    
                                }
    
                                break;
    
                            case "TEXTAREA":
    
                                oData[sName] = oElement.value;
    
                                break;
    
                            case "SELECT":
    
                                aOptions = oElement.options;
                                nOptions = aOptions.length;
                                aValues = [];
    
                                for (n = 0; n < nOptions; n++) {
    
                                    oOption = aOptions[n];
    
                                    if (oOption.selected) {
    
                                        sValue = oOption.value;
    
                                        if (!sValue || sValue === "") {
    
                                            sValue = oOption.text;
    
                                        }
    
                                        aValues[aValues.length] = sValue;
    
                                    }
    
                                }
    
                                oData[sName] = aValues;
    
                                break;
        
                            }
        
        
                        }
                        else {
        
                            sType = oElement[0].type;
        
                            switch (sType) {
        
                            case "radio":
    
                                for (n = 0; n < nElements; n++) {
    
                                    oRadio = oElement[n];
    
                                    if (oRadio.checked) {
    
                                        oData[sName] = oRadio.value;
                                        break;
    
                                    }
    
                                }
    
                                break;
    
                            case "checkbox":
    
                                aValues = [];
    
                                for (n = 0; n < nElements; n++) {
    
                                    oCheckbox = oElement[n];
    
                                    if (oCheckbox.checked) {
    
                                        aValues[aValues.length] = 
                                            oCheckbox.value;
    
                                    }
    
                                }
    
                                oData[sName] = aValues;
    
                                break;
        
                            }
        
                        }
        
                    }
        
                }
        
            }
        
        
            return oData;
        
        },
        
        /**
        * Removes the Panel element from the DOM and sets all child elements 
        * to null.
        * @method destroy
        */
        destroy: function () {
        
            removeButtonEventHandlers.call(this);
            
            this._aButtons = null;

            var aForms = this.element.getElementsByTagName("form"),
                oForm;
            
            if (aForms.length > 0) {

                oForm = aForms[0];

                if (oForm) {
                    Event.purgeElement(oForm);
                    if (oForm.parentNode) {
                        oForm.parentNode.removeChild(oForm);
                    }
                    this.form = null;
                }
            }
        
            Dialog.superclass.destroy.call(this);  
        
        },
        
        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the Dialog
        */
        toString: function () {
            return "Dialog " + this.id;
        }
    
    });

}());

(function () {

    /**
    * SimpleDialog is a simple implementation of Dialog that can be used to 
    * submit a single value. Forms can be processed in 3 ways -- via an 
    * asynchronous Connection utility call, a simple form POST or GET, 
    * or manually.
    * @namespace pega.widget
    * @class SimpleDialog
    * @extends pega.widget.Dialog
    * @constructor
    * @param {String} el The element ID representing the SimpleDialog 
    * <em>OR</em>
    * @param {HTMLElement} el The element representing the SimpleDialog
    * @param {Object} userConfig The configuration object literal containing 
    * the configuration that should be set for this SimpleDialog. See 
    * configuration documentation for more details.
    */
    pega.widget.SimpleDialog = function (el, userConfig) {
    
        pega.widget.SimpleDialog.superclass.constructor.call(this, 
            el, userConfig);
    
    };

    var Dom = pega.util.Dom,
        SimpleDialog = pega.widget.SimpleDialog,
    
        /**
        * Constant representing the SimpleDialog's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {
        
            "ICON": { 
                key: "icon", 
                value: "none", 
                suppressEvent: true  
            },
        
            "TEXT": { 
                key: "text", 
                value: "", 
                suppressEvent: true, 
                supercedes: ["icon"] 
            }
        
        };

    /**
    * Constant for the standard network icon for a blocking action
    * @property pega.widget.SimpleDialog.ICON_BLOCK
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_BLOCK = "blckicon";
    
    /**
    * Constant for the standard network icon for alarm
    * @property pega.widget.SimpleDialog.ICON_ALARM
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_ALARM = "alrticon";
    
    /**
    * Constant for the standard network icon for help
    * @property pega.widget.SimpleDialog.ICON_HELP
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_HELP  = "hlpicon";
    
    /**
    * Constant for the standard network icon for info
    * @property pega.widget.SimpleDialog.ICON_INFO
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_INFO  = "infoicon";
    
    /**
    * Constant for the standard network icon for warn
    * @property pega.widget.SimpleDialog.ICON_WARN
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_WARN  = "warnicon";
    
    /**
    * Constant for the standard network icon for a tip
    * @property pega.widget.SimpleDialog.ICON_TIP
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_TIP   = "tipicon";

    /**
    * Constant representing the name of the CSS class applied to the element 
    * created by the "icon" configuration property.
    * @property pega.widget.SimpleDialog.ICON_CSS_CLASSNAME
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_CSS_CLASSNAME = "yui-icon";
    
    /**
    * Constant representing the default CSS class used for a SimpleDialog
    * @property pega.widget.SimpleDialog.CSS_SIMPLEDIALOG
    * @static
    * @final
    * @type String
    */
    SimpleDialog.CSS_SIMPLEDIALOG = "yui-simple-dialog";

    
    pega.extend(SimpleDialog, pega.widget.Dialog, {
    
        /**
        * Initializes the class's configurable properties which can be changed 
        * using the SimpleDialog's Config object (cfg).
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {
        
            SimpleDialog.superclass.initDefaultConfig.call(this);
        
            // Add dialog config properties //
        
            /**
            * Sets the informational icon for the SimpleDialog
            * @config icon
            * @type String
            * @default "none"
            */
            this.cfg.addProperty(DEFAULT_CONFIG.ICON.key, {
                handler: this.configIcon,
                value: DEFAULT_CONFIG.ICON.value,
                suppressEvent: DEFAULT_CONFIG.ICON.suppressEvent
            });
        
            /**
            * Sets the text for the SimpleDialog
            * @config text
            * @type String
            * @default ""
            */
            this.cfg.addProperty(DEFAULT_CONFIG.TEXT.key, { 
                handler: this.configText, 
                value: DEFAULT_CONFIG.TEXT.value, 
                suppressEvent: DEFAULT_CONFIG.TEXT.suppressEvent, 
                supercedes: DEFAULT_CONFIG.TEXT.supercedes 
            });
        
        },
        
        
        /**
        * The SimpleDialog initialization method, which is executed for 
        * SimpleDialog and all of its subclasses. This method is automatically 
        * called by the constructor, and  sets up all DOM references for 
        * pre-existing markup, and creates required markup if it is not 
        * already present.
        * @method init
        * @param {String} el The element ID representing the SimpleDialog 
        * <em>OR</em>
        * @param {HTMLElement} el The element representing the SimpleDialog
        * @param {Object} userConfig The configuration object literal 
        * containing the configuration that should be set for this 
        * SimpleDialog. See configuration documentation for more details.
        */
        init: function (el, userConfig) {

            /*
                Note that we don't pass the user config in here yet because we 
                only want it executed once, at the lowest subclass level
            */

            SimpleDialog.superclass.init.call(this, el/*, userConfig*/);
        
            this.beforeInitEvent.fire(SimpleDialog);
        
            Dom.addClass(this.element, SimpleDialog.CSS_SIMPLEDIALOG);
        
            this.cfg.queueProperty("postmethod", "manual");
        
            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }
        
            this.beforeRenderEvent.subscribe(function () {
                if (! this.body) {
                    this.setBody("");
                }
            }, this, true);
        
            this.initEvent.fire(SimpleDialog);
        
        },
        
        /**
        * Prepares the SimpleDialog's internal FORM object, creating one if one 
        * is not currently present, and adding the value hidden field.
        * @method registerForm
        */
        registerForm: function () {

            SimpleDialog.superclass.registerForm.call(this);

            this.form.innerHTML += "<input type=\"hidden\" name=\"" + 
                this.id + "\" value=\"\"/>";

        },
        
        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
        * Fired when the "icon" property is set.
        * @method configIcon
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configIcon: function (type,args,obj) {
        
            var sIcon = args[0],
                oBody = this.body,
                sCSSClass = SimpleDialog.ICON_CSS_CLASSNAME,
                oIcon,
                oIconParent;
        
            if (sIcon && sIcon != "none") {

                oIcon = Dom.getElementsByClassName(sCSSClass, "*" , oBody);

                if (oIcon) {

                    oIconParent = oIcon.parentNode;
                    
                    if (oIconParent) {
                    
                        oIconParent.removeChild(oIcon);
                        
                        oIcon = null;
                    
                    }

                }


                if (sIcon.indexOf(".") == -1) {

                    oIcon = document.createElement("span");
                    oIcon.className = (sCSSClass + " " + sIcon);
                    oIcon.innerHTML = "&#160;";

                } else {

                    oIcon = document.createElement("img");
                    oIcon.src = (this.imageRoot + sIcon);
                    oIcon.className = sCSSClass;

                }
                

                if (oIcon) {
                
                    oBody.insertBefore(oIcon, oBody.firstChild);
                
                }

            }

        },
        
        /**
        * Fired when the "text" property is set.
        * @method configText
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration 
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers, 
        * this will usually equal the owner.
        */
        configText: function (type,args,obj) {
            var text = args[0];
            if (text) {
                this.setBody(text);
                this.cfg.refireEvent("icon");
            }
        },
        
        // END BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the SimpleDialog
        */
        toString: function () {
            return "SimpleDialog " + this.id;
        }
    
    });

}());

(function () {

    /**
    * ContainerEffect encapsulates animation transitions that are executed when 
    * an Overlay is shown or hidden.
    * @namespace pega.widget
    * @class ContainerEffect
    * @constructor
    * @param {pega.widget.Overlay} overlay The Overlay that the animation 
    * should be associated with
    * @param {Object} attrIn The object literal representing the animation 
    * arguments to be used for the animate-in transition. The arguments for 
    * this literal are: attributes(object, see pega.util.Anim for description), 
    * duration(Number), and method(i.e. Easing.easeIn).
    * @param {Object} attrOut The object literal representing the animation 
    * arguments to be used for the animate-out transition. The arguments for  
    * this literal are: attributes(object, see pega.util.Anim for description), 
    * duration(Number), and method(i.e. Easing.easeIn).
    * @param {HTMLElement} targetElement Optional. The target element that  
    * should be animated during the transition. Defaults to overlay.element.
    * @param {class} Optional. The animation class to instantiate. Defaults to 
    * pega.util.Anim. Other options include pega.util.Motion.
    */
    pega.widget.ContainerEffect = 
    
        function (overlay, attrIn, attrOut, targetElement, animClass) {
    
        if (!animClass) {
            animClass = pega.util.Anim;
        }
        
        /**
        * The overlay to animate
        * @property overlay
        * @type pega.widget.Overlay
        */
        this.overlay = overlay;
    
        /**
        * The animation attributes to use when transitioning into view
        * @property attrIn
        * @type Object
        */
        this.attrIn = attrIn;
    
        /**
        * The animation attributes to use when transitioning out of view
        * @property attrOut
        * @type Object
        */
        this.attrOut = attrOut;
    
        /**
        * The target element to be animated
        * @property targetElement
        * @type HTMLElement
        */
        this.targetElement = targetElement || overlay.element;
    
        /**
        * The animation class to use for animating the overlay
        * @property animClass
        * @type class
        */
        this.animClass = animClass;
    
    };


    var Dom = pega.util.Dom,
        CustomEvent = pega.util.CustomEvent,
        Easing = pega.util.Easing,
        ContainerEffect = pega.widget.ContainerEffect;


    /**
    * A pre-configured ContainerEffect instance that can be used for fading 
    * an overlay in and out.
    * @method FADE
    * @static
    * @param {pega.widget.Overlay} overlay The Overlay object to animate
    * @param {Number} dur The duration of the animation
    * @return {pega.widget.ContainerEffect} The configured ContainerEffect object
    */
    ContainerEffect.FADE = function (overlay, dur) {

        var fin = {
            attributes: {opacity:{from:0, to:1}},
            duration: dur,
            method: Easing.easeIn
        };

        var fout = {
            attributes: {opacity:{to:0}},
            duration: dur,
            method: Easing.easeOut
        };

        var fade = new ContainerEffect(overlay, fin, fout, overlay.element);

        fade.handleUnderlayStart = function() {
            var underlay = this.overlay.underlay;
            if (underlay && pega.env.ua.ie) {
                var hasFilters = (underlay.filters && underlay.filters.length > 0);
                if(hasFilters) {
                    Dom.addClass(overlay.element, "yui-effect-fade");
                }
            }
        };

        fade.handleUnderlayComplete = function() {
            var underlay = this.overlay.underlay;
            if (underlay && pega.env.ua.ie) {
                Dom.removeClass(overlay.element, "yui-effect-fade");
            }
        };

        fade.handleStartAnimateIn = function (type,args,obj) {
            Dom.addClass(obj.overlay.element, "hide-select");

            if (!obj.overlay.underlay) {
                obj.overlay.cfg.refireEvent("underlay");
            }

            obj.handleUnderlayStart();

            Dom.setStyle(obj.overlay.element, "visibility", "visible");
            Dom.setStyle(obj.overlay.element, "opacity", 0);
        };

        fade.handleCompleteAnimateIn = function (type,args,obj) {
            Dom.removeClass(obj.overlay.element, "hide-select");

            if (obj.overlay.element.style.filter) {
                obj.overlay.element.style.filter = null;
            }

            obj.handleUnderlayComplete();

            obj.overlay.cfg.refireEvent("iframe");
            obj.animateInCompleteEvent.fire();
        };

        fade.handleStartAnimateOut = function (type, args, obj) {
            Dom.addClass(obj.overlay.element, "hide-select");
            obj.handleUnderlayStart();
        };

        fade.handleCompleteAnimateOut =  function (type, args, obj) {
            Dom.removeClass(obj.overlay.element, "hide-select");
            if (obj.overlay.element.style.filter) {
                obj.overlay.element.style.filter = null;
            }
            Dom.setStyle(obj.overlay.element, "visibility", "hidden");
            Dom.setStyle(obj.overlay.element, "opacity", 1);

            obj.handleUnderlayComplete();

            obj.overlay.cfg.refireEvent("iframe");
            obj.animateOutCompleteEvent.fire();
        };

        fade.init();
        return fade;
    };
    
    
    /**
    * A pre-configured ContainerEffect instance that can be used for sliding an 
    * overlay in and out.
    * @method SLIDE
    * @static
    * @param {pega.widget.Overlay} overlay The Overlay object to animate
    * @param {Number} dur The duration of the animation
    * @return {pega.widget.ContainerEffect} The configured ContainerEffect object
    */
    ContainerEffect.SLIDE = function (overlay, dur) {
    
        var x = overlay.cfg.getProperty("x") || Dom.getX(overlay.element),
    
            y = overlay.cfg.getProperty("y") || Dom.getY(overlay.element),
    
            clientWidth = Dom.getClientWidth(),
    
            offsetWidth = overlay.element.offsetWidth,
    
            slide = new ContainerEffect(overlay, 
            
            { attributes: { points: { to: [x, y] } },
                duration: dur,
                method: Easing.easeIn },
    
            { attributes: { points: { to: [(clientWidth + 25), y] } },
                duration: dur,
                method: Easing.easeOut },
    
            overlay.element, pega.util.Motion);
        
        
        slide.handleStartAnimateIn = function (type,args,obj) {
            obj.overlay.element.style.left = ((-25) - offsetWidth) + "px";
            obj.overlay.element.style.top  = y + "px";
        };
        
        slide.handleTweenAnimateIn = function (type, args, obj) {
        
            var pos = Dom.getXY(obj.overlay.element),
                currentX = pos[0],
                currentY = pos[1];
        
            if (Dom.getStyle(obj.overlay.element, "visibility") == 
                "hidden" && currentX < x) {

                Dom.setStyle(obj.overlay.element, "visibility", "visible");

            }
        
            obj.overlay.cfg.setProperty("xy", [currentX, currentY], true);
            obj.overlay.cfg.refireEvent("iframe");
        };
        
        slide.handleCompleteAnimateIn = function (type, args, obj) {
            obj.overlay.cfg.setProperty("xy", [x, y], true);
            obj.startX = x;
            obj.startY = y;
            obj.overlay.cfg.refireEvent("iframe");
            obj.animateInCompleteEvent.fire();
        };
        
        slide.handleStartAnimateOut = function (type, args, obj) {
    
            var vw = Dom.getViewportWidth(),
                pos = Dom.getXY(obj.overlay.element),
                yso = pos[1];
    
            obj.animOut.attributes.points.to = [(vw + 25), yso];
        };
        
        slide.handleTweenAnimateOut = function (type, args, obj) {
    
            var pos = Dom.getXY(obj.overlay.element),
                xto = pos[0],
                yto = pos[1];
        
            obj.overlay.cfg.setProperty("xy", [xto, yto], true);
            obj.overlay.cfg.refireEvent("iframe");
        };
        
        slide.handleCompleteAnimateOut = function (type, args, obj) {
            Dom.setStyle(obj.overlay.element, "visibility", "hidden");
        
            obj.overlay.cfg.setProperty("xy", [x, y]);
            obj.animateOutCompleteEvent.fire();
        };
        
        slide.init();
        return slide;
    };
    
    ContainerEffect.prototype = {
    
        /**
        * Initializes the animation classes and events.
        * @method init
        */
        init: function () {

            this.beforeAnimateInEvent = this.createEvent("beforeAnimateIn");
            this.beforeAnimateInEvent.signature = CustomEvent.LIST;
            
            this.beforeAnimateOutEvent = this.createEvent("beforeAnimateOut");
            this.beforeAnimateOutEvent.signature = CustomEvent.LIST;
        
            this.animateInCompleteEvent = this.createEvent("animateInComplete");
            this.animateInCompleteEvent.signature = CustomEvent.LIST;
        
            this.animateOutCompleteEvent = 
                this.createEvent("animateOutComplete");
            this.animateOutCompleteEvent.signature = CustomEvent.LIST;
        
            this.animIn = new this.animClass(this.targetElement, 
                this.attrIn.attributes, this.attrIn.duration, 
                this.attrIn.method);

            this.animIn.onStart.subscribe(this.handleStartAnimateIn, this);
            this.animIn.onTween.subscribe(this.handleTweenAnimateIn, this);

            this.animIn.onComplete.subscribe(this.handleCompleteAnimateIn, 
                this);
        
            this.animOut = new this.animClass(this.targetElement, 
                this.attrOut.attributes, this.attrOut.duration, 
                this.attrOut.method);

            this.animOut.onStart.subscribe(this.handleStartAnimateOut, this);
            this.animOut.onTween.subscribe(this.handleTweenAnimateOut, this);
            this.animOut.onComplete.subscribe(this.handleCompleteAnimateOut, 
                this);

        },
        
        /**
        * Triggers the in-animation.
        * @method animateIn
        */
        animateIn: function () {
            this.beforeAnimateInEvent.fire();
            this.animIn.animate();
        },
        
        /**
        * Triggers the out-animation.
        * @method animateOut
        */
        animateOut: function () {
            this.beforeAnimateOutEvent.fire();
            this.animOut.animate();
        },
        
        /**
        * The default onStart handler for the in-animation.
        * @method handleStartAnimateIn
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleStartAnimateIn: function (type, args, obj) { },
    
        /**
        * The default onTween handler for the in-animation.
        * @method handleTweenAnimateIn
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleTweenAnimateIn: function (type, args, obj) { },
    
        /**
        * The default onComplete handler for the in-animation.
        * @method handleCompleteAnimateIn
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleCompleteAnimateIn: function (type, args, obj) { },
        
        /**
        * The default onStart handler for the out-animation.
        * @method handleStartAnimateOut
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleStartAnimateOut: function (type, args, obj) { },
    
        /**
        * The default onTween handler for the out-animation.
        * @method handleTweenAnimateOut
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleTweenAnimateOut: function (type, args, obj) { },
    
        /**
        * The default onComplete handler for the out-animation.
        * @method handleCompleteAnimateOut
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleCompleteAnimateOut: function (type, args, obj) { },
        
        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the ContainerEffect
        */
        toString: function () {
            var output = "ContainerEffect";
            if (this.overlay) {
                output += " [" + this.overlay.toString() + "]";
            }
            return output;
        }
    
    };

    pega.lang.augmentProto(ContainerEffect, pega.util.EventProvider);

})();

pega.register("container", pega.widget.Module, {version: "2.5.2", build: "1076"});
//static-content-hash-trigger-GCC
var gEventType = "Refresh Section";
var uwtUserStart = 0;

function setUserStart(eventType) {
	uwtUserStart = new Date().getTime();

	if( typeof(eventType) !== 'undefined' ) {
		gEventType = eventType;
	}
}

if(typeof desktopwrappersupport_getDesktopWindow== "function"){
	pega.u.d.myDesktop = desktopwrappersupport_getDesktopWindow();
}

function doFormSubmit(strAction, objButton, strBusyText,event) {
	return pega.u.d.submit(strAction, objButton, strBusyText,event);
}

function openUrlInWindow(oUrl, sName, sOptions, bReplace,event) {
	return pega.u.d.openUrlInWindow(oUrl, sName, sOptions, bReplace,event);
}

function shrinkToFit() {
	pega.u.d.shrinkToFit();
}

function checkContainersExpanded() {
  	if (typeof pega.u.d.checkContainersExpanded === "function") {
		pega.u.d.checkContainersExpanded();
    }
}

function doHarnessResize() {
	/*
	 * In IE9, the parallel downloads are limited;
	 * resize even can trigger earlier than load event of document;
	 * pega.u.d may not be available sporadically hence catching the IE9FileDownloadException;
	 */
	try {
		pega.u.d.doHarnessResize();
	}catch(IE9FileDownloadException) {}
}

function selectTab(event) {
	pega.u.d.selectTab(event);
}

function doClose(event){
if(pega.ui.NavigateTopHandler){ // We are in nav top frameless DC
	pega.desktop.activateDocument(0);
	return;
}

	pega.u.d.doClose(event);
}

function ShowSubscriptPrompt(PageGroupProperty, ClassName, pageName, customActivity,event, partialRefresh){
	pega.u.d.ShowSubscriptPrompt(PageGroupProperty, ClassName, pageName, customActivity,event, partialRefresh);
}

function AppendToGroup(PageGroupProperty, ClassName, Subscript, pageName, customActivity,event, partialRefresh){
	pega.u.d.AppendToGroup(PageGroupProperty, ClassName, Subscript, pageName, customActivity,event, partialRefresh);
}

function RemoveFromGroup(PageGroupProperty, Subscript, pageName, customActivity,event, partialRefresh){
	pega.u.d.RemoveFromGroup(PageGroupProperty, Subscript, pageName, customActivity,event, partialRefresh);
}

function expandIt(expandElement,event){
	if (typeof pega.u.d.expandIt === "function") {
		pega.u.d.expandIt(expandElement,event);
    }
}

function expandHeader(expandElement, event, container, bFromKeyboard){
	if (typeof pega.u.d.expandHeader === "function") {
		pega.u.d.expandHeader(expandElement, event, container, bFromKeyboard);
    }
}

function displayFormErrors(errorFromServer){
	pega.u.d.displayFormErrors(errorFromServer);
}

function toggleExpandCollapse(event){
  	if (typeof pega.u.d.toggleExpandCollapse === "function") {
		pega.u.d.toggleExpandCollapse(event);
    }
}

function customActivityInPopup(url,windowHeight,windowWidth,event){
	pega.u.d.customActivityInPopup(url,windowHeight,windowWidth,event);
}


function attachAccessKeys(){
	pega.u.d.attachAccessKeys();
}

function loadContainer(expandElement, event,container){
	pega.u.d.loadContainer(expandElement, event,container);
}

function h_isHarness(strWindow) {
	var oWnd = window;
	 if (strWindow == "PARENT") {
		oWnd = window.parent;
	} 
	if (oWnd.document.getElementById("PEGA_HARNESS"))  {
		return true;
	}  
	return false;     
}

function handleUpdate(event){
	pega.u.d.handleUpdate(event);
}

function doSave(bSaveAndContinue,event, bCloseAfterSave){
  pega.u.d.doSave(bSaveAndContinue,event, bCloseAfterSave);
}

function processAction(taskStatus, taskIndex, streamType, prevTaskIndex, prevTaskStatus,bIsModal,event,modalSection,urlObj,reloadElement,bCalledFromGrid){
 pega.u.d.processAction(taskStatus, taskIndex, streamType, prevTaskIndex, prevTaskStatus,bIsModal,event,modalSection,urlObj,reloadElement,bCalledFromGrid);
}

function AppendToList(PageListProperty, ClassName, element, pageName, customActivity, event, partialRefresh){
	pega.u.d.AppendToList(PageListProperty, ClassName, element, pageName, customActivity, event, partialRefresh);
}

function RemoveFromList(PageListProperty, element, pageName, customActivity, event, partialRefresh){
	pega.u.d.RemoveFromList(PageListProperty, element, pageName, customActivity,event, partialRefresh);
}

 
function handleClientEvent(eventType, activityName, activityParams, index, event, dataTransform){
	pega.u.d.handleClientEvent(eventType, activityName, activityParams, index, event, dataTransform);
}

function doPrintDiv( DivId ) {
         pega.u.d.doPrintDiv(DivId);
}

function harnessOnLoad(){
	pega.u.d.harnessOnLoad();
}

function harnessOnUnload(){
	pega.u.d.harnessOnUnload();
}

function disableAllOtherButtons(  srcElement ) {
	pega.u.d.disableAllOtherButtons( srcElement );
}

function makeButtonBusy(objButton, strBusyText){
	pega.u.d.makeButtonBusy(objButton, strBusyText);
}

function explorerFormIsDirty(){
	return pega.u.d.explorerFormIsDirty();
}

function reSubmit(actionParams){
	pega.u.d.reSubmit(actionParams);
}

function displayHelp(event){
	pega.u.d.displayHelp(event);
}

function doSubmit(event) {
	doFormSubmit('pyActivity=FinishAssignment',null,'',event)
}

function doModalAction(submitModalDlgParam,event){
  //Added a null check to avoid the execution of submit call if there are any validation errors on client side.... BUG-289924
  if(submitModalDlgParam!=null){
	pega.u.d.doModalAction(submitModalDlgParam,event);
   }
}

function doOverlayAction(submitModalDlgParam,event){
	pega.u.d.doOverlayAction(submitModalDlgParam,event);
}

function takeAction(taskStatus, taskIndex, streamType, uiRef, uiType, ele, event) {
	pega.u.d.takeAction(taskStatus, taskIndex, streamType, uiRef, uiType, ele, event);
}

function checkEnterKey(event) {
	pega.u.d.checkEnterKey(event);
}

function checkEnterKeyNoSubmit(event) {
	pega.u.d.checkEnterKeyNoSubmit(event);
}

/*
* BUG-56496 : HTTP Status 403 - Directory listings are not allowed 
* Added this function to reduce markup size
*/
function pd(event) {
	if(pega.util && pega.util.Event) {
		pega.util.Event.preventDefault(event);
	}
}

/*US-46730 If any action in action set for a event is unsupported in offline then it notifies user*/
function alertIgnoreActions(event){
		alert("One or more actions configured on this control cannot be supported in offline mode. Hence all actions configured for \""+ event.type +"\" are ignored.");
}

/* Wrappers for RDL Add / Remove APIs */
function addRDLRow(dataSource, rowPage) {
	if(pega.ui && pega.ui.template && pega.ui.template.RDL) {
		pega.ui.template.RDL.addRow(dataSource, rowPage); 
	}
}

function removeRDLRow(event) {
	if(pega.ui && pega.ui.template && pega.ui.template.RDL) {
		pega.ui.template.RDL.removeRow(event);
	}
}

/*
	This function is used to add page to pagelist via modal dialog. 
	@param $Object $event
*/
function addToRepeatSource(event, datasource, position, localAction, templateName, rowClass, packagedPageName, bSkipLocalAction) {
    if(bSkipLocalAction && bSkipLocalAction == "true"){
      	// US-200634 changes
        var pageListSource = pega.ui.DataRepeaterUtils.getSourcePageList(datasource[0], event);
        pega.desktop.DataRepeater.addToRepeatSourceWithoutLA(event, pageListSource, position, rowClass, bSkipLocalAction,datasource[1]);
    }else if(pega.u.d.ServerProxy.isDestinationLocal()){ // OSCO
        if(pega.ui && pega.ui.template && pega.ui.template.DataRepeater) {
          	pega.ui.template.DataRepeater.addToRepeatSourceUsingLA(event, datasource, position, localAction, templateName, rowClass, packagedPageName);
        }
	}else{ // desktop
		if (pega.ui && pega.ui.DataRepeaterUtils && pega.desktop && pega.desktop.DataRepeater) {
			var pageListSource = pega.ui.DataRepeaterUtils.getSourcePageList(datasource, event);
			pega.desktop.DataRepeater.addToRepeatSourceUsingLA(event, pageListSource, position, localAction, templateName, rowClass, packagedPageName);
		}
	}
}

/*
	This function is used to remove the page from pagelist.
	@param $Object $event
  @param $boolean $showConfirmBox(applies only to template grid)
*/
function removeFromRepeatSource(event, showConfirmBox) {
	if(pega.ui && pega.ui.DataRepeaterUtils) {
		var layoutType = pega.ui.DataRepeaterUtils.getLayoutType(event); 
    if(layoutType === "template-grid"){
      pega.ui.template.DataRepeater.Actions.doListAction(event, "DELETEITEM", showConfirmBox);
    }
		else if(layoutType == "grid"){ // for repeating grid (or) tree (or) treegrid
			doGridAction(event, "DELETE");
		}else if(layoutType == "repeat-layout" || layoutType=="dlgrepeat-layout"){ // for repeating dynamic layout
          	if(layoutType=="dlgrepeat-layout"){
            	var dsObject = pega.ui.DataRepeaterUtils.getAbsoluteDataSourceFromEvent(event,true);  
            } else {
				var dsObject = pega.ui.DataRepeaterUtils.getAbsoluteDataSourceFromEvent(event);
            }
			var dataSource = dsObject.dataSource; // absolute path of the data repeat source
			var rowIndex = dsObject.rowIndex;
			var domIndex = dsObject.domIndex; // to update the handles post successfull deletion of current row
          	if(layoutType=="dlgrepeat-layout"){
              	var repeatLayoutParentNode = $(pega.util.Event.getTarget(event)).closest("[data-lg-repeatsource]");
                var sectionContext = pega.u.d.getBaseRef(repeatLayoutParentNode);
                if(!sectionContext) {
                  sectionContext = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName');
                }
              	dsObject.sectionContext = sectionContext
            }else {
            	dsObject.sectionContext = pega.ui.DataRepeaterUtils.getRepeatLayoutSectionContext(event);  
            }			
			if(pega.u.d.ServerProxy.isDestinationLocal()){ // OSCO
				if(pega.ui.template && pega.ui.template.DataRepeater) {
					pega.ui.template.DataRepeater.removeFromRepeatSource(dsObject);
				}
			} else { // desktop
				if(pega.desktop && pega.desktop.DataRepeater) {
					pega.desktop.DataRepeater.removeFromRepeatSource(dsObject);
				}
			}        
        }  
	}
}

/* @protected- This API is used to edit an item bound to a page list / data page
   @param $Object $event
 */
function editRepeatItem(event) {
	if(pega.ui && pega.ui.DataRepeaterUtils) {
		var layoutType = pega.ui.DataRepeaterUtils.getLayoutType(event); 
    if(layoutType === "template-grid"){
      pega.ui.template.DataRepeater.Actions.doListAction(event, "EDITITEM");
    }
		else if(layoutType == "grid"){ 
			// for repeating grid (or) tree (or) treegrid
			doGridAction(event, "EDITITEM");
		} else {
			// Edit item for RDL
			if(pega.ui && pega.ui.rdlMasterDetails) {
				pega.ui.rdlMasterDetails.showDetails(event);
			}
		}
	}
}

/* 
	RDL Pagination API:
	Loads more data fetched from the Server on to RDL
	event - event object
*/
function loadMoreData(event) {
	if(pega.ui && pega.ui.DataRepeaterUtils) {
		var layoutType = pega.ui.DataRepeaterUtils.getLayoutType(event); 
  
    if (pega.desktop && pega.desktop.DataRepeater) {
      // Paginate
      pega.desktop.DataRepeater.loadMoreData(event);
    }
	}
}

/*SE-27756/BUG-250774 Start*/
function preventDocOnBeforeUnload(e){
  pega.u.d.deletedDocuments = true;
}
/*SE-27756/BUG-250774 End*/


//static-content-hash-trigger-GCC
/**!

 @license
 handlebars v4.7.7

Copyright (C) 2011-2019 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/*
Modifications :

# EPIC-65956 : The equals(=) sysmbol is removed from the escape 
and badchars object to support the expression and action generation. 
Line 325 and Line 3334 has been modified.

*/

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Handlebars"] = factory();
	else
		root["Handlebars"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = __webpack_require__(1)['default'];

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;

	var _handlebarsBase = __webpack_require__(3);

	var base = _interopRequireWildcard(_handlebarsBase);

	// Each of these augment the Handlebars object. No need to setup here.
	// (This is done to easily share code between commonjs and browse envs)

	var _handlebarsSafeString = __webpack_require__(36);

	var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

	var _handlebarsException = __webpack_require__(5);

	var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

	var _handlebarsUtils = __webpack_require__(4);

	var Utils = _interopRequireWildcard(_handlebarsUtils);

	var _handlebarsRuntime = __webpack_require__(37);

	var runtime = _interopRequireWildcard(_handlebarsRuntime);

	var _handlebarsNoConflict = __webpack_require__(43);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
	function create() {
	  var hb = new base.HandlebarsEnvironment();

	  Utils.extend(hb, base);
	  hb.SafeString = _handlebarsSafeString2['default'];
	  hb.Exception = _handlebarsException2['default'];
	  hb.Utils = Utils;
	  hb.escapeExpression = Utils.escapeExpression;

	  hb.VM = runtime;
	  hb.template = function (spec) {
	    return runtime.template(spec, hb);
	  };

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};

	    if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }

	    newObj["default"] = obj;
	    return newObj;
	  }
	};

	exports.__esModule = true;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	};

	exports.__esModule = true;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;
	exports.HandlebarsEnvironment = HandlebarsEnvironment;

	var _utils = __webpack_require__(4);

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	var _helpers = __webpack_require__(9);

	var _decorators = __webpack_require__(29);

	var _logger = __webpack_require__(31);

	var _logger2 = _interopRequireDefault(_logger);

	var _internalProtoAccess = __webpack_require__(32);

	var VERSION = '4.7.7';
	exports.VERSION = VERSION;
	var COMPILER_REVISION = 8;
	exports.COMPILER_REVISION = COMPILER_REVISION;
	var LAST_COMPATIBLE_COMPILER_REVISION = 7;

	exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0 <4.3.0',
	  8: '>= 4.3.0'
	};

	exports.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';

	function HandlebarsEnvironment(helpers, partials, decorators) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};
	  this.decorators = decorators || {};

	  _helpers.registerDefaultHelpers(this);
	  _decorators.registerDefaultDecorators(this);
	}

	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,

	  logger: _logger2['default'],
	  log: _logger2['default'].log,

	  registerHelper: function registerHelper(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple helpers');
	      }
	      _utils.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },

	  registerPartial: function registerPartial(name, partial) {
	    if (_utils.toString.call(name) === objectType) {
	      _utils.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },

	  registerDecorator: function registerDecorator(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple decorators');
	      }
	      _utils.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  },
	  /**
	   * Reset the memory of illegal property accesses that have already been logged.
	   * @deprecated should only be used in handlebars test-cases
	   */
	  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
	    _internalProtoAccess.resetLoggedProperties();
	  }
	};

	var log = _logger2['default'].log;

	exports.log = log;
	exports.createFrame = _utils.createFrame;
	exports.logger = _logger2['default'];

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.extend = extend;
	exports.indexOf = indexOf;
	exports.escapeExpression = escapeExpression;
	exports.isEmpty = isEmpty;
	exports.createFrame = createFrame;
	exports.blockParams = blockParams;
	exports.appendContextPath = appendContextPath;
	
  /*var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};*/
  
  var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;'
	};

  /*
    var badChars = /[&<>"'`=]/g,
	      possible = /[&<>"'`=]/;
  */
  
	var badChars = /[&<>"'`]/g,
	    possible = /[&<>"'`]/;

	function escapeChar(chr) {
	  return escape[chr];
	}

	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }

	  return obj;
	}

	var toString = Object.prototype.toString;

	exports.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  exports.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	exports.isFunction = isFunction;

	/* eslint-enable func-style */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};

	exports.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }

	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}

	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function createFrame(object) {
	  var frame = extend({}, object);
	  frame._parent = object;
	  return frame;
	}

	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}

	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$defineProperty = __webpack_require__(6)['default'];

	exports.__esModule = true;
	var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];

	function Exception(message, node) {
	  var loc = node && node.loc,
	      line = undefined,
	      endLineNumber = undefined,
	      column = undefined,
	      endColumn = undefined;

	  if (loc) {
	    line = loc.start.line;
	    endLineNumber = loc.end.line;
	    column = loc.start.column;
	    endColumn = loc.end.column;

	    message += ' - ' + line + ':' + column;
	  }

	  var tmp = Error.prototype.constructor.call(this, message);

	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	  for (var idx = 0; idx < errorProps.length; idx++) {
	    this[errorProps[idx]] = tmp[errorProps[idx]];
	  }

	  /* istanbul ignore else */
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, Exception);
	  }

	  try {
	    if (loc) {
	      this.lineNumber = line;
	      this.endLineNumber = endLineNumber;

	      // Work around issue under safari where we can't directly set the column value
	      /* istanbul ignore next */
	      if (_Object$defineProperty) {
	        Object.defineProperty(this, 'column', {
	          value: column,
	          enumerable: true
	        });
	        Object.defineProperty(this, 'endColumn', {
	          value: endColumn,
	          enumerable: true
	        });
	      } else {
	        this.column = column;
	        this.endColumn = endColumn;
	      }
	    }
	  } catch (nop) {
	    /* Ignore if the browser is very particular */
	  }
	}

	Exception.prototype = new Error();

	exports['default'] = Exception;
	module.exports = exports['default'];

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(7), __esModule: true };

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(8);
	module.exports = function defineProperty(it, key, desc){
	  return $.setDesc(it, key, desc);
	};

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;
	exports.registerDefaultHelpers = registerDefaultHelpers;
	exports.moveHelperToHooks = moveHelperToHooks;

	var _helpersBlockHelperMissing = __webpack_require__(10);

	var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

	var _helpersEach = __webpack_require__(11);

	var _helpersEach2 = _interopRequireDefault(_helpersEach);

	var _helpersHelperMissing = __webpack_require__(24);

	var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

	var _helpersIf = __webpack_require__(25);

	var _helpersIf2 = _interopRequireDefault(_helpersIf);

	var _helpersLog = __webpack_require__(26);

	var _helpersLog2 = _interopRequireDefault(_helpersLog);

	var _helpersLookup = __webpack_require__(27);

	var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

	var _helpersWith = __webpack_require__(28);

	var _helpersWith2 = _interopRequireDefault(_helpersWith);

	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}

	function moveHelperToHooks(instance, helperName, keepHelper) {
	  if (instance.helpers[helperName]) {
	    instance.hooks[helperName] = instance.helpers[helperName];
	    if (!keepHelper) {
	      delete instance.helpers[helperName];
	    }
	  }
	}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	exports['default'] = function (instance) {
	  instance.registerHelper('blockHelperMissing', function (context, options) {
	    var inverse = options.inverse,
	        fn = options.fn;

	    if (context === true) {
	      return fn(this);
	    } else if (context === false || context == null) {
	      return inverse(this);
	    } else if (_utils.isArray(context)) {
	      if (context.length > 0) {
	        if (options.ids) {
	          options.ids = [options.name];
	        }

	        return instance.helpers.each(context, options);
	      } else {
	        return inverse(this);
	      }
	    } else {
	      if (options.data && options.ids) {
	        var data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
	        options = { data: data };
	      }

	      return fn(context, options);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var _Object$keys = __webpack_require__(12)['default'];

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('each', function (context, options) {
	    if (!options) {
	      throw new _exception2['default']('Must pass iterator to #each');
	    }

	    var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;

	    if (options.data && options.ids) {
	      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	    }

	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    if (options.data) {
	      data = _utils.createFrame(options.data);
	    }

	    function execIteration(field, index, last) {
	      if (data) {
	        data.key = field;
	        data.index = index;
	        data.first = index === 0;
	        data.last = !!last;

	        if (contextPath) {
	          data.contextPath = contextPath + field;
	        }
	      }

	      ret = ret + fn(context[field], {
	        data: data,
	        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
	      });
	    }

	    if (context && typeof context === 'object') {
	      if (_utils.isArray(context)) {
	        for (var j = context.length; i < j; i++) {
	          if (i in context) {
	            execIteration(i, i, i === context.length - 1);
	          }
	        }
	      } else if (global.Symbol && context[global.Symbol.iterator]) {
	        var newContext = [];
	        var iterator = context[global.Symbol.iterator]();
	        for (var it = iterator.next(); !it.done; it = iterator.next()) {
	          newContext.push(it.value);
	        }
	        context = newContext;
	        for (var j = context.length; i < j; i++) {
	          execIteration(i, i, i === context.length - 1);
	        }
	      } else {
	        (function () {
	          var priorKey = undefined;

	          _Object$keys(context).forEach(function (key) {
	            // We're running the iterations one step out of sync so we can detect
	            // the last iteration without have to scan the object twice and create
	            // an itermediate keys array.
	            if (priorKey !== undefined) {
	              execIteration(priorKey, i - 1);
	            }
	            priorKey = key;
	            i++;
	          });
	          if (priorKey !== undefined) {
	            execIteration(priorKey, i - 1, true);
	          }
	        })();
	      }
	    }

	    if (i === 0) {
	      ret = inverse(this);
	    }

	    return ret;
	  });
	};

	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(13), __esModule: true };

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(14);
	module.exports = __webpack_require__(20).Object.keys;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(15);

	__webpack_require__(17)('keys', function($keys){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(16);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(18)
	  , core    = __webpack_require__(20)
	  , fails   = __webpack_require__(23);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(19)
	  , core      = __webpack_require__(20)
	  , ctx       = __webpack_require__(21)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	// type bitmap
	$export.F = 1;  // forced
	$export.G = 2;  // global
	$export.S = 4;  // static
	$export.P = 8;  // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	module.exports = $export;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	var core = module.exports = {version: '1.2.6'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(22);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('helperMissing', function () /* [args, ]options */{
	    if (arguments.length === 1) {
	      // A missing field in a {{foo}} construct.
	      return undefined;
	    } else {
	      // Someone is actually trying to call something, blow up.
	      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	    }
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('if', function (conditional, options) {
	    if (arguments.length != 2) {
	      throw new _exception2['default']('#if requires exactly one argument');
	    }
	    if (_utils.isFunction(conditional)) {
	      conditional = conditional.call(this);
	    }

	    // Default behavior is to render the positive path if the value is truthy and not empty.
	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
	      return options.inverse(this);
	    } else {
	      return options.fn(this);
	    }
	  });

	  instance.registerHelper('unless', function (conditional, options) {
	    if (arguments.length != 2) {
	      throw new _exception2['default']('#unless requires exactly one argument');
	    }
	    return instance.helpers['if'].call(this, conditional, {
	      fn: options.inverse,
	      inverse: options.fn,
	      hash: options.hash
	    });
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('log', function () /* message, options */{
	    var args = [undefined],
	        options = arguments[arguments.length - 1];
	    for (var i = 0; i < arguments.length - 1; i++) {
	      args.push(arguments[i]);
	    }

	    var level = 1;
	    if (options.hash.level != null) {
	      level = options.hash.level;
	    } else if (options.data && options.data.level != null) {
	      level = options.data.level;
	    }
	    args[0] = level;

	    instance.log.apply(instance, args);
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('lookup', function (obj, field, options) {
	    if (!obj) {
	      // Note for 5.0: Change to "obj == null" in 5.0
	      return obj;
	    }
	    return options.lookupProperty(obj, field);
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('with', function (context, options) {
	    if (arguments.length != 2) {
	      throw new _exception2['default']('#with requires exactly one argument');
	    }
	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    var fn = options.fn;

	    if (!_utils.isEmpty(context)) {
	      var data = options.data;
	      if (options.data && options.ids) {
	        data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
	      }

	      return fn(context, {
	        data: data,
	        blockParams: _utils.blockParams([context], [data && data.contextPath])
	      });
	    } else {
	      return options.inverse(this);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;
	exports.registerDefaultDecorators = registerDefaultDecorators;

	var _decoratorsInline = __webpack_require__(30);

	var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	exports['default'] = function (instance) {
	  instance.registerDecorator('inline', function (fn, props, container, options) {
	    var ret = fn;
	    if (!props.partials) {
	      props.partials = {};
	      ret = function (context, options) {
	        // Create a new partials stack frame prior to exec.
	        var original = container.partials;
	        container.partials = _utils.extend({}, original, props.partials);
	        var ret = fn(context, options);
	        container.partials = original;
	        return ret;
	      };
	    }

	    props.partials[options.args[0]] = options.fn;

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	var logger = {
	  methodMap: ['debug', 'info', 'warn', 'error'],
	  level: 'info',

	  // Maps a given level value to the `methodMap` indexes above.
	  lookupLevel: function lookupLevel(level) {
	    if (typeof level === 'string') {
	      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
	      if (levelMap >= 0) {
	        level = levelMap;
	      } else {
	        level = parseInt(level, 10);
	      }
	    }

	    return level;
	  },

	  // Can be overridden in the host environment
	  log: function log(level) {
	    level = logger.lookupLevel(level);

	    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
	      var method = logger.methodMap[level];
	      // eslint-disable-next-line no-console
	      if (!console[method]) {
	        method = 'log';
	      }

	      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        message[_key - 1] = arguments[_key];
	      }

	      console[method].apply(console, message); // eslint-disable-line no-console
	    }
	  }
	};

	exports['default'] = logger;
	module.exports = exports['default'];

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$create = __webpack_require__(33)['default'];

	var _Object$keys = __webpack_require__(12)['default'];

	var _interopRequireWildcard = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.createProtoAccessControl = createProtoAccessControl;
	exports.resultIsAllowed = resultIsAllowed;
	exports.resetLoggedProperties = resetLoggedProperties;

	var _createNewLookupObject = __webpack_require__(35);

	var _logger = __webpack_require__(31);

	var logger = _interopRequireWildcard(_logger);

	var loggedProperties = _Object$create(null);

	function createProtoAccessControl(runtimeOptions) {
	  var defaultMethodWhiteList = _Object$create(null);
	  defaultMethodWhiteList['constructor'] = false;
	  defaultMethodWhiteList['__defineGetter__'] = false;
	  defaultMethodWhiteList['__defineSetter__'] = false;
	  defaultMethodWhiteList['__lookupGetter__'] = false;

	  var defaultPropertyWhiteList = _Object$create(null);
	  // eslint-disable-next-line no-proto
	  defaultPropertyWhiteList['__proto__'] = false;

	  return {
	    properties: {
	      whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
	      defaultValue: runtimeOptions.allowProtoPropertiesByDefault
	    },
	    methods: {
	      whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
	      defaultValue: runtimeOptions.allowProtoMethodsByDefault
	    }
	  };
	}

	function resultIsAllowed(result, protoAccessControl, propertyName) {
	  if (typeof result === 'function') {
	    return checkWhiteList(protoAccessControl.methods, propertyName);
	  } else {
	    return checkWhiteList(protoAccessControl.properties, propertyName);
	  }
	}

	function checkWhiteList(protoAccessControlForType, propertyName) {
	  if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
	    return protoAccessControlForType.whitelist[propertyName] === true;
	  }
	  if (protoAccessControlForType.defaultValue !== undefined) {
	    return protoAccessControlForType.defaultValue;
	  }
	  logUnexpecedPropertyAccessOnce(propertyName);
	  return false;
	}

	function logUnexpecedPropertyAccessOnce(propertyName) {
	  if (loggedProperties[propertyName] !== true) {
	    loggedProperties[propertyName] = true;
	    logger.log('error', 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\n' + 'You can add a runtime option to disable the check or this warning:\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
	  }
	}

	function resetLoggedProperties() {
	  _Object$keys(loggedProperties).forEach(function (propertyName) {
	    delete loggedProperties[propertyName];
	  });
	}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(34), __esModule: true };

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(8);
	module.exports = function create(P, D){
	  return $.create(P, D);
	};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$create = __webpack_require__(33)['default'];

	exports.__esModule = true;
	exports.createNewLookupObject = createNewLookupObject;

	var _utils = __webpack_require__(4);

	/**
	 * Create a new object with "null"-prototype to avoid truthy results on prototype properties.
	 * The resulting object can be used with "object[property]" to check if a property exists
	 * @param {...object} sources a varargs parameter of source objects that will be merged
	 * @returns {object}
	 */

	function createNewLookupObject() {
	  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
	    sources[_key] = arguments[_key];
	  }

	  return _utils.extend.apply(undefined, [_Object$create(null)].concat(sources));
	}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

	// Build out our basic SafeString type
	'use strict';

	exports.__esModule = true;
	function SafeString(string) {
	  this.string = string;
	}

	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	  return '' + this.string;
	};

	exports['default'] = SafeString;
	module.exports = exports['default'];

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$seal = __webpack_require__(38)['default'];

	var _Object$keys = __webpack_require__(12)['default'];

	var _interopRequireWildcard = __webpack_require__(1)['default'];

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;
	exports.checkRevision = checkRevision;
	exports.template = template;
	exports.wrapProgram = wrapProgram;
	exports.resolvePartial = resolvePartial;
	exports.invokePartial = invokePartial;
	exports.noop = noop;

	var _utils = __webpack_require__(4);

	var Utils = _interopRequireWildcard(_utils);

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	var _base = __webpack_require__(3);

	var _helpers = __webpack_require__(9);

	var _internalWrapHelper = __webpack_require__(42);

	var _internalProtoAccess = __webpack_require__(32);

	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = _base.COMPILER_REVISION;

	  if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
	    return;
	  }

	  if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
	    var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
	        compilerVersions = _base.REVISION_CHANGES[compilerRevision];
	    throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	  } else {
	    // Use the embedded version info since the runtime doesn't know about this revision yet
	    throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	  }
	}

	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
	  }

	  templateSpec.main.decorator = templateSpec.main_d;

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as pseudo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);

	  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)
	  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;

	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }
	    partial = env.VM.resolvePartial.call(this, partial, context, options);

	    var extendedOptions = Utils.extend({}, options, {
	      hooks: this.hooks,
	      protoAccessControl: this.protoAccessControl
	    });

	    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);

	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, extendedOptions);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }

	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name, loc) {
	      if (!obj || !(name in obj)) {
	        throw new _exception2['default']('"' + name + '" not defined in ' + obj, {
	          loc: loc
	        });
	      }
	      return container.lookupProperty(obj, name);
	    },
	    lookupProperty: function lookupProperty(parent, propertyName) {
	      var result = parent[propertyName];
	      if (result == null) {
	        return result;
	      }
	      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
	        return result;
	      }

	      if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
	        return result;
	      }
	      return undefined;
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        var result = depths[i] && container.lookupProperty(depths[i], name);
	        if (result != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },

	    escapeExpression: Utils.escapeExpression,
	    invokePartial: invokePartialWrapper,

	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },

	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },

	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    mergeIfNeeded: function mergeIfNeeded(param, common) {
	      var obj = param || common;

	      if (param && common && param !== common) {
	        obj = Utils.extend({}, common, param);
	      }

	      return obj;
	    },
	    // An empty object to use as replacement for null-contexts
	    nullContext: _Object$seal({}),

	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };

	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var data = options.data;

	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }

	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }

	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }

	  ret.isTop = true;

	  ret._setup = function (options) {
	    if (!options.partial) {
	      var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
	      wrapHelpersToPassLookupProperty(mergedHelpers, container);
	      container.helpers = mergedHelpers;

	      if (templateSpec.usePartial) {
	        // Use mergeIfNeeded here to prevent compiling global partials multiple times
	        container.partials = container.mergeIfNeeded(options.partials, env.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = Utils.extend({}, env.decorators, options.decorators);
	      }

	      container.hooks = {};
	      container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);

	      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
	      _helpers.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);
	      _helpers.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
	    } else {
	      container.protoAccessControl = options.protoAccessControl; // internal option
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	      container.hooks = options.hooks;
	    }
	  };

	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2['default']('must pass parent depths');
	    }

	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}

	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var currentDepths = depths;
	    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
	      currentDepths = [context].concat(depths);
	    }

	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }

	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}

	/**
	 * This is currently part of the official API, therefore implementation details should not be changed.
	 */

	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      partial = options.data['partial-block'];
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}

	function invokePartial(partial, context, options) {
	  // Use the current closure context to save the partial-block if this partial
	  var currentPartialBlock = options.data && options.data['partial-block'];
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }

	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    (function () {
	      options.data = _base.createFrame(options.data);
	      // Wrapper function to get access to currentPartialBlock from the closure
	      var fn = options.fn;
	      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        // Restore the partial-block from the closure for the execution of the block
	        // i.e. the part inside the block of the partial call.
	        options.data = _base.createFrame(options.data);
	        options.data['partial-block'] = currentPartialBlock;
	        return fn(context, options);
	      };
	      if (fn.partials) {
	        options.partials = Utils.extend({}, options.partials, fn.partials);
	      }
	    })();
	  }

	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }

	  if (partial === undefined) {
	    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}

	function noop() {
	  return '';
	}

	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}

	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils.extend(prog, props);
	  }
	  return prog;
	}

	function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
	  _Object$keys(mergedHelpers).forEach(function (helperName) {
	    var helper = mergedHelpers[helperName];
	    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
	  });
	}

	function passLookupPropertyOption(helper, container) {
	  var lookupProperty = container.lookupProperty;
	  return _internalWrapHelper.wrapHelper(helper, function (options) {
	    return Utils.extend({ lookupProperty: lookupProperty }, options);
	  });
	}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(39), __esModule: true };

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(40);
	module.exports = __webpack_require__(20).Object.seal;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(41);

	__webpack_require__(17)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(it) : it;
	  };
	});

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.wrapHelper = wrapHelper;

	function wrapHelper(helper, transformOptionsFn) {
	  if (typeof helper !== 'function') {
	    // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639
	    // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.
	    return helper;
	  }
	  var wrapper = function wrapper() /* dynamic arguments */{
	    var options = arguments[arguments.length - 1];
	    arguments[arguments.length - 1] = transformOptionsFn(options);
	    return helper.apply(this, arguments);
	  };
	  return wrapper;
	}

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	exports.__esModule = true;

	exports['default'] = function (Handlebars) {
	  /* istanbul ignore next */
	  var root = typeof global !== 'undefined' ? global : window,
	      $Handlebars = root.Handlebars;
	  /* istanbul ignore next */
	  Handlebars.noConflict = function () {
	    if (root.Handlebars === Handlebars) {
	      root.Handlebars = $Handlebars;
	    }
	    return Handlebars;
	  };
	};

	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ })
/******/ ])
});
;
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.template");
pega.ui.template.RenderingEngine = (function () {

   var registeredUIComponentRenderers = {};
	 var currentDocument = null;
	 var templatingUtils = pega.ui.TemplateEngine;

    /* This is the main method of the Rendering Engine
     * Arguments: templateTreesIterator - iterator for the metadata JSON
     *            doc - document / documentFragment /element
     */
  

   /*
    * Jit loader will fall through if pega.ui.JitJLoader doesn't exist
    * If does exist, need to dynamically load js files that correspond to all the ui component defintions and their js files that
    * are in the component templates.  So we get a component list and then call the jitloader.loadComponent on all the components.
    * They are all loaded asynchronously.  When the final one has been loaded, the callback will continue with loading the templates.
    */
   var arTemplate = new Array();
   var _jitLoader = function(localCallback, templates, callback) {
     
      if (pega.ui.JitJLoader) {

        
          var arCompList = pega.ui.jittemplate.getComponentList(templates, null, false);
        
          var componentCount = arCompList.length;
          var componentIndex = 1;
        
          for (var i =0; i < componentCount; i++) {
            oComponent = arCompList[i];
            pega.ui.JitJLoader.loadComponent(oComponent.type, oComponent.name, null, "render", function(error, category, componentName, feature) {
              console.log("loading:" + category + " - " + componentName);
              if (error != null) {
                console.error(error);
              }
              componentIndex++;
              if (componentIndex === componentCount) {
                
                localCallback(callback);
              }
            }.bind(this));
          }
        
      } else {
        //alert("no jit");
        localCallback(callback);
      }
   }
	 
	// TODO: Avoid creating and writing a documentFrgament at the caller, pass an element directly.
   
   /* SE-50169 passing scopedMetaDataTree from renderUI to maintain metadatatree at function scoped  */
    var beginRendering = function(doc, callback, scopedMetaDataTree) {

		if (!doc)
			return;

      
        setCurrentDocument(doc);
		var metaDataTree =  scopedMetaDataTree || pega.ui.TemplateEngine.getMetadataTree();
		if(!metaDataTree) {
			callback && callback();
			return;
		}
				
		var templates =  pega.ui.TemplateEngine.getTemplates(metaDataTree); // pyTemplates
		if(!templates) {
			callback && callback();
			return;
		}
    
    /* 
     * call the jitLoader, to load all js files and then process the templates.
     * _jitLoader(localCallback, templates, originalCallback)
     */
   _jitLoader( function(callback) {
         
        /* inside localCallback of jitLoader */
      
        /* Process each child of the template tree
         */
        for(var i=0; i<templates.length; i++) {
          var templateTree = templates[i];	// templateTree or templateNode or template
          if(!templateTree)
            continue;

          // TODO: Invoke data binding the same pass
          /*Bind the values to the generated markup - custom binder */
          //pega.ui.template.TemplateDataBinder.bindPegaTemplates(documentFrag);

          /* Locate the tree-root-marker using the components isntanceID */
          // TODO: comapre perf of object.property vs object["property"]
          var componentId = templateTree["pyInstanceID"];
          var templateTreeNode = doc.querySelector("[data-template-instance-id='" + componentId + "']");
          if(!templateTreeNode) 
            continue;

          var primaryPage = templateTree["pzPrimaryPage"];  
                    var currentContext = pega.ui.TemplateEngine.getCurrentContext();
                    if(primaryPage) {
                        currentContext.push(primaryPage);
                    }


          var _markup = __renderTemplateTree(templateTree, doc);

                  if(primaryPage) {
                        currentContext.pop();
                    }
          if(_markup == "$asyncRendered$WithLoadingMessage"){
            templateTreeNode.innerHTML = "<div class=\"field-item dataValueRead\"><span>Loading...</span></div>";
          }else if(_markup == "$asyncRendered$WithoutLoadingMessage"){
            templateTreeNode.style.display = "none";
          }else if(_markup != "$asyncDone$NoChangeRequired"){
            templateTreeNode.outerHTML = (_markup || "");
          }
        }

        // Execute callback
        callback && callback();
     
        /* end of localCallback for jitloader */

     }, templates, callback);
			
  };

	var getCurrentDocument = function(){
      	if(currentDocument)
			return currentDocument;
      	else 
          	return document;
          
	};
    var setCurrentDocument = function(currentDoc){
		currentDocument = currentDoc;
	};
    /* This method is used to register a component's render method with the Rendering Engine
     * Arguments: uiComponentTemplateName - String identifying the component
     *            renderer - render method of the component
     */
    var register = function (uiComponentTemplateName, renderer) {

        if (uiComponentTemplateName && typeof renderer === 'function') {
            registeredUIComponentRenderers[uiComponentTemplateName] = renderer;
        }
    };

    /* This method is used to retrieve a component's render method
     * Arguments: uiComponentTemplateName - String identifying the component
     * Return:    renderer - render method of the component
     */
    var getRenderer = function (uiComponentTemplateName) {
            return registeredUIComponentRenderers[uiComponentTemplateName];
        };

    /* This method is called recursively for each component and its children
     * Arguments: treeNode - the object containing the metadata information of a component
     * Return:    markup - the markup of a rendered component
     */
	 // The actual rendering call
    var __renderTemplateTree = function (treeNode, doc) {
		// TODO: Check if boolean
		//if(!treeNode.pyProcessChildren)	// RE would not process the children
		//	return;
      
		
		var childTemplates =  pega.ui.TemplateEngine.getTemplates(treeNode); // pyTemplates
		if(treeNode.pyProcessChildren == "true" && childTemplates) {	// RE would not process the children
			for(var j=0; j<childTemplates.length; j++) {
				var childTemplateTree = childTemplates[j];
				if(!childTemplateTree)
					continue;
				
				var tempStr = __renderTemplateTree(childTemplateTree);
				// Push to child markup array
				if(!treeNode.childrenMarkupArray)
					treeNode.childrenMarkupArray = [];
				treeNode.childrenMarkupArray.push(tempStr || "");
				
			}
		}
		
		//var templateNodes = 
			
        var markup;
        /* For each tree node retrieve its children(if any) and call __renderTemplateTree on them recursively.
         * The structure of the meta-data can be as follows:
         * pyTemplate()
         * - pyCell(1)
         *    - pyTemplate()
         * - pyCell(2)
         *    - pyTemplate()
         * This structure causes the templateMetadataTreeIterator API to return an array of iterators as opposed to a single iterator with all the children
         */
        
		
		// LDP
        //try
		{
			var asynRenderCallback = function() {
				return function(markup) {
					var componentId = treeNode["pyInstanceID"];
					var childTemplateTreeNode = doc.querySelector("[data-template-instance-id='" + componentId + "']");
					if(childTemplateTreeNode)
						childTemplateTreeNode.outerHTML = markup;
					// If no node found, wait for it
					else {
					/*to avoid race conditions where the asynRenderCallback called when doc is already cleaned but not yet replaced in the document due to timeouts in loadDOMObject or any other places.*/
						setTimeout(function() {
							childTemplateTreeNode = pega.ctx.dom.querySelector("[data-template-instance-id='" + componentId + "']");
							if(childTemplateTreeNode)
								childTemplateTreeNode.outerHTML = markup;
						},250); 
					}	
				}
			}(treeNode, doc);
			
			var renderer =  getRenderer(treeNode["pyName"]);
        if(typeof renderer == "function") {
          markup = renderer.call(null, treeNode, null, asynRenderCallback);
        }
        else
          console.log("Cannot find  renderer for component: " + treeNode["pyName"]);
      
        }
      
        return markup;
    };

   
    return {
        register: register,
        beginRendering: beginRendering,
        getRenderer: getRenderer,
		getCurrentDocument: getCurrentDocument,
        setCurrentDocument: setCurrentDocument
    };
})();

// Dummy render
pega.ui.template.RenderingEngine.register("Dummy", function(metadata) {
    // Do nothing
	return "";
});
//static-content-hash-trigger-NON
/**
 * Factory method to create instance of template.
 */
// ns for defaults
if (typeof pega == "undefined")
	pega = {};
pega.ui = pega.ui || {};
pega.ui.TEMPLATE_DEFAULTS = pega.ui.TEMPLATE_DEFAULTS || {};

pega.ui.TemplateEngine = (function() {

	var isUnitTesting = pega.isUnitTesting;
	var repeatingCompCTProps;
	var _removeData = false;
	/* Constants */
	// When Identifier to when property mapping
	var _whenListMap = {
		"pyVisibilityWhenId": "pyVisibility", // Visible When
		"pyDisabledWhenId": "pyDisabled", // Disabled When
		"pyReadOnlyWhenId": "pyReadOnly", // ReadOnly When
		"pyObfuscatedWhenId": "pyObfuscated", // Obfuscated When
		"pyContainerVisibilityWhenId": "pyContainerVisibility", // Container visibility
		"pyBodyVisibilityWhenId": "pyBodyVisibility", // Body Visibility
		"pyExpandedWhenId": "pyExpandedWhen", // Expand When
		"pyContainerActiveWhenId": "pyContainerActive", // Active When
		"pyRequiredWhenId": "pyRequired", // Required When
		"pyViewPrivilegeWhenId": "pyViewPrivilege", // View Privilege
		"pyDisablePrivilegeId": "pyDisablePrivilege" // Disabled Privilege
	};

    /*
    var _alienDataElementsList = ["$pxWhens", "$pxSections", "$pxNonTemplates", "$pxLocalized", "$pxPrivileges", "$pxDataSource", "$pxActionString"];
    */

	// What is different when property called by different components
	var _componentWhenPropertyMap = {
		"pyVisibility": {
			"pxSection": "pyVisibility"
		},
		"pyDisabled": {

		},
		"pyReadOnly": {

		},
		"pyObfuscated": {

		},
		"pyContainerVisibility": {
			"pxLayoutContainer": "pyWhenCondition"
		},
		"pyBodyVisibility": {
			"pxLayoutContainer": "pyVisibility_BV"
		},
		"pyExpandedWhen": {
			"pxLayoutHeader": "expanded"
		},
		"pyContainerActive": {

		},
		"pyRequired": {

		},
		"pyViewPrivilege": {

		},
		"pyDisablePrivilege": {

		}
	};

	var _repeatingComponentsMap = ["RepeatingDynamicLayout", "pxGrid", "DynamicLayoutGroup", "nextPage", "pxTreeGrid", "pxTreeGridChildren"];

    /*
    var _componentLocalizationMap = {
        "pxButton": {
            "pyLabelVal": {
                mode: "pyModes1",
                messageType: "pyButtonLabel"
            }
        },
        "pxLink": {
            "pyLabelVal": {
                mode: "pyModes1",
                messageType: "pyButtonLabel"
            },
        },
        "pxCheckbox": {
            "pyTooltipValue ": {
                mode: "pyModes0",
                messageType: "pyToolTip"
            },
            "pyCheckboxCaptionValue ": {
                mode: "pyModes0",
                messageType: "pyCaption"
            },
        },
        "pxDisplayText": {
            "pyValue": {
                mode: "pyCell",
                messageType: "pyCaption"
            },
        },
        "pxTextArea": {
            "pyPlaceholderValue": {
                mode: "pyModes0",
                messageType: ""
            },
            "pyToolTip": {
                mode: "pyModes0",
                messageType: "pyTooltipValue"
            },
        },
        "pxTextInput": {
            "pyPlaceholderValue": {
                mode: "pyModes0",
                messageType: "pyActionPrompt"
            },
            "pyToolTip": {
                mode: "pyModes0",
                messageType: "pyTooltipValue"
            },
        },
        "pxLayoutHeader": {
            "headerTitle": {
                messageType: "pyCaption"
            },
        },
    };
    */

	var _whenRulePropertiesMap = {
		"pyVisibilityWhenId": {
			"class": "pyVisibilityWhenClass",
			"name": "pyVisibilityWhenName"
		},
		"pyDisabledWhenId": {
			"class": "pyDisabledWhenClass",
			"name": "pyDisabledWhenName"
		},
		"pyRequiredWhenId": {
			"class": "pyRequiredWhenClass",
			"name": "pyRequiredWhenName"
		},
		"pyBodyVisibilityWhenId": {
			"class": "pyBodyVisibilityWhenClass",
			"name": "pyBodyVisibilityWhenName"
		}
	}

	var _CONSTANTS = {
		WHEN_LIST_MAP: _whenListMap,
		COMPONENT_WHEN_PROPERTY_MAP: _componentWhenPropertyMap,
		REPEATING_COMPONENTS_MAP: _repeatingComponentsMap,
		WHEN_RULE_PROPERTIES_MAP: _whenRulePropertiesMap,
		/*COMPONENT_LOCALIZATION_MAP: _componentLocalizationMap*/
	};


	var counter = 1;
	var asyncStreamQueue = [];
	var isUIRendered = false;
	var repeatingDepthStack = [];

    /**
    * holds the primary page, on which top level sections has to render.
    * All top level sections will be part of addMetadataTree call.
    */
	var _primaryContext;

    /**
     * Returns the markup after executing the template.
     */
	var _execute = function(templateName, data) {

		var log = pega.ui.logger.LogHelper;
		if (!templateName) {
			log.error("templateName is null");
			return null;
		}
		var template = Handlebars.templates[templateName]
		if (!template) {
			// look into the partials
			template = Handlebars.partials[templateName]
		}

		// Still template does not exist throw error
		if (!template) {
			log.error("Template not found ", templateName);
			return null;
		}

		return template(data);
	};

    /**
     * Register helpers with handlebar.
     */
	var _registerHelper = function(helperName, helper, override) {
		if (!helper) {
			pega.ui.logger.LogHelper.error("Helper name cannot be empty");
			return false;
		}
		if (override == true && !Handlebars.helpers[helperName]) {
			return false;
		}
		Handlebars.registerHelper(helperName, helper);
	};

    /**
     * Get register helper.
     */
	var _getHelper = function(helperName) {
		return Handlebars.helpers[helperName];
	};

	var _register = function(templateName, callback, partial) {
		var template = Handlebars.template,
			templates = Handlebars.templates = Handlebars.templates || {};
		if (partial) {
			Handlebars.partials[templateName] = template(callback);
		} else {
			templates[templateName] = template(callback);
		}
	};


	// Defaults stuff
	var _getDefaults = function() {
		return pega.ui.TEMPLATE_DEFAULTS;
	};
	var _getDefaultsByComponent = function(componentType) {
		return pega.ui.TEMPLATE_DEFAULTS[componentType];
	};


	// Clone helper
	var _cloneObject = function(srcObject) {

		if (typeof (srcObject) != "object" || srcObject == null)
			return srcObject;
		var clonedObject = srcObject.constructor();
		for (var i in srcObject)
			clonedObject[i] = _cloneObject(srcObject[i]);
		return clonedObject;
	}

	// Clone metadata
	var _cloneMetadata = function(componentMetadata) {
		return _cloneObject(componentMetadata);
	};
  
  
	var _isObjectEmpty = function(obj) {
		if (!obj)
			return;
		if (typeof obj == "object")
			return (Object.keys(obj).length == 0);
	};
  
	var _isParseArray = function(arr) {
		for (var i = 0; i < arr.length; i++) {
			if (_isObjectEmpty(arr[i]))
				return true;
		}
	};

	var _isSingleProperty = function(obj) {
		return (Object.keys(obj).length == 1);
	};

	var _isSubset = function(superObj, subObj) {
		var flag;
		for (var key in subObj) {
			if (!superObj.hasOwnProperty(key))
				return false;
		}
		return true;
	};

	var _isMetaObject = function(obj) {
		if (typeof obj != "object")
			return;
		if (obj["$pxSections"] || obj["$pxNonTemplates"] || obj["$pxWhens"] || obj["$pxLocalized"])
			return true;
	};

	// Merge helper
    /*
        source: defaults
        target: componentMetadata
    */
	var _mergeObjects = function(target, source, bOverride, bDisallowDisparateTypes, bReplace) {
        /*
        // If target doesn't exist, create one
        if(typeof target != 'object')
            target = {};
        */

		for (var property in source) {
			if (source.hasOwnProperty(property)) {
				var sourceValue = source[property];

				// Replace each pxSections entry as is
				// BUG-314437 : Replace "$pxLocalized" as is
				if (bReplace || property == "$pxLocalized") {
					target[property] = sourceValue;
				}
				/* BUG-330736: $pxPageSize$pageList == 0 indicates that the pageslist has been emptied at the server */
				if (property.indexOf("$pxPageSize$") != -1 && sourceValue === 0) {
					var startIndex = "$pxPageSize$".length;
					var listPropName = property.substring(startIndex, property.length);
          if(property in target) { /* BUG-413726: Update $pxPageSize$ property  */
            target[property] = sourceValue;
          }
					if (listPropName && target[listPropName]) {
						delete target[listPropName];
					}
				}
				// Primitive type
				else if (typeof sourceValue != 'object') {
					// Check if property exists in target
					if (!(property in target) || bOverride) {
						if (bDisallowDisparateTypes && typeof target[property] == "object") {
							// Do nothing
						} else {
							// Add default prop to component only if it doesn't exist on comp
							target[property] = sourceValue;
						}
					}
				} else if (!(property in target)) {
					// If object is not available, replace
					if (bDisallowDisparateTypes) {
						// Skip if pxPageSize exists
						var sizeProperty = "$pxPageSize" + "$" + property;
						if (sizeProperty in target && target[sizeProperty] !== 0) {
							target[property] = _cloneObject(sourceValue);
						} else if (sourceValue instanceof Array) {
							if (!_isAllEmpty(sourceValue)) {
								target[property] = _cloneObject(sourceValue);
							}
						} else if (target instanceof Array) {  //BUG-301192- Fixed merging of empty changetracker object (pagelist) and clientdataprovider      
							if (!_isAllEmpty(sourceValue)) {
								target[property] = _cloneObject(sourceValue);
							}
						} else {
							target[property] = _cloneObject(sourceValue); /* BUG-304240: Always clone change tracker object. */
						}
					} else {
						target[property] = sourceValue;
					}
				}
				// The original code
                /*
                } else if (property in target) {
                    _mergeObjects(target[property], sourceValue, bOverride, bDisallowDisparateTypes);
                }
                */
				else if (property in target) {

					var sizeProperty = "$pxPageSize" + "$" + property;
					var partialListProperty = "$partialListProperty" + "$" + property;

					var isSourceListOrGroupProperty = sizeProperty in source;
					var isPartialListProperty = false;

                    /*
                        New rules:
                        If sizeProperty -> full list
                        If sparse array -> partial list
                        If partialListProperty -> partial list
                    */
					if (sourceValue instanceof Array) {
						isPartialListProperty = false;      // Set partial - false by default

						// Look for pxPageSize sibling property
						if (sizeProperty in source) {
							isPartialListProperty = false;
						}
            /* BUG-530745 clearing will happen only if sourceValue has empty objects */
						if (_isParseArray(sourceValue)) {
							isPartialListProperty = true;
							// Delete extra items from target based on incoming size
							// HACK: BUG-311754: To support <LAST> predicate with incomplete AND sparse list!!!!!!!!
							// TODO: Remove post 7.3GA
							/* BUG-360684: Updated the logic to depend on sizeProperty */
							if (target[property] instanceof Array && typeof source[sizeProperty] != "undefined") {
								var targetLength = Object.keys(target[property]).length;
								var sourceLength = parseInt(source[sizeProperty]);
								var diff = targetLength - sourceLength;
								target[property].splice(sourceLength, diff);
							}
						}
						// Look for partialListProperty sibling property on target (set by MD)
						if (partialListProperty in target) {
							isPartialListProperty = true;
						}
					}

                    /*  
                        **CT signals empty object - delete it
                        - target and source are empty => target already knows what it holds, do not splice
                    */
					if (bOverride && source instanceof Array && bDisallowDisparateTypes && (_isAllEmpty(sourceValue) && !_isAllEmpty(target[property])) && !_isSingleProperty(sourceValue) && _isSubset(target[property], sourceValue) && !_isMetaObject(target[property])) {
						// TODO: Depend on pxListProperty
						//target[property] = {};
						target.splice(property, 1);
					}
					// {PL or PG} + {ContextTree & AJAX} + Not Partial Refresh
					else if (bOverride && (target[property] && (target[property] instanceof Array || (target[property].constructor == Object && isSourceListOrGroupProperty))) && !bDisallowDisparateTypes && pega.ui.TemplateEngine.__AJAXRendering && !_isAllEmptyWithMeta(sourceValue) && !isPartialListProperty) {
						// PL in AJAX -> Replace as is
						//target[property] = _cloneObject(sourceValue);
						target[property] = sourceValue;
					}
					// In case of primitive homogeneous array, adapt incoming as is
					else if (sourceValue instanceof Array && (typeof sourceValue[0] == "string" || typeof sourceValue[0] == "number")) {
						target[property] = sourceValue;
					}
					// Rest of the world
					else {
						// Only when target exists       
						if (typeof target[property] == "object") {
							// Check if descendants need to be merged as is
							var replaceFlag = _replaceAsIsList.indexOf(property) != -1;
							_mergeObjects(target[property], sourceValue, bOverride, bDisallowDisparateTypes, replaceFlag);
						}
						// target is primitive - somehow
						/* sourceValue => object, targetValue => string */
						// SE-36013: Adapting primitive types for context tree 
						else if (!bDisallowDisparateTypes || (target[property] && typeof target[property] == typeof sourceValue))
							target[property] = sourceValue;
					}
				}
			}
		}
	};

	var _replaceAsIsList = ["$pxSections"];

	//Made associated changes to fix BUG-310790
	var _isAllEmpty = function(obj) {
		for (var k in obj) {
			// If value is "" || null || undefined, continue
			if (obj[k] === "" || obj[k] === null || obj[k] === undefined)
				continue;
			// Quit with false, if a 'real' value is found
			if (typeof obj[k] != "object") {
				return false;
			}
			else {
				// If an object is encountered, go after it recursively; Return immediately if false; Else give it another chance
				//return false;
				if (_isAllEmpty(obj[k]) === false)
					return false;
			}
		}
		return true;
	};

    /*
    var _isAllEmptyWithMeta = function (arr) {
        if (typeof arr != "object" )
            return false;

        if (!(arr instanceof Array))
            arr = [arr];

        for (var i = 0; i < arr.length; i++) {
            var obj = arr[i];
            for (var k in obj) {
                if (k == "$pxNonTemplates" || k == "$pxWhens" || k == "$pxLocalized")
                    continue;
                if (obj[k]) {
                    //return false;
                    return _isAllEmptyWithMeta(obj[k]);
                }
            }
        }
        return true;
    };
    */

	var _isAllEmptyWithMeta = function(obj) {
		for (var k in obj) {
			// If value is "" || null || undefined, continue
			if (obj[k] === "" || obj[k] === null || obj[k] === undefined || k == "$pxNonTemplates" || k == "$pxWhens" || k == "$pxLocalized")
				continue;
			// Quit with false, if a 'real' value is found
			if (typeof obj[k] != "object") {
				return false;
			}
			else {
				// If an object is encountered, go after it recursively; Return immediately if false; Else give it another chance
				//return false;
				if (_isAllEmpty(obj[k]) === false)
					return false;
			}
		}
		return true;
	};

	// Merge defaults per  component
	var _mergeDefaults = function(componentMetadata) {

		var componentType = componentMetadata["pyName"];
		var defaults = _getDefaultsByComponent(componentType);
		//if (defaults)
		{
			// Merge defaults on to component
			_mergeObjects(componentMetadata, defaults);
		}
	};

    /*
    var _getMetadataPath = function(componentMetadata, mode) {
        var obj;
        switch (mode) {
            case "pyModes0":
                obj = componentMetadata[pyCell]["pyModes"][0];
                break;
            case "pyModes1":
                obj = componentMetadata[pyCell]["pyModes"][1];
                break;
            case "pyCell":
                obj = componentMetadata[pyCell];
                break;
            default:
                obj = componentMetadata;
        }
        return obj;
    };
    */

	// Used only by section store
	var _buildTemplateTree = function(rootTemplate, bSkipSection) {

		// Sections are already parsed
		if (bSkipSection && rootTemplate["pyName"] == "pxSection")
			return;

		_mergeDefaults(rootTemplate);

		var templates = rootTemplate["pyTemplates"];
		if (!templates)
			return;
		var len = templates.length;

		for (var i = 0; i < len; i++) {

			// Recursively call for child components
			if (templates[i]["pyName"]) {
				if (bSkipSection && templates[i]["pyName"] == "pxSection")
					continue;

				_buildTemplateTree(templates[i], bSkipSection);
			}
		}
	};

	var _getPathFromParentSection = function(component) { /* ISSUE-22144: Logic to retrieve path of the component from its parent section */
		var path = "";
		var parentObj = component;
		while (true) {
			path = (parentObj.objName ? parentObj.objName : '') + path;
			if (parentObj.parentObj && parentObj.parentObj.pyName == "pxSection") {
				break;
			} else if (parentObj.parentObj) {
				parentObj = parentObj.parentObj;
			} else {
				break;
			}
		}

		return (path ? path.substr(1) : "");
	};


    /*
     * Process the metadata
     * - Merge defaults
     * - Clone referenced section component
     * - Process Whens
     * - Process NonTemplates
     * - Process localized values
     */
	var _processMetadata = function(rootTemplate, bOnLoad) {
		var templates = rootTemplate["pyTemplates"];
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();

		var len = templates.length;


		// For each and every template component, do the following
		for (var i = 0; i < len; i++) {
			rootTemplate["pyTemplates"][i].objName = ".pyTemplates." + i;
			rootTemplate["pyTemplates"][i].parentObj = rootTemplate;

			rootTemplate["pyTemplates"][i] = _processMetadataPerComponent(templates[i], currentContext, bOnLoad);

			if (rootTemplate["pyTemplates"][i]) {
				if (rootTemplate["pyTemplates"][i][pega.ui.TEMPLATE_CONSTANTS.PYGENERATEPATH] === "true") {
					rootTemplate["pyTemplates"][i].path = _getPathFromParentSection(rootTemplate["pyTemplates"][i]);
				}
				delete rootTemplate["pyTemplates"][i].parentObj;
				delete rootTemplate["pyTemplates"][i].objName;
			}

		}


		return rootTemplate;
	};

	var _processMetadataPerComponent = function(template, currentContext, bOnLoad, bFromRepeatRender) {
		var pxReferencedId;

		var primaryPage;

		// var template = templates[i];
		var inRepeatingComponent = _inRepeatingComponent(template.pyName);

		//if (bOnLoad) {
		// 1. Merge defaults for referenced sections
		if (!template.pxReferencedId) {
			_mergeDefaults(template);
		}
		//}

		// Set Primary Page to be used by Whens n NTs
		// TODO: Harness to use pzPrimaryPage instead of pzPrimaryPageName
		primaryPage = template["pxDatapages"] || template["pzPrimaryPage"] || template["pzPrimaryPageName"] /* Harness */;
		if (primaryPage) {
			if (primaryPage.startsWith("$$")) {
        /*BUG-573608 : change to manage data source array (_getIndexedReference), as same DP can resolve to different page if parameterized */
				template["pzPrimaryPage"] = primaryPage = _getIndexedReference(currentContext.getDataSource(primaryPage.substring(2)));
			} else if (template["isUsingPagePRef"]) {
				template["pzPrimaryPage"] = primaryPage = currentContext.getPropertyValue(primaryPage);
			}
			if (primaryPage) {
				var resolvedRef = currentContext.getReferencedProperty(primaryPage, true);
				if (resolvedRef) {
					if (template["pyName"] == "pxSection") {
						template["originalReference"] = primaryPage;
					}
					template["pzPrimaryPage"] = primaryPage = resolvedRef;
				}
				if (primaryPage.startsWith(".")) {
					var resolvedPage = currentContext.getPropertyValue(primaryPage)
					primaryPage = (resolvedPage && typeof resolvedPage == "string") ? resolvedPage : primaryPage;
				}

				currentContext.push(primaryPage);
			}
		}

		// 1.5. Process constants
		_processConstants(template);

		// 2. Process Whens
		_processWhens(template);

		// 3. Clone referenced section
		var pxReferencedId = template.pxReferencedId;
		template = _cloneReferencedSection(template);

		if (!template) {
			// Cleanup
			if (primaryPage)
				currentContext.pop();

			return;
		}

		// 4. Process Non-Templates
		_processNonTemplates(template);
		_processSubscriptionIds(template);
		_processErrors(template);
		// 5. Process Localized daata
		// NR: Will be handled by controls
        /*
        if (pega.u.d.ServerProxy.isDestinationRemote()) // Not offline
            _processLocalizedData(template);
        */

		// Recursively call for child components
		// Process RDL children only when it is directly called from RDL render
		if (!_isComponentDummy(template) && template["pyTemplates"] && ((!bOnLoad && bFromRepeatRender) || !inRepeatingComponent)) {
			_processMetadata(template, bOnLoad);
		}

		// Process parameter pages
		_processParamPage(template);

		// Cleanup
		if (primaryPage)
			currentContext.pop();

		// Asign back
		return template;
	};

	var _isComponentDummy = function(componentMetadata) {
		return componentMetadata["pyName"] == "Dummy";
	};

	/* LRU */
	var _LRUSectionCache = [];
	// TODO: Send along with UITemplatingStatus in AJAX or as a separate request?
	var _deletedSectionList = [];
	var MAX_SECTIONS_COUNT = 100;

	var _pushtoArray = function(input, arr, maxSize) {
		if (!arr)
			arr = _LRUSectionCache;
		if (!maxSize)
			maxSize = MAX_SECTIONS_COUNT;

		var index = arr.indexOf(input);
		if (index != -1) {
			// Remove element if already exists
			arr.splice(index, 1);
		}
		// check limit
		if (arr.length >= maxSize) {
			// Remove element
			var removedItem = arr.shift();
			// Add to delete list
			_deletedSectionList.push(removedItem);

		}

		// Add to end
		arr.push(input);
	}

	// Remove deleted items from Section Store
	var _updateMetadataCache = function(type) {
		var sectionStore = pega.ui.ClientDataProvider.getMetadataStoreByType(type);
		for (var i = 0; i < _deletedSectionList.length; i++) {
			var removedItem = _deletedSectionList[i];
			sectionStore[removedItem] = null
		}
	};

	// Clone referenced section
	var _cloneReferencedSection = function(metadata) {
		var pxReferencedId = metadata.pxReferencedId;
		if (pxReferencedId) {

			var instanceId = metadata.pyInstanceID; // TODO: Correct case
			// Referenced sections
			if (metadata.pyName == "pxSection") {

				// Get pxReadOnly
				var currentContext = pega.ui.TemplateEngine.getCurrentContext();
				var pxReadOnly = currentContext.getSectionReadOnlyFlag(pxReferencedId);
				pxReadOnly = _getIndexedReference(pxReadOnly);

				var sectionUniqueID = currentContext.getSectionUniqueID(pxReferencedId);
				sectionUniqueID = _getIndexedReference(sectionUniqueID);

				var sectionGadgetID = currentContext.getSectionGadgetInfo(pxReferencedId);
				sectionGadgetID = _getIndexedReference(sectionGadgetID);

				var sectionParams = currentContext.getSectionParameters(pxReferencedId);
				sectionParams = _getIndexedReference(sectionParams);

				// Get the instance ID from the current pxReferencedId
				var contextInstanceId = currentContext.getSectionInstanceId(pxReferencedId);
				contextInstanceId = _getIndexedReference(contextInstanceId);

				// Get param DP params
				var usingPage = currentContext.getSectionParamDP(pxReferencedId);
				var usingPageParams;
				var usingPageName;
				if (usingPage) {
					usingPageParams = _getIndexedReference(usingPage["params"]);
					usingPageName = _getIndexedReference(usingPage["name"]);
				}

				// Get dynamic pxReferencedId
				var dynamicReferenceId = currentContext.getDynamicSectionId(pxReferencedId);
				pxReferencedId = (dynamicReferenceId && _getIndexedReference(dynamicReferenceId)) || pxReferencedId;

				// Get dynamic instanceId on top of newly retrieved dynamic pxReferencedId
				var dynamicInstanceId = currentContext.getSectionInstanceId(pxReferencedId);
				dynamicInstanceId = _getIndexedReference(dynamicInstanceId) || contextInstanceId || instanceId;

				// Now lookup in metadata store for definition
				var sectionStore = pega.ui.ClientDataProvider.getMetadataStoreByType("SECTION");
				var sourceMetadata = sectionStore[pxReferencedId];
				if (!sourceMetadata) {
					// Pretty print only if there is a dynamic section entry
					if (dynamicReferenceId)
						console.log("Section metadata with id' " + pxReferencedId + "' not found!");
					return;
				}

				// Push to context
				currentContext.pushSectionReferenceId(pxReferencedId);

				// Add to cache
				/* BUG-401554: The cache implementation is incomplete */
				// _pushtoArray(pxReferencedId);

				var pzPrimaryPage = metadata.pzPrimaryPage;
				var ignoreBaseRef = metadata.ignoreBaseRef;
				var originalBaseRef = metadata.originalReference;
				var secActionStringID = metadata.secActionStringID;

				// Put new metadata
				metadata = _cloneObject(sourceMetadata);
				if (originalBaseRef) {
					metadata.sectionBaseRef = (!ignoreBaseRef && originalBaseRef) ? originalBaseRef : "";
				} else {
					metadata.sectionBaseRef = (!ignoreBaseRef && pzPrimaryPage) ? pzPrimaryPage : "";
				}
				/*US-184868 Action support for section include*/
				if (secActionStringID) {
					metadata.secActionStringID = secActionStringID;
				}

				// Respect the dynamic context set
				if (pzPrimaryPage) {
					metadata.pzPrimaryPage = pzPrimaryPage;
				}
				if (pxReadOnly) {
					metadata.pxReadOnly = pxReadOnly;
				}
				if (sectionParams) {
					metadata.sectionParams = sectionParams;
				}
				if (dynamicInstanceId && !pega.u.d.ServerProxy.isDestinationLocal()) {
					metadata.pyInstanceID = dynamicInstanceId;
				}
				if (usingPageParams) {
					metadata[pega.ui.TEMPLATE_CONSTANTS.DECPARAMS] = usingPageParams;
				}
				if (usingPageName) {
					metadata[pega.ui.TEMPLATE_CONSTANTS.DECPAGE] = usingPageName;
				}
				if (sectionUniqueID) {
					metadata.UID = sectionUniqueID;
				}
				if (sectionGadgetID) {
					metadata.outerGadget = sectionGadgetID;
				}
			}
		}
		return metadata;
	};

	var _processConstants = function(componentMetadata) {
		var componentType = componentMetadata["pyName"];

		switch (componentType) {
			case "pxTimeline":
				_processConstantsForTimeline(componentMetadata);
				break;
		}
	};

	var _processConstantsForTimeline = function(componentMetadata) {
		var editableModes = componentMetadata.pyCell.pyModes[1];
		var TEMPLATE_CONSTANTS = pega.ui.TEMPLATE_CONSTANTS;
		editableModes["startDateProperty"] = editableModes[TEMPLATE_CONSTANTS["PYTIMELINEEVENTSTARTDATE"]];
		delete editableModes[TEMPLATE_CONSTANTS["PYTIMELINEEVENTSTARTDATE"]];
		editableModes["endDateProperty"] = editableModes[TEMPLATE_CONSTANTS["PYTIMELINEEVENTENDDATE"]];
		delete editableModes[TEMPLATE_CONSTANTS["PYTIMELINEEVENTENDDATE"]];
		editableModes["eventSection"] = editableModes[TEMPLATE_CONSTANTS["PYTIMELINEEVENTSECTION"]];
		delete editableModes[TEMPLATE_CONSTANTS["PYTIMELINEEVENTSECTION"]];
		editableModes["dataSource"] = editableModes[TEMPLATE_CONSTANTS["PYSOURCENAME"]];
		delete editableModes[TEMPLATE_CONSTANTS["PYSOURCENAME"]];
		editableModes["startTimeRange"] = editableModes[TEMPLATE_CONSTANTS["PXTIMELINESTARTDATE"]];
		delete editableModes[TEMPLATE_CONSTANTS["PXTIMELINESTARTDATE"]];
		editableModes["endTimeRange"] = editableModes[TEMPLATE_CONSTANTS["PXTIMELINEENDDATE"]];
		delete editableModes[TEMPLATE_CONSTANTS["PXTIMELINEENDDATE"]];
		editableModes["className"] = editableModes[TEMPLATE_CONSTANTS["PYREADWRITESTYLE"]];
		delete editableModes[TEMPLATE_CONSTANTS["PYREADWRITESTYLE"]];
		editableModes["timeRange"] = editableModes[TEMPLATE_CONSTANTS["PYTIMELINERANGE"]];
		delete editableModes[TEMPLATE_CONSTANTS["PYTIMELINERANGE"]];

		// TODO: Add remainder

	};

	var _processWhens = function(componentMetadata) {
		var componentType = componentMetadata["pyName"];
		// pyTemplate
		_callProcessWhens(componentMetadata, componentType);
		// cell
		if (componentMetadata.pyCell) {
			_callProcessWhens(componentMetadata.pyCell, componentType);

			// If dummy return
			if (_isComponentDummy(componentMetadata))
				return;

			if (componentMetadata.pyCell.pyModes) {
				if (componentMetadata.pyCell.pyModes[0])
					_callProcessWhens(componentMetadata.pyCell.pyModes[0], componentType);
				if (componentMetadata.pyCell.pyModes[1])
					_callProcessWhens(componentMetadata.pyCell.pyModes[1], componentType);
			}
		}
	};

	var _processParamPage = function(componentMetadata) {
		var pxParamPage = componentMetadata["parampg"];
		if (!pxParamPage) {
			return;
		}
		var state = _lookupParamPage(pxParamPage);
		state = _getIndexedReference(state);
		componentMetadata["parampg"] = state;
	};

	// Process Whens se component
	var _callProcessWhens = function(componentMetadata, componentType) {
		var isHCOffline = pega.u.d.ServerProxy.isDestinationLocal();
		//var componentType = componentMetadata["pyName"];
		var pxWhenIdentifiers = componentMetadata["pxWhenIdentifiers"];

		if (!pxWhenIdentifiers)
			return;

		var whenListMap = _CONSTANTS.WHEN_LIST_MAP;
		var whenIds = Object.keys(whenListMap);

		for (var i = 0; i < whenIds.length; i++) {
			var whenId = whenIds[i]; // pyVisibilityWhenId
			if (pxWhenIdentifiers[whenId]) {
				var whenProperty = whenListMap[whenId]; // pyVisibility
				var normalisedProperty = _getComponentWhenPropertyMap(whenProperty, componentType); // pyVisibility
				// Lookup WhenId
				var state;
				if (whenProperty == "pyViewPrivilege" || whenProperty == "pyDisablePrivilege") {
					state = _lookupPrivilege(pxWhenIdentifiers[whenId]);
				} else {
					var whenRule = pxWhenIdentifiers[whenId];
					if (isHCOffline) {
						whenRule = _createWhenRuleProperiesObjectForOffline(whenId, pxWhenIdentifiers);
					}
					state = _lookupWhen(whenRule);
				}

				// In case of array
				state = _getTruthValue(_getIndexedReference(state));

				// Update the when property state
				componentMetadata[normalisedProperty] = state;
				/* BUG-301806 and BUG-302599 */
				var pyCell = componentMetadata.pyCell;
				var reserveSpace = (pyCell && (pyCell.pyLabelReserveSpace === "true" || pyCell.pyReserveSpace === "true"));

				// visibility false, don't execute render n quit
				if (whenProperty == "pyVisibility" || whenProperty == "pyViewPrivilege") {
					if (componentMetadata[normalisedProperty] == "undefined")
						delete componentMetadata[normalisedProperty];
					else if (!state && !reserveSpace) {
						componentMetadata.pyName = "Dummy";
						return;
					}
				}
			}
		}

		// Check parent readonly status
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();
		var readOnlyStatus = currentContext.isSectionReadOnly();
		if (readOnlyStatus) {
			// Does child have readonlywhen condition?
			var normalisedProperty = _getComponentWhenPropertyMap("pyReadOnly", componentType);
			if (!componentMetadata[normalisedProperty])
				componentMetadata[normalisedProperty] = readOnlyStatus;
		}
	};
	// _lookupWhen
	var _lookupWhen = function(whenId) {
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();
		return currentContext.getWhenResult(whenId);
	};

	var _lookupParamPage = function(pageId) {
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();
		return currentContext.getParamPage(pageId);
	};

	var _lookupPrivilege = function(privilegeId) {
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();
		return currentContext.getPrivilegeResult(privilegeId);
	};

	var _getIndexedReference = function(reference) {
        /*
        var reference = references;
        // In case of same section included multiple times under same 
        // context then non template ids as array will be recieved from server.
        if (Array.isArray(references) && references.length > 0) {
            reference = references.splice(0, 1)[0];
        }
        */
		// In case of array, return arr[0]
		// Ya, expect undefined

		if (reference instanceof Array)
			return reference.shift();
		else
			return reference;
	};

	var _getTruthValue = function(reference) {
		if (reference instanceof Array)
			return reference;
		else
			return !!reference;
	};

	var _processSubscriptionIds = function(componentMetadata) {
		var TEMPLATE_CONSTANTS = pega.ui.TEMPLATE_CONSTANTS;
		var componentType = componentMetadata["pyName"];
		if (componentMetadata[TEMPLATE_CONSTANTS["PXSUBSCRIPTIONIDENTIFIERS"]]) {
			var pySubscriptionId = componentMetadata[TEMPLATE_CONSTANTS["PXSUBSCRIPTIONIDENTIFIERS"]][TEMPLATE_CONSTANTS["PYWSSUBSCRIPTIONID"]];
			if (!pySubscriptionId)
				return;
			//BUG-305486 : pushing context for non-template include using page      
			var primaryPage = componentMetadata["primaryPage"];
			var currentContext = pega.ui.TemplateEngine.getCurrentContext();
			if (primaryPage) {
				if (primaryPage.startsWith("$$")) {
          /*BUG-573608 : change to manage data source array (_getIndexedReference), as same DP can resolve to different page if parameterized */
					componentMetadata["pzPrimaryPage"] = primaryPage = _getIndexedReference(currentContext.getDataSource(primaryPage.substring(2)));
				}
				if (primaryPage) {
					var resolvedRef = currentContext.getReferencedProperty(primaryPage, true);
					currentContext.push(resolvedRef || primaryPage);
				}
			}
			var newSubscriptionId = _getIndexedReference(_lookupSubscriptionId(pySubscriptionId));
			if (primaryPage) {
				currentContext.pop();
			}
			// Stamp the new id     
			if (newSubscriptionId)
				componentMetadata['pyFinalSubscriptionId'] = newSubscriptionId;
		}

	};
	var _lookupSubscriptionId = function(subscriptionId) {
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();
		return currentContext.getSubscriptionId(subscriptionId);
	};

	var _processErrors = function(componentMetadata) {
		if (componentMetadata && componentMetadata.pyCell && componentMetadata.pyCell.pyModes) {
			if (componentMetadata.pyCell.pyModes[0])
				_callProcessErrors(componentMetadata.pyCell.pyModes[0]);
			if (componentMetadata.pyCell.pyModes[1])
				_callProcessErrors(componentMetadata.pyCell.pyModes[1]);
      if (componentMetadata.pyCell.startDateConfig && componentMetadata.pyCell.endDateConfig) {
        _callProcessErrors(componentMetadata.pyCell.startDateConfig);
        _callProcessErrors(componentMetadata.pyCell.endDateConfig);
      }
		}

	};
	var _callProcessErrors = function(componentMetadata) {
		var TEMPLATE_CONSTANTS = pega.ui.TEMPLATE_CONSTANTS;
		var errorId = componentMetadata[TEMPLATE_CONSTANTS["PXERRORIDENTIFIERS"]] ? componentMetadata[TEMPLATE_CONSTANTS["PXERRORIDENTIFIERS"]][TEMPLATE_CONSTANTS["PYERRORID"]] : "";
		if (!errorId)
			return;
		var errorMessage = _getIndexedReference(_lookupErrorId(errorId));
		componentMetadata.errMsgHTML = errorMessage;

	}
	var _lookupErrorId = function(errorId) {
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();
		return currentContext.getErrorId(errorId);
	};
	// Process NonTemplates per component
	var _processNonTemplates = function(componentMetadata) {
		var TEMPLATE_CONSTANTS = pega.ui.TEMPLATE_CONSTANTS;
		var componentType = componentMetadata["pyName"];
		var pyNonTemplateId = componentMetadata[TEMPLATE_CONSTANTS.PXNONTEMPLATEREF];
		if (!pyNonTemplateId)
			return;
		//BUG-305486 : pushing context for non-template include using page
		var primaryPage = componentMetadata["primaryPage"];
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();
		var isContextPushRequired = true;
		if (primaryPage) {
			if (primaryPage.startsWith("$$")) {
        /*BUG-573608 : change to manage data source array (_getIndexedReference), as same DP can resolve to different page if parameterized */
				componentMetadata["pzPrimaryPage"] = primaryPage = _getIndexedReference(currentContext.getDataSource(primaryPage.substring(2)));
			} else if (componentMetadata["isUsingPagePRef"]) {
				componentMetadata["pzPrimaryPage"] = primaryPage = currentContext.getPropertyValue(primaryPage);
			}
			if (primaryPage) {
				var resolvedRef = currentContext.getReferencedProperty(primaryPage, true);
				if (!resolvedRef) isContextPushRequired = false;
				if (isContextPushRequired) {
					currentContext.push(resolvedRef || primaryPage);
				}
			}
		}

		var newNonTemplateId = _getIndexedReference(_lookupNonTemplate(pyNonTemplateId));
		if (isContextPushRequired && primaryPage) {
			currentContext.pop();
		}

		// Stamp the new id
		if (newNonTemplateId)
			componentMetadata[TEMPLATE_CONSTANTS.PYNONTEMPLATEID] = newNonTemplateId;
	};

	// _lookupNT
	var _lookupNonTemplate = function(nonTemplateId) {
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();
		return currentContext.getNonTemplateId(nonTemplateId);
	};

	// Process Loalization per component
	// @deprecated
    /*
    var _processLocalizedData = function(componentMetadata) {

        var componentType = componentMetadata["pyName"];
        var localizableProperties = _getComponentLocalizationMap(componentType);
        for (var property in localizableProperties) {
            var valueObj = localizableProperties[property];
            var mode = valueObj["mode"];
            var messageType = valueObj["messageType"];

            // Set the localized value
            var localizedValue = _lookupLocalizedValue(property, messageType);
            if (localizedValue) {
                var pathObject = _getMetadataPath(componentMetadata, mode);
                pathObject[property] = localizedValue;
            }
        }
    };
    // lookup localized value
    var _lookupLocalizedValue = function(property, messageType) {
        var primaryPagePointer = pega.peekStackFrame("PrimaryPageStack");
        if (!primaryPagePointer)
            return;
        var propertyReference = primaryPagePointer[property];
        if (!propertyReference)
            return;
        var pxLocalizedData = propertyReference["pxLocalizedData"];
        if (!pxLocalizedData)
            return;

        return pxLocalizedData[messageType];
    };
    */

    /*
     * Handlebars renderer helpers
     */
	// Called by Handlebars template of section
	var _renderChildren = function(componentInfo, docFrag) {
		var templatePath = componentInfo._ref;
		pega.ui.logger.LogHelper.debug("Rendering template location : ", templatePath);

		docFrag = docFrag || pega.ui.template.RenderingEngine.getCurrentDocument();
		var returnHtml = "";

		var templates = pega.ui.TemplateEngine.getTemplates(componentInfo);

		if (templates) {

			for (var i = 0; i < templates.length; i++) {

				var templateNode = templates[i];
				if (!templateNode)
					return;

				var templateName = templateNode["pyName"];

				if (templateName != "") {
					var markup = pega.ui.template.RenderingEngine.getRenderer(templateName)(templateNode);

					if (templateNode["pyInstanceID"]) {
						pega.ui.logger.LogHelper.debug("Replacing template markup at instanceid : ", templateNode["pyInstanceID"]);
						var placeholder = docFrag.querySelector("[data-template-instance-id='" + templateNode["pyInstanceID"] + "']");
						if (placeholder && placeholder.outerHTML) {
							placeholder.outerHTML = markup;
						}
					} else {
						returnHtml = returnHtml + markup;
					}
				}
			}
		}
		return returnHtml;
	};

    /**
     * Returns the string containing the refresh when attributes for the passed component.
     * @param componentInfo Object
     *  Callers should pass componentInfoParent
     * @return attributes string
     **/

	var _getRefreshWhenAttributes = function(componentInfo, componentInfoParent) {
		var attrStr = "";
		//var componentObj = componentInfo.templatePage;
		var componentObj = componentInfo;

		//if(componentInfo.templatePage.get("pyName").getValue() != "pxLayoutContainer"){
		if (componentInfo["pyName"] != "pxLayoutContainer") {
			componentObj = componentInfoParent;
		}
		var rw = componentObj["pyRefreshWhen"];
		var rwProperty = componentObj["pyRefreshWhenProperty"];
		var rwDataTransform = componentObj["pyRefreshWhenDTransform"];
		var rwPreActivity = componentObj["pyRefreshWhenActivity"];

		//rwp='' rw='' rwa='' pdt=''
		if (rwProperty && rwProperty != '') {
			attrStr += " rwp=\"" + rwProperty + "\" ";
		}
		if (rw && rw != '') {
			attrStr += "rw=\"" + rw + "\" ";
		}
		if (rwPreActivity && rwPreActivity != '') {
			attrStr += "rwa=\"" + rwPreActivity + "\" ";
		}
		if (rwDataTransform && rwDataTransform != '') {
			attrStr += "pdt=\"" + rwDataTransform + "\" ";
		}
		return attrStr;
	};

    /*
    removes pyForceReloadTemplates from ClientCache
    */
	var _removeForceReloadTemplates = function(forceReloadRoots) {

		if (!forceReloadRoots) {
			//var roots = pega.ui.ClientCache.find("D_UITemplateMeta.pyForceReloadTemplates");
			var roots = this.getMetadataTree()["pyForceReloadTemplates"];
			if (roots) {
				//forceReloadRoots = roots.getValue();
				forceReloadRoots = roots;
				if (!forceReloadRoots) {
					// Do not proceed.
					return;
				}
			}
		}

		// TODO: revisit
		pega.ui.logger.LogHelper.debug("Removing paths ", forceReloadRoots);
		var forceReloadPaths = forceReloadRoots.split(",");
		for (var path in forceReloadPaths) {
			var metadataTree = pega.ui.ClientCache.find(forceReloadPaths[path]);
			metadataTree.remove();
		}
	};
  
  var _removeHarnessSkeleton = function(){
    // Removing the skeleton
      var harnessSkeletonWrapper = document.getElementById("harness_skeleton_wrapper");
		  if (harnessSkeletonWrapper) {
			    harnessSkeletonWrapper.remove();
		  }
  };

  /* renderUI: Renders the template UI (invoked both in onload and reload (AJAX) scenarios)
          1) Extarct scripts fromm template-scripts
          2) Call RE
          3) Call data binding
          4) Purge metadata tree
  */
	var _renderUI = function(responseNode, uiRenderedCallback, renderPartialParams) {
      
		var actualContext = pega.ctx;
		// Set AJAX rendering
		this.__AJAXRendering = !!uiRenderedCallback;
		if (!this.__UIRenderCount)
			this.__UIRenderCount = 0;
		else {
			/* BUG-314443: Do not execute if one call is already in progress */
			setTimeout(function() {
				pega.ui.TemplateEngine.renderUI(responseNode, uiRenderedCallback, renderPartialParams);
			}, 0);
			return;
		}
		this.__UIRenderCount++;
		//this.__streamCacheObject = this.__streamCacheObject || {};
		//this.__streamCached = false;
    
    /* SE-50169 Maintaining metadatatree object in a function scope to avoid timing issues.*/
    var scopedMetaDataTree = pega.u.d.parseAndGetMetaDataTree(responseNode);

		// Reset the flags
		isUIRendered = false;

		if (typeof pega.ui.property == 'function') {
			pega.u.property = new pega.ui.property();
		}
		var doc = document;
		var responseText;
		// Template rendering
		function scriptsLoadedCallback() {
			pega.ctxmgr.setContext(actualContext);
			// Call RE
			function callback() {
				// Call data binding
				pega.ui.template.DataBinder.bindData(doc);

				pega.ui.TemplateEngine.__UIRenderCount--;

				if (!pega.ui.TemplateEngine.__UIRenderCount) {
					// Purge metadata tree
					pega.ui.TemplateEngine.purgeMetadataTree(doc);
				}

				// Reset
				if (pega.ui.TemplateEngine.__RDLROWIntercepted) {
					pega.ui.TemplateEngine.__RDLROWIntercepted = false;
					pega.clientTools.putParamValue("bRDLShowDetails", false);

					if (pega.ui.TemplateEngine.__originalThread) {
						pega.u.d.switchThread(pega.ui.TemplateEngine.__originalThread);
						pega.ui.TemplateEngine.__originalThread = null;
					}
				}

				if (uiRenderedCallback) { // AJAX
					pega.clientTools.reset();
					uiRenderedCallback(doc.innerHTML, true);
				} else {
          //setTimeout(_removeHarnessSkeleton, 0);
					pega.ui.ClientCache.clearChangedPagesList();
					// If template and init load, fire explict load and DOMContentLoaded events
                    /*
                  if(pega.isUITemplatized && typeof TemplateEvents != "undefined") {
                     var eventDescriptor = {eventName: "load", customProperty: "__pegaInducedOnLoad"};
                     TemplateEvents.fireCustomEvent(eventDescriptor);
                     var eventDescriptor = {eventName: "DOMContentLoaded", customProperty: "__pegaInducedOnDOMContentLoaded"};
                     TemplateEvents.fireCustomEvent(eventDescriptor);
                  }
                */
				}
				pega.ui.EventsEmitter.publish("TemplateUIRendered");

				// BUG-360494: Empty the current RE document
				pega.ui.template.RenderingEngine.setCurrentDocument(null);
			}

			_mergeChangeTrackerOnToContextTree();

			var metadataTree = scopedMetaDataTree || pega.ui.TemplateEngine.getMetadataTree();
			if (metadataTree) {
				var sectionStore = pega.ui.ClientDataProvider.getMetadataStoreByType("SECTION");
				if (sectionStore) {
					// Merge defaults per section in store
					for (var section in sectionStore) {
						var sectionObject = sectionStore[section];
						if (sectionObject) {
							_buildTemplateTree(sectionObject);
						} else {
							console.log("Can't find section: " + section + " in section store.");
						}
					}
				}

				// 2nd pass: Defer loaded layouts, Grids, harnesses
				_buildTemplateTree(metadataTree, true);

				// Process metadata
				metadataTree = _processMetadata(metadataTree, true);

				if (renderPartialParams && renderPartialParams.partialMetadataPath) { /* if partial params are present then retrieve metadata from partialMetadataPath and invoke generateMetadataFn to update partial metadata. */
					var partialMetadataPath = renderPartialParams.partialMetadataPath;
					var instanceId = metadataTree.pyTemplates[0].pyInstanceID;
					var partialMetadataTree = partialMetadataPath.split(".").reduce(_index, metadataTree.pyTemplates[0]);
					partialMetadataTree.pyInstanceID = instanceId;
					metadataTree = {"pyTemplates": []};
					metadataTree.pyTemplates.push(partialMetadataTree);
					if (renderPartialParams.generateMetadataFn && typeof renderPartialParams.generateMetadataFn === "function") {
						renderPartialParams.generateMetadataFn(partialMetadataTree);
						pega.ui.TemplateEngine.setMetadataTree(metadataTree);
					}
				}
			}

			// The actual rendering
			pega.ui.template.RenderingEngine.beginRendering(doc, callback, metadataTree);

			// Updte metadata cache
			// TODO: Notify server of deleted list
			_updateMetadataCache("SECTION");
			pega.ctxmgr.resetContext();
		}
    
		// Consume the responseText
		if (typeof responseNode == "string") {
			responseText = responseNode;

			// Detect if RDL row section
			if (responseNode.indexOf("RDLROWMARKUP_BEGIN") != -1) {
				this.__RDLROWIntercepted = true;
				pega.clientTools.putParamValue("bRDLShowDetails", true);
				var threadName = pega.u.d.getThreadName();
				var baseThreadName = pega.u.d.baseThreadName;
				if (threadName == baseThreadName + "/" + pega.ui.rdlMasterDetails.RDL_MD_THREAD) {
					// Switch to base
					pega.u.d.switchThread(baseThreadName);
					this.__originalThread = threadName;
				}
			}
		} else if (responseNode && responseNode.nodeType == 1) {
			responseText = responseNode.innerHTML;
		} else {

			// Onload, Initialize ChangeTracker
			pega.u.d.initChangeTracker();
			pega.ui.ClientDataProvider.initChangeTracker();

			// harness execute case, do direct invocation
			scriptsLoadedCallback();
			return;
		}
		var harCtxMgr = pega.ui.HarnessContextMgr;
    // AJAX case
		if (responseNode.nodeType == 1) {
			// node already exists, do not create one
		} else {
			responseNode = document.createElement("div");
			responseNode.innerHTML = responseText;
		}
    
		// Check for nontemplate rendering or special conditions
    //BUG-337591 - instead of using text search using queryselector on responseNode
     if (!(pega.ctx.isUITemplatized) || responseText.lastIndexOf("{EndReloadCell}") != -1 || !responseNode.querySelector("[data-template-instance-id]")) {
			// Invoke actual callback and quit
			/*Identify if non template stream has client expressions*/
			if (pega.ui.ExpressionEvaluator && !pega.ui.ExpressionEvaluator.getNTExpressionStatus()) {
				var ctDivStrs = ["id=\"CT\"", "id='CT'", "data-refresh", "data-required", "layout-active-when"];
				for (var i = ctDivStrs.length - 1; i >= 0; i--) {
					if (responseText.indexOf(ctDivStrs[i]) > -1) {
						pega.ui.ExpressionEvaluator.setNTExpressionStatus(true);
						break;
					}
				}
			}

			_mergeChangeTrackerOnToContextTree();
			if (responseText.lastIndexOf("{EndReloadCell}") != -1 && responseText.indexOf("data-template-instance-id") != -1) {
				// This is templatized reload cell, needs true param.
				uiRenderedCallback && uiRenderedCallback(responseText, true);
			} else {
				uiRenderedCallback && uiRenderedCallback(responseText);
			}

			this.__UIRenderCount--;
			return;
		}

		

		doc = responseNode;

		var responseThreadName;
		if (doc) {
			var CTDiv = doc.querySelector("div[id^='AJAXCT']");
			if (CTDiv) {
				responseThreadName = CTDiv.getAttribute("CTTHREAD");
				// BUG-307438: If the incoming thread is a workprocessing one and has init values, initialize ChangeTracker; Assumed HC has spl thread retrieval
				if (CTDiv.hasAttribute("data-json") && (responseThreadName == pega.u.d.getThreadName() + "/$WorkProcessing") && this.__AJAXRendering && !pega.u.d.ServerProxy.isHybridClient()) {
					responseThreadName = pega.u.d.initChangeTracker(responseNode);
				}
			}
		}

		// Initialize ChangeTracker
		/* BUG-269834: If no thread, found in resp object, default to CT's current thread */
		var currentThread = pega.u.d.getThreadName();
		var threadName = /*pega.u.d.initChangeTracker(doc) || */ responseThreadName;
		if (threadName && threadName != currentThread) {
			pega.clientTools.init(threadName);
			pega.ui.ClientDataProvider.initChangeTracker(threadName);
		}

		if (!threadName && currentThread) {/* BUG-300242: This resets to correct thread then responseThreadName(threadName) is null */
			pega.clientTools.init(currentThread);
			pega.ui.ClientDataProvider.initChangeTracker(currentThread);
		}

		pega.ui.EventsEmitter.publishSync("BeforeTemplateScriptExtraction");
		pega.u.d.extractTemplateScripts(responseNode, scriptsLoadedCallback);
		pega.control && pega.control.Actions && pega.control.Actions.prototype.hideSkeleton && pega.control.Actions.prototype.hideSkeleton();
	};

	var _updateContextPage = function(obj, pageRef) {

		if (obj instanceof Array) {
			for (var i in obj) {
				if (obj[i]["pzPrimaryPage"]) {
					obj[i]["pzPrimaryPage"] = pageRef;
				}
			}
		} else {
			obj["pzPrimaryPage"] = pageRef;
		}

		return obj;
	};

	var _addMetadataTree = function(obj) {
		if (typeof obj != "object")
			return;

		if (!pega.ctx["D_UITemplateMeta"])
			pega.ctx["D_UITemplateMeta"] = {};
		if (!pega.ctx["D_UITemplateMeta"].pyTemplates)
			pega.ctx["D_UITemplateMeta"].pyTemplates = [];

        /* Consider targetContext if available, Use cases where launching localaction from RDL or
          launching localaction from different context than packaging.<pzPrimaryPage>
        */
		if (_primaryContext && pega.u.d.ServerProxy.isDestinationLocal()) {
			obj = _updateContextPage(obj, _primaryContext);
			_primaryContext = null;
		}

		if (obj instanceof Array) {
			pega.ctx["D_UITemplateMeta"].pyTemplates = pega.ctx["D_UITemplateMeta"].pyTemplates.concat(obj);
		} else {
			pega.ctx["D_UITemplateMeta"].pyTemplates.push(obj);
		}

		// Set templating status to true
		pega.ctx.isUITemplatized = true;
		pega.isUITemplatized = true;
	};

	// TODO: Is this required?
	var _addRepeatingCompCTProps = function(obj) {
		if (typeof obj != "object")
			return;
		repeatingCompCTProps = obj;
	};


	// @deprecated
	var _setMetadataTree = function(incoming) {
		if (typeof incoming == "object")
			pega.ctx["D_UITemplateMeta"] = incoming;
		else {
			try {
				pega.ctx["D_UITemplateMeta"] = JSON.parse(incoming);
			} catch (e) {
				console.log("An error occurred parsing the metadata tree: " + e);
			}
		}
	};

	var _getMetadataTree = function() {
		return pega.ctx["D_UITemplateMeta"];
	};

	var _purgeMetadataTree = function(doc) {
		delete pega.ctx["D_UITemplateMeta"];

		//HFIX-42254 changes related
		if (pega.u.d.purgeSectionMetaAfterUse) {
			if (doc && doc.nodeType == 1) {
				var currentHarness = document.getElementById("PEGA_HARNESS");
				var currentHarnessName = "";
				if (currentHarness)
					currentHarnessName = currentHarness.getAttribute("node_name");

				var harness = doc.querySelector("[id='PEGA_HARNESS']") || doc.querySelector("[node_name]");
				if (harness) {
					var harnessName = harness.getAttribute("node_name");
					var blackList = pega.u.d.SectionMetaPurgeBlacklist;
					if (blackList instanceof Array && (blackList.indexOf(harnessName) != -1 || blackList.indexOf(currentHarnessName) != -1)) {
						// Black-listed harness, quit
						return;
					}
				}
			}
			// Clean section store
			pega.ui.ClientDataProvider.cleanMetadataStore("SECTION");
		}
	};

	var _getTemplates = function(metaDataTree) {
		if (!metaDataTree)
			metaDataTree = this.getMetadataTree();
		return metaDataTree["pyTemplates"];
	};

    /**
     * renders the stream immediately when rendering of UI is done,
     * else push the stream object to the queue so that it can be processed
     * at the end.
     * @param  {AsyncStream} asyncStreamObj object holds the necessary information to
     *                                      process the stream.
     */
	var _renderAsyncStream = function(asyncStreamObj, enableAttachOnLoad) {
		if (enableAttachOnLoad) {
			asyncStreamObj.enableAttachOnLoad = enableAttachOnLoad;
		}
		if (isUIRendered) {

			var placeholder = pega.ctx.dom.getElementById(asyncStreamObj.getUniqueId());
			if (placeholder) {
				if (asyncStreamObj.enableAttachOnLoad) {
					pega.u.d.loadDOMObject(placeholder, asyncStreamObj.getStream(), null, {
						domAction: "replace",
						domElement: placeholder
					});
				} else {
					placeholder.outerHTML = asyncStreamObj.getStream();
				}
			}
		} else {
			asyncStreamQueue.push(asyncStreamObj);
		}
	};

    /**
     * Renders all async stream captured.
     */
	var _renderAsyncStreams = function() {
		var len = asyncStreamQueue.length;
		isUIRendered = true;

		for (var i = 0; i < len; i++) {
			var asyncStreamObj = asyncStreamQueue[i];
			_renderAsyncStream(asyncStreamObj);
		}

		asyncStreamQueue = [];
	};

    /**
     * AsyncStream class
     */
	var AsyncStream = function() {

		var uniqueId = "template" + (counter++);
		var lStream;

		this.setStream = function(stream) {
			lStream = stream;
		};

		this.getStream = function() {
			return lStream;
		};

		this.getUniqueId = function() {
			return uniqueId;
		};

		this.getPlaceholderMarkup = function() {
			return "<div id='" + uniqueId + "' class=\"field-item dataValueRead templateloading\"><span>Loading...</span></div>";
		};

	};

	var _newAsyncStream = function() {
		return new AsyncStream();
	};

	var RepeatingDepth = function(pStepPage, pIndex) {
		var stepPage = pStepPage;
		var index = pIndex;
		this.setStepPage = function(pStepPage) {
			stepPage = pStepPage;
		};
		this.setIndex = function(pIndex) {
			index = pIndex;
		};
		this.getStepPage = function() {
			return stepPage;
		};
		this.getIndex = function() {
			return index;
		};
	};
	var _newRepeatingDepth = function(stepPage, index) {
		return new RepeatingDepth(stepPage, index);
	};
	var _pushRepeatingDepth = function(contextData) {
		if (!contextData || !(contextData instanceof RepeatingDepth) || !contextData.getStepPage() || !contextData.getIndex()) {
			return null;
		}
		repeatingDepthStack.push(contextData);
	};
	var _popRepeatingDepth = function() {
		return repeatingDepthStack.pop();
	};
	var _peekRepeatingDepth = function() {
		if (repeatingDepthStack.length == 0) {
			return null;
		}
		return repeatingDepthStack[repeatingDepthStack.length - 1];
	};
	var _getRepeatingDepthForExpression = function() {
		var returnStr = "";
		for (var i = 0; i < repeatingDepthStack.length; i++) {
			returnStr += "_" + repeatingDepthStack[i].getIndex();
		}
		return returnStr;
	};

	var _getComponentWhenPropertyMap = function(property, componentType) {
		return _CONSTANTS.COMPONENT_WHEN_PROPERTY_MAP[property][componentType] || property;
	};

    /*
    var _getComponentLocalizationMap = function(component) {
        return _CONSTANTS.COMPONENT_LOCALIZATION_MAP[component];
    };
    */

	var _createWhenRuleProperiesObjectForOffline = function(whenId, whenIdentifiers) {
		var whenProperties = _CONSTANTS.WHEN_RULE_PROPERTIES_MAP[whenId];
		if (whenProperties !== undefined) {
			var properties = {};
			properties.uniqueId = whenIdentifiers[whenId];
			properties.className = whenIdentifiers[whenProperties["class"]];
			properties.ruleName = whenIdentifiers[whenProperties["name"]];
			return properties;
		}
		return whenIdentifiers[whenId];
	}

	var _inRepeatingComponent = function(componentType) {
		if (_CONSTANTS.REPEATING_COMPONENTS_MAP.indexOf(componentType) != -1)
			return true;
	};

    /*
     * Analyse and merge big data viz. data, localized data, Whens, NonTemplates, referenced components in one go
     * - Writes big data to client cache
     * - Merge defaults
     * - Clone referenced section component
     * - Process Whens
     * - Process NonTemplates
     * - Proces localized data

     * Sample big data
      {
        "pyDisplayHarness": {
            "pyName": {
                "value": "Shasank",
                "pxLocalized": {
                    "pyTooltip": "Naam"
                },
            },
            "pyId": {
                "value": "2013092",
            },
            "pxWhens": {
                "w1": true,
                "w3": true
            },
        },
        "D_Emplyees": {
            "pxResults": [
                {   // 0
                    "pyName": {
                        "value": "Shasank",
                        "pxLocalized": {
                            "pyTooltip": "Naam"
                        },
                    },
                    "pyId": {
                        "value": "2013092",
                    },
                    "pxWhens": {
                        "w1": true,
                        "w2": true
                    },
                    "pxNonTemplates": {
                        "nt1": "1482329980111000"
                    }
                },
                {   // 1
                    "pyName": {
                        "value": "Rama",
                        "pxLocalized": {
                            "pyTooltip": "Naam"
                        },
                    },
                    "pyId": {
                        "value": "123",
                    },
                    "pxWhens": {
                        "w1": true,
                        "w2": true
                    },
                    "pxNonTemplates": {
                        "nt1": "1482329980111000"
                    }
                }
            ]
        }
       }
    */
	var _mergeBigData = function(bigDataObject, thread) {
		// Write to ClientDataProvider      
		if (!thread)
			thread = pega.ui.ClientDataProvider.getBaseThread();
		//var currentDataProvider = pega.ui.ClientDataProvider.getTrackerByThread(thread).trackedPropertiesList;
		for (var key in bigDataObject) {
			/* added for US-229126 - parmn */
			if (_removeData && !key.startsWith('$')) {
				_removeStaleData(key, bigDataObject);
			}
			// Replace
			//currentDataProvider[key] = bigDataObject[key];
			_adaptPage(key, bigDataObject[key], thread, bigDataObject);
		}
	};

	var _enableDataUpdate = function() {
		_removeData = true;
	};

	var _disableDataUpdate = function() {
		_removeData = false;
	};


	/* added for US-229126 - parmn */
	var _removeStaleData = function(pageName, bigDataObject) {
		if (bigDataObject && pageName && bigDataObject[pageName]) {
			for (var key in bigDataObject[pageName]) {
				if (!key.startsWith('$') && typeof bigDataObject[pageName][key] == "string") {
					delete bigDataObject[pageName][key];
				} else if (!key.startsWith('$') && typeof bigDataObject[pageName][key] == "object") {
					_removeStaleData(key, bigDataObject[pageName]);
				}
			}
		}
	};

	var _adaptPage = function(pageName, pageObject, thread, bigDataObject) {
		var currentDataProvider = pega.ui.ClientDataProvider.getTrackerByThread(thread).trackedPropertiesList;
		if (!currentDataProvider[pageName] || typeof pageObject != "object" || (pageObject instanceof Array && pega.ui.TemplateEngine.__AJAXRendering))
			currentDataProvider[pageName] = pageObject;
		else {
      /* INC-220532 (HFIX-83970) - when a pageGroup is mapped to pageList through a page 
      (like in steppage of the activity), 
      in that case (pyWorkPage.$pxReferencedPropertiesList will have information related to configured pageList 
      and how it is related to pageGroup and from where the data is expected to fetch)
      ex: pyWorkPage.$pxReferencedPropertiesList = {".Ref_Prop_1": "SourceReferencePage.pyWorkParty"} // pyWorkParty is pageGroup
      and bigDataObject.SourceReferencePage.pyWorkParty = {"group-1": {// group data } } 
      
      In this case, as we don't handle pageGroup merging yet, directly accept what is received from the server and update the clientDataProvider.
      */
      var currentPage = currentDataProvider[pageName];
      var references = currentPage["$pxReferencedPropertiesList"];
      var referencedProperties = Object.keys(references || {});

      referencedProperties.forEach(function (item) {
        if (item && item !== "$value") {
          var pageSize = "$pxPageSize$" + item.split(".")[1];
          if (pageSize in currentPage && references[item] && references[item].indexOf(".") !== 0) {  
            var topLevelPagePropertyName = references[item].split(".")[0];
            _mergeObjects(currentDataProvider[topLevelPagePropertyName], bigDataObject[topLevelPagePropertyName], true, null, true);
          }
        }
      });
      /* INC-220532 - ENDS */
			_mergeObjects(currentDataProvider[pageName], pageObject, true);
    }
	};

	var _mergeChangeTrackerOnToContextTree = function() {
		// Merge CT and big data only in case of online.
		if (!pega.u.d.ServerProxy.isDestinationLocal()) {
			var changeTrackerMap = pega.ui.ChangeTrackerMap;
			var clientDataProvider = pega.ui.ClientDataProvider;

			// No ChangeTracker found, quit
			if (!changeTrackerMap || !changeTrackerMap.getTracker())
				return;

			// No ClientDataProvider found, quit (Non-Template case)
			if (!clientDataProvider || !clientDataProvider.getTracker())
				return;

			/* BUG-307438: Since we don't change the thread of the changetracker we need to read the correct threadname from the clientdataprovider that is always pointing to the correct thread */
			var threadName = clientDataProvider.getTracker().threadName;
			var clientDataProviderObject = clientDataProvider.getTrackerByThread(threadName);
			var changeTrackerObject = changeTrackerMap.getTrackerByThread(threadName);

			// Non-Template case
			if (!clientDataProviderObject || !changeTrackerObject || !clientDataProviderObject.trackedPropertiesList)
				return;

			/* BUG-311762: Only menus use change tracker data (Others are actions and expressions which do not depend on ClientDataProvider) */
			var clonedCT = {};
			for (var prop in changeTrackerObject.trackedPropertiesList) {
				if (changeTrackerObject.trackedPropertiesList.hasOwnProperty(prop)) {
					if (prop.startsWith("pyNavigation") || prop == "pxRequestor") {
						clonedCT[prop] = _cloneObject(changeTrackerObject.trackedPropertiesList[prop]);
					}
				}
			}

			_mergeObjects(clientDataProviderObject.trackedPropertiesList, clonedCT, true, true);

			//publish AfterChangeTrackerDataMerged event which triggers expression evaluation on changed properties
			pega.ui.EventsEmitter.publishSync("AfterChangeTrackerDataMerged");

		}

	};

	var _mergeSectionStore = function(sectionsMap) {

        /*
        if (!window["PEGA_METADATA_STORE"])
            window["PEGA_METADATA_STORE"] = {};
        if (!window["PEGA_METADATA_STORE"]["SECTION"])
            window["PEGA_METADATA_STORE"]["SECTION"] = {};
        */
		var sectionStore = pega.ui.ClientDataProvider.getMetadataStoreByType("SECTION");

		// Collate
		for (var key in sectionsMap) {
			//window["PEGA_METADATA_STORE"]["SECTION"][key] = sectionsMap[key];
			sectionStore[key] = sectionsMap[key];
		}
	};

	var _getClientDataProvider = function(thread) {
		var source;
		var nonHC = pega.u.d.ServerProxy.isDestinationRemote();
		var ClientCache;

		// ClientDataProvider
		if (pega.ctx.isUITemplatized && nonHC)
			ClientCache = pega.ui.ClientDataProvider;
		// ChangeTracker
		else
			ClientCache = pega.ui.ChangeTrackerMap;

		// TODO: remove null check
		if (!ClientCache)
			return;

		if (thread)
			source = ClientCache.getTrackerByThread(thread);
		else
			source = ClientCache.getTracker();

		return source;
	};

	var _getCurrentContext = function() {
		return pega.ui.TemplateEngine.ContextObject;
	};

	var _resolveDataTokens = function(tokenString) {
		tokenString = tokenString.replace(/\$NT\$(.*?)\$NT\$/g, function(original, token) {
			var value = pega.ui.TemplateEngine.getCurrentContext().getPropertyValue(token);
			return value;
		});

		return tokenString;
	};

    /*
    var _purgeAlienData = function(source) {

        for (var property in source) {
            if (source.hasOwnProperty(property)) {
                var sourceValue = source[property];
                // Check if object contains an alien property and delete
                if (_alienDataElementsList.indexOf(property) != -1) {
                    delete source[property];
                    continue;
                }
                // Primitive type
                if (typeof sourceValue == 'object') {
                    _purgeAlienData(source[property]);
                }
            }
        }
    };
    */

	// Convert . notation to object reference
	var _index = function(obj, i) {
		if (obj) {
			if (/^'.*'$/.test(i)) {
				i = i.substring(1, i.length - 1);
			}
			return obj[i];
		}
	};

	// Convert pega notation to dot notation
	var _convertToDotNotation = function(reference) {
		if (!reference)
			return "";

		return reference.replace(/\(([^)]+)\)/g, function(a, b) {
			if (!isNaN(b)) {
				b--;
			}
			return "." + b;
		});
	};

    /*
        Removes the given page from context tree
        page -> (String) page to be deleted e.g. A.B.C.d
    */
	var _invalidateDataSource = function(page) {
		var isHCOffline = pega.u.d.ServerProxy.isDestinationLocal();

		var tracker = pega.ui.ClientDataProvider.getTracker();
		if (isHCOffline || !page || !tracker)
			return;

		page = _convertToDotNotation(page);

		var topLevel = page.indexOf(".") == -1;

		var lastDot = page.lastIndexOf(".");
		var pageLength = page.length;
		var property = page.substr(lastDot + 1, pageLength - 1); // d
		var propertyReference = page.substr(0, page.lastIndexOf(".")); // A.B.C

		var clientDataProviderObject = tracker.trackedPropertiesList;

		var obj = propertyReference.split(".").reduce(_index, clientDataProviderObject); // A[B][C]
		if (obj && !topLevel)
			delete obj[property]; // delete A[B][C][d]
		else if (lastDot == -1) // No dot - top level
			delete clientDataProviderObject[page];
        /*
        // Delete from ChangeTracker also
        var changeTrackerObject = pega.ui.ChangeTrackerMap.getTracker().trackedPropertiesList;
        var obj = propertyReference.split(".").reduce(_index, changeTrackerObject); // A[B][C]
        if (obj && !topLevel)
            delete obj[property]; // delete A[B][C][d]
        else if (lastDot == -1) // No dot - top level
            delete changeTrackerObject[page];
        */
	};

	// @Only full ref is supported
	var _getValueFromContextTree = function(propertyReference) {
		var tracker = pega.ui.ClientDataProvider.getTracker();
		if (!tracker)
			return;
		var clientDataProviderObject = tracker.trackedPropertiesList;
		var value = propertyReference.split(".").reduce(_index, clientDataProviderObject);
		return value;
	};

	// CT
	var _getValueFromChangeTracker = function(propertyReference, thread) {
		propertyReference = _convertToDotNotation(propertyReference);
		var tracker;
		if (!thread)
			tracker = pega.ui.ChangeTrackerMap.getTracker();
		else
			tracker = pega.ui.ChangeTrackerMap.getTrackerByThread(thread);

		if (!tracker)
			return;

		var changeTrackerObject = tracker.trackedPropertiesList;
		var value = propertyReference.split(".").reduce(_index, changeTrackerObject);
		return value;
	};

	// @pageList -> Array
	var _hasNonTemplates = function(pageList) {
		for (var i = 0; i < pageList.length; i++) {
			var page = pageList[i];
			for (var property in page) {
				if (property == "$pxNonTemplates") {
					return true;
				}
			}
		}
	};

	var _setPrimaryContext = function(context) {
		_primaryContext = context;
	}
  

  /**
     * All exposed APIs
     */
	var templateInterface = {
		execute: _execute,
		registerHelper: _registerHelper,
		getHelper: _getHelper,
		register: _register,
		cloneMetadata: _cloneMetadata,
		renderChildren: _renderChildren,
		getRefreshWhenAttributes: _getRefreshWhenAttributes,
		removeForceReloadTemplates: isUnitTesting ? _removeForceReloadTemplates : undefined,
		getTemplates: _getTemplates,
		getMetadataTree: _getMetadataTree,
		setMetadataTree: _setMetadataTree,
		addMetadataTree: _addMetadataTree,
		purgeMetadataTree: _purgeMetadataTree,
		renderUI: _renderUI,
		renderAsyncStreams: _renderAsyncStreams,
		renderAsyncStream: _renderAsyncStream,
		newAsyncStream: _newAsyncStream,
		getDefaults: _getDefaults,
		addRepeatingCompCTProps: _addRepeatingCompCTProps,
		createRepeatingDepth: _newRepeatingDepth,
		pushRepeatingDepth: _pushRepeatingDepth,
		popRepeatingDepth: _popRepeatingDepth,
		peekRepeatingDepth: _peekRepeatingDepth,
		getRepeatingDepthForExpression: _getRepeatingDepthForExpression,
		mergeBigData: _mergeBigData,
		mergeSectionStore: _mergeSectionStore,
		processMetadata: _processMetadata,
		getClientDataProvider: _getClientDataProvider,
		buildTemplateTree: _buildTemplateTree,
		getCurrentContext: _getCurrentContext,
		processMetadataPerComponent: _processMetadataPerComponent,
		resolveDataTokens: _resolveDataTokens,
		invalidateDataSource: _invalidateDataSource,
		getValueFromContextTree: _getValueFromContextTree,
		getValueFromChangeTracker: _getValueFromChangeTracker,
		hasNonTemplates: _hasNonTemplates,
		mergeObjects: _mergeObjects,
		CONSTANTS: _CONSTANTS,
		isAllEmpty: isUnitTesting ? _isAllEmpty : undefined,
		isAllEmptyWithMeta: isUnitTesting ? _isAllEmptyWithMeta : undefined,
		isSparseArray: isUnitTesting ? _isParseArray : undefined,
		isObjectEmpty: isUnitTesting ? _isObjectEmpty : undefined,
		isSingleProperty: isUnitTesting ? _isSingleProperty : undefined,
		isSubset: isUnitTesting ? _isSubset : undefined,
		isMetaObject: isUnitTesting ? _isMetaObject : undefined,
		pushtoArray: isUnitTesting ? _pushtoArray : undefined,
		updateMetadataCache: isUnitTesting ? _updateMetadataCache : undefined,
		cloneReferencedSection: isUnitTesting ? _cloneReferencedSection : undefined,
		processConstantsForTimeline: isUnitTesting ? _processConstantsForTimeline : undefined,
		lookupWhen: isUnitTesting ? _lookupWhen : undefined,
		lookupParamPage: isUnitTesting ? _lookupParamPage : undefined,
		lookupPrivilege: isUnitTesting ? _lookupPrivilege : undefined,
		getTruthValue: isUnitTesting ? _getTruthValue : undefined,
		lookupSubscriptionId: isUnitTesting ? _lookupSubscriptionId : undefined,
		lookupErrorId: isUnitTesting ? _lookupErrorId : undefined,
		lookupNonTemplate: isUnitTesting ? _lookupNonTemplate : undefined,
		index: isUnitTesting ? _index : undefined,
		convertToDotNotation: isUnitTesting ? _convertToDotNotation : undefined,
		processConstants: isUnitTesting ? _processConstants : undefined,
		processParamPage: isUnitTesting ? _processParamPage : undefined,
		callProcessWhens: isUnitTesting ? _callProcessWhens : undefined,
		processNonTemplates: isUnitTesting ? _processNonTemplates : undefined,
		processSubscriptionIds: isUnitTesting ? _processSubscriptionIds
			: undefined,
		processErrors: isUnitTesting ? _processErrors : undefined,
		processWhens: isUnitTesting ? _processWhens : undefined,
		callProcessErrors: isUnitTesting ? _callProcessErrors : undefined,
		mergeChangeTrackerOnToContextTree: isUnitTesting ? _mergeChangeTrackerOnToContextTree : undefined,
		cloneObject: isUnitTesting ? _cloneObject : undefined,
		getIndexedReference: isUnitTesting ? _getIndexedReference : undefined,
		setPrimaryContext: _setPrimaryContext,
		enableDataUpdate: _enableDataUpdate,
		disableDataUpdate: _disableDataUpdate
	};

	return templateInterface;
})();

// TODO: Dummy mocks; REMOVE
pega.ui.TemplateEngine.mergeDefaults = function(metadata) {
	return metadata;
};
pega.ui.TemplateEngine.addServerWhenTable = function(metadata) {

};
pega.ui.TemplateEngine.addRepeatingCompCTProps = function(metadata) {

};
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.TemplateEngine");

pega.ui.TemplateEngine.ContextObject = (function() {
	var isUnitTesting = pega.isUnitTesting;
	var _stack = [];
	var _stepObject = {};
	var changetracker;
	var changetrackerBackup;
	var clientData;
	var clientDataBackup;
	var topLevelContextData;
	var isHCOffline = false;
	var FIRST_PREDICATE = "'<FIRST>'";
	var LAST_PREDICATE = "'<LAST>'";
	var FIRST_PREDICATE_NQ = "<FIRST>";
	var LAST_PREDICATE_NQ = "<LAST>";
	var INDEX_SEPARATOR = "_";
	var LOCALIZED_HEAD = "$pxLocalized";
	var LINKED_PROPERTY = "$value";

	//written only for jsUnits purpose
	/* istanbul ignore next */
	var _setHCOffline = function() {
		isHCOffline = true
	}

	/* 
		US-324619: Change Tracker Support For Ajax Container in Offline
		TASK-895034 : With thread support in offline PIMC (Multiwebview as of this story US-324619), all the DataPages, pxThread, pxRequestor and OperatorID pages. These pages are common to all the thread will be present in STANDARD thread. 
    BUG-543290: added static pages used in Offline PMC
	*/
	var _isSharedPage = function(handle) {
    var standardPages = ['pxThread', 'pxRequestor', 'OperatorID', 'AccessGroup', 'Application', 'Org', 'OrgDivision', 'pxProcess'];
    var isStandard = standardPages.some(function(pageName) { return handle.startsWith(pageName) });
		return handle && (handle.startsWith("D_") || isStandard);
	};

	/*
    	These API's should be executed but thread is switched only when there is ajax container in PIMC offline application
		API to switch to proper clientData object which has the data.
	*/
	var checkAndSwitchToStandardThread = function(handle) {
		if (pega.mobile && pega.mobile.isMultiWebViewOfflinePegaMobileClient && pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal()) {
			var parentWindow = pega.mobile.support.getPortalWindow();
		} else {
			return;
		}

		/* Ajax Container and its scripts are loaded only in parent webview (hidden webview). So checking using parentWindow */
		if (parentWindow && parentWindow.pega.ctx.isMDC && pega.mobile.isMultiWebViewOfflinePegaMobileClient && _isSharedPage(handle)) {
			// Preserve the current clientData for restoring back
			if (clientData) {
				clientDataBackup = clientData;
			}

			if (changetracker) {
				changetrackerBackup = changetracker;
			}

			changetracker = parentWindow.pega.ui.TemplateEngine.getClientDataProvider("STANDARD");
			clientData = parentWindow.pega.ui.TemplateEngine.getClientDataProvider("STANDARD").trackedPropertiesList;
		}
	};

	var restoreToCurrentChangeTracker = function(handle) {
		if (pega.mobile && pega.mobile.isMultiWebViewOfflinePegaMobileClient && pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal()) {
			var parentWindow = pega.mobile.support.getPortalWindow();
		} else {
			return;
		}

		/* Ajax Container and its scripts are loaded only in parent webview (hidden webview). So checking using parentWindow */
		if (parentWindow && parentWindow.pega.ctx.isMDC && pega.mobile.isMultiWebViewOfflinePegaMobileClient && _isSharedPage(handle) && changetrackerBackup) {
			changetracker = changetrackerBackup;
			clientData = clientDataBackup;
		}
	}

	var _initTracker = function() {
		isHCOffline = pega.u.d.ServerProxy.isDestinationLocal();
		changetracker = pega.ui.TemplateEngine.getClientDataProvider();

		clientData = changetracker.trackedPropertiesList; // ContextTree || ChangeTracker
		topLevelContextData = pega.ui.ClientDataProvider.getTracker().trackedPropertiesList; // ContextTree

		if (_isObjectEmpty(_stepObject)) {
			_stepObject = clientData;
		}
	};

	var _getStepObject = function() {
		if (isHCOffline) {
			// In case of offline, context data always sits on top level
			return topLevelContextData;
		} else {
			return _stepObject;
		}
	};
	/* istanbul ignore next */
	var isRelativeReference = function(reference) {
		return reference.startsWith(".");
	};

	// Convert . notation to object reference
	var _index = function(obj, i) {
		if (obj) {
			if (i === FIRST_PREDICATE) {
				i = 0;
			}
			else if (i === LAST_PREDICATE) {
				i = (obj.length ? obj.length - 1 : 0);
			}
			else if (/^'.*'$/.test(i)) {
				i = i.substring(1, i.length - 1);
			}

			return obj[i];
		}
	};

	// Convert pega notation to dot notation
	var _convertToDotNotation = function(reference) {
		if (!reference)
			return "";

		return reference.replace(/\(([^)]+)\)/g, function(a, b) {
			if (!isNaN(b)) { // number - PL
				b--;
			} else if (/^\(.*\)$/.test(a)) { // (TypeA) - PG
				b = "'" + b + "'";
			}
			return "." + b;
		});
	};

	// Convert dot notation to pega notation
	var _convertToPegaNotation = function(reference) {
		if (!reference)
			return "";

		var referenceArray = reference.split(".");
		var pegaString = "";
		for (var i = 0; i < referenceArray.length; i++) {
			var token = referenceArray[i];

			if (!isNaN(parseInt(token, 10))) { // 2
				pegaString = pegaString.substring(0, pegaString.length - 1); // Remove previous .
				token++;
				pegaString += "(" + token + ").";
			} else if (/^'.*'$/.test(token)) { // enclosed in single quotes, e.g. .'TypeA'
				pegaString = pegaString.substring(0, pegaString.length - 1); // Remove previous .
				pegaString += "(" + token.substring(1, token.length - 1) + ")."; // (TypeA)
			} else {
				pegaString += token + ".";
			}
		}
		// Remove last .
		if (pegaString.lastIndexOf(".") === pegaString.length - 1)
			pegaString = pegaString.substring(0, pegaString.length - 1);

		return pegaString;
	};


    /*  *Escape sequence*
      i/p: "pyWorkPage.Features(9).CompanyImage(1)"
      o/p: "pyWorkPage.Features(9).CompanyImage[1]"
    */
	var _escapeParantheses = function(str) {
		var lastDotPos = str.lastIndexOf(".");
		var strBeforeDot = str.substring(0, lastDotPos);
		var strAfterDot = str.substring(lastDotPos); // CompanyImage(1)
		strAfterDot = strAfterDot.replace(/\(/, "[").replace(/\)/, "]"); // CompanyImage[1]

		return strBeforeDot + strAfterDot; // pyWorkPage.Features(9).CompanyImage[1]

	};
    /*  *Unescape sequence*
      i/p: "pyWorkPage.Features(9).CompanyImage[1]"
      o/p: "pyWorkPage.Features(9).CompanyImage(1)"
    */
	var _unescapeParantheses = function(str) {
		var lastDotPos = str.lastIndexOf(".");
		var strBeforeDot = str.substring(0, lastDotPos);
		var strAfterDot = str.substring(lastDotPos); // CompanyImage[1]
		strAfterDot = strAfterDot.replace(/\[/, "(").replace(/\]/, ")"); // CompanyImage(1)

		return strBeforeDot + strAfterDot; // pyWorkPage.Features(9).CompanyImage(1)
	};
	/* istanbul ignore next */
	var isOldSchoolLiteral = function(str) {
		/* 
		Rules
		1. If no dot literal
		2. If / literal
		*/

		if (str.indexOf(".") === -1 || str.indexOf("/") === -1)
			return true;
	};


	var _getAbsoluteContext = function(reference, lookupObj) {

		if (!lookupObj) {
			checkAndSwitchToStandardThread(reference);
			lookupObj = clientData;
			restoreToCurrentChangeTracker(reference);
		}

		var obj = reference.split(".").reduce(_index, lookupObj);
		return obj;
	};

	var _getPropertyValue = function(propertyReference, bLiteral, _localizationArgs, ignoreClientValue) {
		/*
			.property1
			property1
			Page1.property1
			.EmbeddedPage.property1
  
		  */
		if (pega.c && pega.c.actionSequencer && pega.c.actionSequencer.getValueFromPendingEventValues && !ignoreClientValue) {
			var _valFromPendingQueue = pega.c.actionSequencer.getValueFromPendingEventValues(pega.ui.TemplateEngine.getCurrentContext().getEntryHandle(propertyReference));
			if (_valFromPendingQueue != null) {
				return _valFromPendingQueue;
			}
		}
		if (bLiteral || !propertyReference)
			return propertyReference || "";

		// Save the original property
		var originalProperty = propertyReference;
		//var fullPropertyReference = propertyReference;

		// Enter only if not field name literal from localiztion
		if (!_localizationArgs || !_localizationArgs.isFieldNameLiteral) {
			propertyReference = _escapeParantheses(propertyReference);
			propertyReference = _convertToDotNotation(propertyReference); // Employees.pxResults(2) -> Employees.pxResults.1
			propertyReference = _unescapeParantheses(propertyReference);
		}

		if (propertyReference.indexOf(".") === -1) { // 2 -> property1 -> .property1
			propertyReference = "." + propertyReference;
		}

		var lookupObject;
		var fullPropertyReference = propertyReference;

		// Check if top reference
		if (propertyReference.startsWith("top.")) {						// top.name
			propertyReference = propertyReference.replace(/^top./, "");	// name

			if (_stack[0])
				lookupObject = _stack[0].contextObject;
			else
				lookupObject = {};
		}
		// Check if parent reference
		else if (propertyReference.startsWith("parent.")) {	// parent.parent.name
			var parentSplit = propertyReference.split("parent.");
			var parentCount = parentSplit.length - 1;					// 2
			propertyReference = parentSplit[parentCount];				// name

			// var stackObject = _stack[_stack.length-1-parentCount];
			/* BUG-413249: It can happen that stack[1] is A.B.C.D.E and stack[0] is A.B.C */
			var stackObject = _stack[_stack.length - 1];
			if (stackObject) {
				var topOfStack = stackObject.fullPropertyReference;
				var levels = topOfStack.split('.');
				var parentLevels = levels.slice(0, levels.length - parentCount);

				/* US-316142 : Incase of multi-webview PIMC application with ajax conatiner has multiple threads and share pages always loaded in STANDARD thread  */
				if ((pega.ui && pega.ui.hasAjaxContainer) && (_isMultiWebViewOfflinePIMC() || _isSingleWebViewOfflinePIMC()) && _isSharedPage(handle)) {
					lookupObject = parentLevels.reduce(_index, pega.ui.ClientDataProvider.getTrackerByThread("STANDARD").trackedPropertiesList);
				} else {
					lookupObject = parentLevels.reduce(_index, pega.ui.ClientDataProvider.getTracker().trackedPropertiesList);
				}
			} else {
				lookupObject = {};
			}
		}
		// Relative
		else if (propertyReference.startsWith(".")) {
			fullPropertyReference = _getReference() + propertyReference;
			checkAndSwitchToStandardThread(fullPropertyReference);
			lookupObject = _stepObject;
			propertyReference = propertyReference.replace(/^\./, "");
			restoreToCurrentChangeTracker(fullPropertyReference);
		}
		// Absolute
		else {
			checkAndSwitchToStandardThread(fullPropertyReference);
			lookupObject = clientData;
			restoreToCurrentChangeTracker(fullPropertyReference);
		}

		// Offline specific stuff
		if (isHCOffline) {
			fullPropertyReference = _convertToPegaNotation(fullPropertyReference);

			// Declare expressions
			if (pega.offline.declareexpressions)
				pega.offline.declareexpressions.fireExpression(fullPropertyReference);

			checkAndSwitchToStandardThread(fullPropertyReference);
			// AutoPopulate
			var populatedReference = pega.ui.AutopopulateSupport.resolveReference(fullPropertyReference, changetracker);
			// A populated ref exists
			if (populatedReference && populatedReference != fullPropertyReference) {
				// Got a new address, go for it
				return _getPropertyValue(populatedReference);
			}
			restoreToCurrentChangeTracker(fullPropertyReference);
		}

		// Literals need special processing
		var locIndex = propertyReference.indexOf(LOCALIZED_HEAD);	// propertyReference: "$pxLocalized.Search...$pyActionPrompt"

		// Check if literal
		if (locIndex !== -1 && _localizationArgs.isFieldNameLiteral) {
			var dotLiteral = propertyReference.split(LOCALIZED_HEAD)[1];	// .Search...$pyActionPrompt
			propertyReference = propertyReference.replace(dotLiteral, "");			// $pxLocalized
			var literal = dotLiteral.substr(1);										// Search...$pyActionPrompt
		}

		var propertyValue = propertyReference.split(".").reduce(_index, lookupObject);

		// Manually lookup localized string
		if (literal && propertyValue)
			propertyValue = propertyValue[literal];

		/*
		// Handle linked property
		if(propertyValue && typeof propertyValue == "object" && propertyValue[LINKED_PROPERTY] != undefined){  // Allows empty string 
          	propertyValue = propertyValue[LINKED_PROPERTY] || "";
        }
		*/

		// Handle linked property
		if (propertyValue && typeof propertyValue == "object") {
			// Allow empty string 
			if (propertyValue[LINKED_PROPERTY] === null || propertyValue[LINKED_PROPERTY] === "")
				propertyValue = "";
			else if (propertyValue[LINKED_PROPERTY] !== undefined)
				propertyValue = propertyValue[LINKED_PROPERTY];
		}

		// Override originalproperty for localized
		// TODO: Replace with !isOldSchoolLiteral()
		if (_localizationArgs || (isHCOffline && (originalProperty.indexOf(".") !== -1 && originalProperty.indexOf("/") === -1))) {
			originalProperty = "";
		}

		// If explicitly marked as null
		if (propertyValue === null || propertyValue === "")
			return "";
		// could be a constant
		else if (propertyValue === undefined)
			return originalProperty;
		else
			return propertyValue;
	};


    /**
     * _getLocalizedValue
     * @param  {String} propName  Allowed values: .Prop, .Page.Prop, .PageGroup(Index).Prop, Page.Prop, Page.PageList(1).Prop, Page.PageGroup(SubScript).Prop
	 * @param  {String} fieldName Ex: pyMessageLabel, pyCaption
     * @param  {String} fieldValue Ex: Female
     * @param  {String} multi-byte mode Ex: 0

     * @return {String} Localized value Ex: Dames
     */
	var _getLocalizedValue = function(propName, fieldName, mode) {
        /*
          .prop1    -> CC -> $pxLocalized -> $prop1         o/p: .$pxLocalized.$prop1$pyCaption$1
          Page1.P2.prop1 -> Page1 -> P2 -> $pxLocalized -> $prop1   o/p: Page1.P2.$pxLocalized.$prop1$pyCaption
          .page1.prop1 -> CC -> -> page1 -> $pxLocalized -> $prop1  o/p: .page1.$pxLocalized.$prop1$pyCaption
          FieldName -> CC -> $pxLocalized -> FieldName        o/p:.$pxLocalized.FieldName$pyCaption

        */

		if (!propName)
			return "";

		if (isHCOffline) {
			var bLiteral = true;
			// Check if property or constant
			if (isNaN(propName) && propName.indexOf(".") !== -1 && propName.indexOf(" ") === -1 && propName.indexOf("..") === -1) {
				bLiteral = false;
			}
			// Relative - make it absolute
			if (!bLiteral && propName.startsWith(".")) {
				propName = _getReference() + propName;
			}


			var value = _getPropertyValue(propName, bLiteral);
			if (typeof value != "string") {
				// something's wrong here, assign propName back
				value = propName;
			}
			// BUG-311832: Handling for parameterized fieldvalues
			if (value.indexOf('\t') !== -1 && value.indexOf('[') === -1) {
				value = value.replace('\t', '\\t');
				value = "\\t[" + fieldName + "]" + value;
			}
			return pega.clientTools.getLocalizedTextForString(fieldName, value);
		}

		var originalProperty = propName;
		var isFieldNameLiteral;

		// Mark literals
		// BUG-383173: Consider \\t also
		if (propName.indexOf(" ") !== -1 || (propName.indexOf("\t") !== -1) || !isNaN(parseFloat(propName)))
			isFieldNameLiteral = true;

		var dotPos = propName.lastIndexOf(".");
		if (dotPos > 0 && propName.substr(dotPos + 1) && !isFieldNameLiteral) { // something exists after .
			propName = propName.substr(0, dotPos) + ".$pxLocalized.$" + propName.substr(dotPos + 1); // 2 & 3
		} else if (dotPos === 0) { // 1
			propName = ".$pxLocalized.$" + propName.substr(1);
		} else { // 4
			propName = ".$pxLocalized." + propName;
			isFieldNameLiteral = true;
		}

		propName += "$" + fieldName;
		if (mode)
			propName += "$" + mode;

		// Additional args
		var localizationArgs = {
			isFieldNameLiteral: isFieldNameLiteral,
		};
    
    /*BUG-609823 : If there is a pagename with propname that will return an object. Expect only string*/
		var propValue= _getPropertyValue(propName, null, localizationArgs) || _getPropertyValue(originalProperty) /*|| originalProperty*/;
    if (typeof propValue != "string") {
				// something's wrong here, assign propName back
				propValue = originalProperty;
			}
    return propValue;
	};

	var _getServerWhenResult = function(stepObject, whenId) {
		if (!stepObject.$pxWhens) {
			return;
		}
		var uniqueId = whenId.uniqueId ? whenId.uniqueId : whenId;
		return _getTruthValue(stepObject.$pxWhens[uniqueId]);
	};

	var _getWhenResult = function(whenId) {
		var stepObject = _getStepObject();

		if (isHCOffline && whenId.className && whenId.ruleName) {
			var whenClass = whenId.className;
			var whenName = whenId.ruleName;
			if (!pega.ui.When.isServerRule(whenName)) {
				try {
					return pega.ui.When.evaluate(whenName, whenClass);
				} catch (error) {
					if (pega.ui.When.canUseFallbackAfterError(error)) {
						var serverWhenResult = _getServerWhenResult(stepObject, whenId);
						var msg = "Evaluation of the When rule '" + whenClass + "!" + whenName + "' is not supported on the client. " +
							"Using precalculated server value '" + serverWhenResult + "'. [" + error + "]";
						if (pega.ui.When.isMissingRuleError(error)) {
							console.info(msg);
						} else {
							console.warn(msg);
						}
						return serverWhenResult;
					} else {
						throw error;
					}
				}
			}
		}
		return _getServerWhenResult(stepObject, whenId);
	};

	var _getSubscriptionId = function(subscriptionId) {
		var stepObject = _getStepObject();

		if (!stepObject.$pxSubscriptionId)
			return;

		return stepObject.$pxSubscriptionId[subscriptionId];
	};

	var _getErrorId = function(errorId) {
		var stepObject = _getStepObject();

		if (!stepObject.$pxErrors)
			return;

		return stepObject.$pxErrors[errorId];
	};

	var _getParamPage = function(pageId) {
		var stepObject = _getStepObject();

		if (!stepObject.$pxParamPage)
			return;

		return stepObject.$pxParamPage[pageId];
	};

	var _getPrivilegeResult = function(privilegeId) {
		var stepObject = _getStepObject();

		if (!stepObject.$pxPrivileges)
			return;

		return _getTruthValue(stepObject.$pxPrivileges[privilegeId]);
	};

	var _getNonTemplateId = function(nonTemplateId) {
		var stepObject = _getStepObject();

		if (!stepObject.$pxNonTemplates)
			return;

		return stepObject.$pxNonTemplates[nonTemplateId];
	};

    /*
  var _getParamDPName = function(dataPageId) {
    var stepObject = _getStepObject();

    if(!stepObject.$pxDatapages)
      return;

        return stepObject.$pxDatapages[dataPageId];
    };
  */

	var _getDataSource = function(dataSourceId) {
		var stepObject = _getStepObject();

		if (!stepObject.$pxDataSource)
			return;

		return stepObject.$pxDataSource[dataSourceId];
	};

	var _replaceActionStringTokens = function(actionString) {
		var regExp, context, contextPath, primaryPage;
		if (actionString) {
			regExp = new RegExp(/(\$CTX\$)|(\$PRIMARY\$)|(\$PARENT\d*\$)|(\$TOP\$)/gi);
			context = pega.ui.TemplateEngine.getCurrentContext();
			contextPath = context.getEntryHandle();
			primaryPage = pega.u.d.primaryPageName;
			actionString = actionString.replace(regExp, function(match, p1, p2, p3, p4, offset, actonStr) {
				var ctx = p1 || p2 || p3 || p4;
				var dataPage;
				switch (true) {
					case /\$PRIMARY\$/.test(ctx):
						dataPage = primaryPage;
						break;
					case /\$CTX\$/.test(ctx):
						dataPage = contextPath;
						break;
					case /\$TOP\$/.test(ctx):
						dataPage = (contextPath && contextPath.indexOf(".") !== -1) ?
							contextPath.substring(0, contextPath.indexOf(".")) : contextPath;
						break;
					case /\$PARENT\d*\$/.test(ctx):
						if (contextPath && contextPath.lastIndexOf(".") !== -1) {
							var contextPathTemp = contextPath;
							var index = parseInt(ctx.replace("$PARENT", "").replace("$", ""), 10);
							for (var i = 0; i < index; i++) {
								if (contextPathTemp.lastIndexOf(".") !== -1) {
									contextPathTemp = contextPathTemp.substring(0, contextPathTemp.lastIndexOf("."));
								} else {
									break;
								}
							}
							dataPage = contextPathTemp;
						} else {
							dataPage = contextPath;
						}
						break;
				}
				return dataPage;
			});
		}
		return actionString;
	};

	var _getActionString = function(actionId) {
		var stepObject = _getStepObject();

		if (!stepObject.$pxActionString)
			return "";

		var actionString = stepObject.$pxActionString[actionId];
		if (actionString instanceof Array)
			actionString = actionString.shift();
		// Replace tokens for HC
		if (isHCOffline)
			actionString = _replaceActionStringTokens(actionString);

		return actionString || "";
	};
  
  var _getFieldValParam = function(labelVal) {
    var stepObject = _getStepObject();
    if (!stepObject[LOCALIZED_HEAD])
      return "";
    var resolvedVal = stepObject[LOCALIZED_HEAD][labelVal + "$pyCaption"];
    return resolvedVal || "";
  };
  
	var _getDynamicSectionId = function(pxReferencedId) {
		var stepObject = _getStepObject();

		var pxSections = stepObject.$pxSections;
		if (!pxSections || !pxSections[pxReferencedId])
			return;

		return pxSections[pxReferencedId]["pxReferencedId"];
	};

	var _getSectionReadOnlyFlag = function(pxReferencedId) {
		var stepObject = _getStepObject();

		var pxSections = stepObject.$pxSections;
		if (!pxSections || !pxSections[pxReferencedId])
			return;

		return pxSections[pxReferencedId]["pxReadOnly"];
	};

	var _getSectionUniqueID = function(pxReferencedId) {
		var stepObject = _getStepObject();

		var pxSections = stepObject.$pxSections;
		if (!pxSections || !pxSections[pxReferencedId])
			return;

		return pxSections[pxReferencedId]["sectionUniqueID"];
	};

	var _getSectionGadgetInfo = function(pxReferencedId) {
		var stepObject = _getStepObject();

		var pxSections = stepObject.$pxSections;
		if (!pxSections || !pxSections[pxReferencedId])
			return;

		return pxSections[pxReferencedId]["outerGadget"];
	};

	var _getSectionParameters = function(pxReferencedId) {
		var stepObject = _getStepObject();

		var pxSections = stepObject.$pxSections;
		if (!pxSections || !pxSections[pxReferencedId])
			return;

		return pxSections[pxReferencedId]["secParams"];
	}

	var _getDynamicValue = function(dynamicValueReference) {
		var stepObject = _getStepObject();

		var pxDynamicValues = stepObject.$pxDynamicValues;
		if (!pxDynamicValues || !pxDynamicValues[dynamicValueReference])
			return dynamicValueReference;

		return pxDynamicValues[dynamicValueReference];
	};

	var _getSectionInstanceId = function(pxReferencedId) {
		var stepObject = _getStepObject();

		var pxSections = stepObject.$pxSections;
		if (!pxSections || !pxSections[pxReferencedId])
			return;

		return pxSections[pxReferencedId]["instanceId"];
	};

	var _getSectionParamDP = function(pxReferencedId) {
		var stepObject = _getStepObject();

		var pxSections = stepObject.$pxSections;
		if (!pxSections || !pxSections[pxReferencedId])
			return;

		return pxSections[pxReferencedId]["paramDP"];
	};

	var _isSectionReadOnly = function() {
		return _peek()["pxReadOnly"] == "true";
	};

	var _getReferencedProperty = function(property, contextAware) {
		var referencedPropertiesList;
		if (contextAware) {
			referencedPropertiesList = _getStepObject()["$pxReferencedPropertiesList"];
		} else {
			referencedPropertiesList = clientData["$pxReferencedPropertiesList"];
		}
    
		if (referencedPropertiesList)
			return referencedPropertiesList[property];
	};

	//SECURE PROPERTY
	var _isSecuredProperty = function(propertyName) {
		if (!propertyName) {
			return false;
		}
		if (propertyName.indexOf(".") === -1) {
			propertyName = "." + propertyName;
		}
		var propArray = propertyName.split(".");
		propArray[propArray.length - 1] = "$pxMasked." + propArray[propArray.length - 1];
		propertyName = propArray.join(".");
		var value = _getPropertyValue(propertyName);
		if (value == 1) {
			return true;
		} else {
			return false;
		}
	};

	var _getID = function(propName, controlName, genNonUniqueId) {
		if ((!genNonUniqueId && (bEnableUniqueId === "true" || bEnableUniqueId === true)) || controlName === "pxCheckbox" || controlName === "pxRadioButtons") {
			var threadPrefix = "";
			var threadName = "";
			var crc32Hash = "";
			threadName = pega.u.d.getThreadName();
			if (threadName.indexOf("/") > 0) {
				threadPrefix = threadName.substring(threadName.indexOf("/") + 1);
			}

			if (!propName) {
				propName = _getReference();
			}
			if (propName.startsWith(".")) {
				propName = _getReference() + propName;
			}
			crc32Hash = CRC32.str(threadPrefix + propName);
			return pega.u.d.getCRC32LpadHash((crc32Hash >>> 0).toString(16), 8, '0');
		} else {
			var propNameForID = "";
			if (!controlName) {
				return _getEntryHandle(propName);
			}
			if (controlName === "pxMultiSelect") {
				propNameForID = propName.replace(/[^\w]/gi, '');
			} else {
				propNameForID = propName.substring(propName.lastIndexOf(".") + 1);
			}

			var repeatingParentInfo = this.getRepeatingParentInfo();
			if (repeatingParentInfo.component === "RepeatingDynamicLayout") {
				propNameForID += "_rdi_" + repeatingParentInfo.index;
			}
			return propNameForID;
		}
	};

	var _getEntryHandle = function(propName) {
		if (!propName) {
			return _getReference();
		}
		if (propName.startsWith(".")) {
			propName = _getReference() + propName;
		}
    /* US-344786 : Handling referenced properties as well*/
    var referencedPropName=_getReferencedProperty(propName);
    propName = referencedPropName?referencedPropName:propName;

		return pega.u.property.toHandle(_resolvePredicates(propName));
	};

	var _resolvePredicates = function(property) {
		var dotisedProperty = _convertToDotNotation(property);
		var firstPos = dotisedProperty.indexOf(FIRST_PREDICATE);
		var lastPos = dotisedProperty.indexOf(LAST_PREDICATE);
		var predicatePos = (lastPos !== -1) ? lastPos : (firstPos !== -1) ? firstPos : -1;

		if (predicatePos !== -1) {
			var predicateParent = dotisedProperty.substring(0, predicatePos - 1);
			var lookupObj = clientData;
			var obj = predicateParent.split(".").reduce(_index, lookupObj);
			var length = (obj && obj.length || 0);
			property = property.replace(FIRST_PREDICATE_NQ, 1);
			property = property.replace(LAST_PREDICATE_NQ, length); // 1-based
		}

        /* In case there is a chained last and first predicate, call _resolvePredicates recursively 
         * Ex: pxStageHistory(<LAST>).pxProcesses(<FIRST>).pyAgedInstances */
		dotisedProperty = _convertToDotNotation(property);
		if (dotisedProperty.indexOf(FIRST_PREDICATE) !== -1 || dotisedProperty.indexOf(LAST_PREDICATE) !== -1) {
			/* Not all predicate resolved, call recursively */
			return _resolvePredicates(property);
		} else {
			/* All predicates resolved */
			return property;
		}
	};

	var _getReference = function() {
		var reference = _peek().fullPropertyReference;
		return _convertToPegaNotation(reference);
	};

	var _resolvePage = function(pageReference) {
		if (isHCOffline && typeof pageReference === 'string' &&
			pega.ui.ParametrizedDPUtils.isParametrizedDataPage(pageReference)) {
			var dot_index = pageReference.indexOf(".");
			var listProp;
			if (dot_index !== -1) {
				listProp = pageReference.substring(dot_index);
				pageReference = pageReference.substring(0, dot_index);
			}
			//pageReference = pega.ui.ParametrizedDPUtils.createDPInstance(pageReference, null);
			pageReference = pega.ui.ClientCache.find(pageReference).getName();

			if (listProp) {
				pageReference = pageReference + listProp;
			}
		}
		return pageReference;
	};

    /*
      Pushes the given primary page and read only status to the stack by creating an entry
      pxReadonly -> (String) "true" | "false"
      Respects readOnly flag on section, if any

    */
	var _push = function(pageReference, pxReadOnly, extraInfo) {
		var obj;

		pageReference = _resolvePage(pageReference);
		// If no page reference, copy from previous
		if (!pageReference && pxReadOnly)
			pageReference = _peek().fullPropertyReference;
		// If no pxReadonly, copy from previous
		if ((pageReference || !isNaN(parseInt(pageReference, 10))) && !pxReadOnly)
			pxReadOnly = _peek().pxReadOnly;

		if (!isNaN(parseInt(pageReference, 10))) {
			pageReference = "." + pageReference;
		} else {
			pageReference = _convertToDotNotation(pageReference);
		}

		if (pageReference.startsWith(".")) {
			if (_isEmpty()) {
				throw "InvalidReference: QueueEmpty";
			}

			obj = _getAbsoluteContext(pageReference.substring(1), _peek().contextObject); // dot-less
			// Calc full reference
			pageReference = _peek().fullPropertyReference + pageReference;

		} else {
			obj = _getAbsoluteContext(pageReference);
		}

		// row
		if (!extraInfo)
			extraInfo = _peek().extraInfo;

		// extract numeric subscripts

		_stack.push({
			fullPropertyReference: pageReference,
			contextObject: obj || {},
			pxReadOnly: pxReadOnly,
			extraInfo: extraInfo
		});

		// Save the current poinrer
		_stepObject = obj || {};
	};

	// Pushes adhoc  context to stack, say a reloaded section happens to be part of RDL row
	var _pushAdhocContext = function(vSectionRef) {
		var currentContext = pega.ui.TemplateEngine.getCurrentContext();
		/*BUG-342360 : Handle defer loaded DL inside readonly Parent Context*/
		if (vSectionRef && vSectionRef.nodeType === 1 && vSectionRef.hasAttribute("data-deferinvoke")) {
			var sectionNode = $(vSectionRef).closest("div[node_name]")[0];
			/*BUG-384940- Added a nullcheck to see if a parent section exists. Ex: screen-layout */
			if (sectionNode) {
				var isSectionReadOnly = sectionNode.getAttribute("readonly");
				if (isSectionReadOnly === "true") {
					currentContext.push(undefined, "true");
					return true;
				}
			}
		}

		// Push readonly true for Timeline descendants
		var isTimelineDescendant = $(vSectionRef).closest(".vis-item")[0];
		if (isTimelineDescendant) {
			currentContext.push(undefined, "true");
			return true;
		}

		// var baseRef = $(vSectionRef).closest("[data-repeat-source] > [base_ref]").attr("base_ref"); 
		var baseRef;
		var nearestRDLRow = $(vSectionRef).closest("[data-repeat-source] > [base_ref]")[0];
		if (nearestRDLRow) {
			/* BUG-327448: base_ref attribute might contain relative base reference */
			baseRef = pega.u.d.getBaseRef(nearestRDLRow) || nearestRDLRow.getAttribute("base_ref");
		}

		if (!baseRef)
			return;

		// Ex: D_GetShowcaseItems.pxResults(5) -> D_GetShowcaseItems.pxResults.4
		baseRef = _convertToDotNotation(baseRef);
		var repeatInfo = {
			component: "RepeatingDynamicLayout",
		};

		// Push RDL context
		currentContext.push(baseRef, undefined, repeatInfo);
		return true;
	};

	var _getRepeatingParentInfo = function() {
		var fullPropertyReference = _peek()["fullPropertyReference"] || "";

		var regex = /(\.[\d+]+)/g;
		var matches = fullPropertyReference.match(regex);
		var indexString = "";
		if (matches) {
			for (var i = 0; i < matches.length; i++) {
				indexString = indexString + INDEX_SEPARATOR + (parseInt(matches[i].substr(1), 10) + 1);	// 1-based index
			}
		}
		indexString = indexString.substr(1);
		var extraInfo = _peek()["extraInfo"];
		if (extraInfo) {
			extraInfo.index = indexString;
			return extraInfo;
		}
		else {
			return {};
		}
	};

	var _pushSectionReferenceId = function(sectionReferenceId) {
		// Get context object
		_peek()["pxReferencedId"] = sectionReferenceId;
	};
    /*
    var _popSectionReferenceId = function(sectionReferenceId) {
      // Get context object
      _peek()["pxReferencedId"] = null;
    };
    */

	var _pop = function() {
		_stack.pop();
		if (!_isEmpty())
			_stepObject = _peek().contextObject;
		else
			_stepObject = {};
	};

	var _peek = function() {
		return _stack[_stack.length - 1] || {};
	};

	// Tells if the queue is empty
	var _isEmpty = function() {
		return _getSize() === 0;
	};

	var _getSize = function() {
		return _stack.length;
	};

	var _getTruthValue = function(reference) {
		if (reference instanceof Array)
			return reference;
		else
			return !!reference;
	};

	var _isObjectEmpty = function(obj) {
		if (!obj)
			return;
		if (typeof obj == "object")
			return (Object.keys(obj).length === 0);
	};

	return {
		push: _push,
		pop: _pop,

		isEmpty: _isEmpty,
		getSize: _getSize,

		getPropertyValue: _getPropertyValue,
		getLocalizedValue: _getLocalizedValue,
		getWhenResult: _getWhenResult,
		getPrivilegeResult: _getPrivilegeResult,
		getSubscriptionId: _getSubscriptionId,
		getErrorId: _getErrorId,
		getNonTemplateId: _getNonTemplateId,
		getDynamicSectionId: _getDynamicSectionId,
		getSectionReadOnlyFlag: _getSectionReadOnlyFlag,
		getSectionUniqueID: _getSectionUniqueID,
		getSectionGadgetInfo: _getSectionGadgetInfo,
		getSectionParameters: _getSectionParameters,
		getSectionInstanceId: _getSectionInstanceId,
		isSectionReadOnly: _isSectionReadOnly,
		getDataSource: _getDataSource,
		getActionString: _getActionString,
    getFieldValParam : _getFieldValParam,
		getDynamicValue: _getDynamicValue,
		initTracker: _initTracker,
		getEntryHandle: _getEntryHandle,
		getID: _getID,
		getReference: _getReference,
		replaceActionStringTokens: _replaceActionStringTokens,
		pushSectionReferenceId: _pushSectionReferenceId,
		isSecuredProperty: _isSecuredProperty,
		getReferencedProperty: _getReferencedProperty,
		getRepeatingParentInfo: _getRepeatingParentInfo,
		_stack: _stack,
		getParamPage: _getParamPage,
		getSectionParamDP: _getSectionParamDP,
		pushAdhocContext: _pushAdhocContext,
		resolvePredicates: _resolvePredicates,
		getStepObject: isUnitTesting ? _getStepObject : undefined,
		resolvePage: isUnitTesting ? _resolvePage : undefined,
		setHCOffline: isUnitTesting ? _setHCOffline : undefined,
		index: isUnitTesting ? _index : undefined
	};
})();

// Polyfill for startsWith (<=IE11)
if (!String.prototype.startsWith) {
	String.prototype.startsWith = function(searchString, position) {
		if (typeof searchString === 'undefined') {
			return false;
		}
		position = position || 0;
		return this.substr(position, searchString.length) === searchString;
	};
}

// EOF
//static-content-hash-trigger-GCC
var $pNamespace = pega.namespace;
$pNamespace("pega.ui");
// The editor is a singleton class which returns its public methods.
pega.ui.composer = (function() {
  /////////////////////////////////////////////////////////////////////////////////
  //                              CONSTANTS                                      //
  /////////////////////////////////////////////////////////////////////////////////
  var ANIMATION_DURATION = 500;
  var STATES = {
    INACTIVE: "inactive",
    LOADING: "loading",
    SUSPENDED: "suspended",
    READY: "ready",
    TRANSITIONING: "transitioning"
  };

  /////////////////////////////////////////////////////////////////////////////////
  //                              GLOBALS                                        //
  /////////////////////////////////////////////////////////////////////////////////
  /* -- PRIVATE GLOBALS -- */
  var _ignoreNextServerCall = false; // Flag for when to ignore setting Live Composer settings
  var _currentComposerWindow; // Current top level composer window
  var _deviceOutline //Element that contains innerPortalFrame
  var _innerPortalFrame; // Current preview window with embedded portal
  var _previousPortalURL; // Previous url for portal to display
  var _screenLayoutElement; // Top level reference to the screen layout div
  var _focusedElement = null; // Focused section
  var _runtimeEditor = null; //editor for templated sections at runtime
  var _loadingIndicator;
  var _propertyPanelPgRef; //this is used for correct context for submitting cells on apply and save
  var _isInUIMode = false; //Used for showing runtime editing pens
  var _rehighlightTimeout; //Used as a holder for the timeout of reHighlight to optimizes highlighting to prevent unnessesary logic to run for highlighting when refreshes occur
  // Panel variables
  var _layoutEditorPanel; // Layout editor panel in Pega Express
  var _gridLayoutEditorPanel; // Layout editor panel for grid in Pega Express
  var _propertyPanel; // Property panel in Pega Express appearing in side panel for fields edited in express
  var _gridPropertyPanel; // Property panel in Pega Express appearing in side panel for grids in express
  var _addPanel; // Add panel (fields, sections, etc) for layout editor
  var _addPanelForGrid;
  var _uiDesignTopPanel; 
  var _pagesPanel;
  var _addViewSelectedRowPosition; // Add view panel with field group or data ref need to show overlay in the selected row
  var _themePropertyPanel; // Property panel appearing in field side panel for field's theme formats edited in express

  // Tree variable
  var _sectionTreeOverlay = null;

  /* -- PUBLIC GLOBALS -- */
  var publicAPI = {};
  var state = STATES.INACTIVE;
  publicAPI.isTemplateRuntimeEditorEnabled = false; //feature toggle set in pzLiveComposer Section

  /////////////////////////////////////////////////////////////////////////////////
  //                              PRIVATE FUNCTIONS                              //
  /////////////////////////////////////////////////////////////////////////////////

  /**
     * Handles the animation effects for showing the composer bar.
     *
     * @param callback - Function to run when animation of the composer bar is complete
     */
  function _show(callback) {
    _screenLayoutElement.addClass("fade-final-state");
    _screenLayoutElement.addClass("slide-final-state");
    _postLiveComposerSettings(true);
    setTimeout(callback, 1000);
  }

  /**
     * Hides the composer bar.
     *
     * @param callback - Function to run when animation is complete
     */
  function _hide(callback) {
    _screenLayoutElement.addClass("slide-transition");
    _screenLayoutElement.addClass("fade-final-state");
    _screenLayoutElement.removeClass("slide-final-state");
    _postLiveComposerSettings(false);

    _gridLayoutEditorPanel.hide();
    _layoutEditorPanel.hide();
    _uiDesignTopPanel.hide();

    setTimeout(callback, 1000);
  }

  /**
     * Initializes the panel elements
     */
  function _initializePanels() {
    // Layout Editor
    _initializeLayoutEditor();

    // GridLayout Editor
    _initializeGridLayoutEditor();

    // Property Panel
    var propertyPanelOptions = {};
    propertyPanelOptions.preHide = function() {
      //need to refresh the layout edit when the property panel is closed since
      //there could be changes that need to be reflected in the layout editor
      _reHighlightElement(false);
      //Clear the reloadStatus that is set when container is dirty. gSectionReloadedin in current context is set to false.
      pega.u.d.clearReloadedStatus();
    }

    // BUG-404833: Ensure that the first layout within the property panel layout group is always active 
    propertyPanelOptions.preShow = function() {    
      // Obtain the layout group (fall out if there is not one, i.e., in simple panels)
      var layoutGroup = _propertyPanel.getElement().querySelector(".content-layout-group");
      if(layoutGroup) {
        // Obtain the active header
        var activeHeader = LayoutGroupModule.getActiveTabElement(layoutGroup)[0];

        var oldActiveChild;
        var newActiveChild;

        // Iterate througha ll of the layout group child nodes
        for(var i = 0; i < layoutGroup.childNodes.length; i++) {
          var currentChild = layoutGroup.childNodes[i];

          // If we find the first layout, set the newActiveChild element
          if(!newActiveChild && currentChild.classList.contains("layout")) {
            newActiveChild = currentChild;
          }

          // If we find a header match with the current active header, set the oldActiveChild element
          if(currentChild.querySelector(".header") === activeHeader) {
            oldActiveChild = currentChild;
          }            
        }

        // Set the elements tab to active if it is not active
        if(newActiveChild !== oldActiveChild){
          LayoutGroupModule.setLayoutActive(newActiveChild);
          LayoutGroupModule.setLayoutInactive(oldActiveChild);
        }
      }
    }  

    _propertyPanel = new pega.ui.components.panels.ClassLoader("expressPropertyPanel", propertyPanelOptions);
    _layoutEditorPanel.addChild(_propertyPanel);

    // Add Panel
    var addPanelOptions = {};
    addPanelOptions.preHide = function() {
      _refreshLayoutEditor(_focusedElement, {
        clearUndoRedo: false
      });
      _addPanel.getElement().removeEventListener('scroll', _hideViewOverlay, true); 
      _addPanel.getElement().removeEventListener('click', _hideViewOverlay, true);
      publicAPI.sendEvent("LayoutEditor.widgetListClose");
    };

    _addPanel = new pega.ui.components.panels.ClassLoader("expressAddPanel", addPanelOptions);
    _addPanel.getElement().classList.add("layout-editor-add");
    _layoutEditorPanel.addChild(_addPanel);

    // Property Panel for Grid
    _gridPropertyPanel = new pega.ui.components.panels.ClassLoader("expressGridPropertyPanel", null);
    _gridLayoutEditorPanel.addChild(_gridPropertyPanel);
    // Add Grid Panel options
    var addGridPanelOptions = {};
    addGridPanelOptions.preHide = function() {
      publicAPI.sendEvent("LayoutEditor.widgetListClose");
    };

    // Add Panel for table/grid
    _addPanelForGrid = new pega.ui.components.panels.ClassLoader("expressGridAddPanel", null);
    _gridLayoutEditorPanel.addChild(_addPanelForGrid);

    // Theme Property Panel
    _themePropertyPanel = new pega.ui.components.panels.ClassLoader("expressThemePropertyPanel", null);
    _propertyPanel.addChild(_themePropertyPanel);
    _addPanel.getElement().addEventListener('scroll', _hideViewOverlay, true); 
    _addPanel.getElement().addEventListener('click', _hideViewOverlay, true);

    _initializeUIDesignTopPanel();
    _initializePagesPanel();
  }

  /**
     * Initializes the Runtime Editor
     */
  function _initializeRuntimeEditor() {
    //if the runtime editor has been initialized already, then destroy before initializing again
    if (_runtimeEditor) {
      _runtimeEditor.destroy();
    }
    _runtimeEditor = new pega.ui.designtemplate.RuntimeEditor({
      contentWindow: pega.ui.composer.getComposerPreviewWindow(),
      containerClass: "ignore-suppression",
      selectCellCallback: function(cell) {
        $(_focusedElement).removeClass("ignore-suppression");
        var pgRef;
        if (cell !== null) {
          var cellInspectObject = pega.ui.inspector.utilities.getTempInspectorObject($(cell));
          pgRef = cellInspectObject.get("pgRef");
          _focusedElement = pega.ui.inspector.utilities.elementToHighlight(cellInspectObject.get("element")[0]);
        } else {
          pgRef = _propertyPanelPgRef;
          _focusedElement = cell;
        }

        _showPropertyPanel(pgRef);


      },
      selectTemplateCallback: function(htmlElement){
        var parent = _runtimeEditor.getParentSection();
        var inspectorElement =  pega.ui.inspector.utilities.getTempInspectorObject($(htmlElement));
        var clearUndoRedo = false;                
        var usingPageClassRef = inspectorElement.get("pgRef"); /* Need for BUG-403721 fix */

        // See if section include inside include layout, if not want to clear undo/redo
        if (parent && parent !== htmlElement) {
          if (inspectorElement.get("clipboardPath") !== parent.getAttribute("node_name")) {
            clearUndoRedo = true;
          }                
        }

        //if we are selecting the parent, then we want to 
        // either load the layout editor or the grid layour editor based on the type of element selected               
        if(inspectorElement.get("type") === "Layout" && inspectorElement.get("subType") === "REPEATGRID"){
          publicAPI.isTemplateRuntimeEditorEnabled = false;
          publicAPI.loadGridLayoutEditor(null, htmlElement);
          publicAPI.isTemplateRuntimeEditorEnabled = true;

        } else {
          _refreshLayoutEditor(htmlElement, {
            clearUndoRedo: clearUndoRedo,
            usingPageClassRef: usingPageClassRef
          });
        }    

      },
      beforeDropCallback: function() {
        _showLoading();
      },
      dropCallback: function(dataObj) {
        /* reference for dataObj
                    dataObj = {
                        "detail": {
                            "draggedElementCss": sourceElement.attr("class");
                            "sectionStreamName": sectionStreamName,
                            "sectionClassName": sectionClassName,
                            "sourcePath": sourcePath,
                            "destinationRegionName": destinationRegionName,
                            "destinationPath": destPath,
                            "targetPosition": targetPosition
                        }
                    }
                */
        if (dataObj == null || dataObj.detail == null) {
          _reloadSection();
          return;
        }
        var sectionNode = pega.u.d.getSectionByName("pzLayoutEditor", "",
                                                    document);
        var parentPagePath = pega.u.d.getBaseRef(sectionNode);

        // Build up URL for preActivity
        var reloadURL = new SafeURL();
        reloadURL.put("sourcePath", dataObj.detail.sourcePath);
        reloadURL.put("destinationRegionName", dataObj.detail.destinationRegionName);
        reloadURL.put("destinationPath", dataObj.detail.destinationPath);
        reloadURL.put("parentPagePath", parentPagePath);
        reloadURL.put("targetPosition", dataObj.detail.targetPosition);
        // Refresh case
        pega.u.d.reloadSection(sectionNode, "pzEditTemplatesFromClient",
                               reloadURL.toQueryString(), false, false, -1, false, null,
                               null, null, _reloadSection);
      }
    });
  }

  /**
     * Initializes the layout editor panel.
     */
  function _initializeLayoutEditor() {
    var layoutEditorPanelOptions = {};

    layoutEditorPanelOptions.preShow = function() {
      //toggle configure link off
      _toggleConfigureLink(false);

      _screenLayoutElement.scrollTop(0);
      _screenLayoutElement.scrollLeft(0);
    }
    layoutEditorPanelOptions.showCallback = function() {
      _toggleLayoutEditorEvents(false);
      _toggleLayoutEditorEvents(true);
      _toggleConfigureLink(false);

      pega.ui.composer.registerEventListener("LiveComposer.stateChange", _layoutEditorPanel.hide);
    }
    // TASK-647416 added hide logic
    layoutEditorPanelOptions.preHide = function() {
      $(_focusedElement).removeClass("ignore-suppression");

      _toggleLayoutEditorEvents(false);


      //unsupress UI mode highlighting if it was previously on
      if(!_gridLayoutEditorPanel.isShowing()){
        _focusedElement = null;
        if (publicAPI.isInUIMode()) {
          // _isInUIMode before panel was opened was set to true
          _initializeRuntimeEditor();
          _runtimeEditor.showHighlightForEditableContent();
          _toggleConfigureLink(false);
        } else {
          _toggleConfigureLink(true); 
          _runtimeEditor.destroy();
          _runtimeEditor = null;
        }
      } 
    }
    // TASK-647416 added hide callback logic
    layoutEditorPanelOptions.hideCallback = function() {
      pega.ui.composer.sendEvent('LiveComposer.rightPanelHidden')
      pega.ui.composer.cancelEventListener('LiveComposer.stateChange', _layoutEditorPanel.hide);
    }
    _layoutEditorPanel = new pega.ui.components.panels.ClassLoader("expressRightPanel", layoutEditorPanelOptions);
    _layoutEditorPanel.getElement().classList.add("layout-editor-express");
    pega.ui.panelManager.registerPanel(_layoutEditorPanel, pega.ui.panelConstants.DOCK_LOCATION.RIGHT);
  }

  /**
     * Initializes _uiDesignTopPanel
     */
  function _initializeUIDesignTopPanel(){
    var uiDesignTopPanelOptions = {};     

    _uiDesignTopPanel = new pega.ui.components.panels.ClassLoader("uiDesignTopPanel", uiDesignTopPanelOptions);
    pega.ui.panelManager.registerPanel(_uiDesignTopPanel, pega.ui.panelConstants.DOCK_LOCATION.TOP);
  }

  /**
    * Initializes _pagesPanel
    */
  function _initializePagesPanel(){
    var pagesPanelOptions = {};

    /* Save the right panel object temporarily */
    var rightPanel = _layoutEditorPanel;
    var gridPanel = _gridLayoutEditorPanel;

    pagesPanelOptions.preShow = function() {
      // Now is the time to close the right panel(s)
      var tempRightPanel = rightPanel;
      var tempGridPanel = gridPanel;
      tempRightPanel.hide();
      tempGridPanel.hide();
    }

    pagesPanelOptions.hideCallback = function() {
      var frameList = pega.util.Dom.getFrames(window);

      // For each of the windows in our list...
      for(var i = 0; i < frameList.length; i++) {
        var currentFrame = frameList[i];
        //remove event listeners for page panel
        if(currentFrame.document.body != null) {
          currentFrame.document.body.removeEventListener("click", _closePagesPanelOnClickAway);
        }
      }  
    }

    pagesPanelOptions.pushesContent = false;

    _pagesPanel = new pega.ui.components.panels.ClassLoader("pagesPanel", pagesPanelOptions);
    pega.ui.panelManager.registerPanel(_pagesPanel, pega.ui.panelConstants.DOCK_LOCATION.LEFT);

  }

  /**
     * Initializes the layout editor panel.
     */
  function _initializeGridLayoutEditor() {
    var gridLayoutEditorPanelOptions = {};

    gridLayoutEditorPanelOptions.preShow = function() {
      _screenLayoutElement.scrollTop(0);
      _screenLayoutElement.scrollLeft(0);
    }
    gridLayoutEditorPanelOptions.showCallback = function() {
      _toggleGridLayoutEditorEvents(false);
      _toggleGridLayoutEditorEvents(true);
      _toggleConfigureLink(false);
      pega.ui.composer.registerEventListener("LiveComposer.stateChange", _gridLayoutEditorPanel.hide);
    }
    // TASK-647416 added hide logic
    gridLayoutEditorPanelOptions.preHide = function() {
      $(_focusedElement).removeClass("ignore-suppression");

      _focusedElement = null;
      _toggleGridLayoutEditorEvents(false);

      //unsupress UI mode highlighting if it was previously on
      if(!_layoutEditorPanel.isShowing()){
        if (publicAPI.isInUIMode()) {
          // _isInUIMode before panel was opened was set to true
          _initializeRuntimeEditor();
          _runtimeEditor.showHighlightForEditableContent();
          _toggleConfigureLink(false);
        } else {
          _toggleConfigureLink(true); 
          _runtimeEditor.destroy();
          _runtimeEditor = null;
        }
      } 
    }
    // TASK-647416 added hide callback logic
    gridLayoutEditorPanelOptions.hideCallback = function() {
      pega.ui.composer.sendEvent('LiveComposer.rightPanelHidden')
      pega.ui.composer.cancelEventListener('LiveComposer.stateChange', _gridLayoutEditorPanel.hide);
    }
    _gridLayoutEditorPanel = new pega.ui.components.panels.ClassLoader("expressGridRightPanel", gridLayoutEditorPanelOptions);
    _gridLayoutEditorPanel.getElement().classList.add("layout-editor-express");
    pega.ui.panelManager.registerPanel(_gridLayoutEditorPanel, pega.ui.panelConstants.DOCK_LOCATION.RIGHT);
  }

  function _layoutEditorSaveResponse(additionalData) {
    // Check if event is requesting the panel to be reloaded
    if(additionalData && additionalData.panelRefresh && additionalData.panelRefresh == true) {
      _refreshLayoutEditor(_runtimeEditor.getFocusedTemplate(), {
        clearUndoRedo: true
      });
    }

    // Call reload section to update UI
    _reloadSection(additionalData);
  }


  /**
     * @private Calls server to set the settings for live composer on clipboard
     *
     * @param $Boolean$ isEditingOn - Required param to specifiy the state of the portal
     **/
  function _postLiveComposerSettings(isEditingOn) {
    if (!_innerPortalFrame.contentWindow.pega) {
      return;
    }
    
    //To prevent unessesary server hits its params are not set correctly or _ignoreNextServerCall is set
    if (!(isEditingOn == true || isEditingOn == false) || (_ignoreNextServerCall)) {
      _ignoreNextServerCall = false;
      return;
    }
    var asyncCall = new _innerPortalFrame.contentWindow.SafeURL(
      "Embed-Pega-PortalPage.pzLiveComposer_SaveSettings");
    asyncCall.put("isEditingOn", isEditingOn);
    _innerPortalFrame.contentWindow.pega.util.Connect.asyncRequest("POST", asyncCall.toURL());
  }

  /**
     * @private Finds the selected section and then refreshes it within the preview window. If the selected 
     * section is included multiple times, refresh all instances of it and re-focus the affected element 
     * in the template that that is being configured 
     *
     * @param $Object$ additionalData - Container of any additional data needed to be sent (in form of object) to this event function
     * @param $Function$ afterRefreshCallback - Called after the build in callback is run for the reload
     */
  function _reloadSection(additionalData, afterRefreshCallback) {
    //if coming from the collaboration, then check if the property panel is 
    if(additionalData && additionalData.skipCollaboration == true && _propertyPanel.isShowing()){
      //The focusedElement is currently the field corresponding to the open property panel, reset this to be the 
      _focusedElement = _runtimeEditor.getFocusedTemplate()
      //close the property panal as the whole section needs to be refreshed.
      _propertyPanel.hide();
    }

    var tempInspectedObject = pega.ui.inspector.utilities.getTempInspectorObject($(_focusedElement));
    var ruleName = tempInspectedObject.get("ruleName");
    // Cache off the focused element to use for refresh scenarios
    var cachedFocusedElement = _focusedElement;
    // Get all instances of a section based on its name
    var sectionNodes = pega.u.d.getSectionsByName(ruleName, tempInspectedObject.ownerWindow.document);
    // build up callback for reload of the section, as well as any duplicates of it included in the UI 
    if (sectionNodes != null) {
      _showLoading();
      // Clear and re-highlight based off the cached version of the focused element
      // since we will lose context of it if the same section is included multiple times
      var callback = function() {
        if (_runtimeEditor != null) {
          _runtimeEditor.clearAllHighlights();
          _runtimeEditor.focusTemplate(cachedFocusedElement, true);
        }
        var tempInspectedObject = pega.ui.inspector.utilities.getTempInspectorObject($(
          cachedFocusedElement));
        var isTemplated = tempInspectedObject.get("templated");
        if (isTemplated) {
          $(_focusedElement).addClass("ignore-suppression");
        } else {
          $(_focusedElement).removeClass("ignore-suppression");
        }
        _loadingIndicator.hide();
        // If the optional callback was passed in then call it
        if (afterRefreshCallback != null) {
          afterRefreshCallback();
        }

        // US-236561: Extract the template's insKey and notify the channel 
        if((pega.collaboration && pega.collaboration.actions) && 
           (!additionalData || additionalData.skipCollaboration !== true)) { 
          pega.collaboration.actions.updateCollaboration(tempInspectedObject.get("insKey"), "save");
        }
      }
      // Loop over the array, which includes all instances of the section and refresh them
      for (var i = 0; i < sectionNodes.length; i++) {
        //set the harness context to be the harness of the section to be refreshed.  The inner harness
        //may not have been set at this point, as the layout editor is in a different frame.
        var harnessID = $(sectionNodes[i]).closest("[data-harness-id]").attr("data-harness-id");
        tempInspectedObject.ownerWindow.pega.ctxmgr.setCurrentHarnessContext(harnessID);

        tempInspectedObject.ownerWindow.pega.u.d.reloadSection(sectionNodes[i], "", "", false, false, -1,
                                                               false, null, null, null, callback);
      }
    }
  }
  /**
     * @private Finds the selected grid(table) and then refreshes it in the callback to the _reloadSection. 
     *
     * @param $Function$ - Called after the Apply in the grid panel header is selected
     */
  function _reloadGridSection() {
    var gridInspectObject = pega.ui.inspector.utilities.getTempInspectorObject($(_focusedElement));

    var gridSectionInspectObject = pega.ui.inspector.parser.getNearestParent(gridInspectObject, [{
      'type': "Section"
    }]);
    var gridSectionElement = gridSectionInspectObject.get('element')[0];

    var gridMeta = _focusedElement.dataset.uiMeta;

    var cachedPropertyPanelPgRef = _propertyPanelPgRef;
    _propertyPanelPgRef = gridInspectObject.get('pgRef');
    _focusedElement = gridSectionElement;
    _reloadSection(null, function() {
      _propertyPanelPgRef = cachedPropertyPanelPgRef;
      _focusedElement = gridSectionElement.querySelector('[data-ui-meta="' + gridMeta + '"]');
      _runtimeEditor.focusTemplate(_focusedElement, true);
    });
  }

  /**
     * @private Called when an edit is applied from the property panel to reload the layout editor and ui without closing the property panel
     * @param hasPageMessages - flag that dicates whether there are page error messages exist or not (i.e., don't refresh panel to make them disappear)
     **/
  function _propertyPanelApply(hasPageMessages) {
    // When the event is sent from activities, this value returns the string "true", so convert it to a boolean
    if (typeof hasPageMessages === "string") {
      hasPageMessages = (hasPageMessages == "true");
    }

    // BUG-498406 show error for missing section param val when required    
    var requiredFieldsList = document.querySelectorAll('[data-node-id="pzRuleCallParamsInner"] .iconErrorDiv+input');
    if (requiredFieldsList != null) {
      var event ;
      // IE issue with event needs this check
      if (typeof(Event) === 'function') {
        event = new Event('blur');
      } else {
        event = document.createEvent('Event');
        event.initEvent('blur', true, true);
      }
      for (var i = 0; i < requiredFieldsList.length; i++) {
        validation_ValidateFieldOnEvent(requiredFieldsList[i],'onblur',null, event);
      }
    }
    
    // BUG-346534: If page error messages exist, do not refresh the property panel to clear them out
    if (!hasPageMessages) {
      // Untoggle the click events and cache off data pertained to the currently highlighted cell
      _runtimeEditor.turnAllListenersOff();

      var focusedElem = _runtimeEditor.getFocusedElement();
      _focusedElement = $(focusedElem).closest('[data-ui-meta*=templated]')[0];
      // When the current focused element is templated then go to its parent
      if (focusedElem === _runtimeEditor.getFocusedTemplate()) {
        var cellInspectObject = pega.ui.inspector.utilities.getTempInspectorObject($(focusedElem));

        cellInspectObject = pega.ui.inspector.parser.getNearestParent(cellInspectObject, [{
          'templated': true
        }]);
        _focusedElement = cellInspectObject.get('element')[0];
      } else {
        // Cannot have a null focused element or reloading the section blows up.
        if (_focusedElement == null) {
          _focusedElement = _runtimeEditor.getParentSection();
        }
      }

      _reloadSection(null, function() {
        publicAPI.focusRuntimeEditorCell(_propertyPanelPgRef);
      });
      //Clear the reloadStatus that is set when container is dirty. (gSectionReloaded in current context is set to false)
      pega.u.d.clearReloadedStatus();
    }   

  }

  /**
     * Called to show the live composer busy indicator which always appears in the top window
     */
  function _showLoading() {
    if (pega.u.d.gBusyInd) {
      pega.u.d.gBusyInd.hide();
    }
    _loadingIndicator.show(false, true);
  }

  /**
	   * Called to hide the overlay used to add field group and date reference views
	   */
  function _hideViewOverlay(e) {
    var po = pega.u.d.getPopOver();
    po.close(undefined,undefined,"true",undefined);
    _addViewSelectedRowPosition = e.target.closest("div.layout-editor-row");
  }
  /**
     * @private Toggles the mouse cursor state for all known frames
     *
     * @param $Boolean$ turnOn - Flag to toggle on or off
     */
  function _toggleSuppressionEvents(turnOn) {
    var tempFrameList = pega.ui.inspector.utilities.getFrameList(pega.ui.composer.getComposerPreviewWindow());
    for (var x = 0; x < tempFrameList.length; x++) {
      var bodyElement = tempFrameList[x].document.body;
      // BUG-292614: For frames that do not have a body, continue looping
      if (!bodyElement) {
        continue;
      }

      if (turnOn && !bodyElement.classList.contains("runtime-tree-default-cursor")) {
        bodyElement.classList.add("runtime-tree-default-cursor");
        tempFrameList[x].addEventListener('click', publicAPI.handleSuppression, true);
        tempFrameList[x].addEventListener("mousedown", publicAPI.handleSuppression, true);
        tempFrameList[x].addEventListener('dragover', publicAPI.handleSuppression, true);
        tempFrameList[x].addEventListener('drop', publicAPI.handleSuppression, true);
      } else if (!turnOn && bodyElement.classList.contains("runtime-tree-default-cursor")) {
        bodyElement.classList.remove("runtime-tree-default-cursor");
        tempFrameList[x].removeEventListener('click', publicAPI.handleSuppression, true);
        tempFrameList[x].removeEventListener("mousedown", publicAPI.handleSuppression, true);
        tempFrameList[x].removeEventListener('dragover', publicAPI.handleSuppression, true);
        tempFrameList[x].removeEventListener('drop', publicAPI.handleSuppression, true);
      }
    }
  }

  /**
     * Shows the property panel based on given page reference.
     * @param pgRef - The page reference for the cell to open the property panel against.
     */
  function _showPropertyPanel(pgRef) {
    var template = _runtimeEditor.getFocusedTemplate();
    var tempInspectorObj = pega.ui.inspector.utilities.getTempInspectorObject($(template));
    var insKey = tempInspectorObj.get("insKey");
    _propertyPanelPgRef = pgRef;

    var params = {};
    params.cellPath = pgRef;
    params.key = insKey;
    params.hidefooter = true;
    params.pyIsRegionHeaderVisible = pgRef.indexOf("pyHeaderCells") > -1;

    _propertyPanel.loadByClass("Pega-UI-PanelContent-PropertyPanel", function() {
      _propertyPanel.show();
    }, params);

    pega.ui.composer.getComposerPreviewWindow().pega.u.d.detachOnload(_deferLoadRehighlight, true);
    //BUG-342438 remove any menu that has been launched as we show prop panel.
    pega.c.menu.killMenus();
  }

  /**
     * Called to show the theme property panel panel
     **/
  function _showThemePanel(pgRef) {
    var template = _runtimeEditor.getFocusedTemplate();
    var tempInspectorObj = pega.ui.inspector.utilities.getTempInspectorObject($(template));
    var insKey = tempInspectorObj.get("insKey");
    if (pgRef == undefined || pgRef == "") {
      var focusedElem = _runtimeEditor.getFocusedElement();
      var pgRefCell = pega.ui.inspector.utilities.getTempInspectorObject($(focusedElem).closest(
        '[data-ui-meta*=pyRegions]'));
      pgRef = pgRefCell.get("pgRef");
    }
    _propertyPanelPgRef = pgRef;

    var params = {};
    params.cellPath = pgRef;
    params.key = insKey;

    _themePropertyPanel.loadByClass("Pega-UI-PanelContent-ThemePanel", function() {
      _themePropertyPanel.show();
    }, params);
  }

  /*
     *  Function called on click of apply of theme panel 
     *  preview is updated with latest skin generated after save 
     */
  function _themePanelApply() {
    var previewWindow = publicAPI.getComposerPreviewWindow();
    var docObj = previewWindow.document;
    if(previewWindow.name === 'FormFactoriFrame' && appSkin_with_savedFormat) {
      var link = docObj.createElement('link');
      link.rel = 'stylesheet';
      link.type = "text/css";
      link.href = appSkin_with_savedFormat;
      docObj.head.appendChild(link);
    }
    var iframes = $(docObj).find("iframe");
    if (appSkin_with_savedFormat) {
      for(var i=0; i<iframes.length; i++){
        var iframeDom = iframes[i].contentDocument;
        var link = iframeDom.createElement('link');
        link.rel = 'stylesheet';
        link.type = "text/css";
        link.href = appSkin_with_savedFormat;
        iframeDom.head.appendChild(link);
      }
    }
  }

  /**
     * Called to rehighlight element that was focused
     */
  function _reHighlightElement(skipFocusTemplateCallback) {
    //Pass valid focus element, null causes errors
    var currentFocusElement = _runtimeEditor.getFocusedElement();
    if (currentFocusElement == null) {
      currentFocusElement = _runtimeEditor.getParentSection();
    }
    var tempInspectorObj = pega.ui.inspector.utilities.getTempInspectorObject($(currentFocusElement));

    var isSection = tempInspectorObj.get("type") === "Section";
    var isTable = tempInspectorObj.get("type") === "Layout" && tempInspectorObj.get("subType") === "REPEATGRID";

    if (isSection || isTable) {
      _focusedElement = currentFocusElement;
    } else {
      //reset the focusedElement
      _focusedElement = _runtimeEditor.getFocusedTemplate();
    }

    //clear out the highlighting and reenable the highlights and dragging
    _runtimeEditor.clearAllHighlights();
    //_runtimeEditor.highlightTemplate(_focusedElement);
    _runtimeEditor.focusTemplate(_focusedElement, skipFocusTemplateCallback);
  }

  /**
     * Rehighlights the given element after all defer load sections have been loaded.
     * @param htmlElement - The element to rehighlight after defer load sections have loaded.
     */
  function _deferLoadRehighlight(htmlElement) {
    clearTimeout(_rehighlightTimeout);
    _rehighlightTimeout = setTimeout(function() {
      if (_runtimeEditor.getFocusedTemplate() != null && _runtimeEditor.getFocusedTemplate().contains(htmlElement)) {
        _reHighlightElement(true);
      }
    }, 100);
  }

  /**
     *  toggle the orange configure link in the UI
     *  showLink - true to show, false to hide
     */
  function _toggleConfigureLink(showLink) {
    var tempFrameList = pega.ui.inspector.utilities.getFrameList(pega.ui.composer.getComposerPreviewWindow());

    for (var x = 0; x < tempFrameList.length; x++) {
      if (tempFrameList[x].document && tempFrameList[x].document.body) {
        if (showLink) {
          tempFrameList[x].document.body.classList.remove("hideConfigureLink");
        } else {
          tempFrameList[x].document.body.classList.add("hideConfigureLink");
        } 
      }
    }
  }

  /** 
     *  Gets the required parameters for layout editor panel load
     */
  function _getParamsForLayoutEditor(parentInspectorObject, tempInspectorObj) {
    var params = {};
    params.clearUndoRedo = true;
    params.isConfigureFormEnabled = (parentInspectorObject.get("type") == "FlowAction");
    params.hidefooter = false;

    var tempInspElement = tempInspectorObj.get("element")[0];

    // BUG-524668: If inside a mdc-fieldset, extract the thread name and add to the params object so they can be added to
    // the context page server-side.
    var isInMDCFieldSet = $(tempInspElement).closest(".mdc-fieldset")[0];
    if(isInMDCFieldSet) {
      var actionUrl = isInMDCFieldSet.dataset["action"];
      if(actionUrl != "") {
        params.threadName = pega.u.d.getThreadName({url: actionUrl});
        
        // BUG-622643: Hide the "Configure form" option if in an "ACTERCIARY" thread context (see US-391416)
        if(params.threadName.indexOf("/ACTERTIARY") > -1) {
          params.isConfigureFormEnabled = false;
        }
      }
    }
    
    var hasNoTemplatedAncestor = pega.ui.inspector.parser.getNearestParent(tempInspectorObj, [{'templated': true}]) === null;
    var isParentAHarness = parentInspectorObject.get("type") === "Harness";
    var isParentAWorkareaWidget = parentInspectorObject.get("sectionType") === "workareaWidget";
    var isParentAFlowAction = parentInspectorObject.get("type") === "FlowAction";
    var isEditingSectionAWorkarea = tempInspectorObj.get("sectionType") === "workarea";
    var isEditingSectionConfigureViewSection =  $(tempInspElement).hasClass('express-configure-highlight');

    //if any of these conditions are tue, then we do NOT want to show the settings link
    params.isSettingsLinkDisabled = hasNoTemplatedAncestor || isParentAHarness ||  
      isParentAWorkareaWidget || isParentAFlowAction || 
      isEditingSectionAWorkarea || isEditingSectionConfigureViewSection;

    // Need section name and class name for obj-open in pzPreLoad if there is no inskey
    // This is required since the non-templated sections are not having insKey
    if (tempInspectorObj.get("insKey") === undefined) {
      var sectionName = tempInspectorObj.get("clipboardPath");
      if (sectionName !== undefined) {
        params.sectionName = sectionName;
      }
      var sectionClassName = tempInspectorObj.get("className");
      if (sectionClassName !== undefined) {
        params.sectionClassName = sectionClassName;
      }
    }
    return params;
  }

  /**
     * Called to toggle all event listeners for the layout editor and prop panel
     */
  function _toggleLayoutEditorEvents(turnOn) {
    if (turnOn === true) {
      //TODO: events should be where they are coming from not what they are doing
      pega.ui.composer.registerEventListener("LayoutEditor.save", _layoutEditorSaveResponse);
      pega.ui.composer.registerEventListener("LayoutEditor.move", _showLoading);
      pega.ui.composer.registerEventListener("LayoutEditor.switchTemplate", _showLoading);
      pega.ui.composer.registerEventListener("LayoutEditor.addWidget", _runtimeEditor.disableInteraction);
      //TODO: Why is this called widetListClose and the other addWidget, should probablly rename to closeWidget or update other to be consistent
      pega.ui.composer.registerEventListener("LayoutEditor.widgetListClose", _runtimeEditor.enableInteraction);
      pega.ui.composer.registerEventListener("PropertyPanel.apply", _propertyPanelApply);
      pega.ui.composer.registerEventListener("PropertyPanel.hide", _propertyPanel.hide);
      //pega.ui.composer.registerEventListener("LayoutEditor.rehighlightElement", _reHighlightElement); --- future hook
      pega.ui.composer.registerEventListener("ThemePanel.apply", _themePanelApply);
      pega.ui.composer.registerEventListener("ThemePanel.hide", _themePropertyPanel.hide);
      pega.ui.composer.registerEventListener("ThemePanel.show", _showThemePanel);
      pega.ui.composer.getComposerPreviewWindow().pega.u.d.attachOnload(_deferLoadRehighlight, true);
      _toggleSuppressionEvents(true);
    } else {
      pega.ui.composer.cancelEventListener("LayoutEditor.save", _layoutEditorSaveResponse);
      pega.ui.composer.cancelEventListener("LayoutEditor.move", _showLoading);
      pega.ui.composer.cancelEventListener("LayoutEditor.switchTemplate", _showLoading);
      pega.ui.composer.cancelEventListener("LayoutEditor.addWidget", _runtimeEditor.disableInteraction);
      pega.ui.composer.cancelEventListener("LayoutEditor.widgetListClose", _runtimeEditor.enableInteraction);
      pega.ui.composer.cancelEventListener("PropertyPanel.apply", _propertyPanelApply);
      pega.ui.composer.cancelEventListener("PropertyPanel.hide", _propertyPanel.hide);
      //pega.ui.composer.cancelEventListener("LayoutEditor.rehighlightElement", _reHighlightElement); --- future hook
      pega.ui.composer.cancelEventListener("ThemePanel.apply", _themePanelApply);
      pega.ui.composer.cancelEventListener("ThemePanel.hide", _themePropertyPanel.hide);
      pega.ui.composer.cancelEventListener("ThemePanel.show", _showThemePanel);
      pega.ui.composer.getComposerPreviewWindow().pega.u.d.detachOnload(_deferLoadRehighlight, true);
      _toggleSuppressionEvents(false);
    }
  }

  /**
     * Called to toggle all event listeners for the grid layout editor and prop panel
     */
  function _toggleGridLayoutEditorEvents(turnOn) {
    if (turnOn === true) {
      //TODO: events should be where they are coming from not what they are doing
      pega.ui.composer.registerEventListener("GridLayoutEditor.save", _reloadGridSection);
      pega.ui.composer.registerEventListener("GridPropertyPanel.apply", _propertyPanelApply);
      pega.ui.composer.registerEventListener("GridPropertyPanel.hide",_gridPropertyPanel.hide);
      pega.ui.composer.getComposerPreviewWindow().pega.u.d.attachOnload(_deferLoadRehighlight, true);
    } else {
      pega.ui.composer.cancelEventListener("GridLayoutEditor.save", _reloadGridSection);
      pega.ui.composer.cancelEventListener("GridPropertyPanel.apply", _propertyPanelApply);
      pega.ui.composer.cancelEventListener("GridPropertyPanel.hide", _gridPropertyPanel.hide);
      pega.ui.composer.getComposerPreviewWindow().pega.u.d.detachOnload(_deferLoadRehighlight, true);
    }
  }

  /**
     * Refreshes the layout editor panel (does not call show).
     *
     * @param focusedElem The currently focused element.
     * @param additionalParams Additional parameters to pass to pzPreLoad activity for layout editor panel.
     */
  function _refreshLayoutEditor(focusedElem, additionalParams) {
    _showLoading();
    var tempInspectorObj = pega.ui.inspector.utilities.getTempInspectorObject($(focusedElem));
    var key = tempInspectorObj.get("insKey");

    if(_layoutEditorPanel.isShowing()) {
      _showLoading();
      $(_focusedElement).removeClass("ignore-suppression");
      $(focusedElem).addClass("ignore-suppression");
      _focusedElement = focusedElem;
      // Check if the parent is a flow action and pass param to load to disable configure form button
      var parentInspectorObject = pega.ui.inspector.parser.getNearestParent(tempInspectorObj);

      var params = _getParamsForLayoutEditor(parentInspectorObject, tempInspectorObj);
      params.key = key;
      /* For BUG-403721 fix when the dom for a section like field group miss its key */
      if (null == key || key == "undefined") {
        params.usingPageClass = true;
      }
      // add additional params to our current params
      for (var key in additionalParams) {
        params[key] = additionalParams[key];
      }

      _layoutEditorPanel.loadByClass("Pega-UI-PanelContent-LayoutEditor", function() {
        _loadingIndicator.hide();
      }, params);
    } else {
      publicAPI.loadLayoutEditor(key, focusedElem);
    }
  }

  /**
      * close the page panel when clicking outside of it
      */
  function _closePagesPanelOnClickAway(e) {
    /* If pages panel is open and not clicking on pages link or within pages panel */
    pega.control.menu.killMenus();
    var pagesLink = $('.pages-title a.Header_nav')[0];
    if(_pagesPanel.isShowing() && e.target.parentElement !== pagesLink && e.target !== pagesLink && $(e.target).closest("#pagesPanel").length === 0) {
      _pagesPanel.hide();
    }
  }

  /////////////////////////////////////////////////////////////////////////////////
  //                              PUBLIC FUNCTIONS                               //
  /////////////////////////////////////////////////////////////////////////////////

  /**
     * @public Called to initalize all variables that need to wait for window load event to finish
     **/
  publicAPI.initialize = function() {
    // Store reference to screen layout div
    _screenLayoutElement = $(".screen-layout");
    _deviceOutline = $('.deviceOutline')[0];
    if (typeof _deviceOutline === "undefined") return;
    // Set off the top most composer window
    _currentComposerWindow = publicAPI.getCurrentComposerWindow();
    // Initialize form factor namespace
    pega.ui.composer.formfactor.init();
    // Initialize variables for top most composer window
    if (_currentComposerWindow == window) {
      _loadingIndicator = new pega.ui.busyIndicator("", true, document.body, 250);
      // Get a handle on the iframes
      _innerPortalFrame = document.getElementById("FormFactoriFrame");
      // Add load event to the inner frame
      $(_innerPortalFrame).on("load", pega.ui.composer.loadPreviewWindow);
      if (pega.ui.designtemplate != null) {
        // Only init panels in composer frame
        _initializePanels();
      }
    }
  }


  /**
     * When calling show property from "Settings" link in layout editor 
     * this api is called so that we can get ref from nearest templated parent
     */
  publicAPI.showPropertyPanel = function() {
    // Get parent insKey needed to show prop panel
    var focusedElem = _runtimeEditor.getFocusedElement();
    var cellInspectObject = pega.ui.inspector.utilities.getTempInspectorObject($(focusedElem));
    cellInspectObject = pega.ui.inspector.parser.getNearestParent(cellInspectObject, [{
      'templated': true
    }]);
    var insKey = cellInspectObject.get("insKey");
    // Get current page ref relevant to parent section
    var pgRefCell = pega.ui.inspector.utilities.getTempInspectorObject($(focusedElem).closest(
      '[data-ui-meta*=pyRegions]'));
    _propertyPanelPgRef = pgRefCell.get("pgRef");

    var params = {};
    params.cellPath = _propertyPanelPgRef;
    params.key = insKey;
    params.hidefooter = true;

    _propertyPanel.loadByClass("Pega-UI-PanelContent-PropertyPanel", function() {
      _propertyPanel.show();
    }, params);

    pega.ui.composer.getComposerPreviewWindow().pega.u.d.detachOnload(_deferLoadRehighlight, true);
  }

  /**
     * Shows the add panel for the layout editor.
     *
     * @param target The target element of the click event (used to get the base ref for the panel's rendering page)
     * @param isHeaderEditing Used in the pzWidgetList section to determine what items can be added to the region (US-248828)
     */
  publicAPI.showAddPanel = function(target, isHeaderEditing) {
    if(typeof isHeaderEditing === "undefined" || isHeaderEditing != "true") {
      isHeaderEditing = "false";
    }

    var pagePath = pega.u.d.getBaseRef(target);
    pagePath = pagePath.substring(0, pagePath.indexOf('.pyContext'));

    if (pagePath === "") {
      pagePath = pega.u.d.getBaseRef(target);
      _addPanelForGrid.loadByDynamic('pzWidgetList', pagePath, function() {
        _addPanelForGrid.show();
      }, {
        'panelLabel': 'Add columns',
        'isFromGridLayout': true
      });
    } else {
      _addPanel.loadByDynamic('pzWidgetList', pagePath, function() {
        _addPanel.show();
        publicAPI.sendEvent("LayoutEditor.addWidget");
      }, {
        'panelLabel': 'Add...',
        'isHeaderEditing': isHeaderEditing
      });
    }
  }

  /**
     * Shows the UI Design top panel 
     *
     * @param target The target element of the click event (can be used to get the base ref for the panel's rendering page)
     */
  publicAPI.showUIDesignTopPanel = function(target) {
    
    ///if the panel is already showing then there is nothing to do!
    if(_uiDesignTopPanel.isShowing()){
      return;
    }

    var uiDesignTopPanelShell = document.getElementById("uiDesignTopPanel");
    
    //we don't need to reload the design panel as it's content doesn't change
    if(uiDesignTopPanelShell && uiDesignTopPanelShell.hasChildNodes() ){
      _uiDesignTopPanel.show(); 
    } else {
      var configurations = {};
      configurations.sectionName = "pzUIDesignTopPanel";
      configurations.sectionClass = "@baseclass";
      configurations.disableHeader = true;
      configurations.callback = function() {
        _uiDesignTopPanel.show(); 
      }
      _uiDesignTopPanel.loadSectionInPanel(configurations);
    }
  }
  
   /**
     * Hide the UI Design top panel 
     */
  
 publicAPI.hideUIDesignTopPanel = function() {
    
    ///if the panel is already showing then there is nothing to do!
    if(_uiDesignTopPanel.isShowing()){
      _uiDesignTopPanel.hide();
    }
  }
  /**
    * Shows the Pages panel. always reload the panel content and then show the panel
    */
  publicAPI.showPagesPanel = function(target) {   
    //if the panel is already showing then don't show it again.
    if(_pagesPanel.isShowing()) {
      return;
    }
    
    var configurations = {};
    configurations.sectionName = "pzPagesPanelContent";
    configurations.sectionClass = "Rule-HTML-Harness";
    configurations.pageContext = "D_pzCreateNewPage";
    configurations.preActivityName = "pzSetupPagesPanel";
    configurations.headerSectionName = "pzPagesPanelHeader";
    configurations.headerSectionClass = "Rule-HTML-Harness";
    configurations.callback = function() {
      _pagesPanel.show();
    }

    _pagesPanel.loadSectionInPanel(configurations);  
    

    // Extract all the frames
    var frameList = pega.util.Dom.getFrames(window);
    
    // For each of the windows in our list...
    for(var i = 0; i < frameList.length; i++) {
      var currentFrame = frameList[i];
      // Remove and add the doc handler for hiding the left pages panel
      currentFrame.document.body.removeEventListener("click", _closePagesPanelOnClickAway);
      currentFrame.document.body.addEventListener("click", _closePagesPanelOnClickAway);
    }
  }

  /**
     * Hides the UI Design Pages panel 
     *
     */
  publicAPI.hidePagesPanel = function(){
    if(_pagesPanel.isShowing()){
       _pagesPanel.hide();
    }
  }


  /**
     * Focuses the cell in the UI according to pgRef. For instance via the pen click in the
     * layout editor right panel.
     *
     * @param pgRef The pgRef of the cell to focus.
     */
  publicAPI.focusRuntimeEditorCell = function(pgRef) {
    _propertyPanelPgRef = pgRef;
    var filter = [{
      "pgRef": _propertyPanelPgRef
    }];
    var breakFilter = [{
      "type": "Section"
    }];
    var model = pega.ui.inspector.parser.buildModel(_runtimeEditor.getFocusedTemplate(), filter,
                                                    breakFilter);
    // Normal case
    for (var key in model.lookupByID) {
      var cellInspectorObject = model.lookupByID[key];
      // Parser can return root node with the filter we're using, make sure we skip it (BUG-300627)
      if (cellInspectorObject.get('element')[0] !== _runtimeEditor.getFocusedTemplate()) {
        var focusedHtmlElement = cellInspectorObject.get('element')[0];

        //if cell is of type section should not drill up to parent as you are already drilled into child, should remain in same context
        if (cellInspectorObject.get('type') === "Section") {

          // BUG-367541: If the property panel is showing, reload it to account for the new changes
          if(_propertyPanel.isShowing()) {
            _showPropertyPanel(_propertyPanelPgRef);
          }

          _runtimeEditor.focusTemplate(focusedHtmlElement);
        } else {
          _runtimeEditor.focusCell(focusedHtmlElement);
        }
        return;
      }
    }
    // "Invisible" case - if no element was found on the screen
    _focusedElement = null;
    _runtimeEditor.focusCell(null);
  }

  /**
     * if the runtime editor exists, this funciton untoggles the click events.
     * this function also caches off data pertained to the currently highlighted cell
     */
  publicAPI.turnOffEditingEvents = function() {
    if (_runtimeEditor) {
      _runtimeEditor.turnAllListenersOff();
    }
  }

  /**
     *  @public Call to replace the current window's URL
     *
     *   @param windowObj - Required param to target the window's object you wish to change the URL on
     *   @param url - Required param to tell what the target windows new url will be
     **/
  publicAPI.replaceWindowURL = function(windowObj, url) {
    //encode the url always to avoid xss attacks
    windowObj.location.replace(encodeURIComponent(url));
  }

  /**
     * @public Called to toggle in and out of PreviewMode by redirecting the URL
     *
     * @param portalName - Optional param to specify a portal name to use as the Live Composer Portal
     * @return True if the toggle was performed successfully; false indicates the composer bar is
     *  still transitioning in or out so a toggle was not performed.
     **/
  publicAPI.toggle = function(portalName) {
    if (_currentComposerWindow != window) {
      return _currentComposerWindow.pega.ui.composer.toggle(portalName);
    } else if (state == STATES.TRANSITIONING || !publicAPI.isActive()) {
      return false;
    } else if (state == STATES.SUSPENDED) {
      state = STATES.TRANSITIONING;
      // Create callback for loading up form factor
      var showCallback = function() {
        state = STATES.READY;
      }
      // Call form factor to load previous state
      pega.ui.composer.formfactor.load(function() {
        _show(showCallback)
      });
    } else {
      state = STATES.TRANSITIONING;
      var hideCallback = function() {
        state = STATES.SUSPENDED;
      }
      _hide(hideCallback);
    }
    return true;
  }

  /**
     * @public loops up the parent windows and finds the top most preview window
     *
     * @return The top most Live Composer window
     **/
  publicAPI.getCurrentComposerWindow = function() {
    if(pega.desktop.portalCategory === "workspace" && window.name === pega.desktop.portalName) return window;
    var TempWindow = window;
    var PreviousWindow;
    try {
      while (TempWindow.parent != null && TempWindow != PreviousWindow && TempWindow.parent.pega &&
             TempWindow.parent.pega.ui && TempWindow.parent.pega.ui.composer) {
        PreviousWindow = TempWindow;
        TempWindow = TempWindow.parent;
        if(TempWindow.pega.desktop.portalCategory === "workspace" && TempWindow.name === TempWindow.pega.desktop.portalName) return TempWindow;
      }
    } catch (e) {
      // Do Nothing
    }
    return TempWindow;
  }

  /**
     * @public Checks if the current window is the Form Factor frame
     *
     * @return True if the current window is the Form Factor Preview Window; Otherwise false
     **/
  publicAPI.isComposerPreviewFrame = function() {
    return (window.name == "FormFactoriFrame");
  }

  /**
     * @public Get the PreviewWindow window object
     *
     * @return preview window object
     **/
  publicAPI.getComposerPreviewWindow = function() {
    var currentComposerWindow = pega.ui.composer.getCurrentComposerWindow();
    if (currentComposerWindow != window) {
      return currentComposerWindow.pega.ui.composer.getComposerPreviewWindow();
    } else {
      return _innerPortalFrame.contentWindow;
    }
  }

  /**
     * @public Returns true if the composer bar is showing.
     *
     * @return True if the composer bar is showing; false otherwise.
     */
  publicAPI.isActive = function() {
    var currentComposerWindow = pega.ui.composer.getCurrentComposerWindow();
    if (currentComposerWindow != window) {
      return currentComposerWindow.pega.ui.composer.isActive();
    } else {
      return (state != STATES.INACTIVE);
    }
  }

  /**
     * @public Returns true if Live Composer is on
     *
     * @return True if the live composer is on; false otherwise.
     **/
  publicAPI.isComposerOn = function() {
    if (pega.ui.composer.getCurrentComposerWindow() != window) {
      return pega.ui.composer.getCurrentComposerWindow().pega.ui.composer.isComposerOn();
    } else {
      return (state != STATES.INACTIVE && state != STATES.SUSPENDED);
    }
  }

  /**
     * @public Loads all the preview mode iFrames
     * @param portalName - url of the window to preview
     * @param url - If the original portal is a single document portal then the url is passed along
     * @param autoLoad - Boolean for when the live composer portal should load automatically
     **/
  publicAPI.loadComposerMode = function(portalName, url, autoLoad, turnOnComposer) {
    if (_currentComposerWindow != window) {
      _currentComposerWindow.pega.ui.composer.loadComposerMode(portalName, url, autoLoad, turnOnComposer);
    } else if (!publicAPI.isActive()) {
      // BUG-327052 Set busy manually because we aren't really an autogen portal. DO NOT USE THIS AS AN EXAMPLE
      pega.ui.statetracking.setBusy("loadComposerMode");
      _previousPortalURL = url;
      // Add class to top screen layout panel (_topPanelElement)
      $("body > .screen-layout > .screen-layout-region-header").addClass("composerbar");
      // Set the state of composer based on the autoLoad param
      if (autoLoad) {
        state = STATES.LOADING;
      } else {
        state = STATES.SUSPENDED;
      }
      // Resize frame to default and set style
      if(_deviceOutline) {
        _deviceOutline.style.visibility = "hidden";
        _deviceOutline.style.width = "100%";
        _deviceOutline.style.height = "100%";
      }
      
      // Build the base RedirectAndRun url to show designer studio
      var redirectAndRunURL = new SafeURL("Embed-PortalLayout.RedirectAndRun");
      redirectAndRunURL.put("ThreadName", "OpenPortal_InnerLive");
      redirectAndRunURL.put("bPurgeTargetThread", true);
      redirectAndRunURL.put("bEncodeLocation", true);
      // Build up the Location param for RedirectAndRun which is really a url for a
      // show selected portal URL, which shows the portal that is specified in portalName param
      var showSelectedPortalURL = new SafeURL("Data-Portal.pzShowSelectedPortalForComposer");
      showSelectedPortalURL.put("ThreadName", "OpenPortal_InnerLive");
      showSelectedPortalURL.put("portal", portalName);
      showSelectedPortalURL.put("Name", portalName);
      showSelectedPortalURL.put("isLaunchedByLiveComposer", true);
      showSelectedPortalURL.put("developer", false);
      // Add the query string of the ShowSelectedPortal url to the location param for redirect and run
      redirectAndRunURL.put("Location", showSelectedPortalURL.toQueryString());
      // Redirect the window to the new url
      /*
        commented: publicAPI.replaceWindowURL(_innerPortalFrame.contentWindow, redirectAndRunURL.toURL());
        replaceWindowURL now encodes the url always, so use location.replace directly as safeurl's toURL already encodes the url
      */
      $(_innerPortalFrame.contentWindow)[0].location.replace(redirectAndRunURL.toURL());
      //Check to see if live composer should be turned on by default
      if (turnOnComposer) {
        _screenLayoutElement.addClass("slide-final-state");
        _screenLayoutElement.addClass("fade-transition");
        _screenLayoutElement.addClass("fade-final-state");
        _ignoreNextServerCall = turnOnComposer;
      } else {
        _screenLayoutElement.addClass("fade-final-state");
        _screenLayoutElement.addClass("slide-transition");
      }
    }
  }

  /**
     * @public Called from inner preview frame to control visibility of the frame and loads second url for single doc portals
     **/
  publicAPI.loadPreviewWindow = function() {
    if (_currentComposerWindow != window) {
      _currentComposerWindow.pega.ui.composer.loadPreviewWindow();
    } else if (state == STATES.LOADING) {
      state = STATES.READY;
      // Set the callback for show based on if the portal is single document
      if (_previousPortalURL == null || _previousPortalURL == "") {
        // If not a single document portal then just set title and fade in
        var showCallback = function() {
          // Set the title to that of the inner portal
          document.title = _innerPortalFrame.contentDocument.title;
          // Fade in the iframe
          $(_deviceOutline).css("visibility", "visible").hide().fadeIn(ANIMATION_DURATION,
                                                                       function() {
            // BUG-327052 Set state tracking to done because we aren't really an autogen portal. DO NOT USE THIS AS AN EXAMPLE
            pega.ui.statetracking.setDone();
            // Remove the background mask class
            $(document.body).removeClass("show-background-mask");
            pega.ui.composer.formfactor.load(function() {});
          });
          // Remove the inner frames load event
          $(_innerPortalFrame).off("load", pega.ui.composer.loadPreviewWindow);
        }
        } else {
          // If it is a single document portal then redirect to the original url to maintain state
          var showCallback = function() {
            // Set the title to that of the inner portal
            document.title = _innerPortalFrame.contentDocument.title;
            // Load second URL for single document portals so the state remains
            /*
              commented: publicAPI.replaceWindowURL(_innerPortalFrame.contentWindow, _previousPortalURL);
              replaceWindowURL now encodes the url always, so use location.replace directly as _previousPortalURL is already encoded by server
            */
            $(_innerPortalFrame.contentWindow)[0].location.replace(_previousPortalURL);
          }
        }
      // Call show with callback function for when animation is complete
      _show(showCallback);
    } else if ($(_deviceOutline).css("visibility") == "hidden") {
      $(_deviceOutline).css("visibility", "visible").hide().fadeIn(ANIMATION_DURATION, function() {
        // BUG-327052 Set state tracking to done because we aren't really an autogen portal. DO NOT USE THIS AS AN EXAMPLE
        pega.ui.statetracking.setDone();
        // Remove the background mask class
        $(document.body).removeClass("show-background-mask");
        // Turn on editing when in Pega Express
        if (!_screenLayoutElement.hasClass("slide-transition")) {
          pega.ui.edit.config.toggle();
        }
      });
      // Remove the inner frames load event
      $(_innerPortalFrame).off("load", pega.ui.composer.loadPreviewWindow);
    }
  }

  /**
     * @public Called to load the content of the right panel
     **/
  publicAPI.loadLayoutEditor = function(key, elem) {
    // Make sure left slider panel closes whenever the layout editor is opened
    ExpressExtSlider.closeSlider();
    _showLoading();

    _focusedElement = elem;
    var tempInspectedObject = pega.ui.inspector.utilities.getTempInspectorObject($(_focusedElement));
    // Check if the parent is a flow action and pass param to load to disable configure form button
    var parentInspectorObject = pega.ui.inspector.parser.getNearestParent(tempInspectedObject);

    var isTemplated = tempInspectedObject.get("templated");
    if (isTemplated) {
      $(_focusedElement).addClass("ignore-suppression");
    } else {
      $(_focusedElement).removeClass("ignore-suppression");
    }

    var params = _getParamsForLayoutEditor(parentInspectorObject, tempInspectedObject);
    params.key = key;

    _initializeRuntimeEditor();
    _layoutEditorPanel.loadByClass("Pega-UI-PanelContent-LayoutEditor", function() {
      _layoutEditorPanel.show();
      _loadingIndicator.hide();
    }, params);

    if (publicAPI.isTemplateRuntimeEditorEnabled) {
      _runtimeEditor.clearAllHighlights();
      _runtimeEditor.focusTemplate(_focusedElement, true);
    }
  }

  /**
     * @public Called to load grid content of the right panel
     **/
  publicAPI.loadGridLayoutEditor = function(key, elem) {
    // Make sure left slider panel closes whenever the layout editor is opened
    ExpressExtSlider.closeSlider();
    _showLoading();

    _focusedElement = elem;
    var tempInspectedObject = pega.ui.inspector.utilities.getTempInspectorObject($(_focusedElement));
    // Check if the parent is a flow action and pass param to load to disable configure form button
    var parentInspectorObject = pega.ui.inspector.parser.getNearestParent(tempInspectedObject);

    var isTemplated = tempInspectedObject.get("templated");
    if (isTemplated) {
      $(_focusedElement).addClass("ignore-suppression");
    } else {
      $(_focusedElement).removeClass("ignore-suppression");
    }

    var params = _getParamsForLayoutEditor(parentInspectorObject, tempInspectedObject);

    var cellInspectObject = pega.ui.inspector.parser.getNearestParent(tempInspectedObject, [{
      'type': "Section"
    }]);
    _propertyPanelPgRef = tempInspectedObject.get("pgRef");

    params.cellPath = tempInspectedObject.get("pgRef");
    params.key = cellInspectObject.get("insKey");
    params.hidefooter = true;

    _gridLayoutEditorPanel.getElement().classList.add("grid-layout-panel");
    _gridLayoutEditorPanel.loadByClass("Pega-UI-PanelContent-Grid", function() {
      _gridLayoutEditorPanel.show();
      _loadingIndicator.hide();
    }, params);

    if (_runtimeEditor != null && publicAPI.isTemplateRuntimeEditorEnabled) {
      _runtimeEditor.clearAllHighlights();
      _runtimeEditor.focusTemplate(elem, true);
    }
  }

  /**
     * @public Called to open Property Panel For Grid Layout in the right panel
     **/
  publicAPI.openPropertyPanelForGridLayout = function(cellIndex, insKey) {
    // Get parent insKey needed to show prop panel
    _focusedElement = _runtimeEditor.getFocusedElement();
    var cellInspectObject = pega.ui.inspector.utilities.getTempInspectorObject($(_focusedElement));
    var sectionBodyStartPosition = cellIndex.indexOf(".pyTable.pyRows(2)");
    if (sectionBodyStartPosition > 0) {
      _propertyPanelPgRef = cellInspectObject.get("pgRef");
    } else {
      _propertyPanelPgRef = cellInspectObject.get("pgRef") + ".pySectionBody(2).pyTable.pyRows(2).pyCells("+cellIndex+")";
    }
    var params = {};
    params.cellPath = _propertyPanelPgRef;
    params.key = insKey;
    params.isTableGrid = true;

    _gridPropertyPanel.loadByClass("Pega-UI-PanelContent-PropertyPanel", function() {
      // Disable pagination option for Custom
      var panelElements = _gridPropertyPanel.getElement();
      var customPageSelected = panelElements.querySelector(".table-col-page [value='Custom']:checked");
      var customPageUnselected = panelElements.querySelector(".table-col-page [value='Custom']:not(:checked)");
      if (customPageUnselected !== null) {
        customPageUnselected.disabled = true;
      } else if (customPageSelected !== null) {
        customPageSelected.disabled = true;
      }  
      _gridPropertyPanel.show();
    }, params);

    pega.ui.composer.getComposerPreviewWindow().pega.u.d.detachOnload(_deferLoadRehighlight, true);
  }

  /**
     * @public Called to open Property Panel For Grid column in the right panel
     **/    
  publicAPI.openPropertyPanelForGridColumn = function(cellIndex) {
    // Get parent insKey needed to show prop panel
    var focusedElem = _runtimeEditor.getFocusedElement();
    var cellInspectObject = pega.ui.inspector.utilities.getTempInspectorObject($(focusedElem));
    _propertyPanelPgRef = cellInspectObject.get("pgRef");
    cellInspectObject = pega.ui.inspector.parser.getNearestParent(cellInspectObject, [{
      'type': "Section"
    }]);
    var insKey = cellInspectObject.get("insKey");     
    var params = {};
    params.cellPath = _propertyPanelPgRef;
    params.key = insKey;   
    params.isTableGrid = true;
    params.isTableGridColumn = true;
    params.cellIndex = cellIndex;
    _gridPropertyPanel.loadByClass("Pega-UI-PanelContent-PropertyPanel", function() {
      _gridPropertyPanel.show();
    }, params);

    pega.ui.composer.getComposerPreviewWindow().pega.u.d.detachOnload(_deferLoadRehighlight, true);

  }

  /**
     * Called from top bar device switch buttons to change the device and center it.
     * Sort of a wrapper function to make sure right dock content is closed if it is open.
     *
     * @param $String$ activeClass - Class of the item being selected
     * @param $Integer$ width - new width for the preview
     * @param $Integer$ height - new height for the preview
     * @param $String$ userAgent - The user agent to set inside of the iFrame
     * @param $String$ orientation - the orientation of the device (portrait/landscape)
     */
  publicAPI.switchDevice = function(activeClass, width, height, userAgent, orientation) {
    // immediately hide any parent level panels (they hide their children as well) before the DOM
    // is refreshed, otherwise code is trying to access DOM elements which are no longer there
    if(_layoutEditorPanel){
      _layoutEditorPanel.hide();
    }
    if(_gridLayoutEditorPanel){
      _gridLayoutEditorPanel.hide();
    }

    pega.ui.composer.sendEvent('LiveComposer.stateChange');
    pega.ui.composer.formfactor.switchDevice(activeClass, width, height, userAgent, orientation);
  }

  /**
     * @public Register an event listener that will fire the specified fuction with provided params
     * when an event with the registered name is called
     *
     * @param $String$ strEventName - String value to specify what event to listen for from sendEvent calls.
     * To prevent name collision the name should follow a "." delimited naming convention
     * @param $Object$ objFunction - Function to call when this event listener picks up an event with the given name
     * @param $Object$ objData - Data which will be passed as a parameter to the function this event listener fires
     * @param $String$ scope - Scope of the listener
     **/
  publicAPI.registerEventListener = function(strEventName, objFunction, objData, scope) {
    publicAPI.getCurrentComposerWindow().pega.desktop.registerEventListener(strEventName, objFunction, objData, scope);
  }

  /**
     * @public Removes an event listener that has been previously registered
     *
     * @param $String$ strEventName - String value to specify a listener to remove with the given name
     * @param $Function$ objFunction - Function tied to the event name, used to remove the registered listener
     **/
  publicAPI.cancelEventListener = function(strEventName, objFunction) {
    publicAPI.getCurrentComposerWindow().pega.desktop.cancelEventListener(strEventName, objFunction);
  }

  /**
     * @public Send an event with specified name and data which will be picked up by any listener configured
     * to listen for events with the same name.
     *
     * @param $String$  strEventName - String value to specify what event listener to fire
     * @param $String$  objEventData - Data which will be passed as a parameter to the function fired by the event listener
     * @param $String$  mode - Modes are registered in DesktopEventNames, Default - ASYNC
     *     SYNC= Each registered listener is invoked, in time order of registration, in the current browser thread
     *     ASYNC= Each registered listener is called  in a timeout.  If ObjData is an object reference the sending
     *             must maintain the object beyond the current browser thread.
     *     ASYNC_REPLACE= Replace any in progress ASYNC events to the named event with new ObjData
     *     ASYNC_COPY= ObjData (string or object serialized to a string) is copied to the top desktop window and
     *     sent to each registered listener in a timeout.
     *     ASYNC_COPY_REPLACE= ObjData (string or object serialized to a string) is copied to the top desktop window,
     *     any in progress ASYNC events to the named event are replaced and sent to each registered listener in a timeout.
     * @param $Integer$ delay - delay in millisecs - default=10 millisecs.
     **/
  publicAPI.sendEvent = function(strEventName, objEventData, mode, delay) {
    publicAPI.getCurrentComposerWindow().pega.desktop.sendEvent(strEventName, objEventData, mode, delay);
  }

  /**
     * @public Handles applying suppression to click events in the preview frame
     * @param $Event$ e - The event passed from the event listener this has been applied to
     */
  publicAPI.handleSuppression = function(e) {
    if ($(e.target).closest(".ignore-suppression").length <= 0) {
      if (e.preventDefault) e.preventDefault();
      e.cancelBubble = true;
      if (e.stopPropagation) e.stopPropagation();
      return false;
    }
  }

  /**
     * @public Called by click of page from pages list. This will launch the harness passed 
     *         in preview window in Express.
     * @param $String$ className - "Applies to" class of the harness to be shown
     * @param $String$ harnessName - pyStreamName of the harness to be shown
     * @param $String$ harnessLabel - pyLabel of the harness to be shown
     * @param $Event$ event - The event to be passed when harness is launched
     * @param $Boolean$ launchInUIMode - If would like to be in UI editing mode after launching page pass as true
     */
  publicAPI.openPageInPreview = function(className, harnessName, harnessLabel, event, launchInUIMode) {
    publicAPI.getComposerPreviewWindow().showPortalPage(className, harnessName, harnessLabel, event);
    formFactorIframe.showFormFactorIframe(); /*Epic-33387: Whenever formfactor is shown this method should be called*/
    if (launchInUIMode) {
      publicAPI.toggleUIMode(true);
    }
  }

  /**
     * @public Add a class selector when a page item is hovered on in the left panel
     * @param $Event$ e - The event passed from the event listener this has been applied to
     */
  publicAPI.selectPageItem = function (evt) {
    var target = evt.target;
    if ($(target).closest('.page-info-row').length > 0) {
      var pageRow = $(target).closest('.page-info-row')[0];
      var pageParent = $(pageRow).closest('.page-info-list')[0];
      $(pageParent).find(".selected").removeClass("selected");
      $(pageRow).addClass("selected");
    }
  }

  /**
     * @public Toggles the page panel for infinity only application.  This
     * feature is turned off for hybrid and constellation applications.
     *
     */
  publicAPI.toggleUIDesignTopPanel = function() {
    
    if(typeof _uiDesignTopPanel === "undefined"){
      return;
    }
    if (_isInUIMode) {
      publicAPI.showUIDesignTopPanel();
    }
    else {
      publicAPI.hideUIDesignTopPanel();
    }
    
  }
  /**
     * @public Toggles the UI mode used for runtime editing. Note that this method has an implmented
     * the override functionality of toggling due to the toggle method not supporting it in IE11.
     * @param $Boolean$ to override the toggle - if passed true then it adds class, if false removes it
     *
     */
  publicAPI.toggleUIMode = function(override) {
    if ( (typeof _layoutEditorPanel === "undefined" && typeof _gridLayoutEditorPanel === "undefined") || (!_layoutEditorPanel.isShowing() && !_gridLayoutEditorPanel.isShowing()) 
        || (typeof _layoutEditorPanel !== "undefined" && _layoutEditorPanel.isShowing()) || (typeof _gridLayoutEditorPanel !== "undefined" && _gridLayoutEditorPanel.isShowing()) ) {            

      // toggle the _isInUIMode value if override is undefined (jasmine) or not specified
      // override is passed as "" from the autogen run script in the ruleform icon on click

      if(typeof override === 'undefined' || override === "") {
        _isInUIMode = !_isInUIMode;                             
      } else { // otherwise swap UI mode
        _isInUIMode = override;
      }

      _toggleConfigureLink(!_isInUIMode);

      var uiEditModeButtonSelector = ".ui-edit-mode-button";
      var uiEditModeClass = "in-edit-mode";
      var currentComposerWindow = publicAPI.getCurrentComposerWindow();

      //Just do these toggles once, i.e. not for every frame
      if (_isInUIMode) {
        // add class for blue highlight to button
        $(uiEditModeButtonSelector).addClass(uiEditModeClass);
        // add class to slide left when design mode is ON
        currentComposerWindow.document.querySelector("aside").classList.add("hide-left-nav");
        currentComposerWindow.document.querySelector("main").classList.add("slide-left");
      } else {
        // remove class for blue highlight from button
        $(uiEditModeButtonSelector).removeClass(uiEditModeClass);
        // remove class to slide back when design mode is OFF
        currentComposerWindow.document.querySelector("aside").classList.remove("hide-left-nav");
        currentComposerWindow.document.querySelector("main").classList.remove("slide-left");
        if (typeof _pagesPanel !== "undefined" && _pagesPanel.isShowing()) {
          _pagesPanel.hide();
        }

        if (typeof _layoutEditorPanel !== "undefined" && _layoutEditorPanel.isShowing()) {
          _layoutEditorPanel.hide();
        }
        if (typeof _gridLayoutEditorPanel !== "undefined" && _gridLayoutEditorPanel.isShowing()) {
          _gridLayoutEditorPanel.hide();
        }
        
        // hide top bar
        publicAPI.toggleUIDesignTopPanel();
      }

      if (window === currentComposerWindow) {
        if (_isInUIMode && _runtimeEditor === null) {
          _initializeRuntimeEditor();
          _runtimeEditor.showHighlightForEditableContent();
          //TODO might need something like this _enableAllInteractions(); 
        } else if (!_isInUIMode && _runtimeEditor) {
          _runtimeEditor.destroy();
          _runtimeEditor = null;
        }
      }
    } 
  }

  /**
     * @public Getter method for ui mode state
     */
  publicAPI.isInUIMode = function() {
    if (_currentComposerWindow != window) {
      return publicAPI.getCurrentComposerWindow().pega.ui.composer.isInUIMode();
    } else if(_isInUIMode) {
      return _isInUIMode;
    } else {
      return false
    }
  }

  /**
     * @public toggles the work area tree in the layout editor panel
     */
  publicAPI.toggleSectionTreeOverlay = function() {
    if(_sectionTreeOverlay === null) {
      var sectionTreeOverlayOptions = {};
      sectionTreeOverlayOptions.hoverCallback = function(element) {_runtimeEditor.hoverElement(element);};
      sectionTreeOverlayOptions.dehoverCallback =  function() {_runtimeEditor.dehoverElement();};
      sectionTreeOverlayOptions.focusCallback =  function(element) {_runtimeEditor.focusTemplate(element);};
      sectionTreeOverlayOptions.contextWindow =  pega.ui.composer.getComposerPreviewWindow();                              
      _sectionTreeOverlay = new pega.ui.designtemplate.SectionTreeOverlay(_layoutEditorPanel.getElement(), sectionTreeOverlayOptions);      
    }

    //set the tree's location based on which panel is showing
    var elementContentLocation = null;

    if(_layoutEditorPanel && _layoutEditorPanel.isShowing()){
      elementContentLocation = _layoutEditorPanel.getElement();
    } else if(_gridLayoutEditorPanel && _gridLayoutEditorPanel.isShowing()){
      elementContentLocation = _gridLayoutEditorPanel.getElement();
    }
    _sectionTreeOverlay.setTreeLocation(elementContentLocation);

    _sectionTreeOverlay.toggle(_runtimeEditor.getFocusedElement()); 
  }

  /**
     * @public Refreshes the state as needed for the blue-dashed UIMode highlighting.
     * This function is called when you navigate or refresh items in APP studio,
     * and is needed in order to keep the UIMode highlighting in sync.
     */
  var _updateUIModeHighlighting_TimeoutResponse;
  publicAPI.updateUIModeHighlighting = function() { 
    if(pega.ui.composer.isActive()){
      var composerMashupWindow = pega.ui.composer.getComposerPreviewWindow();
      if (composerMashupWindow.pega && composerMashupWindow.pega.web 
          && composerMashupWindow.pega.web.isWebMashup && composerMashupWindow.frames.length > 0) {
        var mashupFrame = composerMashupWindow.frames[0].document;
        mashupFrame.body.classList.add("mashup-preview-body");
      }
      if(pega.ui.composer.isInUIMode()) {
        if (_currentComposerWindow != window) {
          publicAPI.getCurrentComposerWindow().pega.ui.composer.updateUIModeHighlighting();
        }
        // show highlighting unless we have a focused template (layout editor is open)
        else if (!_runtimeEditor.getFocusedTemplate()) {
          // BUG-403777 Since composer_bar loads in all harness frames, there are refresh scenarios where this "onload" function
          // gets called from multiple frames and causes a race condition issue. Using setTimeout/clearTimeout to ensure the
          // re-highlight code is called only once
          clearTimeout(_updateUIModeHighlighting_TimeoutResponse);
          _updateUIModeHighlighting_TimeoutResponse = setTimeout(function() {
            // BUG-422496: Verify that the layout editor is not appearing before toggling on the workarea highlights. This is to
            // prevent a race condition from occurring when clicking Apply in the property panel. The content refreshes and tries to 
            // refocus the cell; however, because this function is called on harness changes (pega.u.d.attachOnload below), the below 
            // logic would commence, removing the focus cell and revealing workarea highlights.
            // BUG-424590 don't start runtime editor in a window you have lost context of
            // BUG-485022: Updated to account for grid layout editor scenarios
            if(!_layoutEditorPanel.isShowing() && !_gridLayoutEditorPanel.isShowing() && pega.ui.composer.getComposerPreviewWindow() && pega.ui.composer.getComposerPreviewWindow().pega) {
              _initializeRuntimeEditor();
              _runtimeEditor.showHighlightForEditableContent();
              _toggleConfigureLink(false);
            }
          }, 100);
        }              
      }  
    }
  }

  /* @public Called to submit changes made for controls and section in the right panel 
     * as well as page settings modal in pages panel
     **
     * @param $String$ sectionName - Section to reload when there are errors
     * @param $String$ isError - error message
     * @param $Event$ event - The event to be passed from modal
     * @param $Boolean$ saveIt - to save section in layout editor
     * @param $String$ bReload - set value if the preview portal needs to be reloaded
     */
  publicAPI.submitChangesForPanel = function(sectionName, isError, event, saveIt, bReload) {  
    if (isError !== "") {
      var sectionNode = pega.u.d.getSectionByName(sectionName, "", document);
      pega.u.d.reloadSection(sectionNode, "", "", false, false, -1, false, null, null, null, null);        
    } else {        
      var submitModalDlgParam = pega.u.d.submitModalDlgParam;
      if (submitModalDlgParam) {
        if (pega.u.d.bModalDialogOpen){
          doModalAction(pega.u.d.submitModalDlgParam, event);
        }
      }
      if(saveIt != null){
        pega.ui.composer.sendEvent("LayoutEditor.save");
      }
      if (bReload) {
        pega.ui.composer.formfactor.reloadPreview(bReload);
      }
    }
  }
  /* @public Called to position arrow for the add view overlay
     **/    
  publicAPI.positionAddViewOverlayArrow = function() { 
    pega.ui.composer.removeAddViewOverlayArrow();
    var popOverElement = pega.u.d.getPopOver().getActivePopOverElement();
    var arrowElement = popOverElement.querySelector(".po-arrow-hide");
    var offsetForCurrentRow = Math.round($(_addViewSelectedRowPosition).offset().top 
                                         - $(_addViewSelectedRowPosition).offsetParent().offset().top) + 30; 

    if (!arrowElement.classList.contains("add-arrow")) {
      arrowElement.classList.add("add-arrow");
    }

    if(popOverElement.offsetTop > offsetForCurrentRow) {         
      arrowElement.classList.add("to-right");         
    } else {
      arrowElement.classList.add("to-left");
    }
  }

  /* @public Called to remove arrow pointer
     **/    
  publicAPI.removeAddViewOverlayArrow = function() {
    var popOverElement = pega.u.d.getPopOver().getActivePopOverElement();
    if (popOverElement !== null) {
      var toBeRemoved = popOverElement.querySelector(".overlayPO .to-right");
      if (toBeRemoved != null) {
        toBeRemoved.classList.remove("to-right");
      }

      toBeRemoved = document.querySelector(".overlayPO .to-left");
      if (toBeRemoved != null) {
        toBeRemoved.classList.remove("to-left");
      }
    }
  } 

  publicAPI.getSelectedRuntimeEditorTemplate = function() {
    if(_runtimeEditor) {
      return _runtimeEditor.getFocusedTemplate();
    }
    return null;
  }

  return publicAPI;
}());

try {
  // Override Desktop Window
  if (window.name == "FormFactoriFrame") { // If in preview frame
    pega.desktop.support.setDesktopWindow(window);
  } else if (parent.name == "FormFactoriFrame") { // If loading inside of the preview frame
    pega.desktop.support.setDesktopWindow(parent);
  }
} catch (e) {
  // Do nothing if inside of other iframe
}

window.addEventListener("load", function() {
  pega.ui.composer.initialize();
});

// check if ui mode highlighting should be updated when the ui is loaded
pega.u.d.attachOnload(function() {
  // BUG-424590 additional check before calling updateUIModeHighlighting to avoid scenarios
  // where it is unnecessarily called 
  if(pega.ui.composer.getCurrentComposerWindow() != window) {
    pega.ui.composer.updateUIModeHighlighting();  
  }      
}, true);
//static-content-hash-trigger-GCC
var $pNamespace = pega.namespace;
$pNamespace("pega.ui.composer");

pega.ui.composer.formfactor = (function () {
    var publicAPI = {};
    /////////////////////////////////////////////////////////////////////////////////
    //                                  CONSTANTS                                  //
    /////////////////////////////////////////////////////////////////////////////////
    var ANIMATION_DURATION = 500;

    /////////////////////////////////////////////////////////////////////////////////
    //                                   GLOBALS                                   //
    /////////////////////////////////////////////////////////////////////////////////
    /* -- PRIVATE GLOBALS -- */
    var _currentPreviewWindow; // Current preview window if in preview mode

    var _dynamicContainerTab; // The dynamic container tab that the device lives in
    var _deviceOutline; //Outer Div that contains _deviceIFrame
    var _deviceIFrame; // IFrame that contains the preview of original content
    var _previewElement; // Mask that shows where the preview will be displayed

    var _deviceResolutionText; // span that contains the resolution text
    var _deviceResolutionElement; // Div that contains the resolution label and text

    var _previousUserAgent = window.navigator.userAgent; // Previous user agent used to prevent user agent from being set
    var _currentUserAgent = window.navigator.userAgent; // Current user agent

  	var _currentDeviceWidth; // Caches off the actual width (in pixels) of the device
  	var _currentDeviceHeight; // Caches off the actual height (in pixels) of the device
  
    /* -- PUBLIC GLOBALS -- */

    /////////////////////////////////////////////////////////////////////////////////
    //                              PRIVATE FUNCTIONS                              //
    /////////////////////////////////////////////////////////////////////////////////
    /** _getEventTarget - get the target of the given event
     * @param e - event object
     **/
    function _getEventTarget(e) {
        var tg = null;
        if (!e) var e = window.event;
        if (e && e.target) tg = e.target;
        else if (e && e.srcElement) tg = e.srcElement;
        return tg;
    }

    /** _resizeElement - Animate the given element to the given size
     * @param element - element to animate
     * @param width - new width for the element
     * @param height - new height for the element
     **/
    function _resizeElement(element, width, height) {
        // Set the overflow to hidden durring the animation to get rid of scrollbars
        $(_dynamicContainerTab).css('overflow', 'hidden');

        var pixelWidth = width, pixelHeight = height;
        // If going to full screen then we need to get pixel dimensions for calculations
        if (width == "100%" && height == "100%") {
            pixelWidth = $(_dynamicContainerTab).innerWidth();
            pixelHeight = $(_dynamicContainerTab).innerHeight();
        }

        // Set resolution text
        $(_deviceResolutionText).html(pixelWidth + "x" + pixelHeight);
        _deviceResolutionElement.style.display = "block";
        
        //Set margin to resolution text in case of mashup
        _toggleMashupOptionsAndSetMargin("deviceResolution","show");
          
        // Set new top value for preview pane
        var NewTop = Math.floor(($(window).height() - $(".composerbar").height() - pixelHeight) / 6);
        if (NewTop < 0) NewTop = 0;

        // Animate the new size and location
        element.style.width = (width.indexOf("%") > 0) ? width : width + "px";
        element.style.height = (height.indexOf("%") > 0) ? height : height + "px";
        element.style.top = NewTop + "px";
      
        // remove overflow after transition ends
        setTimeout(function () {
            _dynamicContainerTab.style.removeProperty("overflow");
        }, ANIMATION_DURATION);
    }

    /** _clearPreview - Clears the mask that is displaying the preview on hover and remove temp event
     * @param e - event object
     **/
    function _clearPreview(e) {
        // Find the target and remove the mouse out
        var tg = _getEventTarget(e);
        if (tg) {
            tg.removeEventListener("mouseout", _clearPreview);
        }

        // If not animating the iframe then set back the size
        if (!$(_deviceOutline).is(':animated')) {
            $(_deviceResolutionText).html(_currentDeviceWidth + "x" + _currentDeviceHeight);
        } 

        $(_previewElement).css({
            'display': 'none',
            'z-index': '2'
        });
    }

    /** _setUserAgent - Set user agent of the inner frame when it has changed from what it currently is
     * @param $String$ userAgent - User Agent to switch to
     **/
    function _setUserAgent(userAgent) {
		    // used to set the user agent if the content window is not yet loaded
		    var loadHandler = function() {
			      _setUserAgent(userAgent);			
		    };
	
		    // remove the previous handlers that may be in queue
		    // so that we don't accidentally overwrite the most current call
		    $(_deviceIFrame.contentWindow).unbind('load', loadHandler);
	
        _currentUserAgent = window.navigator.userAgent;

        // If there is a userAgent passed in then set it to that
        if (userAgent) {
            _currentUserAgent = userAgent;
        }

        // If trying to change to the same user agent then return
        if (_previousUserAgent == _currentUserAgent) {
            return;
        }

		    // If the window isn't finished loading call this function again once it is
		    if(_deviceIFrame.contentWindow.document.body == null) {
			      $(_deviceIFrame.contentWindow).bind('load', loadHandler);			
		    } else {
			      //Adding a mask to the screen to prevent any interaction with page while switching preview
			      var tempMask = _deviceIFrame.contentWindow.document.createElement("div");
			      $(tempMask).css({position:"fixed", top:"0", left:"0", bottom:"0", right:"0", "z-index":"1000"});
			      _deviceIFrame.contentWindow.document.body.appendChild(tempMask);
			      _previousUserAgent = _currentUserAgent
			
			      // Call server to set the user agent
			      var actionURL = new SafeURL("pzFormFactorSetUserAgent");
			      actionURL.put("UserAgentOverride", _currentUserAgent);
            if(_deviceIFrame.contentWindow.pega && _deviceIFrame.contentWindow.pega.util){
              _deviceIFrame.contentWindow.pega.util.Connect.asyncRequest("POST", actionURL.toURL(), {
                success: function (o) {
                  _deviceIFrame.contentWindow.pega.u.d.ignoreDirty = "true";
                  publicAPI.reloadPreview();         
                }
              });		
            }else{
              // BUG-606316: reload preview of c11n portals by native localtion reload.
              _deviceIFrame.contentWindow.location.reload(true);
            }
		    }
    }

    /** _handleWindowResize - repositions the formfactor preview iframe to be centered
     **/
    function _handleWindowResize() {
        // If set to desktop make sure to set to 100% after animation
        if ($(".icon-laptop.formfactor-active").length > 0) {
            if(_deviceOutline) {
                _deviceOutline.style.width = "100%";
                _deviceOutline.style.height = "100%";
            }
        } else {
            // Resize the iframe only if window size actually changed, otherwise
            // resizing the iframe will trigger more window resize events in IE9.
            // The resize below handles all the positioning so resize as the same size.
            _resizeElement(_deviceOutline, _currentDeviceWidth, _currentDeviceHeight);
        }
    }

    /** _handleWindowUnload - handles setting user agent back if the window is unloaded
     **/
    function _handleWindowUnload(e) {
        if (pega.ui.composer.isActive() && _currentUserAgent != window.navigator.userAgent) {
            // Call server to se the user agent
            //var actionURL = new SafeURL("pzFormFactorSetUserAgent");
            var actionURL = new SafeURL("pzFormFactorWindowUnload");
            actionURL.put("UserAgentOverride", window.navigator.userAgent);
            _deviceIFrame.contentWindow.pega.util.Connect.asyncRequest("POST", actionURL.toURL(), {
                success: function (o) {
                    // Do not reload as it will close the portal window when launched from DS
                    if (window.opener) {
                        window.opener.location.reload(true);
                    }
                }
            });
        }
    }
    

    /////////////////////////////////////////////////////////////////////////////////
    //                               PUBLIC FUNCTIONS                              //
    /////////////////////////////////////////////////////////////////////////////////
    publicAPI.init = function () {
        _currentPreviewWindow = publicAPI.getCurrentPreviewWindow();

        if (_currentPreviewWindow == window) {
            // Get a handle on cached elements
            _dynamicContainerTab = $(".app-studio main.screen-layout-region-main")[0];
            _deviceIFrame = document.getElementById("FormFactoriFrame");
            _deviceOutline = $(".deviceOutline")[0];
            $(_deviceOutline).addClass("laptop-margin");
            
            _toggleMashupOptionsAndSetMargin("deviceOutline","show");

            if (_deviceIFrame != null) {
                _previewElement = document.getElementById("FormFactorPeviewMask");
                _deviceResolutionText = document.getElementById("FormFactorPreviewResolutionText");
                _deviceResolutionElement = document.getElementById("FormFactorPreviewResolution");

                window.addEventListener("resize", _handleWindowResize, true);
                window.addEventListener("beforeunload", _handleWindowUnload, true);
            }
        }
    }

    /** getCurrentPreviewWindow - loops up the parent windows and finds the top most preview window
     **/
    publicAPI.getCurrentPreviewWindow = function() {
        if( window.pega.d.pzUnitTestPKey == "pxExpress") return window;
        var TempWindow = window;
        var PreviousWindow;
        try {
            while (TempWindow.parent != null && TempWindow != PreviousWindow && TempWindow.parent.pega && TempWindow.parent.pega.ui && TempWindow.parent.pega.ui.composer && TempWindow.parent.pega.ui.composer.formfactor) {

                PreviousWindow = TempWindow;
                TempWindow = TempWindow.parent;
                if(TempWindow.pega.d.pzUnitTestPKey == "pxExpress") return TempWindow;
            }
        } catch (e) {
            // Do nothing
        }

        return TempWindow;
    }

    /** defaultPreview - Called from pega.ui.composer.toggle to retrieve the formfactor settings from the server
     *
     * @param callback - callback function to be called when the asyncRequest finishes
     **/
    publicAPI.load = function (callback) {
        if (_currentPreviewWindow != window) {
            _currentPreviewWindow.pega.ui.composer.formfactor.load(callback);
        } else {
            // Calls the server to retrieve information for settings
            var postURL = new SafeURL("Data-Portal.pzDevicePreview_GetSettings");
            //TODO: Not a real fall back for when in offline mode. This will not work well
            if (pega && !pega.offline) pega.util.Connect.asyncRequest("POST", postURL.toURL(), {
                success: function (o) {
                    var settings = eval("(" + o.responseText + ")")

                    // Defaults the preview size based on what was stored on the server
                    if (settings.pySelectedDevice == "phone") {
                        publicAPI.switchDevice("icon-mobile-phone", settings.pySelectedPhone.pyWidth, settings.pySelectedPhone.pyHeight, settings.pySelectedPhone.pyUserAgent, settings.pyPhoneOrientation)
                    } else if (settings.pySelectedDevice == "tablet") {
                        publicAPI.switchDevice("icon-tablet", settings.pySelectedTablet.pyWidth, settings.pySelectedTablet.pyHeight, settings.pySelectedTablet.pyUserAgent, settings.pyTabletOrientation)
                    }

                    // Called after the async request finishes
                    callback()
                },
                failure: function (o) {
                    callback()
                }
            });
            
          if(pega && pega.ui && pega.ui.ChangeTrackerMap) {
            var CTDiv = pega.ui.ChangeTrackerMap.getTracker();
            var appSettings = CTDiv.trackedPropertiesList["D_pzAppViewSettings"];
            if (appSettings && appSettings.pySelectedChannelClass == "Pega-Landing-AppView-Mashup") {
                      _toggleMashupOptionsAndSetMargin("mashupOptions","show");
                    } 
          }
        }
    }
    
    /**
     * public api to toggle the display of mashup preview options
     *
     */ 
    publicAPI.toggleMashupOptionsAndSetMargin = function (divName, classValue) {
      _toggleMashupOptionsAndSetMargin(divName, classValue);
    }
      
      
    _toggleMashupOptionsAndSetMargin = function (divName, classValue) {
      var mashupOptDiv = document.getElementsByClassName("mashupOptDiv")[0];
      var deviceOutlines = document.getElementsByClassName("deviceOutline");

      if (divName=="mashupOptions" && classValue=="show"){
        if(mashupOptDiv){
             mashupOptDiv.classList.remove("hidden");
             mashupOptDiv.classList.remove("hide");
             mashupOptDiv.classList.add("show");
        }
        if(_deviceOutline && mashupOptDiv){
             _deviceResolutionElement.style.marginTop = "55px";
                 if (deviceOutlines[0].className.indexOf("landscape") != -1 || deviceOutlines[0].className.indexOf("portrait") != -1)  {
                     deviceOutlines[0].style.marginTop= "110px";
                 } 
                 else {
                     deviceOutlines[0].style.marginTop= "80px";
                 }
        }
      }else if (divName=="mashupOptions" && classValue=="hide"){
        if(mashupOptDiv){
          mashupOptDiv.classList.remove("show");
          mashupOptDiv.classList.add("hide");
        }
        if(_deviceOutline && mashupOptDiv){
          _deviceOutline.style.marginTop = "";
          if (deviceOutlines[0].className.indexOf("landscape") === -1 && deviceOutlines[0].className.indexOf("portrait") === -1) 
          _deviceOutline.style.height= "100%";
          _deviceResolutionElement.style.marginTop = "";
        }
      }else if (divName=="deviceOutline" || divName=="deviceResolution"){
        if(mashupOptDiv && mashupOptDiv.className.indexOf("show") !== -1){
          if(_deviceOutline && _deviceResolutionElement){
                 _deviceResolutionElement.style.marginTop = "55px";
                 if (_deviceOutline.className.indexOf("landscape") !== -1 || deviceOutlines[0].className.indexOf("portrait") !== -1)  {
                     _deviceOutline.style.marginTop= "110px";
                 } 
                 else {
                     _deviceOutline.style.marginTop= "80px";
                 }
        }
        }
        else {
          if(_deviceOutline && _deviceResolutionElement){
          _deviceOutline.style.marginTop= "";
            if (deviceOutlines[0].className.indexOf("landscape") === -1 && deviceOutlines[0].className.indexOf("portrait") === -1) 
          _deviceOutline.style.height= "100%";
          _deviceResolutionElement.style.marginTop = "";
          }
        }
      }
      
      if(mashupOptDiv && mashupOptDiv.className.indexOf("show") !== -1){
        _deviceResolutionElement = document.getElementById("FormFactorPreviewResolution");
        _deviceResolutionElement.style.display = "none";    
        if (_deviceOutline.className.indexOf("landscape") !== -1 || deviceOutlines[0].className.indexOf("portrait") !== -1)  {
          _deviceOutline.style.marginTop= "135px";
        } 
        else {
          _deviceOutline.style.marginTop= "80px";
          if (_deviceOutline.className.indexOf("landscape") === -1 && deviceOutlines[0].className.indexOf("portrait") === -1)
          _deviceOutline.style.height= "calc(100% - 80px)";
        }
      } 
    }

    /** switchDevice - If not in preview mode redirect the window calling preview activity. If in preview mode call preview on preview window
     * @param $String$ activeClass - Class of the item being selected
     * @param $Integer$ width - new width for the preview
     * @param $Integer$ height - new height for the preview
     * @param $String$ userAgent - The user agent to set inside of the iFrame
     * @param $String$ orientation - the orientation of the device (portrait/landscape)
     **/
    publicAPI.switchDevice = function (activeClass, width, height, userAgent, orientation) {      
        if (_currentPreviewWindow != window) {
            _currentPreviewWindow.pega.ui.composer.formfactor.switchDevice(activeClass, width, height, userAgent, orientation);
        } else {
            _setUserAgent(userAgent);

            var CurrentButton = $("." + activeClass);
          
            var tempMouseOut = function () {
                CurrentButton.removeClass("temp-no-rotate");
                CurrentButton.off("mouseout", tempMouseOut);
            }

            // If the current button is not set to horizontal but there are others set then clear the class
            if ($(".formfactor-horizontal").length > 0 && !CurrentButton.hasClass("formfactor-horizontal")) {
                $(".formfactor-horizontal").removeClass("formfactor-horizontal");
            }

            // If clicking an icon with no-rotate and its active drop out
            if (CurrentButton.hasClass("formfactor-active") && CurrentButton.hasClass("no-rotate")) {
                return;
            }

            // Add mouse out that controls if the icon should be flipped again only add if it does not have the no-rotate class
            if (!CurrentButton.hasClass("no-rotate") && !CurrentButton.hasClass("temp-no-rotate")) {
                CurrentButton.addClass("temp-no-rotate");
                CurrentButton.on("mouseout", tempMouseOut);
            }
            // Clean up classes before orientation logic
            $(_deviceOutline).removeClass("portrait");
            $(_deviceOutline).removeClass("landscape");
            $(_deviceOutline).addClass("addMargin");
            $(_deviceOutline).removeClass("laptop-margin");
 
            // Add classes based on orientation
            if (orientation == "landscape") {
                var tempWidth = width;
                var tempHeight = height;
                height = tempWidth;
                width = tempHeight;
              
                CurrentButton.addClass("formfactor-horizontal");
                $(_deviceOutline).addClass("landscape");
                _toggleMashupOptionsAndSetMargin("deviceOutline","show");
                
            } else if (orientation == "portrait") {
                CurrentButton.removeClass("formfactor-horizontal");
                $(_deviceOutline).addClass("portrait");
                _toggleMashupOptionsAndSetMargin("deviceOutline","show");
            } else {
                $(_deviceOutline).removeClass("addMargin");
            }
          
            // Set the global caching variables to the actual pixels of the device (obtain actual pixel values for full-screen 100% width/height)
          	_currentDeviceWidth = (width == "100%") ? $(_dynamicContainerTab).innerWidth() - 28 : width;
          	_currentDeviceHeight = (height == "100%") ? $(_dynamicContainerTab).innerHeight() - 28 : height;
          
            // Blindly take off any active class and re apply
            $(".formfactor-active").removeClass("formfactor-active");
            CurrentButton.addClass("formfactor-active");

            // Animate the new size and location
            _clearPreview();
            _resizeElement(_deviceOutline, width, height);

            if(activeClass === "icon-laptop") {
              $(_deviceOutline).addClass("laptop-margin");
              _toggleMashupOptionsAndSetMargin("deviceOutline","show");
            }    
        }
    }

    /** preview - Display a div showing where the new preview will be by calling showPreview on _currentPreviewWindow
     * @param $Event$ e - event object
     * @param $Integer$ width - new width for the preview
     * @param $Integer$ height - new height for the preview
     * @param $String$ orientation - ** The CURRENT orientation of the device
     **/
    publicAPI.preview = function (e, width, height, orientation, previewDevice, selectedDevice) {
        if (_currentPreviewWindow != window) {
            _currentPreviewWindow.pega.ui.composer.formfactor.preview(e, width, height, orientation, previewDevice, selectedDevice);
        } else {
          
            // Find the target and add a mouse out to clear the preview
            var tg = _getEventTarget(e);

            //If hovering over the same element selected that cannot be "rotated" then ignore
            if ($(tg).hasClass("no-rotate") && $(tg).hasClass("formfactor-active")) {
                return;
            }

            // Add mouse out to clear preview when leaving icon
            if (tg) {
                tg.addEventListener("mouseout", _clearPreview);
            }

            // 1. If previewing the same device and currently in portrait orientation then switch landscape
            // 2. If not the same device but the preview is in landscape then make sure to switch
            if ((previewDevice == selectedDevice && orientation == "portrait") ||
                (previewDevice != selectedDevice && orientation == "landscape")) {
                var tempWidth = width;
                var tempHeight = height;
                height = tempWidth;
                width = tempHeight;
            }

            // If previewing full screen remove margin from element to align it to the top
            if (height == "100%") {
                $(_previewElement).removeClass("addMargin");
            } else {
                $(_previewElement).addClass("addMargin");
            }

            // Set up default css for mask
            $(_previewElement).css({
                'width': $(_deviceIFrame).width(),
                'height': $(_deviceIFrame).height(),
                'top': $(_deviceOutline).css('top'),
                'display': 'inline',
                'z-index': '3'
            });

            // Animate the new size and location
            _resizeElement(_previewElement, width, height);
        }
    }

    /** reloadPreview - Reload the current preview
     * @param bReload - Optional flag to not reload
     **/
    publicAPI.reloadPreview = function (bReload, previewContentWindow) {
        if (bReload == null || bReload == true) {
            /**
             *  Need to determine the state of the inner document.   5
             *  If the inner document its isSDM and the URL contains FinishAssignment we to to force a refresh
             *
             **/
          	var previewWindow = previewContentWindow || _deviceIFrame.contentWindow;

            //if single document portal && work object is open
            if (previewWindow.pega && // is Infinity portal if this is defined
                previewWindow.pega.ui.NavigateTopHandler &&  //single doc portal
                !previewWindow.pega.u.d.isNew() &&  //not the new harness
                !previewWindow.pega.u.d.bIsDCSPA && //not a dynamic container single page application (BUG-299600)
                (previewWindow.strHarnessMode == "ACTION"  || previewWindow.pega.u.d.isConfirm() || previewWindow.pega.u.d.isReview())) { //perform harness or confirm harness or review harness
                // Send a refresh event to the work object
                previewWindow.pega.c.Actions.prototype.refresh("currentharness", "", "RefreshOnConflicts", "&=", "", ",", previewWindow.document, "1", "pyWorkPage");
            } else {
                previewWindow.location.reload(true);
            }
        }
    }

    /** getDeviceWindow - loops up the parent windows and finds the top most device window
     **/
    publicAPI.getDeviceWindow = function() {
        if (_currentPreviewWindow != window) {
            _currentPreviewWindow.pega.ui.composer.formfactor.getDeviceWindow();
        } else {
            return _deviceIFrame.contentWindow;
        }
    }

     /** changePortal - Load the portal preview with a new portal passed in
     * @param strNewPortal - key of the portal
     **/
    publicAPI.changePortal = function (strNewPortal) {
        if (strNewPortal != null) {
            //Build a url with new portal name to load into the content window.
            var oSafeURL = new SafeURL("Data-Portal.pzShowSelectedPortalForComposer");
            oSafeURL.put("portal", strNewPortal);
            oSafeURL.put("Name", strNewPortal);
            oSafeURL.put("ThreadName", "OpenPortal_InnerLive");
            oSafeURL.put("developer", false);
            oSafeURL.put("isLaunchedByLiveComposer",true);
            oSafeURL.put("isLiveComposerEditingOn", true);
            oSafeURL.put("isPreviewFrame",true);       

            // Build the base RedirectAndRun url to show portal
            var redirectAndRunURL = new SafeURL("Embed-PortalLayout.RedirectAndRun");
            redirectAndRunURL.put("ThreadName", "OpenPortal_InnerLive");
            redirectAndRunURL.put("bPurgeTargetThread", true);
            redirectAndRunURL.put("bEncodeLocation", true);
            redirectAndRunURL.put("Location", oSafeURL.toQueryString());
            _deviceIFrame.contentWindow.location = redirectAndRunURL.toURL();

            pega.ui.composer.sendEvent("LiveComposer.stateChange");
            pega.ui.composer.sendEvent("LiveComposer.startLoading");
        }
    }
    
    publicAPI.copyToClipBoard = function (event, testid) {
      var copyTextarea = document.querySelector("[data-test-id=" + testid + "]");
      copyTextarea.select();
      try {
          var successful = document.execCommand('copy');
          var msg = successful ? 'successful' : 'unsuccessful';
         // console.log('Copying text command was ' + msg);
      } catch (err) {
        console.log('Oops, unable to copy due to error '+err);
      }
    }
    
    /** previewChannel - Load the portal preview with the mashup template portal if the objclass passed 
    *                  is the Mashup objclass, otherwise fall back on regular changePortal
    * @param strChannelId - key for the channel/portal
    * @param strObjClass - objclass for the channel/portal
    * @param strExternalWebsiteURL - external website URL
    * @param strIsPreviewInPopup - flag to preview in popup
    **/
    publicAPI.previewChannel = function (strChannelId, strObjClass, strExternalWebsiteURL, strIsPreviewInPopup) {
      if (strObjClass === "Pega-Landing-AppView-Mashup") {
       _toggleMashupOptionsAndSetMargin("mashupOptions","show");
        
        if(strExternalWebsiteURL) {
            var loadExternalURL = new SafeURL();            
            loadExternalURL.put("hostPath", strExternalWebsiteURL);
          
          if(strIsPreviewInPopup == "true") {
            loadExternalURL.put("pyActivity", "@baseclass.pzProcessURLInWindow");
            loadExternalURL.put("pyPreActivity", "@baseclass.pzInvokeExternalURLLoader");
            openUrlInWindow(loadExternalURL.toURL());

          } else {            
            loadExternalURL.put("pyActivity", "@baseclass.pzInvokeExternalURLLoader");
            
            _deviceIFrame.contentWindow.location = loadExternalURL.toURL();

            pega.ui.composer.sendEvent("LiveComposer.stateChange");
            pega.ui.composer.sendEvent("LiveComposer.startLoading");
          }

        } else {
          pega.ui.composer.formfactor.changePortal("pzMashupComposerPreviewTemplate");
        }
      } else {
        //hide mashup preview options div
        _toggleMashupOptionsAndSetMargin("mashupOptions","hide");
        // by default do a change portal if not a mashup
        pega.ui.composer.formfactor.changePortal(strChannelId);
      }
    }
    return publicAPI;
}());
//static-content-hash-trigger-GCC
//<script>
pega.namespace("pega.tools");

if (typeof pega.tools.useWgx == "undefined")
{
	pega.tools.useWgx = false;
	if ("ActiveXObject" in window)
	{
		try
		{
			new ActiveXObject("Microsoft.XMLDOM");
		}
		catch (e)
		{
			pega.tools.useWgx = true;
			$.ajax
			({
				url: "webwb/pzWickedGoodXpath.js",
				dataType: "script",
				success: function(data, textStatus, jqXHR) { wgxpath.install(); },
				async: false
			});
		}
	}
}

pega.tools.normalizeXpath = function(xPath){
      if (!pega.tools.XMLDocumentUseZeroBasedIndex || "ActiveXObject" in window){
            return xPath;
      }
      var test = /(\[)(\d+)(\])/g;
      return xPath.replace(test, function(match, p1, p2, p3){
            return p1 + (parseInt(p2, 10) + 1) + p3;  
      });
};

pega.tools.XMLDocumentUseZeroBasedIndex = false;
pega.tools.XMLDocument = 
{
	get: function(sSignature)
	{
		var isMoz = false;
		if ("ActiveXObject" in window && !pega.tools.useWgx)
		{
			isMoz = false;

			// default, sSignature will be null, but if you are given the signature
			// then use it and don't search for a more current one
			if ((sSignature == null) || (sSignature == "")) {
				var arrSignatures;
				if (pega.tools.XMLDocumentUseZeroBasedIndex) {
					arrSignatures = ["Microsoft.XmlDom", "MSXML2.DOMDocument.3.0"];
				} else {
					arrSignatures = ["MSXML2.DOMDocument.6.0", "MSXML2.DOMDocument.3.0"];
				}
				for (var i=0; i < arrSignatures.length; i++)
				{
					try
					{
						var dom = new ActiveXObject(arrSignatures[i]);
						if (!pega.tools.XMLDocumentUseZeroBasedIndex && arrSignatures[i] == "MSXML2.DOMDocument.3.0") {
							// the 3.0 dom document defautls to XSLPattern, need to change it to XPath if not zero based index.
							dom.setProperty("SelectionLanguage", "XPath");
						}
						return dom;
					}
					catch (err)
					{
				
					}
				}
				throw new Error("MSXML is not installed on your system.");
			}
			else {
				try
				{
					var dom = new ActiveXObject(sSignature);
					return dom;
				}
				catch (err)
				{
				
				}
			}
			throw new Error("MSXML is not installed on your system.");
		}
		else if (document.implementation && document.implementation.createDocument)
		{
			isMoz = true;
			var dom = document.implementation.createDocument("", "pagedata", null);
			dom.parseError = 
			{
				valueOf: function () { return this.errorCode; },
				toString: function () { return this.errorCode.toString(); }
			};
			
			dom._initError();
			dom.addEventListener("load", function()
				{
					this._checkForErrors();
					this._changeReadyState(4);
				}, false);
			return dom;
		}
		else
		{
			throw new Error ("Your browser doesn't support an XML DOM object.");
		}
	},
	
	defineGetter: function(obj, prop, get)
	{
		if (Object.defineProperty)
		{
	    		return Object.defineProperty(obj, prop, this.accessorDescriptor("get", get));
	 	}
	 	if (Object.prototype.__defineGetter__)
	  	{
	    		return obj.__defineGetter__(prop, get);
		}	
		throw new Error("browser does not support getters");
	},

	accessorDescriptor: function(field, fun)
	{
		var desc = { enumerable: true, configurable: true };
		desc[field] = fun;
		return desc;
	},
	
	removeTextNodes: function(elem){
	/*This API intends to clear the unnecessary text nodes (nodeType==3) in the xml*/
	if(!elem || (elem.tagName && elem.ownerDocument.documentElement.tagName.toLowerCase()=="html")){ /*API is intended only for XML DOM, hence added second condition to skip execution when HTML DOM*/
		return;
	}
	var children = elem.childNodes;
		if(!children){
			return;
		}
        var child;
        var len = children.length;
        var i = 0;
        var whitespace = /^\s*$/;
        for(; i < len; i++){
            child = children[i];
            if(child.nodeType == 3){
                if(whitespace.test(child.nodeValue)){
                    elem.removeChild(child);
                    i--;
                    len--;
                }
            }else if(child.nodeType == 1){
                this.removeTextNodes(child);
            }
        }
	},

	isWhitespace : function(elem){
		var whitespace = /^\s*$/;
		if(elem.nodeType == 3 && whitespace.test(elem.nodeValue)){
			return true;
		} return false;
	}
}

var oMozDocument = null;
if (typeof XMLDocument != "undefined") 
{
    oMozDocument = XMLDocument;
} 
else if (typeof Document != "undefined") 
{
    oMozDocument = Document;
}

if (oMozDocument && !window.opera)
{
    try
	{
		oMozDocument.prototype.readyState = 0;
		//BUG-188518 - Safari on Mac logs an error while trying to modify (or even access) a prototype property of a native object; probably as a way to promote best practice of not modifying native objects
		//Detecting Safari on Mac to not execute the next statement
		if (!(pega.env.ua.webkit && /Macintosh/.test(navigator.userAgent))) {
			oMozDocument.prototype.onreadystatechange = null;
		}
    }
	catch(e) { }
    
    oMozDocument.prototype._changeReadyState = function (iReadyState) 
    {
		try {
			this.readyState = iReadyState;
		} catch(e) {
		}
        if (typeof this.onreadystatechange == "function") {
            this.onreadystatechange();
        }
    };

    oMozDocument.prototype._initError = function () 
    {
		this.parseError.errorCode = 0;
        this.parseError.filepos = -1;
        this.parseError.line = -1;
        this.parseError.linepos = -1;
        this.parseError.reason = null;
        this.parseError.srcText = null;
        this.parseError.url = null;
    };
    
    oMozDocument.prototype._checkForErrors = function () 
    {
		var docEl = this.documentElement,
		/*Fix for webkit/firefox where it returns text node as firstChild - Bug-118923 : kumad1*/
			docElChild = docEl.firstElementChild || docEl.firstChild; 
		/* 
		* Need to check if the childs got failed in case the string is of html document
		*/
        if (docEl.tagName == "parsererror" || (docElChild && docElChild.tagName == "parsererror") || (docElChild && docElChild.firstChild && docElChild.firstChild.tagName  == "parsererror")) /*Bug-118923 : kumad1*/
        {

            var reError = />([\s\S]*?)Location:([\s\S]*?)Line Number (\d+), Column (\d+):<sourcetext>([\s\S]*?)(?:\-*\^)/;

            reError.test(this.getXmlOrSerialize());
            
            this.parseError.errorCode = -999999;
            this.parseError.reason = RegExp.$1;
            this.parseError.url = RegExp.$2;
            this.parseError.line = parseInt(RegExp.$3);
            this.parseError.linepos = parseInt(RegExp.$4);
            this.parseError.srcText = RegExp.$5;
        }
    };
            
    oMozDocument.prototype.loadXML = function (sXml) 
    {
        this._initError();
    
        this._changeReadyState(1);
    
        var oParser = new DOMParser();
        var oXmlDom = oParser.parseFromString(sXml, "text/xml");
 
        while (this.firstChild) {
            this.removeChild(this.firstChild);
        }


        for (var i=0; i < oXmlDom.childNodes.length; i++) {
			if (oXmlDom.childNodes && oXmlDom.childNodes.length > 0 )
			{
				var oNewNode = this.importNode(oXmlDom.childNodes[i], true);
				this.appendChild(oNewNode);
			}
        }

        this._checkForErrors();
        
		this._changeReadyState(4);
		if (this.parseError.errorCode == 0)
			return true;
		else
			return false;
	

    };
    
    oMozDocument.prototype._load = oMozDocument.prototype.load;

    oMozDocument.prototype.load = function (sURL) 
    {
        this._initError();
        this._changeReadyState(1);
        this._load(sURL);
		if (this.parseError.errorCode == 0)
			return true;
		else
			return false;        
    };
    
    // Note: __defineGetter__ and __defineSetter__ are nonstandard deprecated functions...
	if (Node.prototype.__defineGetter__ && Node.prototype.__defineSetter__) {
		Node.prototype.__defineGetter__("xml", function () 
		{
			var oSerializer = new XMLSerializer();
			return oSerializer.serializeToString(this, "text/xml");
		});

		Node.prototype.__defineGetter__("text", function () 
		{
			var sText = "";
			for (var i = 0; i < this.childNodes.length; i++) {
				if (this.childNodes[i].hasChildNodes()) {
					sText += this.childNodes[i].text;
				} else {
					sText += this.childNodes[i].nodeValue;
				}
			}
			return sText;

		});

		Node.prototype.__defineSetter__("text", function(text){
			this.textContent = text;
		});
	} else {
		pega.tools.XMLDocument.defineGetter(Node,"xml", function () 
		{
			var oSerializer = new XMLSerializer();
			return oSerializer.serializeToString(this, "text/xml");
		});
		
		pega.tools.XMLDocument.defineGetter(Node,"text", function () 
		{
			var sText = "";
			for (var i = 0; i < this.childNodes.length; i++) {
				if (this.childNodes[i].hasChildNodes()) {
					sText += this.childNodes[i].text;
				} else {
					sText += this.childNodes[i].nodeValue;
				}
			}
			return sText;
		});
	}

    Element.prototype.selectNodes = function(sXPath)
    {
		if (typeof XPathEvaluator != 'undefined') // non-IE browsers and IE Quirks Mode
		{
			sXPath = pega.tools.normalizeXpath(sXPath);
	   		var oEvaluator = new XPathEvaluator();
			var oResult = oEvaluator.evaluate(sXPath, this, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
			var aNodes = new Array();
			
			if (oResult !=null)
			{
				var oElement = oResult.iterateNext();
				while(oElement)
				{
					aNodes.push(oElement);
					oElement = oResult.iterateNext();
				}
			}
			aNodes.item = function(index){
				return this[index];
			};
			if (aNodes.length == 0) 
				return null;
			else 
				return aNodes;
		}
		else if (document.evaluate)
		{
			var oResult = document.evaluate(sXPath, this, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
			var aNodes = new Array();
			
			if (oResult !=null)
			{
				var oElement = oResult.iterateNext();
				while(oElement)
				{
					aNodes.push(oElement);
					oElement = oResult.iterateNext();
				}
			}
			aNodes.item = function(index){
				return this[index];
			};
			return aNodes.length == 0 ? null : aNodes;
		}
		else
		{
			var dom = new ActiveXObject("Microsoft.XMLDOM");
			dom.loadXML(this.getXmlOrSerialize());
			dom.setProperty("SelectionNamespaces",    "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'");
			dom.setProperty("SelectionLanguage", "XPath");
			if (dom.documentElement == null)
				return null;
		 	return dom.documentElement.selectNodes(sXPath);
		}
    };

	Element.prototype.selectSingleNode = function(sXPath)
	{
		if (typeof XPathEvaluator != 'undefined' ) // non-IE browsers and IE Quirks Mode
		{
			sXPath = pega.tools.normalizeXpath(sXPath);
            
            /*Edge does not support xpath of /^(\.\.\/)*(\.\.)/ format. Returning the actual node by traversing to the parent based on the number of '/'s in the xpath */
          	if(navigator.userAgent.indexOf("Edge")!=-1 && /^(\.\.\/)*(\.\.)/.test(sXPath)){
            	var xPathArray = sXPath.split("/");
              	var result = this;
              	for(var i =0; i<xPathArray.length; i++){
                  if(result.parentNode){
                    result = result.parentNode;
                    if(xPathArray[i] && xPathArray[i] != ".."){
                    	result = result.getElementsByTagName(xPathArray[i])[0];
                    }
                  } else {
                    return null;
                  }
                }
              	return result;
          	}
			var oEvaluator = new XPathEvaluator();
			var oResult = oEvaluator.evaluate(sXPath, this, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
			
			if (oResult !=null)
			{
				return oResult.singleNodeValue;
			}
			else
				return null;
		}
		else if (document.evaluate)
		{
			var oResult = document.evaluate(sXPath, this, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
			return oResult ? oResult.singleNodeValue : null;
		}
		else
		{
			var dom = new ActiveXObject("Microsoft.XMLDOM");
			dom.loadXML(this.getXmlOrSerialize());
			dom.setProperty("SelectionNamespaces",    "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'");
			dom.setProperty("SelectionLanguage", "XPath");
			if (dom.documentElement == null)
				return null;
		 	return dom.documentElement.selectSingleNode(sXPath);
		}
    };

	Element.prototype.getXmlOrSerialize = function()
	{
		return this.xml ? this.xml : (new XMLSerializer()).serializeToString(this);
	};

    oMozDocument.prototype.getUniqueId = function() {
		return Element.prototype.getUniqueId(); 	
    };

    oMozDocument.prototype.selectNodes = function(sXPath)
    {
		if (typeof XPathEvaluator != 'undefined') // non-IE browsers and IE Quirks Mode
		{

			sXPath = pega.tools.normalizeXpath(sXPath);
	   		var oEvaluator = new XPathEvaluator();
			var oResult = oEvaluator.evaluate(sXPath, this, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
			var aNodes = new Array();
			if (oResult !=null)
			{
				var oElement = oResult.iterateNext();
				while(oElement)
				{
					aNodes.push(oElement);
					oElement = oResult.iterateNext();
				}
			}
			aNodes.item = function(index){
				return this[index];
			};
			if (aNodes.length == 0) 
				return null;
			else 
				return aNodes;
		}
		else if (document.evaluate)
		{
			var oResult = document.evaluate(sXPath, this, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
			var aNodes = new Array();
			if (oResult !=null)
			{
				var oElement = oResult.iterateNext();
				while(oElement)
				{
					aNodes.push(oElement);
					oElement = oResult.iterateNext();
				}
			}
			aNodes.item = function(index){
				return this[index];
			};
			return aNodes.length == 0 ? null : aNodes;
		}
		else
		{
			var dom = new ActiveXObject("Microsoft.XMLDOM");
			dom.loadXML(this.getXmlOrSerialize());
			dom.setProperty("SelectionNamespaces",    "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'");
			dom.setProperty("SelectionLanguage", "XPath");
			if (dom.documentElement == null)
				return null;
		 	return dom.documentElement.selectNodes(sXPath);
		}
    };

	oMozDocument.prototype.selectSingleNode = function(sXPath)
	{
		if (typeof XPathEvaluator != 'undefined') { // non-IE browsers and IE Quirks Mode
			sXPath = pega.tools.normalizeXpath(sXPath);
			var oEvaluator = new XPathEvaluator();
			var oResult = oEvaluator.evaluate(sXPath, this, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
			
			if (oResult !=null)
			{
				return oResult.singleNodeValue;
			}
			else
				return null;
		}
		else if (document.evaluate)
		{
			var oResult = document.evaluate(sXPath, this, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
			return oResult ? oResult.singleNodeValue : null;
		}
		else
		{
			var dom = new ActiveXObject("Microsoft.XMLDOM");
			dom.loadXML(this.getXmlOrSerialize());
			dom.setProperty("SelectionNamespaces",    "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'");
			dom.setProperty("SelectionLanguage", "XPath");
			if (dom.documentElement == null)
				return null;
		 	return dom.documentElement.selectSingleNode(sXPath);
		}
	};

	oMozDocument.prototype.getXmlOrSerialize = function()
	{
		return this.xml ? this.xml : (new XMLSerializer()).serializeToString(this);
	};
}
//static-content-hash-trigger-GCC
/****************** Validation Framework ******************
 *
 *	This framework delegates the processing of validation from
 *	attributes in html elements to the appropriate functions.
 *
 *	© 2005 Pegasystems Inc.
 **********************************************************/
 //
 //<script>
 //

/* @package This framework delegates the processing of validation from attributes in html elements to the appropriate functions.
*/

 /**
    set globals and attach events
 */

var errorDB = function(){

	var errorStore = {};

	return {
		setError: function(propName){
			if(!propName)
				return;
			errorStore[propName]=true;
		},

		clearError: function(propName){
			if(!propName)
				return;
			errorStore[propName]=false;

		},

		isHavingError: function(propName){
			return errorStore[propName];
		}
	};
}
//US-211605 : Change to make errorDB harness context aware
function getErrorDB(){
  if(typeof pega.ctx.errorDB == "undefined"){
    pega.ctx.errorDB = window.errorDB();
  }
  return pega.ctx.errorDB;
}

//global array to store the validation type objects
if (typeof validation_ValidationTypes == 'undefined') {
	var validation_ValidationTypes = {};
}
if (typeof pega.ctx.rule_obj_validate_ValidationTypes == 'undefined') {
	pega.ctx.rule_obj_validate_ValidationTypes = {};
}

if(typeof(pega)!='undefined' && typeof(pega.u)!='undefined' && typeof(pega.u.d)!='undefined'){
	pega.u.d.attachOnload(validation_init, true);
}
else if(typeof(harness)!='undefined'){
	harness.attachOnload(validation_init, true);
}
else{
	pega.util.Event.addListener(window, "load", validation_init);
}

// functions used to display errors
var validation_displayErrors;
var validation_displayFieldError;

// types of elements to validate
var validation_elTypesToValidate = new Array("input", "select", "textarea");

/*
@Handler
@protected- Initialization of validation
@param $Object$reloadElement- Reloaded element to attach validation
@return $void$
*/

function validation_init(reloadElement) {
	setTimeout(_validation_init, 10, reloadElement);
}

function _validation_init(reloadElement) {
  	// usually last piece of onload processing, capture to performance monitor, even though small amount of time
    pega.ui.statetracking.setBusy("csvalid._validation_init");
  	
	if(reloadElement == null || reloadElement.type == "load"){
		if(typeof(configure_rule_declareExpressions) == 'function') {
			configure_rule_declareExpressions();
		}
		if(typeof(pega.ctx.configure_rule_obj_validate) == 'function') {
			pega.ctx.configure_rule_obj_validate();
		}
		validation_attachValidation();
	} else {
      /* BUG-299588: To support declaratives in SPA */
      var strClass = reloadElement.getAttribute('class');
      if((reloadElement.nodeName == "MAIN" || (reloadElement.nodeName == "DIV" && strClass && strClass.indexOf("screen-layout-region-content") >= 0
)) && pega.u && pega.u.d && pega.ctx.bIsDCSPA){
        if(typeof(configure_rule_declareExpressions) == 'function') {
          configure_rule_declareExpressions();
          //delete configure_rule_obj_validate;
        }
        if(typeof(pega.ctx.configure_rule_obj_validate) == 'function') {
          pega.ctx.configure_rule_obj_validate();
          //delete configure_rule_obj_validate;
        }
      } else if(pega.ctx && pega.ctx.isMDC && reloadElement.nodeName == "DIV" && reloadElement.getAttribute("data-mdc-recordid") != "" && strClass && strClass.indexOf("show") >= 0) {
        /* BUG-392196: if reloadelement is MDC div */
        if(typeof(configure_rule_declareExpressions) == 'function') {
          configure_rule_declareExpressions();
          //delete configure_rule_obj_validate;
        }
        if(typeof(pega.ctx.configure_rule_obj_validate) == 'function') {
          pega.ctx.configure_rule_obj_validate();
          //delete configure_rule_obj_validate;
        }    
      }
      validation_attachValidation(reloadElement);
	}

    pega.ui.statetracking.setDone();
}

// list of attributes that imply a validation type
// for example, in <input min="5">, the attribute min implies the validation type min
var validation_attributesThatImply = new Array();

/*
@protected- Object to tie an event type and a function together.
@param $String$attributeName - Attribute name
@param $String$validationType - Validation Type
@return $void$
*/
function validation_AttributeImplies(attributeName, validationType)
{
	this.attributeName = attributeName;
	this.validationType = validationType;
}

/*@protected- Object to tie an event type and a function together.
  @param $String$eventName - Event Name
  @param $Function$functionPointer - Function Pointer
  @return $void$
 */
function validation_EventFunction(eventName, functionPointer)
{
	this.eventName = eventName;
	this.functionPointer = functionPointer;
}

/*@protected- Object to represent error.
  @param $String$element - Element to attach the error message
  @param $String$errorMessage - Error message to be displayed with the element
  @return $void$
 */
function validation_Error(element, errorMessage)
{
	this.element = element;
	this.errorMessage = errorMessage;
}

/*
@constructor
@public- A validation type.
Each validation type has a default function that will be executed when an explicit call is made to trigger validation
(mostly will be called before submit) The default function can be null if validation only occurs on events
Each validation type has an array which specificies what validation function should be called on what event
this array is made up of EventFunction objects
@param $String$name - name of the object
@param $Function$defaultFunction - default function to be called
@return $void$
 */

function validation_ValidationType(name, defaultFunction)
{
	this.defaultFunction = defaultFunction;
	this.eventValidationList = new Array();
	this.addEventFunction = function(eventName,functionPointer){this.eventValidationList[eventName]=functionPointer;}
	this.addAttributeThatImplies = function(attributeName){validation_attributesThatImply.push(new validation_AttributeImplies(attributeName, name))};

    if (typeof(validation_ValidationTypes) == "undefined") {
      validation_ValidationTypes = {};
    }

	validation_ValidationTypes[name.toLowerCase()] = this; 

}



/*
@protected- Get the function pointer.
This function takes a validation type and an eventType and returns the associated function pointer.
Example:  if validation type is validDate, and onblur should trigger a function, calling getFunctionForValType(validDate, "onblur")
would return that function
@param $String$valType - Validation type
@param $String$eventType - Event type
@return $function$ - Associated function pointer
 */
function validation_getFunctionForValType(valType, eventType)
{
	return valType.eventValidationList[eventType];
}

/*
@protected-Function to collect all elements and run validation on each one.
This triggers the default validation function to be called if it exists.
@param $Object$container - An option argument can be passed to limit the scope from using the doucment object to the object passed in. The document object is the default.
@return $boolean$ Return the validate status
*/

function validation_validate(container, serverErrors)
{
  var harnessContextDIV = pega.ctx.dom.getElementById("PEGA_HARNESS");
	if(null == container)
	{
		container = harnessContextDIV;
		validationElements = [];
		validation_attachValidation();

	}

	var errorList = new Array();
	var successList = new Array();

	if(container == harnessContextDIV) {
		validaton_validateCollection(validationElements, errorList, successList);
	} else {
		// validate each type of element such as input, select, etc
		for(var i=0; i<validation_elTypesToValidate.length; i++) {
			//var elementList = container.getElementsByTagName( validation_elTypesToValidate[i] );
      var elementList = pega.ctx.dom.getElementsByTagName(validation_elTypesToValidate[i], container);
			validaton_validateCollection(elementList, errorList, successList);
		}
	}
 if(typeof(validation_displayErrors)=='function'){
		validation_displayErrors(errorList, successList, serverErrors);
	}

	return (errorList.length == 0) ? true : false;
}

/*@protected- Validation the given collection of elements.
Display functions use both the errorList and successList.
@param $Array$aCollection - Collection of elements
@param $Array$errorList - List of errors
@param $Array$successList - List of success
@return $void$
 */
function validaton_validateCollection(aCollection, errorList, successList)
{
	var aCollectionLength = aCollection.length;
	var validation_validateFieldRef = validation_validateField;
	var someErrors;
	var someErrorsLength = 0;
	for(var i=0; i<aCollectionLength; i++)
	{
		var elementRef = aCollection[i];
    var isValidationRequired = (elementRef.readOnly && elementRef.hasAttribute("data-editable"));
		if(!elementRef || (!elementRef.parentNode && !elementRef.parentElement)) {
			continue;
		}
		/*Added the calendar check to support new auto generated control and BUG-504015*/
		if((elementRef.type === "hidden" && pega.util.Dom.getNextSibling(elementRef) && pega.util.Dom.getNextSibling(elementRef).tagName.toLowerCase() === "select") || isValidationRequired){

		}else if((elementRef.type === "hidden" &&
        !elementRef.getAttribute("data-calendar") &&
        !elementRef.hasAttribute("data-datetype")) ||
        !elementRef.getAttribute("validationType") ||
        (elementRef.readOnly &&
        (!elementRef.className || elementRef.className.indexOf("TACOL") === -1))  ||
        (!pega.u.d.validateHiddenField  && pega.u.d.validateHiddenField  !== undefined &&
        (elementRef.offsetHeight == 0 &&
        (elementRef.id.indexOf('PEGACKEDITOR') === -1 ||  // for non RTE elements 
        (elementRef.parentElement.childNodes[1] && elementRef.parentElement.childNodes[1].offsetHeight == 0) ))) ) // to check visibility for RTE using sibiling element
			continue;
		someErrors = validation_validateFieldRef( elementRef );
		someErrorsLength = someErrors.length;

		for(var j=0; j<someErrorsLength; j++)
		{
			errorList.push(someErrors[j]);
		}
		if(0 == someErrorsLength)
		{
			successList.push( elementRef );
		}
	}
}

/*
@protected- Calls the default validation functions on an input field.
An input can have multiple validation types, therefore there can be multiple default validation functions.
@param $Object$anInput - DOM input object element that the event occurs
@return $Array$ - an array of errors found.
*/
function validation_validateField(anInput)
{

	//validate_attachRuleObjValidate(anInput);
	var errorList = new Array();
	var anInputVTypeAttr = anInput.getAttribute("validationType");
	var anInputDName = anInput.displayName;
	if(null != anInputVTypeAttr && anInputVTypeAttr != "")
	{
		var valTypeArray = validation_removeSpaces(anInputVTypeAttr).split(",");
		for(var j=0; j<valTypeArray.length; j++)
		{
			var valType = validation_ValidationTypes[valTypeArray[j]];

            if((undefined != valType) && (null != valType.defaultFunction))
            {
				if((anInputDName == null) ||(anInputDName == "")){
					anInput.displayName = validation_getDisplayName(anInput);
				}
	            aPossibleError = valType.defaultFunction(anInput);
                if(null != aPossibleError)
                {
    	            errorList.push(aPossibleError);
                }
            }
		}
	}

	return errorList;
}


/*
@Handler
@public- Calls a validation function for the given event type on an input field.
An input can have multiple validation types, therefore there
can be multiple validation functions triggered by an event.
@param $Object$object - Input element
@param $String$eventType - Event type
@param $Function$customEventHandler - Custom Event Handler
@return $void$
*/
function validation_ValidateFieldOnEvent(object, eventType, customEventHandler, event)
{
	var errorList = new Array();
  var noErrorOnCalExpression;
	if(!object.getAttribute) return;
  var currentCtx = pega.ctx;
  pega.ctxmgr.setContext(pega.ctxmgr.getContextByTarget(object));
	if(null != object.getAttribute("validationType"))
	{

		//validate_attachRuleObjValidate(object);
		var valTypeArray = validation_removeSpaces(object.getAttribute("validationType")).split(",");
		for(var j=0; j<valTypeArray.length; j++)
		{
      noErrorOnCalExpression = false;
			var valType = validation_ValidationTypes[valTypeArray[j].toLowerCase()];
			if(typeof(valType)!='undefined')
			{
				var valFunc = validation_getFunctionForValType(valType, eventType);
				if(null != valFunc)
				{
					if((object.displayName == null) ||(object.displayName == "")){
						object.displayName = validation_getDisplayName(object);
					}

					if(valTypeArray[j].toLowerCase()=="calculateexpression"){
						if(errorList.length == 0){
							aPossibleError = valFunc(object, eventType);
						}
            //SE-55290 if calculatexpression doesnot have an error, mark the flag as true and pass as an parameter for validation_displayFieldError
            if(!aPossibleError){
              noErrorOnCalExpression = true;
            }
					}
					else if(valTypeArray[j].toLowerCase()=="auto_format"){
						if(errorList.length == 0){
							aPossibleError = valFunc(object, eventType);
						}
					}
					else{
						aPossibleError = valFunc(object,eventType);
					}
					if(null != aPossibleError)
					{
						errorList.push(aPossibleError);
					}
					if(aPossibleError == "terminate" || (eventType=="onkeyup" && valTypeArray[j].toLowerCase() != "alphanumericspacevalidation" ) ){
            pega.ctxmgr.setContext(currentCtx);
						return;
					}
          if(valTypeArray[j].toLowerCase()=="required" && eventType == "onblur" && errorList.length == 0 && object.name && window.getErrorDB  &&
             window.getErrorDB().isHavingError(object.name)){
            pega.ctxmgr.setContext(currentCtx);
            return;
          }/*Code commented to hanlde BUG 53090 Autobots*/
					//if(aPossibleError == null && eventType=="onblur" && object.onchange != null){
					//	return;}/*BUG 53090 End*/
				}
			}
		}
		/*HFIX-9485: Moving BUG-70236 block from above to show alerts on every tabout in accessibility mode.*/
		/* BUG-70236: START */
		//BUG-139144 Added data-change for auto generated components
		if(eventType=="onblur" && getErrorDB().isHavingError(object.getAttribute("name")) && object.onchange != null && !object.getAttribute("data-change") && (errorList.length == 0 && (typeof aPossibleError == "undefined" || !aPossibleError)) && !(object.getAttribute("data-ctl") == '["DateRange"]')) {
      pega.ctxmgr.setContext(currentCtx);
			return;
		}
		/* BUG-70236: END */
	}

	var successList = new Array();
	var propName = object && object.getAttribute("name");
	if(errorList.length == 0)
	{
		successList.push(object);
		getErrorDB().clearError(propName);
	}else{
		getErrorDB().setError(propName);
	}

	if(typeof(validation_displayFieldError)=='function'){
		validation_displayFieldError(errorList, successList, event, noErrorOnCalExpression);
	}

  //BUG-811778: if element is datetime-dropdown call the custom event handler
  var isDatetimeDropdown = pega.u && pega.u.d && typeof(pega.u.d.isDateTimeDropdownElement)=='function' && pega.u.d.isDateTimeDropdownElement(object);
	// if there were no errors, call the custom event handler if one exists
	if((errorList.length == 0 || isDatetimeDropdown) & (customEventHandler != null))
	{
	    customEventHandler.call(object, event);
	}
  pega.ctxmgr.setContext(currentCtx);
}


/*
@protected- This function attaches the validation functions to events for all input fields.
Should be called after input fields are created.  If input fields are created
dynamically, this function should be called again.
@param $Object$container- An option argument can be passed to limit the scope from using the doucment object to the object passed in. The document object is the default.
@return $void$
*/
function validation_attachValidation(container) {
	if(null == container){
		if(typeof pega.ctx.bPortalUser!="undefined" && pega.ctx.bPortalUser){
			container = pega.ctx.dom.getElementById("PEGA_HARNESS");
		}
		else {
			container = document.querySelector("main");
		}
	}
	for(var i=0; i<validation_elTypesToValidate.length; i++){
		//var elementList = container.getElementsByTagName(validation_elTypesToValidate[i]);
    var elementList = pega.ctx.dom.getElementsByTagName(validation_elTypesToValidate[i], container);
		validation_attachValidationToCollection(elementList);
		/*if(typeof(pega)!='undefined' && typeof(pega.u)!='undefined' && typeof(pega.u.d)!='undefined') {
			pega.u.d.attachFocusHandler(elementList);
		}*/
	}
	/*if(typeof(pega) != 'undefined' && typeof(pega.u) != 'undefined' && typeof(pega.u.d) != 'undefined'){
		var focusInputTypes = new Array("button", "a");
		for(var i=0; i<focusInputTypes.length; i++){
			var elementList = container.getElementsByTagName(focusInputTypes[i]);
			pega.u.d.attachFocusHandler(elementList);
		}
	}*/
}


/*
@protected- Attaches validation to a collection of elements
This function is called from validation_attachValidation function with the collection of elements
@param $Array$aCollection - Collection of elements
@return $void$
*/

function validation_attachValidationToCollection(aCollection) {
	//Attach validation types
	var aCollectionLength = aCollection.length;
	var checkRDE = typeof(window.init_expression_calculation) == "function";
	var validation_attachValidationToElementRef = validation_attachValidationToElement;
	for(var i=0; i<aCollectionLength; i++) {
		var elementRef = aCollection[i];
    var isValidationRequired = (elementRef.readOnly && elementRef.hasAttribute("data-editable"));
		/*Added the calendar check to support new auto generated control*/
		if((elementRef.type === "hidden" && pega.util.Dom.getNextSibling(elementRef) && pega.util.Dom.getNextSibling(elementRef).tagName.toLowerCase() === "select") || isValidationRequired){

		}else if((elementRef.type == "hidden" && !elementRef.getAttribute("data-calendar") && !elementRef.hasAttribute("data-datetype")) || (elementRef.readOnly === true && (!elementRef.className ||elementRef.className.indexOf("TACOL")==-1))) {
			continue;
		}
		validation_attachValidationToElementRef(elementRef, checkRDE);
	}
}

var removeDuplicateValidations = function(inp) {
	var retArr = [];
	var inpLen = inp.length;
	outer:for(var i = 0, n = inpLen; i < n; i++) {
		if(inp[i]) {
			var inpRS = inp[i];
			if(inpRS == "") {
				continue;
			}
			for(var x = 0, y = retArr.length; x < y; x++) {
				if(retArr[x]==inpRS) continue outer;
			}
			retArr[retArr.length] = inpRS;
		}
	}
	return retArr;
};
var validationElements = [];
var localVal_ValTypes = {};
/*
@protected- Attaches validation to an element.
This function attaches the validation to the given object
Called by validation_attachValidationToCollection function
@param $Object$anObject - Object to attach the validation
@return $void$
*/
function validation_attachValidationToElement(anObject, checkRDE) {
	var appendValidArr = validation_addImpliedTypes(anObject);
	var anObjName = anObject.name;
	var objAttrib = anObject.getAttribute("validationType");
	if(checkRDE === true) {
		var rdeVType = rule_declare_expressions_ValidationTypes[anObjName];
		if(typeof rdeVType != "object") {
			rdeVType = rule_declare_expressions_ValidationTypes[validation_getEntryHandleForPageProperties(anObjName)];
		}
		if(typeof rdeVType == "object") {
			appendValidArr += ",calculateexpression";
		}
	}
	var rovVType = pega.ctx.rule_obj_validate_ValidationTypes && pega.ctx.rule_obj_validate_ValidationTypes[anObjName];
	if(typeof rovVType != "object") {
		rovVType = pega.ctx.rule_obj_validate_ValidationTypes && pega.ctx.rule_obj_validate_ValidationTypes[validation_getEntryHandleForPageProperties(anObjName)];
	}
	if(typeof rovVType == "object") {
		if(rovVType.bRequired.toLowerCase()=="true") {
			appendValidArr += ",required";
		}
		if(rovVType.validate) {
			appendValidArr += "," + rovVType.validate;
			if(rovVType.errorMessage!=""){
				anObject.setAttribute("errMessage", rovVType.errorMessage);
			}
		}
	}

	if(!objAttrib) {
		objAttrib = "";
	}

	var valTypeArray = (objAttrib + "," + appendValidArr).toLowerCase().replace(/ /g,"").split(",");
	valTypeArray = removeDuplicateValidations(valTypeArray);
	if(valTypeArray.length == 0) {
		return;
	}
	anObject.setAttribute("validationType", valTypeArray.join(","));
	validationElements.push(anObject);
	for(var j=0; j<valTypeArray.length; j++) {
		if(!localVal_ValTypes[valTypeArray[j]]) {
			localVal_ValTypes[valTypeArray[j]] = validation_ValidationTypes[valTypeArray[j]];
		}
		var validationObject = localVal_ValTypes[valTypeArray[j]];
		if(validationObject) {
			var eventList = validationObject.eventValidationList;
			if(eventList.onload) {
				var customEventHandler = anObject["onload"];
				validation_ValidateFieldOnEvent(anObject, "onload", customEventHandler);
			}
			if(eventList.onmouseover) {
				var customEventHandler = anObject["onmouseover"];
				anObject["onmouseover"] = new Function("event", "validation_ValidateFieldOnEvent(this,'onmouseover'," + customEventHandler + ", event);");
			}
			if(eventList.onmouseout) {
				var customEventHandler = anObject["onmouseout"];
				anObject["onmouseout"] = new Function("event", "validation_ValidateFieldOnEvent(this,'onmouseout'," + customEventHandler + ", event);");
			}
			if(eventList.onmousedown) {
				var customEventHandler = anObject["onmousedown"];
				anObject["onmousedown"] = new Function("event", "validation_ValidateFieldOnEvent(this,'onmousedown'," + customEventHandler + ", event);");
			}
		}
	}
}

/*
@protected- This function is adding the values to the validationType attributeof the input from the Rule-Obj-Validate.
If the Rule-Obj-Validate is having a Rule-Edit-Validate and Required as checked,
This function adds those values to the validationType attribute.
Also it creates an errMessage attribute in the input object which is taken from the Rule-Obje Validate
@param $object$anInput- DOM input object element that the event occurs
@return $boolean$ - Status
*/

function validate_attachRuleObjValidate(anInput){

	if(anInput.readOnly){
		return;
	}

	/* Get the Rule-Obj-Validate object */
	var objValidate = pega.ctx.rule_obj_validate_ValidationTypes && pega.ctx.rule_obj_validate_ValidationTypes[anInput.name];

	if(objValidate==null){
		objValidate = pega.ctx.rule_obj_validate_ValidationTypes && pega.ctx.rule_obj_validate_ValidationTypes[validation_getEntryHandleForPageProperties(anInput.name)];
	}

	/* To check the validation type is already added */
	var validateFound = false;

	if(objValidate!=null){
		var valTypeArray = validation_removeSpaces(anInput.getAttribute("validationType")).split(",");
		if(objValidate.validate!=null){

			for(var j=0; j<valTypeArray.length; j++){
				if(valTypeArray[j].toLowerCase() == objValidate.validate.toLowerCase()){
					validateFound = true;
				}
			}

			/* If the validation type is not added, add it to the validationType of the object */
			if(validateFound == false){

				if(anInput.getAttribute("validationType") == ""){
					anInput.setAttribute("validationType", objValidate.validate);
				}
				else{
					anInput.setAttribute("validationType", anInput.getAttribute("validationType") + "," + objValidate.validate);
				}
			}

			/* Add the error message to the object */
			if(objValidate.errorMessage!=""){
				anInput.setAttribute("errMessage", objValidate.errorMessage);
			}
		}

		/* If the required is set in Rule-Obj-Validate,  add it to the validationType of the object */
		if(objValidate.bRequired.toLowerCase()=="true"){
			for(var j=0; j<valTypeArray.length; j++){

				/* If required is already added, return the function */
				if(valTypeArray[j] == "required"){
					return;
				}
			}
			if(anInput.validationType == ""){
				anInput.setAttribute("validationType", "required");
			}
			else{
				anInput.setAttribute("validationType", anInput.getAttribute("validationType") + ",required");
			}
			return true;
		}
	}
	return;
}

/*
@protected- This function is used to get the validation entry handle when the elements are in a repeating layoout.
This breaks the name into two parts and remove the line number and set the two parts.
@param $String$name - The name of the property
@return $String$entryHandle - Entry handle of the property
*/

function validation_getEntryHandleForPageProperties(name){
	var splitChars = ["$l", "$g"];
	var entryHandle = name;
	for(var j=0;j<splitChars.length;j++){
		var splitArray = entryHandle.split(splitChars[j]);
		for(var i=1;i<splitArray.length;i++){
			var dollarIndex = splitArray[i].indexOf('$');
			splitArray[i] = splitArray[i].substring(dollarIndex);
		}
		if(splitArray[0]!=entryHandle){
			entryHandle = splitArray[0];
			for(var i=1;i<splitArray.length;i++){
				if(splitArray[i].indexOf('$') != -1){
					splitArray[i] = splitChars[j] + splitArray[i];
					entryHandle += splitArray[i];
				}
				else{
					entryHandle += splitChars[j];
				}
			}
		}
	}
	return entryHandle;
}



/*
@protected- Add implied validation types
For example, input min=5, the attribute min implies the validation type min
Change input to input min=5 validationType=min
@param $Object$anObject - Element object
@return $void$
 */
function validation_addImpliedTypes(anObject) {
	var appendString = "";
	var valLen = validation_attributesThatImply.length;
	for(var j=0; j<valLen; j++) {
		var attributeName = validation_attributesThatImply[j].attributeName;
		if(anObject[attributeName]) {
			if(appendString == "") {
				appendString = validation_attributesThatImply[j].validationType;
			} else {
				appendString = "," + validation_attributesThatImply[j].validationType;
			}
		}
	}
	return appendString;
}

/*
@protected- Function for removing extra spaces in the string
@param $String$aString - String to remove spaces
@return $String$ - String removed spaces
*/
function validation_removeSpaces(aString) {
	return aString.replace(/ /g,"");
}

/*
@protected- To set the displayName when the displayName is not having a value.
@param $Object$object - Object to get the display name
@return $String$ - String with the display name
*/

function validation_getDisplayName(object){
	if((object.id == null) ||(object.id == "")){
		return object.name;
	}
	else{
		return object.id;
	}
}

/*
@constructor
@protected- Te create the validation object when a Rule-Obj-Validate
  @param $String$name - Name of the element
  @param $String$validate - Validate
  @param $String$bRequired - Required field
  @param $String$errorMessage - Error message
  @return $void$
*/

function rule_obj_validate_Object(name, validate, bRequired, errorMesssage)
{
		this.validate=validate;
		this.bRequired= bRequired;
		this.errorMessage = errorMesssage;
}



/*@protected- To create the validation object when a Rule-Obj-Validate
  @param $String$name - Name of the element
  @param $String$validate - Validate
  @param $String$bRequired - Required field
  @param $String$errorMessage - Error message
  @return $void$
*/

function rule_obj_validate(name, validate, bRequired, errorMesssage ){
		bConfigure=false;
		var validationObj = new rule_obj_validate_Object(name, validate, bRequired, errorMesssage);
		/*
		this.validate=validate;
		this.bRequired= bRequired;
		this.errorMessage = errorMesssage;
		pega.ctx.rule_obj_validate_ValidationTypes[name] = this;
		*/
    if(!pega.ctx.rule_obj_validate_ValidationTypes){
      pega.ctx.rule_obj_validate_ValidationTypes = {};
    }
		pega.ctx.rule_obj_validate_ValidationTypes[name] = validationObj;
}



/****************** Validation Utility ******************
 *
 *	Utility functions used by validation types.
 *
 *	© 2005 Evan Witt
 **********************************************************/
//=============CONSTANTS=================
var PERIOD_KEYCODE = 46;
var COMMA_KEYCODE = 44;
var MINUS_KEYCODE = 45;
var ZERO_KEYCODE = 48;
var NINE_KEYCODE = 57;

/*@protected- Prevent a character that was typed from being accepted
  @return $void$
 */
function valutility_cancelKeyPress()
{
	window.event.returnValue = false;
	return null;
}

/*@protected- Takes a keyCode
  @return $boolean$	- Return true if the entered character is numeric and false otherwise
 */
function valutility_isNumeric()
{
	if (window.event.keyCode >= ZERO_KEYCODE && window.event.keyCode <= NINE_KEYCODE)
    {
		return true;
	}
	return false;
}

/*@protected- Takes a keyCode
  @return $boolean$	- Return true if the entered character is alphabetic and false otherwise
 */
function valutility_isAlphabetic()
{
	if ((window.event.keyCode >= 65 && window.event.keyCode <= 90) ||
        (window.event.keyCode >= 97 && window.event.keyCode <= 122))
    {
		return true;
	}
	return false;
}

/*@protected- Takes a keyCode
  @return $boolean$ - Return true if the entered character is one of the a, A, m, M, p, P
 */
function valutility_isTimeSuffix(){

	if((window.event.keyCode == 65) || (window.event.keyCode == 77) || (window.event.keyCode == 80) ||
	(window.event.keyCode == 97) || (window.event.keyCode == 109) || (window.event.keyCode == 112)){

		return true;
	}
	return false;
}
/*@protected- Takes a keyCode
  @param $String$keyCode - Key code string
  @return $boolean$ Return true if the entered character is the same as the passed keyCode
		and false otherwise
 */
function valutility_isCharacter(keyCode)
{
	if (window.event.keyCode == keyCode)
    {
		return true;
	}
	return false;
}


/**********************************
 *	Title: Date Validation Types
 *
 *	© 2005 Evan Witt
 ***********************************/

/**********************************
The following configuration fields are declared in different file:

// date format fields - can be changed to reset date format
// sample date with the following setting - 01/24/2005
var date_separator = "/";
var date_datePos = 2;
var date_monthPos = 1;
var date_yearPos = 3;

// error message strings for date
var date_dateMsgStr1 = "date_dateMsgStr1 ";
var date_dateMsgStr2 = " date_dateMsgStr2";

// error meessage string for beforedate
var date_beforeDateMsgStr1 = "date_beforeDateMsgStr1 ";
var date_beforeDateMsgStr2 = " date_beforeDateMsgStr2 ";
var date_beforeDateMsgStr3 = " date_beforeDateMsgStr3";

// error meessage string for afterdate
var date_afterDateMsgStr1 = "date_afterDateMsgStr1 ";
var date_afterDateMsgStr2 = " date_afterDateMsgStr2 ";
var date_afterDateMsgStr3 = " date_afterDateMsgStr3";
***********************************/


// type declarations
{

	var date_beforeDate = new validation_ValidationType("beforedate", date_isBeforeDate);
	date_beforeDate.addAttributeThatImplies("dateBefore");

	var date_afterDate = new validation_ValidationType("afterdate", date_isAfterDate);
	date_afterDate.addAttributeThatImplies("dateAfter");
}

/*@constructor- Object used to store and compare dates
  @param $String$date - Date
  @param $String$month - Month
  @param $String$year - Year
 */
function date_ValDate(date, month, year)
{
	this.date = date;
	this.month = month;
	this.year = year;
}


/*@protected- Tests the passed element to see if it is before another date.
  @param $Object$object - element object
  @return $void$
 */
function date_isBeforeDate(object)
{
	var otherField = pega.ctx.dom.getElementById(object.getAttribute("dateBefore"));
	if(null == otherField)
	{
		return;
	}

	var thisDate = date_toStdFormat(pega.control.PlaceHolder.getValue(object));
	var otherDate = date_toStdFormat(pega.control.PlaceHolder.getValue(otherField));

	// if null, the dates are not valid and the check is irrelevant
	if((null == thisDate) || (null == otherDate))
	{
		return;
	}

	if(!date_isBeforeOtherDate(thisDate, otherDate))
	{
		//var errorMessage = date_beforeDateMsgStr1 + object.displayName + date_beforeDateMsgStr2 +
		//					otherField.displayName + date_beforeDateMsgStr3;
        var errorMessage=date_beforeDateMsgStrFull;
        errorMessage = resolveParams(errorMessage,[otherField.displayName]);
		return (new validation_Error(object, errorMessage));
	}
}

/*@protected- Tests the passed element to see if it is after another date.
  @param $Object$object - element object
  @return $void$
 */
function date_isAfterDate(object)
{
	var otherField = pega.ctx.dom.getElementById(object.getAttribute("dateAfter"));
	if(null == otherField)
	{
		return;
	}

	var thisDate = date_toStdFormat(pega.control.PlaceHolder.getValue(object));
	var otherDate = date_toStdFormat(pega.control.PlaceHolder.getValue(otherField));
	// if null, the dates are not valid and the check is irrelevant
	if((null == thisDate) || (null == otherDate))
	{
		return;
	}

	if(!date_isBeforeOtherDate(otherDate, thisDate))
	{
		//var errorMessage = date_afterDateMsgStr1 + object.displayName + date_afterDateMsgStr2 +
		//					otherField.displayName + date_afterDateMsgStr3;
		var errorMessage = date_afterDateMsgStrFull;
        errorMessage = resolveParams(errorMessage,[otherField.displayName]);
      return (new validation_Error(object, errorMessage));
	}
}

/*@protected- Compares two date objects
to test if the first object represents a date before the second date object
@param $Date$date - first date object to compare
@param $Date$otherDate - second date object to compare
@return $boolean$
*/
function date_isBeforeOtherDate(date, otherDate)
{
	return 	((date.year < otherDate.year) ||
			 ((date.year == otherDate.year) && (date.month < otherDate.month)) ||
			 ((date.year == otherDate.year) && (date.month == otherDate.month) && (date.date < otherDate.date)));
}

/*@protected- Tranlates date into format for easy comparison: YYYYMMDD
Example: August 12, 2001 would be 20010812
@param $string$dateString - String representation of the date
@return $date_ValDate$ - Date val date object
*/
function date_toStdFormat(dateString)
{
	re = /\D*(\d*)\D*(\d*)\D*(\d*)\D*/
	var result = re.exec(dateString);
	if(null == result)
	{
		return null;
	}

	var date = date_parseDatePart(result[date_datePos]);
	var month = date_parseDatePart(result[date_monthPos]);
	var year = date_parseYearPart(result[date_yearPos]);

	if(date_isDateValid(date, month, year))
	{
		return (new date_ValDate(date, month, year));
	}
	else{
    var jsDateTimeFormat = pega.u.d.CalendarUtil.javaDateTimeFormatToJSDateTimeFormat(pega.u.d.CalendarUtil.localeFormats.dateTime);
    var momObj = moment(dateString,jsDateTimeFormat);
    if(momObj.isValid()){
      return momObj.toDate();
    }
		return null;
	}
}

/*@protected- Function for keypress filtering
Allow anything except for alphabetic characters
@return $void$
*/
function date_filterKeyPress()
{
	var allowKey = (!valutility_isAlphabetic());
	if(!allowKey)
	{
		valutility_cancelKeyPress();
	}
	return null;
}

/*@protected- Function for keypress filtering
Allow anything except for alphabetic characters excluding A, M, P
@return $void$
*/

function time_filterKeyPress()
{
	var allowKey = valutility_isTimeSuffix();
	if(allowKey){
		return null;
	}
	else{
		allowKey = (!valutility_isAlphabetic());
	}
	if(!allowKey)
	{
		valutility_cancelKeyPress();
	}
	return null;
}

/*@protected- Function to format the date
@param $String$date - Date
@param $String$month - Month
@param $String$year - Year
@return $String$ - Date String
*/

function date_formatDate(date, month, year)
{
	var dateString = "";
	dateString += date_selectDatePart(1, date, month, year) + date_separator;
	dateString += date_selectDatePart(2, date, month, year) + date_separator;
	dateString += date_selectDatePart(3, date, month, year);
	return dateString;
}

/*@protected- Function to select part of the date
@param $String$partNumber - Position
@param $String$date - Date
@param $String$month - Month
@param $String$year - Year
@return $String$ - Date String
*/

function date_selectDatePart(partNumber, date, month, year)
{
	if(partNumber == date_datePos)
	{
		return date_formatDatePart(date);
	}
	else if(partNumber == date_monthPos)
	{
		return date_formatDatePart(month);
	}
	else if(partNumber == date_yearPos)
	{
		return year;
	}
}

/*@protected-For formatting, make sure month and date fields have two digits
@param $Integer$number - month
@return $String$number - month added a leading zero when it has only one digit
 */
function date_formatDatePart(number)
{
	if(number<10)
	{
		return "0" + number;
	}
	return number;
}

/*@protected-For parsing date part
@param $String$str - date string
@return $Integer$ - parsed date
*/

function date_parseDatePart(str)
{
	return parseInt(date_stripPrecedingZeros(str));
}

/*@protected-For strip preceding zeroes
@param $String$str - date string
@return $String$ - stripped string
*/

function date_stripPrecedingZeros(str)
{
	var i=0;
	while(str.charAt(i)=='0')
	{
		i++;
	}
	return str.substring(i, str.length);
}

/*@protected-For parse year part of the date string
@param $String$str - date string
@return $String$ - year
*/

function date_parseYearPart(str)
{
	var year = parseInt(date_stripPrecedingZeros(str));

	// handle if user entered only two-digits - assume current century
	if(year < 100)
	{
		year += 2000;
	}
	return year;
}

/*@protected- Check for valid date
@param $String$date - Date
@param $String$year - Year
@param $String$month - Month
@return $boolean$ - Valid date
*/

function date_isDateValid(date, month, year)
{
	// are all parts numbers
	if(isNaN(date) || isNaN(month) || isNaN(year))
	{
		return false;
	}

	// is month valid
	if(month < 1 || month > 12)
	{
		return false;
	}

	// is date valid
	var daysInMonth = date_getDaysInMonth(month, year);
	if(date > daysInMonth)
	{
		return false;
	}

	return true;
}

/*@protected- Get days in month
@param $String$year - Year
@param $String$month - Month
@return $Int$dayCount - Number of days for the month
*/

function date_getDaysInMonth(month, year)
{
    // days in each month
	var dayCounts = new Array(31, -1, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);

	var dayCount;
	if(month == 2)
	{
        dayCount = date_isLeapYear( year ) ? 29 : 28;
	}
	else
	{
		dayCount = dayCounts[month-1];
	}
	return dayCount;
}

/*@protected- Checks whether number represents leap year
@param $String$year - Year
@return $boolean$ - is leap year or not
*/

function date_isLeapYear(year)
{
    if (((year % 4)==0) && ((year % 100)!=0) || ((year % 400)==0))
    {
        return true;
    }
    else
    {
        return false;
    }
}


/**********************************
 *	Title: Length Validation Type
 *
 *	© 2005 Evan Witt
 ***********************************/

/**********************************
The following configuration fields are declared in different file:

// error message strings for length
var length_lengthMsgStr1 = "length_lengthMsgStr1 ";
var length_lengthMsgStr2 = " length_lengthMsgStr2 ";
var length_lengthMsgStr3 = " length_lengthMsgStr3 ";
***********************************/


{
	length_length = new validation_ValidationType("lengthtype", length_isCorrectLength);
	length_length.addAttributeThatImplies("requiredLength");
	length_length.addEventFunction("onblur", length_isCorrectLength);
}

/*@protected- Check the length of the value.
@param $Object$object - Object of the element
@return $Object$ - Return validation_Error object
*/

function length_isCorrectLength(object)
{
	var str = pega.control.PlaceHolder.getValue(object);
	var length = parseInt(object.getAttribute("requiredLength"));
	if(null == str || "" == str || isNaN(length))
	{
		return;
	}

	if(str.length != length)
	{
		//var errorMessage = length_lengthMsgStr1 + object.displayName + length_lengthMsgStr2 + length + length_lengthMsgStr3;
        var errorMessage = length_lengthMsgStrFull;
        errorMessage = resolveParams(errorMessage,[length]);
		return (new validation_Error(object, errorMessage));
	}

}
/**********************************
 *	Title: Numeric Validation Types
 *
 *	© 2005 Evan Witt
 ***********************************/

/**********************************
The following configuration fields are declared in different file:

// error message strings for min
var numeric_minMsgStr1 = "numeric_minMsgStr1 ";
var numeric_minMsgStr2 = " numeric_minMsgStr2 ";
var numeric_minMsgStr3 = " numeric_minMsgStr3 ";

// error message strings for max
var numeric_maxMsgStr1 = "numeric_maxMsgStr1 ";
var numeric_maxMsgStr2 = " numeric_maxMsgStr2 ";
var numeric_maxMsgStr3 = " numeric_maxMsgStr3 ";

// error message strings for lessThan
var numeric_lessThanMsgStr1 = "numeric_lessThanMsgStr1 ";
var numeric_lessThanMsgStr2 = " numeric_lessThanMsgStr2 ";
var numeric_lessThanMsgStr3 = " numeric_lessThanMsgStr3 ";

// error message strings for less than equal
var numeric_lessThanEqualMsgStr1 = "numeric_lessThanEqualMsgStr1 ";
var numeric_lessThanEqualMsgStr2 = " numeric_lessThanEqualMsgStr2 ";
var numeric_lessThanEqualMsgStr3 = " numeric_lessThanEqualMsgStr3 ";

// error message strings for less than equal
var numeric_greaterThanMsgStr1 = " numeric_greaterThanMsgStr1 ";
var numeric_greaterThanMsgStr2 = " numeric_greaterThanMsgStr2 ";
var numeric_greaterThanMsgStr3 = " numeric_greaterThanMsgStr3 ";


// error message strings for less than equal
var numeric_greaterThanEqualMsgStr1 = " numeric_greaterThanEqualMsgStr1 ";
var numeric_greaterThanEqualMsgStr2 = " numeric_greaterThanEqualMsgStr2 ";
var numeric_greaterThanEqualMsgStr3 = " numeric_greaterThanEqualMsgStr3 ";

// error message strings for decimal
var numeric_decimalMsgStr1 = " numeric_decimalMsgStr1 ";
var numeric_decimalMsgStr2 = " numeric_decimalMsgStr2 ";
var numeric_decimalMsgStr3 = " numeric_decimalMsgStr3 ";
***********************************/


/**
	Type declarations
 */
{
	var numeric_min = new validation_ValidationType("min", numeric_isAboveMin);
	numeric_min.addEventFunction("onblur", numeric_isAboveMin);
	numeric_min.addAttributeThatImplies("min");

	var numeric_max = new validation_ValidationType("max", numeric_isAboveMax);
	numeric_max.addEventFunction("onblur", numeric_isAboveMax);
	numeric_max.addAttributeThatImplies("max");

	var numeric_lessThan = new validation_ValidationType("lessthan", numeric_isLessThan);
	numeric_lessThan.addAttributeThatImplies("lessThan");

	var numeric_lessThanEqual = new validation_ValidationType("lessthanequal", numeric_isLessThanOrEqual);
	numeric_lessThanEqual.addAttributeThatImplies("lessThanEqual");

	var numeric_greaterThan = new validation_ValidationType("greaterthan", numeric_isGreaterThan);
	numeric_greaterThan.addAttributeThatImplies("greaterThan");

	var numeric_greaterThanEqual = new validation_ValidationType("greaterthanequal", numeric_isGreaterThanOrEqual);
	numeric_greaterThanEqual.addAttributeThatImplies("greaterThanEqual");

}


//=================MIN=========================
/*
@protected- Validation function for is above minimum value.
This function returns the validation error object if the field is above minimum value.
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/
function numeric_isAboveMin(object)
{
	if(null == object.min)
	{
		return;
	}

	var fieldValue = numeric_parseNumber(pega.control.PlaceHolder.getValue(object));
	var otherValue = numeric_parseNumber(object.getAttribute("min"));
	if(isNaN(fieldValue) || isNaN(otherValue))
	{
		return;
	}

	if(fieldValue < otherValue)
	{
		//var errorMessage = numeric_minMsgStr1 + object.displayName + numeric_minMsgStr2 + object.min + numeric_minMsgStr3;
        var errorMessage = numeric_minMsgStrFull;
        errorMessage = resolveParams(errorMessage,[object.getAttribute("min")]);
		return (new validation_Error(object, errorMessage));
	}
}


//=================MAX=========================

/*
@protected- Validation function for is above maximum value.
This function returns the validation error object if the field is above maximum value.
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function numeric_isAboveMax(object)
{
	if(null == object.max)
	{
		return;
	}

	/* BUG-618549 : For slider control the object.value is always without considering the locale */
  var currValue = pega.control.PlaceHolder.getValue(object);
  if(object.type === "range"){
    var currentLocale = pega && pega.u && pega.u.d && pega.u.d.Locale.replace("_","-");
    if(currentLocale && currValue.indexOf(".") !== -1)
      currValue = Number(currValue).toLocaleString(currentLocale);
  }
  /* end */
	var fieldValue = numeric_parseNumber(currValue);
	var otherValue = numeric_parseNumber(object.getAttribute("max"));
	if(isNaN(fieldValue) || isNaN(otherValue))
	{
		return;
	}

	if(fieldValue > otherValue)
	{
		//var errorMessage = numeric_maxMsgStr1 + object.displayName + numeric_maxMsgStr2 + object.max + numeric_maxMsgStr3;
        var errorMessage = numeric_maxMsgStrFull;
        errorMessage = resolveParams(errorMessage,[object.getAttribute("max")]);
		return (new validation_Error(object, errorMessage));
	}

}



//=================LESS THAN=========================

/*
@protected- Validation function for check less than.
This function returns the validation error object if the field is less than the value.
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function numeric_isLessThan(object)
{
	var otherField = pega.ctx.dom.getElementById(object.getAttribute("lessThan"));
	if(null == otherField)
	{
		return;
	}

	var fieldValue = numeric_parseNumber(pega.control.PlaceHolder.getValue(object));
	var otherValue = numeric_parseNumber(pega.control.PlaceHolder.getValue(otherField));
	if(isNaN(fieldValue) || isNaN(otherValue))
	{
		return;
	}

	if(fieldValue >= otherValue)
	{
		//var errorMessage = numeric_lessThanMsgStr1 + object.displayName + numeric_lessThanMsgStr2 +
		//					otherField.displayName + numeric_lessThanMsgStr3;
        var errorMessage = numeric_lessThanMsgStrFull;
        errorMessage = resolveParams(errorMessage,[otherField.displayName]);
		return (new validation_Error(object, errorMessage));
	}
}


//=================LESS THAN OR EQUAL=========================

/*
@protected- Validation function for check less than or equal.
This function returns the validation error object if the field is less than or equal the value.
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function numeric_isLessThanOrEqual(object)
{
	var otherField = pega.ctx.dom.getElementById(object.getAttribute("lessThanEqual"));
	if(null == otherField)
	{
		return;
	}

	var fieldValue = numeric_parseNumber(pega.control.PlaceHolder.getValue(object));
	var otherValue = numeric_parseNumber(pega.control.PlaceHolder.getValue(otherField));
	if(isNaN(fieldValue) || isNaN(otherValue))
	{
		return;
	}

	if(fieldValue > otherValue)
	{
		//var errorMessage = numeric_lessThanEqualMsgStr1 + object.displayName + numeric_lessThanEqualMsgStr2 +
		//					otherField.displayName + numeric_lessThanEqualMsgStr3;
		var errorMessage = numeric_lessThanEqualMsgStrFull;
        errorMessage = resolveParams(errorMessage,[otherField.displayName]);
      return (new validation_Error(object, errorMessage));
	}
}



//=================GREATER THAN=========================
/*
@protected- Validation function for check greater than.
This function returns the validation error object if the field is greater than the value.
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function numeric_isGreaterThan(object)
{
	var otherField = pega.ctx.dom.getElementById(object.getAttribute("greaterThan"));
	if(null == otherField)
	{
		return;
	}

	var fieldValue = numeric_parseNumber(pega.control.PlaceHolder.getValue(object));
	var otherValue = numeric_parseNumber(pega.control.PlaceHolder.getValue(otherField));
	if(isNaN(fieldValue) || isNaN(otherValue))
	{
		return;
	}

	if(fieldValue <= otherValue)
	{
		//var errorMessage = numeric_greaterThanMsgStr1 + object.displayName + numeric_greaterThanMsgStr2 +
		//					otherField.displayName + numeric_greaterThanMsgStr3;
		var errorMessage = numeric_greaterThanMsgStrFull;
        errorMessage = resolveParams(errorMessage,[otherField.displayName]);
      return (new validation_Error(object, errorMessage));
	}
}



//=================GREATER THAN OR EQUAL=========================
/*
@protected- Validation function for check greater than or equal.
This function returns the validation error object if the field is less than or greater the value.
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/
function numeric_isGreaterThanOrEqual(object)
{
	var otherField = pega.ctx.dom.getElementById(object.getAttribute("greaterThanEqual"));
	if(null == otherField)
	{
		return;
	}

	var fieldValue = numeric_parseNumber(pega.control.PlaceHolder.getValue(object));
	var otherValue = numeric_parseNumber(pega.control.PlaceHolder.getValue(otherField));
	if(isNaN(fieldValue) || isNaN(otherValue))
	{
		return;
	}

	if(fieldValue < otherValue)
	{
		//var errorMessage = numeric_greaterThanEqualMsgStr1 + object.displayName + numeric_greaterThanEqualMsgStr2 +
		//					otherField.displayName + numeric_greaterThanEqualMsgStr3;
		var errorMessage = numeric_greaterThanEqualMsgStrFull;
        errorMessage = resolveParams(errorMessage,[otherField.displayName]);
      return (new validation_Error(object, errorMessage));
	}

}

//=====================DECIMAL TYPE=============================

/*
@protected- Function for keypress filtering
@return $void$
*/

function numeric_filterKeyPress()
{
	var allowKey = (valutility_isNumeric() ||
					valutility_isCharacter(PERIOD_KEYCODE) ||
					valutility_isCharacter(COMMA_KEYCODE) ||
					valutility_isCharacter(MINUS_KEYCODE));
	if(!allowKey)
	{
		valutility_cancelKeyPress();
	}
	return null;
}

function convertToUniversalFormat( strValue) {

	var spcRegExp = /\s/g;
	strValue = strValue.replace(spcRegExp, '');  //remove spaces

	var objRegExp = new RegExp("\\" + grouping_separator, "g"); //search for grouping Separator
	//replace all matches with empty strings
	strValue =  strValue.replace(objRegExp,'');

	var objRegExp = new RegExp("\\" + decimal_separator, "g"); //search for decimal Separator
	//replace all matches with .
	return strValue.replace(objRegExp,'.');
}



//=================DECIMALS PLACES=========================

/*
@protected- Function to ensure decimal places of a string
@param $String$numberString- Number string
@param $String$noOfDecimals- Number of decimal places
@return $Int$
*/


function numeric_ensureDecimalPlaces(numberString, noOfDecimals)
{
	if(null == numberString || "" == numberString)
	{
		return;
	}

	//re = /(\-?)([^\.]*)\.?(\d*)/
	var re =new RegExp("(\\-?)([^\\" + decimal_separator + "]*)\\" + decimal_separator + "?(\\d*)");
	var result = re.exec(numberString);

	var negativeSign = result[1];
	var numberPart = result[2];
	var decimalPart = result[3];

	var pureNumber = 0;
	var digitPlace = 0;

	for(var i=0; i<numberPart.length; i++)
	{
		var thisNumber = parseInt(numberPart.charAt(i));
		if(!isNaN(thisNumber))
		{
			pureNumber = (10*pureNumber) + thisNumber;
		}
	}

	// if there are 0 decimals, it is a special case - all others handled below
	if(noOfDecimals == 0)
	{
		var number = parseFloat(pureNumber + "." + decimalPart);
		return Math.round(number);
	}

	var orginalNoOfDecimals = decimalPart.length;

	// get amount of decimal
	var decimalString = numeric_removePrecedingZeros(decimalPart);
	var decimalNumber = parseInt(decimalString);
	decimalNumber = (isNaN(decimalNumber)) ? 0 : decimalNumber;

	// follow example on the right with number 4214.4363, assume 2 decimals wanted
	var allDigits = pureNumber*Math.pow(10, orginalNoOfDecimals) + decimalNumber;  // 42144363

	if(0 == allDigits) // special case if it is 0
	{
		return numeric_addTrailingZeros("0" + decimal_separator, noOfDecimals);
	}

	if(negativeSign != null && negativeSign != "") // take negativity into account
	{
		allDigits *= -1;
	}

	var numToRound = allDigits/(Math.pow(10, (orginalNoOfDecimals - noOfDecimals) )); // 421443.63
	var rounded = Math.round(numToRound); // 421444
	var finalNumber = rounded/(Math.pow(10, noOfDecimals)); // 4214.44

	var numberStr = "" + finalNumber;
	var shouldBeLength = ("" + rounded).length + 1;
	var retVal;
	if(numberStr.length == (shouldBeLength - 1 - noOfDecimals))
	{
		retVal = numberStr + decimal_separator;
		retVal = numeric_addTrailingZeros(retVal, noOfDecimals);
	}
	else if(shouldBeLength == numberStr.length)
	{
		retVal = numberStr;
	}
	else
	{
		var neededZeros = shouldBeLength - numberStr.length;
		retVal = numeric_addTrailingZeros(numberStr, neededZeros);
	}

	return retVal;
}

/*
@protected- Function to remove preceding zeros
@param $String$numberString- Number string
@return $String$ - String which zeros have been removed
*/


function numeric_removePrecedingZeros(numberString)
{
	var i=0;
	while(i<numberString.length)
	{
		if(numberString.charAt(i) != "0")
		{
			break;
		}
		i++;
	}
	return numberString.substring(i, numberString.length);
}

/*
@protected- Function to remove trailing zeros
@param $String$str- String to remove trailing zeros
@param $String$noOfZeros- Number of zeros
@return $String$str - String removed trailing zeros
*/

function numeric_addTrailingZeros(str, noOfZeros)
{
	for(var i=0; i<noOfZeros; i++)
	{
		str += "0";
	}
	return str;
}

/*
@protected- Function to reformat numerics
@param $String$x- String to numeric reformat
@return $String$- Formatted string
*/


function numeric_reformat(x)
{
	if(null == x || "" == x)
	{
		return;
	}

	re = /(\-?)([^\.]*)\.?(\d*)/
	var result = re.exec(x);

	var sign = result[1];
	var numberPart = result[2];
	var decimalPart = result[3];

	var newNumberPart = "";
	var digitPlace = 0;
	for(var i=numberPart.length-1; i>=0; i--)
	{
		if(isNaN(parseInt(numberPart.charAt(i))))
		{
			continue;
		}
		newNumberPart = numberPart.charAt(i) + newNumberPart;
		digitPlace++;
		if(digitPlace == 3 && i != 0)
		{
			newNumberPart = "," + newNumberPart;
			digitPlace = 0;
		}
	}
	decimal = (decimalPart == "") ? "" : ".";

	return sign + newNumberPart + decimal + decimalPart;
}

/*
@protected- Counts number of occurences of c in aString
@param $String$aString- String to number of occurances of c
@param $String$c- character
@return $String$- Formatted string
*/

function numeric_occurence(aString, c)
{
	var total = 0;
	for(var i=0;i<aString.length;i++)
	{
		if(c == aString.charAt(i))
		{
			total++;
		}
	}
	return total;
}

/*
@protected- Parse the number
@param $String$str- String to parse as a number
@return $Float$- Parsed number
*/

function numeric_parseNumber(str)
{
	if("" == str || null == str)
	{
		return NaN;
	}

	//var numbersMatch = /[0-9-.]/g;
	var numbersMatch = new RegExp("[0-9-" + decimal_separator + "]", "g");
	var numbers = str.match(numbersMatch);
	if(null == numbers)
	{
		return NaN;
	}

	var theNumber = "";
	for(var i=0; i<numbers.length; i++)
	{
		theNumber += numbers[i];
	}

	var theNumber = convertToUniversalFormat(str);
	return parseFloat(theNumber);
}


/**********************************
 *	Title: Rang Show Validation Type
 *
 *	© 2005 Evan Witt
 ***********************************/

{
	rangeshow_rangeShow = new validation_ValidationType("rangeshow", null);
	rangeshow_rangeShow.addEventFunction("onblur", rangeshow_isInRange);
	rangeshow_rangeShow.addEventFunction("onload", rangeshow_isInRange);
}

/*
@protected- Function to check is in range
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function rangeshow_isInRange(object)
{
	if(null == object.elementIdToShow)
	{
		return;
	}

	var otherElement = pega.ctx.dom.getElementById(object.elementIdToShow);

	var lowerBound = parseFloat(object.lowerBound);
	var upperBound = parseFloat(object.upperBound);

	if(isNaN(lowerBound))
	{
		lowerBound = Number.NEGATIVE_INFINITY;
	}

	if(isNaN(upperBound))
	{
		upperBound = Number.POSITIVE_INFINITY;
	}

	otherElement.style.display = "none";
	var value = parseFloat(pega.control.PlaceHolder.getValue(object));
	if(isNaN(value))
	{
		return;
	}

	if(value >= lowerBound && value <= upperBound)
	{
		otherElement.style.display = "";
	}
}


/**********************************
 *	Title: z Validation Types
 *
 *	© 2005 Evan Witt
 ***********************************/

/**********************************
The following configuration fields are declared in different file:

// error meessage string for required selections
var select_reqSelMsgStr1 = " select_reqSelMsgStr1 ";
var select_reqSelMsgStr2 = " select_reqSelMsgStr2 ";
var select_reqSelMsgStr3 = " select_reqSelMsgStr3 ";

// error meessage string for minimum selections
var select_minSelMsgStr1 = " select_minSelMsgStr1 ";
var select_minSelMsgStr2 = " select_minSelMsgStr2 ";
var select_minSelMsgStr3 = " select_minSelMsgStr3 ";

// error meessage string for maximum selections
var select_maxSelMsgStr1 = " select_maxSelMsgStr1 ";
var select_maxSelMsgStr2 = " select_maxSelMsgStr2 ";
var select_maxSelMsgStr3 = " select_maxSelMsgStr3 ";
***********************************/



/**
	Type declarations
 */
{
	var select_requiredselections = new validation_ValidationType("requiredselections", select_hasReqSelections);
	select_requiredselections.addAttributeThatImplies("requiredselections");

	var select_minselections = new validation_ValidationType("minselections", select_hasMinSelections);
	select_minselections.addAttributeThatImplies("minselections");

	var select_maxselections = new validation_ValidationType("maxselections", select_hasMaxSelections);
	select_maxselections.addAttributeThatImplies("maxselections");
}


//=================REQUIRED AMOUNT OF SELECTIONS=========================
/*
@protected- Function to check required amount of selections
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function select_hasReqSelections(object)
{
	var requiredSelections = parseInt(object.getAttribute("requiredselections"));
	var numberOfSelections = select_countSelections(object);

	if(requiredSelections != numberOfSelections)
	{
		//var errorMessage = select_reqSelMsgStr1 + object.displayName + select_reqSelMsgStr2 +
		//					object.requiredselections + select_reqSelMsgStr3;
		var errorMessage = select_reqSelMsgStrFull;
        errorMessage = resolveParams(errorMessage,[object.getAttribute("requiredselections")]);
      return (new validation_Error(object, errorMessage));
	}
}

//=================MINIMUM NUMBER OF SELECTIONS=========================
/*
@protected- Function to check minimum number of selections
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function select_hasMinSelections(object)
{
	var minSelections = parseInt(object.getAttribute("minselections"));
	var numberOfSelections = select_countSelections(object);

	if(minSelections > numberOfSelections)
	{
		//var errorMessage = select_minSelMsgStr1 + object.displayName + select_minSelMsgStr2 +
		//					object.minselections + select_minSelMsgStr3;
		var errorMessage = select_minSelMsgStrFull;
        errorMessage = resolveParams(errorMessage,[object.getAttribute("minselections")]);
      return (new validation_Error(object, errorMessage));
	}
}

//=================MAXIMUM NUMBER OF SELECTIONS=========================
/*
@protected- Function to check maximum number of selections
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function select_hasMaxSelections(object)
{
	var maxSelections = parseInt(object.getAttribute("maxselections"));
	var numberOfSelections = select_countSelections(object);

	if(maxSelections < numberOfSelections)
	{
		//var errorMessage = select_maxSelMsgStr1 + object.displayName + select_maxSelMsgStr2 +
		//					object.maxselections + select_maxSelMsgStr3;
		var errorMessage = select_maxSelMsgStrFull;
        errorMessage = resolveParams(errorMessage,[object.getAttribute("maxselections")]);
      return (new validation_Error(object, errorMessage));
	}
}

//=================UTILITY FUNCTIONS=========================
/*
@protected- Function to count selections
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function select_countSelections(object)
{
	var selectedCount = 0;
	for(var i=0; i<object.childNodes.length; i++)
	{
		if(object.childNodes[i].selected)
		{
			selectedCount++;
		}
	}
	return selectedCount;
}

/**********************************
 *	Title: Time Validation Types
 *
 *	© 2005 Evan Witt
 ***********************************/

/**********************************
The following configuration fields are declared in different file:

// error meessage string for time
var time_timeMsgStr1 = " time_timeMsgStr1 ";
var time_timeMsgStr2 = " time_timeMsgStr2 ";

// error meessage string for time after
var time_afterTimeMsgStr1 = " time_afterTimeMsgStr1 ";
var time_afterTimeMsgStr2 = " time_afterTimeMsgStr2 ";
var time_afterTimeMsgStr3 = " time_afterTimeMsgStr3 ";

// error meessage string for time before
var time_beforeTimeMsgStr1 = " time_beforeTimeMsgStr1 ";
var time_beforeTimeMsgStr2 = " time_beforeTimeMsgStr2 ";
var time_beforeTimeMsgStr3 = " time_beforeTimeMsgStr3 ";

var time_use24HourFormat = false;
***********************************/


// time declaration
{
	var time_time = new validation_ValidationType("time", time_isTime);
	time_time.addEventFunction("onblur", time_isTime);

	var time_timeBefore = new validation_ValidationType("timebefore", time_isBefore);
	time_timeBefore.addAttributeThatImplies("timeBefore");

	var time_timeAfter = new validation_ValidationType("timeafter", time_isAfter);
	time_timeAfter.addAttributeThatImplies("timeAfter");
}
/*
@protected- Function to validate Time
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function time_isTime(object)
{
	var time = pega.control.PlaceHolder.getValue(object);
	if(null == time || "" == time)
	{
		return;
	}

	var timeOffset = time_stringToOffset(time)
	if(timeOffset == -1)
	{
		//var errorMessage = time_timeMsgStr1 + object.displayName + time_timeMsgStr2;
        var errorMessage = time_timeMsgStrFull;
        errorMessage = resolveParams(errorMessage,[object.displayName]);
       return (new validation_Error(object, errorMessage));
	}

	pega.control.PlaceHolder.setValue(object, (time_use24HourFormat) ? time_offsetTo24Hr(timeOffset) : time_offsetTo12Hr(timeOffset));
}

/*
@protected- Function to validate time after
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function time_isAfter(object)
{
	var otherField = pega.ctx.dom.getElementById(object.getAttribute("timeAfter"));
	if(null == otherField)
	{
		return;
	}

	var fieldValue = time_stringToOffset(pega.control.PlaceHolder.getValue(object));
	var otherValue = time_stringToOffset(pega.control.PlaceHolder.getValue(otherField));
	if((-1 == fieldValue) || (-1 == otherValue))
	{
		return;
	}

	if(fieldValue <= otherValue)
	{
		//var errorMessage = time_afterTimeMsgStr1 + object.displayName + time_afterTimeMsgStr2 +
		//					otherField.displayName + time_afterTimeMsgStr3;
		var errorMessage = time_afterTimeMsgStrFull;
        errorMessage = resolveParams(errorMessage,[otherField.displayName]);
      return (new validation_Error(object, errorMessage));
	}
}

/*
@protected- Function to validate Time before
@param $object$object- The object which represents the input field
@return $object$validation_Error - Validation Error object
*/

function time_isBefore(object)
{
	var otherField = pega.ctx.dom.getElementById(object.getAttribute("timeBefore"));
	if(null == otherField)
	{
		return;
	}

	var fieldValue = time_stringToOffset(pega.control.PlaceHolder.getValue(object));
	var otherValue = time_stringToOffset(pega.control.PlaceHolder.getValue(otherField));
	if((-1 == fieldValue) || (-1 == otherValue))
	{
		return;
	}

	if(fieldValue >= otherValue)
	{
		//var errorMessage = time_beforeTimeMsgStr1 + object.displayName + time_beforeTimeMsgStr2 +
		//					otherField.displayName + time_beforeTimeMsgStr3;
	  var errorMessage = time_beforeTimeMsgStrFull;
      errorMessage = resolveParams(errorMessage,[otherField.displayName]);
      return (new validation_Error(object, errorMessage));
	}
}

/*
@protected- Function to Return a number which represents the number of minutes
past midnight if the time is not valid, returns -1
@param $String$timeString- String to offset
@return $object$validation_Error - Validation Error object
*/

function time_stringToOffset(timeString)
{
	re = /(\d\d*)(:?)(\d*)\s*([ap]?)/g;
	var result = re.exec(timeString.toLowerCase());
	if(null == result)
	{
		return -1;
	}

	var hour;
	var minute;
	var isPM;

	// there was no : separator
	if("" == result[2])
	{
		if(result[1].length==3) // if there are three numbers
		{
			// assume first number is hour
			hour = parseInt(result[1].charAt(0));
			// assume second number is minute
			minute = parseInt(result[1].charAt(1) + result[1].charAt(2));
		}
		else if(result[1].length==4) // if there are four numbers
		{
			hour = parseInt(result[1].charAt(0) + result[1].charAt(1));
			minute = parseInt(result[1].charAt(2) + result[1].charAt(3));
		}
		else
		{
			return -1;
		}
	}
	else
	{
		hour = parseInt(result[1]);
		minute = parseInt(result[3]);
	}

	if(minute<0 || minute>59 || isNaN(minute) || isNaN(hour))
	{
		return -1;
	}

	var timeOffset;
	if(time_use24HourFormat)
	{
		if(hour<0 || hour>23)
		{
			return -1;
		}

		timeOffset = time_24HrToOffset(hour, minute);
	}
	else
	{
		if(hour<1 || hour>12)
		{
			return -1;
		}

		isPM = ("p" == result[4]) ? true : false;
		timeOffset = time_12HrToOffset(hour, minute, isPM);
	}
	return timeOffset;
}

/*
@protected- Function to set time offset to 12 hour
@param $String$offset- String to offset
@return $String$
*/

function time_offsetTo12Hr(offset)
{
	if(offset>=0 && offset<60)
	{
		return "12:" + time_ensureTwoDigits(offset) + "AM";
	}
	else if(offset>=60 && offset<720)
	{
		var hour = Math.floor(offset/60);
		var minute = offset % 60;
		return hour + ":" + time_ensureTwoDigits(minute) + "AM";
	}
	else if(offset>=720 && offset<780)
	{
		var minute = offset % 60;
		return "12:" + time_ensureTwoDigits(minute) + "PM";
	}
	else if(offset>=780 && offset<1440)
	{
		offset -= 12*60;
		var hour = Math.floor(offset/60);
		var minute = offset % 60;
		return hour + ":" + time_ensureTwoDigits(minute) + "PM";
	}
}

/*
@protected- Function to set time offset to 24 hour
@param $String$offset- String to offset
@return $String$
*/

function time_offsetTo24Hr(offset)
{
	var hour = Math.floor(offset/60);
	var minute = offset % 60;
	return time_ensureTwoDigits(hour) + ":" + time_ensureTwoDigits(minute);
}

/*
@protected- Function to ensure two digits
@param $String$number- A number
@return $String$number
*/

function time_ensureTwoDigits(number)
{
	if(number<10)
	{
		return "0" + number;
	}
	return number;
}
/*
@protected- Function to set time 12 hour to offset
@param $String$offset- String to offset
@return $String$
*/
function time_12HrToOffset(hour, minute, isPM)
{
	var minuteOffset = hour*60 + minute;
	if(isPM)
	{
		minuteOffset += 60*12;
	}
	if(hour==12)
	{
		minuteOffset -= 60*12;
	}
	return minuteOffset;
}
/*
@protected- Function to set time 24 hour to offset
@param $String$offset- String to offset
@return $String$
*/
function time_24HrToOffset(hour, minute)
{
	return hour*60 + minute;
}


/*Validations for Minimum Character Length in Text Input Type Controls */
{
	length_mincharlength = new validation_ValidationType("minchars", length_hasMinChars);
	length_mincharlength.addAttributeThatImplies("minchars");
	length_mincharlength.addEventFunction("onblur", length_hasMinChars);
	length_mincharlength.addEventFunction("onchange", length_hasMinChars);
}

function resolveParams(inputString,params)
{
  var outputString=inputString;
  if(params)
    {
      for(var i=1;i<=params.length;i++)
        {
          var tempStr="{"+i+"}";
          outputString=outputString.replace(tempStr, params[i-1]);
        }
      }
  return outputString;
}

function length_hasMinChars(object)
{
	var str = pega.control.PlaceHolder.getValue(object);
	var length = parseInt(object.getAttribute("minchars"));
	if(null == str || "" == str || isNaN(length))
	{
		return;
	}

	if(str.length < length)
	{
		// var errorMessage = length_minCharsMsg1 + object.displayName + length_minCharsMsg2 + length + length_minCharsMsg3;
		//var errorMessage = length_minCharsMsg1 +" " +object.displayName +" "+ length_minCharsMsg2 +" "+ length +" "+ length_minCharsMsg3;
        var errorMessage = length_minCharsMsgFull;
        errorMessage=resolveParams(errorMessage,[length]);
		return (new validation_Error(object, errorMessage));
	}
}

function validation_validateFromUIEvent(e, target) {
	if(target == null || typeof(target.nodeName) == 'undefined')
	{
		return;
	}
	var targetTag = target.nodeName.toUpperCase();
	if((targetTag == "INPUT" || targetTag == "SELECT" || targetTag == "TEXTAREA") && target.validationsAdded != true) {
		var attrib = target.getAttribute("validationType");
		if(attrib != null) {
			var validationsList = attrib.split(",");
			for(var i=0; i<validationsList.length; i++) {
        if(pega.ctx.bClientValidation !== "true" && validationsList[i].toLowerCase()!== "calculateexpression") {
          continue;
        }
				var validationObject = validation_ValidationTypes[validationsList[i].toLowerCase()];
				if(validationObject) {
					var eventList = validationObject.eventValidationList;
					var eventsAdded = new Array();
					for(var eventName in eventList) {
						if("onload" != eventName && "onmouseover" != eventName && "onmousedown" != eventName && "onmouseout" != eventName) {
							if(!eventsAdded[eventName]) {
								var customEventHandler = target[eventName];
								target[eventName] = new Function("event", "validation_ValidateFieldOnEvent(this,'" + eventName + "'," + customEventHandler + ", event);");
								if(e && ("focusin" == e.type || "focus" == e.type) && eventName == "onfocus") {
									validation_ValidateFieldOnEvent(target[j], eventName, customEventHandler);
								}
								eventsAdded[eventName] = true;
								target.validationsAdded = true;
							}
						}
					}
				}
			}
		}
	}
}
//static-content-hash-trigger-GCC
/****************************************
@Helper: partial
@Description: Use 'partial' to create a partial or inline partial template
@Usage: To create partial template
{{partial "anchor"}} 
   <a href={{this.href}}>{{this.title}}</a>
{{/partial}}
To consume refer 'includePartial'
****************************************/           
Handlebars.registerHelper('partial', function (templateName,block) {
  Handlebars.templates[templateName]= Handlebars.templates[templateName] || block.fn;
});


/****************************************
@Helper: includePartial
@Description: Use 'includePartial' 
              - To consume an inline/partial helper 
              - Allows parameters
              - Allows Caching of generated markup.
@Usage:  
Include partial:
-----------------
{{#includePartial "anchor"}} 
   fallback content when partial not found
{{/includePartial}}

Cache markup:
-------------
{{#includePartial "anchor" cache="SAVE"}}

Retrive from Cache:
------------------
{{#includePartial "anchor" cache="PLUCK"}}
or
{{#includePartial "anchor" cache="GET"}}
****************************************/
Handlebars.tmplCache = {};
Handlebars.registerHelper('includePartial', function (templateName,options) {
  var params = options.hash;
  var parentParams = this.params;// params of parent component;
  var Cache = Handlebars.tmplCache;
  //Note:Pass unique id to avoid cache conflicts.
  var cacheId = this["pyUniqueId"];
  var cacheAction = params["cache"]; 
  var markup ="",block,template;

  if(cacheAction == "GET"){
     markup = Cache[cacheId];
  }else if(cacheAction == "PLUCK"){
     markup = Cache[cacheId];
     delete Cache[cacheId];
  }else{
    this.params=params;
    template = Handlebars.templates[templateName];
    if(template){
      markup = new Handlebars.SafeString(template(this));
    }else{ //placeholder when template is not avialable
      block = arguments[arguments.length-1];
      markup = block.fn(this); 
    }
    if(cacheAction == "SAVE"){
        Cache[cacheId]=markup;
    }
    parentParams? this.params = parentParams: delete this.params;
  }
  return markup;
});
/****************************************
@Helper: for
@Description: Use 'for' to loop between a range of values 
@Usage:  
{{#for this.startIndex this.endIndex 1}} 
   index:{{this}}
{{/for}}
****************************************/
Handlebars.registerHelper('for', function(from, to, incr, block) {
    var accum = '';
    for(var i = from; i <= to; i += incr){
        accum += block.fn(i);
    }
    return accum;
});

/****************************************
@Helper: if_in
@Description: Use 'if_in' to search an array of values or in arguments
@Usage:  
eg1: {{#if_in numberToSearch arrayOfNumners}}Number Found{{/if_in}}
eg2: {{#if_in isHidden "true" true "1" 1}} It's hidden {{/if_in}}
****************************************/

Handlebars.registerHelper('if_in', function(el,arr,block){
    var matchFound =false,
        len = arguments.length, 
        codeBlock;
    if(arr instanceof Array && len===3){ //passed via array
       matchFound = arr.indexOf(el)>-1;
       codeBlock = block;
    }else if(len>=3){  // passed via arguments
       matchFound = searchArgs(el,arguments,1,len-1);
       codeBlock = arguments[len-1];
    }else{
      console.error("insufficient number of arguments for helper:if_in");
    }
	return matchFound? codeBlock.fn(this) : codeBlock.inverse(this);
});

//Use to search arguments object with a range (start & end)
function searchArgs(el,args,start,end){
  var matchFound =false, i;
  for(i=start;i<end;i++){
    if(args[i] === el){
       matchFound = true;
       break;
    }
  }
  return matchFound;
}

Handlebars.registerHelper("printAttributeIfNotEmpty", function(attrName, attrVal) {
	if(attrVal) {
		return new Handlebars.SafeString(attrName + "=" + attrVal);
	} else {
		return "";
	}
});

Handlebars.registerHelper("printAttributeIfNotEmptyWithPrefixAndSuffix", function(attrName, attrVal, prefix, suffix) {
	if(attrVal) {
		return new Handlebars.SafeString(attrName + "=" + ((prefix ? prefix : "") + attrVal + (suffix ? suffix : "")));
	} else {
		return "";
	}
});

Handlebars.registerHelper("getMenuDepth", function(entryHandle) {
  if(entryHandle) {
    entryHandle = entryHandle.substring(entryHandle.indexOf('$', 1));
    entryHandle = entryHandle.replace(/\$ppyElements\$l/g, '');
    return entryHandle;
  }
});


/* Helper function to identify active when menu for maintaining state */
Handlebars.registerHelper("getActiveWhenNav", function(metaData, isActiveIndex, index) {
  var toAddActiveAttr = "";
  /*if(nodeParent && nodeParent.isActiveIndex == index){*/
  if(isActiveIndex == index){
    toAddActiveAttr = "data-active-menu";
  }
  return toAddActiveAttr;
});

Handlebars.registerHelper("JSONToStringInMenu", function(obj, options) {
	var strVal = JSON.stringify(obj);
  if(options){
    strVal = strVal.replace("&#39;","'").replace("&amp;","&").replace("&lt;","<").replace("&gt;",">");
  }
	return strVal;
});

Handlebars.registerHelper("JSONToString", function(obj, options) {
	var strVal = JSON.stringify(obj);
  if(options){
    strVal = strVal.replace("&#39;","'").replace("&amp;","&").replace("&lt;","<").replace("&gt;",">").replace("&quot;","\"");
  }
	return strVal;
});

Handlebars.registerHelper("appendProperty", function(targetObj, key, value) {
	targetObj[key] = value;
});

Handlebars.registerHelper("if_eq", function(a, b, opts) {
	if(a === b) {
		return opts.fn(this);
	} else {
		return opts.inverse(this);
	}
});

Handlebars.registerHelper("if_not_eq", function(a, b, opts) {
	if(a !== b) {
		return opts.fn(this);
	} else {
		return opts.inverse(this);
	}
});

Handlebars.registerHelper('ifCond', function (v1, operator, v2, options) {

    switch (operator) {
         case '!=':
            return (v1 != v2) ? options.fn(this) : options.inverse(this);
        case '==':
            return (v1 == v2) ? options.fn(this) : options.inverse(this);
        case '===':
            return (v1 === v2) ? options.fn(this) : options.inverse(this);
        case '<':
            return (v1 < v2) ? options.fn(this) : options.inverse(this);
        case '<=':
            return (v1 <= v2) ? options.fn(this) : options.inverse(this);
        case '>':
            return (v1 > v2) ? options.fn(this) : options.inverse(this);
        case '>=':
            return (v1 >= v2) ? options.fn(this) : options.inverse(this);
        case '&&':
            return (v1 && v2) ? options.fn(this) : options.inverse(this);
        case '||':
            return (v1 || v2) ? options.fn(this) : options.inverse(this);
        case 'and':
      		return (v1 && v2); /* without 'options' for nested operations */
        case 'eq':
      		return (v1 == v2);
        case 'or':
      		return (v1 || v2);
        case 'neq':
            return (v1 != v2);
        default:
            return options.inverse(this);
    }
});

Handlebars.registerHelper('obfuscateText', function (str) {
	for(var i=0; i<str.length; i++){
		str = str.substr(0,i) + '\u25CF'+ str.substr(i+1)
	}
	return str; 
});

Handlebars.registerHelper("addEllipsis", function(caption, maxWidth) {
	return (caption.length > maxWidth) ? caption.substring(0,maxWidth)+"..." : caption;
});

Handlebars.registerHelper("setParam", function(paramName, paramValue) {
	pega.clientTools.putParamValue(paramName,paramValue);
});


Handlebars.registerHelper("math", function(lvalue, operator, rvalue, options) {
    lvalue = parseFloat(lvalue);
    rvalue = parseFloat(rvalue);
  	var result = 0;
    switch (operator) {
    	case '+': 
        	result = lvalue + rvalue;
        	break;
        case '-': 
        	result = lvalue - rvalue;
        	break;
        case '*': 
        	result = lvalue * rvalue;
        	break;
        case '/': 
        	result = lvalue / rvalue;
        	break;
        case '%': 
        	result = lvalue % rvalue;
        	break;
    }
    return result;
});

/*Handlebar child template renderer helper when client cache API gets optimized

pega.ui.TemplateEngine.registerHelper("renderChildren", function(parentTemplatePath) {
  var childrenComps = pega.ui.ClientCache.find(parentTemplatePath+".pyTemplates");
  if(!childrenComps) {
    return "";
  }
  var childrenMarkup = "";
  var childrenIterator = childrenComps.iterator();
  while(childrenIterator.hasNext()) {
    var ccPage =  childrenIterator.next();
    if(ccPage){
      var treeNode = new pega.ui.TemplateTreeNode(ccPage);
      var pyName = ccPage.get('pyName') ? ccPage.get('pyName').getValue() : 'PLACEHOLDER';
      if(typeof pega.ui.template.RenderingEngine.getRenderer(pyName) == 'function'){
        childrenMarkup = childrenMarkup + pega.ui.template.RenderingEngine.getRenderer(pyName)(treeNode);
      }
    }
  }
  
});
*/
/*
Handlebars.registerHelper("renderChildren", function(parentTemplatePath, index) {
  var ccPage = pega.ui.ClientCache.find(parentTemplatePath+".pyTemplates(" + (index + 1) + ")");
  if(ccPage){
    var treeNode = new pega.ui.TemplateTreeNode(ccPage);
    var pyName = ccPage.get('pyName') ? ccPage.get('pyName').getValue() : 'Placeholder';
    if(pyName && typeof pega.ui.template.RenderingEngine.getRenderer(pyName) == 'function'){
      pega.ui.logger.LogHelper.debug("Rendering child, name: " +pyName+ " and path: " +parentTemplatePath+".pyTemplates(" + (index + 1) + ")");
      return pega.ui.template.RenderingEngine.getRenderer(pyName)(treeNode);
    }
  }
  return "";
});
*/

Handlebars.registerHelper("renderChildren", function(componentInfo) {
	if(!componentInfo)
		return;
	var componentName = componentInfo["pyName"];
	var renderer = pega.ui.template.RenderingEngine.getRenderer(componentName);
	if(typeof renderer == "function") {
		pega.ui.logger.LogHelper.debug("Rendering component: " + componentName);
		return renderer(componentInfo);
	} else {
      	pega.ui.logger.LogHelper.error("Renderer component: " + componentName + " not found");
    }
});

Handlebars.registerHelper("getTemplateMarker", function (componentInfo) {
  return "data-template";
});
//static-content-hash-trigger-GCC
var pega = pega || {};
pega.ui = pega.ui || {};


pega.namespace("pega.ui.DetermineDataProvider");

$.extend(pega.ui.DetermineDataProvider, (function () {
  return {
    
	getClientDataProvider : function (thread) {
   
      var source;
      var nonHC = pega.u.d.ServerProxy.isDestinationRemote();
      var harCtxMgr = pega.ui.HarnessContextMgr;
      var ClientCache;

      // ClientDataProvider
      if (harCtxMgr.get('isUITemplatized') && nonHC)
        ClientCache = pega.ui.ClientDataProvider;
      // ChangeTracker
      else
        ClientCache = pega.ui.ChangeTrackerMap;

      // TODO: remove null check
      if (!ClientCache)
        return;

      if (thread)
        source = ClientCache.getTrackerByThread(thread);
      else
        source = ClientCache.getTracker();

      return source;      
      
    }
    
    

  }

})());
//static-content-hash-trigger-GCC
/*
 * Client Cache is a ClipBoard like structure in Client side
 * that encapsulates properties, pages and page lists and provides
 * convenient methods for them.
 *
 * @see <a href="https://mesh.pega.com/docs/DOC-67439">Client Cache API specification</a>
 */
var pega = pega || {};
pega.ui = pega.ui || {};

pega.ui.ClientCacheHelper = (function() {
	var ERROR_NOT_A_PAGE_JSON = "Passed JSON doesn't correspond to a page";
	var ERROR_NOT_VALID_ARGUMENT = "Passed argument is not valid";

	/*Types of Errors: US-149845*/
	var ERROR_TYPES = {
		ERROR: "error",
		WARNING: "warning",
		INFO: "info"
	};

	var MESSAGE_STATES = {
		ADDED: "added",
		PRESENTED: "presented",
		SUBMITTED: "submitted"
	};

	var SHARED_PAGES = [
		'pxThread',
		'pxRequestor',
		'OperatorID',
		'AccessGroup',
		'Application',
		'Org',
		'OrgDivision',
		'pxProcess'
	];
		
	var messageMap = {};

	var _getPortalWindow = function() {
		return (pega.mobile && pega.mobile.support) ? pega.mobile.support.getPortalWindow() : window;
	}
  
	var _log = function(msg) {
		pega.ui.ClientCache.log(msg);
	}

    var _isSharedWebView = function() {
        return window === _getPortalWindow();
    }

	var _isOfflineEnabled = function () {
		return pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal();
	};

	var _isSharedPage = function(handle) {
		return handle && (handle.startsWith('D_') || handle.startsWith('Declare_') || SHARED_PAGES.some(function(pageName) {
			return handle.startsWith(pageName);
		}));
	};

	var _shouldUseGlobalChangeTracker = function(handle) {
		if (pega.mobile && pega.mobile.isMultiWebViewOfflinePegaMobileClient && _isOfflineEnabled() && _isSharedPage(handle)) {
			var parentWindow = pega.ui.ClientCacheHelper.getPortalWindow();
			return parentWindow && parentWindow.pega.ctx.isMDC;
		}
		return false;
	}

    var _shouldForwardToSharedWebView = function(handle) {
        return _shouldUseGlobalChangeTracker(handle) && !pega.ui.ClientCacheHelper.isSharedWebView();
    }

	var _createEmptyObject = function() {
		if (window !== _getPortalWindow()) {
			return _getPortalWindow().pega.ui.ClientCacheHelper.createEmptyObject();
		}
		return {};
	}

	var _createEmptyArray = function() {
		if (window !== _getPortalWindow()) {
			return _getPortalWindow().pega.ui.ClientCacheHelper.createEmptyArray();
		}
		return [];
	}

	var _createClientCacheObject = function(ref) {
		return new ClientCacheObject(ref);
	}

	var _createClientCacheProperty = function(ref) {
		return new ClientCacheProperty(ref);
	}

	var _createClientCachePage = function(ref) {
		return new ClientCachePage(ref);
	}

	var _createClientCacheList = function(ref, options) {
		return new ClientCacheList(ref, options);
	}

	var _createObjectFromJson = function(json) {
		if (window !== _getPortalWindow()) {
			return _getPortalWindow().pega.ui.ClientCacheHelper.createObjectFromJson(json);
		}
		return JSON.parse(json);
	}

	/* ClientCache specific objects */

	/* Initializes a non-existing property with an empty array (for type=="list") or an empty object (for type=="group") */
	var initListOrGroupIfNecessary = function (propertyContainer, key, type) {
		if (propertyContainer[key] == null) {
			if (type === "group") {
				propertyContainer[key] = pega.ui.ClientCacheHelper.createEmptyObject();
			} else {
				propertyContainer[key] = pega.ui.ClientCacheHelper.createEmptyArray();
			}
		}
	}
	
	var _navigateChangeTracker = function(ref, changetracker) {
		// Reach the object in ChangeTracker
		var splitRef = ref.split(".");
		var prop = changetracker.trackedPropertiesList;
		for (var i = 0; i < (splitRef.length - 1); i++) {
			var propName = changetracker.returnListOrGroupProp(splitRef[i]);
			var keyNew = propName.key;
			var index = propName.index;
			if (propName.type) {
				initListOrGroupIfNecessary(prop, keyNew, propName.type);
				prop = prop[keyNew][index];
			} else {
				prop = prop[splitRef[i]];
			}
		}
		return prop;
	};

	/* ClientCacheObject object - has methods common to property, page, page list */
	var ClientCacheObject = function(propRef) {
		this._ref = propRef;
	};

	/* Returns name of the property / page / list */
	ClientCacheObject.prototype.getName = function() {
		return this._ref.substring(this._ref.lastIndexOf(".") + 1);
	};

	/* Returns fully qualified property reference */
	ClientCacheObject.prototype.getReference = function() {
		return this._ref;
	};

	/* Returns entry handle for the property */
	ClientCacheObject.prototype.getEntryHandle = function() {
		return pega.ui.property.toHandle(this._ref);
	};

	/* Returns the parent ClientCachePage */
	ClientCacheObject.prototype.getParent = function() {
		var parentPropRef = this._ref.substring(0, this._ref.lastIndexOf("."));
		if (parentPropRef) {
			return pega.ui.ClientCache.find(parentPropRef);
		} else {
			return null;
		}
	};

	/* Returns the top level page */
	ClientCacheObject.prototype.getTopLevelPage = function() {
		var topLevelPageRef = this._ref.substring(0, this._ref.indexOf("."));
		if (topLevelPageRef) {
			return pega.ui.ClientCache.find(topLevelPageRef);
		} else {
			return this;
		}
	};

	/* Checks if any error is there on the pages */
	ClientCacheObject.prototype.hasMessages = function() {
		var topRef = this.getTopLevelPage()._ref;
		if (!messageMap[topRef]) {
			return false;
		}
		var isValidRef = function(key, ref) {
			var nextChar = key.substr(ref.length, 1);
			return key === ref || (key.indexOf(ref) === 0 && (nextChar === "." || nextChar === "("));
		};
		for (var key in messageMap[topRef]) {
			if (messageMap[topRef].hasOwnProperty(key)) {
				if (isValidRef(key, this._ref)) {
					var messageArr = messageMap[topRef][key];
					for (var count in messageArr) {
						if (messageArr[count]["type"] == ERROR_TYPES.ERROR || messageArr[count]["state"] == MESSAGE_STATES.ADDED) {
							return true;
						}
					}
				}
			}
		}
		return false;
	};


	ClientCacheObject.prototype.setMessagePresentationState = function(messageState) {
		var topRef = this.getTopLevelPage()._ref;
		if (!messageMap[topRef]) {
			return;
		}
		for (var key in messageMap[topRef]) {
			if (messageMap[topRef].hasOwnProperty(key)) {
				var messageArr = messageMap[topRef][key];
				for (var index in messageArr) {
					if ((messageArr[index]).hasOwnProperty("state")) {
						messageArr[index]["state"] = messageState;
					}
				}
			}
		}

	};

	/* Gets the messages present in the page as String array */
	ClientCacheObject.prototype.getMessages = function(prop, type) {
		var type = type || undefined;
		var messages = pega.ui.ClientCacheHelper.createEmptyArray();
		var topRef = this.getTopLevelPage()._ref;
		if (!messageMap[topRef]) {
			return messages;
		}
		var searchKey = prop ? this._ref + "." + prop : this._ref;
		var isValidRef = function(key, ref) {
			var nextChar = key.substr(ref.length, 1);
			return key === ref || (key.indexOf(ref) === 0 && (nextChar === "." || nextChar === "("));
		};
		for (var key in messageMap[topRef]) {
			if (messageMap[topRef].hasOwnProperty(key)) {
				var ref = null;
				if (key === searchKey) {
					ref = key;
				} else if (isValidRef(key, searchKey)) {
					ref = key;
				}
				if (ref) {
					if (type === undefined || (type !== ERROR_TYPES.ERROR && type !== ERROR_TYPES.INFO && type !== ERROR_TYPES.WARNING)) {
						messages = messages.concat(messageMap[topRef][ref]);
					} else {
						for (var key in messageMap[topRef][ref]) {
							if (messageMap[topRef][ref][key].type === type) {
								messages = messages.concat(messageMap[topRef][ref][key]);
							}
						}
					}
				}

			}
		}

		return messages;
	};

	/* Gets the messages present in the page with handles. */
	ClientCacheObject.prototype.getMessagesWithHandle = function() {
		var messageObj = this._getMessagesWithKeys();
		var returnMessArr = pega.ui.ClientCacheHelper.createEmptyArray();
		var returnMessObj = pega.ui.ClientCacheHelper.createEmptyObject();
		for (var key in messageObj) {
			returnMessObj["handle"] = pega.ui.property.toHandle(key);
			returnMessObj["message"] = messageObj[key];
			returnMessArr.push(returnMessObj);
			returnMessObj = pega.ui.ClientCacheHelper.createEmptyObject();
		}
		return returnMessArr;
	};

	/* Adds an error to the page. Checks for duplicates */
	ClientCacheObject.prototype.addMessage = function(message, property, type) {
		var topRef = this.getTopLevelPage()._ref;
		var type = type || ERROR_TYPES.ERROR;
		var messageObject = pega.ui.ClientCacheHelper.createEmptyObject();
		messageObject["text"] = message;
		messageObject["type"] = type;
		messageObject["state"] = MESSAGE_STATES.ADDED;

		var ref = this._ref;
		if (!message || typeof message !== "string" || message === "") {
			return false;
		}

		if (typeof property !== "undefined" && !(this instanceof ClientCacheProperty)) {
			ref += "." + property;
		}
		if (!messageMap[topRef]) {
			messageMap[topRef] = pega.ui.ClientCacheHelper.createEmptyObject();
		}
		if (!((messageMap[topRef])[ref])) {
			(messageMap[topRef])[ref] = pega.ui.ClientCacheHelper.createEmptyArray();
		}

		var propertyMessages = (messageMap[topRef])[ref];

		//Check for duplicates
		for (var i = 0; i < propertyMessages.length; i++) {
			if (message === propertyMessages[i]["text"]) {
				return false;
			}
		}

		propertyMessages.push(messageObject);
		return true;
	};

	/*Clears all the messages on a page or property*/
	ClientCacheObject.prototype.clearMessages = function(prop) {
		var topRef = this.getTopLevelPage()._ref;
		if (!messageMap[topRef]) {
			return;
		}
		var isValidRef = function(key, ref) {
			var nextChar = key.substr(ref.length, 1);
			return key === ref || (key.indexOf(ref) === 0 && (nextChar === "." || nextChar === "("));
		};
		var searchKey = prop ? this._ref + "." + prop : this._ref;

		for (var key in messageMap[topRef]) {
			if (messageMap[topRef].hasOwnProperty(key)) {
				var ref = null;
				if (key === searchKey) {
					ref = key;
				} else if (isValidRef(key, searchKey)) {
					ref = key;
				}
				if (ref) {
					var messageArr = messageMap[topRef][ref];
					for (var index in messageArr) {
						if (messageArr[index]["type"] === ERROR_TYPES.ERROR || messageArr[index]["state"] === MESSAGE_STATES.SUBMITTED) {
							messageArr.splice(index, 1);
						}
					}

					if ((messageMap[topRef][ref]).length === 0) {
						delete messageMap[topRef][ref];
					}
				}
			}
		}
	};

	/* ClientCacheProperty object - used to represent single valued property */
	var ClientCacheProperty = function(propRef) {
		this.type = pega.ui.ClientCache.OBJECT_TYPE_PROPERTY;
		this._ref = propRef;
	};

	ClientCacheProperty.DIRTY_FLAG_TRUE = true;
	ClientCacheProperty.DIRTY_FLAG_FALSE = false;

	ClientCacheProperty.prototype = _createClientCacheObject();
	ClientCacheProperty.prototype.constructor = ClientCacheProperty;

	/* Getter */
	ClientCacheProperty.prototype.getValue = function() {
		var value;
		// US-92600: Fire expressions on property read
		if (pega.offline && pega.offline.declareexpressions && pega.offline.declareexpressions.fireExpression) {
			pega.offline.declareexpressions.fireExpression(this);
		}
		var changetracker = pega.ui.ClientCache._getChangeTracker(this._ref);
		value = changetracker.getPropertyValue(this._ref, true);

		return value;
	};
	/* Setter */
	ClientCacheProperty.prototype.setValue = function(value) {
        // Re-create the value in case if it's going to be stored on a shared webview
		if (typeof value === "object" && _shouldForwardToSharedWebView(this._ref)) {
			value = pega.ui.ClientCacheHelper.createObjectFromJson(JSON.stringify(value));
		}

		var changetracker = pega.ui.ClientCache._getChangeTracker(this._ref);
		if ((value === null || typeof value != "object") && value !== undefined) {
			var propName = this.getName();
			if (propName.type)
				_navigateChangeTracker(this._ref, changetracker)[propName.key][propName.index] = value;
			else
				_navigateChangeTracker(this._ref, changetracker)[propName] = value;
		} else {
			_log("ClientCacheProperty.setValue: " + ERROR_NOT_VALID_ARGUMENT);
		}
	};
	/* Checks if dirty
	   ClientCacheProperty.prototype.isDirty = function() {
	   // TODO: Not implemented yet
	   }; */
	/* Sets the dirty state
	   ClientCacheProperty.prototype.setDirty = function(dirtyFlag) {
	   // TODO: Not implemented yet
	   }*/

	/* returns number messages on a property */
	ClientCacheProperty.prototype.getMessageCount = function() {
		var topRef = this.getTopLevelPage()._ref;
		if (!messageMap[topRef]) {
			return 0;
		}
		for (var key in messageMap[topRef]) {
			if (key == this._ref
				&& messageMap[topRef].hasOwnProperty(key)) {
				return (messageMap[topRef][key]).length;
			}
		}
		return 0;
	};

	/* ClientCachePage object - used to represent page */
	var ClientCachePage = function(propRef) {
		this.type = pega.ui.ClientCache.OBJECT_TYPE_PAGE;
		this._ref = propRef;
		// Cache the parent object
		//this._model = changetracker.getPropertyValue(this._ref);
	};

	ClientCachePage.prototype = _createClientCacheObject();
	ClientCachePage.prototype.constructor = ClientCachePage;

	/* Returns the property / page / list object on passing the name */
	ClientCachePage.prototype.get = function(propName) {
		if (propName.indexOf(".") === 0) {// strip leading "."
			propName = propName.substring(1, propName.length);
		}
		return pega.ui.ClientCache.find(this._ref + "." + propName);
	};

	/* Returns names of all properties in a page */
	ClientCachePage.prototype.getPropertyNames = function() {
		var changetracker = pega.ui.ClientCache._getChangeTracker(this._ref);
		var _model = changetracker.getPropertyValue(this._ref, true);
		return pega.u.d.getObjectKeys(_model);
	};

	/*returns number of messages on a page and nested properties*/
	ClientCachePage.prototype.getMessagesCountAll = function() {
		var topRef = this.getTopLevelPage()._ref;
		var count = 0;
		if (messageMap[topRef]) {
			for (var prop in messageMap[topRef]) {
				var nextChar = prop.substr(this._ref.length, 1);
				if (messageMap[topRef].hasOwnProperty(prop) && (prop.indexOf(this._ref) === 0 && (nextChar === "." || nextChar === "("))) {
					count += (messageMap[topRef][prop]).length;
				}
			}
		}
		return count;
	};

	/*gets all messages on a page and its nested properties*/
	ClientCachePage.prototype.getMessagesAll = function() {
		return this.getMessages();
	};

	/* Sets the passed client cache page as the content of this page */
	ClientCachePage.prototype.adoptPage = function(fromPage) {
		var withChildProp = function(prop, refPart, callback, changetracker) {
			if (!prop[refPart]) {
				var splitPropName = changetracker.returnListOrGroupProp(refPart);
				if (splitPropName.type) {
					initListOrGroupIfNecessary(prop, splitPropName.key, splitPropName.type);
					prop = prop[splitPropName.key];
					refPart = splitPropName.index;
				} else {
					refPart = splitPropName;
				}
			}
			callback(prop, refPart, changetracker);
		};
		var replaceCurrentProp = function(prop, key) {
			currentProp = prop[key];
		};
		var setChildProp = function(prop, key, changetracker) {
			var json = JSON.stringify(changetracker.getPropertyValue(fromPage._ref));
			prop[key] = pega.ui.ClientCacheHelper.createObjectFromJson(json);
		};

		var propRefSplit = this._ref.split(".");
		if (!propRefSplit || propRefSplit.length === 0) {
			return;
		}
		var changetracker = pega.ui.ClientCache._getChangeTracker(this._ref);
		var currentProp = changetracker.trackedPropertiesList;
		// Navigate through the this reference to get to the place where we want to clone
		for (var idx = 0; idx < propRefSplit.length - 1; idx++) {
			withChildProp(currentProp, propRefSplit[idx], replaceCurrentProp, changetracker);
		}
		withChildProp(currentProp, propRefSplit[idx], setChildProp, pega.ui.ClientCache._getChangeTracker(fromPage._ref));
	};

	/* Sets the object parsed from the passed JSON string as the content of this ClientCachePage */
	ClientCachePage.prototype.adoptJSON = function(jsonStructure, isObject) {
		// Get the JS object
		try {
			var objectInServerFormat;
			if (!isObject) {
				objectInServerFormat = pega.ui.ClientCacheHelper.createObjectFromJson(jsonStructure);
			} else {
				objectInServerFormat = pega.ui.ClientCacheHelper.createObjectFromJson(JSON.stringify(jsonStructure));
			}
		} catch (e) {
			if (pega.ui.ClientCache.isDebug())
				throw e;
			return;
		}
		if (Array.isArray(objectInServerFormat)) {
			_log("ClientCachePage.adoptJSON: " + ERROR_NOT_A_PAGE_JSON);
			return;
		}
		var changetracker = pega.ui.ClientCache._getChangeTracker(this._ref);
		var model = _navigateChangeTracker(this._ref, changetracker);
		var propName = changetracker.returnListOrGroupProp(this.getName());
		if (propName.type) {
			initListOrGroupIfNecessary(model, propName.key, propName.type);
			model[propName.key][propName.index] = objectInServerFormat;
		} else {
			model[propName] = objectInServerFormat;
		}
		this.clearMessages();
	};


	/* Returns a JSON string of the referenced object */
	ClientCachePage.prototype.adoptServerJSON = function(jsonObject) {

		if (!jsonObject || typeof jsonObject != "object")
			return "{}";

		// RegExp to identify scubscript, ex: c(1)
		var regExpPageList = new RegExp("\\([0-9]+\\)$");

		var convertedModel = (function recurseParse(clientObject) {
			var serverObject = pega.ui.ClientCacheHelper.createEmptyObject();

			for (var key in clientObject) {
				if (!clientObject.hasOwnProperty(key))
					continue;

				var value = clientObject[key];

				if (typeof value == "object" && value != null) {
					// Some recursive things needed here

					var isIndexed = key.match(regExpPageList);

					if (isIndexed) {
						// Page list, special handling required
						var baseKey = key.replace(isIndexed[0], "");

						if (!serverObject[baseKey]) {
							serverObject[baseKey] = pega.ui.ClientCacheHelper.createEmptyArray();
						}

						// Dense array implementation
						var index = isIndexed[0].substring(1, isIndexed[0].length - 1);
						if (index > 1) {
							if (!serverObject[baseKey][index - 2])
								_log("Pagelist supplied is a partial one! ");
						}

						serverObject[baseKey][index - 1] = recurseParse(value);
					} else {
						// Two cases, either object or page group
						if (value && value.pxSubscript && isNaN(value.pxSubscript)) {
							// Page group
							var baseKey = key.substring(0, key.lastIndexOf("("));

							if (!serverObject[baseKey]) {
								serverObject[baseKey] = pega.ui.ClientCacheHelper.createEmptyObject();
							}

							serverObject[baseKey][value.pxSubscript] = recurseParse(value);
						} else {
							// Page
							serverObject[key] = recurseParse(value);
						}
					}
				} else {
					serverObject[key] = value;
				}
			}

			return serverObject;
		})(jsonObject);
		this.adoptJSON(convertedModel, true);
	};

	/* Returns a JSON string of the referenced object */
	ClientCachePage.prototype.getJSON = function() {
		var changetracker = pega.ui.ClientCache._getChangeTracker(this._ref);
		var model = changetracker.getPropertyValue(this._ref, true);

		if (!model || typeof model != "object") {
			return "{}";
		}
		// Sanitize data
		//pega.ui.TemplateEngine.purgeAlienData(model);

		if (typeof pega.offline == 'undefined' || (pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationRemote())) {
			return JSON.stringify(model);
		}

		// RegExp to identify scubscript, ex: c(1)
		var regExpPageList = new RegExp("\\([0-9]+\\)$");

		var convertedModel = (function recurseParse(clientObject, parentKey) {

			var serverObject = pega.ui.ClientCacheHelper.createEmptyObject();
			if (Array.isArray(clientObject)) {
				serverObject = pega.ui.ClientCacheHelper.createEmptyArray();
			}

			for (var key in clientObject) {
				if (!clientObject.hasOwnProperty(key))
					continue;

				var originalKey = key;
				var tempKey = key;
				var type;
				var value;

				if (clientObject[key] && Array.isArray(clientObject[key])) {
					serverObject[key] = recurseParse(clientObject[key], originalKey);
					continue;
				} else if (clientObject[key] && typeof clientObject[key] == "object" && Object.keys(clientObject[key]).length > 0) {
					var childKey = Object.keys(clientObject[key])[0];
					if (clientObject[key][childKey] && clientObject[key][childKey]["pxSubscript"] == childKey) {
						serverObject[key] = recurseParse(clientObject[key], originalKey);
						continue;
					}
				}
				//if pagelist or pagegroup item
				if ((key === parseInt(key, 10) || (clientObject[key] && clientObject[key].pxSubscript == key)) && parentKey) {
					tempKey = parentKey + "(" + key + ")";
					type = (key === parseInt(key, 10)) ? "list" : "group";
				}

				if (type != "group") {
					if (pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal()) {
						// Code required for AutoPopulateSupport
						key = pega.ui.AutopopulateSupport.resolveReference(tempKey, changetracker, clientObject, true);
					}
				}

				if (key == tempKey) {
					value = clientObject[originalKey];
				} else {
					value = clientObject[key];
				}

				if (typeof value == "object" && value != null) {
					serverObject[key] = recurseParse(value, originalKey);
				} else {
					serverObject[key] = value;
				}
			}

			return serverObject;
		})(model);

		return JSON.stringify(convertedModel);
	};

	/* Returns a JSON object of the referenced object */
	ClientCachePage.prototype.getJSONObject = function() {
		var changetracker = pega.ui.ClientCache._getChangeTracker(this._ref);
		var model = changetracker.getPropertyValue(this._ref, true);
		if (model) {
			// Sanitize data
			//pega.ui.TemplateEngine.purgeAlienData(model);
			return pega.ui.ClientCacheHelper.createObjectFromJson(JSON.stringify(model));
		} else {
			return pega.ui.ClientCacheHelper.createEmptyObject();
		}
	};

	/* Adds / updates a property / page / list to the page */
	ClientCachePage.prototype.put = function(propName, value) {
		var changetracker = pega.ui.ClientCache._getChangeTracker(this._ref);
		var _model = changetracker.getPropertyValue(this._ref, true);
		if (!_model) {
			console.warn("Attempt to write " + propName + " to a dangling node - Model not found!");
			return null;
		}

		// Validate the property name
		if (typeof propName != "string") {
			_log("ClientCachePage.put propName : " + ERROR_NOT_VALID_ARGUMENT);
			return null;
		}

		// First we want to remove the existing property
		this.remove(propName);

		//Remove error messages on the page
		this.clearMessages(propName);

		// Update its definition
		if (typeof value == "string" || typeof value == "number" || typeof value == "boolean") {
			// It's a single valued property
			//_navigateChangeTracker(this._ref)[this.getName()][propName] = value;
			_model[propName] = value;
		} else if (Array.isArray(value)) {
			// We have successfully deleted the old page list, now is the time for new!
			for (var i = 0; i < value.length; i++) {
				var embeddedPage = pega.ui.ClientCacheHelper.createClientCachePage(this._ref + "." + propName + "(" + (i + 1) + ")");
				embeddedPage.adoptJSON(JSON.stringify(value[i]));
			}
			// Handle the empty array case
			if (value.length == 0) {
				/*var embeddedPage = new ClientCachePage(this._ref + "." + propName+"(0)");
				embeddedPage.adoptJSON("{}");*/
				_model[propName] = pega.ui.ClientCacheHelper.createEmptyArray();
			}
		} else if (typeof value == "object") {
			// Later decide whether it's a page or a page group
			// For now treat it as a page only
			// _navigateChangeTracker(this._ref)[propName] = new Object();
			var embeddedPage = pega.ui.ClientCacheHelper.createClientCachePage(this._ref + "." + propName);
			embeddedPage.adoptJSON(JSON.stringify(value));
		} else {
			_log("ClientCachePage.put value : " + ERROR_NOT_VALID_ARGUMENT);
			return null;
		}
		return this.get(propName);
	};

	ClientCachePage.prototype._addMessages = function(messages) {
		if (!messages || Object.keys(messages).length == 0) {
			return;
		}
		var topRef = this.getTopLevelPage()._ref;
		if (!messageMap[topRef]) {
			messageMap[topRef] = pega.ui.ClientCacheHelper.createEmptyObject();
		}
		for (var key in messages) {
			messageMap[topRef][key] = messages[key];
		}
	};

	ClientCachePage.prototype._getMessagesWithKeys = function() {
		var messagesWithKeys = pega.ui.ClientCacheHelper.createEmptyObject();
		var topRef = this.getTopLevelPage()._ref;
		if (!messageMap[topRef]) {
			return messagesWithKeys;
		}
		var isValidRef = function(key, ref) {
			var nextChar = key.substr(ref.length, 1);
			return key == ref || (key.indexOf(ref) == 0 && (nextChar == "." || nextChar == "("));
		};
		for (var key in messageMap[topRef]) {
			if (messageMap[topRef].hasOwnProperty(key)) {
				if (isValidRef(key, this._ref)) {
					messagesWithKeys[key] = messageMap[topRef][key];
				}
			}
		}
		return messagesWithKeys;
	};

	/* Removes a property / page / list from the page */
	ClientCachePage.prototype.remove = function(propName) {
		var changetracker = pega.ui.ClientCache._getChangeTracker(this._ref);
		var _model = changetracker.getPropertyValue(this._ref, true);
		if (!_model) {
			console.warn("Attempt to remove " + propName + " from a dangling node - Model not found!");
			return null;
		}

		var indexedPropName = "";
		// Check if propName is a valid string
		if (propName && typeof propName == "string") {
			indexedPropName = changetracker.returnListOrGroupProp(propName);
			// Delete the property from model
			if (indexedPropName.type) {
				_model[indexedPropName.key] && delete _model[indexedPropName.key][indexedPropName.index];
			}
			else
				delete _model[propName];
			// Delete page list also
			var prop = pega.ui.ClientCache.find(this._ref + "." + propName);
			if (prop && prop.type == pega.ui.ClientCache.OBJECT_TYPE_LIST) {
				// Delete each page
				var iterator = prop.iterator();
				while (true) {
					var page = iterator.next();
					if (page) {
						page.getParent().remove(page.getName());
					} else {
						break;
					}
				}
			}
			//Remove error messages on the page
			this.clearMessages(propName);
		} else if (propName === undefined) {
			// Remove the page itself
			var parent = this.getParent();
			if (parent) {
				parent.remove(this.getName());
			} else {
				indexedPropName = changetracker.returnListOrGroupProp(this.getName());
				if (indexedPropName.type)
					delete changetracker.trackedPropertiesList[indexedPropName.key][indexedPropName.index];
				else
					delete changetracker.trackedPropertiesList[indexedPropName];
			}
			//Remove error messages on the page
			this.clearMessages();
		} else {
			_log("ClientCachePage.remove propName : " + ERROR_NOT_VALID_ARGUMENT);
		}
	};

	/* ClientCacheList object - used to represent page list */
	var ClientCacheList = function(propRef, options) {
		this.type = pega.ui.ClientCache.OBJECT_TYPE_LIST, this._ref = propRef;

		if (options) {
			//this.options = options;
			this.startIndex = options.startIndex;
			this.endIndex = options.endIndex;
		}

		// Cache the parent object
		//this._parent = this.getParent()._model;
		var parentPropRef = this._ref.substring(0, this._ref.lastIndexOf("."));
		var changeTracker = pega.ui.ClientCache._getChangeTracker(parentPropRef);
		this._parent = changeTracker.getPropertyValue(parentPropRef, true);
		if (this._parent == null) {
			// Revert to the original time consuming method
			this._parent = changetracker.getPropertyValue(this.getParent()._ref, true);
		}

		// Cache pxResults
		this.pxResults = this._parent[this.getName()];
		// Slice
		if (this.startIndex || this.startIndex == 0) {
			this.pxResults = this.pxResults.slice(this.startIndex, this.endIndex);
		}

		if (this._parent) {
			this._get = function(index) {
				if (index != 0) {
					//var value = this._parent[this.getName()][index-1];
					var value = this.pxResults[index - 1];

					if (value) {
						return pega.ui.ClientCacheHelper.createClientCachePage(this._ref + "(" + index + ")");
					}
				}
				return null;
			};
		}/* else { // Unreachable code
        this._get = function(index) {
        var pageRef = this._ref + "(" + index + ")";
        return _find(pageRef);
        };
        }*/
		// this._name = this.getName();
	};

	ClientCacheList.prototype = _createClientCacheObject();
	ClientCacheList.prototype.constructor = ClientCacheList;

	/* Returns the page at particular index */
	ClientCacheList.prototype.get = function(index) {
		/* Old implementation
			 var pageRef = this._ref + "(" + index + ")";
			 return _find(pageRef);
			 */
		/* Check if present */
		return this._get(index);
	};

	ClientCacheList.prototype.size = function(_internal) {

		if (this.getName().type) {
			return this._parent[this.getName().key].length;
		} else {
			if (_internal)
				return this._parent[this.getName()] ? this._parent[this.getName()].length : 0;
			else
				return this.pxResults ? this.pxResults.length : 0;
		}
	};

	ClientCacheList.prototype.add = function(index) {
		// We need to count the number of pages in the page list
		var size = this.size(true);

		if (index == undefined || (typeof index == "number" && index == size + 1)) {
			// Create a blank page at size + 1 position
			//var newIndex = this.getName() + "(" + (size + 1) + ")";
			this._parent[this.getName()][size] = pega.ui.ClientCacheHelper.createEmptyObject();

			// Remove the 0th entry when the first page is added
			/*if (size == 0) {
			  delete this._parent[this.getName()][0];
			}*/

			// Return the handle to the newly created page
			return pega.ui.ClientCache.find(this._ref + "(" + (size + 1) + ")");
		} else if (typeof index == "number" && index <= size) {
			// Validate the index
			// It should be a number, it should be less than or equal to size and it should be greater than 0
			var isValidIndex = (index === parseInt(index, 10)) && index > 0 && index <= size;

			if (isValidIndex) {
				var reindexListMessages = function(messages, index, ref) {
					var reindexedMessages = pega.ui.ClientCacheHelper.createEmptyObject();

					if (!messages || Object.keys(messages).length == 0) {
						return reindexedMessages;
					}
					var oref = ref + "(";
					for (var key in messages) {
						if (messages.hasOwnProperty(key) && key.indexOf(oref) == 0) {
							var oldIndex = parseInt(key.substr(oref.length).substr(0, key.substr(oref.length).indexOf(")")), 10);
							if (oldIndex < index) {
								reindexedMessages[key] = messages[key];
							} else {
								var newIndex = oldIndex + 1;
								var newKey = key.replace(oref + oldIndex + ")", oref + newIndex + ")");
								reindexedMessages[newKey] = messages[key];
							}
						}
					}
					return reindexedMessages;
				};

				// Get the JSON of the parent page
				//var parentObject = JSON.parse(this.getParent().getJSON());
				var changetracker = pega.ui.ClientCache._getChangeTracker(this.getParent()._ref);
				var parentObject = changetracker.getPropertyValue(this.getParent()._ref, true)


				//get existing error messages on this page and reindex the message keys
				var messagesWithKeys = this.getParent()._getMessagesWithKeys();
				messagesWithKeys = reindexListMessages(messagesWithKeys, index, this._ref);

				// Insert the blank page in the index position
				parentObject[this.getName()].splice(index - 1, 0, pega.ui.ClientCacheHelper.createEmptyObject());

				// Construct the parent page again
				//this.getParent().adoptJSON(JSON.stringify(parentObject));

				//repopulate the error messages
				this.getParent()._addMessages(messagesWithKeys);

				//this._parent = this.getParent()._model;
				this._parent = changetracker.getPropertyValue(this.getParent()._ref, true);

				// Return the handle to the newly created page
				return pega.ui.ClientCache.find(this._ref + "(" + index + ")");
			}
		}
	};

	ClientCacheList.prototype.remove = function(index) {
		var size = this.size(true);
		// Validate the index
		// It should be a number, it should be less than or equal to size and it should be greater than 0
		var isValidIndex = index && typeof index == "number" && (index === parseInt(index, 10)) && index > 0 && index <= size;

		if (isValidIndex) {
			var reindexListMessages = function(messages, index, ref) {
				var reindexedMessages = pega.ui.ClientCacheHelper.createEmptyObject();
				if (!messages || Object.keys(messages).length == 0) {
					return reindexedMessages;
				}
				var oref = ref + "(";
				for (var key in messages) {
					if (messages.hasOwnProperty(key) && key.indexOf(oref) == 0) {
						var oldIndex = parseInt(key.substr(oref.length).substr(0, key.substr(oref.length).indexOf(")")), 10);
						if (oldIndex < index) {
							reindexedMessages[key] = messages[key];
						} else if (oldIndex > index) {
							var newIndex = oldIndex - 1;
							var newKey = key.replace(oref + oldIndex + ")", oref + newIndex + ")");
							reindexedMessages[newKey] = messages[key];
						}
					}
				}
				return reindexedMessages;
			};

			// Get the JSON of the parent page
			//var parentObject = JSON.parse(this.getParent().getJSON());
			var changetracker = pega.ui.ClientCache._getChangeTracker(this.getParent()._ref);
			var parentObject = changetracker.getPropertyValue(this.getParent()._ref, true);

			// Remove the element
			parentObject[this.getName()].splice(index - 1, 1);

			//Get existing errors messages on this page and reindex the key
			var messagesWithKeys = this.getParent()._getMessagesWithKeys();
			messagesWithKeys = reindexListMessages(messagesWithKeys, index, this._ref);

			// Construct the parent page again
			//this.getParent().adoptJSON(JSON.stringify(parentObject));

			//Repopulate the collected error messages
			this.getParent()._addMessages(messagesWithKeys);

			this._parent = changetracker.getPropertyValue(this.getParent()._ref, true);

			return true;
		}
		return false;
	};

	/* Returns an iterator over the page list */
	ClientCacheList.prototype.iterator = function(startIndex) {
		var counter = 1;
		if (startIndex) {
			counter = startIndex;
		}
		var that = this;
		var cachedItem, cachedItemIdx;

    // Cache current item as it's usually requested twice
		function _getCachedItem(counter) {
			if (cachedItemIdx !== counter) {
				cachedItem = that._get(counter);
				cachedItemIdx = counter;
			}
			return cachedItem;
		}
    
		return {
			hasNext: function() {
				//return that._model[that._name + "(" + counter + ")"] != null;
				return _getCachedItem(counter) != null;
			},
			next: function() {
				return _getCachedItem(counter++);
			}
			/* Returns the index of ClientCachePage last returned by next
				   getIndex: function() {
				   return counter - 1;
				   } */
		}
	};

	/* Accepts a callback and calls it with each ClientCachePage object */
	ClientCacheList.prototype.each = function(callback) {
		var toProceed = true;
		var iter = this.iterator();
		var counter = 1;
		while(toProceed !== false && iter.hasNext()) { 
			toProceed = callback(iter.next(), counter++); 
		}
	};

    return {
		getPortalWindow: _getPortalWindow,
		isSharedWebView: _isSharedWebView,
		isSharedPage: _isSharedPage,
		isOfflineEnabled: _isOfflineEnabled,
		createEmptyObject: _createEmptyObject,
		createEmptyArray: _createEmptyArray,
		createClientCacheObject: _createClientCacheObject,
		createClientCacheProperty: _createClientCacheProperty,
		createClientCachePage: _createClientCachePage,
		createClientCacheList: _createClientCacheList,
		createObjectFromJson: _createObjectFromJson,
		shouldUseGlobalChangeTracker: _shouldUseGlobalChangeTracker
    }
})();

//////////////////////////////////////////////////////////////////////////

pega.ui.ClientCache = (function() {
	/* CONSTANTS - ClientCache object type */
	var OBJECT_TYPE_PROPERTY = "property";
	var OBJECT_TYPE_PAGE = "page";
	var OBJECT_TYPE_LIST = "list";
	var PRIMARY_THREAD_NAME = "STANDARD";

	/* CONSTANTS - ClientCache error codes */
	var ERROR_NOT_VALID_ARGUMENT = "Passed argument is not valid";

	/* Large Data Page error codes */
	var ERROR_DATAPAGE_NOT_FOUND = 1001;
	var ERROR_CUSTOM_FUNCTION_CORRUPTED = 1002;
	var ERROR_NOT_SUPPORTED = 1004;

	/* CONSTANTS - Debugging */
	var DEBUG_MODE_ON = true;
	var DEBUG_MODE_OFF = false;

	// The changetracker for the current thread
	var localChangeTracker;
	
	// BUG-529137 : Stack to backup the change tracker instances
	var largeDatapageRegistry = {};
	var sourceDatapageRegistry = {};

	var changedPagesList = {};

	/* Initialize the ClientCache with a particular thread
	   *
	   * @param {string} threadName Name of the thread, leave blank for default thread
	   */
	var _init = function(threadName) {
		localChangeTracker = pega.ui.DetermineDataProvider.getClientDataProvider(threadName);
	};


	var getChangeTracker = function(handle) {
		if (!localChangeTracker) {
			_init();
		}
		if (pega.ui.ClientCacheHelper.shouldUseGlobalChangeTracker(handle)) {
			var portalWindow = pega.ui.ClientCacheHelper.getPortalWindow();
            return portalWindow.pega.ui.DetermineDataProvider.getClientDataProvider(PRIMARY_THREAD_NAME);	
		}
		return localChangeTracker;
	};

	/* Reset ClientCache with default thread */
	var _reset = _init;
  
	/* Switch off or on auto refreshing of parametrized datapages after synchronization.
	* @param autoRefresh {boolean} If false then switch off auto refreshing.
	*/
	var _autoRefreshParamDP = true;
	var _setAutorefreshParametrizedDatapages = function(autoRefresh) {
		_autoRefreshParamDP = !!autoRefresh; // NOSONAR
	};

	/* 
	  TASK-895034 : End of API changes for multiple thread support
	*/

	/* Logging and debugging */
	var debug = pega.ui.debug;

	var _isDebug = function() {
		return (debug || pega.ui.debug);
	};

	var _log = function(msg) {
		if (_isDebug() && window.console) {
			console.log(msg);
		}
	};

	/* Set the debug mode on of off
	   *
	   * @param {boolean} debugMode The mode of debugging, can be on or off
	   * @returns {Object} ClientCache debugging methods
	   */
	var _setDebugMode = function(debugMode) {
		if (debugMode === DEBUG_MODE_ON || debugMode === DEBUG_MODE_OFF) {
			debug = debugMode;
		}

		return {
			resetDatapageRegistry: _resetDatapageRegistry
		}
	};

	/*
	   * Synchronously returns "true" only for datapages which are known as large
	   *
	   * @param {string} datapageName
	   * @returns {boolean}
	   */
	var _isLargeDatapage = function(datapageName) {
		var isLarge = false;
		if (datapageName) {			
			if (_shouldInitializeChangeTracker()) {
				_init();
			} 
      		var changetracker = getChangeTracker(datapageName);
			var entity = changetracker.getPropertyValue(datapageName, true);
			if (entity) {
				isLarge = entity['pxIsLarge'] === "true";
			}
		}
		return isLarge;
	};

	/*
	   * Helper methods to handle dynamic load of Large Datapages
	   */

	var _resetDatapageRegistry = function() {
		largeDatapageRegistry = {};
		sourceDatapageRegistry = {};
	};

	var _compareParams = function(currentParams, lastParams) {
		if (lastParams === undefined) {
			return false;
		}

		var currentParamsLength = Object.keys(currentParams).length;
		var lastParamsLength = Object.keys(lastParams).length;

		if (currentParamsLength !== lastParamsLength) {
			return false;
		}

		for (var param in currentParams) {
			if (currentParams[param] !== lastParams[param]) {
				return false;
			}
		}
		return true;
	};

	/*
	   * Registers large datapage with its populating function
	   *
	   * @param {string} datapageName The name of large datapage
	   * @param {Function} customFunction Reference to custom function to populate large datapage
	   * @param {Array} sourceDatapages Array of large datapage source pages (optional)
	   */
	var _registerLargeDatapage = function(datapageName, customFunction, sourceDatapages) {
		if (typeof datapageName !== 'string') {
			_log("pega.ui.ClientCache: Can't register large datapage. Provide valid datapage name.");
			return;
		}

		if (typeof customFunction !== 'function') {
			_log("pega.ui.ClientCache: Can't register large datapage " + datapageName + " due to invalid custom function reference.");
			return;
		}

		if (!(sourceDatapages === undefined || Array.isArray(sourceDatapages))) {
			_log("pega.ui.ClientCache: Can't register large datapage " + datapageName + " due to invalid source datapages format.");
			return;
		}

		if (largeDatapageRegistry[datapageName]) {
			_log("pega.ui.ClientCache: Custom function for large datapage " + datapageName + " is already registered.");
			return;
		}

		var largeDatapageDef = {
			"customFunction": customFunction,
			"sourceDatapages": sourceDatapages || [],
			"lastParams": undefined,
			"executionQueue": []
		};
		largeDatapageRegistry[datapageName] = largeDatapageDef;

		if (sourceDatapages) {
			for (var index = 0; index < sourceDatapages.length; index++) {
				var sourceDatapageRecord = sourceDatapageRegistry[sourceDatapages[index]];
				if (sourceDatapageRecord) {
					sourceDatapageRecord.push(datapageName);
				} else {
					sourceDatapageRegistry[sourceDatapages[index]] = [datapageName];
				}
			}
		}

		_log("pega.ui.ClientCache: Registered large datapage " + datapageName + ".");
	};

	/*
	   * Invalidates large datapages on change during synchronization
	   *
	   * @param {boolean} invalidateAll Indicate if invalidate all large datapages or not
	   * @param {Array} updatedDatapageList Array of large datapages names to invalidate (if not invalidateAll)
	   */
	var _invalidateLargeDatapages = function(invalidateAll, updatedDatapageList) {
		if (invalidateAll) {
			for (var largeDatapage in largeDatapageRegistry) {
				largeDatapageRegistry[largeDatapage].lastParams = undefined;
			}
			return;
		}

		for (var i = 0; i < updatedDatapageList.length; i++) {
			var updatedDatapage = updatedDatapageList[i];
			if (largeDatapageRegistry[updatedDatapage]) {
				largeDatapageRegistry[updatedDatapage].lastParams = undefined;
			}

			if (sourceDatapageRegistry[updatedDatapage]) {
				for (var j = 0; j < sourceDatapageRegistry[updatedDatapage].length; j++) {
					var affectedDP = sourceDatapageRegistry[updatedDatapage][j];
					largeDatapageRegistry[affectedDP].lastParams = undefined;
				}
			}
		}
	};

	var _queuingFindPageAsync = function(datapageName, parametersMap, onSuccess, onError, options) {
		if (!pega.offline) {
			onError(ERROR_NOT_SUPPORTED, "findPageAsync is not supported in online");
			return;
		}

		var largeDatapageDef = largeDatapageRegistry[datapageName];

		var error = function(e) {
			onError(ERROR_DATAPAGE_NOT_FOUND, "Large data page " + datapageName + " is not registered and it doesn't contain report definition");
		};

		var callback = function(datapageDef, results, code, message) {
			datapageDef.executionQueue.shift();
			try {
				if (code) {
					onError(code, message);
				} else {
					onSuccess(results);
				}
			} catch (e) {
				console.error("FindPageAsync callback failed. The original exception follows.");
				console.error(e);
			}
			if (datapageDef.executionQueue.length > 0) {
				var execFunction = datapageDef.executionQueue[0];
				execFunction(datapageDef);
			}
		};

		var execFunc = function(datapageDef) {
			var success = function(results) {
				callback(datapageDef, results);
			};
			var failure = function(code, message) {
				callback(datapageDef, undefined, code, message);
			};
			_findPageAsync(datapageName, parametersMap, success, failure, options);
		};

		var fireFindPageAsync = function() {
			if (largeDatapageDef.executionQueue.length === 0) {
				largeDatapageDef.executionQueue.push(execFunc);
				execFunc(largeDatapageDef);
			} else {
				largeDatapageDef.executionQueue.push(execFunc);
			}
		};

		var portalWindow = pega.ui.ClientCacheHelper.getPortalWindow();

		var _buildAndRegisterLDPCustomFunction = function(reportDefinition) {
			var customFunction = portalWindow.pega.ui.ReportDefinition.Interpreter.buildCustomFunction(datapageName, reportDefinition.pyData);
			var sourceDatapages = portalWindow.pega.ui.ReportDefinition.Interpreter.getSourceDatapages(reportDefinition.pyData);
			pega.ui.ClientCache.registerLargeDatapage(datapageName, customFunction, sourceDatapages);
			largeDatapageDef = largeDatapageRegistry[datapageName];
			fireFindPageAsync();
		};

		if (!largeDatapageDef) {
			var pxRDHandler = _getLargeDataPageReportDefinitionHandler(datapageName);
			if (pxRDHandler !== undefined) {
				pega.offline.clientstorehelper.getReportDefinition(pxRDHandler, _buildAndRegisterLDPCustomFunction, error);
			} else {
				error();
			}
		} else {
			fireFindPageAsync();
		}

	};

	var _getLargeDataPageReportDefinitionHandler = function(datapageName) {
		if (datapageName) {
			var changetracker = getChangeTracker(datapageName);
			var entity = changetracker.getPropertyValue(datapageName, true);
			if (entity) {
				return entity.pxRDHandler;
			}
		}
	};

	/*
	   * Asynchronously populates given datapage with data from custom tables
	   *
	   * @param {string} datapageName The name of large datapage
	   * @param {Object} parametersMap Map of parameters to execute datapage with
	   * @param {Function} onSuccess Method called on datapage population success
	   * @param {Function} onError Method called on datapage population failure
	   */
	var _findPageAsync = function(datapageName, parametersMap, onSuccess, onError, options) {
		var finishWithError = function(errorCode, errorMessage) {
			_log("pega.ui.ClientCache: " + errorMessage);
			onError(errorCode, errorMessage);
		};

		if (parametersMap === undefined || parametersMap == null) {
			parametersMap = pega.ui.ClientCacheHelper.createEmptyObject();
		}

		var largeDatapageDef = largeDatapageRegistry[datapageName];
		if (!largeDatapageDef) {
			finishWithError(ERROR_DATAPAGE_NOT_FOUND, "Large data page " + datapageName + " is not registered.");
			return;
		}

		var cachedDatapage = _find(datapageName);
		if (!cachedDatapage) {
			finishWithError(ERROR_DATAPAGE_NOT_FOUND, "Large data page " + datapageName + " is registered, but can't be found in ClientCache.");
			return;
		}

		if (_compareParams(parametersMap, largeDatapageDef.lastParams)) {
			onSuccess(cachedDatapage);
			return;
		}

		var successCallback = function(results) {
			if (options && options.action === "append") {
				var list = cachedDatapage.get("pxResults");
				cachedDatapage.put("pxResults", list.pxResults.concat(results));
			} else {
				cachedDatapage.put("pxResults", results);
			}
			largeDatapageDef.lastParams = parametersMap;
			onSuccess(cachedDatapage);
		}
		var errorCallback = function(code, message) {
			onError(code, message);
		}

		var theWindow = pega.desktop.support.getDesktopWindow();
		try {
			largeDatapageDef.customFunction(parametersMap, theWindow.launchbox.PRPC.ClientStore, successCallback, errorCallback);
		} catch (exception) {
			finishWithError(ERROR_CUSTOM_FUNCTION_CORRUPTED, "Custom function to populate large datapage " + datapageName + " is corrupted.");
		}
	};

	var _shouldInitializeChangeTracker = function() {
		/* BUG-285722: Removing the check for isHybridClient */
		/*var bHC = pega.u.d && pega.u.d.ServerProxy && pega.u.d.ServerProxy.isHybridClient && pega.u.d.ServerProxy.isHybridClient();
		/return !changetracker || changetracker.isDummy() || bHC;*/
		return !localChangeTracker || localChangeTracker.isDummy();
	};

	/*
	   * Finds and wraps a client cache entity and wraps it in defined
	   * classes and returns it
	   *
	   * @param {string} propRefOrHandle Property reference or handle
	   * @returns {ClientCacheObject}
	   */
	var _find = function(propRefOrHandle, options) {
		if (!propRefOrHandle) {
			// Property reference is empty
			_log("pega.ui.ClientCache.find: " + ERROR_NOT_VALID_ARGUMENT);
			return null;
		} else {
			/* Initialize the client cache with the default thread */
			/* BUG-244806: Sometimes the changetracker gets initialized with a dummy tracker object, reinitialize in those cases */
			/* BUG-245578: We cannot simply depend on pega.u.d.switchThread to initialize ClientCache, sometimes pega.u.d.url is directly modified */
			if (_shouldInitializeChangeTracker()) {
				_init();
			}

			/* TASK-895034 : With thread support in offline, all the DataPages, pxThread, pxRequestor and OperatorID pages which 
      are common to all thethread will be present in STANDARD thread. 
      Change the changetracker context to STANDARD if any of these pages are accessed. */
      		var changetracker = getChangeTracker(propRefOrHandle);

			if (!options || options.doNotTrack != true) {
				_pushToChangeList(propRefOrHandle);
			}
			// Valid property
			var propRef = propRefOrHandle;
			// Check if it is prop ref
			if (propRef.indexOf("$") !== -1) {
				propRef = pega.ui.property.toReference(propRefOrHandle);
			}

			// Create DP object in change tracker list and get the property reference.
		    propRef = pega.ui.ParametrizedDPUtils.createDPInstance(propRef, changetracker);

			if (pega.ui.ClientCacheHelper.isOfflineEnabled())
				propRef = pega.ui.AutopopulateSupport.resolveReference(propRef, changetracker);
			var value = changetracker.getPropertyValue(propRef, true);

			var prop = null;

			if (value == null || (Array.isArray(value))) {
				if (changetracker.getPropertyValue(propRef + "(1)", true) || changetracker.getPropertyValue(propRef + "(0)", true)) {
					// This means we are referring to a page list
					prop = pega.ui.ClientCacheHelper.createClientCacheList(propRef, options);
				} else {
					// Well, property doesn't really exist in the ChangeTracker
					prop = null;
					//_log("pega.ui.ClientCache.find: Property - '" + propRefOrHandle + "' doesn't exist in ClientCache");
				}
			} else if (typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean') {
				// It's referring to a single valued property
				prop = pega.ui.ClientCacheHelper.createClientCacheProperty(propRef);
			} else if (typeof value == 'object') {
				// It's referring to a page
				prop = pega.ui.ClientCacheHelper.createClientCachePage(propRef);
			}

			return prop;
		}
	};

	/*
	   * Creates a top level page with the given name
	   *
	   * @param {string} pageName Name of the top level page to be created
	   * @returns {ClientCacheObject}
	   */
	var _createPage = function(pageName) {
		if (!pageName || typeof pageName !== "string") {
			_log("pega.ui.ClientCache.createPage: " + ERROR_NOT_VALID_ARGUMENT);
			return null;
		}		
		// If no / invalid object is passed, create one
		// if (!obj || typeof obj !== "object") obj = new Object();

		/* Initialize the client cache with the default thread */
		/* BUG-244806: Sometimes the changetracker gets initialized with a dummy tracker object, reinitialize in those cases */
		/* BUG-245578: We cannot simply depend on pega.u.d.switchThread to initialize ClientCache, sometimes pega.u.d.url is directly modified */
		if (_shouldInitializeChangeTracker()) {
			_init();
		}
		var changeTracker = getChangeTracker(pageName);

		/* Create new object named 'pageName' only if not parametrized DP */
		if (!pega.ui.ParametrizedDPUtils.isParametrizedDataPage(pageName, changeTracker)) {	
			changeTracker.trackedPropertiesList[pageName] = pega.ui.ClientCacheHelper.createEmptyObject();
		}

		// Return the handle
		return _find(pageName);
	};

	var bPauseChangeList = false;
	var _pushToChangeList = function(reference) {
		if (bPauseChangeList) {
			return;
		}
		var topLevelPageRef;
		if (reference.indexOf(".") !== -1) {
			topLevelPageRef = reference.substring(0, reference.indexOf("."));
		} else {
			topLevelPageRef = reference;
		}
		if (topLevelPageRef && !changedPagesList[topLevelPageRef]) {
			changedPagesList[topLevelPageRef] = true;
		}
	};
	var _getChangedPagesList = function() {
		return Object.keys(changedPagesList);
	}
	var _clearChangedPagesList = function() {
		changedPagesList = {};
	}

	var _pauseChangedPagesList = function() {
		bPauseChangeList = true;
	}

	var _resumeChangedPagesList = function() {
		bPauseChangeList = false;
	}

	return {
		/* CONSTANTS */
		OBJECT_TYPE_PROPERTY: OBJECT_TYPE_PROPERTY,
		OBJECT_TYPE_PAGE: OBJECT_TYPE_PAGE,
		OBJECT_TYPE_LIST: OBJECT_TYPE_LIST,
		isLargeDatapage: _isLargeDatapage,
		registerLargeDatapage: _registerLargeDatapage,
		invalidateLargeDatapages: _invalidateLargeDatapages,
		findPageAsync: _queuingFindPageAsync,
		find: _find,
		createPage: _createPage,
		setDebugMode: _setDebugMode,
		DEBUG_MODE_ON: DEBUG_MODE_ON,
		DEBUG_MODE_OFF: DEBUG_MODE_OFF,
		init: _init,
		reset: _reset,
		log: _log,
		isDebug: _isDebug,
		_getChangeTracker: getChangeTracker,
		getChangedPagesList: _getChangedPagesList,
		clearChangedPagesList: _clearChangedPagesList,
		pauseChangedPagesList: _pauseChangedPagesList,
		resumeChangedPagesList: _resumeChangedPagesList,
		setAutorefreshParametrizedDatapages: _setAutorefreshParametrizedDatapages,
		get autoRefreshParamDP() {
			return _autoRefreshParamDP;
		} 
	};
})();
//static-content-hash-trigger-GCC
/* ClientTools.js */
;(function() {
	var clientTools = function () {
		
		/* The ParamPage constructor */
		var _createParamPage = function() {
			return {};
		};

		/* Map of ClientParamPages per thread */
		var _ClientParamPagesMapByThread = {
		};

		var _currentParamPage;
		// var _currentStepPage = null;
		
		/* ClientTools System Error codes */
		var ERROR_INVALID_ARGUMENT_STRING = "Non String value passed";
		var ERROR_MISSING_ARGUMENTS_1_of_2 = "2 arguments required, but only 1 present";
		var ERROR_MISSING_ARGUMENTS_0_of_2 = "2 arguments required, but 0 present";
		var ERROR_MISSING_ARGUMENTS_0_of_1 = "1 argument required, but only 0 present";
		
		/* Method to switch the tab context */
		var _switchContext = function(context) {
			if(context.thread) {
				var thread =  context.thread;
				if(!_ClientParamPagesMapByThread[thread])
					_ClientParamPagesMapByThread[thread] = _createParamPage();
				// Set the marker on this thread
				_currentParamPage = _ClientParamPagesMapByThread[thread];
			}
		};
		
		// Initialize with base thread
		_switchContext({thread: "baseThread"});
		/* Pointer to the current ParamPage */
		_currentParamPage = _ClientParamPagesMapByThread["baseThread"];
		
		
		// Public APIs
		/* 
			API: putParamValue(sKeyName, aKeyValue)
			Description: Adds the key to the Parameter page on the current thread or updates the key's value if it already exists
			Arguments: 
			sKeyName -> A String containing the name of the key you want to create/update.
			sKeyValue -> A String containing the value of the key you want to create/update.
			Return value: None
		*/
		var putParamValue = function(key, value) {
			if(arguments.length == 0) {
				pega.ui.ClientCache.log(ERROR_MISSING_ARGUMENTS_0_of_2);
				return -1;
			}
          	if(arguments.length == 1) {
				pega.ui.ClientCache.log(ERROR_MISSING_ARGUMENTS_1_of_2);
				return -1;
			}
			if(typeof key != "string")	{
				pega.ui.ClientCache.log(ERROR_INVALID_ARGUMENT_STRING + " for key");
				return -1;
			}
			
			_currentParamPage[key] = value;
		};

		/* 
			API: getParamValue()
			Description: Retrieves the value of the specified key from the Parameter page
			Arguments: sKeyName -> A String containing the name of the key to be retrieved
			Return value: Value of the key specified
		*/
		var getParamValue = function(key) {
			if(arguments.length == 0) {
				pega.ui.ClientCache.log(ERROR_MISSING_ARGUMENTS_0_of_1);
			}
			if(typeof key != "string")	{
				pega.ui.ClientCache.log(ERROR_INVALID_ARGUMENT_STRING + " for key");
			}
			
			return _currentParamPage[key];
		};
		
		/* 
			API: getParamPage()
			Description: Returns the Parameter page on the current Thread; Use get / put / clear methods on it
			Arguments: None
			Return value: Returns the current Parameter page object
		*/
		var getParamPage = function() {
			return {
				clear: _clear,
				get: getParamValue,
				put: putParamValue
			};
		};
      
        /* 
			API: objOpenByHandle(handle, pagename, onSuccess, onFailure, options)
			Description: 
			Arguments: handle -> work item insKey, pagename -> page to put object's output on, priority -> server (default) | client 
			Return value: 
		*/
        var objOpenByHandle = function(handle, pageName, onSuccess, onFailure, options) {
            
            var priority = (options && options.priority) ? options.priority : "server";
            var dataOnly = true; //always true for this method!!

            var helperOptions = {
                 "priority" : priority,
                 "dataOnly" : dataOnly
            };

            var onHaveObject = function(result){
                //Data object successfully found and returned...
              	//save to Client Cache using given page name
              
                var tempPage = pega.ui.ClientCache.createPage(pageName);
                tempPage.adoptJSON(result.content);
                onSuccess(tempPage);
            }
            
            //calls clientstorehelper with dataOnly as true always
            pega.offline.clientstorehelper.getWorkItem(
                handle, 
                onHaveObject, 
                onFailure, 
                helperOptions
            );
        };
		
        /* Get the localized value of the string.
         * @param $String fieldName (example:pyCaption)
         * @param $String fieldValue (String to be localized)
         * @return $String localizedValue
         */
        var _getLocalizedTextForString = function(fieldName, fieldValue) {
          var activeContext = _getPrimaryPage();
          if(fieldName.indexOf(".")==0){
            fieldName = fieldName.substr(1);
          }
          /* BUG-328823: HFix-37621 - Trim the spaces */
          var lookupfieldValue = fieldValue;
          if(typeof lookupfieldValue == "string"){
            lookupfieldValue = lookupfieldValue.trim();
          }           
          /* BUG-287949: Do not use toUpperCase while sending the fieldValue to getText */
          return (pega.offline && pega.offline.localization.getText(fieldName, lookupfieldValue, activeContext)) || fieldValue;
        };
      
		/* Get the localized value of the message.
		 * @param $String messageName (pyMessageName of the message rule)
         * @param $String messageClassName (pyClassName  of the message rule)
		 * @return $String localizedMessage
		 */
        var _getLocalizedMessage = function(messageName, messageClassName) {
          //fieldValue is in the format :"\t[@Data-Admin-Operator-Mesh.PYMESSAGELABEL]MeshCredentialsNotValid\tPaul\tparam2\tparam3"
          var fieldValue = "\\t[" + messageClassName + ".PYMESSAGELABEL]" + messageName;          
          var localizedMessage = pega.clientTools.getLocalizedTextForString("PYMESSAGELABEL", fieldValue);  
          if (localizedMessage === fieldValue) {
            localizedMessage = messageName;
          }
          return localizedMessage;
        };
      
		/* Get the localized value of the paragraph.
		 * @param $String ruleKey (pxInsName of the paragraph)
         * @param $Function callback
		 * @return $String localizedParagraphText
		 */
        var _getLocalizedParagraph = function(ruleKey, callback) {
          var activeContext = _getPrimaryPage();
          pega.offline.localization.getLocalizedParagraph(ruleKey, activeContext, callback);
        };     

		/* Switch the locale of the user.
         * @param $String locale (example: EN_US)
         */
        var _switchLocale = function(locale, onSuccess, onFailure){
          pega.offline.localizationUtils.setLocale(locale, onSuccess, onFailure);
        };
      
		/* Internal methods */
		/*
			API: clear()
			Description: Helper method to clear the parameter page. Clears the Parameter page on the current thread (Empties all the parameters)
			Arguments: None
			Return value: None
		*/
		var _clear = function() {
			for(var key in _currentParamPage) {
				if(_currentParamPage.hasOwnProperty(key))
					delete _currentParamPage[key];
			}
		};
        
        var _getPrimaryPage = function() {
			return pega.getPrimaryPage();
		};
		
		/* Expose public APIs */	
		var returnObject = {
			getPrimaryPage: _getPrimaryPage,
			getParamValue: getParamValue,
			putParamValue: putParamValue,
			getParamPage: getParamPage,
            objOpenByHandle: objOpenByHandle,
            getLocalizedTextForString: _getLocalizedTextForString,
            getLocalizedMessage: _getLocalizedMessage,
            switchLocale: _switchLocale,
			getLocalizedParagraph: _getLocalizedParagraph
		};
		
		// Extend from ClientCache
		jQuery.extend(returnObject, pega.ui.ClientCache);	
		return returnObject;
	};
	
	// The public interface
	pega.clientTools =  new clientTools();
})();

(function() {
	var stackFrame = {};
	
	var _pushStackFrame = function(type, clientCachePage) {
		if(!stackFrame[type])
            stackFrame[type] = [];
     	stackFrame[type].push(clientCachePage);
	};
	
	var _popStackFrame = function(type) {
		if(stackFrame[type])
          return stackFrame[type].pop();
	};	
  	var _peekStackFrame = function(type) {
		var stack = stackFrame[type];
      	if(!stack)
          return;
		return stack[stack.length - 1];
	};
	
	var _getPrimaryPage = function() {
        var ppStack = stackFrame["PrimaryPage"];
		if(ppStack)
      		return ppStack[ppStack.length - 1];
	};
	
	pega.pushStackFrame = _pushStackFrame;
	pega.popStackFrame = _popStackFrame;
    pega.peekStackFrame = _peekStackFrame;
	pega.getPrimaryPage = _getPrimaryPage;
   
})();
//static-content-hash-trigger-GCC
var pega = pega || {};
pega.ui = pega.ui || {};

/* Param DP utils contains the uitility methods mainly used by client cache */
pega.ui.ParametrizedDPUtils = (function() {

	function _createDPInstance(reference, changetracker) {
		if(_isParametrizedDataPage(reference, changetracker)) {
			return new this.ParametrizedDPProxy(reference, changetracker).getPropRef();
		}
		return reference;
	}

	function _isDataPage(reference) {
		return reference.indexOf("D_") == 0 || reference.indexOf("Declare_") == 0;
	}

  function _isParametrizedDataPage(reference, changetracker) {
		if(!changetracker)
			changetracker = pega.ui.ClientCache._getChangeTracker(reference);

		if(_isDataPage(reference)) {
			var metadata = changetracker.getPropertyValue(_getDPNameFromRef(reference));
			return (metadata && metadata["pyParameters"] && metadata["pyParameters"].length > 0) ? true : false;
		}
		return false;
	}

  function _isParametrizedDataPageInstance(reference, changetracker) {
		if(!changetracker)
			changetracker = pega.ui.ClientCache._getChangeTracker(reference);

		if(_isDataPage(reference)) {
			var metadata = changetracker.getPropertyValue(_getDPNameFromRef(reference));
			return (metadata && metadata["pxDPParameters"]) ? true : false;
		}
		return false;
	}

	function _getDPNameFromRef(reference) {
		var dpName = reference;
		if (reference.indexOf(".") > 0) {
			dpName = reference.substring(0, reference.indexOf("."));
		}
		return dpName;
	}

	return {
		createDPInstance: _createDPInstance,
		isParametrizedDataPage: _isParametrizedDataPage,
        isParametrizedDataPageInstance: _isParametrizedDataPageInstance,
        getDPNameFromRef: _getDPNameFromRef
	}
})();
//static-content-hash-trigger-GCC
/* Param DP utils contains the uitility methods mainly used by client cache */
var ParametrizedDPUtilsOffline = (function(){

	function _getParamsFromMetadata(metadata) {
		var paramCount = -1,
			params = {}; // store param name along with default values if any

		while (metadata["pyParameters"][++paramCount]) {
			var param = metadata["pyParameters"][paramCount];
			params[param.pyParametersParamName] = param.pyParametersParamDefaultValue;
		}

		return params;
	}
	var _ParametrizedDPProxy = function(reference, changetracker) {
		this.reference = reference;
		this.dpName = pega.ui.ParametrizedDPUtils.getDPNameFromRef(reference);
		this.metadata = changetracker.getPropertyValue(this.dpName);
		this.createIfRequired();
	};

	_ParametrizedDPProxy.prototype = {
		DP_HASH_PREFIX : "_pa",/* Prefix for generated hash. It is inline with server naming conversion */
		DP_HASH_SUFFIX : "pz", /* Suffix for generated hash. It is inline with server naming conversion */
		DP_CLASS_NAME : "",
		getPropRef : function() {
			return this.reference;
		},
		/**
		*	Based on the type(parametrized or non parametrized) of the DP decision is taken to invoke custom populater function.
		*	And reference is updated with appropriate value. 
		*	 Ex: If "D_ABC.pyName" is passed then in case of parametrized DP reference is modified to "D_ABC_hash.pyName".
		*		 For non parametrized DP no change is made to reference
		*/
		createIfRequired : function() {
			var newRef = this.metadata.pxHashedDPRef;
			var hashedPage;
			if(this.isInitializeRequired()){
				this.deleteHashedPage();
				hashedPage = this.createHashInstance();
				this.metadata.pxHashedDPRef = hashedPage.getReference();
				this.invokeCustomDataPopulator(hashedPage);
				newRef = hashedPage.getReference();
			} else if (pega.ui.ClientCache.autoRefreshParamDP) {
				hashedPage = this.getHashedPage();
				newRef = hashedPage.getReference();
				this.invokeCustomDataPopulator(hashedPage);
			}
			this.reference = this.reference.replace(this.dpName, newRef);
		},
		invokeCustomDataPopulator: function(hashedPage) {
			var paramsMap = _getParamsFromMetadata(this.metadata),
				paramsNames = pega.u.d.getObjectKeys(paramsMap),
				populatorFunction = window[this.dpName];

			/* Populating data page parameters with current values*/
			for (var paramName in paramsNames) {
				if (paramsNames.hasOwnProperty(paramName)) {
					var paramValue = pega.clientTools.getParamValue(paramsNames[paramName]);
					paramsMap[paramsNames[paramName]] = typeof paramValue != "undefined" ? paramValue : null;
				}
			}
			hashedPage.put("pxDPParameters", paramsMap);
            hashedPage.put("pzPageNameBase", this.dpName);
			if (populatorFunction && typeof populatorFunction == 'function') {
				try {
					/* Populate the page by calling user provided method along with page ref and map of all params */
					populatorFunction(hashedPage, paramsMap);
					/* Override pxObjClass with DP class */
					hashedPage.put("pxObjClass", this.metadata.pyClassName); 
				} catch(e) {
					pega.ui.logger.LogHelper.error("Error encountered while invoking populator function: " + this.dpName + "(). " + "Error: " + e.message);
					hashedPage.put("pxObjClass", this.DP_CLASS_NAME); // Setting the default class
				}
			} else {
				pega.clientTools.log("Populator function '" + this.dpName + "()' is not found.");
				hashedPage.put("pxObjClass", this.DP_CLASS_NAME); // Setting the default class
			}
		},
		/**
		*	Deletes the existing hashed DP from memory.
		*/
		deleteHashedPage : function() {
			var dp = this.getHashedPage();
			if (dp) {
				dp.remove();
			}
		},
		/**
		*	Creates a new hashed DP. EX: D_ABC_pa12345768pz
		*/
		createHashInstance : function() {
			return pega.clientTools.createPage(this.dpName + this.DP_HASH_PREFIX + this.generateDataPageHash() + this.DP_HASH_SUFFIX);
		},
		/**
		*	Checks whether params have changed in param page and returns boolean value.
		*/
		isInitializeRequired : function() {
			var toBeCreated = false;
			var hashedPage = this.getHashedPage();

			if (hashedPage) {
				toBeCreated = this.areParametersModified(hashedPage);
			} else {
				toBeCreated = true;
			}

			return toBeCreated;
		},
		
		areParametersModified: function(hashedPage) {
			var pxDPParamsPage = hashedPage.get("pxDPParameters");
			if(!pxDPParamsPage){
				return true;
			}
			var pxDPParameters = JSON.parse(pxDPParamsPage.getJSON());
          	var paramsNames = pega.u.d.getObjectKeys(pxDPParameters);
			for (var paramName in paramsNames) {
				if (paramsNames.hasOwnProperty(paramName)) {
					/* Check for parameter value changes */
					var globalParam = pega.clientTools.getParamValue(paramsNames[paramName]);
					var localParam = pxDPParameters[paramsNames[paramName]];
					var cond;
					if(!globalParam)
						cond = (!!globalParam !== !!localParam);	// bool check
					else
						cond = (globalParam !== localParam);
				
					if(cond)
						return true;
				}
			}
		},
		
		/**
		*	Returns the hashed data page based on the "pxHashedDPRef" value in metadata.
		*/
		getHashedPage : function() {
			if (this.metadata.pxHashedDPRef) {
				return pega.clientTools.find(this.metadata.pxHashedDPRef);
			}
			return null;
		},
		/**
		 *  Generates hash based on time. This is same as server side implementation.
		 *  At server only Node scoped Data pages has MD5 hash based on name-value pair of params.
		 *  Example of server side MD5 hash :
		 *  		new MD5("DP_pzinsKey_param1=param1value,param2=param2value,")
		 *  Hash for Data page scoped as Thread or Requester is system time (System.nanoTime())
		 *
		 *  At server com.pega.pegarules.exec.internal.declare.infengine.pages.DeclarativePageUtilsImpl.buildDPIName() method has the logic for hash generation.
		 */
		generateDataPageHash : function() {
			return new Date().getTime(); /* TASK-304696: Generate hash for DP based on time stamp */
		}
	};
	_ParametrizedDPProxy.prototype.constructor = _ParametrizedDPProxy;

	return {
		ParametrizedDPProxy : _ParametrizedDPProxy
	}
})();


pega.lang.augmentObject(pega.ui.ParametrizedDPUtils, ParametrizedDPUtilsOffline);
ParametrizedDPUtilsOffline = null;
//static-content-hash-trigger-NON
pega.ui.DataRepeaterUtils = {
	 
	TEMPLATE_GRID: "template-root-marker",
  TEMPLATE_GRID_ROW: "cellCont",
	SIMPLE_LAYOUT: "bsimplelayout",
	NONTEMPLATE_GRID: "bGrid",
	SECTION_INCLUDE: "section",		
	SECTION_DIV_CLASS: "sectionDivStyle",
	/* 
	This method is used to execute the pre and post list action Javascript hooks
	@param $String type - PRE/POST
	@param $Object pageListSource - ClientCache page
	@param $String action - Add/Delete/Paginate
	@param $Object context - context
	 */
  	executeListActionHook : function(type, pageListSource, action, context){
      var fname;
      var listname = pageListSource._ref.replace(".","$");
      switch(type){
      	case "PRE":
            fname =  listname + "_" + "preListAction";
          	break;
        case "POST":
            fname =  listname + "_" + "postListAction";
          	break;
      }
      
      if(typeof window[fname] == "function"){
        window[fname](action,context);
      }
    },
  
    /* 
	This method is used to extract the absolute data source from the event object
	@param $Object event
	@return $Object - contains the datasource path, rowIndex and domIndex
	 */
	getAbsoluteDataSourceFromEvent: function(event,isDLG) {
		// Get PL and index from baseref
		var srcElement = pega.util.Event.getTarget(event);
      	if(isDLG){
          	var RLNode = pega.ctx.dom.$(srcElement).closest("[data-lg-child-id]");
        }else{
          	var RLNode = pega.ui.rdlMasterDetails.getEnclosingRL(srcElement);
		
        }
		var rowBaseRef = pega.u.d.getBaseRef(srcElement);

		// No RL || baseref found, quit
		if (!RLNode || !rowBaseRef)
			return;
		var childNodes = pega.ctx.dom.$(RLNode).children();
		var domIndex;
      	for(var i=0;i<childNodes.length;i++){
			if(pega.util.Dom.isAncestor(childNodes[i],srcElement)){
				domIndex = i;
              	break;
			}
		}
      	if(isDLG){
          	var dataSource = RLNode.attr("data-lg-repeatsource");		
        }else {
          	var dataSource = RLNode.getAttribute("data-repeat-source");		
        }
		var lastLeftParentheses = rowBaseRef.lastIndexOf("(");
		var lastRightParentheses = rowBaseRef.lastIndexOf(")");

		var rowIndex = parseInt(rowBaseRef.substring(lastLeftParentheses + 1, lastRightParentheses), 10);
		var pageListPath = rowBaseRef.substring(0, lastLeftParentheses);
      	
        /* startIndex, endIndex
		var startIndex, endIndex;
		var paginationConfig = RLNode.getAttribute("data-pagination-config");
		if(paginationConfig) {
			paginationConfig = JSON.parse(paginationConfig);
			if(paginationConfig.pagingMode == "Progressive") {
				startIndex = paginationConfig.listStartIndex;
				endIndex = paginationConfig.listEndIndex;
			}
		}*/
      
		return {
			dataSource : pageListPath,
			rowIndex : rowIndex,
          	domIndex : domIndex
			/*startIndex: startIndex,
			endIndex: endIndex*/
		};
	},

    /* 
	This method is used to calculate the absolute data source 
	@param $String datasource
	@return $Object - contains the datasource path
	 */
	getAbsoluteDataSourceFromDataSource: function(dataSource) {
		//If the configured dataSource is a property, find the full path
		if (dataSource.indexOf(".") == 0) {
			//look for the first layout that is configured with the passed dataSource
			var layoutNode = pega.ctx.dom.querySelector('[data-repeat-source$="' + dataSource + '"]');
			var dataRepeatSource = layoutNode.getAttribute("data-repeat-source");
			var pgList = dataRepeatSource.substring(dataRepeatSource.lastIndexOf("."), dataRepeatSource.length);
			if (pgList == dataSource) {
				dataSource = dataRepeatSource;
			}
		}
		return {
			dataSource : dataSource
		};
	},	

	/*
	This function is used to get the source pageList
	@param $String $sourcePath
	@param $Object $event
	@return $Object$
	 */
	getSourcePageList : function() {
		if(arguments.length == 0){
			return null;
		}
		var propRef = arguments[0],
		    event = null,
			baseRef = "",
			sourceList = null,
			sourceListParent = "",
			listName = "";
		if(arguments.length > 1) {
			event = arguments[1];
            if(event){
				baseRef = pega.u.d.getBaseRef(null, event);  
            }
		}
		if (propRef.indexOf("D_", 0) === 0 || propRef.indexOf("Declare_", 0) === 0) {
			listName = "pxResults";
			sourceListParent = propRef;/* In case of DP, DP itself is a top level page so assign DP name to sourceListParent */
            propRef = propRef + "." + listName;
		} else if(propRef.indexOf(".") == 0){ /* In case of embedded page list */
			listName = propRef.substring(1);
			if(baseRef === "") {
				baseRef = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName');
			}
			if(baseRef && baseRef != "") {
				propRef = baseRef + propRef;
			}
			sourceListParent = baseRef;
		} else { /* In case of user defined absolute pagelist path */
			sourceListParent = propRef.substring(0, propRef.lastIndexOf("."));
			listName = propRef.substring(propRef.lastIndexOf(".") + 1);
		}
      
		if(pega.u.d.ServerProxy.isDestinationLocal()){ /* Do ClientCache related stuff only for offline */
          sourceList = pega.ui.ClientCache.find(propRef);
          if (!sourceList) {
              var page = pega.ui.ClientCache.find(sourceListParent);
              if(!page) {
                  return;
              }
              /* Incase of empty source, create first record */
              page.put(listName, []);
              //sourceList = pega.ui.DataRepeaterUtils.getSourcePageList(propRef);
              sourceList = pega.ui.ClientCache.find(propRef);
          }
        }
      	else{ /* For desktop, set propRef to sourceList */
          	sourceList = propRef;
      	}
		return sourceList;
	},

	/*
	This method is used to update the entry handles ('name' property) of the controls in the RDL rows
	@param $String datasourceReference
	@param $String operation
	@param $Integer DOM_Row_index - For delete
	*/
	/*Ignoring the following method as it requires DOM manipulation ans uses defined APIs*/
	updateEntryHandles : /*istanbul ignore next*/ function(datasourceReference, operation, DOM_Row_index) {
		var repeats = pega.ctx.dom.$("div[data-repeat-source='" + datasourceReference + "']"), 
			currentRowPropHandle;
		repeats.each(function(layoutIndex, repeat) {
          /* BUG-373773: Do not bother with updateEntryHandles if the rdl has no exisiting rows */
          if(repeat && repeat.classList.contains("rdlHasNoRows")){
            return;
          }
          var repeatChildren = pega.ctx.dom.$(repeat).children();
          if (operation == "DELETE") { /* Remove entry handles for current row */
            var rowToDelete = pega.ctx.dom.$(repeatChildren[DOM_Row_index]);
            pega.ctx.dom.$(rowToDelete).find("[name]").each(function(eleIndex, element) {
              element.removeAttribute("name");
			  element.removeAttribute("value");
			  delete element.value;
            });
            DOM_Row_index++;
          }
          repeatChildren.each(function(childIndex, currentRow) { /* Fixing entry handles for existing rows */
            currentRow = pega.ctx.dom.$(currentRow);
            if(!currentRow.hasClass("rdl-nomoredatasection")){
              var variableIndex=0;
              var currentRowBaseRef = currentRow.attr('base_ref');
              var resArr = currentRowBaseRef.match(/\(\d+\)/g);
              var pageIndex = parseInt(resArr[resArr.length - 1].replace("(", "").replace(")", ""));
              var currentRowIndex=pageIndex;
              if(childIndex >= DOM_Row_index) {
                currentRowPropHandle = pega.ui.property.toHandle(datasourceReference + "(" + (pageIndex) + ")");
                if (operation == "DELETE") {
                  pageIndex--;
                  variableIndex=-1;
                } else if(operation == "INSERT") {
                  pageIndex++;
                  variableIndex=1;
                }
                var newBaseRef = datasourceReference + "(" + (pageIndex) + ")";
                var newPropHandle = pega.ui.property.toHandle(newBaseRef);

                pega.ctx.dom.$(currentRow).find("[name^='" + currentRowPropHandle + "']").each(function(eleIndex, element) {
                  var oldName = element.getAttribute("name");
                  var newName = oldName.replace(currentRowPropHandle, newPropHandle);
                  element.setAttribute("name", newName);
                });
                
                /*Bug -277150 fix for arrangement of rows in case of expand when */
                var expandWhenStateNodes=pega.ctx.dom.$(currentRow).find("#EXPAND-INDICATOR");
                var expandWhenStateNodesSize=expandWhenStateNodes.length;
                for(var i=0;i<expandWhenStateNodesSize;i++){
              	  var elementName=expandWhenStateNodes[i];
                  var oldName=elementName.getAttribute("name");
                  var  newName = oldName.substring(0,oldName.indexOf(currentRowIndex.toString()));
                  newName=newName+(currentRowIndex+variableIndex);
                  elementName.setAttribute("name", newName);                                                       
                }

              }
            }
          });
        });
	},
  	
  	/*
	This function is used to get the layout type (template-grid/grid/tree/treegrid/rdl) from the target element
	@param $Object $event
	@return $String value is either "grid" (or) "repeat-layout"
	*/
    getLayoutType: function(event){
      var target = pega.util.Event.getTarget(event);
      var parent = target && target.parentNode;
      var harnessDiv = pega.ctx.dom.getContextRoot(target);

      while(parent && parent != harnessDiv){
        if(parent.tagName === "TABLE" && parent.hasAttribute("uniqueid")){
          return "template-grid";
        }
        else if(parent.hasAttribute("datasource") || (parent.getAttribute("bgrid") || parent.getAttribute("btree") || parent.getAttribute("btreegrid"))){
          return "grid";
        } else if(parent.hasAttribute("data-repeat-source")){
          return "repeat-layout";
        }else if(parent.hasAttribute("data-lg-repeatsource")){
          return "dlgrepeat-layout";
        }
        parent = parent.parentNode;
      }
    },
  	
  	/*
    This API returns the section context in which event.target is present.
	@param $Object event
	@return $String primaryPage context of the section
    */
  	getRepeatLayoutSectionContext: function(event) {
      var repeatLayoutParentNode = pega.ui.rdlMasterDetails.getEnclosingRL(pega.util.Event.getTarget(event)).parentNode;
      var sectionContext = pega.u.d.getBaseRef(repeatLayoutParentNode);
      if(!sectionContext) {
        sectionContext = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName');
      }
      return sectionContext;
    },
    
	/*
	This method is used to merge property values from the "sourcePage" to the "targetPage".
	@param $String targetPageRef - ClientCache reference
	@param $String sourcePageRef - ClientCache reference
	*/
	mergePage: function(targetPageRef, sourcePageRef){
		var targetPage = pega.ui.ClientCache.find(targetPageRef);
		var sourcePage = pega.ui.ClientCache.find(sourcePageRef);
		if(targetPage && sourcePage){
			var propNames = targetPage.getPropertyNames();
			for(var i=0; i< propNames.length; i++){
				var prop = sourcePage.get(propNames[i]);
				if(prop && !this.isStandardProperty(propNames[i])){
                  	if(prop.type == "page") {
                      this.mergePage(targetPageRef + "." + propNames[i], sourcePageRef + "." + propNames[i]);
                    } else {
                      targetPage.put(propNames[i], prop.getValue());
                    }
				}
			}
		}
	},
	
	/*
	This method is used by mergePage to detemine if the properties are "Standard" properties which should not be overwritten.
	@param $String propName
    */	
	isStandardProperty: function(propName){
		var standardProperties = ["pxCreateDateTime", "pxObjClass", "pxRefObjectClass", "pxRefObjectInsName", "pxRefObjectKey", "pzInsKey"];
        return standardProperties.indexOf(propName) > -1;
	},
	
	getPackagedPageName: function(){
    return "PackagedPage1709121363";
    //HFIX-42554 commented below code and returning the string
		// Packaged page name = "PackagedPage" + JAVA hashCode of "PackagedPage"
		/*var packagedPageName = "PackagedPage";
		packagedPageName += this.hashCode(packagedPageName);
		packagedPageName = packagedPageName.replace("-","");
		return packagedPageName;*/
	},
	

	 
	hashCode: function(str) {
	  var hash = 0, i, chr, len;
	  if (str.length == 0) return hash;
	  for (i = 0, len = str.length; i < len; i++) {
		chr   = str.charCodeAt(i);
		hash  = ((hash << 5) - hash) + chr;
		hash |= 0; // Convert to 32bit integer
	  }
	  return hash;
	},
	
	
	updateDataPageRecordByInsKey: function(dataPageName, insKey, rowPage) {
		var cc = pega.ui.ClientCache;
		if(dataPageName && insKey && rowPage && (dataPageName.indexOf("D_") == 0 || dataPageName.indexOf("Declare_") == 0)) {
			var dp_list = cc.find(dataPageName);
			var dp_iter = dp_list && dp_list.iterator();
			if(dp_iter) {
				while(dp_iter.hasNext()) {
					var dp_page = dp_iter.next();
					if(dp_page.get("pzInsKey").getValue() === insKey) {
						dp_page.adoptJSON(rowPage.getJSON());
					}
				}
			}
		}
	},
  
  	saveDataPage: function(dataPageName, callbackObj) {
		var cc = pega.ui.ClientCache;
		var dp_list = cc.find(dataPageName);
		if(dp_list && (dataPageName.indexOf("D_") == 0 || dataPageName.indexOf("Declare_") == 0) && !pega.ui.ParametrizedDPUtils.isParametrizedDataPageInstance(dp_list.getReference())) {
			pega.offline.clientstorehelper.saveDataPage(dataPageName, dp_list.getJSON(), callbackObj.success, callbackObj.failure);
		}
    },
  	/**
		Returns an object {type, domNode(ele with eventDescriptor), rowNode(in case of repeat layout)}
		Currently this method identifies SIMPLE_LAYOUT, TEMPLATE_GRID, NONTEMPLATE_GRID
	*/
  	getLayoutInfo: function(e, eventDescriptor) {
		var tempLayoutDiv = pega.util.Event.getTarget(e);
      	var rowNode = null;
		
		while(true){
			/* BUG-245084: document doesn't have getAttribute, hence the null check */
			if(tempLayoutDiv && tempLayoutDiv.getAttribute && tempLayoutDiv.getAttribute(eventDescriptor) != null && tempLayoutDiv.getAttribute(eventDescriptor).indexOf(".") != 0) {/* Third check: Check if data-click='.', if yes skip the block and continue climbing DOM. */
				if(tempLayoutDiv.getAttribute("bsimplelayout")!=null) {
					return {type: this.SIMPLE_LAYOUT, domNode: tempLayoutDiv};
				} else if(pega.ctx.dom.$(tempLayoutDiv).hasClass(this.TEMPLATE_GRID)) {
					var rowRef = null;
					if(rowNode) {
					  rowRef = pega.u.d.getBaseRef(pega.ctx.dom.$(rowNode).children().get(0));
					}
					return {type: this.TEMPLATE_GRID, domNode: tempLayoutDiv, rowNode: rowNode, rowRef: rowRef, nodeType: "repeatObject"};/* If nodeType is not present then object is stringified in correctActionArgs() method */
				} else if(tempLayoutDiv.getAttribute("bGrid") != null){
					return {type: this.NONTEMPLATE_GRID, domNode: tempLayoutDiv};
				} else if(pega.ctx.dom.$(tempLayoutDiv).hasClass(this.SECTION_DIV_CLASS)){
                  /*US-184868 Action support for section include*/
                  return {type: this.SECTION_INCLUDE, domNode: tempLayoutDiv};
                } else {
                  return;
                }
			}
          	
          	tempLayoutDiv = tempLayoutDiv.parentNode;
          
          	if(tempLayoutDiv == null || (tempLayoutDiv.tagName && tempLayoutDiv.tagName.toUpperCase()=="HTML")) {
				break;
			}
      if(tempLayoutDiv != null && tempLayoutDiv.tagName && tempLayoutDiv.tagName.toUpperCase()=="A" && tempLayoutDiv.getAttribute("href")!=null && (/^mailto:/i.test(tempLayoutDiv.getAttribute("href")) || /^tel:/i.test(tempLayoutDiv.getAttribute("href")))) {
				break;
			}
			
			/* BUG-245084: document doesn't have a tagName, hence the null check */
			if(tempLayoutDiv.tagName && tempLayoutDiv.tagName.toUpperCase() == "TR" && pega.ctx.dom.$(tempLayoutDiv).hasClass(this.TEMPLATE_GRID_ROW) && pega.ctx.dom.$(tempLayoutDiv).children("th").length == 0) {
			  rowNode = tempLayoutDiv;
			}
		}
		
    },
	
	getClosestRepeatLayoutInfo: function(e, bMoreInfoRequired) {
		var tempLayoutDiv = pega.util.Event.getTarget(e);
		var rowNode = null, layoutInfo = null;
		//if(pega.control.isActionableElement(tempLayoutDiv))/* If event target is actionable element then return  */
		while(true) {
			if(pega.ctx.dom.$(tempLayoutDiv).hasClass(this.TEMPLATE_GRID)) {
				layoutInfo = {type: this.TEMPLATE_GRID};
				if(bMoreInfoRequired) {
					layoutInfo.domNode = tempLayoutDiv;
					layoutInfo.rowNode = rowNode;
				}
              	if(rowNode) {
                  layoutInfo.rowRef = pega.u.d.getBaseRef(pega.ctx.dom.$(rowNode).children().get(0));
                }
				return layoutInfo;
			}
			if(bMoreInfoRequired && tempLayoutDiv.tagName.toUpperCase() == "TR" && pega.ctx.dom.$(tempLayoutDiv).hasClass(this.TEMPLATE_GRID_ROW) && pega.ctx.dom.$(tempLayoutDiv).children("th").length == 0) {
			  rowNode = tempLayoutDiv;
			}
          	tempLayoutDiv = tempLayoutDiv.parentNode;
			if(tempLayoutDiv == null || (tempLayoutDiv.tagName && tempLayoutDiv.tagName.toUpperCase()=="HTML")) {
				break;
			}
		}
	}
};
//static-content-hash-trigger-GCC
pega.ui.template.DataRepeater = {

	/* Public APIs*/
	/*
  Algorithm:
  Arguments: data-source, row context page JSON
  1. Get PL from DS using CC APIs
  2. Invoke PL.add().adoptJSON(pageJSON)
  3. Refresh the layout (DC) using pega.ui.DCUtil.refresh()
  */
	add: /* istanbul ignore next */function (dataSource, pageJSON) {
		// If No dataSource or pageJSON, return
		if (!dataSource || !pageJSON) return;
		var dsObject = pega.ui.DataRepeaterUtils.getAbsoluteDataSourceFromDataSource(dataSource);
		dataSource = dsObject.dataSource;
		// No valid datasource found, quit
		if (!dataSource) return;

		// Step1: Get PL from DS
		var PL = pega.ui.ClientCache.find(dataSource);
		// Corresponding PL could not be found
		if (!PL) {
			var parentPage = pega.ui.ClientCache.find(dataSource.substring(0, dataSource.lastIndexOf(".")));
			var pageListProp = dataSource.substring(dataSource.lastIndexOf(".") + 1, dataSource.length);
			PL = parentPage.put(pageListProp, []);
		}
		// PL still couldn't be found, quit
		if (!PL) {
			return;
		}

		// Step2: Add page to PL
		PL.add().adoptJSON(pageJSON);

		// Step3: Refresh RL
		if (pega.u.d.ServerProxy.isDestinationLocal()) {
			pega.ui.DCUtil && pega.ui.DCUtil.refresh();
			if (pega.u.d && typeof pega.u.d.evaluateRefreshWhensOSCO == "function") {
				pega.u.d.evaluateRefreshWhensOSCO(false, true);
			}
		} else {
			var RLNode = pega.ctx.dom.querySelector("[data-repeat-source='" + dataSource + "']");
			pega.u.d.reloadSection && pega.u.d.reloadSection(RLNode, '', '', false, false, '', false);
		}
	},

	/* API to add a page to a valid pageList or datapage
  * event: event object
  * datasource: String representation of the datasource
  * position: INSERTFIRST/INSERTLAST
  * lacalAction: The localAction to be displayed in the modal dialog
  * templateName: The name of the template section for the modal dialog
  * rowClass: The class of the row page
  * packagedPageName: The page on which the localaction section has been packaged
  */
	addToRepeatSourceUsingLA: function (event, datasource, position, localAction, templateName, rowClass, packagedPageName) {
		// Step 1: Find the datasource
		var sourceList = pega.ui.DataRepeaterUtils.getSourcePageList(datasource, event),
		    newlyAddedPage,
		    index,
		    entryHandleFirstRow;
		/*
  var sectionParentFromEventTarget;
  if (pega.u.d.ServerProxy.isDestinationLocal()) {
  var targetEleSection = pega.u.d.getSectionDiv(pega.util.Event.getTarget(event));
  if(targetEleSection) {
  sectionParentFromEventTarget = targetEleSection.parentNode;
  }
  }
  */
		//Step 2: If the source exists, add a new page to the source depending on the position 	
		if (sourceList) {
			/* Invoke JS Pre hook with the page list's container page */
			pega.ui.DataRepeaterUtils.executeListActionHook("PRE", sourceList, position, sourceList.getParent());

			switch (position) {
				case "INSERTLAST":
					// Create a new page in the source list
					newlyAddedPage = sourceList.add();
					index = sourceList.size();
					break;
				case "INSERTFIRST":
					// Insert the page at the first position in the page list
					newlyAddedPage = sourceList.add(1);
					index = 1;
					break;
			}
		} else {
			return;
		}

		// Step 3: Set its class
		newlyAddedPage.put("pxObjClass", rowClass);

		/* Invoke JS post hook with the new added page context */
		pega.ui.DataRepeaterUtils.executeListActionHook("POST", sourceList, position, newlyAddedPage);
		var dlgDiv = pega.ctx.dom.$("[data-lg-repeatsource='" + datasource + ".pxResults']");
		if (dlgDiv.length > 0) {
			LayoutGroupModule.setLayoutActiveIndex(dlgDiv, "ADD" + position);
		}
		/* Defining the callback object with the submit and cancel callbacks */
		var callbackObj = {
			submit: function () {
				var dataSource = sourceList.getReference();
				if (position === "INSERTFIRST") {
					pega.ui.DataRepeaterUtils.updateEntryHandles(sourceList.getReference(), "INSERT", 1);
				}
				var dlgDiv = pega.ctx.dom.$("[data-lg-repeatsource='" + datasource + ".pxResults']");
				if (dlgDiv.length > 0) {
					var arrSectionsWithDLG = [];
					//var sectionFromEventTarget = pega.util.Dom.getChildren(sectionParentFromEventTarget)[0];
					pega.ctx.dom.$("[data-lg-repeatsource~='" + dataSource + "']").each(function (index, element) {
						var sectionDiv = pega.u.d.getSectionDiv(element);
						if (sectionDiv && arrSectionsWithDLG.indexOf(sectionDiv) == -1) {
							arrSectionsWithDLG.push(sectionDiv);
						}
					});
					for (var i = 0; i < arrSectionsWithDLG.length; i++) {
						pega.u.d.reloadSection(arrSectionsWithDLG[i], '', '', false, false, '', false);
					}
				}
				//Refresh the sections containging the RDL bound to 'dataSource'
				pega.ui.rdlMasterDetails.refreshRDLSections(dataSource, index);
			},
			cancel: function () {
				// Delete the newly added page on cancel
				sourceList.remove(index);
         var dataSource = sourceList.getReference();
        /* BUG-582991 : Refresh RDL while cancel as well*/
        pega.ui.rdlMasterDetails.refreshRDLSections(dataSource);
			}
		};

		/* Step 4: Prepare the "options" to be sent to processAction*/
		var options = {
			mTObjClass: rowClass,
			fAObjClass: rowClass,
			isCenterOverlay: "false",
			isLocalAction: "true",
			doNotRefresh: true,
			doNotSubmit: true,
			animObj: {
				animIn: "anim-bottom",
				animOut: "anim-bottom"
			},
			contextParams: { /* TASK-319793: Pass these params so that entry handles are changed to current row context */
				packagedContext: packagedPageName,
				runtimeContext: newlyAddedPage.getReference()
			}
		};

		/* BUG-245825: Pass the base reference to the flow action, so that it can be launched on proper context */
		var urlObj = new SafeURL();
		urlObj.put("BaseReference", newlyAddedPage.getReference());

		// Step 5: Launch the modal dialog to display the flowaction
		pega.u.d.processAction(localAction, "", "Rule-Obj-FlowAction", "", "", true, event, templateName, urlObj, null, null, "", callbackObj, options, false);
	},

	/*
  Algorithm:
  Arguments: eventObject
  1. Get RL Node from eventObject
  2. Get PL from DS using CC APIs
  3. Invoke PL.remove()
  4. Refresh the RL (DC) using pega.ui.DCUtil.refresh()
  */
	remove: /* istanbul ignore next */function (event) {

		// Step1: Get RL Node from eventObject
		var srcElement = pega.util.Event.getTarget(event);
		var RLNode = pega.ui.rdlMasterDetails.getEnclosingRL(srcElement);

		// Step2: Get PL from eventObject
		var dsObject = pega.ui.DataRepeaterUtils.getAbsoluteDataSourceFromEvent(event);
		var dataSource = dsObject.dataSource;
		var rowIndex = dsObject.rowIndex;
		// No data source / row index found, quit
		if (!dataSource || !rowIndex) return;

		var PL = pega.ui.ClientCache.find(dataSource);
		// Corresponding PL could not be found
		if (!PL) return;

		// Step3: Remove page from PL
		PL.remove(rowIndex);
		var dlgDiv = pega.ctx.dom.$("[data-lg-repeatsource='" + dataSource + ".pxResults']");
		if (dlgDiv.length > 0) {
			LayoutGroupModule.setLayoutActiveIndex(dlgDiv, "DEL" + rowIndex);
		}

		// Step4: Refresh RL
		if (pega.u.d.ServerProxy.isDestinationLocal()) {
			pega.ui.DCUtil && pega.ui.DCUtil.refresh();
			var dlgDiv = pega.ctx.dom.$("[data-lg-repeatsource='" + dataSource + "']");
			if (dlgDiv.length > 0) {
				var arrSectionsWithDLG = [];
				//var sectionFromEventTarget = pega.util.Dom.getChildren(sectionParentFromEventTarget)[0];
				pega.ctx.dom.$("[data-lg-repeatsource~='" + dataSource + "']").each(function (index, element) {
					var sectionDiv = pega.u.d.getSectionDiv(element);
					if (sectionDiv && arrSectionsWithDLG.indexOf(sectionDiv) == -1) {
						arrSectionsWithDLG.push(sectionDiv);
					}
				});
				for (var i = 0; i < arrSectionsWithDLG.length; i++) {
					pega.u.d.reloadSection(arrSectionsWithDLG[i], '', '', false, false, '', false);
				}
			}
			if (pega.u.d && typeof pega.u.d.evaluateRefreshWhensOSCO == "function") {
				pega.u.d.evaluateRefreshWhensOSCO(false, true);
			}
		} else {
			pega.u.d.reloadSection && pega.u.d.reloadSection(RLNode, '', '', false, false, '', false);
		}
	},

	/*
  Algorithm:
  Arguments: eventObject
  1. Get PL from DS using CC APIs
  3. Invoke PL.remove()
  4. Refresh the RL (DC) using pega.ui.DCUtil.refresh()
  */
	removeFromRepeatSource: function (dsObject) {

		// Step1: Get PL from eventObject

		var dataSource = dsObject.dataSource;
		var rowIndex = dsObject.rowIndex;
		var domIndex = dsObject.domIndex;
		// No data source / row index found, quit
		if (!dataSource || !rowIndex) return;

		var PL = pega.ui.ClientCache.find(dataSource);
		// Corresponding PL could not be found
		if (!PL) return;
		/* Invoke JS pre hook with the new added page context */
		pega.ui.DataRepeaterUtils.executeListActionHook("PRE", PL, "DELETE", PL.get(rowIndex));

		// Step3: Remove page from PL
		PL.remove(rowIndex);

		/* Invoke JS post hook with the new added page context */
		pega.ui.DataRepeaterUtils.executeListActionHook("POST", PL, "DELETE", PL.getParent());

		// Update handle post row deletion
		pega.ui.DataRepeaterUtils.updateEntryHandles(dataSource, "DELETE", domIndex);
		var dlgDiv = pega.ctx.dom.$("[data-lg-repeatsource='" + dataSource + "']");
		if (dlgDiv.length > 0) {
			LayoutGroupModule.setLayoutActiveIndex(dlgDiv, "DEL" + rowIndex);
		}
		if (pega.u.d && typeof pega.u.d.evaluateRefreshWhensOSCO == "function") {
			pega.u.d.evaluateRefreshWhensOSCO(false, true);
		}
		var dlgDiv = pega.ctx.dom.$("[data-lg-repeatsource='" + dataSource + "']");
		if (dlgDiv.length > 0) {
			var arrSectionsWithDLG = [];
			//var sectionFromEventTarget = pega.util.Dom.getChildren(sectionParentFromEventTarget)[0];
			pega.ctx.dom.$("[data-lg-repeatsource~='" + dataSource + "']").each(function (index, element) {
				var sectionDiv = pega.u.d.getSectionDiv(element);
				if (sectionDiv && arrSectionsWithDLG.indexOf(sectionDiv) == -1) {
					arrSectionsWithDLG.push(sectionDiv);
				}
			});
			for (var i = 0; i < arrSectionsWithDLG.length; i++) {
				pega.u.d.reloadSection(arrSectionsWithDLG[i], '', '', false, false, '', false);
			}
		}
		pega.ui.rdlMasterDetails.refreshRDLSections(dataSource, rowIndex);
	}
};
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.logger");

pega.ui.logger.LogHelper = (function () {	
	
	var _logLevels = {
			DEBUG: 1,			
			ERROR: 2
	};
	
	var currentLogLevel = _logLevels.ERROR;	
	
	var _debug,_error;
	
	// Initialize skeltons
	_debug = function (){};
	_error = function (messages) {
		var msg = "";
		for (var arg in arguments) {
			msg += " " + arguments[arg];
		}
		console.error("ERROR:" + msg);						
	};			
	
	var _setLogLevel = function (logLevel) {
		currentLogLevel = logLevel;
	};
	
	var _enableDebug = function () {
		_debug = function (messages) {			
			var msg = "";
			for (var arg in arguments) {
				msg += " " + arguments[arg];
			}
			console.log("DEBUG:" + msg);
		};
		_init();
	};
	
	var _disableDebug = function () {		
		_debug = function (){};		
		_init();
	};
	
	var _init = function() {
		pega.ui.logger.LogHelper.debug = _debug;
		pega.ui.logger.LogHelper.error = _error;
	};
	
	var loggerInterface = {	
		setLogLevel: _setLogLevel,
		LoggingLevel: _logLevels,
		debug: _debug,
		error: _error,
		enableDebug: _enableDebug,
		disableDebug: _disableDebug
	};
	
	return loggerInterface;
})();
//static-content-hash-trigger-GCC
var pega;
(function (pega) {
    var u;
    (function (u) {
        var clientEvents;
        (function (clientEvents) {
            var $log = pega.ui.logger.LogHelper;
            var subscriptionMap = {};
            clientEvents.EQ_COMPLETED = "EventQueueComplete";
            clientEvents.EQ_PAUSED_FOR_MODAL = "EventQueuePausedForModal";
            clientEvents.WS_ON_OPEN = "WebSocketsOnOpen";
            clientEvents.WS_ON_CLOSE = "WebSocketsOnClose";
            clientEvents.WS_ON_ERROR = "WebSocketsOnError";
            clientEvents.WS_ON_REOPEN = "WebSocketsOnReOpen";
            clientEvents.TMPLT_RENDERING_DONE = "TmpltRenderDone";
            clientEvents.subscribe = function (eventType, callback) {
                if (!subscriptionMap[eventType]) {
                    subscriptionMap[eventType] = [];
                }
                subscriptionMap[eventType].push(callback);
                $log.debug("subscribed for event -" + eventType + "- with callback -" + callback);
            };
            clientEvents.unsubscribe = function (eventType, callback) {
                var index;
                if (subscriptionMap[eventType]) {
                    index = subscriptionMap[eventType].indexOf(callback);
                    if (index != -1) {
                        subscriptionMap[eventType].splice(index, 1);
                        $log.debug("unsubscribed for event -" + eventType + "- with callback -" + callback);
                    }
                }
            };
            clientEvents.publish = function (eventType, message) {
                var i;
                var callback;
                try {
                    if (subscriptionMap[eventType]) {
                        $log.debug("publishing message -" + message + "- for event -" + eventType);
                        for (i = 0; i < subscriptionMap[eventType].length; i = i + 1) {
                            var callback = subscriptionMap[eventType][i];
                            if (callback && typeof callback === 'function') {
                                callback(message);
                            }
                        }
                    }
                }
                catch (e) {
                    $log.error("error while publishing " + e);
                }
            };
            clientEvents.publishAsync = function (eventType, message) {
                setTimeout(function () {
                    clientEvents.publish(eventType, message);
                }, 0);
            };
        })(clientEvents = u.clientEvents || (u.clientEvents = {}));
    })(u = pega.u || (pega.u = {}));
})(pega || (pega = {}));
;
pega.u.ce = pega.u.clientEvents;
//static-content-hash-trigger-GCC
var utilities = {
    prevParentOfSec : null,
    pagesToRemoveMap : {},
    addPageToRemoveList : function(secID,page){//pass secID or harnessID
      var utility = pega.u.template.utility;
       var pagesMap = utility.pagesToRemoveMap;
       pagesMap[secID] = pagesMap[secID] || [];
       pagesMap[secID].push(page);
    }, 
    childsOfASection : {},
    addSectionAsChild : function(childID,parentID){
      var utility = pega.u.template.utility;
      var childMap = utility.childsOfASection;
       childMap[parentID] = childMap[parentID] || [];
       childMap[parentID].push(childID);
    },
  	getChildsOfSection : function(secID,childSectionIds){
      var utility = pega.u.template.utility;
      var childSecIds = childSectionIds || [];
      var childIDs = utility.childsOfASection[secID];
      if(childIDs){
        var size = childIDs.length;
      	for(var i=0;i<size;i++){
          if((childIDs[i] !== secID) && (childSecIds.indexOf(childIDs[i]) === -1)){ 
        	childSecIds.push(childIDs[i]);
        	utility.getChildsOfSection(childIDs[i],childSecIds);
          }
      	}
      }
      return childSecIds;
  	},
    getParentOfASec : function(id){ 
      var utility = pega.u.template.utility;
        var childs = utility.childsOfASection;
          for(var i in childs){
            if(childs[i].indexOf(id) !== -1){
              return i;
            }
       }
    },
  getHarnessCleanUpPages : function(id){
    var utility = pega.u.template.utility;
      var pagesToRemove = utility.pagesToRemoveMap[id] ? utility.pagesToRemoveMap[id].toString() : "";
      utility.pagesToRemoveMap = {};
      utility.childsOfASection = {};
      return pagesToRemove;
  },
    removeRefsOfSection : function(secID){
      var utility = pega.u.template.utility;
      var refs = utility.childsOfASection;
      for(var key in refs){
        key === secID ? delete refs[key] : removeInnerRefs(refs[key]);
      }
        function removeInnerRefs(arr){
          for(var kk=0;kk<arr.length;kk++){
            arr[kk] === secID ? arr.splice(arr.indexOf(kk),1) : "";
          }
        }
    },
   removePageRefs : function(pages,harnessId){ 
     var utility = pega.u.template.utility;
        var harnessPages = utility.pagesToRemoveMap[harnessId];
     if(harnessPages){
          var pagesArr = pages.split(",");
          var size = pagesArr.length;
         for(var i=0;i<size;i++){
           if(harnessPages.indexOf(pagesArr[i]) != -1){
             harnessPages.splice(harnessPages.indexOf(pagesArr[i]),1);
           }
         }
     }
   },
  addSectionInfo : function(secObj){
    var utility = pega.u.template.utility;
    if(secObj.action == "push"){
      utility.addSectionAsChild(secObj["uniqueID"],pega.peekStackFrame("secID") || utility.prevParentOfSec || "Top");
      pega.pushStackFrame("secID", secObj["uniqueID"]);
    }else if(secObj.action == "pop"){
      pega.popStackFrame("secID");
    }
  }
};
pega.ui.template.utility = utilities;
//static-content-hash-trigger-GCC
var ajaxengine = {
	gIsScriptsLoading: false,
	activeAsyncRequests: 0,
	/*Counter to track active async requests*/
	preReloadEle: null,
	AJAXStatus: null, // initialized by pega.u.ajaxstatus
	ajaxParams: new Hashtable(),
	ajaxFailureCount: 1,
	BEFORE_SECTIONS_REFRESH: "BeforeSectionsRefresh",
	AFTER_SECTIONS_REFRESH: "AfterSectionsRefresh",
	BEFORE_COMPONENT_REFRESH: "BeforeComponentRefresh",
	AFTER_COMPONENT_REFRESH: "AfterComponentRefresh",
	//Do not cache section list in refresh if this boolean is set to true
	ignoreCachingSectionList: false,
	/* value of 1 retries request twice */
	ajaxFailureSecondaryCount: -1,
	checkExceptions: function(stream, div) {
		if (stream.indexOf("PegaServErr") >= 0) {
			var docfrag = document.createDocumentFragment();
			var newTempdiv = document.createElement("div");
			newTempdiv.innerHTML = stream;
			docfrag.appendChild(newTempdiv);
			var ele = pega.util.Dom.getElementsById("PegaServErr", newTempdiv, "div");
			if (ele && ele.length > 0) {
				docfrag.removeChild(newTempdiv);
				docfrag = null;
				div.innerHTML = stream;
				return true;
			}
			docfrag.removeChild(newTempdiv);
			docfrag = null;
		}
		return false;
	},
	incrementAsyncRequestCount: function() {
		pega.u.d.activeAsyncRequests++;
		if (pega.u.d.activeAsyncRequests == 1) {
			if (this.AJAXStatus) {
				this.AJAXStatus.start();
			}
		}
		// publish state to test and performance tooling
		pega.ui.statetracking.setAjaxBusy();
	},
	decrementAsyncRequestCount: function() {
		if (pega.u.d.activeAsyncRequests > 0) {
			pega.u.d.activeAsyncRequests--;
			// publish state to test and performance tooling
			pega.ui.statetracking.setAjaxDone();
		}
		if (pega.u.d.activeAsyncRequests == 0) {
			if (this.AJAXStatus) {
				this.AJAXStatus.complete();
			}
			pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
		}
	},
	isAjaxInProgress: function() {
		return (pega.u.d.activeAsyncRequests > 0);
	},
	pauseAjaxSequencer: function() {
		pega.u.d.incrementAsyncRequestCount();
		if (pega.c && pega.c.actionSequencer) {
			pega.c.actionSequencer.pause();
		}
	},
	resumeAjaxSequencer: function() {
		pega.u.d.decrementAsyncRequestCount();
		if (pega.c && pega.c.actionSequencer && !pega.u.d.isAjaxInProgress()) {
			pega.c.actionSequencer.resume();
		}
	},
    /**
     * PostData this is wrapper to process SafeURL, FormData and postbody string
     * @param this can be null, string, SafeURL instance or FormData instance
     */
	PostData: function(postData) {
		var isFormData = postData instanceof FormData;
		postData = postData || new SafeURL();
		this.getInfoToSend = function() {
			return postData;
		};
    this.get = function(name) {
      return postData!==null ? postData.get(name) : null;
    };
		if (isFormData) {
			this.append = function(name, value) {
				postData.append(name, value);
			};
		} else if (postData instanceof SafeURL) {
			this.append = function(name, value) {
				postData.put(name, value);
			};
			this.getInfoToSend = function() {
				return postData.toEncodedPostBody();
			};
		} else {
			this.append = function(name, value) {
        if(typeof(postData.put) === "function"){
           postData.put(name, value); 
        }else {
				    postData += "&";
				    postData += name;
				    postData += "=";
				    postData += encodeURIComponent(value);
        }
			};
		}
		this.addOnlyOnceInfo = function() {
			if (!pega.ui.onlyOnce) {
				return;
			}
			var onlyOnceObj = pega.ui.onlyOnce.getAllNamesObject();
			for (var ooname in onlyOnceObj) {
				this.append("$O" + ooname, "");
			}
		};
		this.isFormData = function() {
			return isFormData;
		};
	},
	asyncRequest: function(method, safeUrl, callback, postData, asyncConfigOptions) {
		if (!pega.u.d.isHarnessInitialized()) {
			pega.u.d.deferAsyncRequest(this, [method, safeUrl, callback, postData, asyncConfigOptions]);
			return;
		}
		var postDataObj = new this.PostData(postData);
        /* BUG-260360: Set templating status to N if not already set.
            If "StreamList" is present then skip the block as refresh-other section may have multiple sections to refresh and each has its own templating status in "StreamList" param */
		if (pega.ctx.isUITemplatized) {
			if (!safeUrl.get("UITemplatingStatus") && !safeUrl.get("StreamList")) {
				safeUrl.put("UITemplatingStatus", "N");
			}
		}
		//US-81755:Stopping ajax request when offline
		if (pega.u.d.ServerProxy.isDestinationLocal()) {
			if (typeof (safeUrl.get("pyActivity")) != "undefined") {
				if (safeUrl.get("pyActivity") == "ReloadSection") {
					if (typeof (safeUrl.get("StreamName")) != "undefined") {
						alert("Configuration for Ajax request to reload " + safeUrl.get("StreamName") || safeUrl
							.get("StreamList") + " section is not supported in offline");
					} else if (typeof (safeUrl.get("StreamList")) != "undefined") {
						var sectionsList = safeUrl.get("StreamList").split(":");
						var str = "Configuration for Ajax request to reload ";
						for (var i = 0; i < sectionsList.length; i++) {
							if (sectionsList[i] != "") {
								var list = sectionsList[i].split("|");
								str = str + list[0] + " ";
							}
						}
						str = str + " sections is not supported in offline";
						alert(str);
					} else {
						alert(
							"Configuration for Ajax request to call ReloadSection activity is not supported in offline"
						);
					}
				}
				else {
					/* BUG-222626*/
					if (safeUrl.get("pyActivity") == "pzRunActionWrapper") {
						var Configurationisnotsupportedinoffline = pega.u.d.fieldValuesList.get("Configurationisnotsupportedinoffline");
						Configurationisnotsupportedinoffline = Configurationisnotsupportedinoffline.replace("$*~ActivityName~*$", safeUrl.get("pzActivity"));
						alert(Configurationisnotsupportedinoffline);
					}
					else {
						alert("Configuration for Ajax request to call " + safeUrl.get("pyActivity") +
							" activity is not supported in offline ");
					}
				}
			} else {
				alert("Configuration for Ajax request is not supported in offline");
			}
			/* BUG-305686: calling hide busy indicator */
			pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
			pega.control && pega.control.Actions && pega.control.Actions.prototype.hideSkeleton && pega.control.Actions.prototype.hideSkeleton();
			return;
		}
		// start busy logger
		pega.ui.statetracking.setAjaxPreBusy("asyncRequest");
		try {
			//Set the pyActiveDocumentType on every post request. This will sync the clipboard with the client state
			var DCUtil = pega.desktop.support.getDesktopWindow() ? pega.desktop.support.getDesktopWindow().pega.ui
				.DCUtil : null;
			if (method.toUpperCase() == 'POST' && DCUtil && (safeUrl.get("pyActivity") !== "@baseclass.doUIAction")) {
				var keyToUse = pega.u.property.toHandle(
					'Declare_pyDisplay.pyDCDisplayState.pyActiveDocumentType');
				var documentType = DCUtil.getActiveDocumentType();
				if (documentType && documentType != "") {
					postDataObj.append(keyToUse, documentType);
				} else {
					//console.log('not setting pyActiveDocumentType in post data ');
				}
			}
		} catch (e) {}
		safeUrl.put("inStandardsMode", pega.u.d.inStandardsMode);
		/* chens3 add Change Tracker Id to request if present */
		var isRemoteCase = safeUrl.get("isRemoteCase");
		//BUG-438913 Added typeof string check to not break AttachContent usecase
		if (pega.ui.ChangeTrackerMap.getTracker().id && isRemoteCase != 'true' && safeUrl.get("isMDC") != "true" &&
			((typeof (postData) === 'string') || !postData || (postData && postData.get && postData.get("isDCSPA") !== "true"))) {
			safeUrl.put("AJAXTrackID", pega.ui.ChangeTrackerMap.getTracker().id);
		}
		if (pega.u.d.ServerProxy.isDestinationRemote() && (pega.offline || pega.mobile.isMultiWebViewOfflinePegaMobileClient)) {
			safeUrl.put("isRemoteCase", "true");
		}
		var hID = pega.ctx.pzHarnessID; /* pega.ctx.dom.getElementById("pzHarnessID"); */
		if (hID) safeUrl.put("pzHarnessID", hID);
		///TODO HAS FILE
        /*var hasFile = pega.ctx.hasFile();
        var oForm = pega.ctx.getFormElement();
        if (hasFile) {           
          this.removeReadOnlyFormatValues(oForm);
        if (asyncConfigOptions && asyncConfigOptions.resetPlaceholders) {
                pega.control.PlaceHolder.removePlaceHolderValues(oForm);
            }
        }*/
		var headerButtonIndicator = pega.ctx.dom.querySelectorAll("input#HeaderButtonSectionIndicator");
		if (headerButtonIndicator && headerButtonIndicator[0]) {
			safeUrl.put('HeaderButtonSectionName', headerButtonIndicator[0].value);
		}
		postDataObj.addOnlyOnceInfo();
		if (safeUrl.get("pzPrimaryPageName") == false && safeUrl.get("pyActivity") != "pyDeleteDocumentPg") {
			safeUrl.put("pzPrimaryPageName", pega.ctx.primaryPageName);
		}
		if (safeUrl.get("pzKeepPageMessages") == "true") {
			// stop clearing the error tables for defer loaded conditions
		} else {
			this.clearErrorTables();
		}
		this.checkAndUpdateTargetParam(safeUrl);
		callback = this.wrapCallback(callback, safeUrl, asyncConfigOptions); // wraps original callback with additional functionality  and returns wrapped callback.
		/* Start for Benchmark Timer Submit End Time */
		if (typeof bRecordEvent != "undefined" && bRecordEvent) {
			if (!callback.customevents) {
				callback.customevents = {};
			}
			if (!callback.customevents.onComplete) {
				callback.customevents.onComplete = function() {
					pega.u.d.decrementAsyncRequestCount();
					var responseText = arguments[1][0].conn.responseText;
				}
			} else {
				var origComplete = callback.customevents.onComplete;
				callback.customevents.onComplete = function() {
					pega.u.d.decrementAsyncRequestCount();
					var responseText = arguments[1][0].conn.responseText;
					origComplete();
				}
			}
		}
		/* End for Benchmark Timer Submit End Time */
		pega.u.d.pauseAjaxSequencer();
		if (pega.u.d.fixBaseThreadTxnId) {
			pega.u.d.fixBaseThreadTxnId(safeUrl);
		}

		if (!pega.ctx.ignoreCachingSectionList) {
			pega.u.d.cacheSectionNamesInRefresh(safeUrl);
		}

		if (safeUrl.get("isSecuredURL") == "true") {
			safeUrl.remove("isSecuredURL");
			/* US-237221: remove pyAvtivity from strUrlSF */
			if (safeUrl.get("pyActivity") != null && typeof (safeUrl.get("pyActivity")) === "string") {
				safeUrl.remove("pyActivity");
			}
		}

		pega.u.d.ajaxParams['method'] = method;
		pega.u.d.ajaxParams['safeUrl'] = safeUrl.toURL();
		pega.u.d.ajaxParams['callback'] = callback;
		if (!postDataObj.isFormData()) {
			pega.u.d.ajaxParams['postData'] = postDataObj.getInfoToSend();
		}
		if (pega.u.d.ajaxFailureSecondaryCount < 0 && pega.u.d.ajaxFailureCount != 0) {
			pega.u.d.ajaxFailureSecondaryCount = pega.u.d.ajaxFailureCount;
		}
		// set default callback timeout to fix issue with IE bug(12152)
		if (pega.u.d.ajaxTimeout && pega.u.d.ajaxTimeout > 0) {
			callback.timeout = pega.u.d.ajaxTimeout;
		}
		var pyLatitude = pega.util.Dom.getElementsById("pxRequestorPyLatitude", document.forms[0], "INPUT");
		var pyLongitude = pega.util.Dom.getElementsById("pxRequestorPyLongitude", document.forms[0], "INPUT");
		//BUG-482090 - Added a check for get tracker changes as it was giving some Secu-0001 alerts for pyLat and pyLong properties. Hence not adding them to postData
    if (method == "POST" && pyLatitude && pyLatitude.length == 1  && pyLatitude[0].value != ""  && pyLongitude && pyLongitude.length == 1 && pyLongitude[0].value != "" && safeUrl.get("pyActivity") != "pzGetTrackerChanges") {
			try {
				var latCord = pega.util.Dom.getElementsById("pxRequestorPyLatitude", document.forms[0], "INPUT")[
					0];
				var longCord = pega.util.Dom.getElementsById("pxRequestorPyLongitude", document.forms[0],
					"INPUT")[0];
				postDataObj.append(latCord.getAttribute("name"), latCord.value);
				postDataObj.append(longCord.getAttribute("name"), longCord.value);
			} catch (e) { /* console.log("Error in setting latitude and longitude"); */}
		}
		if (postDataObj.isFormData()) {
			var request = new XMLHttpRequest();
			request.onreadystatechange = function() {
				var responseObj = {};
				for (var attr in this) {
					responseObj[attr] = this[attr];
				}
				if (this.readyState == 4) {
					if (callback.argument) {
						responseObj.argument = callback.argument;
					}
					if (this.status == 200) {
						callback.success.call(callback.scope, responseObj);
					} else {
						callback.failure.call(callback.scope, responseObj);
					}
				}
			};
			//Fix for BUG-423206 & BUG-425628 include CSRFtoken and browser fingerprint in the formbody
			//Fix for BUG-487724 - setting parent CSRFtoken for FlowInModal ,DCSPA and AC cases.
			var topHarnessContext = pega.ctxmgr.getRootDocumentContext();
			if ((pega.u.d && (pega.u.d.isFlowinModalProgress || pega.u.d.bIsFlowInModal || pega.u.d.bIsDCSPA)) || pega.ctx.isMDC) {
				var topHarnessContext = pega.ctxmgr.getRootDocumentContext();
				if (topHarnessContext)
					postDataObj.append("pzCTkn", topHarnessContext.activeCSRFToken);
			} else {
				postDataObj.append("pzCTkn", pega.ctx.activeCSRFToken);
			}
			postDataObj.append("pzBFP", pega.d.browserFingerprint);
      pega.u.d.convertToRunActivityAction(safeUrl, postDataObj); 
			request.open(method, safeUrl.toURL());
			request.send(postDataObj.getInfoToSend());
			var rtn = request;
		} else {
			var _async;
			if (asyncConfigOptions) {
				_async = asyncConfigOptions.bAsync;
			}
			var safeURLToSend = safeUrl;
      
      pega.u.d.convertToRunActivityAction(safeUrl, postDataObj); 
      
			if (method == "POST") {
				safeURLToSend = pega.u.d.moveParamsFromURLToPostData(safeUrl, postDataObj);
			}
			var rtn = pega.util.Connect.asyncRequest(method, safeURLToSend.toURL(), callback, postDataObj.getInfoToSend(), _async);
		}
		// increment busy logger
		pega.ui.statetracking.setAjaxPreDone();
		return rtn;
	},
  
  convertToRunActivityAction : function(safeUrl, postDataObj){
    var strActivityName = safeUrl.get("pyActivity");
    pega.u.d.preFillMissingParams(safeUrl, postDataObj); 
    
    if(strActivityName && pega && typeof pega.isSecuredFeature == "function" && !pega.isSecuredFeature(strActivityName)){
      safeUrl.put("pzActivity", strActivityName);
      safeUrl.put("pyActivity", "pzRunActionWrapper");
      safeUrl.put("skipReturnResponse", "true");
      safeUrl.put("pySubAction", "runAct");
    }
  },
  
  preFillMissingParams : function(safeUrl, postDataObj){
    var strActivityName = safeUrl.get("pyActivity");
    if(strActivityName=="ReloadSection" || strActivityName=="ReloadHarness" || strActivityName=="@baseclass.ReloadSection" || strActivityName=="@baseclass.ReloadHarness"){
      var preAct = safeUrl.get("PreActivity");
      var preDT = safeUrl.get("PreDataTransform");
      var preActMulti = (postDataObj!=null) ? postDataObj.get("PreActivitiesList") : null;
      if(!preAct){
        safeUrl.put("PreActivity", "");
      }
      if(!preDT){
        safeUrl.put("PreDataTransform", "");
      }
      if(!preActMulti && (strActivityName=="ReloadSection" || strActivityName=="@baseclass.ReloadSection")){
        if(postDataObj){
           postDataObj.append("PreActivitiesList", "")
        }else{
          safeUrl.put("PreActivitiesList", "");
        }
      }
    }
  },

	/*moves parameters to post body(US-227358)*/
	moveParamsFromURLToPostData: function(safeUrl, postDataObj) {
		var safeURLUpdated = SafeURL_clone(safeUrl);
		var parameterSetForQueryString = {
			/*'pyActivity': true,*/
			'pzTransactionId': true,
			'pzPrimaryPageName': true,
			'pzFromFrame': true,
			'AJAXTrackID': true,
			'pxReqURI': true
		};
		var urlHashTable = safeURLUpdated.hashtable;
		for (var key in urlHashTable) {
			if (!parameterSetForQueryString[key]) {
				var decodedValue;
				try {
					decodedValue = decodeURIComponent(urlHashTable[key]);
				} catch (e) {
					decodedValue = urlHashTable[key];
				}
				postDataObj.append(key, decodedValue);
				delete urlHashTable[key];
			}
		}
		return safeURLUpdated;
	},

	/* Skeleton CallBack to get skeleton out from ajax response - start */
	fetchAndAttachSkeleton: function(responseObj) {
		if (responseObj && responseObj.responseText) {
			var newTempdiv = document.createElement("div");
			newTempdiv.innerHTML = responseObj.responseText;
			var $skeletonDivs = $(newTempdiv).find("[data-skeleton]");
			for (var i = 0; i <= $skeletonDivs.length; i++) {
				if ($("body").find("#" + $skeletonDivs.attr("id")).length == 0) {
					$("body").append($skeletonDivs[i]);
				}
			}
			/*$(newTempdiv).find("[data-skeleton]").remove();
			responseObj.responseText = $(newTempdiv).html();*/
		}
		newTempdiv = null;
		// return responseObj;      
	},
	/* Skeleton CallBack to get skeleton out from ajax response - end */


	/*// wraps original callback with additional functionality  and returns wrapped callback. */
	wrapCallback: function(callback, safeUrl, asyncConfigOptions) {
		var actualContext = pega.ctx; //cache current harness context for later use in callback handlers
		var originalCallback = callback;
		if (!callback) {
			callback = {};
		}
		//perform scope handling
		var calleeScope;
		if (callback.scope) {
			calleeScope = callback.scope;
		} else {
			calleeScope = this;
		}
		//if responseText in responseObject is of type JSON or not
		var jsonTypeResponse = callback.isJSONTypeResponse;

		/* ISSUE-67244: Incase of offline we are not getting isJSONTypeResponse in offline so setting to false explicitly else UI is not rendering with Ajax Container */
		if (pega.u.d.isAppOfflineEnabled() && pega.u.d.ServerProxy.isDestinationLocal()) {
			jsonTypeResponse = false;
		}

		var hasFile = false;//pega.ctx.hasFile();
		//store value of original callback.
		var originalSuccessCallback = callback.success;
		var originalFailureCallback = callback.failure;
		var originalUploadCallback = callback.upload;
		//override the 'success' case callback
		callback.success = function(respObject) {
			try {
				pega.ctxmgr.setContext(actualContext); //set to the actual harness context
				pega.u.d.ajaxParams['method'] = null;
				pega.u.d.ajaxParams['safeUrl'] = null;
				pega.u.d.ajaxParams['callback'] = null;
				pega.u.d.ajaxParams['postData'] = null;
				if (pega.u.MessagingManager) {
					pega.u.MessagingManager.tryReconnect();
				}
				// start busy logger
				pega.ui.statetracking.setAjaxPostBusy("ajaxEngine.callback.success");
				pega.u.d.ajaxFailureSecondaryCount = -1;
				pega.u.d.decrementAsyncRequestCount();

				/* Skeleton remove from response */
				var navUserAgent = navigator.userAgent;
				var isMobile = navUserAgent.match(/Android/i) || navUserAgent.match(/BlackBerry/i) || navUserAgent.match(/iPhone|iPad|iPod/i) || navUserAgent.match(/Opera Mini/i) || navUserAgent.match(/IEMobile/i);
				var isTablet = navUserAgent.match(/Tablet|iPad|iPod/i);
				if ((navUserAgent.toLowerCase().indexOf('pegamobilesdk') != -1) || (navUserAgent.toLowerCase().indexOf('ampwebcontrol') != -1) || (navUserAgent.toLowerCase().indexOf('pegaelectroncontainer') != -1) || (isMobile && !isTablet) || (respObject && respObject.responseText && respObject.responseText.indexOf("class=\"skeleton\"") > 0)) {
					pega.u.d.fetchAndAttachSkeleton(respObject);
				}

				var retHTML = respObject.responseText;
        		var errorPattern = new RegExp(/pega.u.d.pyStreamNameForGadget\s*=\s*\"ActivityStatusError\"/g);
				/*BUG-130967: removed > in <html> as the html tag comes with a class(<html class="">)*/
				/*BUG-307367: Added the ActivityStatusError index in the last */
				if (retHTML.indexOf("<html") > -1 && retHTML.indexOf("ActivityStatusError") > -1 && errorPattern.test(retHTML) && retHTML.indexOf("retHTML.indexOf(\\\"ActivityStatusError\\\")") == -1) {
					if (originalCallback) {
						if (top.launchbox && top.launchbox.Browser) {
							var mywindow = pega.desktop.support.getDesktopWindow();
							var frame = mywindow.$(
								'<div><iframe name="pzErrorDetailWindow" id="pzErrorDetailWindow" frameborder="0" src="" style="width:100%; height:100%"/></div>'
							);
							var dialogWindow = frame.dialog({
								autoOpen: true,
								modal: true,
								draggable: false,
								closeOnEscape: false,
								resizable: false,
								width: '100%',
								height: $(mywindow).height(),
								left: '0px',
								top: '0px',
								open: function() {
									var pzDisplayModalDialogWindow = $(this).children()[0].contentWindow;
									pzDisplayModalDialogWindow.document.write(retHTML);
								},
								close: function() {
									dialogWindow.dialog('destroy');
									frame.remove();
									dialogWindow.remove();
								}
							}).resize();
							var content = mywindow.$("#pzErrorDetailWindow").contents();
							var title = content.find("title").html();
							dialogWindow.dialog('option', 'title', title);
							content.find("#EXPAND-INNERDIV").css("display", "block");
							if (mywindow.$("html").hasClass("iOS")) {
								dialogWindow.css("overflow", "auto");
								dialogWindow.css("-webkit-overflow-scrolling", "touch");
							} else {
								dialogWindow.css("overflow", "hidden");
							}
							dialogWindow.css("padding", "0");
						} else {
							var win = window.open("", 'errorDetailWindow', 'toolbar=no,scrollbars=yes');
							if (win) {
								win.document.write(respObject.responseText);
								if (win.document.getElementById("EXPAND-INNERDIV")) {
									win.document.getElementById("EXPAND-INNERDIV").style.display = "block";
								}
								win.focus();
							}
						}
					}
					pega.u.d.gBusyInd.hide();
				} else {
					//respObject.responseText = responseNode.innerHTML; = responseNode.innerHTML;
					pega.u.d.showURLTamperFailures(respObject, safeUrl);
					var contextPushed = false;
					function uiRenderedCallback(responseText, isTemplateCB) {
						pega.ctxmgr.setContext(actualContext);
						if (responseText != null) respObject.responseText = responseText;
						//calling original "success" case callback.
						if (typeof originalSuccessCallback == "function") {
							originalSuccessCallback.call(calleeScope, respObject);
						}
						// Bug-116808 pega gets destroyed in originalSuccessCallback when creating property alias.
						if (typeof (pega) == "undefined") return;
						if (pega.c && pega.c.actionSequencer && (pega.c.actionSequencer.isQueueEmpty() || (pega.c
							.actionSequencer.getEventsQueueLength() == 1 && pega.c.actionSequencer.getActionInQueue(
								'publishEndOfQueue')))) {
							pega.u.d.evaluateClientConditionsOnChangeList(true, true);
							pega.u.d.ct_sectionsList = new Array();
              /*BUG-530842 : publishing AFTER_SECTIONS_REFRESH on callback*/
              pega.ui.EventsEmitter.publishSync(pega.u.d.AFTER_SECTIONS_REFRESH, safeUrl);
						}
						// creating new tracker if tracker div present in response
						pega.u.d.initChangeTracker();
						/* nullify the preReloadEle which was set in pega.u.d.reload function to the dom element just now reloaded due to the current AJAX response */
						pega.u.d.preReloadEle = null;
						/*if (hasFile) {
						  pega.control.PlaceHolder.addPlaceHolderValues(document.forms[0]);
						  pega.u.d.addReadOnlyFormatValues(document.forms[0]);
						}*/
						if (pega.c && pega.c.actionSequencer && !pega.u.d.gIsScriptsLoading && !pega.u.d.isAjaxInProgress()) {
							pega.c.actionSequencer.resume();
						}
						/*fix for bug 42943 begin*/
						if (safeUrl && safeUrl.get("pyActivity") != "pyDeleteDocumentPg") { // resizeModalDialog gets called on onunload from deletedocumentpg ajax call which is not needed.
							if (pega.u.d.bModalDialogOpen) {
								pega.u.d.resizeModalDialog();
								//pega.u.d.focusOnModalDialogFirstElement();
							}
						}
						/*fix for bug 42943 end*/
						// increment busy logger
						pega.ui.statetracking.setAjaxPostDone();
						pega.ctxmgr.resetContext();
						actualContext = null;
						var scriptsToRemove = document.querySelectorAll("script[data-to-remove]");
						for (var i = 0; i < scriptsToRemove.length; i++) {
							if (scriptsToRemove[i].parentNode) {
								scriptsToRemove[i].parentNode.removeChild(scriptsToRemove[i]);
							}
						}
						/*BUG-342360 - Pop the context if its pushed before rendering layout */
						if (contextPushed) {
							pega.ui.TemplateEngine.getCurrentContext().pop();
							contextPushed = false;
						}
					}
					if (!jsonTypeResponse) {
						if (pega.u.d.showLoginScreen(respObject.responseText)) return;
						if (pega.u.d.ServerProxy.isDestinationRemote() || pega.u.d.bIsDCSPA) {
							var dummyDiv = document.createElement("div");
							var isFromDatapage = asyncConfigOptions && asyncConfigOptions.isFromDatapage;
              if(!isFromDatapage) {
                dummyDiv.innerHTML = retHTML;
              }
							var pega_script = dummyDiv.querySelector("#pega_scripts");
							if (pega_script) {
								pega_script = pega_script.innerHTML;
								try {
									pega_script = pega_script.replace(/&amp;/g, '&');
									eval(pega_script);
									var ctObjs = pega.u.ChangeTrackerMap.getTrackers();
									delete ctObjs.NONOSCOThread;
									if (pega.u.d.ServerProxy.isDestinationRemote()) {
										pega.u.d.initChangeTracker(dummyDiv);
										if (pega.u.d.ServerProxy.isDestinationRemote()) {/* BUG-299624 */
											/*BUG-304824  we need to set server availabilty to true after tracker intialization*/
											if (pega.offline && pega.offline.NetworkStatus) {
												var trackedPropertiesList = pega.u.ChangeTrackerMap.getTracker().trackedPropertiesList;
												trackedPropertiesList.pxRequestor = trackedPropertiesList.pxRequestor || {};
												trackedPropertiesList.pxRequestor.pzIsPegaServerAvailable = ((!!pega.offline.NetworkStatus.STATE_ONLINE) ? "true" : "false");
											}
										}
										pega.ui.ClientDataProvider.initChangeTracker();
									}
								} catch (e) {
									console.log('exception while evaluating pega script');
								}
							}
						} else {
							// datatransform TASK-449847 bajaj
							var dataTransform = arguments[0].argument ? arguments[0].argument[11] : undefined;
							if (dataTransform && (dataTransform instanceof Array) && dataTransform.length > 0 &&
								dataTransform[0] !== ",") {
								var pageRef = pega.u.d.getBaseRef(arguments[0].argument[0]) || undefined;
								var className = $(arguments[0].argument[0]).attr("data-offline-classkey") || $(
									arguments[0].argument[0]).attr("pyclassname");
								for (var i in dataTransform) {
									var dtName = dataTransform[i] ? dataTransform[i].split(",") : "";
									if (dtName) pega.offline.runDataTransform(dtName[0], className, pageRef);
								}
							}
						}
						var trackersMap = pega.ui.ChangeTrackerMap.getTrackers();
						for (var threadName in trackersMap) {
							var currentTracker = trackersMap[threadName];
							currentTracker.parseForChangeTrackerDiv(respObject.responseText, false);
							// 05/30/2013 GUJAS1 Invoke DC CT callback if provided
							pega.u.d.notifyDCForCTChanges(currentTracker);
							/* handle cross-threadChanges for other active documents*/
							currentTracker.handleXThreadChanges();
						}
						var puma = pega.namespace("pega.ui.maps.addressmap");
						if (puma && typeof puma.notifyMapsOnCT == "function") {
							var crnttrackerAM = pega.ui.ChangeTrackerMap.getTracker();
							puma.notifyMapsOnCT(crnttrackerAM);
						}
						var putm = pega.namespace("pega.ui.trackingmaps");
						if (putm && typeof putm.notifyMapsOnCT == "function") {
							var crnttrackerTM = pega.ui.ChangeTrackerMap.getTracker();
							putm.notifyMapsOnCT(crnttrackerTM);
						}

						pega.u.d.parseLazyLoadSpan(respObject.responseText);
						if (typeof callback.preRenderer == "function") {
							var isPreCallbackRejected = (false === callback.preRenderer.call(calleeScope, respObject));
							if (isPreCallbackRejected) {
								return;
							}
						}
					}
					if (!jsonTypeResponse && pega.ctx.isUITemplatized) {
						var currentContext = pega.ui.TemplateEngine.getCurrentContext();
						var renderPartialParams;

						if (respObject.argument && respObject.argument.length > 0) {
							pega.ui.EventsEmitter.publishSync("BeforeTemplateUIRendered", {
								targets: respObject.argument[3] || respObject.argument[0]
							});

							// Push adhoc  context, say received section is a child of 
							if (respObject.argument instanceof Array) {
								contextPushed = currentContext.pushAdhocContext(respObject.argument[0]);
								if (respObject.argument.length >= 8) {
									if (respObject.argument[7] && respObject.argument[7].bOSCOPartialRefresh) {
										renderPartialParams = respObject.argument[7];
									}
								}
							}
						}
						/* added for US-229126 - parmn */
						var domClickElement = this.gFocusElement ? this.gFocusElement : (this.focusElement ? this.focusElement : null);
						if (this.loadBehaviour == "firstuse" && domClickElement && !domClickElement.getAttribute('data-fetched')) {
							var tempDomEle = document.createElement('div');
							tempDomEle.innerHTML = respObject.responseText;
							$(tempDomEle).find('div[id^="AJAXCT"]').remove();
							$(tempDomEle).find('#PegaOnlyOnce').remove();
							$(tempDomEle).find("script[src]").remove();

							pega.ui.ClientDataProvider.getMetadataStoreByType("LOCALACTION")[this.uniqueId] = $(tempDomEle).html();
							domClickElement.setAttribute('data-fetched', true);
							this.loadBehaviour = "";
							this.uniqueId = "";
						}
            
            // If called from getDatapage, renderUI is escaped and callback function is triggered
            if(isFromDatapage) {
              uiRenderedCallback && uiRenderedCallback(respObject.responseText);
            } else {
              pega.ui.TemplateEngine.renderUI(respObject.responseText, uiRenderedCallback, renderPartialParams);
            }
            
						//Pop adhoc context, if any
						//pushed && currentContext.pop();
					} else {
						// Call uiRenderedCallback immediately
						uiRenderedCallback(respObject.responseText);
					}
				}

				pega.ctxmgr.resetContext(); //reset to the base harness context
				//actualContext = null;
			} catch (e) {
				pega.ctxmgr.resetContext();
				actualContext = null;
				throw e;
			}
		}
		callback.failure = function(respObject) {
			try {
				pega.ctxmgr.setContext(actualContext); //set to the actual harness context
				pega && pega.u && pega.u.d && pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide(); /*Fix for BUG-220314:Uncontrollable Focus in Data Transform*/

				if (pega && pega.offline && pega.offline.NetworkStatus) {
					/* BUG-180086: set ajaxFailureSecondaryCount to -1 to skip ajax retry logic for offline cases. */
					pega.u.d.ajaxFailureSecondaryCount = -1;
				}
				pega.u.d.decrementAsyncRequestCount();
				try {
					pega.u.d.parseLazyLoadSpan(respObject.responseText);
				} catch (e) {}
				if (typeof originalFailureCallback == "function") {
					originalFailureCallback.call(calleeScope, respObject);
				}
				while (pega.u.d.ajaxFailureSecondaryCount >= 0) {
					pega.u.d.ajaxFailureSecondaryCount--;
					if (pega.u.d.ajaxFailureSecondaryCount >= 0) {
						return pega.util.Connect.asyncRequest(pega.u.d.ajaxParams['method'], pega.u.d.ajaxParams['safeUrl'], pega.u.d.ajaxParams['callback'], pega.u.d.ajaxParams['postData']);
					}

				}
				if (window.ajaxRequestFail) {
					try {
						ajaxRequestFail(respObject);
					} catch (e) {}
				} else {
					// HC check
					if (pega.mobile && pega.mobile.hybrid && pega.mobile.hybrid.getLaunchBox() && pega.u.d.activeAsyncRequests >
						0 && pega.u.d.showAjaxFailureMessageMobile) {
             /*BUG-714421 Skip Alert for pzBuildFilterIcon Activity when triggered from pzpega_ui_template_grid_helpers */    
            var shouldSkipAlert = false;
            shouldSkipAlert = respObject.status === 0 && typeof asyncConfigOptions === "object" && asyncConfigOptions.skipAlert;
            if(!shouldSkipAlert)
						  {
                var alertMessage = pega.u.d.fieldValuesList.get("AjaxRequestFailed");
                if(!alertMessage) {
                  alertMessage = "AJAX request failed. Reason: $*~Reason~*$";
                }
                alertMessage = alertMessage.replace("$*~Reason~*$", respObject.statusText);
                alert(alertMessage);
              }
					}
				}
				/* nullify the preReloadEle which was set in pega.u.d.reload function to the dom element just now reloaded due to the current AJAX response */
				pega.u.d.preReloadEle = null;
				if (pega.c && pega.c.actionSequencer && !pega.u.d.gIsScriptsLoading && !pega.u.d.isAjaxInProgress()) {
					pega.c.actionSequencer.resume();
				}
				pega.ctxmgr.resetContext(); //reset to the base harness context
				actualContext = null;
			} catch (e) {
				pega.ctxmgr.resetContext();
				actualContext = null;
				throw e;
			}
		}
		callback.upload = function(respObject) {
			try {
				pega.ctxmgr.setContext(actualContext); //set to the actual harness context
				// start busy logger
				pega.ui.statetracking.setAjaxPostBusy("ajaxEngine.callback.upload");
				pega.u.d.ajaxFailureSecondaryCount = -1;
				/* if(pega && pega.offline && pega.offline.NetworkStatus) {
					pega.offline.NetworkStatus.setAjaxStatus(pega.offline.NetworkStatus.STATE_ONLINE);
				} */
				pega.u.d.decrementAsyncRequestCount();
				var trackersMap = pega.ui.ChangeTrackerMap.getTrackers();
				for (var threadName in trackersMap) {
					var currentTracker = trackersMap[threadName];
					currentTracker.parseForChangeTrackerDiv(respObject.responseText, false);
					// 05/30/2013 GUJAS1 Invoke DC CT callback if provided
					pega.u.d.notifyDCForCTChanges(currentTracker);
					/* handle cross-threadChanges for other active documents*/
					currentTracker.handleXThreadChanges();
				}
				var puma = pega.namespace("pega.ui.maps.addressmap");
				if (puma && typeof puma.notifyMapsOnCT == "function") {
					var crnttracker = pega.ui.ChangeTrackerMap.getTracker();
					puma.notifyMapsOnCT(crnttracker);
				}
				pega.u.d.parseLazyLoadSpan(respObject.responseText);
				if (typeof callback.preRenderer == "function") {
					var isPreCallbackRejected = (false === callback.preRenderer.call(calleeScope, respObject));
					if (isPreCallbackRejected) {
						return;
					}
				}
				var uiRenderedCallback = function(responseText, isTemplateCB) {
					pega.ctxmgr.setContext(actualContext);
					if (responseText) respObject.responseText = responseText;
					if (typeof originalUploadCallback == "function") {
						originalUploadCallback.call(calleeScope, respObject);
					}
					if (pega.c && pega.c.actionSequencer && pega.c.actionSequencer.isQueueEmpty()) {
						pega.u.d.evaluateClientConditionsOnChangeList(true, true);
					}
					// creating new tracker if tracker div present in response
					pega.u.d.initChangeTracker();
					/* nullify the preReloadEle which was set in pega.u.d.reload function to the dom element just now reloaded due to the current AJAX response */
					pega.u.d.preReloadEle = null;
					// BUG-194325 GUJAS1 03/16/2015: WebWiz introduced this issue with the refactoring done during wrapCallback method implementation.
					// To unblock event sequencing in Attach Content, a safe check has been added. WebWiz should fix this by adding the missing hasFile correctly.
					//TODO has File
					/*if (hasFile) {
						pega.control.PlaceHolder.addPlaceHolderValues(pega.ctx.getFormElement());
						pega.u.d.addReadOnlyFormatValues(pega.ctx.getFormElement());
					}*/
					if (pega.c && pega.c.actionSequencer && !pega.u.d.gIsScriptsLoading && !pega.u.d.isAjaxInProgress()) {
						pega.c.actionSequencer.resume();
					}
					// increment busy logger
					pega.ui.statetracking.setAjaxPostDone();
					pega.ctxmgr.resetContext();
					actualContext = null;
				}
				if (pega.ctx.isUITemplatized) {
					pega.ui.TemplateEngine.renderUI(respObject.responseText, uiRenderedCallback);
				} else {
					// Call uiRenderedCallback immediately
					uiRenderedCallback(respObject.responseText);
				}
				pega.ctxmgr.resetContext(); //reset to the base harness context
				//actualContext = null;
			} catch (e) {
				pega.ctxmgr.resetContext();
				actualContext = null;
				throw e;
			}
		}
		return callback;
	},
	checkAndUpdateTargetParam: function(safeURL) {
		//BUG-227295 : Updated target popup set if it exists in current url.
        /*var currLocation = SafeURL_createFromEncryptedURL(location.search);
        if (currLocation.get("target") === "popup" && !pega.u.d.bIsDCSPA) {
            safeURL.put("target", "popup");
        }*/
	},
	postPage: function(safeUrl, callback, postData) {
		var calleeScope = this;
		if (callback && callback.scope) {
			calleeScope = callback.scope;
		}
		pega.u.d.pauseAjaxSequencer();
		return pega.util.Connect.asyncRequest("POST", safeUrl.toURL(), {
			success: function(respObject) {
				if (callback && typeof callback.success == "function") {
					try {
						callback.success.call(calleeScope, respObject);
					} catch (e) {}
				}
				pega.u.d.resumeAjaxSequencer();
			},
			failure: function(respObject) {
				if (callback && typeof callback.failure == "function") {
					try {
						callback.failure.call(calleeScope, respObject);
					} catch (e) {}
				}
				pega.u.d.resumeAjaxSequencer();
			}
		}, postData);
	},
	/*chens3 caching sections that are refreshed*/
	cacheSectionNamesInRefresh: function(safeUrl) {
		if (safeUrl.get("pyActivity") && safeUrl.get("pyActivity") == 'ReloadSection' && (!safeUrl.get(
			"partialRefresh") || safeUrl.get("partialRefresh") != 'true') && !safeUrl.get("RenderSingle")) {
			var sectionRef = safeUrl.get("StreamName");
			var baseRef = safeUrl.get("BaseReference");
			if (!baseRef) {
				baseRef = "";
			}
			if (sectionRef && sectionRef != null) {
				pega.u.d.ct_sectionsList.push(sectionRef + "~" + baseRef);
			} else {
				if (safeUrl.get("StreamList") != null) {
					var sectionRef = safeUrl.get("StreamList").split(":");
					for (var i = 0; i < sectionRef.length; i++) {
						if (sectionRef[i] != "") {
							pega.u.d.ct_sectionsList.push(sectionRef[i].split("|")[0] + "~" + baseRef);
						}
					}
				}
			}
		}
		if (safeUrl.get("pyActivity") && safeUrl.get("pyActivity") == 'ReloadCell') {
			pega.u.d.ct_postedProp = safeUrl.get("pyPropertyTarget");
		}
	},
	/* XSS decoder */
	decodeCrossScriptingFilter: function(jsonString, escapeFlag) {
		var crossScriptCodes = {
			"&#61;": "=",
			"&lt;": "<",
			"&gt;": ">",
			"&quot;": "\"",
			"&#39;": "'",
			"&#37;": "%",
			"&#59;": ";",
			"&#40;": "(",
			"&#41;": ")",
			"&#43;": "+",
			"&amp;": "&"
		}
		if (typeof escapeFlag != 'undefined' && escapeFlag != null) crossScriptCodes["&quot;"] = "\\\"";
		for (var prop in crossScriptCodes) {
			var re = new RegExp(prop, "ig");
			jsonString = jsonString.replace(re, crossScriptCodes[prop]);
		}
		return jsonString;
	},
	clearErrorTables: function() {
		//Removing Error Table
		var errorTAble = pega.ctx.dom.querySelectorAll("#ERRORTABLE");
		if (errorTAble) {
			var len_errorTable = errorTAble.length; //for performance reasons
			/*BUG-110460 - In case of custom error section, instead of removing errorTAble, removing the innerHTML of the span */
			for (var i = 0; i < len_errorTable; i++) {
				if (pega.u.d.formErrorType == "NONE") {
					var spanEle = pega.util.Dom.getElementsById("ERRORMESSAGES_ALL", errorTAble[i]);
					while (spanEle && spanEle.lastChild) {
						spanEle.removeChild(spanEle.lastChild);
					}
				} else {
					// id can be FormErrorMarker_Div
					var removeErrorTable = true;
					var parentErrorId = $(errorTAble[i].parentNode).attr('id');
					if (pega.u.d.bModalDialogOpen && pega.util.Dom.isAncestor(pega.u.d.modalDialog.body, errorTAble[i]) && !pega.util.Dom.isAncestor(pega.u.d.modalDialog.body, pega.u.d.preReloadEle)) {
						removeErrorTable = false;
					}
					if (removeErrorTable) {
						errorTAble[i].parentNode.removeChild(errorTAble[i]);
					}
					if (parentErrorId == 'FormErrorMarker_Div' && pega.u.d.canErrorDivAbsolute()) {
						// re-adjust the harness padding
						pega.u.d.toggleHarnessPadding();
					}
				}
			}
		}
		var errorTableSpacer = pega.ctx.dom.querySelectorAll("#ErrorTableSpacer")
		if (errorTableSpacer) {
			var len_errorTableSpacer = errorTableSpacer.length; //for performance reasons
			for (var i = 0; i < len_errorTableSpacer; i++) {
				errorTableSpacer[i].style.display = "none";
			}
		}
	},
	showLoginScreen: function(newStream) {
		var invalidSessionDivBegin = '{"invalidSessionAction"';
		var invalSessIdx = newStream.indexOf(invalidSessionDivBegin, 0);
		if (invalSessIdx == 0) {
      var unknownSessionURL =  window.localStorage.getItem("pzUnknownSessionURL");
      window.localStorage.removeItem("pzUnknownSessionURL");
			var oWnd = pega.desktop.support.getDesktopWindow();
			if (!oWnd) {
				oWnd = window;
			}
			var locationJSON = eval("(" + newStream + ")");
			if (locationJSON.invalidSessionAction && locationJSON.pxReqContextPath) {
				pega.u.d.redirectingToLoginScreen = true;
				if (oWnd.pega) {
					oWnd.pega.u.d.redirectingToLoginScreen = true;
				}
				/* isPortal check is to handle IAC cases */
				var isPortal = true;
				if (!pega.u.d.isPortal()) {
					isPortal = false;
				}
				if (oWnd.pega && !oWnd.pega.u.d.isPortal()) {
					isPortal = false;
				} else {
					isPortal = true;
				}
				if (!isPortal) {
					oWnd.location.reload();
				} else {
					if(unknownSessionURL != null) {
            oWnd.location.href = unknownSessionURL;
          } else {
					  oWnd.location.href = locationJSON.pxReqContextPath + (locationJSON.pxReqServletNameReal ? ("/" + locationJSON.pxReqServletNameReal) : "");
          }
				}
				return true;
			}
		}
		return false;
	},
    /**
     * @public Adds the information to the given element and then calls reloadSection API to retrieve the markup from the server
     * this is done because reloadSection handles the PegaOnlyOnce logic that prevents duplicate libraries from being loading more than once
     *
     * @param $String$ sectionName - The name of the section to be loaded
     * @param $String$ sectionClass - The class of the section to be loaded
     * @param $HTML Element$ elem - The HTML to load the section into
     * @param $Function$ callback - Callback fucntion to call when reload is finished
     * @param $String$ baseRef - The base reference of the section to be loaded
     * @param $String$ preActivityName - Name of the pre activity
     * @param $String$ preActivityParams - Parameters for preActivity example:"&paramname=paramvalue"
     */
	loadSectionIntoDom: function(sectionName, sectionClass, elem, callback, baseRef, preActivityName, preActivityParams) {
		if (!preActivityName) {
			preActivityName = "";
		}
		if (!preActivityParams) {
			preActivityParams = "";
		}

		// Set default section attributes
		elem.className = "sectionDivStyle";
		elem.id = "RULE_KEY";
		elem.setAttribute("node_type", "MAIN_RULE");
		elem.setAttribute("version", "1");
		elem.setAttribute("objclass", "Rule-HTML-Section");

		// If client side templating is on then make sure to add data-template attribute
		// lots of reload logic checks if attribute exists so it import to only add when true
		if (pega.ctx.isUITemplatized === true) {
			elem.dataset.template = true;
		}

		// Set name and class
		elem.setAttribute("node_name", sectionName);
		elem.setAttribute("pyclassname", sectionClass);
		elem.dataset.nodeId = sectionName;

		if (baseRef && baseRef != "") {
			elem.setAttribute("BASE_REF", baseRef);
		}

		// Call OOTB reloadSection to handle already loaded scripts
		var tempKeepPageMessages = pega.ctx.KeepPageMessages;
		pega.ctx.KeepPageMessages = true;
		pega.u.d.reloadSection(elem, preActivityName, preActivityParams, false, false, -1, false, null, null, null, callback);
		pega.ctx.KeepPageMessages = tempKeepPageMessages;

		return elem;
	},
	refreshSection: function(sectionName, usingPage, container) {
		if (typeof (container) == "undefined") {
			var container = document;
		}
		var sectionNode = this.getSectionByName(sectionName, usingPage, container);
		if (sectionNode) {
			this.reloadSection(sectionNode, '', '', false, true, '-1', false);
		}
	},
	//ETCHASKETCH -- Added new arguments: rwPreactivities and dataTransforms
	reloadSections: function(firstString, at_sectionsTable, preActivity, preActivityParams, index, event,
		rwPreActivities, dataTransforms, declarePageParams, layouts2refresh) {
		event = (event == undefined) ? window.event : event;
		var oArgs = {
			reloadElement: at_sectionsTable,
			preActivity: preActivity,
			preActivityParams: preActivityParams,
			bFormSubmit: false,
			bSectionSubmit: true,
			pageListIndex: index,
			bDoNotSetAll: true,
			event: event,
			strReloadType: 'MultipleSections',
			sourceString: firstString,
			isPreActivityParamsEncoded: true,
			rwPreActivities: rwPreActivities,
			oDataTransform: dataTransforms,
			declarePageParams: declarePageParams,
			layouts2refresh: layouts2refresh
		};
		this.reload(oArgs);
	},
	sectionRefreshCallback: function(o) {
		var newDiv = document.createElement("div");
		newDiv.innerHTML = o.responseText;
		var returnedDivs = pega.util.Dom.getElementsById("SECGRP", newDiv, "DIV"); // Get all the divs that have sections in them
		if ((pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal()) && !returnedDivs) {
			returnedDivs = [];
			returnedDivs.push(newDiv);
		}
		var reloadElements = o.argument[0];
		var nextElementName = o.argument[2];
		if (nextElementName !== undefined && pega.u.d.focusElement && pega.u.d.focusElement.tagName && pega.u.d.focusElement.tagName.toUpperCase() !==
			"IFRAME") {
			var pos = pega.u.d.getCaretPosition(pega.u.d.focusElement);
		}
    
    var focusElementName = pega.u.d.focusElement && pega.u.d.focusElement.name;
    var focusElementTagName = pega.u.d.focusElement && pega.u.d.focusElement.tagName;
    
		var layoutRefreshDivs = false;
		/* BUG-196493, BUG-201589 :  No need to cleanup complex elements in case of dynamic layout refresh */
		if (o.argument.length == 4 && o.argument[3] && o.argument[3].length && o.argument[3].length > 0) {
			layoutRefreshDivs = o.argument[3];
		} else {
			this.cleanUpHarnessElements(null, reloadElements);
		}
		if (returnedDivs != null) {
			pega.ctx.returnedDivsCount = 0;
            /* allow lazy load processing only after adding the last section's markup;
             * stop it for all the earlier section loads
             */
			var allowLazyLoadOnlyOnce = function() {
				pega.ctx.returnedDivsCount--;
				if (pega.ctx.returnedDivsCount > 0) {
					return false;
				}
				/* here means currently the last section is being loaded. */
				setTimeout(function() {
					pega.u.d.lazyLoadManager.detachBeforeLoad(allowLazyLoadOnlyOnce);
				}, 0);
				delete pega.ctx.returnedDivsCount;
				return true;
			};
			pega.u.d.lazyLoadManager.attachBeforeLoad(allowLazyLoadOnlyOnce);
			for (var indCount = 0; indCount < returnedDivs.length; indCount++) {
				if (layoutRefreshDivs) {
					var propDivs = pega.util.Dom.getElementsByAttribute("data-refresh", "true", "DIV",
						returnedDivs[indCount])
					if (propDivs && propDivs.length > 0) {
						var propDivs = propDivs[0];
						var targetDivs;
						if (layoutRefreshDivs.length == 1) {
							targetDivs = layoutRefreshDivs[0];
						} else {
							targetDivs = layoutRefreshDivs.shift();
						}
						pega.ctx.returnedDivsCount++;
						if (propDivs.getAttribute("bsimplelayout") == "true") {
							if (!propDivs.getAttribute("data-methodname")) {
								propDivs.setAttribute("data-methodname", targetDivs.getAttribute(
									"data-methodname") || targetDivs.parentElement.getAttribute(
										"data-methodname"));
							}
							if (propDivs.getAttribute("data-expr-id")) {
								try {
								  var oldExprId = targetDivs.getAttribute("data-expr-id") || targetDivs.parentElement.getAttribute("data-expr-id");
								  if (oldExprId && oldExprId.indexOf('_') > 0) {
									  propDivs.setAttribute("data-expr-id", oldExprId);
								  }
								} catch(e) {
								    console.log('exception while setting data-expr-id on layout divs');
								}
							}
							pega.u.d.loadDOMObject(targetDivs, propDivs.innerHTML);
						} else {
							pega.u.d.loadDOMObject(targetDivs, propDivs.innerHTML);
						}
					}
				} else {
					var propDivs = pega.util.Dom.getElementsById("RULE_KEY", returnedDivs[indCount], "DIV");
					if (propDivs && propDivs.length > 0) {
						var propDivs = propDivs[0];
						var targetDivs;
            //SE-57882, BUG-524752 for mutisection refresh in offline case,reponse is set to correct reload element
            if (reloadElements.length && reloadElements.length > 1 && pega.u.d.isAppOfflineEnabled() && pega.u.d.ServerProxy.isDestinationLocal()) {
              try{
                for(var i=0; i<reloadElements.length;i++){
                  var reloadEleNodeName = reloadElements[i].getAttribute("node_name");
                  if(o.handle && typeof o.handle == "string" && reloadEleNodeName && typeof reloadEleNodeName == "string" && o.handle.toLowerCase().indexOf(reloadElements[i].getAttribute("node_name").toLowerCase()) > -1){
                    targetDivs = reloadElements[i];
                    reloadElements.splice(i, 1);
                    break;
                  }
                }
              }catch(e){
                targetDivs = reloadElements.shift();
              }
            }else{
              targetDivs = reloadElements.shift();
            }
						if (pega.u.d.checkExceptions(propDivs.innerHTML, targetDivs)) {
							pega.u.d.gBusyInd.hide();
							return;
						}
						var uniqueId = pega.u.d.getSectionId(propDivs);
						if (uniqueId && uniqueId != "" && pega.u.d.getSectionId(targetDivs) != "") {
							targetDivs.setAttribute("uniqueID", uniqueId);
						}
						/* Update BASE_REF - Start */
						var baserefDiv = pega.util.Dom.getElementsById("BASE_REF", returnedDivs[indCount], "DIV");
						if (baserefDiv && baserefDiv.length > 0) {
							var divObj = baserefDiv[0];
							var newBaseRef = divObj.getAttribute("BASE_REF");
							if (typeof newBaseRef != 'undefined' && newBaseRef != null) {
								var oldBaseRef = targetDivs.getAttribute("BASE_REF");
								if (oldBaseRef && oldBaseRef != newBaseRef) {
									targetDivs.setAttribute("BASE_REF", newBaseRef);
									targetDivs.removeAttribute("FULL_BASE_REF");
									var parentDiv = targetDivs.parentNode;
									if (parentDiv) {
										if (parentDiv.tagName && parentDiv.tagName.toLowerCase() == "div" &&
											parentDiv.id == "CT") {
											if (parentDiv.getAttribute("sec_baseRef")) {
												parentDiv.setAttribute("sec_baseRef", newBaseRef);
											}
										}
									}
								}
							}
						}

						/* Update BASE_REF - End */
						pega.ctx.returnedDivsCount++;

						pega.u.d.loadDOMObject(targetDivs, propDivs.innerHTML);
					}
				}
			}
		}
		var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", newDiv);
		if (onlyOnceEle && onlyOnceEle[0]) {
			pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
		}
		if (nextElementName !== undefined && focusElementName && focusElementTagName && focusElementTagName.toUpperCase() !== "IFRAME") {
			var focusNextElement = true;
			try {
			  var actionInQueue = pega.c.actionSequencer.getActionInQueue("runScript");
			  if (actionInQueue && actionInQueue.indexOf("AutoCompleteAG.setFocusToInput") != -1) {
				  focusNextElement = false;
			  }
			} catch(e) {
			  console.log('exception while checking runScript action in action json');
			}
			/* BUG-169932 & BUG-170614: removing auto focus to first field for touchable devices */
			if (focusNextElement && !(pega.cl && pega.cl.isTouchAble() && pega.u.d.isMobile())) {
				this.focusNextElement(nextElementName, newDiv, pos);
			}
		}
		pega.u.d.handleFormErrors(newDiv);
		pega.u.d.gBusyInd.hide();
	},
    /*
     * This internally calls removeFromMemory() for all sectionIds and sections in reloadElements
     * @Param: $Array$sectionIds - Array of section ids for which memory should be freed
     * @Param: $Array$reloadElements - Array of DOM objects(in most cases section divs). Memory is cleaned for all the sections in it, including the object.
     */
	cleanUpHarnessElements: function(sectionIds, reloadElements) {
		if (!(sectionIds && sectionIds instanceof Array)) {
			sectionIds = new Array();
		}

		for (var i = 0; i < reloadElements.length; i++) {
			var reloadElement = reloadElements[i];
			if (reloadElement) {
				var mainNodes = pega.ctx.dom.querySelectorAll("DIV[node_type='MAIN_RULE']", reloadElement),
					len = mainNodes.length,
					sectionId = reloadElement.getAttribute("uniqueID");
				if (typeof sectionId === "string") {
					sectionIds.push(sectionId);
				}
				for (var j = 0; j < len; j++) {
					var node = mainNodes[j];
					var uniqueId = node.getAttribute("uniqueID")
					if (node.id == "RULE_KEY" && uniqueId && uniqueId != "") {
						sectionIds.push(uniqueId);
					}
				}
				this.removeSmartInfoListeners && this.removeSmartInfoListeners(reloadElement);
			}
			for (var k = 0; k < sectionIds.length; k++) {
				this.removeFromMemory(sectionIds[k]);
			}
		}
	},
	reload: function(oArgs) {
		var harCtxMgr = pega.ui.HarnessContextMgr;
		// start busy logger
		pega.ui.statetracking.setAjaxPreBusy("reload");
		/*List Based Triggering Story - Autobots 6.2 - gujas - Start*/
		var repeatProperty = 'repeatProperty' in oArgs ? oArgs.repeatProperty : null;
		/*List Based Triggering Story - Autobots 6.2 - gujas - End*/
		var reloadElement = oArgs.reloadElement;
		var preActivity = 'preActivity' in oArgs ? oArgs.preActivity : '';
		var preActivityParams = 'preActivityParams' in oArgs ? oArgs.preActivityParams : '';
		var bFormSubmit = 'bFormSubmit' in oArgs ? oArgs.bFormSubmit : this.submitForm();
		var bSectionSubmit = 'bSectionSubmit' in oArgs ? oArgs.bSectionSubmit : true;
		var pageListIndex = oArgs.pageListIndex;
		var bDoNotSetAll = 'bDoNotSetAll' in oArgs ? oArgs.bDoNotSetAll : false;
		var event = oArgs.event;
		var strReloadType = oArgs.strReloadType;
		var sourceString = oArgs.sourceString;
		var declarePageParams = oArgs.declarePageParams;
		var forceAJAX = oArgs.forceAJAX;
		var isSecuredURL = false;
		var preAvtivityStaticParams = null;
		var preDTStaticParams = null;
		var preActivityParamsAll = null;
    var isRefreshSectionHasDT = false;
		if (oArgs.appendExtraQueryString && typeof (oArgs.appendExtraQueryString) === "object" &&
			oArgs.appendExtraQueryString.length == 3 && typeof (oArgs.appendExtraQueryString[0]) === "string" && oArgs.appendExtraQueryString[0].indexOf("pzuiactionzzz") === 0) {
			preAvtivityStaticParams = oArgs.appendExtraQueryString[1];
			preDTStaticParams = oArgs.appendExtraQueryString[2];
			oArgs.appendExtraQueryString = SafeURL_createFromURL(oArgs.appendExtraQueryString[0]);
			preActivityParamsAll = preActivityParams;
			isSecuredURL = true;
		}
		/* Fix for Landing Pages */
		var bKeepPageMessages = harCtxMgr.get("KeepPageMessages") ? harCtxMgr.get("KeepPageMessages") : "false";
		var pegaHarnessDiv = pega.ctx.dom.getElementById("PEGA_HARNESS");
		var domEle = reloadElement;
		/* if reloadElement is an array get domEle from it to use as argument to isAncestor */
		if (reloadElement && reloadElement.length > 0) { /* reload element can null, array or dom object */
			domEle = reloadElement[0];
		}
		/*SE-26675 / HFIX-26675 / BUG-239018 : Setting bKeepPageMessages to true if the reloadElement is not from the PEGAHARNESS div and also the portal is NoFrame Portal.*/
		if (pega.u.NavigateTopHandler && domEle && !pega.util.Dom.isAncestor(pegaHarnessDiv, domEle)) {
			bKeepPageMessages = "true";
		}

		// BUG-296506: If container is rdl-scrolllistener, reset scrollTop
		if (domEle) {
			var parentNode = domEle.parentNode;
			if ($(parentNode).hasClass("rdl-scrolllistener")) {
				parentNode.scrollTop = 0;
			}
		}

		var sectionParam = (domEle && domEle.getAttribute("data-params")) || "";
		/* Encoded pre activity parameters fetch START */
		var bIsPreActivityParamsEncoded = 'isPreActivityParamsEncoded' in oArgs ? oArgs.isPreActivityParamsEncoded :
			false;
		//ETCHASKETCH
		var rwPreActivities = oArgs.rwPreActivities;
		var oDataTransform = oArgs.oDataTransform;
		var queryString = new SafeURL();
		if (forceAJAX == undefined || forceAJAX == null) {
			forceAJAX = pega.u.d.forceAJAX;
		}
		var reloadFail = false;
		/* Variable to set when reload section is not found*/
		if (preActivity != "" && strReloadType != "RepeatLayout") bFormSubmit = false;
		if (bFormSubmit) {
			if (this.processOnBeforeSubmit() == false) {
				pega.ui.statetracking.setAjaxPreDone("reload");
				return;
			}
		}
		if (!bFormSubmit) {
			if (reloadElement == null) {
				reloadElement = pega.util.Event.getTarget(event);
			}
			if (strReloadType != 'MultipleSections' && strReloadType != "ShowSection") {
				var parentTable = this.getRepeatObject(reloadElement, true);
				var baseRef = this.getBaseRef(reloadElement);
				/* Climb up the DOM for element ID of "RULE_KEY" and node_type of "MAIN_RULE"*/
				while ((reloadElement.id != "RULE_KEY") || (reloadElement.getAttribute("node_type") !=
					"MAIN_RULE")) {
					if (reloadElement.id == "PEGA_HARNESS") {
						break;
					}
					reloadElement = reloadElement.parentNode;
					if (reloadElement == null) {
						/* If reload element is not found set the reloadFail to true to set form submit*/
						reloadFail = true;
						break;
					}
				}
				if (reloadElement && reloadElement.id != "PEGA_HARNESS" && !reloadElement.getAttribute(
					"node_name")) {
					pega.ui.statetracking.setAjaxPreDone("reload");
					return;
				}
			}
            /* RAIDV, 16/6/2011, BUG-41268  : Chart in other section disappears when tree grid is reloaded/row added/deleted and this is true for all the cases
             where partialrefresh is set as true. Partial refresh shouldn't have to process before submits. Since, chart is hidden on submit and shown on load
             by inline scripts, those never run in partial refresh.*/
			if (strReloadType != "PartialSection" && strReloadType != "Queued" && strReloadType != "partial-refresh") {
				if (this.processOnBeforeSubmit(false, reloadElement, oArgs.layouts2refresh) == false) {
					pega.ui.statetracking.setAjaxPreDone("reload");
					return;
				}
			}
			if (!this.isSafeToReload(reloadElement)) {
				pega.ui.statetracking.setAjaxPreDone("reload");
				return "unsafeToReload";
			}
			var clientEventTarget = false;
			var sectionIDList = "";
			var strUrlSF = SafeURL_createFromURL(harCtxMgr.get("url"));
			var preDTParams = "";
			if (isSecuredURL) {
				if (oDataTransform && oDataTransform.length >= 1) {
					var dtInfo = oDataTransform[0];
					if (dtInfo.indexOf("<||>") != -1) {
						dtInfo = dtInfo.substring(0, dtInfo.indexOf("<||>"));
					}
					if (dtInfo.indexOf(",") != -1) {
						var dataTransformName = dtInfo.substring(0, dtInfo.indexOf(","));
						var params = dtInfo.substring(dtInfo.indexOf(",") + 1);
						if (dataTransformName != "" && params) {
							if (pega.c.eventParser.hasTokens(params)) {params = pega.c.eventParser.replaceTokensWrapper(params, '', undefined, true);}
							var splitArr = params.split("&");
							if (splitArr && splitArr.length) {
								for (var i = 1; i <= splitArr.length; i++) {
									if (splitArr[i - 1] == '') {continue;}
									var oParam = splitArr[i - 1].split("=");
									if (preDTParams != "") {preDTParams += "&"}
									preDTParams += oParam[0] + "=" + oParam[1];
								}
							}
						}
					}
				}

				if ((oDataTransform && oDataTransform.length > 0 && !(oDataTransform.length == 1 && oDataTransform[0] == ",")) || (rwPreActivities && rwPreActivities.length > 0)) {
					var PreActivityContextPageList = "";
					var isListEmpty = true;
					var isEmptyContextAdded = false;
					if (oDataTransform) {
						for (var j = 1; j <= oDataTransform.length; j++) {
							if (oDataTransform[j - 1].indexOf("<||>") != -1) {
								var usingPage = oDataTransform[j - 1].substring(oDataTransform[j - 1].indexOf("<||>") + 4);
								if (usingPage == "" && isEmptyContextAdded) {continue;}
								PreActivityContextPageList += (isListEmpty ? "" : "|:") + (usingPage == "" ? "$NULL$" : usingPage);
								isListEmpty = false;
								if (usingPage == "") {isEmptyContextAdded = true;}
							}
						}
					} else if (rwPreActivities && rwPreActivities != "") {
						for (var preAcsCount = 0; preAcsCount < rwPreActivities.length; preAcsCount++) {
							var preActivityString = rwPreActivities[preAcsCount];
							if (preActivityString.indexOf("<||>") != -1) {
								var preActivityStringArr = preActivityString.split("<||>");
								var usingPage = preActivityStringArr[1];
								if (usingPage == "" && isEmptyContextAdded) {continue;}
								PreActivityContextPageList += (isListEmpty ? "" : "|:") + usingPage;
								isListEmpty = false;
								if (usingPage == "") {isEmptyContextAdded = true;}
							}
						}
					}
					if (PreActivityContextPageList != "") {
						strUrlSF.put("PreActivityContextPageList", PreActivityContextPageList);
					}
				}
			}
			strUrlSF.put("pyActivity", "ReloadSection");

			if (bIsPreActivityParamsEncoded) {
				strUrlSF.put("pyEncodedParameters", "true");
			}
			strUrlSF.put("pzKeepPageMessages", bKeepPageMessages);
			// send the harness name and harness class, used by personalized template grid - start
			var strPHarnessClass = pega.ctx.strHarnessClass || "";
			var strPHarnessPurpose = pega.ctx.strHarnessPurpose || "";
			strUrlSF.put("strPHarnessClass", strPHarnessClass);
			strUrlSF.put("strPHarnessPurpose", strPHarnessPurpose);
			// send the harness name and harness class, used by personalized template grid - end
			var preActList = "";
			//ETCHASKETCH -- Process preactivities and data transforms
			if (!isSecuredURL && ((oDataTransform && oDataTransform.length > 0 && !(oDataTransform.length == 1 && oDataTransform[0] == ",")) || (rwPreActivities && rwPreActivities.length > 0))) {
				preActList = "<pagedata>";
				if (oDataTransform) {
					preActList += "<dataTransforms REPEATINGTYPE=\"PageList\">";
					for (var j = 1; j <= oDataTransform.length; j++) {
						var commaIndex = oDataTransform[j - 1].indexOf(",");
						var dataTransformName = oDataTransform[j - 1];
						var params;
						if (commaIndex != -1) {
							dataTransformName = oDataTransform[j - 1].substring(0, commaIndex);
							params = oDataTransform[j - 1].substring(oDataTransform[j - 1].indexOf(",") + 1);
						}
						var ind = oDataTransform[j - 1].indexOf("<||>");
						var usingPage = "";
						if (ind != -1) {
							if (commaIndex != -1) {
								params = oDataTransform[j - 1].substring(oDataTransform[j - 1].indexOf(",") + 1,
									oDataTransform[j - 1].indexOf("<||>"));
							} else {
								dataTransformName = oDataTransform[j - 1].substring(0, ind);
							}
							usingPage = oDataTransform[j - 1].substring(ind + 4);
						}
						var bParamsBlockAdded = false;
						preActList += "<rowdata REPEATINGINDEX=\"" + j + "\"><dataTransform>" + dataTransformName +
							"</dataTransform>";
						if (params) {
							if (pega.c.eventParser.hasTokens(params)) params = pega.c.eventParser.replaceTokensWrapper(
								params, '', undefined, true);
							var splitArr = params.split("&");
							if (splitArr && splitArr.length) {
								for (var i = 1; i <= splitArr.length; i++) {
									if (splitArr[i - 1] == '') {
										continue;
									}
									if (!bParamsBlockAdded) {
										preActList += "<params REPEATINGTYPE=\"PageList\">";
										bParamsBlockAdded = true;
									}
									var oParam = splitArr[i - 1].split("=");
									preActList += "<rowdata REPEATINGINDEX=\"" + i + "\">";
									preActList += "<name>" + oParam[0] + "</name><value>" + oParam[1] + "</value>";
									preActList += "</rowdata>";
								}
								if (bParamsBlockAdded) {
									preActList += "</params>";
								}
							}
						}
						if (trim(usingPage) != '') {
							preActList += "<activityPage>" + usingPage + "</activityPage>";
						}
						preActList += "</rowdata>";
					}
					preActList += "</dataTransforms>";
				}
				if (rwPreActivities && rwPreActivities != "") {
					preActList += "<preActivities REPEATINGTYPE=\"PageList\">";
					for (var preAcsCount = 0; preAcsCount < rwPreActivities.length; preAcsCount++) { // Iterate through PreActivities
						var preActivityString = rwPreActivities[preAcsCount];
						var preActivityStringArr = preActivityString.split("<||>");
						preActList += "<rowdata REPEATINGINDEX=\"" + (preAcsCount + 1) + "\">";
						var parsedStr = preActivityStringArr[0].split(",");
						preActList += "<activity>" + parsedStr[0] + "</activity>";
						if (preActivityStringArr[1] != '') {
							preActList += "<activityPage>" + preActivityStringArr[1] + "</activityPage>";
						}
						// if page info specified, string will be activityname, activitypage, parameters
						// if page not specified, string will be activityname, parameters. In this case, process only if parameters present
						if (parsedStr.length == 3 || (parsedStr.length == 2 && parsedStr[1].indexOf('=') > -1)) {
							preActList += "<params REPEATINGTYPE=\"PageList\">";
							var paramsArr;
							if (parsedStr[1] && parsedStr[1] != '') {
								if (pega.c.eventParser.hasTokens(parsedStr[1])) parsedStr[1] = pega.c.eventParser.replaceTokensWrapper(
									parsedStr[1], '', undefined, bIsPreActivityParamsEncoded);
								paramsArr = parsedStr[1].split("&");
							}
							if (parsedStr[2] && parsedStr[2] != '') {
								if (pega.c.eventParser.hasTokens(parsedStr[2])) parsedStr[2] = pega.c.eventParser.replaceTokensWrapper(
									parsedStr[2], '', undefined, bIsPreActivityParamsEncoded);
								paramsArr = parsedStr[2].split("&");
							}
							for (var paramsCount = 0; paramsCount < paramsArr.length; paramsCount++) {
								preActList += "<rowdata REPEATINGINDEX=\"" + (paramsCount + 1) + "\">";
								var operandValsArr = paramsArr[paramsCount].split("=");
								preActList += "<name>" + operandValsArr[0] + "</name><value>" + operandValsArr[1] +
									"</value>";
								preActList += "</rowdata>";
							}
							preActList += "</params>";
						}
						preActList += "</rowdata>";
					}
					preActList += "</preActivities>";
				}
				preActList += "</pagedata>";
			}
			// preActList added to queryString later to prevent getting overridden
			if (strReloadType == 'MultipleSections') {
				var sectionLen = reloadElement.length;
				var sectionList = "";
				var containerIDList = "";
				var refreshlist = "";
        var isDeclarePagePresent = false;
				for (var i = 0; i < sectionLen; i++) {
					var reloadSection = reloadElement[i];
					if (oArgs.layouts2refresh) queryString.copy(pega.u.d.getQueryString(oArgs.layouts2refresh[i]));
					else queryString.copy(pega.u.d.getQueryString(reloadSection));
					var parentTable = this.getRepeatObject(reloadSection, true);
					var baseRef = this.getBaseRef(reloadSection);
					var declarePageName = reloadSection.getAttribute("data-declarepage");
					if (!pega.u.d.useHashDP && typeof declarePageName != 'undefined' && declarePageName != null &&
						declarePageName != "") {
						baseRef = declarePageName;
            isDeclarePagePresent = true;
					}
					var baseRefWithParams = baseRef;
					var uniqueId = reloadSection.getAttribute("uniqueid");
					if (isDeclarePagePresent && declarePageParams) {
            isDeclarePagePresent = false;
						var secDeclarePageParams = {};
						secDeclarePageParams["params"] = declarePageParams[uniqueId];
						baseRefWithParams = baseRef + "$$" + (JSON.stringify(secDeclarePageParams).replace(
							/:/g, "~~")); /*replacing : with ~~ as : is used as a separator in streamlist param, it is replaced back in ReloadSections HTML*/
					}
					strUrlSF.put("BaseReference", baseRef);
					var rowElem = pega.u.d.getRowAndEntryHandle(reloadSection);
					var rowIndex = "";
					if (rowElem && rowElem.row) {
						rowIndex = "|" + rowElem.row.getAttribute("PL_INDEX");
					}
					var layoutMethod = "";
					if (oArgs.layouts2refresh) {
						layoutMethod = "~!" + oArgs.layouts2refresh[i].getAttribute("data-methodName");
					}
					/* US-74570: START - pass refresh element relative path as part of reload request */
					var templatingStatus = "";
					var reloadElemObj = null;
					if (oArgs.layouts2refresh) {
						reloadElemObj = oArgs.layouts2refresh[i];
					} else {
						reloadElemObj = reloadSection;
					}
					if (typeof (reloadElemObj) != "undefined" && reloadElemObj != null) {
						var isTemplatized = reloadElemObj.hasAttribute("data-template") ? "Y" : "N";
						templatingStatus = ((rowIndex == "") ? "||" : "|") + "|" + isTemplatized;
					}
					/* US-74570: END */
					var secParams = reloadSection.getAttribute("data-params") || "";
					if (pega.c.eventParser.hasTokens(secParams)) {
						secParams = pega.c.eventParser.replaceTokensWrapper(secParams);
					}
					if (secParams != null) {
						secParams = secParams.replace(/:/g, "~#"); /*since : is used as separator in ReloadSections html, replacing it with ~#*/
					}
					var uniqueIdParam = "";
					if (pega.u.d.isAppOfflineEnabled() && pega.u.d.ServerProxy.isDestinationLocal()) {
						uniqueIdParam = "|" + uniqueId;
					}
					sectionList += reloadSection.getAttribute("node_name") + layoutMethod + '|' + reloadSection.getAttribute(
						"objclass") + '|' + baseRefWithParams + rowIndex + templatingStatus + uniqueIdParam +
						'|' + uniqueId + '|' + secParams + ':';
					if (reloadSection.getAttribute("readOnly") != "true") {
						var isContainerDirty = pega.u.d.isContainerDirty(reloadSection);
						if (isContainerDirty && !pega.u.d.bModalDialogOpen) pega.ctx.gSectionReloaded = isContainerDirty;
					}
					var isAdvParamSection = reloadSection.getAttribute("isAdvParamSection");
					var outerGadgetID = reloadSection.getAttribute("outerGadget");
					if (outerGadgetID) {
						var hID = pega.ctx.pzHarnessID; /* pega.ctx.dom.getElementById("pzHarnessID"); */
						strUrlSF.put("pzHarnessID", hID);
						strUrlSF.put("newSectionID", outerGadgetID);
					}
					// If the reloaded section is of type advanced param, then pass the containedSectionID
					if (isAdvParamSection) {
						sectionIDList += reloadSection.getAttribute("node_name") + '|' + reloadSection.getAttribute(
							"containedSectionID") + '|' + baseRef + ':';
					}
					// Otherwise pass the unique ID of the current section
					else {
						var refreshelements = pega.util.Dom.getElementsByAttribute("containedSectionID", "*",
							"DIV", reloadSection);
						if (refreshelements) {
							for (var j = 0; j < refreshelements.length; j++) {
								var eachcontainedsectionID = refreshelements[j].getAttribute(
									"containedSectionID");
								refreshlist += eachcontainedsectionID + ":";
							}
						}
						sectionIDList += refreshlist;
					}
				}
				queryString.copy(sourceString);
				strUrlSF.put("StreamList", sectionList);
			} else if (strReloadType == "ShowSection") {
				if (!isSecuredURL) {
					strUrlSF.put("StreamClass", "Rule-HTML-Section");
				}
				strUrlSF.put("StreamName", oArgs.streamName);
				strUrlSF.put("BaseReference", oArgs.pageName);
				strUrlSF.put("UsingPage", "true");
				if (oArgs.includedStreamName) strUrlSF.put("includedStreamName", oArgs.includedStreamName);
				if (oArgs.sectionOnly === false) strUrlSF.put("WithSubmitButton", "true");
				else strUrlSF.put("WithSubmitButton", "false");
				if (typeof (oArgs.sectionOnly) != "undefined" && oArgs.sectionOnly != null) strUrlSF.put(
					"sectionOnly", oArgs.sectionOnly);
				var sectionParams = oArgs.sectionParams;
				for (var param in sectionParams) {
					strUrlSF.put(param, sectionParams[param]);
				}
				var specialButtons = oArgs.specialButtons;
				if (specialButtons) {
					var length = specialButtons.length;
					var buttonLabels = "";
					var caption = "";
					for (var i = 0; i < length; i++) {
						caption = specialButtons[i].caption;
						if (caption && caption != "") {
							buttonLabels += caption + ",";
						}
					}
					strUrlSF.put("specialButtons", buttonLabels);
				}
			} else {
				/* 04/26/2011 GUJAS1 BUG-41018 Fix Start- If reload element is null, return false.*/
				if (reloadElement == null) {
					return false;
				}
				if (!reloadElement.getAttribute("readOnly") || reloadElement.getAttribute("readOnly") != "true") {
					//BUG-128568 : checking isADP:True for not showing dirty warning on ADP.
					if (oArgs.isADP !== "true") {
						var isContainerDirty = pega.u.d.isContainerDirty(reloadElement);
						//check if refresh section have either DT or pre-activity configured
            if(isContainerDirty && !pega.u.d.bModalDialogOpen) pega.ctx.gSectionReloaded = isContainerDirty;
					}
				}
				/* 04/26/2011 GUJAS1 BUG-41018 Fix End.*/
				var isAdvParamSection = reloadElement.getAttribute("isAdvParamSection");
				var outerGadgetID = reloadElement.getAttribute("outerGadget");
				if (outerGadgetID) {
					var hID = pega.ctx.pzHarnessID; /* pega.ctx.dom.getElementById("pzHarnessID"); */
					strUrlSF.put("pzHarnessID", hID);
					strUrlSF.put("newSectionID", outerGadgetID);
				}
				var expandRL = reloadElement.getAttribute("expandRL");
				if (expandRL) {
					strUrlSF.put("expandRL", expandRL);
				}
				var index = reloadElement.getAttribute("INDEX");
				if (index) {
					strUrlSF.put("index", index);
				}
				if (((!reloadFail) && ((reloadElement.getAttribute("objclass") == "Rule-HTML-Harness")))) { /*BUG-120243*/
					bFormSubmit = true;
				} else if (!reloadFail) {
					/* Check for the reloadElement*/
					var childElement = reloadElement.getElementsByTagName("*")[0];
					var childDisplay = "";
					if (childElement && (childElement.getAttribute("SHOW_WHEN") != null) && (childElement.getAttribute(
						"SHOW_WHEN") != "") && (reloadElement.children[0].id != null) && (reloadElement.children[
							0].tagName == "DIV")) {
						clientEventTarget = true;
						childDisplay = childElement.style.display;
					}
					// If the reloaded section is of type advanced param, then pass the containedSectionID
					if (isAdvParamSection) {
						sectionIDList = reloadElement.getAttribute("node_name") + '|' + reloadElement.getAttribute(
							"containedSectionID") + ':';
					} else { // Otherwise pass the unique ID of the current section
						var refreshlist = "";
						var refreshelements = pega.util.Dom.getElementsByAttribute("containedSectionID", "*",
							"DIV", reloadElement);
						if (refreshelements) {
							for (i = 0; i < refreshelements.length; i++) {
								var eachcontainedsectionID = refreshelements[i].getAttribute(
									"containedSectionID");
								refreshlist += eachcontainedsectionID + ":";
							}
						}
						sectionIDList = refreshlist;
					}
					var bTemplatingStatus = reloadElement.hasAttribute("data-template");
					//If it is partial refresh from non template grid then set template status to N
					if (oArgs.isNonTemplate) {
						bTemplatingStatus = false;
					}
					if (strReloadType == "Queued") {
						var lazyLoadElm = oArgs.queueParams.domElement;
						var childIndex = "";
						if (lazyLoadElm && lazyLoadElm.children[0]) {
							bTemplatingStatus = lazyLoadElm.children[0].hasAttribute("data-template");
						}
					}
					strUrlSF.put("UITemplatingStatus", bTemplatingStatus ? "Y" : "N");
					var streamName = reloadElement.getAttribute("node_name");
					if (pega.u.d.isAppOfflineEnabled() && pega.u.d.ServerProxy.isDestinationLocal()) {
						streamName = streamName + "|" + reloadElement.getAttribute("uniqueid");
					}
					strUrlSF.put("StreamName", streamName);
					strUrlSF.put("BaseReference", baseRef);
					if (bDoNotSetAll) {
						strUrlSF.put("bDoNotSetAll", "true");
					}
					if (parentTable != null && ((parentTable.getAttribute("PL_PROP") != null && typeof (
						parentTable.getAttribute("PL_PROP")) != 'undefined' && typeof (pageListIndex) !=
						'undefined') || (parentTable.getAttribute("PG_PROP") != null && typeof (
							parentTable.getAttribute("PG_PROP")) != 'undefined' && typeof (pageListIndex) !=
							'undefined'))) {
						if (parentTable.getAttribute("PL_PROP") != null) {
							strUrlSF.put("PageList", parentTable.getAttribute("PL_PROP"));
						} else {
							strUrlSF.put("PageList", parentTable.getAttribute("PG_PROP"));
						}
						/*Added the code to support the Tree Grid  for refreshing the section*/
						if (typeof (Grids) != "undefined" && Grids && (event || window.event)) {
							var grid = Grids.getActiveGrid(event);
							if (grid) {
								var target = pega.util.Event.getTarget(event);
								var container = "";
								if (target) {
									if (pega.util.Dom.isAncestor(grid.rightBodyTbl, target)) {
										container = grid.rightBodyTbl;
									} else if (pega.util.Dom.isAncestor(grid.leftBodyUL, target)) {
										container = grid.leftBodyUL;
									}
									if (container) {
										grid.selectPage(event, container);
										if (grid.getLeftRow()) {
											var propRef = pega.ui.property.toReference(grid.getLeftRow().id);
											strUrlSF.put("PageList", propRef);
											strUrlSF.put("isGridAction", "true");
										}
									}
								}
							}
						}
						strUrlSF.put("PageListIndex", pageListIndex);
					}
					if (!isSecuredURL) {
						strUrlSF.put("StreamClass", reloadElement.getAttribute("objclass"));
					}
				}
				if (strReloadType == "PartialSection") {
					/* part of a section is being reloaded; set partial refresh specific parameters in URL*/
					var partialParams = oArgs.partialParams;
					strUrlSF.put("partialRefresh", "true");
					strUrlSF.put("partialTrigger", partialParams.partialTrigger);
					strUrlSF.put("ReadOnly", oArgs.isResponseRO ? oArgs.isResponseRO : this.getReadOnlyValue(
						event) /*readOnly will be set to -1 for true or 0 for false*/);
				}
				if (strReloadType == "Queued") {
					var QParams = oArgs.queueParams;
					if ("layoutId" in QParams) {
						strUrlSF.put("lazyLoadId", QParams.layoutId);
						strUrlSF.put("RenderSingle", QParams.layoutId);
						strUrlSF.put("lazySection", strUrlSF.get("StreamName"));
						/*BUG-117389: Keep Messages can always be true for defer load cases.*/
						//pega.u.d.KeepPageMessages = "true";
						//if (pega.u.d.KeepPageMessages == "true") {
						strUrlSF.put("pzKeepPageMessages", "true");
						//}
					}
					/* show busyIndicator only after 20 minutes if lazily loading a section */
					var busyIndIntervalOriginal;
					if (pega.u.d.gBusyInd) {
						busyIndIntervalOriginal = pega.u.d.gBusyInd.busyIndInterval;
						pega.u.d.gBusyInd.busyIndInterval = 1200000;
					} else {
						busyIndIntervalOriginal = pega.u.d.busyIndInterval;
						pega.u.d.busyIndInterval = 1200000;
					}
				}
			}
			if (typeof (bClientValidation) != 'undefined') {
				strUrlSF.put("bClientValidation", bClientValidation);
			}
			if (harCtxMgr.get("fieldErrorType")) strUrlSF.put("FieldError", harCtxMgr.get("fieldErrorType"));
			if (harCtxMgr.get("formErrorType")) strUrlSF.put("FormError", harCtxMgr.get("formErrorType"));
			if (harCtxMgr.get("pyCustomError")) strUrlSF.put("pyCustomError", harCtxMgr.get("pyCustomError"));
			if (preActivity != null) {
				if (!isSecuredURL) {
					strUrlSF.put("PreActivity", preActivity);
				}
				//strUrlSF.put("ActivityParams", preActivityParams);
				if (preActivity === "ProcessAction") {
					strUrlSF.put("pxTemplateForceReload", "true");
				}
			}
            /*var nParent = reloadElement.parentNode;
             if(nParent && !nParent.getElementById && nParent.getAttribute("BASE_REF")){
             strUrlSF.put("UsingPage", "true");
             }*/
			/*After merging rulekey div and base ref div as a part of GRP-20269, the section main div contains the base reference information*/
			if (reloadElement && reloadElement.getAttribute && reloadElement.getAttribute("BASE_REF")) {
				strUrlSF.put("UsingPage", "true");
			}
			var parentTableObj = (typeof pega.u.d.getRepeatTable == 'function') ? (reloadElement.length > 0 ? pega.u.d.getRepeatTable(reloadElement[0]) : pega.u.d.getRepeatTable(reloadElement)) : null;
			if (parentTableObj != null && (parentTableObj.getAttribute("PL_PROP") != null || parentTableObj.getAttribute(
				"PG_PROP") != null)) {
				strUrlSF.put("bIsGridLayout", "true");
			}
			var responseObj;
			var newStream = "";
			busyIndText = "";
			if (strReloadType != "ShowSection") {
				if (reloadElement.length > 0) this.setBusyIndicator(reloadElement[0], oArgs.ignoreBusyIndInterval,
					oArgs.showOnlyMask);
				else this.setBusyIndicator(reloadElement, oArgs.ignoreBusyIndInterval, oArgs.showOnlyMask);
			} else {
				this.setBusyIndicator(null, oArgs.ignoreBusyIndInterval, oArgs.showOnlyMask);
			}
			var strDisplayHarnessParms = harCtxMgr.get('strDisplayHarnessParms');
			if (typeof (strDisplayHarnessParms) == 'undefined') {
				strDisplayHarnessParms = "";
				harCtxMgr.set("strDisplayHarnessParms", "");
			}
			var sectionUniqueID = "";
			if (reloadElement.length > 0) sectionUniqueID = reloadElement[0].getAttribute("uniqueID");
			else sectionUniqueID = reloadElement.getAttribute("uniqueID");
			switch (strReloadType) {
				case 'Section':
					// 12/22/2011 BUG-57792 GUJAS1 - Added null check to target.
					var nextElement,
						nextElementName = "",
						pos,
						elemValue;
					if (event != null && typeof (event.type) != "undefined") {
						nextElement = pega.util.Event.getTarget(event);
						nextElementName = nextElement && nextElement.getAttribute ? nextElement.getAttribute(
							'name') : "";
					}
					// 12/22/2011 BUG-57792 END.
					if (event != null && typeof (event.type) != "undefined" && event.type.indexOf("key") >= 0) {
						pos = pega.u.d.getCaretPosition(nextElement);
						elemValue = pega.control.PlaceHolder.getValue(nextElement);
					}
					/* US-237221: START - add static params to preActivityParamsAll  */
					if (isSecuredURL) {
						if (preAvtivityStaticParams) {
							for (paramName in preAvtivityStaticParams) {
								if (preActivityParamsAll != "") {
									preActivityParamsAll += "&";
								}
								preActivityParamsAll += paramName + "=" + preAvtivityStaticParams[paramName];
							}
						}
						if (preDTStaticParams && oDataTransform && oDataTransform.length == 1) {
							var dtInfo = oDataTransform[0];
							if (dtInfo.indexOf(",") != -1) {
								var dataTransformName = dtInfo.substring(0, dtInfo.indexOf(","));
								var params = dtInfo.substring(dtInfo.indexOf(",") + 1);
								if (dataTransformName != "" && params) {
									for (paramName in preDTStaticParams) {
										if (params != "") {
											params += "&";
										}
										params += paramName + "=" + preDTStaticParams[paramName];
									}
									oDataTransform[0] = dataTransformName + "," + params;
								}
							}
						}
					}
					/* US-237221: END */
					var callbackArgs = new Array(reloadElement, clientEventTarget, preActivity,
						(isSecuredURL ? preActivityParamsAll : preActivityParams), strDisplayHarnessParms, nextElementName, childDisplay,
						sectionUniqueID, [nextElementName, elemValue, pos], false, oArgs.successCallback,
						oDataTransform); //TASK-449847 added DT
					var callback;
					var oForm = document.forms[0];
					pega.util.Event.addListener(reloadElement, "keydown", pega.u.d.preventKeyAction);
					callback = {
						success: this.handleReloadSuccess,
						failure: this.handleReloadFail,
						scope: this,
						argument: callbackArgs
					};

					break;
				case 'RepeatLayout':
					var callbackArgs = new Array(reloadElement, clientEventTarget, preActivity,
						preActivityParams, strDisplayHarnessParms, oArgs.focusParams, childDisplay,
						sectionUniqueID, repeatProperty);
					/*repeatProperty is List Based Triggering Story - Autobots 6.2 - gujas*/
					var callback = {
						success: this.handleReloadRepeatSuccess,
						failure: this.handleReloadFail,
						scope: this,
						argument: callbackArgs
					};
					break;
				case 'ErrorSection':
					if (event != null && typeof (event.type) != "unknown") var nextElementName = pega.util.Event.getTarget(
						event).name;
					var callbackArgs = new Array(reloadElement, clientEventTarget, preActivity,
						preActivityParams, strDisplayHarnessParms, nextElementName, childDisplay,
						sectionUniqueID);
					var callback = {
						success: this.handleReloadErrorSuccess,
						failure: this.handleReloadFail,
						scope: this,
						argument: callbackArgs
					};
					break;
				case 'MultipleSections':
					var nextElement,
						nextElementName = "";
					//Fixed issue with .name on webkit -DeltaTouch
					if (event != null && typeof (event.type) != "unknown") {
						nextElement = pega.util.Event.getTarget(event);
						/* BUG-213432:Wrong element being focussed once the throbber vanishes */
						if (nextElement && nextElement.nodeName != "BUTTON" && (pega.util.Dom.hasClass(nextElement, "pzbtn-rnd") >
							-1 || pega.util.Dom.hasClass(nextElement, "pzbtn-lft") > -1 || pega.util.Dom.hasClass(
								nextElement, "pzbtn-rgt") > -1 || pega.util.Dom.hasClass(nextElement,
									"pzbtn-mid") > -1)) {
							while (nextElement.nodeName != "BUTTON") {
								nextElement = nextElement.parentNode;
								if (nextElement == null || typeof (nextElement) == "undefined") {
									nextElement = pega.util.Event.getTarget(event);
									break;
								}
							}
						}
						nextElementName = nextElement ? (nextElement.name || ((nextElement instanceof Element) && nextElement.getAttribute("name"))) : "";
					}
					callback = {
						success: this.sectionRefreshCallback,
						failure: this.handleFailure,
						argument: [reloadElement, sectionUniqueID, nextElementName, oArgs.layouts2refresh]
					};
					break;
				case 'ShowSection':
					var callback = {
						success: this.handleShowSectionSuccess,
						failure: this.handleShowSectionFail,
						scope: this,
						argument: [reloadElement, oArgs.onAfterSubmit, oArgs.onAfterCancel, oArgs.bShowAsModal,
							oArgs.streamName, oArgs.sectionOnly, sectionUniqueID, oArgs.pageName, oArgs.specialButtons,
							oArgs.displayAtClick, oArgs.includedStreamName, oArgs.sectionParams]
					};
					break;
				case 'PartialSection':
					partialParams.property = repeatProperty;
					var callbackArgs = new Array(reloadElement, "", "", "", oArgs.focusParams, "", partialParams);
					var callback = {
						success: this.handlePartialSuccess,
						failure: this.handleLoadFail,
						scope: this,
						argument: callbackArgs
					};
					if (!bSectionSubmit) {
						forceAJAX = true;
					}
					break;
				case 'Queued':
					var callbackArgs = new Array(reloadElement, "", "", "", "", "", QParams);
					var callback = {
						success: this.handlePartialSuccess,
						failure: this.handleLoadFail,
						scope: this,
						argument: callbackArgs
					};
					pega.u.d.gBusyInd.busyIndInterval = busyIndIntervalOriginal;
					busyIndIntervalOriginal = 0;
					forceAJAX = true;
					break;
				case 'partial-refresh': /* This option is added to have custom callback methods */
					var callbackArgs = new Array(oArgs.reloadElement, "", "", "", "", "", QParams, {"bOSCOPartialRefresh": pega.u.d.ServerProxy.isDestinationLocal(), "generateMetadataFn": oArgs.generateMetadataFn, "partialMetadataPath": oArgs.partialMetadataPath});
					var callback = {
						success: oArgs.callback.success,
						failure: oArgs.callback.failure,
						scope: this,
						argument: callbackArgs
					};
					if (!bSectionSubmit) {
						forceAJAX = true;
					}
					break;
			}
			if (strReloadType != 'MultipleSections') {
				/*queryString = this.getQueryString(reloadElement, true);*/
				var considerFormdata = true;
				queryString = this.getQueryString(reloadElement, false, forceAJAX, considerFormdata);
			}
			if (oArgs.appendExtraQueryString) {
				queryString.copy(oArgs.appendExtraQueryString);
			}
			if (sectionIDList != "") {
				if (queryString != "password") {
					queryString.put("SectionIDList", sectionIDList);
				}
			}
			if (queryString == "password" && forceAJAX == false) {
				bFormSubmit = true;
				/* In case of form submit, we should remove preventKeyAction listener which is for reload section */
				if (strReloadType == "Section") {
					pega.util.Event.removeListener(reloadElement, "keydown", pega.u.d.preventKeyAction);
				}
			} else if (!bFormSubmit) {

				if (strReloadType == 'MultipleSections') {
					if (reloadElement.length > 0) reloadElement = reloadElement[0];
				}
				var headerButtonIndicator = pega.util.Dom.getElementsBy(function(ele) {
					return ele.id == 'HeaderButtonSectionIndicator';
				}, 'input', reloadElement);
				if (headerButtonIndicator && headerButtonIndicator[0]) {
					strUrlSF.put('HeaderButtonSectionName', headerButtonIndicator[0].value);
				} else {
					strUrlSF.put('HeaderButtonSectionName', '-1');
				}
				/* Get the stream from the server*/
				if (!bSectionSubmit) {
					queryString = pega.u.d.getHiddenEltsAsSafeURL(reloadElement);
					if (sectionIDList != "") queryString.put("SectionIDList", sectionIDList);
				}
				if (oArgs.appendExtraQueryString) {
					queryString.copy(oArgs.appendExtraQueryString);
				}
				if (strReloadType === "Queued") {
					if (QParams.qParamsSafeURL) {
						queryString.copy(QParams.qParamsSafeURL);
					}
				}
				queryString.put("PreActivitiesList", preActList);
				if (sectionParam != null && strReloadType != 'MultipleSections') {
					if (pega.c.eventParser.hasTokens(sectionParam)) {
						sectionParam = pega.c.eventParser.replaceTokensWrapper(sectionParam);
					}
					queryString.put("sectionParam", sectionParam);
				}
				if (strReloadType != 'MultipleSections' && declarePageParams) {
					strUrlSF.put("declarePageParams", JSON.stringify(declarePageParams));
				}
				if (reloadElement && reloadElement.getAttribute("readOnly") == "true") {
					strUrlSF.put('ReadOnly', "-1");
				}
				this.preReloadEle = reloadElement;
				if (preActivity != null) {
					queryString.put("ActivityParams", preActivityParams);
				}
				if (isSecuredURL && preDTParams && preDTParams != "") {
					queryString.put("preDTParams", preDTParams);
				}
                /* ADP bound section should load from Service Queue Processing,
                 add the reload section information to service queue */
				if (strReloadType === "Queued") {
					if (typeof (QParams.adpReload) != 'undefined' && QParams.adpReload == "ADPLoad") {
						this.preReloadEle = null;
						pega.ui.statetracking.setAjaxPreDone("reload");
						return ({
							"strURLSF": strUrlSF,
							"callback": callback,
							"queryString": queryString
						});
					}
				}
				var reloadSectionOSCOHandler = {
					scope: this,
					offline: function(oURL, postData, SPCallback) {
						var secStreamName = oURL.get("StreamName");
						var secStreamList = [];
						if (!secStreamName) {
							var sList = oURL.hashtable.StreamList.split(":");
							for (var indx = 0; indx < sList.length; indx++) {
								var sname = sList[indx].substring(0, sList[indx].indexOf("|"));
								var uniqueId = sList[indx].split("|")[6];
								if (sname) {
									secStreamList.push(sname + "|" + uniqueId);
								}
							}
						} else {
							secStreamList.push(secStreamName);
						}
						for (var i = 0; i < secStreamList.length; i++) {
							var splitArr = secStreamList[i].split("|");
							var query = "div[node_name='" + splitArr[0] + "'][uniqueid='" + splitArr[1] +
								"']";
							var secDiv = pega.ctx.dom.$(query);
							if (secDiv.length > 0) {
								secDiv = secDiv[0];
								//var className = secDiv.getAttribute("pyclassname");
								var className = secDiv.getAttribute("data-offline-classkey");
								if (!className) {
									className = secDiv.getAttribute("pyclassname");
								}
								var key = className.toUpperCase() + "!" + splitArr[0].toUpperCase();
								// bug-228139; use clientstorehelper that uses rule cache
								var pyParamHash = secDiv.getAttribute("data-param-hash");
								if (pyParamHash) {
									// if the data-param-hash is available to append to the key
									key = key + "!" + pyParamHash;
								}

                                /*
                                * Set the primary context for offline cases from baseRef as metadata tree
                                * might hold packaged context which might be stale.
                                */
								if (oURL.hashtable.BaseReference) {
									pega.ui.TemplateEngine.setPrimaryContext(oURL.hashtable.BaseReference);
								}
								pega.offline.clientstorehelper.getSectionStream(null, key, SPCallback.success,
									SPCallback.failure);
							} else {
								var errorMessage = "pzpega_ui_doc_ajaxengine reloadSectionOSCOHandler: Failed to reload section " + secStreamName + " div " + secStreamList[i];
								console.error(errorMessage);
								SPCallback.failure(errorMessage);
							}
						}
					}
				};
				
        /*collate all to be removed pages registered by template components*/
        /* BUG-545781 Added a check to not execute the below code if it is not a layout refresh case
           since the below code is not written to handle layout refresh cases. Clean up of pages in case
           of layout refresh cases has to be made seperately for which currently there is no implementation */
        
				if (!oArgs.layouts2refresh && pega.u.template && pega.u.template.utility && pega.u.template.utility.pagesToRemoveMap) {
					var utility = pega.u.template.utility;
					var pagesToBeRemoved = [];
					var secID;
					if (reloadElement) {
						/*check uniqueid of section and get if it has any remove pages being added*/
						secID = reloadElement.getAttribute("uniqueid");
						if (secID && utility.pagesToRemoveMap[secID]) {
							pagesToBeRemoved.push(utility.pagesToRemoveMap[secID]);
							delete utility.pagesToRemoveMap[secID];
						}
						/*check all nested sections and get if they have any remove pages being added*/
						var childs = utility.getChildsOfSection(secID);
						var childIDsSize = childs ? childs.length : 0;
						for (var ii = 0; ii < childIDsSize; ii++) {
							var childID = childs[ii];
							if (utility.pagesToRemoveMap[childID]) {
								pagesToBeRemoved.push(utility.pagesToRemoveMap[childID]);
								delete utility.pagesToRemoveMap[childID];
								utility.removeRefsOfSection(childID);
							}
						}
						utility.prevParentOfSec = utility.getParentOfASec(secID);
						utility.removeRefsOfSection(secID);
						utility.removePageRefs(pagesToBeRemoved.toString(), pega.ctx.dom.$("#pzHarnessID").attr("value"));
						strUrlSF.put("PagesToRemove", pagesToBeRemoved.toString());
					}
				}
				//Publishing event to cache section streams
				pega.ui.EventsEmitter.publishSync(pega.u.d.BEFORE_SECTIONS_REFRESH, strUrlSF);
				/* BUG-334923: Pass the contextParams to ServerProxy doAction */
				if (isSecuredURL) {
					strUrlSF.put("isSecuredURL", "true");
				}
				this.ServerProxy.doAction(strUrlSF, queryString, reloadSectionOSCOHandler, callback, oArgs.options);
			}
		}
		/* Check for form submit enabled or reload fail cases to submit the form*/
		if ((bFormSubmit) || (reloadFail)) {
			this.submitWhenFail(preActivity, preActivityParams, strDisplayHarnessParms);
		}
		// increment busy logger
		pega.ui.statetracking.setAjaxPreDone("reload");
	},
	preventKeyAction: function(e) {
		var ev = e || window.event;
		pega.util.Event.preventDefault(ev);
	},
	reloadSectionEncoded: function(reloadElement, preActivity, preActivityParams, bFormSubmit, bSectionSubmit,
		pageListIndex, bDoNotSetAll, event, oDataTransform, queryString) {
		event = (event == undefined) ? window.event : event;
		var oArgs = {
			reloadElement: reloadElement,
			preActivity: preActivity,
			isPreActivityParamsEncoded: true,
			preActivityParams: preActivityParams,
			bFormSubmit: bFormSubmit,
			bSectionSubmit: bSectionSubmit,
			pageListIndex: pageListIndex,
			bDoNotSetAll: bDoNotSetAll,
			event: event,
			strReloadType: 'Section',
			oDataTransform: oDataTransform,
			appendExtraQueryString: queryString
		};
		this.reload(oArgs);
	},
    /*
     @public Loads the section by calling to ReloadSection activity
     This function is called when reload the section from client side. Following cases use this function.
     Refresh a section using client events
     This function will update the clipboard with currently entered values using http post data.
     @param $Object$reloadElement - Element contained in the section
     @param $String$preActivity - name of the pre processing activity to be executed before getting the section display
     @param $String$preActivityParams - activity params in the URL notation
     @param $boolean$bFormSubmit - when true submit the entire form data
     @param $boolean$bSectionSubmit - when true submit the data in the section before reload it, hidden if only hidden elements are to be submitted other wise don't submit the section data
     @param $Int$pageListIndex - index for the page list or page group subscript
     @param $boolean$bDoNotSetAll - when true set this parameter. This is so that the reload section gets the onlyonce things
     @param $Object$event - The event object
     @param $String$queryString - call parameters to be placed in body
     @param $Function$successCallback - A function to run when the section has been successfully reloaded
     @param $Object$options - an object with configurations (such as contextParams)
     @return $void$
     */
	//  reloadSection : function(reloadElement, preActivity, preActivityParams, bFormSubmit, bSectionSubmit, pageListIndex, bDoNotSetAll, event, dataTransforms) {
	reloadSection: function(reloadElement, preActivity, preActivityParams, bFormSubmit, bSectionSubmit,
		pageListIndex, bDoNotSetAll, event, oDataTransform, queryString, successCallback, options) {

		event = (event == undefined) ? window.event : event;
		var oArgs = {
			reloadElement: reloadElement,
			preActivity: preActivity,
			preActivityParams: preActivityParams,
			bFormSubmit: bFormSubmit,
			bSectionSubmit: bSectionSubmit,
			pageListIndex: pageListIndex,
			bDoNotSetAll: bDoNotSetAll,
			event: event,
			strReloadType: 'Section',
			oDataTransform: oDataTransform,
			appendExtraQueryString: queryString,
			successCallback: successCallback,
			options: options
		};
		this.reload(oArgs);
	},
	handlePartialSuccess: function(responseObj) {
		var newStream = responseObj.responseText;
		if (newStream.indexOf("ERRORTABLE") < 0) {
			if (typeof fireExpression == 'function') fireExpression();
		}
		var reloadElement = responseObj.argument[0];
		var partialParams = responseObj.argument[6];
		if (newStream.indexOf("<html>") >= 0 || (partialParams.beforeDomActionContext && newStream.indexOf(
			"PegaServErr") > 0)) {
			pega.u.d.gBusyInd.hide();
			pega.u.d.inCall = false;
			if (pega.u.d.changeInEventsArray) pega.u.d.changeInEventsArray.fire();
			return;
		}
		var strSelectUniqueID = "";
		/* BUG-160432: Changing to getAttribute for browser compatibility */
		if (typeof (reloadElement.getAttribute('uniqueID')) != "undefined") strSelectUniqueID = reloadElement.uniqueID;
		else {
			strSelectUniqueID = pega.util.Dom.generateId();
			reloadElement.setAttribute("uniqueID", strSelectUniqueID);
		}
		if (pega.u.d.checkExceptions(newStream, reloadElement)) {
			pega.u.d.inCall = false;
			if (pega.u.d.changeInEventsArray) pega.u.d.changeInEventsArray.fire();
			pega.u.d.gBusyInd.hide();
			return;
		}
		var errors = this.handleErrorAfterPartialSuccess(responseObj);
		/* if some error occured on server side which has put a message in error table in case of appending or inserting a row and a grid row is not returned then only render the errors on UI and return */
		if (errors) {
			/* some server side error ocured and message in error table is put (bokks-only for grids)*/
			if (pega.ui.grid && ((partialParams.beforeDomActionContext && partialParams.beforeDomActionContext instanceof pega
				.ui.grid || partialParams.beforeDomActionContext instanceof pega.ui.gridRowDD) || (
					partialParams.afterDomActionContext && partialParams.afterDomActionContext instanceof pega
						.ui.grid || partialParams.afterDomActionContext instanceof pega.ui.gridRowDD)) &&
				partialParams.domAction && (partialParams.domAction === "append" || partialParams.domAction ===
					"insert" || partialParams.domAction === "remove" || partialParams.domAction === "dragdrop" ||
					partialParams.domAction === "replace")) {
				/* it is append or insert case & BUG-354057- added case for editmode too  */
				if (newStream.indexOf("Row cellCont") < 0 && newStream.indexOf("editMode cellCont") < 0 && newStream.indexOf("PL_INDEX") < 0) {
					/*BUG-74949: In case of re-ordering or dragdrop, reset the DDProcessing property to false.*/
					if (pega.util.Event.isIE && partialParams.domAction === "dragdrop" && partialParams.beforeDomActionContext
						.gridObj && partialParams.beforeDomActionContext.gridObj.DDProcessing) {
						partialParams.beforeDomActionContext.gridObj.DDProcessing = false;
					}
					/* no grid row is returned */
					pega.u.d.gBusyInd.hide();
					pega.u.d.inCall = false;
					/* nullify the preReloadEle variable here before calling for the execution of the next event in the queue */
					pega.u.d.preReloadEle = null;
					if (pega.u.d.changeInEventsArray) pega.u.d.changeInEventsArray.fire();
					return;
				}
			}
		}
        /*
         * handle pegaOnlyOnce tag
         */
		var documentFragment = document.createDocumentFragment();
		var newElement = document.createElement("DIV");
		newElement.style.display = "none";
		documentFragment.appendChild(newElement);
		newElement.innerHTML = newStream;
		var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", newElement);
		if (onlyOnceEle && onlyOnceEle[0]) {
			pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
			onlyOnceEle[0].parentNode.removeChild(onlyOnceEle[0]);
		}
		newElement.innerHTML = null;
		documentFragment.removeChild(newElement);
		documentFragment = null;
		var continueLoading = true;
		var beforeDomAction = partialParams.beforeDomAction;
		var beforeDomActionContext = partialParams.beforeDomActionContext;
		if (beforeDomAction && typeof (beforeDomAction) == "function") {
			var params = partialParams.beforeParams;
			if (beforeDomActionContext) {
				if (params) continueLoading = beforeDomAction.call(beforeDomActionContext, params, responseObj);
				else continueLoading = beforeDomAction.call(beforeDomActionContext, responseObj);
			} else {
				if (params) continueLoading = beforeDomAction.call(this, params, responseObj);
				else continueLoading = beforeDomAction.call(this, responseObj);
			}
		}
		/* if continueLoading is set to boolean false then the function registered as beforeDomAction has loaded the DOM Object*/
		if (continueLoading !== false) this.loadDOMObject(reloadElement, newStream, null, partialParams);
		var afterDomAction = partialParams.afterDomAction;
		var afterDomActionContext = partialParams.afterDomActionContext
		if (afterDomAction && typeof (afterDomAction) == "function") {
			var params = partialParams.afterParams;
			if (afterDomActionContext) {
				if (params) continueLoading = afterDomAction.call(afterDomActionContext, params, responseObj);
				else continueLoading = afterDomAction.call(afterDomActionContext, responseObj);
			} else {
				if (params) afterDomAction.call(this, params, responseObj);
				else afterDomAction.call(this, responseObj);
			}
		}
		pega.u.d.gBusyInd.hide();
		pega.u.d.inCall = false;
		/* nullify the preReloadEle variable here before calling for the execution of the next event in the queue */
		pega.u.d.preReloadEle = null;
		if (pega.u.d.changeInEventsArray) pega.u.d.changeInEventsArray.fire();
		/*List Based Triggering Story - Autobots 6.2 - gujas - Start*/
		/*BUG-70538 Commented the below code as ChangeTracker takes care of refreshing*/
        /*if (partialParams.property && partialParams.property.listName) {
         pega.u.d.triggerAddDeleteRefreshSections(partialParams.property);
         }*/
		/*List Based Triggering Story - Autobots 6.2 - gujas - End*/
	},
	/*List Based Triggering Story - Autobots 6.2 - gujas - Start*/
	triggerAddDeleteRefreshSections: function(listProperty) {
		if (!listProperty) return;
		pega.u.d.temp_currentCT = pega.ui.ChangeTrackerMap.getTracker();
		var refreshTargets = pega.u.d.getRefreshableTargets("adddelete", listProperty);
		var sections = null;
		var preActivities = null;
		var dataTransforms = null;
		if (refreshTargets) {
			sections = refreshTargets.sections;
			preActivities = refreshTargets.preActivities;
			dataTransforms = refreshTargets.dataTransforms;
		}
		if (sections && sections.length > 0) {
			pega.u.d.reloadSections('', sections, null, null, null, null, preActivities, dataTransforms);
		}
	},
	/*List Based Triggering Story - Autobots 6.2 - gujas - End*/
	handleErrorAfterPartialSuccess: function(responseObj) {
		var errors = false;
		var reloadElement = (responseObj.argument && responseObj.argument[0]) || "";
		var newStream = responseObj.responseText;
		var documentFragment = document.createDocumentFragment();
		var newElement = document.createElement("DIV");
		newElement.style.display = "none";
		documentFragment.appendChild(newElement);
		/*If the response has PEGA_GRID_DELETE||DELETE_SUCCESS|| delete is successful. So, return false. BUG-46793*/
		if (newStream.indexOf("PEGA_GRID_DELETE||DELETE_SUCCESS||") != -1) {
			errors = false;
		} else {
			errors = true;
		}
		newElement.innerHTML = newStream;
		var errorTable = pega.util.Dom.getElementsById('ERRORTABLE', newElement);

		//BUG-434629 :Error messages flash on screen
		if (errorTable && pega.u.d.alwaysShowFormLevelErrors == "true") {
			this.displayFormErrors(pega.util.Dom.getOuterHTML(errorTable[0]), newElement);
			return errors;
		}
		/*Don't check for field errors for custom error section*/
		this.handleFormErrors(newElement);
		var customErrorDiv = pega.util.Dom.getElementsById('pyCustomError', newElement);
		if (customErrorDiv && customErrorDiv[0]) {
			/*customErrorMsg span is generated  only when there are messages on the page. Only in this scenario return true.*/
			var errorSpan = pega.util.Dom.getElementsById('customErrorMsg', customErrorDiv[0]);
			if (errorSpan && errorSpan[0]) {
				return errors;
			}
		}
		return false;
	},
    /*
     @protected Holds common functionality for callback success scenario.
     @param Object$responseObj - Response Object
     @return $void$
     */
	handleSuccess: function(responseObj) {
		var reloadElement = responseObj.argument[0];
		var clientEventTarget = responseObj.argument[1];
		var preActivity = responseObj.argument[2];
		var preActivityParams = responseObj.argument[3];
		var strDisplayHarnessParms = responseObj.argument[4];
		var newStream = responseObj.responseText;
		var childDisplay = responseObj.argument[6];
		/*BUG-18874 : don't proceed if the reloadElement is not present in the document */
		if (reloadElement && !pega.util.Dom.inDocument(reloadElement)) return;

		/*BUG-432813 : skip reloadHarness if ReloadElement is in header and not in targeted harness*/
		var isElemInHeader = function(element) {
			while (element && element.tagName && element.tagName.toLowerCase() != "body") {
				if (element.id == "PEGA_HARNESS")
					return false;
				if (element.tagName.toLowerCase() == "header")
					return true;
				element = element.parentNode;
			}
			return false;
		}

		/*BUG-277134:In case of templating, we may get either template or non-template content*/
		if (newStream.indexOf("MAIN_RULE") == -1 && newStream.indexOf("RULE_KEY") == -1 && newStream.indexOf(
			"data-template-instance-id") == -1 && !isElemInHeader(reloadElement)) {
			this.submitWhenFail(preActivity, preActivityParams, strDisplayHarnessParms);
		} else {
			if (pega.u.d.checkExceptions(newStream, reloadElement)) {
				pega.u.d.gBusyInd.hide();
				return;
			}
			/* Set the stream to the innerHTML of the reload element*/
			var documentFragment = document.createDocumentFragment();
			var newElement = document.createElement("DIV");
			/*BUG-5524 : orphan nodes are causing memory leaks when there are swf object in the section. Add the node to a document fragment to avoid this*/
			newElement.style.display = "none";
			documentFragment.appendChild(newElement);
            /*if(pega.util.Event.isIE)
             newElement.innerHTML = reloadElement.outerHTML;
             else{
             newDiv = reloadElement.cloneNode(true);
             newElement.appendChild(newDiv);


             var theNode = pega.util.Dom.getElementsById("RULE_KEY", newElement);
             if(theNode)
             theNode = theNode[0];
             else
             return;
             */
			var theNode = newElement;
			/* Case Decision : skip further execution */
			theNode.innerHTML = newStream;
			var newNode = pega.util.Dom.getElementsById("RULE_KEY", theNode);
			if (newNode && newNode.length > 0) newNode = newNode[0];
			else return;
			var uniqueId = pega.u.d.getSectionId(newNode);
			if (uniqueId && uniqueId != "" && pega.u.d.getSectionId(reloadElement) != "") {
				reloadElement.setAttribute("uniqueID", uniqueId);
			}
			//US-49043 - Edit at runtime. Need to preserve data-ui-meta data if it exists on the refreshed node
			//If the value on old node is different than that on the new node update the old node in DOM
			if ($(reloadElement).attr("data-ui-meta") && $(newNode).attr("data-ui-meta") && ($(reloadElement).attr(
				"data-ui-meta") != $(newNode).attr("data-ui-meta"))) {
				$(reloadElement).attr("data-ui-meta", $(newNode).attr("data-ui-meta"));
			}
			/* Case Decision : skip further execution */
			this.loadDOMObject(reloadElement, newNode.innerHTML);
            /*
             Performance change reflow issue mentioned below should be fixed in mordern browser commenting the below code for now
            BUG-114521 && BUG-118365- Content not rendering in webkit after refresh section.
             Below block is to trigger reflow in webkit to avoid such issues.

            if(pega.env.ua.webkit){
                var tempDisplay = "visible";
                tempDisplay =  window.getComputedStyle ? window.getComputedStyle(document.body, "").visibility : document.body.style.visibility;
                document.body.style.visibility = "hidden";
                document.body.offsetHeight;
                document.body.style.visibility=tempDisplay;
            }
       */
			if (clientEventTarget == true) {
				reloadElement.getElementsByTagName("*")[0].style.display = childDisplay;
			}
			/*          First check for field errors existence */
			var errorMarkers = pega.util.Dom.getElementsById("PegaRULESErrorFlag", document);
			/* Commenting out if condition for BUG-82322 */
			//if (!errorMarkers)
			//{
			this.handleFormErrors(theNode);
			if (pega.u.d.bModalDialogOpen) {
				pega.u.d.bResizeModalDlg = false;
			}
			pega.u.d.resizeHarness();
			if (pega.u.d.bModalDialogOpen) {
				pega.u.d.bResizeModalDlg = true;
			}
			//}
			var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", theNode);
			if (onlyOnceEle && onlyOnceEle[0]) {
				if (pega.util.Event.isIE)
					this.handleOnlyOnce(onlyOnceEle[0].cloneNode(true));
				else
					this.handleOnlyOnce(onlyOnceEle[0]);
			}
			documentFragment.removeChild(newElement);
			documentFragment = null;
			theNode.innerHTML = "";
			pega.util.Event.purgeElement(newElement, true);
			newElement.innerHTML = "";
		}
		//      pega.desktop.support.resizeGadget();
	},
	displayErrorsOnModal: function(strResponse) {
		var modalContentDiv = pega.util.Dom.getElementsById("modaldialog_con", document);
		if (modalContentDiv && modalContentDiv.length > 0) {
			modalContentDiv = modalContentDiv[0];
			var documentFragment = document.createDocumentFragment();
			var newElement = document.createElement("div");
			var existingErrorTable = null;
			newElement.style.display = "none";
			documentFragment.appendChild(newElement);
			newElement.innerHTML = strResponse;
			/*BUG-252858: Get the existingErrorTable based on the entire modal dialog and not from the content*/
			var modalCompleteDiv = pega.util.Dom.getElementsById("modalContent", document);
			if (modalCompleteDiv && modalCompleteDiv.length > 0) {
				modalCompleteDiv = modalCompleteDiv[0];
				existingErrorTable = pega.util.Dom.getElementsById("ERRORTABLE", modalCompleteDiv);
			}
			if (existingErrorTable && existingErrorTable.length > 0) {
				existingErrorTable = existingErrorTable[0];
				var errorMarkers = pega.util.Dom.getElementsById("PegaRULESErrorFlag", modalContentDiv);
				var errorMarkersLength = 0;
				if (errorMarkers) errorMarkersLength = errorMarkers.length;
				if (errorMarkersLength == 0) {
					pega.util.Dom.setStyle(existingErrorTable, "display", "block");
					existingErrorTable.setAttribute("aria-hidden", "false");
				}
				var errorSpan = pega.util.Dom.getElementsById("ERRORMESSAGES_ALL", existingErrorTable);
				if (errorSpan && errorSpan.length > 0) {
					var msgSpan = pega.util.Dom.getElementsById("ERRORMESSAGES_ALL", newElement);
					if (msgSpan && msgSpan.length > 0) {
						errorSpan[0].innerHTML = msgSpan[0].innerHTML;
					} else {
						errorSpan[0].innerHTML = strResponse;
					}
				}
			} else {
				/*US-74327:Updated newActionSection variable to get from siblings of ModalDialog_hd and append error div as first child.*/
				var newActionSection = $("#modaldialog_hd").siblings();
				if (newActionSection.length == 0) {
					newActionSection = $("#modaldialog_con");
				}
				var currentErrorTable = pega.util.Dom.getElementsById("ERRORTABLE", newElement);
				if (currentErrorTable && currentErrorTable.length > 0) {
					var errorMarkers = pega.util.Dom.getElementsById("PegaRULESErrorFlag", modalContentDiv);
					var errorMarkersLength = 0;
					if (errorMarkers) errorMarkersLength = errorMarkers.length;
					if (errorMarkersLength == 0 || pega.u.d.alwaysShowFormLevelErrors == "true") {
						pega.util.Dom.setStyle(currentErrorTable[0], "display", "block");
						currentErrorTable[0].setAttribute("aria-hidden", "false");
					}
					newActionSection[0].insertBefore(currentErrorTable[0], newActionSection[0].firstChild);
				}
			}
			newElement.innerHTML = null;
			documentFragment.removeChild(newElement);
			documentFragment = null;
      /* Focus first field in modal dialog if error table is displayed */
      var modalOverlay = document.getElementById("modalOverlay");
      var tablesInModal = modalOverlay.querySelectorAll("table")
      var isErrorTableDisplayed = false;
      for(var i=0; i<tablesInModal.length; i++) {
        if(tablesInModal[i].getAttribute("id") === "ERRORTABLE") {
          isErrorTableDisplayed = true;
          break;
        }
      }
      if(isErrorTableDisplayed) {
        var input = modalOverlay.querySelector("input");
        input && input.focus() ;
      }
		}
	},
	handleFormErrors: function(theNode) {
		/*US-74327 : Removed pega.u.d.bIsFlowInModal check as errors should be shown on both type of Modal Dialogs(MD) i.e. MD launched from Flow in modal dialog and Launch Local Action/open Local Action actions*/
		if (this.formErrorType == "NONE") {
			this.updateErrorSection(theNode);
		}
		/* Display errors */
		var errorMarkers = pega.ctx.dom.querySelectorAll("#PegaRULESErrorFlag");
		var errorMarkersLength = 0;
		if (errorMarkers) errorMarkersLength = errorMarkers.length;
		var errorNode = pega.util.Dom.getElementsById("ERRORTABLE", theNode);
		//pega.u.d.alwaysShowFormLevelErrors != "true" && errorMarkersLength > 0
		if (pega.u.d.bModalDialogOpen == true && errorNode) {
			var errorMessage = $(errorNode[0]).find("#ERRORMESSAGES_ALL")[0];
			if (errorMessage && errorMessage.children && errorMessage.children.length > 0 && (errorMarkersLength == 0 || pega.u.d.alwaysShowFormLevelErrors == "true")) {
				pega.u.d.displayErrorsOnModal(pega.util.Dom.getOuterHTML(errorNode[0]));
			}
		} else if ((errorNode && errorMarkersLength == 0) || (errorNode && pega.u.d.alwaysShowFormLevelErrors ==
			"true")) {
			this.displayFormErrors(pega.util.Dom.getOuterHTML(errorNode[0]));
		} else {
			var errorNodeLookup = pega.ctx.dom.querySelectorAll("#ERRORTABLE");
			// Do not remove error page, if the refresh triggered in offline.
			if (errorNodeLookup != null && !$(errorNodeLookup).hasClass("offlineerror")) {
				var errorNodeLookupLen = errorNodeLookup.length;
				for (var i = 0; i < errorNodeLookupLen; i++) {
					var isToHideErrorTable = !(pega.u.d.bModalDialogOpen && pega.util.Dom.isAncestor(pega.u.d.modalDialog.body, errorNodeLookup[i]) && !pega.util.Dom.isAncestor(pega.u.d.modalDialog.body, pega.u.d.preReloadEle));
					if (isToHideErrorTable) {
						errorNodeLookup[i].style.display = "none";
						errorNodeLookup[i].setAttribute("aria-hidden", "true");
					}
				}
			}
		}
		if (window.LayoutGroupModule) {
			LayoutGroupModule.checkForErrors();
		}
	},
	handleOnlyOnce: function(onlyOnceEle) {
		/* update client-side onceonly list moved from inline US-135506 */
		try {
			if (onlyOnceEle) {
				var data = onlyOnceEle.getAttribute("data-json")
				if (data && data.length > 0) {
					var obj1 = JSON.parse(data);
					if (obj1 && obj1 != null) {
						if (!pega.ui.onlyOnce) pega.ui.onlyOnce = new OnlyOnceMgr();
						pega.ui.onlyOnce.mergeNewNames(obj1);
					}
				}
			}
		} catch (e) {}
	},
    /*
     @protected Call back function to handle the reload section success
     @param Object$responseObj - Response Object
     @return $void$
     */
	removeFromMemory: function(sectionUniqueID) {
		var tempArray = this.harnessElements.slice();
		var heLength = tempArray.length;
		var removableElements = []; //BUG-242013 (HFix-27001) fix
		//BUG-377044 : memory leake fix - removing detached elements from validation array
		var sectionDIV = pega.ctx.dom.querySelector('div[uniqueid="' + sectionUniqueID + '"]');
		if (sectionDIV) {
			// BUG-430486 : Unset the focused element if it was within the section that is being clened up
			if (pega.u.d.focusElement instanceof Node && sectionDIV.contains(pega.u.d.focusElement)) {
				pega.u.d.focusElement = {};
			}
			var elementsForValidation = sectionDIV.querySelectorAll('[validationtype]');
			elementsForValidation = Array.prototype.slice.call(elementsForValidation);
			if (elementsForValidation && elementsForValidation.length > 0) {
				validationElements = validationElements.filter(function(element) {
					return elementsForValidation.indexOf(element) < 0;
				});
			}
		}
		var originalCtx = pega.ctx;
		for (var i = 0; i < heLength; i++) {
			var complexObject = tempArray[i];
			if (complexObject.sectionID == sectionUniqueID) {
				var currentCtx = pega.ctxmgr.getContextByTarget(document.querySelector('div[uniqueid="' + sectionUniqueID + '"]'));
				pega.ctxmgr.setContext(currentCtx);
				if (complexObject.element && complexObject.element.nullify) complexObject.element.nullify(pega.ctx.bIsDCSPA ? true : false);
				/*BUG-242013 (HFix-27001) fix start*/
				//this.harnessElements.splice(i, 1);
				removableElements.push(i);
				/*BUG-242013 (HFix-27001) fix end*/
				// Bug-85065: don't dereference complexObject.element.x if complexObject.element is undefined
				if (complexObject.element) {
					pega.u.d.detachOnload(complexObject.element.onLoad);
					for (var j = 0; j < pega.u.d.onSubmits.length; j++) {
						if (pega.u.d.onSubmits[j] == complexObject.element.onBeforeSubmit && complexObject.element ==
							pega.u.d.contextObjects[j]) {
							pega.u.d.onSubmits.splice(j, 1);
							pega.u.d.contextObjects.splice(j, 1);
							pega.u.d.gSubmitIdx--;
						}
					}
				}
				complexObject.element = null;
				complexObject = null;
			}
			pega.ctxmgr.resetContext(originalCtx);
		}
		/*BUG-242013 (HFix-27001) fix start*/
		for (var i = removableElements.length - 1; i >= 0; i--) {
			this.harnessElements.splice(removableElements[i], 1);
		} /*BUG-242013 (HFix-27001) fix end*/
		tempArray = null;
	},
    /*
     @protected Call back function to handle the reload section success
     @param Object$responseObj - Response Object
     @return $void$
     */
	handleReloadSuccess: function(responseObj) {
		if (responseObj && responseObj.argument && responseObj.argument[0]) {
			pega.util.Event.removeListener(responseObj.argument[0], "keydown", pega.u.d.preventKeyAction);
		}
		if (responseObj.responseText != "CancelReloadSection") {
			var sectionUniqueID = responseObj.argument[7];
			var reloadElement = responseObj.argument[0];
			this.cleanUpHarnessElements([sectionUniqueID], [reloadElement]);
			var prevElemName,
				prevValue,
				prevCurPos;
			if (responseObj.argument[8]) {
				prevElemName = responseObj.argument[8][0];
				prevValue = responseObj.argument[8][1];
				prevCurPos = responseObj.argument[8][2];
			}
			var reloadElement = responseObj.argument[0];
			var nextElementName = responseObj.argument[5];
			// Get a handle on the successCallback function passed into reloadSection
			var sucessCallback = responseObj.argument[10];
			if (typeof (prevValue) !== "string") {
				this.handleSuccess(responseObj);
				/* BUG-169932 & BUG-170614: removing auto focus to first field for touchable devices */
				if (!(pega.cl && pega.cl.isTouchAble() && pega.u.d.isMobile())) {
					this.focusNextElement(nextElementName, reloadElement);
				}
			} else {
				/*if(prevValue ===  pega.control.PlaceHolder.getValue(document.getElementsByName(prevElemName)[0])) {*/
				if (prevElemName !== pega.u.d.focusElement.name) {
					prevElemName = pega.u.d.focusElement.name;
					prevCurPos = undefined;
				}
				this.handleSuccess(responseObj);
				/* BUG-169932 & BUG-170614: removing auto focus to first field for touchable devices */
				if (!(pega.cl && pega.cl.isTouchAble() && pega.u.d.isMobile())) {
					var sourceElem = prevElemName && pega.ctx.dom.getElementsByName(prevElemName);
					if (sourceElem && sourceElem[0]) {
						if (pega.util.Dom.isAncestor(reloadElement, sourceElem[0])) {
							this.focusNextElement(prevElemName, reloadElement, prevCurPos);
						}
					} else {
						this.focusNextElement(nextElementName, reloadElement);
					}
				}
				/*}*/
			}
			if (responseObj.argument[9]) {
				pega.control.PlaceHolder.addPlaceHolderValues(document.forms[0]);
			}
			if (typeof checkContainersExpanded == "function") {
				/* Fix for BUG-48382: call checkContainersExpanded on refresh to ensure icons are consistently displayed */
				checkContainersExpanded();
			}
			/* end of fix */
			// If a success callback function has been defined then fire it now
			if (sucessCallback != null) {
				sucessCallback();
			}
		}
		pega.u.d.gBusyInd.hide();
		//On every "Refresh This Section" client-event, apply conditions is implicitly called
		var clientEvntAPICntxt = pega.u.d.ClientEventAPI;
		if (clientEvntAPICntxt && clientEvntAPICntxt.src && clientEvntAPICntxt.src.name && clientEvntAPICntxt.isClientEvent) {
			//In case of refresh-section (which has implicit apply-coditions) on a repeating layout, the following code would ensure
			//that this.src (this = ClientEventAPI) has the fresh DOM object of the element after refresh.
			var newDomEle = pega.ctx.dom.getElementsByName(clientEvntAPICntxt.src.name);
			var i = 0;
			if (newDomEle) {
				var newEleLength = newDomEle.length;
				while (i < newEleLength) {
					if (clientEvntAPICntxt.src.type == "radio") {
						if (newDomEle[i].id == clientEvntAPICntxt.src.id && (newDomEle[i].CHECKED || newDomEle[i]
							.checked)) {
							break;
						}
					} else if (newDomEle[i].getAttribute('PN')) {
						break;
					}
					i++;
				}
				if (i < newEleLength) {
					var target = null;

					if (newDomEle[i] && newDomEle[i].name) {
						target = pega.u.property.toReference(newDomEle[i].name);
					}

					pega.u.d.evaluateClientConditions('ELEM', target, undefined, undefined, newDomEle[i]);
				}
			}
		}
	},
    /*
     @protected Call back function to handle the reload-error-section success
     @param Object$responseObj - Response Object
     @return $void$
     */
	handleReloadErrorSuccess: function(responseObj) {
		this.handleSuccess(responseObj);
		pega.u.d.gBusyInd.hide();
	},
    /*
     @protected Call back function to handle the reload section fail
     @param Object$responseObj - Response Object
     @return $void$
     */
	handleReloadFail: function(responseObj) {
		if (responseObj && responseObj.argument && responseObj.argument[0]) {
			pega.util.Event.removeListener(responseObj.argument[0], "keydown", pega.u.d.preventKeyAction);
		} else {
			pega.util.Event.removeListener(pega.u.d.getSectionDiv(pega.u.d.focusElement), "keydown", pega.u.d.preventKeyAction);
		}
		if (responseObj.responseText != undefined) {
			var preActivity = responseObj.argument[2];
			var preActivityParams = responseObj.argument[3];
			var strDisplayHarnessParms = responseObj.argument[4];
			this.submitWhenFail(preActivity, preActivityParams, strDisplayHarnessParms);
		}
		pega.u.d.gBusyInd.hide();
	},
    /*
     @protected Call back function to handle the repeat reload section success
     @param Object$responseObj - Response Object
     @return $void$
     */
	handleReloadRepeatSuccess: function(responseObj) {
		this.handleSuccess(responseObj);
		var reloadElement = responseObj.argument[0];
		var strPreActivity = responseObj.argument[2];
		if (responseObj.argument[5]) {
			/*in case of Drag and drop   sequoia grid column repeat doesnt pass 5 th argument */
			var PageListProperty = responseObj.argument[5][0];
			var indexInList = responseObj.argument[5][1];
			this.getFocusOnNewRow(PageListProperty, indexInList, reloadElement);
		}
		pega.u.d.gBusyInd.hide();
		/*List Based Triggering Story - Autobots 6.2 - gujas - Start*/
		/*BUG-70538 Commented the below code as ChangeTracker takes care of refreshing*/
        /*var property = responseObj.argument[8];
         if (property && property.listName) {
         pega.u.d.triggerAddDeleteRefreshSections(property);
         }*/
		/*List Based Triggering Story - Autobots 6.2 - gujas - End*/
	},
    /*
     @protected- This function is used to replace the object with the new stream.
     @param $Object$domObj - The DOM object to be replaced. This function is used in
     Load Defer Container
     Load Tabbed Container
     Refresh section
     @param $String$newHTML - New HTML from the server
     @return $void$
     */
	loadDOMObject: function(domObj, newHTML, callback, partialParams) {
		// flag performance measurement
		pega.ui.statetracking.setAjaxPostBusy("loadDOMObject");
		if (!callback) {
			callback = pega.u.d.loadHTMLEleCallback;
		}
		/* check if a dom script loading is in progres. If yes, wait for some time and try again */
		if (pega.u.d.gIsScriptsLoading == true) {
			pega.ui.statetracking.setCallbackPending("loadDOMObject200");
			if (pega.c && pega.c.actionSequencer) {
				pega.c.actionSequencer.pause();
			}
			var newPartialParams = new Object();
			/* BUG-75126: Check whether partialParams variable has some properties or not. If not make newPartialParams to null.*/
			var i = 0;
			for (var prop in partialParams) {
				newPartialParams[prop] = partialParams[prop];
				i++;
			}
			if (!i) {
				newPartialParams = null;
			}
			setTimeout(function() {
				pega.u.d.loadDOMObject(domObj, newHTML, callback, newPartialParams);
				pega.ui.statetracking.setCallbackDone("loadDOMObject200");
			}, 200);
		} else {
			var objDOMLoader = new DOMScriptLoader();
			pega.u.d.gIsScriptsLoading = true;
			objDOMLoader.loadHTMLElement(domObj, newHTML, callback, partialParams);
		}
		pega.ui.statetracking.setAjaxPostDone("loadDOMObject");
		/* BUG-421614 *//* BUG-553558 */                                                                                                                                                         
		if (pega.ctx.isUITemplatized && typeof LayoutGroupModule != "undefined" && newHTML && 
        (typeof (newHTML) == "string" && newHTML.indexOf("content-layout-group") != -1 || typeof (newHTML) == "object" && newHTML.querySelectorAll(".content-layout-group").length > 0)
       ){
			LayoutGroupModule.updateStretchTabWidths();
      LayoutGroupModule.checkForErrors(true);
		}
	},
	loadHTMLEleCallback: function(domObj, isHarness) {
		if (pega.u.d.modalDialog && pega.u.d.modalDialog.Header) {
			pega.u.d.modalDialog.setHeader(pega.u.d.modalDialog.Header);
		}
		var $domObj = $(domObj);
		var $domObjFirstChild = $domObj.children().eq(0);
		/* bug-195424 delete the error table from the dynamic layout after updating page messages. */
		if ($domObjFirstChild.attr('bsimplelayout') == 'true') {
			$domObj.find('.error-table').eq(0).remove();
		}
		if (domObj && domObj.id != "PegaOnlyOnce") {
			/* pega.u.d callresizeharness variable is set to false   in modalDialogcallback()  to avoid  resizeharness call when opening a modal dialog */
			if (pega.u.d.callResizeHarness) {
				pega.u.d.HeavyOperations.registerOnceOnInit("resizeHarness");
			}
			/*moved process onloads here from the top to avoid multiple calls to resize harness. Registering resizeHarness in heavyOperations avoids multiple calls to resize harness.*/
			if (pega.c && pega.c.t) pega.c.t.processControlTemplates(domObj);

			if (isHarness === true) {
				pega.u.d.processOnHarnessloads(domObj);
				//BUG-491075 : if AC case then skip focus first input.
				if (pega.u.HarnessContextMgr.get('bIsDCSPA') && !pega.ctx.isMDC) {
					pega.u.d.initFocusOnFirstInput();
				}
        if(!pega.u.d.modalDialog) {
          pega.u.d.focusHeaderOfNavigationharness();
        }
			} else {
				pega.u.d.processOnloads(domObj);
			}
		}
		// Clear out global lists of fragments
		if (pega.tools.EvalDomUtils_globals.objDocFragElemDOM) {
			pega.tools.EvalDomUtils_globals.objDocFragElemDOM = null;
		}

		if (pega.tools.EvalDomUtils_globals.objDocFragDOM) {
			pega.tools.EvalDomUtils_globals.objDocFragDOM = null;
		}

		if (pega.tools.EvalDomUtils_globals.orgDomObj) {
			pega.tools.EvalDomUtils_globals.orgDomObj = null;
		}
		pega.u.d.gIsScriptsLoading = false;
		if (pega.c && pega.c.actionSequencer && !pega.u.d.isAjaxInProgress()) {
			pega.c.actionSequencer.resume();
		}
		/*BUG-290587 height calculation in Nested Layout-Group after defer-load*/
		if (typeof (LayoutGroupModule) != "undefined") {
			var layoutgroup = $(domObj).closest("[data-lg-id]");
			if (layoutgroup.length != 0 && layoutgroup.hasClass("tab-overflow")) LayoutGroupModule.updateLayoutHeight(layoutgroup, 1);
		}
		/*Commented this code as it is giving 2000ms delay. Refer to Eng-670*/
        /*      if(pega.env.ua.ie==6){
         setTimeout(function(){pega.u.d.gIsScriptsLoading = false;},2000);
         }
         else{
         pega.u.d.gIsScriptsLoading = false;
         }*/
	},
	getElementFromCell: function(ctDiv) {
		var retElem = null;
		var inputTypes = new Array("input", "select");
		for (var i = 0; i < inputTypes.length; i++) {
			var inputElementArray = ctDiv.getElementsByTagName(inputTypes[i]);
			for (var j = 0; j < inputElementArray.length; j++) {
				if (inputElementArray[j].name) {
					retElem = inputElementArray[j];
					break;
				}
			}
			if (retElem != null) break;
		}
		return retElem;
	},
	getTemplateElemFromCell: function(ctDiv) {
		var retElem = {};
		var inputTypes = new Array("input", "select");
		for (var i = 0; i < inputTypes.length; i++) {
			var inputElementArray = ctDiv.getElementsByTagName(inputTypes[i]);
			for (var j = 0; j < inputElementArray.length; j++) {
				if (inputElementArray[j].type && inputElementArray[j].type.toLowerCase() == "radio") {
					retElem.elem = ctDiv.children[0];
					retElem.elemName = inputElementArray[j].name;
					break;
				} else if (inputElementArray[j].name) {
					retElem.elem = inputElementArray[j];
					retElem.elemName = inputElementArray[j].name;
					break;
				}
			}
			if (retElem.elem && retElem.elemName) break;
		}
		return retElem;
	},
	reloadCellsOSCO: function(refreshTargets) {
		var ctDivs = refreshTargets.cells2refresh;
		if (!ctDivs) return;
		for (var i = 0, l = ctDivs.length; i < l; i++) {
			try {
				var elemObj = pega.u.d.getTemplateElemFromCell(ctDivs[i]);
				var asynRenderCallback = function() {
					return function(markup) {
						$(elemObj.elem).replaceWith(markup);
					}
				}();
				var metadataPage = pega.ui.controlMetadataMapper.getTemplatePage(elemObj.elemName);
				if (metadataPage.pxCurrentContext) {
					pega.ui.TemplateEngine.getCurrentContext().push(metadataPage.pxCurrentContext);
				}
				var tRenderer = pega.ui.template.RenderingEngine.getRenderer(metadataPage.pyName);
				var newHTML = tRenderer(metadataPage, true, asynRenderCallback);
				if (newHTML != "$asyncRendered$WithLoadingMessage") {
					$(elemObj.elem).replaceWith(newHTML);
				}
				if (metadataPage.pxCurrentContext) {
					pega.ui.TemplateEngine.getCurrentContext().pop();
				}
			} catch (e) {
				console && console.log("Error encountered while refreshing cell : " + e.message);
			}
		}
	},
	reloadCells: function(refreshTargets) {
		if (pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal()) {
			pega.u.d.reloadCellsOSCO(refreshTargets);
			return;
		}
		var ctDivs = refreshTargets.cells2refresh;
		var sections = refreshTargets.sections;
		var strUrlSF = SafeURL_createFromURL(pega.ui.HarnessContextMgr.getCurrentHarnessContext().getProperty("url"));
		strUrlSF.put("pyActivity", "pzReloadCells");
		if (bClientValidation) {
			strUrlSF.put("PVClientVal", true);
		}
		if (!ctDivs || !sections) return;
		var data = {
			"cells": [],
			"values": []
		};
		var originalValues = {};
		var dummyObj = {};
		var propCTDivMap = {}
		for (var i = 0, l = ctDivs.length; i < l; i++) {
			var elem = pega.u.d.getElementFromCell(ctDivs[i]);
			/* This function need to be implemented for radiobutton as well*/
			var propEntryHandle = elem.name;
			var propValue = pega.u.d.getProperty(propEntryHandle);
			var baseRef = pega.u.d.getBaseRef(elem);
			var sectionName = sections[i].getAttribute("node_name");
			var contextPage = pega.u.d.getRowAndEntryHandle(elem).rowEntryHandle;
			if (contextPage == null) {
				contextPage = "";
			}
			propCTDivMap[propEntryHandle] = ctDivs[i];
			var cellID = ctDivs[i].getAttribute("cellid");
			var templateNode = ctDivs[i].querySelector('[data-template]');
			data.cells.push({
				"pyPropertyTarget": propEntryHandle,
				"StreamName": sectionName,
				"BaseReference": baseRef,
				"ContextPage": pega.u.property.toReference(contextPage),
				"UITemplatingStatus": templateNode ? "Y" : "N",
				"CellId": cellID
			});
			data.values.push({
				"entryHandle": propEntryHandle,
				"value": propValue
			});
			originalValues[propEntryHandle] = propValue;
			dummyObj[propEntryHandle] = 1;
			var fullProps = ctDivs[i].getAttribute("FULLPROPS");
			if (fullProps) {
				var propsArray = fullProps.split(",");
				for (var j = 0; j < propsArray.length; j++) {
					var propHandle = pega.u.property.toHandle(propsArray[j]);
					if (!(propHandle in dummyObj)) {
						var propVal = pega.u.d.getProperty(propHandle);
						if (propVal === undefined) {
							propVal = pega.u.d.temp_currentCT.getPropertyValue(pega.u.property.toReference(
								propHandle));
						}
						data.values.push({
							"entryHandle": propHandle,
							"value": propVal
						});
						dummyObj[propHandle] = 1;
					}
				}
			}
		}
		strUrlSF.put("reloadCells", JSON.stringify(data));
		dummyObj = undefined;
		var onSuccess = function(responseObj) {
			// Implement handling response here.
			// We should handle change tracker here.
			// Also remove AJAXCT div from the return markup
			var reponseText = responseObj.responseText;
			reponseText = reponseText.substring(0, reponseText.lastIndexOf("{EndReloadCell}"));
			var markupObj = JSON.parse(reponseText);
			for (var key in markupObj) {
				var markup = markupObj[key];
				var ctDiv = propCTDivMap[key];
				if (pega.util.Dom.inDocument(ctDiv)) {
					var cellNode = ctDiv.parentNode;

					var uiRenderedCallback = function(cellNode) {
						return function(htmlmarkup) {
							pega.u.d.loadDOMObject(cellNode, htmlmarkup);
							// BUG-216840: Validate cell content on reload
							/*  if (typeof(bClientValidation) != "undefined" && bClientValidation && (typeof(
									  validation_validate) == "function")) {
								  validation_validate(cellNode);
							  } */
						}
					};

					pega.ui.TemplateEngine.renderUI(markup, uiRenderedCallback(cellNode));
				} else {
					return;
				}
				if (originalValues[key] != pega.u.d.getProperty(key)) {
					if (pega.control && pega.control.actionSequencer) {
						var targetElem = pega.u.d.getElementFromCell(cellNode);
						if (pega.env.ua.ie) {
							pega.util.Event.fireEvent(targetElem, "onfocusin");
						} else {
							pega.util.Event.fireEvent(targetElem, "onfocus");
						}
						pega.control.actionSequencer.fireTopPriorityEvent(targetElem, "change");
						pega.util.Event.fireEvent(targetElem, "onblur");
						if (pega.env.ua.ie) {
							pega.util.Event.fireEvent(targetElem, "onfocusout");
						}
					}
				}
			}
		}
		var onFailure = function(response) {
			//silently fail for now
		};
		var callBack = {
			success: onSuccess,
			failure: onFailure
		};
		pega.u.d.asyncRequest('POST', strUrlSF, callBack);
	},
    /*
     *  sends AJAX request to get partial section.
     *  param partialParams : the object with key:value pairs to set partialTrigger value and
     *      to override default action to be taken on the AJAX response received.
     *      passed on to handlePartialSuccess and evalDOMScripts API's.
     *      major keys are :
     *          1. partialTrigger : required String value to be sent to server signalling the trigger of this partial refresh
     *          2. domElement : the descendant HTML element of section on which current domAction has to be performed
     *          3. domAction : the dom action to be performed on the domElement other than the default action of setting innerHTML
     *              possible String values -
     *                  1. remove : removes domElement from the DOM; AJAX response still has to be atleast an empty String
     *                  2. replace : replaces domElement by the firstChild of the AJAX response
     *                  3. insert : inserts firstChild of the AJAX response before domElement
     *                  4. append : appends firstChild of the AJAX response as child of domElement
     *          4. beforeDomAction : a function registered to be invoked by handlePartialSuccess before taking the domAction
     *          5. beforParams : the parameter array to be passed to the function registered to be invoked beforeDomAction
     *          6. afterDomAction : a function registered to be invoked by handlePartialSuccess before taking the domAction
     *          7. afterParams : the parameter array to be passed to the function registered to be invoked afterDomAction
     *          8. sendSectionData : set to String value "true" if want to send the form data in the section to server by preparing the query string else if value is hidden, Hidden values will be sent
     */
	refreshPartial: function(oArgs, partialParams) {
		oArgs.strReloadType = "PartialSection";
		oArgs.partialParams = partialParams;
		oArgs.bSectionSubmit = (partialParams.sendSectionData === "true");
		if (partialParams.appendExtraQueryString) {
			oArgs.appendExtraQueryString = partialParams.appendExtraQueryString;
		}
		this.reload(oArgs);
	},
	getFormData: function() {
		var formData = new FormData();
		formData.put = FormData.prototype.append;
		formData.copy = SafeURL.prototype.copy;
		formData.get = formData.get || function() {};/*BUG-484175 Added polyfill as formdata.get method is unavialable in IE*/
		return formData;
	},
    /*
     @protected Get Base Reference
     This function is used to get the query string based on the elements in the reloadElement
     @param $Object$reloadElement - Element to get the query string
     @param considerFormdata - to submit the file as formdata
     @return $String$
     */
	getQueryString: function(reloadElement, bSubmitForPassword, forceAJAX, considerFormdata) {
		if (reloadElement) {

			var elementList = this.stripOutMDCFieldSets(reloadElement);

			var queryString = '';
			var hasFile = ((considerFormdata || pega.u.d.bModalDialogOpen) && pega.ctx.hasFile());
			var queryStrURL = hasFile ? this.getFormData() : new SafeURL();
			var selValueObj = null;
			if (typeof (forceAJAX) == 'undefined') {
				forceAJAX = false;
			}

			for (var j = 0; j < elementList.length; j++) {
				var elementName = elementList[j].name;
				if (elementList[j].type == "radio") {
					if (elementList[j].checked) {
						queryStrURL.put(elementName, elementList[j].value);
					}
				} else if (elementList[j].type == "checkbox") {/*Set checkbox value as string in case of offline as well BUG-362501*/
					queryStrURL.put(elementName, elementList[j].checked.toString());
				} else if (elementList[j].type == "select-one") {
					if (elementList[j].length > 0 && elementList[j].selectedIndex != -1) {
						var elemSelected = elementList[j].options[elementList[j].selectedIndex];
						var elemValue = pega.util.Dom.getInnerText(elemSelected);
						selValueObj = elementList[j].options[elementList[j].selectedIndex].getAttributeNode(
							"value");
						if (selValueObj != null && selValueObj.specified) elemValue = elemSelected.value;
						queryStrURL.put(elementName, elemValue);
					}
				} else if ((elementList[j].type == "text" || elementList[j].type == "hidden") && (elementList[j].getAttribute("data-ctl") == '["DatePicker"]' || elementList[j].getAttribute("data-ctl") == '["DateRange"]')) {
					var elemValue = elementList[j].value;
					if (elemValue && pega.u.d.isAppOfflineEnabled() && pega.u.d.ServerProxy.isDestinationLocal() &&
						(isNaN(elemValue) && elemValue.indexOf("GMT") == -1)) {
						var spanEle = elementList[j];
						while (spanEle && spanEle.tagName && spanEle.tagName.toLowerCase() != "span") {
							spanEle = spanEle.parentNode;
						}
						if (spanEle != elementList[j]) {
							if (elementList[j].type == "hidden") {
								if (elementList[j].hasAttribute("data-value")) {
									elemValue = elementList[j].getAttribute("data-value");
								}
							} else {
								elemValue = elementList[j].value
							}
							elemValue = pega.DateTimeUtil.convertDateTimeToGMT(elemValue, spanEle);

						}
					} else {
						try {
							var originalValueStr = elementList[j].getAttribute("data-value") || elementList[j].getAttribute("originalValue") || elementList[j].value;
							var customTimeZone = elementList[j].getAttribute("data-custom-timezone");
							if (elementList[j].getAttribute("data-formatting") === "yes" || elementList[j].getAttribute(
								"data-formatting") === "done") {
								if (typeof (originalValueStr) != "undefined" && originalValueStr != null) {
									if (customTimeZone) {
										if (elementList[j].type == "hidden") {
											elemValue = elementList[j].value;
										} else {
											elemValue = pega.u.d.CalendarUtil.convertDateTimeBtwnTimezones(originalValueStr, customTimeZone, pega.u.d.TimeZone);;
										}
									} else {
										elemValue = originalValueStr;
									}
								}
							} else {
								if (customTimeZone) {
									if (elementList[j].type == "hidden") {
										elemValue = elementList[j].value;
									} else {
										elemValue = pega.u.d.CalendarUtil.convertDateTimeBtwnTimezones(originalValueStr, customTimeZone, pega.u.d.TimeZone);
									}
								} 
							}
						} catch (e) {}
					}
					queryStrURL.put(elementName, elemValue);
				} else if( elementList[j].type === "range" && elementList[j].getAttribute("data-ctl") == '["Slider"]'){
           var currentLocale = pega && pega.u && pega.u.d && pega.u.d.Locale.replace("_","-");
           var sliderValue = Number(pega.control.PlaceHolder.getValue(elementList[j])).toLocaleString(currentLocale);
           queryStrURL.put(elementName, sliderValue);
        } else if (hasFile && elementList[j].type == "file") {
					var filesList = elementList[j].files;
					var name = elementList[j].name;
					if (filesList.length > 1) {
						name = name + "[]";
					}
					Array.prototype.forEach.call(filesList, function(file) {
						queryStrURL.put(name, file);
					});
					queryStrURL.put("hasFile", "true");
					queryStrURL.put("HarnessPurpose", pega.ctx.strHarnessPurpose);
				} else if (elementList[j].type == "password") {
                    /* Removing the Harness submit in case of password field.
                    var isInFormElement = true;
                     
                    try {
                      if (reloadElement) {
                        var elemInsideForm = false;
                        for (var idx = 0; idx < document.forms.length; idx++) {
                          if (pega.util.Dom.isAncestor(document.forms[idx], reloadElement)) {
                            elemInsideForm = true;
                            break;
                          }
                        }
                        isInFormElement = elemInsideForm;
                      }
                    } catch (e) {}
                    
                    if (isInFormElement) {
                      return "password";
                    } else {*/
					queryStrURL.put(elementName, pega.control.PlaceHolder.getValue(elementList[j]));
				} else {
					if (!(elementName == "" && elementList[j].type == "hidden" && (elementList[j].getAttribute("data-ctl") == undefined || elementList[j].getAttribute("data-ctl") == null))) {
						queryStrURL.put(elementName, pega.control.PlaceHolder.getValue(elementList[j]));
					}
				}
			}

			return queryStrURL;
		}
	},

    /*
     Helper to return input elements from reloadElement,
     after removing microdc related fieldset elements from reloadElement.
    */
	stripOutMDCFieldSets: function(reloadElement) {
		var reloadFieldElements = [];

		//order of elements matters  
		['input', 'select', 'textarea'].forEach(function(element) {
			reloadFieldElements = reloadFieldElements.concat(Array.prototype.slice.call(reloadElement.getElementsByTagName(element))); //NodeList to Array
		});

		var mdcElements = reloadElement.querySelectorAll("fieldset.mdc-fieldset");

		for (var i = 0; i < mdcElements.length; ++i) {
			var mdcFieldElements = Array.prototype.slice.call(mdcElements[i].querySelectorAll('input, select, textarea'));

			reloadFieldElements = reloadFieldElements.filter(function(reloadField) {
				return (mdcFieldElements.indexOf(reloadField) < 0);
			});
		}

		return reloadFieldElements;
	},

    /*
     Helper to disable microdc related fieldset elements when a outer doc is submitted,
     to prevent microdc related fields from submission.
    */
	disableMDCFieldSets: function(reloadElement) {

		var mdcNodeList = reloadElement.querySelectorAll("fieldset.mdc-fieldset");

		for (var i = 0; i < mdcNodeList.length; ++i) {
			mdcNodeList[i].disabled = true;
		}

	},
    /*
     @private creates a SafeURL of hidden input fields
     used  by performFlowACallback incase the modal window commits the transaction
     @param $Object$fromElt the dom element from which the hidden elements are required
     @return $SafeURL$ - it will also have non-empty "HarnessPurpose" key value
     */
	getHiddenEltsAsSafeURL: function(fromElt, checkInputParent) {
		var hdnElts = new SafeURL();
		if (fromElt == null) return hdnElts;
		var ipElts = fromElt.getElementsByTagName("input");
		var i,
			ipElt,
			len = ipElts.length;
		for (i = 0; i < len; i++) {
			ipElt = ipElts[i];
			if ("HIDDEN" == ipElt.type.toUpperCase() && ipElt.name.indexOf("$") < 0) {
				/* BUG-180509 - START: checkInputParent flag added to check the input parent to skip element inside section div */
				if (checkInputParent) {
					var secDivElem = pega.u.d.findParentNamed(ipElt, "BASE_REF");
					if (secDivElem != null) {
						continue;
					}
				}
				/* BUG-180509 - END */
				if (!(ipElt.name == "" && ipElt.type == "hidden" && (ipElt.getAttribute("data-ctl") == undefined || ipElt.getAttribute("data-ctl") == null))) {
					hdnElts.put(ipElt.name, ipElt.value);
				}
			}
		}
		var hrnsPrps = hdnElts.get("HarnessPurpose");
		if (!hrnsPrps || hrnsPrps == null || hrnsPrps == "") {
			try {
				if (window.frameElement != null && window.frameElement.name && window.frameElement.name ==
					"actionIFrame") {
					var hrnsPrpsFromParentDoc = window.parent.pega.ctx.dom.getElementById("HarnessPurpose");
					if (hrnsPrpsFromParentDoc) hdnElts.put("HarnessPurpose", hrnsPrpsFromParentDoc.value);
				}
			} catch (exce) {
				/* cross domain security issues causes exception in IAC mode */
			}
		}
		return hdnElts;
	},
    /**
     * This function saves the data in the current screen
     * @param @required obj - DOM element which has data to be posted.
     * @param @optional callbackFn - It is a 'function' or 'object with success medhod in it'. This is called after postdata is saved through async call.
     * @returns - boolean
     */
	postData: function(obj, callbackFn) {
		if (!obj || obj.nodeType != 1) {
			return false;
		}
		var pud = pega.u.d,
			postData = pud.getQueryString(obj),
			oSafeURL = new SafeURL(),
			callback;
		// Check callbackFn type and assign to callback
		if (callbackFn) {
			if (typeof callbackFn == 'function') {
				callback = {};
				callback.success = callbackFn;
			}
			if (typeof callbackFn == 'object' && typeof callbackFn.success == 'function') {
				callback = callbackFn;
			}
		}
		oSafeURL.put("pyActivity", "pzEmptyActivity");
		pud.asyncRequest('POST', oSafeURL, callback, postData);
		return true;
	},
    /*
     * The API to set the transaction id in the action URL of the harness form
     */
	setFormActionTxnId: function(txnId) {
		if (txnId && document && document.forms[0] && document.forms[0].name == "main") {
			var newURL = document.forms[0].action;
			newURL = SafeURL_createFromURL(newURL);
			var oldTxnId = newURL.get("pzTransactionId");
			if (oldTxnId !== txnId) {
				newURL.put("pzTransactionId", txnId);
				document.forms[0].action = newURL.toURL();
			}
		}
	},
    /*
     * The API fixes the transaction id in the passed baseURL or if not passed, in the form action.
     * The baseURL should be pointing to the same thread as the harness originally rendered from.
     * The correct transaction id for the base thread is always available in the AJAX change tracker.
     * Behavior is that if a baseURL is passed then form action will not be fixed.
     */
	fixBaseThreadTxnId: function(baseURL) {
		if (baseURL && !(baseURL instanceof SafeURL)) {
			return;
		}

		var url = baseURL && baseURL.toURL ? baseURL.toURL() : null;

		/* Modified the thread name extraction considering the CSRFToken */
		if (url) {
			var csrfToken = url.indexOf("/!@");
			if (csrfToken > -1) {
				var threadNamewithCSRFToken = url.substring(csrfToken + 3);
				var bangIndx = threadNamewithCSRFToken.indexOf("!")
				var endIndex = threadNamewithCSRFToken.indexOf('?');
				var threadName = threadNamewithCSRFToken.substring(bangIndx + 1, endIndex);
			} else {
				var startIndex = url.indexOf('!') + 1;
				var endIndex = url.indexOf('?');
				var threadName = url.substring(startIndex, endIndex);
			}
			/*BUG-300961 added second expression in the following expression*/
			if (!pega.ctx.isMDC && pega.u.d.baseThreadName !== threadName && !(pega.u.d.bModalDialogOpen == true && threadName.startsWith(pega.u.d.baseThreadName))) {
				return;
			}
		}
		var trackedTxnId = pega.ui.ChangeTrackerMap.getTracker().getPropertyValue("pxThread.pxClientExchange");
        /*
         * a null value for a transaction id will not be allowed to be put in SafeURL hence
         * converting a null value to empty string "".
         * empty string transaction id in change tracker means the transaction was never commited
         * in the base thread for the base frame
         */
		trackedTxnId = trackedTxnId == null ? "" : trackedTxnId;
		if (url && baseURL instanceof SafeURL) {
			var oldTxnId = baseURL.get("pzTransactionId");
			//BUG-126812 updated the following if expression, added trackedTxnId != ""
			if (trackedTxnId != "" && oldTxnId !== trackedTxnId) {
				baseURL.put("pzTransactionId", trackedTxnId);
			}
		} else {
			pega.u.d.setFormActionTxnId(trackedTxnId);
		}
	},

	getAjaxTrackerID: function() {/* HFix-35069 */
		var trackerID;
		if (pega && pega.ui && pega.ui.ChangeTrackerMap) {
			var tracker = pega.ui.ChangeTrackerMap.getTracker();
			if (tracker) {
				trackerID = tracker.id;
			}
		}
		return trackerID;
	}
};
pega.lang.augmentObject(pega.ui.Doc.prototype, ajaxengine);
ajaxengine = null;
//static-content-hash-trigger-GCC
(function(p) {
	var pud = p.u.d;
	var onRenderCompleteCallback = null;
	var ServerProxy = function() {

		var createConsole = function() {
			var myCon = {};
			var noOp = function() {

			};

			myCon.error = myCon.log = myCon.warn = noOp;
			return myCon;
		};

		var originalContentSource = "";
		var console = window.console;

		var showWarningWithTrace = function(errorMessage) {
			console = console || createConsole();
			console.warn(errorMessage); //show basic error

			try {
				//IE sets the error.stack property only when error thrown. Just creating a new error leaves it as undefined
				throw new Error('Stack Trace for - ' + errorMessage + ' :');
			} catch (ex) {
				if (ex.stack) {
					//error.stack seems to be more informative than the console.trace()- using that.
					//However, print error.stack only when it is available as this is a non-standard property
					console.log(ex.stack);
				}
			}
		};

		var isDestinationRemote = function() {
			return (requestDestination === DESTINATION.REMOTE);
		};
		var isDestinationLocal = function() {
			return (requestDestination === DESTINATION.LOCAL);
		};
		var isHybridClient = function() {
			return (pega && pega.offline);
		};
		var isBrowserClient = function() {
			return !isHybridClient();
		};
		var DESTINATION = {
			LOCAL: 'local',
			REMOTE: 'remote'
		};

		var requestDestination = (pud.isAppOfflineEnabled && pud.isAppOfflineEnabled()) ? DESTINATION.LOCAL : DESTINATION.REMOTE;
		var setDestination = function(dest) {
			if (!isValidDestination(dest)) {
				return;
			}
			requestDestination = dest;
			return requestDestination;
		};

		var isValidDestination = function(dest) {
			return dest && DESTINATION.hasOwnProperty(dest.toUpperCase());
		};

		var actionInfo = null;

		var doAction = function(safeURL, postData, oscoHandler, viewCallback, options) {
			if (!safeURL) {
				//throw (new Error("ServerProxy: doAction: safeURL - Required Param Missing"));
				showWarningWithTrace("ServerProxy: doAction: safeURL - Required Param Missing");
			} else {
				actionInfo = safeURL.toQueryString();
			}
			/* determination of offlinable case or not    */
			invokeHandler(safeURL, postData, oscoHandler, viewCallback, options);
		};

		var invokeHandler = function(safeURL, postData, oscoHandler, viewCallback, options) {
			if (pud.isAppOfflineEnabled() && isDestinationLocal()) {
				if (!oscoHandler) {
					//throw (new Error("ServerProxy: doAction: Required OSCOHandler param Missing"));
					showWarningWithTrace("ServerProxy: doAction: Required OSCOHandler param Missing");
				}

				//  /*  ToDo  update client cache with postData */
				var postJSONString = null;
				if (postData) {
					if (postData instanceof SafeURL) {
						var hash = postData.hashtable;
						var formJSON = {};
						for (var key in hash) {
							//$PpyWorkPage$pName
							if (key.match(/\$P[a-zA-Z0-9_]+\$p/)) {
								var elemRef = pega.ui.property.toReference(key);
								var elemValue = hash[key];
								formJSON = pega.ui.property.toObject(elemRef, elemValue, formJSON); //(elemRef,elemValue);
							}
						}

						var topPage = null;
						for (var page in formJSON) {
							topPage = page;
							var clientCachePage = pega.ui.ClientCache.find(topPage);
							if (!clientCachePage) {
								clientCachePage = pega.ui.ClientCache.createPage(topPage);
							}
							if (clientCachePage) {
								var lookupPage = topPage;
								var isParametrizedDP = pega.ui.ParametrizedDPUtils.isParametrizedDataPage(lookupPage);
								var reference = clientCachePage.getReference();
								if (isParametrizedDP && lookupPage !== reference)
									lookupPage = reference;  // Get current instance not base page
								//clientCachePage.adoptJSON(JSON.stringify($.extend(true, {}, JSON.parse(clientCachePage.getJSON()), formJSON[topPage])));
								clientCachePage.adoptJSON(JSON.stringify($.extend(true, {}, JSON.parse(clientCachePage.getJSON()), formJSON[lookupPage])));
							}
						}
						postJSONString = JSON.stringify(formJSON);
					} else {
						showWarningWithTrace("ServerProxy: PostData should be of type SafeURL");
						return;
						/* throw (new Error("ServerProxy: PostData should be of type SafeURL")); //not throwing exceptions until further architectural decision */
					}
				}
				var wrappedCallback = pega.u.d.wrapCallback(viewCallback);
				var mergedTemplateCallback = {
					success: function(result) {
						// US-109057; call from ajax processing has array, call with data from cache has correctly formatted object (result.responseText)
						if (result.length > 0) {
							result = result[0];
							result.responseText = result.content;
						} else if (!result.responseText) {
							//ClientStore executed successfully, but found no results
							//let this be handled by failure call back.
							wrappedCallback.failure(result);
							return;
						}
						result.argument = wrappedCallback.argument;

						/* BUG-334923: Allow setting the runtime context over packaging time context */
						if (options && options.contextParams) {
							result = setRuntimeContext(result, options.contextParams.packagedContext, options.contextParams.runtimeContext);
						}

						result = mergeTemplateData(result);
						wrappedCallback.success(result);
					},
					failure: function(result) {
						wrappedCallback.failure(result);
					}
				};
				if (viewCallback) {
					pega.u.d.pauseAjaxSequencer();
				}
				oscoHandler.offline.call(oscoHandler.scope, safeURL, postJSONString, mergedTemplateCallback);
			} else if (pud.isAppOfflineEnabled() && isDestinationRemote()) {
				if (oscoHandler && oscoHandler.remote) {
					oscoHandler.remote.call(oscoHandler.scope, safeURL, postData, viewCallback);// Invoke Custom Online Handler
				} else if (oscoHandler && oscoHandler.online) {
					oscoHandler.online.call(oscoHandler.scope, safeURL, postData, viewCallback);// Invoke Custom Online Handler
				} else {
					pega.u.d.asyncRequest("POST", safeURL, viewCallback, postData);
				}
			} else {
				if (oscoHandler && oscoHandler.online) {
					oscoHandler.online.call(oscoHandler.scope, safeURL, postData, viewCallback);// Invoke Custom Online Handler
				} else {
					if (pega.ctx.isMDC && !safeURL.get("UITemplatingStatus")) {
						safeURL.put("UITemplatingStatus", pega.ctx.isUITemplatized ? "Y" : "N");
					}
					pega.u.d.asyncRequest("POST", safeURL, viewCallback, postData);
				}
			}
		};

		var displaySection = function(response, sectionCallback) {
			//TODO: Add implementation
			mergeTemplateData(response);

            /* pega.u.d.initRenderingEngine(response,function(replaceResponse,tempDiv){
               if(replaceResponse){
                   response.responseText = tempDiv.innerHTML;
               }
               sectionCallback(response);
             });*/

			var responseNode = document.createElement("div");
			responseNode.innerHTML = response.responseText;

			pega.ui.TemplateEngine.renderUI(responseNode, function(responseHtml) {
				// if(replaceResponse){
				response.responseText = responseHtml;
				//}
				sectionCallback(response);
			});

		};

		var mergeTemplateData = function(result) {
			try {
				/*Set Ajax response to clientcache in case of offline templatization - Start */
				var htmlResponse = result.responseText;
				var dummyDiv = document.createElement("div");
				dummyDiv.innerHTML = htmlResponse;

				/* if have flow action stream data, merge in now */
				if (result.faStream && result.faStream !== "") {
					var flowActionSpan = $(dummyDiv).find("#FlowActionHTML");
					if (flowActionSpan) {
						flowActionSpan.html(result.faStream);
					}
				}

				/* remove Change tracker div from markup */
				var ajaxCTdivObj = null,
					duplicateModalOverlayDiv = null,
					jsonResponse = null;

				ajaxCTdivObj = $(dummyDiv).find("div[id^='AJAXCT']");
				if (ajaxCTdivObj && ajaxCTdivObj.length >= 1) {
					jsonResponse = JSON.parse(ajaxCTdivObj[0].getAttribute('data-json'));
					ajaxCTdivObj[0].parentNode.removeChild(ajaxCTdivObj[0]);
					ajaxCTdivObj = null;
				}

				duplicateModalOverlayDiv = dummyDiv.getElementsByClassName("modal-overlay");
				duplicateModalOverlayDiv = (duplicateModalOverlayDiv && duplicateModalOverlayDiv.length > 0) ? duplicateModalOverlayDiv[0] : null;
				if (duplicateModalOverlayDiv) {
					//BUG-194435 - packaged harness has this div which is a duplicate.
					duplicateModalOverlayDiv.parentNode.removeChild(duplicateModalOverlayDiv);
				}

				result.responseText = dummyDiv.innerHTML;

				if (jsonResponse && jsonResponse.Initial && jsonResponse.Values) {
					for (var navPage in jsonResponse.Initial) {
						if (navPage.indexOf("pyNavigation") === 0) {
							pega.ui.ClientCache.createPage(navPage).adoptServerJSON(jsonResponse.Initial[navPage]);
						}
					}
				}
				return result;
			} catch (e) {
				showWarningWithTrace("Exception while parsing template data");
			}
		};

		var setRuntimeContext = function(result, packagedContext, runtimeContext) {
			/* TASK-319793: Replace the entry handles based on the params in submitModalDlgParam */
			var htmlResponse = result.responseText;
			if (packagedContext && runtimeContext && htmlResponse.indexOf(packagedContext) !== -1 && packagedContext !== runtimeContext) {
				/* Fix the data-cdb-innerHTML attribute value */
				htmlResponse = htmlResponse.replace(new RegExp("{{" + packagedContext, 'g'), "{{" + runtimeContext);
				/* Fix entry handles */
				htmlResponse = htmlResponse.replace(new RegExp("\\$P" + packagedContext, 'g'), pega.u.property.toHandle(runtimeContext));
				/* Fix other places where packagedContext page name is used */
				result.responseText = htmlResponse.replace(new RegExp(packagedContext, 'g'), runtimeContext);
			}
			return result;
		};

		/****** Validation ********/
		var validate = function(flowActionName, flowClass) {
			if (flowActionName && flowClass) {
				var flowActionInsName = pega.process.flow.generateFlowInsName(flowClass, flowActionName);
				var flowActionRule = pega.offline.clientstorehelper.getFlowActionRuleFromCache(flowActionInsName);

				if (!flowActionRule) {
					console.error("Failed to get flow action rule: " + flowActionInsName + " from cache.");
					return false;
				}

				if (flowActionRule.pxValidateName && flowActionRule.pxValidateClassName) {
					try {
						return pega.offline.runValidate(flowActionRule.pxValidateName, flowActionRule.pxValidateClassName);
					} catch (error) {
						console.error(error.message);
						return false;
					}
				}
			}

			return true;
		};

		var displayFlowAction = function(actionName, objClass, callback, contextParams, sectionHash) {
			// publish state for test tooling; set document modification inprogress
			pega.ui.statetracking.setDocumentBusy();
			var packagedContext, runtimeContext;
			if (contextParams) {
				packagedContext = contextParams.packagedContext;
				runtimeContext = contextParams.runtimeContext;
			}
			var wrappedCallback = pega.u.d.wrapCallback(callback);
			var faCallback = {
				success: function(result) {

					// wrap the flowaction html with span
					var htmlElem = $("<span>" + result.responseText + "</span>");
					var secPDiv = htmlElem.find('#section-placeholder');

					var sectionCallback = {
						success: function(result) {

							//replace placeholder section div with sec stream
							var sectionHTML = result.responseText;
							secPDiv.replaceWith(sectionHTML);

							// restore the complete response
							result.responseText = htmlElem.html();
							mergedTemplateCallback.success(result);
						},
						failure: function(result) {
							mergedTemplateCallback.failure(result);
						}
					};

					if (secPDiv.length) {
						var secClass = secPDiv.attr('data-class').toUpperCase();
						var secName = secPDiv.attr('data-section').toUpperCase();
						var key = sectionHash ? (secName + "!" + sectionHash) : secName;
						pega.offline.clientstorehelper.getSectionStream(secClass, key, sectionCallback.success, sectionCallback.failure);
					}
				},
				failure: function(result) {
					mergedTemplateCallback.failure(result);
				}
			};
			var mergedTemplateCallback = {
				success: function(result) {
					result = setRuntimeContext(result, packagedContext, runtimeContext);
					result = mergeTemplateData(result);
					wrappedCallback.success(result);
					pega.ui.statetracking.setDocumentDone();
				},
				failure: function(result) {
					wrappedCallback.failure(result);
					pega.ui.statetracking.setDocumentDone();
				}
			};
			// bajaa BUG-261461
			var _faRulename = pega.process.flow.generateFlowInsName(objClass, actionName);
			var _faRuleFromCache = pega.offline.clientstorehelper.getFlowActionRuleFromCache(_faRulename);
			var workPage = pega.ui.ClientCache.find("pyWorkPage");
			if (workPage && _faRuleFromCache) {
				_faRuleFromCache.pySubmitLabel ? workPage.put("pySubmitLabel", _faRuleFromCache.pySubmitLabel) : undefined;
				_faRuleFromCache.pyPreviousLabel ? workPage.put("pyPreviousLabel", _faRuleFromCache.pyPreviousLabel) : undefined;
				_faRuleFromCache.pyNextLabel ? workPage.put("pyNextLabel", _faRuleFromCache.pyNextLabel) : undefined;
				_faRuleFromCache.pyCancelLabel ? workPage.put("pyCancelLabel", _faRuleFromCache.pyCancelLabel) : undefined;
				_faRuleFromCache.pyShowFAButtons ? workPage.put("pyShowFAButtons", _faRuleFromCache.pyShowFAButtons) : undefined;
			}
			// BUG-231345: preProcessAction is called twice
			//preProcessAction(actionName, objClass);
			pega.offline.clientstorehelper.getFlowActionStream(objClass, actionName, faCallback.success, faCallback.failure);
		};

		/* US-109057; streamCache removed as ClientStoreHelper wraps ruleCache */
		var displayHarness = function(harnessName, objClass, onRenderComplete, immediateCallback, options, dontResetBusyState) {
			var resetBusyState = !dontResetBusyState;
			pega.u.EventsEmitter && pega.u.EventsEmitter.publishSync("BeforeHarnessStream");
			onRenderCompleteCallback = onRenderComplete;
			var metaData = actionInfo;

			//set server availability status
			if (pega.offline && pega.offline.NetworkStatus) {
				pega.ui.updatePegaServerAvailability(pega.offline.NetworkStatus.getServerAvailabilityStatus());
			}

			// publish state for test tooling; set document modification inprogress
			pega.ui.statetracking.setDocumentBusy();

			/*BUG-486913 changes */
			var getDisplayHarness = (function() {
				return function(faStream) {
					var callback = {
						success: function(dataObject) {
							var stream = dataObject.responseText;
							pega.u.d.ServerProxy.displayHarnessStream(stream, resetBusyState);
							if (typeof onRenderComplete == "function") {
								pega.u.EventsEmitter && pega.u.EventsEmitter.publishSync("AfterHarnessStream");

								/* source === "webview" means this action is being raised from a different webview. 
								This happens in case of PMC MultiWebView offline application where action is raised from parent webview and the action is processed in child webview by opening a new webview 
								*/
								if (options && options.source === "webview") {
									PMCRenderer(dataObject, options, {
										success: onRenderComplete,
										failure: function() {
											console.error("Failed to render harness using PMC Renderer");
										}
									});
								} else {
									onRenderComplete.call(this, dataObject);
									onRenderCompleteCallback = null;
									onRenderComplete = null;
								}
							}
							p && p.c && p.c.Actions && p.c.Actions.prototype.hideSkeleton();
						},
						failure: function(message) {
							pega.ui.statetracking.setDocumentDone();
							if (resetBusyState) {
								pega.u.d.resetBusyState();
							}
							var msgaftersplit = message.split("!");
							var rulename;
							if (msgaftersplit.length > 1)
								rulename = msgaftersplit[1].substring(0, msgaftersplit[1].length - 1);
							showWarningWithTrace(message);
							alert('Failed to load stream: ' + rulename);
							p && p.c && p.c.Actions && p.c.Actions.prototype.hideSkeleton();
						}
					};

					var wrappedCallback = pega.u.d.wrapCallback(callback);

					var mergedTemplateCallback = {
						success: function(result) {
							// add the flow action stream to this object,
							// mergeTemplateData will add it into the harness, if it is not null or blank
							result = mergeTemplateData({responseText: result.responseText, faStream: faStream});
							wrappedCallback.success(result);
							if (resetBusyState) {
								pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
							}
						},
						failure: function(result) {
							wrappedCallback.failure(result);
							if (resetBusyState) {
								pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
							}
						}
					};

					pega.offline.clientstorehelper.getHarnessStream(objClass, harnessName, mergedTemplateCallback.success, mergedTemplateCallback.failure);
				}
			})();

			// check if have getFlowActionStream, and if so, call it to get the flow acton stream,
			// will use this in building the harness
			if (pega.process.flowactionstream.getFlowActionStream) {
				pega.process.flowactionstream.getFlowActionStream(getDisplayHarness, function() {});
			} else {
				getDisplayHarness(null);
			}

			this.onActionComplete(metaData);
		};

		/*
			This API is similar to similar to singlePageRenderer but is more specific to render work harness in PMC MultiwebView which uses Ajax Cotnainer. 
			As in the newly opened harness we don't have any Dynamic Container or Ajax Container releated div's we are explicitly handling it in this API.
		*/
		var PMCRenderer = function(response, metadata, callback) {

			/**
			  We are writing this helper method to process the offline stream. Harness shell is the default/dummy harness which has been used to open the webivew.
			  We are making the call at harness on load to client store to get the harness stream. The stream which we are getting has to get processed at client side.
			*/

			var isPIMC = typeof pmcRuntimeFeatures !== 'undefined';
			var isPIMCOffline = isPIMC && pmcRuntimeFeatures.pxUsesOffline === 'true';
			var isPIMCMultiWebview = isPIMC && pmcRuntimeFeatures.pxUsesMultiWebView === 'true';

			/* preRenderer is used to parse the stream's metadata. Stream brings harness metadata in intialvars and bottom vars. */
			var preRenderer = function(response) {
				var dummyDiv = document.createElement("div");
				dummyDiv.innerHTML = response.responseText;
				var intialVars = dummyDiv.querySelector("script#harnessvars");

				if (!intialVars) {
					dummyDiv.innerHTML = null;
					dummyDiv = undefined;
					return;
				}

				var mainDiv = getMainDiv();
				if (mainDiv) {
					pega.u.d.cleanUpHarnessElements(null, [mainDiv]);
				}

				/* Unloading the previous(Harness Shell) context. */
				pega.ui.HarnessContextMgr.unloadHarnessContext(pega.ctx.pzHarnessID);

				var scriptEle = document.createElement("script");
				scriptEle.innerHTML = intialVars.innerHTML;
				intialVars.parentNode.removeChild(intialVars);
				document.head.appendChild(scriptEle);
				var url = pega.ctx.url;
				/* BUG-528182 : pega.ctx.expressionevaluator is set to undefined as evaluateJSONVariables is being called with undefined value as parameter. 
				As pega.ctx.expressionevaluator.expressionData is not available expressions are not getting evaluated during delta sync. 
				Passing the parameter as true to prevent the creation of new context.
				*/
				evaluateJSONVariables(true);
				deferredFieldValues();

				/* BUG-567585 : processDynamicData method that is getting called from deferredAdditionalDynamic which is called from deferredFieldValues is overriding pega.ctx.url with the packaged value which is wrong. We don't know the thread during packaging. So storing the ctx url before the deferredFieldValues call and extracting the query params from it. */
				var queryParams = url.indexOf('?') > 0 ? url.split('?')[1] : '';
				pega.ctx.url = window.location.pathname + '?' + queryParams;

				/* Populating the new thread name to ctx. */
				if (!pega.ctx.baseThreadName) {
					pega.ctx.baseThreadName = pega.u.d.getThreadName();
				}

				if (!pega.ctx.basePrimaryPageName) {
					pega.ctx.basePrimaryPageName = pega.ctx.primaryPageName;
				}

				response.responseText = dummyDiv.innerHTML;
				dummyDiv.innerHTML = null;
				dummyDiv = undefined;
			};

			function getMainDiv() {
				var mainDiv;
				if (pega.u.d.bIsDCSPA && pega.u.d.replaceWorkArea) {
					mainDiv = document.querySelector("#workarea");
				} else {
					mainDiv = document.querySelector("main");
				}
				return mainDiv;
			}

			var getDummyDiv = function(res) {
				var dummyDiv = document.createElement("div");
				dummyDiv.innerHTML = res;
				var toggleIcon = $(dummyDiv).find("main.screen-layout-region-main-middle a#appview-nav-toggle-one.nav-toggle-one").get(0);
				if (toggleIcon) {
					toggleIcon.remove();
				}
				toggleIcon = $(dummyDiv).find("main.screen-layout-region-main-middle a#appview-nav-toggle-two.nav-toggle-two").get(0);
				if (toggleIcon) {
					toggleIcon.remove();
				}
				return dummyDiv;
			};

			function switchContext() {
				var _currentHarnessCtx;
				var harnessContextMap = pega.ctxmgr.getHarnessContextMap();
				if (!harnessContextMap[pega.ctx.pzHarnessID]) {

					_currentHarnessCtx = pega.ctx;
					var newHarnessId = Object.keys(harnessContextMap)[0];
					pega.ctxmgr.setContext(harnessContextMap[newHarnessId]);
				}
				return _currentHarnessCtx;
			}

			function processCananicalElement(response) {
				var canonicalElement = document.querySelector("head link[rel='canonical']");
				if (canonicalElement) {
					canonicalElement.remove();
				}
				canonicalElement = response.querySelector("link[rel='canonical']");
				if (canonicalElement) {
					document.head.appendChild(canonicalElement);
				}
			};

			var success = function(response) {
				var dummyDiv = getDummyDiv(response.responseText);
				// Switching the context to the new harness stream.
				var _currentHarnessCtx = switchContext();
				processCananicalElement(dummyDiv);

				var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", dummyDiv, "div");
				if (onlyOnceEle && onlyOnceEle[0]) {
					pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
					onlyOnceEle[0].parentNode.removeChild(onlyOnceEle[0]);
				}

				var harnessDiv = pega.util.Dom.getElementsById("PEGA_HARNESS", dummyDiv, "div");

				if (harnessDiv && harnessDiv.length > 0) {
					harnessDiv = harnessDiv[0];
					var scriptArray = dummyDiv.querySelectorAll("script");
					var linkArray = dummyDiv.querySelectorAll("link[rel='stylesheet']");
					var styleArray = dummyDiv.querySelectorAll("style");
					var count = scriptArray.length;

					for (var index = 0; index < count; index++) {
						harnessDiv.appendChild(scriptArray[index]);
					}
					count = linkArray.length;
					for (index = 0; index < count; index++) {
						harnessDiv.appendChild(linkArray[index]);
					}
					count = styleArray.length;
					for (index = 0; index < count; index++) {
						harnessDiv.appendChild(styleArray[index]);
					}
					scriptArray = styleArray = linkArray = null;

					dummyDiv = document.createElement("div");
					dummyDiv.appendChild(harnessDiv);

					var mainDiv;
					var hook = document.createElement("div");
					hook.setAttribute("id", "hook");
					var harnessArea = document.getElementById("PEGA_HARNESS");
					document.getElementById("PEGA_HARNESS").parentNode.insertBefore(hook, document.getElementById("PEGA_HARNESS"));
					mainDiv = hook;
					harnessArea.parentNode.removeChild(harnessArea);

					var wrapperRenderCB = function(domObj) {
						var _currentHarnessCtx = switchContext();
						var harCtxMgr = pega.ui.HarnessContextMgr;

						pega.u.d.loadHTMLEleCallback(domObj, true);

						pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
						pega.u.d.resetBusyState();

						if (metadata && metadata.action === "finishAssignment") {
							pega.ui.HarnessContextMap.set("SubmitInProgress", false);
						}
						pega.ctx.baseFrameName = SafeURL_createFromURL(harCtxMgr.get('url')).get('pzFromFrame');

						// BUG-551052 - Initializing modal dailog after pzPMCHarnessShell is replaced with actual harness
						if (pega.u.d.modalDialog && pega.u.d.modalDialogInit) {
							pega.u.d.modalDialogInit();
						}

						pega.ui.HarnessContextMap.set("ignoreDirtyState", null);
						pega.ui.HarnessContextMap.set("gSectionReloaded", null);
						pega.ui.HarnessContextMap.set("gDirtyOverride", null);

						// ToDo: Check if this is really required
						pega.u.d.gIsScriptsLoading = false;
						if (_currentHarnessCtx) {
							pega.ctxmgr.setContext(_currentHarnessCtx);
						}
					};

					var wrapperCB = function(domObj) {
						/* Setting harness id at document level */
						document.body.setAttribute("data-harness-id", pega.ctx.pzHarnessID);

						pega.ctx.baseFrameName = SafeURL_createFromURL(pega.u.d.url).get('pzFromFrame');

						if (callback && typeof callback.success === 'function') {
							wrapperRenderCB(domObj);
							callback.success(domObj);
						} else {
							pega.u.d.loadHTMLEleCallback(domObj);
						}

						/* fix for BUG-543023 */
						if (isPIMCOffline && isPIMCMultiWebview) {
							pega.u.d.evaluateAllVisibleWhens();
						}

						/* Reordering logic goes here */
						var harnessArea = document.getElementById("PEGA_HARNESS");
						var hook = document.getElementById("hook");
						if (hook) {
							hook.parentNode.insertBefore(harnessArea, hook)
							hook.parentNode.removeChild(hook);
						}
					};

					/**
					   Setting the new stream to the document node.
					   mainDiv : this the hook where we are appending the new stream.
					**/
					pega.u.d.loadDOMObject(mainDiv, harnessDiv.parentNode, wrapperCB);
					delete document.actionForm;
				};
			};

			this.metadata = metadata;
			if (isPIMCOffline) {
				preRenderer.call(this, response);
				success.call(this, response);
			}
		};

		/* 
		  Display the harness in Ajax Container (formerly MicroDC)
		  @params
		  className - @string - class name of the harness
		  harnessName - @string - harness name to be rendered
		  acMetadata - @object 
			action - @string - action name from which this api is called
			mdcTarget - @string - ajax container name (primary/ secondary or teritary)
			callback - @object - success and failure callbacks the should be invoked after harness rendering
		*/
		var displayHarnessInAjaxContainer = function(className, harnessName, acMetadata, callback) {
			if (acMetadata.mdcTarget && acMetadata.mdcTarget !== "dynamicContainer") {
				if (className && harnessName) {
					var metadata = Object.assign({}, acMetadata);
					metadata.className = className;
					metadata.harnessName = harnessName;
					metadata.callback = callback;

					switch (acMetadata.action) {
						/* Actions like createNewWork, openAssignment and openWorkByHandle creates a new dopcument.
					 		These actions should dispatch ADD action to create new document in AjaxContainer.*/
						case "createNewWork":
						case "openAssignment":
						case "openWorkByHandle":
							var currentState = pega.redux.Utils.getAjaxContainerState(acMetadata.mdcTarget);
							if (currentState.tempUrl) {
								pega.ctx.url = currentState.tempUrl;
								delete currentState.tempUrl;
							}

							/* US-324619-8 : For Multi WebView PMC ajax container based application, pzpega_ui_ajax_container bundle is loaded in Parent WebView (Hidden WebView). 
							So dispatch action in the Parent WebView.
							*/
							var portalWindow = pega.mobile.support && pega.mobile.support.getPortalWindow();
							if (pmcRuntimeFeatures && pmcRuntimeFeatures.pxUsesMultiWebView === "true" && portalWindow) {
								/* Multi WebView PMC ajax container */
								portalWindow.pega.redux.store.dispatch(portalWindow.pega.redux.actions(portalWindow.pega.redux.actionTypes.ADD, metadata));
							} else {
								/* Single WebView PMC ajax container */
								pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.ADD, metadata));
							}
							break;
						default:
							/* For other action render harness in appropriate mdcTarget. */
							/* Populating in safeURL to bipass the error that are caused as rendering code is tightly bound to online usecase. */
							var safeURL = new SafeURL();
							safeURL.put("className", className);
							safeURL.put("harnessName", harnessName);
							safeURL.put("callback", callback);
							safeURL.put("mdcTarget", acMetadata.mdcTarget);
							pega.ui.MDCUtil.microDCRenderer(safeURL, new SafeURL(), true);
					}
				} else {
					throw "Passed invalid class name or harness name parameters";
				}
			}
		};

		var processErrors = function() {
			var workPage = pega.ui.ClientCache.find("pyWorkPage");

			if (workPage) {
				if (workPage.hasMessages()) {
					pega.ui.ErrorHandler.showErrors(workPage.getMessagesWithHandle());
				} else {
					workPage.setMessagePresentationState("submitted");
				}
			}
		};

		var displayHarnessStream = function(stream, resetBusyState) {
			// ToDo : Find what replace is doing as we are not executing it in case of offline ajax container
			/* US-324619 : DCUtils shouldn't be loaded or used in case of Ajax Container related harness rendering. Added safe check. */
			if (pega.ui.DCUtil && pega.ui.DCUtil.replace) {
				pega.ui.DCUtil.replace(stream);
			}
			pega.ui.statetracking.setDocumentDone();
			processErrors();
			if (resetBusyState) {
				pega.u.d.resetBusyState();
				pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
			} else if (resetBusyState === false) {
				/* Setting to busy explicitly when resetBusyState value is passed as false. */
				pega.u.d.setBusyState();
			}
		};

		var onActionComplete = function(metaDataInfo) {
			if (pega.u.d.onViewUpdate && metaDataInfo) {
				pega.u.d.onViewUpdate(SafeURL_createFromURL(metaDataInfo));
				actionInfo = null;
			}
		};

		var executeBreakoutCall = function(activityName, activityParams, callback, configObj) {
			if (pud.isAppOfflineEnabled()) {
				/* Build URL */

				var reqURIArray = pega.desktop.pxReqURI.split("*/");
				var pegaURLArray = pega.u.d.url.split("*/");
				var reqURIDestination = reqURIArray[0].substring(0, reqURIArray[0].lastIndexOf('/'));
				var pegaURLDestination = pegaURLArray[0].substring(0, pegaURLArray[0].lastIndexOf('/'));
				pega.u.d.url = pega.u.d.url.replace(pegaURLDestination, reqURIDestination);

				var strUrlSF = SafeURL_createFromURL(pega.u.d.url.trim().substring(0, pega.u.d.url.trim().indexOf("?")));
				var reqURI = strUrlSF.get('pxReqURI');
				reqURI = reqURI.replace(reqURI.substring(reqURI.indexOf('!') + 1), 'NONOSCOThread');
				strUrlSF.put("UITemplatingStatus", "Y");
				strUrlSF.put('pxReqURI', reqURI);
				if (typeof encryptURLForOSCOBreakOut !== "undefined" && encryptURLForOSCOBreakOut) {
          var encSafeURL = SafeURL_createFromURL(encryptURLForOSCOBreakOut);
          strUrlSF.copy(encSafeURL);
        } else {
          strUrlSF.put("pyActivity", "pzOSCOBreakoutWrapper");
        }
				strUrlSF.put("pzActivity", activityName);
				/* Read userName and Password to set the session */
				var postBody = new SafeURL();
                /*postBody.put("UserIdentifier", launchbox.AccountManager.identifier);
                postBody.put("Password", btoa(launchbox.AccountManager.password));*/
				postBody = postBody.toQueryString();

				if (activityName.indexOf(".") === -1) {
					/* Build postData with pyWorkPage */
					var workPage = pega.ui.ClientCache.find("pyWorkPage");
					if (workPage) {
						/* postBodyURL.put("WorkPageJSON", workPage.getJSON()); */
						/* SafeURL is not handling the already escaped string */
						postBody += "&WorkPageJSON=" + encodeURIComponent(workPage.getJSON());
					} else {
						console.log("OSCO Breakout : Failed, due to non-existance of pyWorkPage in ClientCache");
						if (callback.failure) {
							callback.failure.call(callback.scope);
						}
						return;
					}
				}

				/* Pass activity parameters */
				if (activityParams) {
					/*postBodyURL.put("pzActivityParams", activityParams.toQueryString());*/
					postBody += "&pzActivityParams=" + encodeURIComponent(activityParams.toQueryString());
				}

				var ajaxCB = {
					success: function(data) {
						data = data.responseText;
						var status = data.substring(0, 1);
						data = data.substring(2);
						if (status !== "0") {
							/* Call success callback if any */
							if (callback.success) {
								callback.success.call(callback.scope, data);
							}
						} else {
							console.log("OSCO Breakout : Activity execution got failed");
							/* Call Failure callback */
							if (callback.failure) {
								try {
									callback.failure.call(callback.scope);
								} catch (e) {
								}
							}
						}
					}, failure: function() {
						console.log("OSCO Breakout : Failure");
						/* Call Failure callback */
						if (callback.failure) {
							callback.failure.call(callback.scope);
						}
					}
				};
				launchbox.PRPC.ClientStore.keepAliveSessionTimeout(function() {pud.postPage(strUrlSF, ajaxCB, postBody);});
			}
		};

		var spExposedAPI = {
			"doAction": doAction,
			"displaySection": displaySection,
			"displayHarness": displayHarness,
			"displayHarnessStream": displayHarnessStream,
			"displayHarnessInAjaxContainer": displayHarnessInAjaxContainer,
			"displayFlowAction": displayFlowAction,
			"executeBreakoutCall": executeBreakoutCall,
			"setDestination": setDestination,
			"isDestinationRemote": isDestinationRemote,
			"isDestinationLocal": isDestinationLocal,
			"isHybridClient": isHybridClient,
			"isBrowserClient": isBrowserClient,
			"onActionComplete": onActionComplete,
			"DESTINATION": DESTINATION,
			"onRenderComplete": function() {
				if (typeof onRenderCompleteCallback == "function") {
					onRenderCompleteCallback.call(null);
					onRenderCompleteCallback = null;
				}
			}, // BUG-268484
			"resetDestination": function() {
				/* BUG-591395 : Reset destination only when originalContentSource has proper value which will be checked in setDestination API. Commenting below statement as it doesn't makes sense setting requestDestination directly when the setDestination is having a validation check on the parameter that is sent. */
				/* requestDestination = originalContentSource; */
				this.setDestination(originalContentSource);
			},
			"forceDestinationIfOSCOProcessing": function() {
				originalContentSource = requestDestination;
				if (pud.isAppOfflineEnabled()) {
					this.setDestination(this.DESTINATION.LOCAL);
					pega.u.d.switchThread('STANDARD');
					pega.ui.ClientCache.init('STANDARD');
				} else {
					this.setDestination(this.DESTINATION.REMOTE);
				}
			},
			"validate": validate
		};
		return spExposedAPI;
	};
	pud.ServerProxy = ServerProxy();
})(pega);
  //static-content-hash-trigger-GCC
//<script>

(function () {

/*
 @protected This function returns the row index/subscript of the given element in the repeat layout.
 Used by handle client event function, etc.
 @param $Object$element
 @return 
*/

pega.ui.Doc.prototype.getRepeatRow = function(element, getRowObj){
	var parentElt = element;
	while(parentElt && !parentElt.getElementById){
		if(parentElt.getAttribute && (parentElt.getAttribute("PL_PROP") != null || parentElt.getAttribute("PG_PROP") != null))
								break;
		if(parentElt.getAttribute && parentElt.getAttribute("PL_INDEX") != null){
			if(getRowObj){
				return parentElt;
			}
			else{
				return parentElt.getAttribute("PL_INDEX");
			}
		} 
		else if(parentElt.getAttribute && parentElt.getAttribute("PG_SUBSCRIPT") != null){
			if(getRowObj){
				return parentElt;
			}
			else{
				return parentElt.getAttribute("PG_SUBSCRIPT");
			}
		}	
		parentElt = parentElt.parentNode;
	}
	return null;
}




pega.ui.Doc.prototype.getRepeatTable = function(element){
	var parentTable = this.findParentTable(element);
	while(parentTable != null){
		if(parentTable.getAttribute("PL_PROP") != null || parentTable.getAttribute("PG_PROP") != null){
			break;/*return parentTable;*/
		}
		else{
			parentTable = this.findParentTable(parentTable);
		}
	}		
	return parentTable;
}

pega.ui.Doc.prototype.getNumberingElement = function(row) {
	var numberingEle = null;
	var spanElems = pega.util.Dom.getElementsBy(function(ele) {
		if(pega.util.Dom.hasClass(ele, "pageIndex")) return true;
		return false;
	},"span", row);
	if(spanElems && spanElems[0]) {
		numberingEle = spanElems[0];
	}
	return numberingEle;
}

/* set new values for left table in grid ;
 * update SPAN content which is the numbering element
 */
pega.ui.Doc.prototype.setLeftTableValues = function(row, newIndex){ 
	var numberingEle = this.getNumberingElement(row);
	if(numberingEle) {

		/*BUG-107788: As the newIndex is a String, used innerText instead of innerHTML. innerHTML wasn't working in IE 8*/
		numberingEle.innerText = "";
		numberingEle.innerText = newIndex;
		numberingEle.innerHTML = "";
		numberingEle.innerHTML = newIndex;
	}
	
}

/*
 @protected Holds common functionality for updating the entry handles of all the rows 
 @param $String$indexInList - index of the new row that is being added ar deleted
 @param Object$responseObj - Response Object
 @param $boolean$isDelete - identifies whether it is a add/delete operation 
 @return $void$
*/	
pega.ui.Doc.prototype.updateHandlesAfterDelete = function(tableInfo) {
	if(!tableInfo || !tableInfo.length || tableInfo.length < 2)
		return;
	var indexInList = tableInfo[0];
	var tables = tableInfo[1];
    	if(!tables || !tables.length || tables.length == 0)
        		return;
    var grid = tableInfo[2];
	indexInList++ ;

	var forLeftTable = false;
	var grid;
	if(tables.length == 2 && grid) {
		forLeftTable = true;		
	}
   	 for(var tIndex = 0; tIndex < tables.length; tIndex++) {
		if(tIndex == 0 && grid && !grid.bTreegrid && !grid.fixedCol) {
			forLeftTable = false;
			continue;
		}
        var table = tables[tIndex];
		if(forLeftTable == true && tIndex==0) {
			var tableRows = pega.util.Dom.getChildren(table);
			var numRows = tableRows.length;
		}else {
			var tableRows = table.rows;
			var numRows = tableRows.length;
		}
        var currHPref, prevHPref, newHPref, currIndex, prevIndex, newIndex, newId, prevId = ""; 
		var totalRows = numRows;
		/*if(grid && grid.bGrid == true){	
			totalRows = numRows;
		}else {
			totalRows =  numRows-1;
		}*/
		
		if(grid && grid.editConfig == grid.EDIT_EXPANDPANE) {
			indexInList = grid.getIndex(indexInList);  
			indexInList = parseInt(indexInList);
			/*increase the start index when the start element in grid doesn't have id i.e. it's a details row*/
			if(tableRows[indexInList+1] && (tableRows[indexInList+1].id==null || tableRows[indexInList+1].id=="")) {
				indexInList = indexInList +1;
			}
		}
        for (var i = parseInt(indexInList)+1 ; i < totalRows ; i++) {
            var eachRow = tableRows[i];

			currHPref = ( eachRow.getAttribute("hPref") || eachRow.id) ;
			if(grid && grid.editConfig==grid.EDIT_EXPANDPANE && !currHPref) {
				continue;
			}
            currIndex =eachRow.getAttribute("PL_INDEX");         
			if(!currIndex)
			  continue;
			  
            newHPref = prevHPref;
            prevHPref = currHPref;
           
            newIndex = prevIndex;
            prevIndex = currIndex;

            newId = prevId;
            prevId = eachRow.id;

            if(i == parseInt(indexInList)+1 ) {
				if(grid && grid.editConfig == grid.EDIT_EXPANDPANE && !forLeftTable && i>1 && (tableRows[i-1].id==null || tableRows[i-1].id=="")) {
					newHPref = tableRows[i-2].id;		
					newIndex = tableRows[i-2].getAttribute("PL_INDEX");
					newId = tableRows[i-2].id;
				}else {
	                newHPref = (tableRows[i-1].getAttribute("hPref") || tableRows[i-1].id );		
	                newIndex = tableRows[i-1].getAttribute("PL_INDEX");
	                newId = tableRows[i-1].id;
				}
            }
            if(forLeftTable || (grid && !(grid.bTreegrid || grid.bFixedCol))) {
				/* BUG-108583: Calculate Index in case of Optimized RD */
				var correctRowIndex = newIndex;
				if((grid.bReportDefinition || grid.pyPaginateActivity) && ((grid.pageMode != "Progressive Load" && grid.pageMode != "None") || grid.bCBOptimize)) {
					/*BUG-158828: null check for grid.currentPageIndex to avoid computation and setting of 'correctRowIndex' to 'NaN' */
					if(grid.currentPageIndex != null){
						/* BUG-159074: Calling Grid Api instead of calculating row index */
						correctRowIndex = grid.getFirstLoadedRowIndex() + parseInt(newIndex) - 1;
					}
				}
				if(grid.bNumberedSkin){
					this.setLeftTableValues(eachRow,correctRowIndex);
				}
            }
			if(grid && grid.editConfig==grid.EDIT_EXPANDPANE && !forLeftTable) {
				var detailsDiv = pega.ctx.dom.querySelector("[id='rowDetail"+currHPref+"']");
				if(detailsDiv){
					pega.u.d.updatePropertyRef(detailsDiv,prevHPref, newHPref);
				}
			}
            /* Replace $ in currHPref with \$ for string replacement */
             currHPref = currHPref.replace(/\$/g, "\\$");
			 var dataSrcVal;
       var gridObj;
      if (typeof Grids !== "undefined" && Grids) {
        gridObj = Grids.getElementsGrid(eachRow);
      }
			 if(gridObj){
			   dataSrcVal = gridObj.dataSourceRef;
			}
			pega.u.d.updateHandles(eachRow,currHPref,newHPref, currIndex, newIndex, newId,dataSrcVal);
			}


        /* BUG-79770: updateHandles api updating deleted row index to previous(current index - 1) row index
         * Issue is because of evaluateClientConditions api api calling before deleting row from dom.
         * Moving this api call to loadRow api in pzPega_ui_Grid.js
        if (pega.ui.ChangeTrackerMap.getTracker().changedPropertiesList.length > 0) {
            //OGRD - On Grid Row Delete
            pega.u.d.evaluateClientConditions('OGRD',null,true,true);
        }
        */
        forLeftTable = false;
    }
}
 
pega.ui.Doc.prototype.updatePropertyRef = function(detailsDiv,prevHPref, newHPref){
	var detailsRow = detailsDiv.parentNode.parentNode;
	var detailsContent = detailsDiv.innerHTML; 
	var prevEntryHandle = pega.ui.property.toReference(prevHPref);
	prevEntryHandle = prevEntryHandle.replace(/\(/g, "\\(").replace(/\)/g, "\\)");
	var newEntryHandle = pega.ui.property.toReference(newHPref);
	var regex = new RegExp(prevEntryHandle, "g");
	if(detailsContent.match(regex)) {
		detailsContent = detailsContent.replace(regex, newEntryHandle); 
		//this is a hack for the innerHTML thats removing all/some of the scripts tags which are inside the content. Fix for BUG-27477
		detailsContent = "&nbsp" + detailsContent;
		detailsDiv.innerHTML = detailsContent;
		detailsDiv.removeChild(detailsDiv.firstChild); 
	}
	/*update the entry handles in the details row*/
	pega.u.d.updateInnerHTML(detailsRow,prevHPref, newHPref);
}
pega.ui.Doc.prototype.focusNewRow = function(rowInfo){
	if(!rowInfo || !rowInfo.length || rowInfo.length < 3)
		return;
	this.getFocusOnNewRow(rowInfo[0], rowInfo[1], rowInfo[2]);
}

pega.ui.Doc.prototype.updateHandlesAfterInsert = function(tableInfo) {
  
    if(!tableInfo || !tableInfo.length || tableInfo.length < 2)
		return;
	var indexInList = tableInfo[0];
	var tables = tableInfo[1];
    var grid = tableInfo[2];
	
    if(!tables || !tables.length || tables.length == 0)
        return;

	var forLeftTable = false;
	var grid;
	if(tables.length == 2 && grid) {
		forLeftTable = true;
	}
	if(grid && grid.editConfig == grid.EDIT_EXPANDPANE) {
			indexInList = grid.getIndex(indexInList);  
	}
    for(var tIndex = 0; tIndex < tables.length; tIndex++) {
		if(tIndex == 0 && grid && !grid.bTreegrid && !grid.fixedCol) {
			forLeftTable = false;
			continue;
		}
        var table = tables[tIndex];
        if(forLeftTable) {
			var tableRows = pega.util.Dom.getChildren(table);
	        var numRows = tableRows.length;
        }else {
			var tableRows = table.rows;
	         var numRows = tableRows.length;		
        } 
		var totalRows;
		if(grid && grid.bGrid == true){	
			totalRows = numRows-1;
			if(grid.editConfig==grid.EDIT_EXPANDPANE && (tableRows[totalRows].id==null || tableRows[totalRows].id==""))
				totalRows = totalRows-1;
		}else {
			totalRows =  numRows-2;
		}
        var currHPref, prevHPref, newHPref, currIndex, prevIndex, newIndex, newId, prevId = ""; 
        for (var i = totalRows; i > ( parseInt(indexInList)); i--) {
            var eachRow = tableRows[i];
            var currHPref = (eachRow.getAttribute("hPref") || eachRow.id);
			if(grid && grid.editConfig==grid.EDIT_EXPANDPANE && !currHPref) {
				continue;
			}
            var newHPref = prevHPref;
            prevHPref = currHPref;

            currIndex =eachRow.getAttribute("PL_INDEX");
            newIndex = prevIndex;
            prevIndex = currIndex;

            newId = prevId;
            prevId = eachRow.id;
            
            if (i == totalRows) {
                var posValIndex = currHPref.search(/[0-9]*$/);
                var posVal = currHPref.substring(posValIndex);
                if(posVal && !isNaN(posVal)) {
                    posVal = (parseInt(posVal)) + 1;
                    newHPref = currHPref.substring(0, posValIndex) + posVal;
                    newIndex = posVal;
                    var currId = eachRow.id;
                    newId = currId.replace(new RegExp(currIndex + "$"), posVal);
                }
                else				
                    continue;
            }
            if(forLeftTable || (grid && !(grid.bTreegrid || grid.bFixedCol))) {
				/* BUG-103843: Calculate Index in case of Optimized RD */
				var correctRowIndex = newIndex;
				if((grid.bReportDefinition || grid.pyPaginateActivity) && ((grid.pageMode != "Progressive Load" && grid.pageMode != "None") || grid.bCBOptimize)) {
					/*BUG-158828: null check for grid.currentPageIndex to avoid computation and setting of 'correctRowIndex' to 'NaN' */
					if(grid.currentPageIndex != null){
						/* BUG-158971: Calling Grid Api instead of calculating row index */
						correctRowIndex = grid.getFirstLoadedRowIndex() + parseInt(newIndex) - 1;
					}
				}
				if(grid.bNumberedSkin){
					this.setLeftTableValues(eachRow,correctRowIndex);     
				}
            }
			if(grid && grid.editConfig==grid.EDIT_EXPANDPANE && !forLeftTable) {
				var detailsDiv = pega.ctx.dom.querySelector("[id='rowDetail"+currHPref+"']");
				var detailsRow = null;
				if(detailsDiv){
					pega.u.d.updatePropertyRef(detailsDiv,prevHPref, newHPref);
				}
			}
            /* Replace $ in currHPref with \$ for string replacement */
            currHPref = currHPref.replace(/\$/g, "\\$");
          	var dataSrcVal;
            var gridObj
             if (typeof Grids !== "undefined" && Grids) {
             gridObj = Grids.getElementsGrid(eachRow);
             }
			if(gridObj){
			 dataSrcVal = gridObj.dataSourceRef;
             }    
            pega.u.d.updateHandles(eachRow,currHPref,newHPref, currIndex, newIndex, newId,dataSrcVal);			
        }

        if (pega.ui.ChangeTrackerMap.getTracker().changedPropertiesList.length > 0) {
            /* OGRI - On Grid Row Insert*/
            pega.u.d.evaluateClientConditions('OGRI',null,true,true);
        }

        forLeftTable = false;  
    }
}



pega.ui.Doc.prototype.isEmptyJSON = function(jsonObj) {
	var emptyJSON = true;
	for (var prop in jsonObj) {
		emptyJSON = false;
		break;
	}
	return emptyJSON;
}

/*BUG-160193: Introduced new function for updating the delete icon title */
pega.ui.Doc.prototype.updateDeleteIconTitle = function(deletebuttons, currIndex, newIndex){
	for(var i=0;i<deletebuttons.length;i++){
			if(deletebuttons[i]){
				var delButton = deletebuttons[i];
				if(delButton.tagName == "I"){
					delButton = delButton.parentNode ;
				}
				var currAlt = delButton.getAttribute("title") || delButton.getAttribute("alt");
				if(currAlt){
					var newAlt = currAlt.replace(currIndex , newIndex);
					delButton.setAttribute("alt", newAlt);
					delButton.setAttribute("title", newAlt );
				}
			}
	}
}

pega.ui.Doc.prototype.updateHandles = function(eachRow , currHPref, newHPref, currIndex, newIndex, newId, dataSrcVal)
{   
	if(!eachRow.getAttribute("hPref")){
		var grid = true;
	}

	/*pega.u.d.updatePOIJSON(currIndex, newIndex, newHPref);*/

	eachRow.setAttribute("PL_INDEX", newIndex); 	  
	if(!grid){
		var currHPref = eachRow.getAttribute("hPref");
		eachRow.setAttribute("hPref", newHPref);
	}else{
		var currHPref = eachRow.id;
		eachRow.id = newId;
      	// Added below code for handling data-test-id updation logic for Add and delete and reordering elements.
       
      	if(dataSrcVal && eachRow.getAttribute("data-test-id"))
        {
          	var dataSrcHandle = pega.ui.property.toHandle(dataSrcVal);
        	var updatedID = eachRow.getAttribute("id");
          	var automationID = eachRow.getAttribute("data-test-id");
            var testID = automationID.split("-")[0];
            updatedID = updatedID.replace(dataSrcHandle,"");
            updatedID = updatedID.replace(/\$l/g, "_test_ID");
          	updatedID = updatedID.replace(/\$/g, "_test_ID");
            var splitArray = updatedID.split("_test_ID");
            var level = 0;
            for(var i = 0; i < splitArray.length; i++) { 
              if (splitArray[i].match(/\d+/)) {
                if(level > 0) {
                  testID += "-L" + level + "R" + splitArray[i];
                }
                else {
                  testID += "-R" + splitArray[i];
                }
                level++;
              }
            }
            eachRow.setAttribute("data-test-id", testID);
        }
      // Added above code for handling data-test-id updation logic for Add and delete and reordering elements.
    }
	 
	
	var dom = pega.util.Dom;
	/* BUG-160193: Update delete icon title for anchor tag with iconDelete className (or) i tag with iconDelete classname (or) button with id RLDel */
	var delButton = dom.getElementsByClassName("iconDelete", "I", eachRow) ; 
	if(delButton.length > 0){
		this.updateDeleteIconTitle(delButton, currIndex, newIndex);
	}
	delButton = dom.getElementsByClassName("iconDelete", "A", eachRow) ;
	if(delButton.length > 0){
		this.updateDeleteIconTitle(delButton, currIndex, newIndex);
		}/*BUG-515924 - Handle pxDeleteListItem */
  
    var deleteIconSelector="a[title='Delete item "+currIndex+"'],a[title='Delete item "+currIndex+" ']";
    delButton=eachRow.querySelectorAll(deleteIconSelector);
    if(delButton.length > 0)
      		this.updateDeleteIconTitle(delButton, currIndex, newIndex);
  
	delButton = dom.getElementsById("RLDel", eachRow, "BUTTON");
	if(delButton){
		this.updateDeleteIconTitle(delButton, currIndex, newIndex);
	}
	
	// Get the cells in the row
	if(eachRow.tagName=="LI") {
		var eachRowUL = dom.getChildren(eachRow)[0];
		var eachRowCells = dom.getChildren(eachRowUL);
	}else {
		var eachRowCells = eachRow.cells;
	}
	if(grid){
		var rowEle = (eachRow.tagName=="LI")?eachRowCells[eachRowCells.length-1]:eachRow;
		/*Update the class name of TR */
		if(newIndex % 2 == 0) {
			if(dom.hasClass(rowEle,'oddRow')){
				dom.replaceClass(rowEle,'oddRow','evenRow');
			}
		}else {
			if(dom.hasClass(rowEle,'evenRow')){
				dom.replaceClass(rowEle,'evenRow','oddRow');
			} 	
		}
	}

	for (var j = 0; j < eachRowCells.length; j++) {				
		var eachCell = eachRowCells[j];			
		/***To update BASE_REF and included section tDIV index attr, only in case of section included in a RL ***/
		var baseRef = eachCell.getAttribute("BASE_REF");
		if( baseRef !== null ) {
			baseRef = pega.ui.property.toReference(newHPref);
        			eachCell.setAttribute("BASE_REF", baseRef );
			/** To update Section DIV INDEX attr **/
			var allDivs = eachCell.getElementsByTagName("DIV");
			for(var i = 0; i < allDivs.length; i++) {
				var sectionDiv = allDivs[i];
				var sectionIndex = sectionDiv.getAttribute("INDEX");
				if( sectionIndex != null ) {
					sectionIndex = sectionIndex.replace(currIndex, newIndex);
					sectionDiv.setAttribute("INDEX", sectionIndex );
				}
			}
		}
		var inputEle = eachCell.getElementsByTagName("INPUT");
		var selectEle = eachCell.getElementsByTagName("SELECT");
		var textAreaEle = eachCell.getElementsByTagName("TEXTAREA");
		var spanEle = eachCell.getElementsByTagName("SPAN");
		var field_sets = new Array(inputEle, selectEle, textAreaEle,spanEle);
		var labels = eachCell.getElementsByTagName("LABEL");
		for(var x = 0; x < field_sets.length; x++) {
			var set = field_sets[x];
			for(var y = 0; y < set.length; y++) {
				var oldName = field_sets[x][y].getAttribute("name");
				if(oldName) {
					var newName = oldName.replace(new RegExp(currHPref.replace(/\$/g, "\\$"), "g"), newHPref);
					field_sets[x][y].setAttribute("name", newName);
          field_sets[x][y].setAttribute("id", pega.u.d.getCRC32HashId(newName));
				}
			}
		}
    /*HFix-48994 after reorder setting id and label for also along with checked attribute*/
    $(eachCell).find("input[type='radio']").each(function(){
      var checkedVal = $(this).parents("div[data-ctl='RadioGroup']").attr("radvalue");
      $(this).attr("id",$(this).attr("id") + $(this).val());
      var label = $(this).next();
      if(label && label.prop("tagName") && label.prop("tagName").toLowerCase() == "label"){
        label.attr("for", $(this).attr("id"));
      } 
      if(checkedVal == $(this).val()){
        $(this).prop("checked", true);
      }
    });
    
		// Update the 'for' attribute of the labels
		for (var z = 0; z < labels.length; z++) {
		   var forAttrib = labels[z].attributes.getNamedItem("for");
		   if (forAttrib) {
			var val = forAttrib.value;
 			var oldId = val;
			if (oldId) {
                var ele = dom.getElementsById(oldId,eachRow);
				if(ele) {
					var newForAttrib = val.replace(currIndex, newIndex);
					if (val.indexOf("_ri_") != -1) {
						newForAttrib = val.substring(0,(val.indexOf("_ri_")+4)) + newIndex;
					}
					forAttrib.value = newForAttrib;	
					// Updating the ID of the input elements which could be used by label for attrib
					var newId = oldId.replace(currIndex, newIndex); 
					if (oldId.indexOf("_ri_") != -1) {
						newId = oldId.substring(0,(oldId.indexOf("_ri_")+4)) + newIndex;
					}
					ele[0].setAttribute("id", newId);						
				}
			}				
		  }
	  	}
	}
	pega.u.d.updateInnerHTML(eachRow,currHPref, newHPref);
}

/*
 @protected This function is used to focus the correct element of the pyGridPaginator section, after refresh upon a pagination action of a grid 
 @param $HTMLElement$paramcontainerElement - DOM reference of the Grid layout 
 @return $void$
*/
pega.ui.Doc.prototype.getFocusOnPaginatorElement = function(containerElement, gridActionClass){
	/* BUG-145096: Focusing the correct grid pagination bar */
	var gridActionElements = pega.ctx.dom.querySelectorAll("div."+gridActionClass, containerElement);
	pega.util.Dom.getElementsBy(function(ele) {
		return ele.id === "RULE_KEY" 
			&& ele.getAttribute("node_type") === "MAIN_RULE" 
			&& ele.getAttribute("objclass") === "Rule-HTML-Section" 
			&& ele.getAttribute("node_name") === "pyGridPaginator";
	}, "div", gridActionElements[0], function(pgEle) {
		var focusElemArr = pega.util.Dom.getElementsById("pyGridActivePage",pgEle);
		if(focusElemArr instanceof Array && focusElemArr.length > 0) {
			focusElemArr[0].focus();
			focusElemArr[0].focus();
		}
	});
}

/*
 @protected Gets the focus on the new row that was added to the list
 This function is used to focus the new row when we add a new row to the repeating layout.
 When we have a section included inside the repeating layout cells, the first element of the embedded section is focused.
 @param $String$paramPropertyName - Property name
 @param $Int$paramIndexInList - Current index
 @return $void$
*/

pega.ui.Doc.prototype.getFocusOnNewRow = function(paramPropertyName, paramIndexInList, reloadElement){
	if(pega.u.d.isAccessible && !pega.u.d.bFocused){
		/* BUG-221357: HFIX:Accesibility:Section in repeat layout is not keyboard ac */
      	/* Previously getFocusonNewRow was called without arguments in setTimeout method. This method needs to be called with 3 arguments */
      	window.setTimeout(function(){
          	pega.u.d.getFocusOnNewRow(paramPropertyName, paramIndexInList, reloadElement);
        }, 100);  
		pega.u.d.bFocused = true;
		return;
	}

	var srcSourceIndex = -1;
	var nextSourceIndex;
	var nextElement;
	var isInsert = false;
    var strPropertyName;
	if(typeof(paramPropertyName)=="string"){
		strPropertyName = paramPropertyName;
	}
  	var indexInList = pega.ctx.indexInList;
	if(typeof(paramIndexInList)!="undefined"){
		if(paramIndexInList===""){
			isInsert = true;
			paramIndexInList = 0;
		}
		if(paramIndexInList == -1)
			paramIndexInList = 0;
		indexInList = paramIndexInList;
      	pega.ctx.indexInList = paramIndexInList;
	}
	try{
		var indexOfNewRow = parseInt(indexInList)+1;
		var strTrId = "";
		if(isNaN(indexOfNewRow)){
			strTrId = trim(strPropertyName)+indexInList;
		}
		else{		
			strTrId = trim(strPropertyName)+indexOfNewRow;
		}
		var parentRow = pega.util.Dom.getElementsById(strTrId, reloadElement);
		var newRows = parentRow;
		if(parentRow) parentRow = parentRow[0];
		
		if(isInsert && (indexOfNewRow == 1) && (parentRow)){
			var tmpParentRow = parentRow;
			var tmpIndexOfNewRow = indexOfNewRow;
			while(tmpParentRow != null){
				tmpParentRow = pega.util.Dom.getElementsById(trim(strPropertyName) + tmpIndexOfNewRow, reloadElement);
				tmpIndexOfNewRow++;
			}
			tmpIndexOfNewRow = tmpIndexOfNewRow - 2;
			parentRow = pega.util.Dom.getElementsById(trim(strPropertyName) + tmpIndexOfNewRow, reloadElement);
			var newRows = parentRow;
			if(parentRow) parentRow = parentRow[0];
		}
		
		if(newRows && newRows.length){
			for(var i=0;i<newRows.length;i++) {
			var parentRow = newRows[i];
			if(parentRow) {

			var inputTypes = new Array("input", "select", "textarea", "button", "a");
			for(var k=0; k<inputTypes.length; k++){
				var inputElements = parentRow.getElementsByTagName(inputTypes[k]);
				for(var j=0; j<inputElements.length; j++){
                    var eltSourceIndex;
					if(inputElements[j].sourceIndex){
						eltSourceIndex = inputElements[j].sourceIndex;
					}else{
						eltSourceIndex = pega.u.d.getSourceIndex(inputElements[j], reloadElement);
					}
					/*check for display of the elements for focusing BUG-47285*/
					if(srcSourceIndex == -1 && (inputElements[j].type != "hidden") && inputElements[j].style.display!="none"){
						srcSourceIndex = eltSourceIndex;
					}
					if((srcSourceIndex >= eltSourceIndex)  && (inputElements[j].type != "hidden") && inputElements[j].style.display!="none"){
						if(nextSourceIndex == null){
							nextSourceIndex = eltSourceIndex;
							nextElement = inputElements[j];
						}else if(nextSourceIndex > eltSourceIndex){
							nextSourceIndex = eltSourceIndex;
							nextElement = inputElements[j];						
						}
					}
				}
			}

			if(nextElement && nextElement.disabled==true && nextElement.getAttribute("DSSource")){
				var counter = 0;
				var funcRef = function(){
					try{
						if(nextElement.disabled == true && counter<5){
							counter++;
							window.setTimeout(funcRef,500);
							return;
						}
						nextElement.focus();
						if(document.activeElement != nextElement){
							nextElement.focus();
						}
					}catch(exception){}
				};
				window.setTimeout(funcRef,500);
				return;
			}else{
				if(nextElement) {
				nextElement.focus();
				if(document.activeElement != nextElement){
					nextElement.focus();
				}
				return;
				}
			}
			   }
			}			
		}
		if (typeof(paramIndexInList)!="undefined"  && paramIndexInList!=0 && parentRow==null )
			pega.u.d.getFocusOnNewRow(paramPropertyName, paramIndexInList-1, reloadElement);
	}catch (exception){}
}

/*
 * gets the layout number in a section
 */

pega.ui.Doc.prototype.getLayoutIndex= function(element){

	while(element&& element.tagName!="BODY"){
		if(element.getAttribute("section_index")){	
			return element.getAttribute("section_index");
		}
		element=element.parentNode;
	}
	return null;
},
/*
 * common Append code for RepeatingLayout bound to List or Group
 */

pega.ui.Doc.prototype.append = function(payLoad) {
	var repeatProperty = payLoad.repeatProperty,
	className = payLoad.className,
	indexElt = payLoad.indexElt,
	pageName = payLoad.pageName,
	customActivity = payLoad.customActivity,
	eventOrTarget = payLoad.eventOrTarget,
	partialRefresh = payLoad.partialRefresh,
	repeatType = payLoad.repeatType;
	var grid = payLoad.grid;
	var index = "";
	var domAction="insert";
	var repeatBaseRef = "";
         var repeatPrimaryPage = "";
	if(typeof(indexElt) != "string" && typeof(indexElt) != "number") {
		if(indexElt.nodeName == "TR"){
			index = indexElt.getAttribute("PL_INDEX");
		}
		else if(indexElt.nodeName == "BUTTON"){
			index = "";
		}
		else{
			index = this.getRepeatRow(indexElt);
		}
	}
	else{
		if(payLoad.grid && indexElt!= "") {
			var indexElt = grid.rightBodyTbl.rows[grid.getIndex(indexElt)];
			index = indexElt.getAttribute("PL_INDEX");
      /*BUG-625438 : Calculate index only if it is parent node*/
			if(grid.currentPageIndex && grid.currentPageIndex!="" && grid.pyPaginateActivity=="" && grid.pageMode!="Progressive Load" ) {
        var isTopLevelRow = true;
        if(grid.bTree || grid.bTreegrid){
        var rowPropHandle = indexElt.getAttribute("id");
        var rowRefProp = pega.ui.property.toReference(rowPropHandle);
        var rowRefPropLength = rowRefProp.split(".").length;
        var gridSourcePropLength = grid.dataSourceRef.split(".").length;
        if(rowRefProp.startsWith(grid.dataSourceRef) &&  gridSourcePropLength !== rowRefPropLength){
				  isTopLevelRow = false;
          }
        }
        if(isTopLevelRow){
          	  index = index - ((grid.currentPageIndex-1)*grid.rangeSize);
        }
			}
		}else{
			index = indexElt;
		}
	}
	var rcvdEvent = false;
	/* caller sets the eventOrTarget to either Event object or to the target of original event */
	var eventTarget = pega.util.Event.getTarget(eventOrTarget);
	if(eventTarget) {
		/* eventOrTarget has Event object */
		rcvdEvent = true;
		pega.util.Event.stopEvent(eventOrTarget);
	}
	else {
		/* eventOrTarget has target of the original Event object */
		if(payLoad.grid && indexElt!= "") {
			eventOrTarget = indexElt;
		}
		eventTarget = eventOrTarget;
	}
	/* default the values to those for group */
	var repeatPropKey = "PageGroupProperty";
	var indexKey = "Subscript";
	var actvityName = "AppendToPageGroup";
	var defaultTab = index;
	var reloadElem = eventTarget;
	
	var dom = pega.util.Dom;
	if(repeatType!="list")
	{	var grid = pega.ctx.gridObj;
		pega.ctx.gridObj=null;
	}

	if(partialRefresh && partialRefresh === "true") { 
		var domElement = null;
		var beforeDomAction = null;
		var beforeParams = null;
		if(grid) {
			var gridTables = [grid.leftBodyUL , grid.rightBodyTbl];			
			domElement = new Array();
			if(grid.bGrid != true ){
				domElement.push(null); /* push left row*/
				domElement.push(gridTables[1].rows[gridTables[1].rows.length-1]); /* push right row*/
			}else{
				domElement.push(gridTables[0]); /* push left row*/
				domElement.push(dom.getFirstChild(gridTables[1])); /* push right row*/
				domAction="append";
			}
			beforeDomAction = grid.loadGridRows;
			beforeParams = new Array(index, gridTables, repeatType );			
		}else {
			domElement =dom.getAncestorByTagName(eventTarget, "tr");
			var targetTable = dom.getAncestorByTagName(domElement, "table");
			if(repeatType == "list"){ 
				if(targetTable.getAttribute('PL_PROP') == null){
					domElement =dom.getAncestorByTagName(targetTable, "tr");
				}
			}else{
				if(targetTable.getAttribute('PG_PROP') == null){
					domElement =dom.getAncestorByTagName(targetTable, "tr");
				}
			}
			var afterDomAction = this.focusNewRow;
		}
		
		var repeatTable = this.getRepeatTable(indexElt);
		//On enter key press in repeat layout, event is received. For, Repeat Layout(Page Grp) inside Repeat layout(Page List), on enter key press of Page Group don't append a row as it isn't supported.
		if(rcvdEvent && eventOrTarget.type=="keypress" && eventOrTarget.keyCode==13) {
			var eventFiredTable = this.getRepeatTable(eventTarget);
			//As keypress event is not fired on page group table, repeat Table and eventFired table will be different
			if(repeatTable!=eventFiredTable) {
				return;
			}
		}
		var afterParams = new Array (repeatProperty, index, repeatTable);
	}
	var baseRef = this.getBaseRef(eventTarget);
	if(repeatType == "list") {
		/* reset the values of variables for list */
		repeatPropKey = "PageListProperty";
		indexKey = "IndexInList";
		actvityName = "AppendToPageList";
		defaultTab = "ADD";
		
		if(partialRefresh && partialRefresh === "true") { 
			if(index !== "") {
				if(!grid) {
					domElement = dom.getNextSibling(indexElt);/*the new incoming row should be inserted before the sibling of indexElt which is row*/
					beforeDomAction = this.updateHandlesAfterInsert;
					beforeParams = new Array(index, [repeatTable]);
				}
				else if(grid.getIndex(index)<=(gridTables[1].rows.length-2) || grid.action == "INSERTBEFORE" || grid.action == "ADDCHILD"){ /* it is grid on List. For insertbefore, always go into the block*/
					domAction="insert";
					if(gridTables && gridTables.length == 2) {
						domElement = new Array();
						var rtIndex = indexElt.rowIndex;
						if(grid.bTreegrid || grid.fixedCol) {
							var leftRow = dom.getElementsById(indexElt.id, gridTables[0])[0];
							var ul = leftRow.parentNode;
						}
						if(grid.action && grid.action == "INSERTBEFORE") {
							domElement.push(leftRow);	
							domElement.push(gridTables[1].rows[rtIndex]);
							index = index-1;
							if(grid.editConfig==grid.EDIT_EXPANDPANE) {
								if(!grid.bPageGroup){
									var toDeduct = 0;
									if(grid.currentPageIndex && grid.rangeSize){
									    toDeduct = (grid.currentPageIndex-1)*grid.rangeSize;
									}
									beforeParams[0] = afterParams[1] = indexElt.getAttribute("PL_INDEX")-toDeduct;
								}else {
									beforeParams[0] = afterParams[1] = grid.getPGRowIndex(rtIndex);
								}
							}else {
								beforeParams[0] = afterParams[1] = rtIndex;
							}
						}else {
							//if pageName is there it's at a sub-level so, don't increment the number for UL as it doesn't have extra LIs in the sub level
							if(payLoad.appendChild) {
								ul = dom.getElementsById("gridNode", leftRow, "UL")[0];
								domElement.push(ul);
							}else {
								if(pageName) {
									if(index<dom.getChildren(ul).length) { 
										var nextLI = dom.getChildren(ul)[index];
										rtIndex = dom.getElementsById(nextLI.id, grid.rightBodyTbl , "TR")[0].rowIndex-1;
										domElement.push(nextLI);
									}else {//Push the parent UL in case of appending to the last child of a node.
										domElement.push(ul);
									}
								}else{ 
									if(ul){
										domElement.push(dom.getChildren(ul)[parseInt(index,10) + 1]); /* push left row*/
									}else {
										domElement.push(leftRow);
									}
								}
							}
						
							if(grid.bTreegrid){
								if((gridTables[1].rows.length-1)<=rtIndex) { //For treegrid, when u add child for the last row, this scenario comes into picture
									domElement.push(dom.getFirstChild(grid.rightBodyTbl)); //just push the grid's right body table.
								}else{ 
									var childrenUL = dom.getChildren(leftRow);
									if(childrenUL.length == 2 ){
										var childrenExist = true;
										var childUL = childrenUL[1];
										while(childrenExist) {
											var lastChild = dom.getLastChild(childUL);
											if(!lastChild)
												break;
											if(lastChild) {
												var childLeftrow = lastChild.id;
												var childRightrow = dom.getElementsById(childLeftrow, grid.rightBodyTbl , "TR")[0];
												rtIndex = childRightrow.rowIndex;
												if(dom.getChildren(lastChild).length==1) {
													childrenExist = false;
													break;
												}
												childUL = dom.getChildren(lastChild)[1];
											}
										}
									}
									domElement.push(gridTables[1].rows[parseInt(rtIndex,10) + 1]); /* push right row*/
								}
							}else{
								if(grid.editConfig==grid.EDIT_EXPANDPANE) {
									var rowDetailDiv = dom.getElementsById("rowDetail"+indexElt.id, gridTables[1]);
									if(rowDetailDiv && rowDetailDiv[0]) {
										domElement.push(gridTables[1].rows[parseInt(rtIndex,10) + 2]); /* push right row*/
									}else {
										domElement.push(gridTables[1].rows[parseInt(rtIndex,10) + 1]); /* push right row*/
									}
								}else {
									domElement.push(gridTables[1].rows[parseInt(rtIndex,10) + 1]); /* push right row*/
								}
							}
							if(grid.editConfig==grid.EDIT_EXPANDPANE) {
								if(!grid.bPageGroup){
									var toDeduct = 0;
                                  	var isNonOptimizeClipboard = !grid.bReportDefinition && grid.pyPaginateActivity=="";/*BUG-229642: In case of Non Optimize Clipboard dont calculate toDeduct */
									if(grid.currentPageIndex && grid.rangeSize && isNonOptimizeClipboard){
									    toDeduct = (grid.currentPageIndex-1)*grid.rangeSize;
									}
									beforeParams[0] = afterParams[1] = indexElt.getAttribute("PL_INDEX")-toDeduct;
								}else {
									beforeParams[0] = afterParams[1] = grid.getPGRowIndex(rtIndex);
								}
							}else {
								beforeParams[0] = afterParams[1] = rtIndex;
							}
							//When children are expanded for the last row in tree grid and add sibling is clicked.
							if(grid.bTreegrid && !pageName && !dom.getChildren(ul)[parseInt(index,10) + 1]) {
								domElement = new Array();
								domElement.push(gridTables[0]);
								domElement.push(dom.getFirstChild(gridTables[1]));
								beforeParams[0] = afterParams[1] = gridTables[1].rows.length-1;
							}
						}//end of else 
						if(!domElement[1]) {
							domElement[1] = dom.getFirstChild(gridTables[1]);
						}
						if(!domElement[0] && (grid.bTreegrid || grid.fixedCol)) {
							domElement[0] = gridTables[0];
						}
					}
				}
			}
		}else if(partialRefresh && partialRefresh === "false"){
			if(grid && grid.action=="INSERTBEFORE")
				 index=index-1;
		}
		
		if(baseRef!="") {	
			var repeatObject = pega.u.d.getRepeatObject(eventTarget,true);
			if(!repeatObject) {
				var baseRefElement= eventTarget;
				while(baseRefElement!=null && baseRefElement.tagName.toUpperCase()!="BODY"){	
					if(baseRefElement.getAttribute("BASE_REF") && baseRefElement.getAttribute("BASE_REF")!="" )
						break;
					baseRefElement=baseRefElement.parentNode;
				}
				baseRef=this.getBaseRef(baseRefElement.parentNode);
				reloadElem=baseRefElement.parentNode;
			}	
		}
		if(partialRefresh && partialRefresh === "true") {
			if(index !== "")
				this.registerFocusIn(reloadElem);
		}
	} /* if repeatType == "list"*/
	var bFormSubmit = this.submitForm();
	
	if(customActivity!=null && customActivity!=""){
		actvityName = customActivity;
	}
	/* Create the SafeURL object to call to the reloadRepeatLayout */
	var strActionSF=new SafeURL();
	strActionSF.put("BaseReference", baseRef);
	strActionSF.put(repeatPropKey, repeatProperty);
	strActionSF.put("ClassName", className);

	if(grid) {
		strActionSF.put("EditRow", "true");
		if(grid.bRODetails){
			strActionSF.put("bRODetails","true");
		}
		if(grid.currentPageIndex && grid.currentPageIndex!="" && grid.pyPaginateActivity=="" && grid.pageMode!="Progressive Load") {
			if(index==="") {
				var totalPages = (grid.totalRecords%grid.rangeSize==0)?Math.floor(grid.totalRecords/grid.rangeSize):Math.ceil(grid.totalRecords/grid.rangeSize);
				/* BUG-148981 - If there are no records after filtering, totalPages becomes 0 */
				var indexValue = (totalPages==grid.currentPageIndex || grid.totalRecords == 0)?"":(grid.currentPageIndex*grid.rangeSize);
				strActionSF.put(indexKey, indexValue);
			}else {
				strActionSF.put(indexKey, index + ((grid.currentPageIndex-1)*grid.rangeSize));
			}
		}else {
			strActionSF.put(indexKey, index);
			/*pass the startIndex when a custom paginate activity is specified*/
			if(grid.currentPageIndex!="") {
				strActionSF.put("startIndex",((parseInt(grid.currentPageIndex,10)-1)*parseInt(grid.rangeSize,10)+1));
			}
		}
		if(grid.editConfig != grid.EDIT_READWRITE && partialRefresh != "true") {
			strActionSF.put("EditRow", "false"); 
		}
		if(partialRefresh != "true" && payLoad["refreshLayout"]) {
			strActionSF.put("refreshLayout", "true"); 
		}
        //TASK-143235  Add row doesn't work in RD sourced grid with other edit modes  Changes Start
		if(grid.action=="INSERTAFTER" || grid.action=="INSERTBEFORE") {
			if(grid.bReportDefinition ||  grid.pyPaginateActivity){
				var startIndex = (grid.currentPageIndex - 1) * grid.rangeSize + 1;
				strActionSF.put("startIndex", startIndex);
                    	}
		}
		//TASK-143235  Add row doesn't work in RD sourced grid with other edit modes  Changes End

		/* "lastRowToRetrieve" is used in getLastRows() to get the markup for last row  */
		if(payLoad.lastRowToRetrieve && partialRefresh && partialRefresh == 'true') {
			if(grid.action=="INSERTAFTER" || grid.action=="INSERTBEFORE") {
				strActionSF.put("lastRowToRetrieve", payLoad.lastRowToRetrieve);
			}
		}
		
	}else {
		strActionSF.put(indexKey, index);
	}
	
	

	/* If the form submit is enabled set the Finishing Activity */
	if(bFormSubmit){
		strActionSF.put("FinishingActivity","Show-Harness");
	}
	else{
		/* If the form submit is disabled set the finishing activity to empty */
		strActionSF.put("FinishingActivity","");
	}

	/* Set the page name */
	if(pageName){
		strActionSF.put("PageName",pageName);
	}

	if(grid && grid.bTreegrid && payLoad.pyPropRef) {
		strActionSF.put("pyPropRef",payLoad.pyPropRef);
	}
	if(grid && grid.action){
		strActionSF.put("bTreegrid",grid.bTreegrid);
		strActionSF.put("gridAction",grid.action);
		
		if(grid.gridPreActivity) {
			strActionSF.put("gridPreActivity", grid.gridPreActivity);
		}
		if(grid.gridPostActivity) {
			strActionSF.put("gridPostActivity", grid.gridPostActivity);
		}
	}
	var focusParams = new Array(repeatProperty, index);
		/* If it is a tabbed repeating layout, set the default tab */
	var parentDiv = this.getRepeatObject(eventTarget);
	if(parentDiv && parentDiv.tagName == 'DIV') {
		var tabGroupId = parentDiv.getAttribute("tabGroupId");
		dom.getElementsByName("EXPANDED"+tabGroupId, parentDiv)[0].value = defaultTab;
	}
	if(repeatType!="list" && grid)
		var repeatIndex=this.getLayoutIndex(grid.gridDiv);	
	else
	var repeatIndex=this.getLayoutIndex(parentDiv);
	if(!repeatIndex)
		repeatIndex="";
	
	if( partialRefresh && partialRefresh == 'true' ) {
		/* prepare partialParams key:value pairs object*/
		var partialParams = {
			partialTrigger : "appendTo" + repeatProperty+repeatIndex,
			/*List Based Triggering Story - Autobots 6.2 - gujas - Start*/
			listBaseRef: payLoad.listBaseRef,
			listPrimaryPage: payLoad.listPrimaryPage,
			property: repeatProperty,
			index : repeatIndex,
			/*List Based Triggering Story - Autobots 6.2 - gujas - End*/
			domElement : domElement,
			domAction : domAction,
			beforeDomAction : beforeDomAction,
			beforeParams : beforeParams,
			afterDomAction : afterDomAction,
			afterParams	: afterParams
		};
		if(grid){
			partialParams.beforeDomActionContext = grid;
			if(grid.bTreegrid) 
			partialParams.gridAddAction = payLoad.gridAction;
			partialParams.partialTrigger = "appendTo" + grid.property+repeatIndex;	

		}
				
	}
	if(grid) {
		strActionSF.put("gridActivity",actvityName);
		if(grid.editConfig==grid.EDIT_EXPANDPANE) {
			strActionSF.put("showOkCancel","true");
		}
		/*In case of filtered grid we should pass the grid's filtercriteria page in  the request */
		if(grid.bFilteredGrid) {
			strActionSF.put("pyGridFilterCriteriaPage", grid.gridFilterPage);
			/*Bug-122471: isReportDef param is needed for pzMatchesGridFilterCriteria RUF execution.*/
			if(grid.bReportDefinition) {
				strActionSF.put("isReportDef", grid.bReportDefinition);
			}
		}
		if(grid.refreshLayout || grid.bFilteredGrid) {
			if((grid.currentPageIndex && grid.currentPageIndex!="" && grid.pyPaginateActivity=="") || grid.pageMode=="Progressive Load") {
				/*for progressive load, currentPageIndex is not proper always. So, recompute based on row index*/
				var pageIndex;
				if(grid.pageMode=="Progressive Load") {
					if(typeof(grid.activeRow) != "undefined") {/*BUG-125069*/
						pageIndex = Math.ceil(grid.activeRow/grid.rangeSize);
					} else {
						pageIndex = 1;
					}
				} else {
					/* BUG-132331 */ pageIndex = grid.currentPageIndex;
				}
				
				strActionSF.put("currentPageIndex",pageIndex);
				strActionSF.put("pyPageSize",grid.rangeSize);
				if(grid.pageMode=="Progressive Load") {
					strActionSF.put("startIndex",1);
					strActionSF.put("recordsInCurrentPage", (pageIndex+1)*grid.rangeSize);
				}else {
					strActionSF.put("startIndex",((parseInt(pageIndex,10)-1)*parseInt(grid.rangeSize,10)+1));
				}
			}
		}
    /* BUG-521635: A flag to control message clearing from primary page */
    strActionSF.put('KeepGridMessages', pega.u.d.KEEP_GRID_MESSAGES === true ? 'true' : 'false');
		actvityName = "pzdoGridAction";
		if(grid.bGetSafeUrlObj)
			return  strActionSF;
	}
	if(grid && (grid.baseRef || grid.primPage) ){
		repeatBaseRef = grid.baseRef;
                  repeatPrimaryPage = grid.primPage;
	}else{
		repeatBaseRef = baseRef;
                  repeatPrimaryPage = pageName;
		
	}
	var ignoreBusyIndInterval = null;
	if (grid) {
		ignoreBusyIndInterval = true;
	}

	this.reloadRepeatLayout(actvityName, strActionSF.toQueryString(),
			      rcvdEvent ? eventOrTarget : null, focusParams, reloadElem,
			      partialRefresh == 'true' ? partialParams : null, ignoreBusyIndInterval,{listName:repeatProperty,"listBaseRef":repeatBaseRef,"listPrimaryPage":repeatPrimaryPage});
 }

 /*
  *	common Remove code for RepeatingLayout bound to List or Group
  */

 pega.ui.Doc.prototype.remove = function(payLoad) {
	var repeatProperty = payLoad.repeatProperty,
	className = payLoad.className,
	indexElt = payLoad.indexElt,
	pageName = payLoad.pageName,
	customActivity = payLoad.customActivity,
	eventOrTarget = payLoad.eventOrTarget,
	partialRefresh = payLoad.partialRefresh,
	repeatType = payLoad.repeatType;
	var grid = payLoad.grid;
    var listBaseRef = "";
	var listPrimaryPage = "";
	var index = "";
	/* indexElt comes blank for 'Button' control */
	if(!indexElt){
		index = this.getRepeatRow(pega.util.Event.getTarget(eventOrTarget));
	}
	else if(typeof(indexElt) != "string") {
		index = this.getRepeatRow(indexElt);
	}
	else{
		index = indexElt;
	}
	var rcvdEvent = false;
	/* caller sets the eventOrTarget to either Event object or to the target of original event */
	var eventTarget = pega.util.Event.getTarget(eventOrTarget);
	if(eventTarget) {
		/* eventOrTarget has Event object */
		rcvdEvent = true;
		pega.util.Event.stopEvent(eventOrTarget);
	}
	else {
		/* eventOrTarget has target of the original Event object */
		eventTarget = eventOrTarget;
	}

	/* Check for RD and return */
	var repeatTable = this.getRepeatTable(eventTarget);
	if(repeatTable && repeatTable.getAttribute("bReadOnly") == "true"){
		return false;

	}

	var baseRef = this.getBaseRef(eventTarget);

	/* default the values to those for group */
	var repeatPropKey = "PageGroupProperty";
	var indexKey = "Subscript";
	var actvityName = "RemoveFromPageGroup";
	var defaultTab = "";
	var currentRow = this.getRepeatRow(eventTarget, true);
	var indexToFocus = index;
	if(repeatType == "group")
		indexToFocus = pega.u.d.getNextRowSubscript(currentRow);
	
	if(partialRefresh && partialRefresh === "true") {
		var domElement = null;
		var beforeDomAction = null;
		var beforeParams = null;
		if(repeatType=="group"){
			var grid=pega.ctx.gridObj;
			pega.ctx.gridObj=null;
		}
		if(grid) {
			var gridTables = [grid.leftBodyUL , grid.rightBodyTbl];
			domElement = new Array();
			var rowId = currentRow.id;
			var hPref = rowId;
			domElement.push(pega.util.Dom.getElementsById(rowId, gridTables[0])[0]); /* push left row*/
			domElement.push(pega.util.Dom.getElementsById(rowId, gridTables[1])[0]); /* push right row*/						
			beforeDomAction = grid.loadGridRows;
			beforeParams = new Array(index, gridTables, repeatType);
			if(indexToFocus)
				var afterDomAction = grid.callInitGridsAndFocusRow;	
						
		}
		else {
			domElement = currentRow;
			if(indexToFocus){	
				var afterDomAction = this.focusNewRow;
				var repeatTable = this.getRepeatTable(eventTarget);
				var afterParams = new Array (repeatProperty, indexToFocus, repeatTable);
			}
		}
	}
	if(repeatType == "list") {
		/* reset the values of variables for list */
		repeatPropKey = "PageListProperty";
		indexKey = "Index";
		actvityName = "RemoveFromPageList";
		if(index && !isNaN(index)) {
			index = parseInt(index);
			defaultTab = index - 1;
			indexToFocus = index - 1;
		}		
		if(partialRefresh && partialRefresh === "true") {
		
			if(!grid) {
				beforeDomAction = this.updateHandlesAfterDelete;
				beforeParams = new Array(indexToFocus, [repeatTable]);	
				afterParams[1] = indexToFocus;
			}else {
				beforeParams[0] = indexToFocus;
			}
			this.registerFocusIn(eventTarget);
		}
	}
	if(customActivity!=null && customActivity!=""){
		actvityName = customActivity;
	}
	if(baseRef!="") {	
			var repeatObject = pega.u.d.getRepeatObject(eventTarget,true);
			if(!repeatObject) {
				var baseRefElement= eventTarget;
				while(baseRefElement!=null && baseRefElement.tagName.toUpperCase()!="BODY"){	
					if(baseRefElement.getAttribute("BASE_REF") && baseRefElement.getAttribute("BASE_REF") != "")
						break;
					baseRefElement=baseRefElement.parentNode;
				}
				baseRef=this.getBaseRef(baseRefElement.parentNode);
				//reloadElem=baseRefElement.parentNode;
			}	
	}

	/* Create the SafeURL object to call to the reloadRepeatLayout */ 
	var strActionSF=new SafeURL();
	if(className!=null && className!="") {
		strActionSF.put("ClassName",className);
	}
	strActionSF.put("BaseReference",baseRef);
	strActionSF.put(repeatPropKey, repeatProperty);
	strActionSF.put(indexKey, index);
	if(grid) {
		strActionSF.put("bTreegrid", grid.bTreegrid);
		strActionSF.put("currPage",pega.ui.property.toReference(currentRow.id));
	}
	var bFormSubmit = this.submitForm();
	/* If the form submit is enabled set the Finishing Activity */
	if(bFormSubmit) {
		strActionSF.put("FinishingActivity","Show-Harness");
	}
	else {
	/* If the form submit is disabled set the finishing activity to empty */
		strActionSF.put("FinishingActivity","");
	}

	/* Set the page name */
	if(pageName) {
		strActionSF.put("PageName",pageName);
	}

	var focusParams = new Array(repeatProperty, indexToFocus);

	if( partialRefresh && partialRefresh == 'true' ) {
		/* prepare partialParams key:value pairs object*/
		var partialParams = {
			partialTrigger : "delete",
			/*List Based Triggering Story - Autobots 6.2 - gujas - Start*/
			listBaseRef: payLoad.listBaseRef || "",
            listPrimaryPage: payLoad.listPrimaryPage || "",
			property: repeatProperty,
			index : index,
			/*List Based Triggering Story - Autobots 6.2 - gujas - End*/
			domElement : domElement,
			domAction : "remove",
			beforeDomAction : beforeDomAction,
			beforeParams : beforeParams,
			afterDomAction : afterDomAction,
			afterParams	: afterParams
		};
		if(grid){
			partialParams.beforeDomActionContext = grid;
			partialParams.afterDomActionContext = grid;

		}
	}
	/* Set the selected tab value if it is a tabbed repeating layout
	 * repeat object will be a div in case of tabbed repeat
	 */
	var parentDiv = pega.u.d.getRepeatObject(eventTarget);
	if(parentDiv && parentDiv.tagName == "DIV") {
		var tabGroupId = parentDiv.getAttribute("tabGroupId");
		pega.util.Dom.getElementsByName("EXPANDED"+tabGroupId, parentDiv)[0].value = defaultTab;
	}
	/*BUG-79693: In case of filtered page group grid pass the grid's filtercriteria page*/
	if (!grid && repeatType == "group" && pega.ctx.gridObj && pega.ctx.gridObj.bFilteredGrid) {
		strActionSF.put("pyGridFilterCriteriaPage", pega.ctx.gridObj.gridFilterPage);
	}
	if(grid) {
		/*In case of filtered grid we should pass the grid's filtercriteria page in  the request */
		if(grid.bFilteredGrid) {
			strActionSF.put("pyGridFilterCriteriaPage", grid.gridFilterPage);
			if(grid.bReportDefinition) {
				/*BUG-101929:To avoid exception in pzMatchesGridFilterCriteria, send isReportDef param to avoid searching of column in the filteredIndicesSet object.*/
				strActionSF.put("isReportDef", grid.bReportDefinition);
			}
		}
		if(grid.bFilteredGrid || grid.refreshLayout) {
			if((grid.currentPageIndex && grid.currentPageIndex!="" && grid.pyPaginateActivity=="") || grid.pageMode=="Progressive Load") {
				/*for progressive load, currentPageIndex is not proper always. So, recompute based on row index*/
				var pageIndex = (grid.pageMode=="Progressive Load")?Math.ceil(grid.activeRow/grid.rangeSize):grid.currentPageIndex;
				strActionSF.put("pyPageSize",grid.rangeSize);
				if(grid.pageMode=="Progressive Load") {
					if (grid.bDiscardInvisibleRows) {
						strActionSF.put("bDiscardInvisibleRows", "true");
						var startIndex = grid.getFirstLoadedRowIndex();
						strActionSF.put("startIndex", startIndex);
						strActionSF.put("currentPageIndex", grid.currentPageIndex);
						var recordsInCurrentPage =  grid.rangeSize * 3;
						if (1 == grid.currentPageIndex) {
							recordsInCurrentPage = 2 * grid.rangeSize;
						}
						strActionSF.put("recordsInCurrentPage", recordsInCurrentPage);
					} else {
						strActionSF.put("currentPageIndex",pageIndex);
						strActionSF.put("startIndex", 1);
						strActionSF.put("recordsInCurrentPage", (pageIndex+1)*grid.rangeSize);
					}
				}else {
					strActionSF.put("currentPageIndex",pageIndex);
					strActionSF.put("startIndex",((parseInt(pageIndex,10)-1)*parseInt(grid.rangeSize,10)+1));
				}
			}
			var editRowIndex = grid.getActiveRowIndex();
			if(grid.getTableLength(grid.rightBodyTbl)==editRowIndex) {
				if(!grid.currentPageIndex || (grid.currentPageIndex!="" && (Math.ceil(grid.totalRecords/grid.rangeSize) == grid.currentPageIndex))) {
					editRowIndex = grid.getIndex(editRowIndex-1);
				}
			}
			if(editRowIndex>0) {
				strActionSF.put("editRowIndex", grid.getLeftRow(editRowIndex).id);
			}
		}
    /* BUG-521635: A flag to control message clearing from primary page */
    strActionSF.put('KeepGridMessages', pega.u.d.KEEP_GRID_MESSAGES === true ? 'true' : 'false');
		strActionSF.put("gridActivity",actvityName);
		actvityName = "pzdoGridAction";
	}
	if(grid && grid.action){
		strActionSF.put("gridAction",grid.action);
		
		if(grid.gridPreActivity) {
			strActionSF.put("gridPreActivity", grid.gridPreActivity);
		}
		if(grid.gridPostActivity) {
			strActionSF.put("gridPostActivity", grid.gridPostActivity);
		}
	}
	var ignoreBusyIndInterval = null;
	if (grid) {
		ignoreBusyIndInterval = true;
	}
	var addDeleteArgs = {};
	addDeleteArgs.listName = repeatProperty;
	addDeleteArgs.listBaseRef = listBaseRef || payLoad.listBaseRef || baseRef;
	addDeleteArgs.listPrimaryPage = listPrimaryPage ||payLoad.listPrimaryPage;
   //BUG-395161 - Incase of full refresh we need to set gSectionReloaded to true that sets dirty flag
   if(partialRefresh != 'true') { pega.ctx.gSectionReloaded = true;}
	/* BUG-208890: Passing the current grid object */
	this.reloadRepeatLayout(actvityName, strActionSF.toQueryString(), rcvdEvent ? eventOrTarget : null, focusParams, eventTarget,
							partialRefresh == 'true' ? partialParams : null, ignoreBusyIndInterval,addDeleteArgs, grid); /*List Based Triggering Story - Autobots 6.2 - gujas*/
 }

/*
 @Handler
 @public AppendToList Adds a new row to the repeating list
	This function is being called user has a repeating layout using Page Lists. When user clicks the "Add a Row" button, 
	this funciton will be called to add a page to the repeating layout.
 @param $String$PageListProperty - name of the page list property 
 @param $String$ClassName - class of the Page for the pagelist property
 @param $Object$element - domElement which triggered AppendToList; gives index of the current row, the new row would be added after the current 
 @param $String$pageName - name of the page, when no value is passed the primary work page is used
 @param $String$customActivity Custom activity to be called when appending
 @param $Object$event - the event object
 @param $String$partialRefresh - "true"/"false" - if true, server will send single row markup
 @return $void$
*/
 pega.ui.Doc.prototype.AppendToList=function(PageListProperty, ClassName, element, pageName, customActivity, event, partialRefresh){
	event = event === undefined? window.event : event;		
	if(event.type == "keypress"){
		var target = pega.util.Event.getTarget(event);
		if((target.nodeName.toUpperCase() == "BUTTON" || target.nodeName.toUpperCase() == "A") && target.id == "RLAdd"){
			return false;
		}
	}
	var payLoad =	{
						repeatProperty : PageListProperty,
						className : ClassName,
						indexElt : element,
						pageName : pageName,
						customActivity : customActivity,
						eventOrTarget : event === undefined ? window.event : event,
						partialRefresh : partialRefresh,
						repeatType : "list"
					};
	
	
	this.append(payLoad);
}

/*
 @Handler
 @public Removes a row from the repeating list
 This function is being called user has a repeating layout using Page Lists. When user clicks the "Delete a Row" button, 
 this funciton will be called to delte a page from the repeating layout.
 @param $String$PageListProperty - name of the page list property
  @param $Object$element - domElement which triggered RemoveFromList; gives index of the row to be deleted
 @param	$String$pageName - name of the page, when no value is passed the primary work page is used
 @param $String$customActivity Custom activity to be called when appending
 @param $Object$event - the event object
 @param $String$partialRefresh - "true"/"false" - if true, server will not send any row markup
 @return $void$
*/

 pega.ui.Doc.prototype.RemoveFromList=function(PageListProperty, element, pageName, customActivity, event, partialRefresh){
	window.rowDeleted = true;/*BUG-38756 - 'rowDeleted' is used in 'getFromServer' of expression_calculation.js*/
	var payLoad =	{
						repeatProperty : PageListProperty,
						indexElt : element,
						pageName : pageName,
						customActivity : customActivity,
						eventOrTarget : event === undefined ? window.event : event,
						partialRefresh : partialRefresh,
						repeatType : "list"
					};
	
	this.remove(payLoad);
}
/*
 @protected Function which returns callback arguments needed for making a call to refresh layout
 @param $Object  reloadElement
@return $Object$   callbackArg object
*/
 pega.ui.Doc.prototype.getRefreshCallbackArgs =function(reloadElement){

	var dom = pega.util.Dom;
	var expandElement = reloadElement;
	var expandInnerDiv = expandElement;
	var innerDivExists=false;
	while (expandElement.id != "EXPAND-OUTERFRAME") {
		expandElement = expandElement.parentNode;
		if (expandElement == null) {
			return {expandInnerDiv:expandInnerDiv,expandElement:expandElement,reloadElement:reloadElement,paramName:paramName,innerDivExists:innerDivExists};
		}
	}
	var paramName = expandElement.getAttribute("PARAM_NAME");
	var reloadElement= expandElement;
    var childNodes;
	while ((reloadElement.id != "RULE_KEY") || (reloadElement.getAttribute("node_type") != "MAIN_RULE")){
		reloadElement = reloadElement.parentNode;
		if (reloadElement == null){
			break;
		}
	}
	if(expandElement.tagName.toUpperCase() == "TABLE" ) {
           
	  // old table based layout
	  var headerExists = false;
	  var expandElementTd = expandElement.rows[0].cells[0];
	  var firstChild = dom.getFirstChild(expandElementTd);
  	  if(firstChild.tagName.toUpperCase() == "TABLE" && firstChild.getAttribute("node_type") === "HEADER"){
		headerExists = true;
	  }
	  var expandInnerDiv = dom.getElementsById("EXPAND-INNERDIV", expandElement,"DIV");	
  	  if (expandInnerDiv && headerExists && !dom.isAncestor(firstChild,expandInnerDiv[0])){
		expandInnerDiv = expandInnerDiv[0];	
		innerDivExists=true;
	  }
	  else{
		childNodes = pega.util.Dom.getChildren(expandElementTd);
		if(childNodes && childNodes.length == 2) {
			expandInnerDiv = childNodes[1];	
		}else {
			expandInnerDiv = expandElementTd;	
		}
		innerDivExists=false;

	  }
         } else {
            // new div based layout - get first child
            var firstChild = dom.getFirstChild(expandElement);
	   var headerExists = false;
  	   if(firstChild.tagName.toUpperCase() == "DIV" && ( firstChild.getAttribute("node_type") === "HEADER" || firstChild.id == "EXPAND-PLUSMINUS") ){
		headerExists = true;
	   }
	   var expandInnerDiv = dom.getElementsById("EXPAND-INNERDIV", expandElement,"DIV");	
	   /*BUG-179208: The following boolean is required in the case where a grid is configured with the "Display Container Header and Title" option and a section include in the grid cell which also has a layout the same option enabled*/
	   var isGridWithHeader = false;
	   if(expandElement.children.length > 1 && expandElement.children[1] && expandElement.children[1].children.length > 0){
	       var child = expandElement.children[1].children[0];
	       if(child && dom.hasClass(child,'gridDefault')){
		       isGridWithHeader = true;
		   }else if(child && child.children.length > 0 && child.children[0] && dom.hasClass(child.children[0],'gridDefault')){
		       isGridWithHeader = true;
		   }
	    }
       /*BUG-179208: Added the isGridWithHeader boolean to make sure that the correct expandInnerDiv is selected and the correct value of innerDivExists is set*/		
  	   if (expandInnerDiv && headerExists && !dom.isAncestor(firstChild,expandInnerDiv[0]) && !isGridWithHeader){
		expandInnerDiv = expandInnerDiv[0];	
		innerDivExists=true;
	   }
	   else{
		childNodes = pega.util.Dom.getChildren(expandElement);
		if(childNodes && childNodes.length == 2) {/* FIXME - Don't depend on the length to decide expandInnerDiv instead find the required element by class or id */
			expandInnerDiv = childNodes[1];	
		}else {
          	var expandElement_children = $(expandElement).children(".layout-body");
          	if(expandElement_children.length > 0) {/* BUG-243569: "div.inspector-fieldvalue-data" div is introduced by autobots for dynamic layouts to support inspector for field values. Due to this earlier logic failed. Now add code to get correct element */
              expandInnerDiv = expandElement_children[0];
            } else {
              expandInnerDiv = firstChild;
            }	
		}
		innerDivExists=false;
	   }
         }
	return {expandInnerDiv:expandInnerDiv,expandElement:expandElement,reloadElement:reloadElement,paramName:paramName,innerDivExists:innerDivExists};

 }
/*
 @protected Holds common functionality for reloading a repeatlayout
 @param $Object$oArgs - this object has paramters to be passed to this function 
 @return $boolean$
*/
pega.ui.Doc.prototype.refreshRepeatLayout = function(oArgs)
{
    var dom = pega.util.Dom;
	var sendSectionData = true;

	if(oArgs && oArgs.sendSectionData && oArgs.sendSectionData === "false") {
		sendSectionData = false;
	}
	if(sendSectionData && this.processOnBeforeSubmit(false,oArgs.reloadElement) == false) return;
	
	var retCallbackArgs=this.getRefreshCallbackArgs(oArgs.reloadElement);
	var reloadElement=retCallbackArgs.reloadElement;
	var expandElement=retCallbackArgs.expandElement
	var paramName=retCallbackArgs.paramName;
	var innerDivExists=retCallbackArgs.innerDivExists;
	var expandInnerDiv=retCallbackArgs.expandInnerDiv;
  if(expandInnerDiv.tagName.toUpperCase() == "DIV" && pega.util.Dom.hasClass(expandInnerDiv, "layout-noheader")) {/* BUG-316447: Pass correct reloadElement */
    expandInnerDiv = expandInnerDiv.parentNode;
  }

	var clientEventTarget = false;
	var baseRef = this.getBaseRef(reloadElement,oArgs.event);
	

	var strUrlSF = SafeURL_createFromURL(pega.ctx.url);
	var expandRL = reloadElement.getAttribute("expandRL");
	if(expandRL) {
		strUrlSF.put("expandRL", expandRL);
	}
	var index = expandElement.getAttribute("INDEX");
	if(index)
		strUrlSF.put("index",index);
	strUrlSF.put("pyActivity","ReloadSection");
	
	
	// Logic for advanced parameter sections and containers.
	var isAdvParamSection = reloadElement.getAttribute("isAdvParamSection");
    var sectionIDList;
	if (isAdvParamSection) {
		sectionIDList = reloadElement.getAttribute("node_name") +'|' + reloadElement.getAttribute("containedSectionID")+ ':';	
	}
	// Otherwise pass the unique ID of the current section
	else {
		var refreshlist = "";
		var refreshelements = dom.getElementsByAttribute ("containedSectionID", "*", "DIV", reloadElement);
		if(refreshelements) {
				for(var i=0;i<refreshelements.length;i++) {
					var eachcontainedsectionID = refreshelements[i].getAttribute("containedSectionID");
					refreshlist += eachcontainedsectionID + ":" ; 
				}
		}
		sectionIDList = refreshlist;
	}

	strUrlSF.put("StreamName", reloadElement.getAttribute("node_name"));
	strUrlSF.put("RenderSingle", paramName);
	strUrlSF.put("StreamClass", reloadElement.getAttribute("objclass"));
	var childElement = reloadElement.getElementsByTagName("*")[0];
		var childDisplay = "";
		if((childElement.getAttribute("SHOW_WHEN") != null) && (childElement.getAttribute("SHOW_WHEN") != "") && (reloadElement.children[0].id!=null) && (reloadElement.children[0].tagName == "DIV")){
		clientEventTarget = true;
		childDisplay = childElement.style.display;
	}
	strUrlSF.put("bClientValidation", pega.ctx.bClientValidation);
	if(oArgs.preActivity != null){
		strUrlSF.put("PreActivity", oArgs.preActivity);
		strUrlSF.put("ActivityParams", oArgs.preActivityParams);
	}
	var nParent = reloadElement.parentNode;
	if(reloadElement && reloadElement.getAttribute && reloadElement.getAttribute("BASE_REF")){
		strUrlSF.put("UsingPage", "true");
	}

	strUrlSF.put("BaseReference", baseRef);
	strUrlSF.put("ReadOnly","0");/* Append/Delete not possible in a RO mode; thus response is expected to be editable always */
	var popoverLevel = pega.u.d.getPopOverLevel(reloadElement);
	if(popoverLevel >= 0){
		var _popOver = pega.u.d.getPopOver(popoverLevel);
		var _popOverAssoElem = _popOver.getAssociatedElement();
		if(_popOverAssoElem && _popOverAssoElem.getAttribute("data-ctl") == '["AutoCompleteAG"]'){
                        /*modified for BUG-134993*/
			pega.control.AutoCompleteAG.updateParams(strUrlSF, pega.c.PlaceHolder.getValue(_popOverAssoElem),_popOverAssoElem,true);
			//strUrlSF.put("AC_Grid_FilterParamValue", pega.c.PlaceHolder.getValue(_popOverAssoElem));
			strUrlSF.put("BaseReference", pega.u.d.getBaseRef(_popOverAssoElem));
		}
	}

	
	var queryString = new SafeURL();
	
	if(sendSectionData) {
		/* BUG-222988 forceAJAX incase of grid pagination */
		var preActivityArgsUrl = SafeURL_createFromURL(oArgs.preActivityParams)
		if(preActivityArgsUrl && preActivityArgsUrl.get("gridAction") == "PAGINATE"){
          queryString = this.getQueryString(reloadElement, true, true);
        }else{
		queryString = this.getQueryString(reloadElement, true);
	}
	}
	if(sectionIDList!="")
		queryString.put("SectionIDList", sectionIDList);

	/*specifically added to send filter gadget's form elements while reloading the grid.*/	
	if(oArgs.appendExtraQueryString) {
		var extraQueryString = oArgs.appendExtraQueryString;
		queryString.copy(extraQueryString);
	}
    
   /*BUG-324518: Adding validations to avoid nullpointer exception popups in preview mode */
    if(this.fieldErrorType){
       strUrlSF.put("FieldError", this.fieldErrorType);
       }
     if(this.formErrorType){
       strUrlSF.put("FormError", this.formErrorType ); 
       }
 /*BUG-106762: Send pyCustomError to handle errors for custom error section*/
    if(this.pyCustomError){
       strUrlSF.put("pyCustomError", this.pyCustomError);
       }
	
	strUrlSF.put("Increment","true");
	if(!oArgs.ignoreBusyIndInterval) { 
		oArgs.ignoreBusyIndInterval = false;
	}
	if(!oArgs.showOnlyMask) {
		oArgs.showOnlyMask = false;
	}
	this.setBusyIndicator(expandElement, oArgs.ignoreBusyIndInterval, oArgs.showOnlyMask);
	var callbackArgs = new Array(expandInnerDiv, expandElement, paramName,innerDivExists,oArgs.focusParams, "reloadRepeat",oArgs.repeatProperty, oArgs.partialParams, oArgs.oldGridObj);
	var callback = {success:this.handleLoadSuccess, failure: this.handleLoadFail, scope:this, argument: callbackArgs};  
	if(oArgs.gridAction && oArgs.gridAction=="progressiveLoad") {
		callbackArgs = new Array(reloadElement, "", "", "", oArgs.focusParams, "" , oArgs.partialParams);
		callback.success = this.handlePartialSuccess;
		callback.argument = callbackArgs;
	}
	this.asyncRequest('POST', strUrlSF, callback, queryString);
};
pega.ui.Doc.prototype.updateInnerHTML = function (currNode,oldHPref,hPref) {	
   this.reloadElement = currNode;
    var bHTMLUpdated = false;	
    if(hPref && oldHPref && (hPref !==oldHPref )){
		/*if(currNode.tagName.toUpperCase == "TR")
			var eachRowCells = currNode.cells;
		else 
		*/
		var eachRowCells = pega.util.Dom.getChildren(currNode);

		var prevEntryHandle = pega.ui.property.toReference(oldHPref);
		prevEntryHandle = prevEntryHandle.replace(/\(/g, "\\(").replace(/\)/g, "\\)");
		var newEntryHandle = pega.ui.property.toReference(hPref);
		var newregex = new RegExp(prevEntryHandle, "g");

		/* Replace $ in currHPref with \$ for string replacement */
		oldHPref = oldHPref.replace(/\$/g, "\\$");
		var regex = new RegExp(oldHPref, "g");
		for (var j = 0; j < eachRowCells.length; j++) {				
			var eachCell = eachRowCells[j];	
			/*For tree grid UL gridNodes don't update innerHTML. Anyways individual LIs innerHTML will be updated via updateHandles*/
			if(!(eachCell.tagName && eachCell.tagName.toUpperCase()=="UL" && eachCell.id && eachCell.id=="gridNode")) {
				if(!pega.util.Event.isIE || (pega.env.ua.ie > 8 && pega.u.d.inStandardsMode)) {
					/* 
					 * the IE9 and above in standards mode do not keep the value in the innerHTML that is typed on the UI 
					 * i.e. formControl.getAttribute("value") is no longer equal to formControl.value while the latter is what user has entered latest on the UI.
					 * This is same as what non-IE browsers have always followed. Now for IE9 onwards in standards mode, we need to explicitly fix the innerHTML
					 */
					pega.util.Dom.updateInnerHTMLForFields(eachCell);	
				}
                 /*  Here creating RTE template,to re-initialize RTE element */
                var rteTextAreas = eachCell.getElementsByTagName('TextArea'),hasRTE=false;
                if(rteTextAreas && rteTextAreas.length >0){
                    for(var rteIndex=0;rteIndex<rteTextAreas.length;rteIndex++){
                        var rteTextArea = rteTextAreas[rteIndex];
                        var idValue = rteTextArea.getAttribute('id');
                        var nameValue = rteTextArea.getAttribute('name');
                        if(idValue && idValue.match(/PEGAEDITOR[\d]+/)){
                            hasRTE = true;
                            var containerDIV = rteTextArea.parentNode;
                            var _firstChild = containerDIV.getElementsByTagName("DIV")[0];
                            var divList = _firstChild.getElementsByTagName("DIV");
                            if(divList && divList.length > 0){
                                var toolbarDiv = divList[0];
                                if(toolbarDiv.childNodes.length > 1){
                                    toolbarDiv.removeChild(toolbarDiv.childNodes[0]);                            
                                    var subContentDiv = toolbarDiv.getElementsByTagName("DIV")[0];
                                    while(subContentDiv.hasChildNodes()){
                                        subContentDiv.removeChild(subContentDiv.childNodes[0]);
                                    }                                
                                }                            
                            }
                        }
                    }
                }
				var content = eachCell.innerHTML;
				if(content.match(regex)) {
					content = content.replace(regex, hPref); 
                    if(hasRTE){
                        content = content.replace(/PEGAEDITOR[\d]+/g, "PEGAEDITOR");                    
                    }
					//this is a hack for the innerHTML thats removing all/some of the scripts tags which are inside the content. Fix for BUG-27477
					content = "&nbsp" + content;
					eachCell.innerHTML = content;
					eachCell.removeChild(eachCell.firstChild);
          pega.u.d.resetGridDivs(eachCell);
					bHTMLUpdated = true;			
				}
				if(content.match(newregex)) {
					content = content.replace(newregex, newEntryHandle); 
					content = "&nbsp" + content;
					eachCell.innerHTML = content;
					eachCell.removeChild(eachCell.firstChild);
          pega.u.d.resetGridDivs(eachCell);
					bHTMLUpdated = true;
				}
				if(pega.util.Event.isIE && pega.env.ua.ie!=6 ) {
					var selectEles=eachCell.getElementsByTagName('select');
					var selectEle = null;

					for(var y=0;y<selectEles.length;y++){
						selectEle= selectEles[y];
						if (selectEle && selectEle.getAttribute("DSSource")) {
							/* this is a Dynamic Select */
							var selIndex = selectEle.selectedIndex;
							if(selIndex && selectEle.options[selIndex]) {
								selectEle.setAttribute("DSDefault", selectEle.options[selIndex].value);
							}
						}
					}
				}
			}
		}
		if(bHTMLUpdated == true) {
			currNode.setAttribute("contentUpdated",true);
		}else {
			currNode.setAttribute("contentUpdated",false);
		}		
    }/*ends hPref != oldHPref*/     

	var calCont = document.getElementById("Pega_Cal_Cont")
	if(calCont && calCont.parentNode && calCont.parentNode.tagName && calCont.parentNode.tagName.toUpperCase()=="BODY"){
		document.body.removeChild(calCont);
	} 
};
  
/* BUG-571832 : Reinitialize inner Grid on drag drop */  
    pega.ui.Doc.prototype.resetGridDivs=function(cell){
    		/*find the grid Divs and reset id to PEGA_GRID so that the grid object is reinitialized again.*/
					var gridContentDivs = pega.util.Dom.getElementsById("PEGA_GRID_CONTENT", cell);
					if(gridContentDivs && gridContentDivs.length>0) {
						for(var i=0; i<gridContentDivs.length; i++) {
							var gridDiv = gridContentDivs[i].parentNode;
							if(gridDiv.id == "PEGA_GRID_SKIN"){ 
								gridDiv = gridDiv.parentNode;
							}
                          	var rightHeaderTable = pega.util.Dom.getElementsById("headTbl_right"+gridDiv.id.split("PEGA_GRID")[1],gridDiv);
							if(rightHeaderTable && rightHeaderTable[0]){ /*BUG-227843: Removing grid id from the headTbl_right value as grid reinitialization will give new id*/
								rightHeaderTable[0].id = "headTbl_right";
							}
							gridDiv.id = "PEGA_GRID";
							
							/*update gridNode UL id here*/
							var gridBodyLeftDiv = pega.util.Dom.getElementsById("gridBody_left", gridDiv);
							if(gridBodyLeftDiv && gridBodyLeftDiv[0]) {
								var gridNodeUL = pega.util.Dom.getFirstChild(gridBodyLeftDiv[0]);
								if(gridNodeUL && pega.util.Dom.hasClass(gridNodeUL, "gridNode")) {
									gridNodeUL.id = "gridNode";
								}
							}
						}
						content = cell.innerHTML;
					}  
    }

/*
@To process the inline scripts when someone focus the TR, provided isDirty is "Y".
 This function is called when focus in happens after refreshPartial happens.
 @param $Object$e -The event object
 @return $void$
*/

pega.ui.Doc.prototype.onfocusInListener = function(e){
	var tar = e.target || e.srcElement;
	var activeName = tar.name;
	if(tar.id === "RLDel") { /***Event is from Delete button, so no need to processInlineScripts in this case ***/
		return;
	}
	var parent = tar.parentNode;
	while(parent.tagName !== "TR" || (parent.getAttribute("hPref") === null && parent.getAttribute("PL_INDEX") === null)){
	   parent = parent.parentNode;
	   if (parent === null){
		break;
	   }
	}    
	var i = 0;
    var currNode = parent;

    while (i < 2 && currNode) {
        if(currNode) {
           /*Check for the attribute contentUpdated with boolean and string as boolean works in IE and string works in FF*/
            if(currNode.getAttribute("contentUpdated") == true || currNode.getAttribute("contentUpdated") == "true")
            {
                /* Replace $ in currHPref with \$ for string replacement */
                var strSelectUniqueID = "";
				/* BUG-160432: Changing to getAttribute for browser compatibility */
                if (typeof(this.reloadElement.getAttribute('uniqueID')) !== "undefined")		
                    strSelectUniqueID = this.reloadElement.uniqueID;
                else {
                    strSelectUniqueID = pega.util.Dom.generateId();
                    this.reloadElement.setAttribute("uniqueID", strSelectUniqueID) ;
                }
                var objDOMLoader = new DOMScriptLoader();
				var oldCallback = pega.tools.EvalDomUtils_globals.callbackFunction;
				pega.tools.EvalDomUtils_globals.callbackFunction = pega.u.d.callbackForRepeat;

				objDOMLoader.processInlineScripts(this.reloadElement,currNode,strSelectUniqueID,true);
				pega.tools.EvalDomUtils_globals.callbackFunction = oldCallback;
				
				currNode.setAttribute("contentUpdated",false);
            }
           
        }/*ends currNode == TR*/        
        i++;
		/*processInLineScripts for previous row so that it does not react to the actions on focussed row
		 *as now their innerHTML's have same entry handles
		 */
        currNode = pega.util.Dom.getPreviousSibling(currNode);
    }/*ends while*/
}

/*
This function is a callback for processinlinescripts when processinlinescripts invoked on focus in
*/

pega.ui.Doc.prototype.callbackForRepeat = function(domObj)
{
	if(domObj && domObj.id != "PegaOnlyOnce") {	
		pega.u.d.processOnloads(domObj);
	}
	if(pega.env.ua.ie==6){
		setTimeout(function(){pega.u.d.gIsScriptsLoading = false;},2000);
	}
	else{
		pega.u.d.gIsScriptsLoading = false;
	}
}

/*
@To register focusIn listener to the repeating layout TABLE.
 This function is called when refreshPartial happens. Following cases use this function.
	Delete a row from a repeat layout
	Insert a row in a repeat layout
 @param $Object$expandEle- the source element of the event.
 @param $Object$reloadEle - Section DIV containing the repeating layout.
 @return $void$
*/

pega.ui.Doc.prototype.registerFocusIn=function(repeatTable) {
	var reloadElement = repeatTable;
	
	while ((reloadElement.id != "RULE_KEY") || (reloadElement.getAttribute("node_type") != "MAIN_RULE")){
		reloadElement = reloadElement.parentNode;
		if (reloadElement == null)
			return;
	}	
	while(!pega.util.Dom.hasClass(repeatTable,"repeatReadWrite")) {
		repeatTable = repeatTable.parentNode;
		if (repeatTable == null)
			return;
	}
	var listeners = null;
	var ev = pega.util.Event;
	if(ev.isIE ) {
		listeners = ev.getListeners(repeatTable,"focusin");
		if(listeners === null) {
				ev.addListener(repeatTable, "focusin", pega.u.d.onfocusInListener,repeatTable ,{reloadElement:reloadElement}); 
		 }   
	}
	else
	{
		listeners = ev.getListeners(repeatTable,"focus");
		if(listeners === null) {
				ev.addListener(repeatTable, "focus", pega.u.d.onfocusInListener,repeatTable ,{reloadElement:reloadElement}); 
		 }   
	}
}
/*
 @public Loads the section by calling to ReloadSection activity
 This function is called when reload the section from client side. Following cases use this function.
	Delete a row from a repeat layout
	Refresh a section using client events
 This function will update the clipboard with currently entered values using http post data.
 @param $String$preActivity - name of the pre processing activity to be executed before getting the section display
 @param $String$preActivityParams - activity params in the URL notation
 @param $Object$event - The event object
 @param $Object$focusParams - Focus Parameters
 @param $Boolean$showOnlyMask - Boolean value that specifies whether only the mask should appear or busy indicator show up after standard delay time
 @return $void$
	 * param partialParams : the object with key:value pairs to set partialTrigger value and 
	 *		to override default action to be taken on the AJAX response received.
	 *		passed on to handlePartialSuccess and evalDOMScripts API's.
	 *		major keys are :
	 *			1. partialTrigger : required String value to be sent to server signalling the trigger of this partial refresh
	 * 			2. domElement : the descendant HTML element of section on which current domAction has to be performed
	 * 			3. domAction : the dom action to be performed on the domElement other than the default action of setting innerHTML
	 *	  			possible String values - 
	 *					1. remove : removes domElement from the DOM; AJAX response still has to be atleast an empty String
	 *					2. replace : replaces domElement by the firstChild of the AJAX response
	 *					3. insert : inserts firstChild of the AJAX response before domElement
	 *					4. append : appends firstChild of the AJAX response as child of domElement
	 *			4. beforeDomAction : a function registered to be invoked by handlePartialSuccess before taking the domAction
	 *			5. beforeDomActionContext : the context of  function registered to be invoked 
	 *			6. beforParams : the parameter array to be passed to the function registered to be invoked beforeDomAction
	 *			7. afterDomAction : a function registered to be invoked by handlePartialSuccess before taking the domAction
	 *			8. afterDomActionContext : the context of  function registered to be invoked 
	 *			9. afterParams : the parameter array to be passed to the function registered to be invoked afterDomAction
	 *			10. sendSectionData : set to String value "true" if want to send the form data in the section to server by preparing the query string
	 */
 
 pega.ui.Doc.prototype.reloadRepeatLayout = function(preActivity, preActivityParams, event, focusParams, reloadEle, partialParams, showOnlyMask, repeatProperties, repeatObject) {/*List Based Triggering Story - Autobots 6.2 - gujas*/
   if(reloadEle){
		var reloadElement = reloadEle
	}else {
		var reloadElement = pega.util.Event.getTarget(event);
	}
	var oArgs = {
			reloadElement:reloadElement,
			preActivity:preActivity,
			preActivityParams:preActivityParams,
			event:event,
			focusParams:focusParams,
			strReloadType:'RepeatLayout',
			isResponseRO:'0',	/* Append/Delete not possible in a RO mode; thus response is expected to be editable always */
			showOnlyMask:showOnlyMask,
			/*List Based Triggering Story - Autobots 6.2 - gujas - Start*/
			repeatProperty: repeatProperties,
			/*List Based Triggering Story - Autobots 6.2 - gujas - End*/
            oldGridObj: repeatObject /* BUG-208890: Passing the oldGridObj makes sure of nullifying and re-initializing the complex object */
      		/* isNonTemplate : true */ /*To set the Templating status N while reload section*/ /* BUG-477263: Do not force non-template at request level, it cannot be overridden */
	};
	if(partialParams) {
		if(partialParams.partialTrigger) {
			/* partialTrigger is required */
			var tmp = {listName:partialParams.property, listBaseRef: partialParams.listBaseRef, listPrimaryPage: partialParams.listPrimaryPage};
			partialParams.property = tmp;

			/* Take a copy of properties of interest to use while updating handles */
			var action = partialParams.domAction;

			this.refreshPartial(oArgs, partialParams);
		}
		return;
	} else if(preActivity.toLowerCase() == "pzdogridaction" || (preActivity.toLowerCase() == "removefrompagegroup" && pega.ctx.gridObj != null)) {
		var expandElement = oArgs.reloadElement;
		var expandElementFound = true;
		// In tabbed and accordion cases, the 'EXPAND-OUTERFRAME' table is never generated
		// hence fallback to the complete reload in these cases.
		while (expandElement.id != "EXPAND-OUTERFRAME") {
			expandElement = expandElement.parentNode;
			if (expandElement == null) {
				expandElementFound = false;
				break;
			}
		}
		
		if(expandElementFound == true) {
			var paramName = expandElement.getAttribute("PARAM_NAME");
			if(paramName){
        var currentContext = pega.ctxmgr.getCurrentHarnessContext();
        var harnessContext = pega.ctxmgr.getContextByTarget(reloadElement);
        pega.ctxmgr.setContext(harnessContext);
        pega.u.d.refreshRepeatLayout(oArgs);
        pega.ctxmgr.resetContext(currentContext);
      }
			else 
				pega.u.d.reload(oArgs);
		} else {
			pega.u.d.reload(oArgs);
		}
		return;
	}
	this.reload(oArgs);
}

/*
 @Handler
 @protected PromptForGroupSubScript shows a modal dialog that prompts the user for subscript.
	This function is being called user has a repeating layout using Page Groups. When user clicks on the "Add" button,
	this funciton will be called to prompt the dialog box.
 @param $String$PageGroupProperty - name of the page group property 
 @param	$String$ClassName - class of the Page for the Pagegroup property
 @param $String$pageName - name of the page, when no value is passed the primary work page is used
 @param $String$customActivity
 @param $Object$event - the event object
 @param $String$partialRefresh - "true"/"false" - if true, server will send single row markup
 @return $void$
*/
pega.ui.Doc.prototype.ShowSubscriptPrompt = function(PageGroupProperty, ClassName, pageName, customActivity,event, partialRefresh,grid){
	try {
		event = (event == undefined)?window.event : event;
		pega.util.Event.stopEvent(event);
		this.insertButton = pega.util.Event.getTarget(event);
	}catch(e){
		this.insertButton = event;
		
	}
	if(!this.insertButton)
		this.insertButton = event;
	this.PageGroupProperty = PageGroupProperty;
	this.ClassName = ClassName;
	this.pageName = pageName;
	this.customActivity = customActivity;
	var baseref = this.getBaseRef(this.insertButton);
	var oSafeUrl = SafeURL_createFromURL(pega.ctx.url);
	oSafeUrl.put("pyActivity","ReloadSection");
	oSafeUrl.put("StreamName","SubScriptPrompt");
	oSafeUrl.put("baseref",baseref);
	oSafeUrl.put("pageName",pageName);
	oSafeUrl.put("PageGroupProperty",PageGroupProperty);
	oSafeUrl.put("PageGroupClass",ClassName);
	var callback = {
		success: function (oResponse) {
				var strResponse = oResponse.responseText;
				var returnNode = document.createElement("DIV");
				returnNode.innerHTML = strResponse;

				var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce",returnNode);
				if(onlyOnceEle && onlyOnceEle[0]) {
					pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
					returnNode.removeChild(onlyOnceEle[0]);
				}
				
				if(!pega.u.d.bModalRendered)
					pega.u.d.renderModal();
				pega.u.d.modalDialog.show();
				pega.u.d.loadDOMObject(pega.u.d.modalDialog.body,returnNode.innerHTML);
				pega.u.d.subscripts = document.getElementById("subscripts").value;
				pega.u.d.subArr = pega.u.d.subscripts.split(',');
				pega.u.d.focusFirstElement(pega.u.d.modalDialog.innerElement.id);
				var btn = document.getElementById("ModalButtonSubmit");
				var cancelBtn = document.getElementById("ModalButtonCancel");
				if(!btn)
					btn = document.getElementById("ModalButton");

				pega.util.Event.addListener(btn ,"click",pega.u.d.add,partialRefresh,pega.u.d);
				if(cancelBtn) {
					pega.util.Event.addListener(cancelBtn ,"click",pega.u.d.cancelSubscriptModal);
				}

				var firstBoundary = pega.u.d.getFirstFocusableElement(pega.u.d.modalDialog.innerElement.id);		
				var lastBoundary = pega.u.d.getLastFocusableElement(pega.u.d.modalDialog.innerElement.id);
				pega.util.Event.addListener(pega.u.d.modalDialog.innerElement,"keydown",pega.u.d.restrictFocus,[firstBoundary,lastBoundary]);

				pega.u.d.gBusyInd.hide();
		},
		failure: function (oResponse) {
		//handle an unsuccessful request
			 pega.u.d.gBusyInd.hide();
				
		}
	}	
	this.setBusyIndicator();
	var request = this.asyncRequest('POST', oSafeUrl,callback);
}

/*
	This function get called when we click subscript in modaldialog (i.e validate input in modaldialog)
	@param $String$partialRefresh - "true"/"false" - if true, server will send single row markup
	@return $void$
	*/

pega.ui.Doc.prototype.add = function(e,partialRefresh) {
	var inputObj = this.getFirstInputElement(pega.u.d.modalDialog.innerElement.id);
	var inputValue = inputObj.value;
    var subName;
	if (inputValue != null && inputValue!= '') {
		subName = this.trim(inputValue);
	} else {
		subName = inputValue;
	}

	if(this.validateSubScript(subName)) {
		pega.u.d.Subscript = subName;
		/* Persisting the value of pega.ctx.gridObj across the modal dialog hide call */
		var grid = pega.ctx.gridObj;
		pega.u.d.modalDialog.hide();
		try{
			inputObj.blur();
		}
		catch(exp){}
		pega.ctx.gridObj = grid;
		pega.u.d.AppendToGroup(pega.u.d.PageGroupProperty, pega.u.d.ClassName, pega.u.d.Subscript, pega.u.d.pageName, pega.u.d.customActivity,pega.u.d.insertButton,partialRefresh);
	}
	else {
		if (subName == "") alert(this.subscriptError);
		else	alert(subName +" "+ this.subscriptError);
	}	
	//enclose it in trycatch so that cases where pega.u.d is called without passing event does not break
	try{pega.util.Event.stopPropagation(e);}catch(e){}
}

/*
	This function gets called when we click cancel in subscript modaldialog
*/
pega.ui.Doc.prototype.cancelSubscriptModal = function() {
	/* BUG-201103: As part of memory leak issues(BUG-185495) pegaUD variable is removed from window space, using pega.u.d instead */
	pega.u.d.inCall = false;

}


/*
 @public AppendToGroup Adds a new page to the repeating group
	This function is being called user has a repeating layout using Page Groups. When user enters a subscript from the subscript prompt
	this funciton will be called to add a page to the repeating layout.
 @param $String$PageGroupProperty - name of the page group property 
 @param $String$ClassName - class of the Page for the Pagegroup property
 @param $String$Subscript - Subscript of the new element to be added 
 @param $String$pageName - name of the page, when no value is passed the primary work page is used
 @param $String$customActivity Custom activity to be called when appending
 @param $String$partialRefresh - "true"/"false" - if true, server will send single row markup
 @return $void$
*/
 pega.ui.Doc.prototype.AppendToGroup = function(PageGroupProperty, ClassName, Subscript, pageName, customActivity,srcElement,partialRefresh){

	var payLoad =	{
						repeatProperty : PageGroupProperty,
						className : ClassName,
						indexElt : Subscript,
						pageName : pageName,
						customActivity : customActivity,
						eventOrTarget : srcElement,
						partialRefresh : partialRefresh,
						repeatType : "group"
					};

	this.append(payLoad);
}

 pega.ui.Doc.prototype.getNextRowSubscript = function(theRow) {	
        var dom = pega.util.Dom;
		var nextRow = dom.getNextSibling(theRow);	
		var targetRow = null;
		var subscript=null;
		if(nextRow && nextRow.getAttribute("PG_SUBSCRIPT")){
			targetRow = nextRow;
		}
		else{
			var prevSiblingTr =  dom.getPreviousSibling(nextRow);
			if(prevSiblingTr)
				targetRow = dom.getPreviousSibling(prevSiblingTr);

		}
		if(targetRow)
			var subscript = pega.u.d.getRepeatRow(targetRow,false);
			return subscript;
}


/*
 @Handler
 @public RemoveFromGroup Removes a page  from the repeating group
	This function is being called user has a repeating layout using Page Groups. When user clicks the "Delete Row" button from the repeating layout
	this funciton will be called to remove a page to the repeating layout.
 @param $String$PageGroupProperty - name of the page group property
 @param $String$Subscript - Subscript of the page to be deleted
 @param $String$pageName - name of the page, when no value is passed the primary work page is used
 @param $String$customActivity Custom activity to be called when appending
  @param $Object$event - the event object
  @param $String$partialRefresh - "true"/"false" - if true, server will not send any row markup
 @return $void$
*/

pega.ui.Doc.prototype.RemoveFromGroup= function(PageGroupProperty, Subscript, pageName, customActivity,event, partialRefresh){
	
	var payLoad =	{
						repeatProperty : PageGroupProperty,
						indexElt : Subscript,
						pageName : pageName,
						customActivity : customActivity,
						eventOrTarget : event === undefined ? window.event : event,
						partialRefresh : partialRefresh,
						repeatType : "group"
					};

	this.remove(payLoad);
}

pega.ui.Doc.prototype.findValue =function () {
 	//if there are any inputs take the first input return its value 
	//if there are no inputs find the selects. Return its value 
	//if there are no selects, find radios, return its value
 	var obj = this.parseChildNodes(pega.u.d.modalDialog.innerElement); 
	if (obj == null) { return; } return obj;
}

})();
//static-content-hash-trigger-GCC
//<script>
//pega.namespace("pega.ui");

/*@protected
@constructor Property conversion utility */

if (!pega.ui.property) {

	pega.ui.property = function() {
		this.formJSON = {};
	};

	pega.ui.property.prototype = {

		/*
		@protected- Convert PRPC style property reference into internal property handle format
		@param $string$sProp – property reference.
		@param $undefined$sPage – optional page name.
		@return $undefined$ - return property handle.
		*/
		toHandle: function(sProp, sPage) {
			try {
				var ar1 = sProp.split(".");
				if (ar1.length === 1)
					return sProp;
				var sEH = ar1[0] === "" ? "$P" + sPage : "$P" + ar1[0];
				for (var i = 1; i < ar1.length; ++i) {
					var sSeg = ar1[i];
					var ar2 = sSeg.split("(");
					if (ar2.length === 1)
						sEH += ("$p" + sSeg);
					else {
						sEH += ("$p" + ar2[0]);
						var sSub = ar2[1].substring(0, ar2[1].length - 1);
						var sValidChars = "0123456789";
						var bIsInt = true;
						var sCh;
						for (var j = 0; j < sSub.length && bIsInt; ++j) {
							sCh = sSub.charAt(j);
							if (sValidChars.indexOf(sCh) === -1)
								bIsInt = false;
						}
						if (bIsInt)
							sEH += ("$l" + sSub);
						else
							sEH += ("$g" + sSub);
					}
				}
				return sEH;
			}
			catch (e) {}
		},

		/*
		@protected- Convert PRPC style property handle into property reference format
		@param $undefined$sPropHnd – property handle.
		@return $undefined$ - property reference.
		*/
		toReference: function(sPropHnd) {
			try {
				if (sPropHnd === null || sPropHnd === "")
					return "";

				var sBuf = "";
				var sResult = "";
				var len = sPropHnd.length;
				var iPos = sPropHnd.indexOf("$p");
				if (iPos < 0)
					return "";

				var c = ' ';
				var sSep = ".";
				var bDone = false;
				var bHadSubscript = false;

				sResult += (sPropHnd.substring(2, iPos) + sSep);
				iPos++;
				while (!bDone) {
					iPos++;
					if (iPos < len) {
						c = sPropHnd.charAt(iPos);
						if (c === '$') {
							iPos++;
							c = sPropHnd.charAt(iPos);
							switch (c) {

								case 'p':
									sResult += (sBuf + sSep);
									bHadSubscript = (sSep === ')');
									sBuf = "";
									sSep = '.';
									break;

								case 'g':
								case 'l':
									sResult += (sBuf + "(");
									sBuf = "";
									sSep = ')';
									break;

								default:
									if (bHadSubscript) {
										bHadSubscript = false;
										sResult += '.';
									}
									sBuf += c;
									break;
							}
						} else if (c === '[') {
							sBuf += '<';
						} else if (c === ']') {
							sBuf += '>';
						} else {
							if (bHadSubscript) {
								bHadSubscript = false;
								sResult += '.';
							}
							sBuf += c;
						}
					} else {
						if (sBuf !== "") {
							sResult += sBuf;
							if (sSep !== '.')
								sResult += sSep;
						}
						bDone = true;
					}
				}
				return sResult;
			}
			catch (e) {return "";}
		},

		toObject: function(propReference, propValue, targetObject) {

			/*
			  pyWorkPage.Name == formJSON["pyWorkPage"]["Name"] ;
			  pyWorkPage.pyWorkParty(Suman).Contact == formJSON["pyWorkPage"]["pyWorkParty"]["Suman"] ["Contact"]
			  pyWorkPage.Address(1).AddressLine
			  pyWorkPage.Siblings(1)
			  */
			//this.jsObjectFromReference = {}; //initialize
			var propArray = propReference.split(".");
			var propArrayLen = propArray.length;
			var jsonRef = targetObject || {};
			var returnObject = jsonRef;

			for (var cnt = 0; cnt < propArrayLen - 1; cnt++) {
				var currProp = propArray[cnt];

				if (currProp.indexOf("(") !== -1) {
					var startParan = currProp.indexOf("(");
					var endParan = currProp.indexOf(")");
					var subscript = currProp.substring(startParan + 1, endParan);
					var embedProp = currProp.substring(0, startParan);
					var index = parseInt(subscript);
					if (!isNaN(index)) {
						//Address(1)
						if (!(embedProp in jsonRef))
							jsonRef[embedProp] = [];
						jsonRef = jsonRef[embedProp][index - 1] = jsonRef[embedProp][index - 1] || {};
					} else {
						if (!(embedProp in jsonRef))
							jsonRef[embedProp] = {};
						jsonRef = jsonRef[embedProp][subscript] = jsonRef[embedProp][subscript] || {};
					}
				} else {
					if (!(currProp in jsonRef))
						jsonRef[currProp] = {};
					jsonRef = jsonRef[currProp];
				}
			}

			//Check for Value List and Value Group
			var lastKey = propArray[propArrayLen - 1];
			if (lastKey.indexOf("(") == -1) {
				jsonRef[propArray[propArrayLen - 1]] = propValue;
			} else {
				startParan = lastKey.indexOf("(");
				endParan = lastKey.indexOf(")");
				subscript = lastKey.substring(startParan + 1, endParan);
				embedProp = lastKey.substring(0, startParan);
				index = parseInt(subscript);
				if (!isNaN(index)) {
					//Address(1)
					if (!(embedProp in jsonRef))
						jsonRef[embedProp] = [];
					jsonRef = jsonRef[embedProp][index - 1] = propValue;
				} else {
					if (!(embedProp in jsonRef))
						jsonRef[embedProp] = {};
					jsonRef = jsonRef[embedProp][subscript] = propValue;
				}
			}
			return returnObject;
		},

		getFormJSON: function() {
			var formRef;

			/*
				ISSUE-65861:
				Ajax Container can hold multiple form object maintaining the context properly.
				Get the current showed harness's record id to get the proper form data.
			 */
			if (pega.ctx && pega.ctx.isMDC) {
				var ajaxContainerCurrentRecordId = pega.ctx.recordId;
				if (ajaxContainerCurrentRecordId) {
					formRef = document.querySelector('[data-mdc-recordid=' + ajaxContainerCurrentRecordId + '] form');
				} else {
					console.error("Cannot get record Id of the ajax container to get the form object");
					return "";
				}
			} else {
				/*
					Dynamic container will have one form object so getting it directly.
				 */
				formRef = document.forms[0];
			}

			if (!formRef) {
				console.error("Couldn't find form object in the document");
				return "";
			}
			var formElements = formRef.elements;
			var formElementlen = formElements.length;
			var target = {};

			for (var cnt = 0; cnt < formElementlen; cnt++) {
				var elem = formElements[cnt];
				var elemName = elem.name;
				if (elemName && elemName.charAt(0) === "$") {
					var elemRef = this.toReference(elemName);

					//BUG-252237 - only add a radio button if the button is checked
					if (elem.type === "radio") {
						if (elem.checked) {
							this.toObject(elemRef, elem.value, target);
						} else {
							// BUG-386889: Using correct api to get elements by name.
							// BUG-306721: Setting to empty if none of radio button's in the group are checked to prevent null objects in the page list source usecase.
							var radioGroup = elem ? document.getElementsByName(elem.name) : null, checkedCount = 0;
							if (radioGroup) {
								for (var index = 0; index < radioGroup.length; index++) {
									if (radioGroup[index].checked) {
										checkedCount++;
									}
								}

								if (checkedCount === 0) {
									this.toObject(elemRef, "", target);
								}
							}
						}
					} else {
            /**Added below code as part of BUG-793046 Fix*/
						var value;
            if (elem.type === "text" && elem.getAttribute("data-auto-formatting") &&
                elem.getAttribute("data-auto-formatting") === "true") {
						  value = pega.control.PlaceHolder.getValue(elem);
					  }else{
              value = elem.value;
            }
            /**End*/
						if (elem.type === "checkbox") {
							value = elem.checked.toString();
						}
						this.toObject(elemRef, value, target);
					}
				} else {
					continue;
				}
			}
			return JSON.stringify(target);
		}

	};
}
//</script>
//static-content-hash-trigger-GCC
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.1
*/
/**
 * Provides methods to parse JSON strings and convert objects to JSON strings.
 *
 * @module json
 * @class JSON
 * @namespace pega.lang
 * @static
 */
(function () {

var l = pega.lang,
    isFunction = l.isFunction,
    isObject   = l.isObject,
    isArray    = l.isArray,
    _toStr     = Object.prototype.toString,
                 // 'this' is the global object.  window in browser env.  Keep
                 // the code env agnostic.  Caja requies window, unfortunately.
    Native     = (pega.env.ua.caja ? window : this).JSON,

/* Variables used by parse */

    /**
     * Replace certain Unicode characters that JavaScript may handle incorrectly
     * during eval--either by deleting them or treating them as line
     * endings--with escape sequences.
     * IMPORTANT NOTE: This regex will be used to modify the input if a match is
     * found.
     *
     * @property _UNICODE_EXCEPTIONS
     * @type {RegExp}
     * @private
     */
    _UNICODE_EXCEPTIONS = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,

    /**
     * First step in the safety evaluation.  Regex used to replace all escape
     * sequences (i.e. "\\", etc) with '@' characters (a non-JSON character).
     *
     * @property _ESCAPES
     * @type {RegExp}
     * @static
     * @private
     */
    _ESCAPES = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,

    /**
     * Second step in the safety evaluation.  Regex used to replace all simple
     * values with ']' characters.
     *
     * @property _VALUES
     * @type {RegExp}
     * @static
     * @private
     */
    _VALUES  = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,

    /**
     * Third step in the safety evaluation.  Regex used to remove all open
     * square brackets following a colon, comma, or at the beginning of the
     * string.
     *
     * @property _BRACKETS
     * @type {RegExp}
     * @static
     * @private
     */
    _BRACKETS = /(?:^|:|,)(?:\s*\[)+/g,

    /**
     * Final step in the safety evaluation.  Regex used to test the string left
     * after all previous replacements for invalid characters.
     *
     * @property _UNSAFE
     * @type {RegExp}
     * @static
     * @private
     */
    _UNSAFE  = /^[\],:{}\s]*$/,


/* Variables used by stringify */

    /**
     * Regex used to replace special characters in strings for JSON
     * stringification.
     *
     * @property _SPECIAL_CHARS
     * @type {RegExp}
     * @static
     * @private
     */
    _SPECIAL_CHARS = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,

    /**
     * Character substitution map for common escapes and special characters.
     *
     * @property _CHARS
     * @type {Object}
     * @static
     * @private
     */
    _CHARS = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    
    UNDEFINED = 'undefined',
    OBJECT    = 'object',
    NULL      = 'null',
    STRING    = 'string',
    NUMBER    = 'number',
    BOOLEAN   = 'boolean',
    DATE      = 'date',
    _allowable = {
        'undefined'        : UNDEFINED,
        'string'           : STRING,
        '[object String]'  : STRING,
        'number'           : NUMBER,
        '[object Number]'  : NUMBER,
        'boolean'          : BOOLEAN,
        '[object Boolean]' : BOOLEAN,
        '[object Date]'    : DATE,
        '[object RegExp]'  : OBJECT
    },
    EMPTY     = '',
    OPEN_O    = '{',
    CLOSE_O   = '}',
    OPEN_A    = '[',
    CLOSE_A   = ']',
    COMMA     = ',',
    COMMA_CR  = ",\n",
    CR        = "\n",
    COLON     = ':',
    COLON_SP  = ': ',
    QUOTE     = '"';

// Only accept JSON objects that report a [[Class]] of JSON
Native = _toStr.call(Native) === '[object JSON]' && Native;

// Escapes a special character to a safe Unicode representation
function _char(c) {
    if (!_CHARS[c]) {
        _CHARS[c] =  '\\u'+('0000'+(+(c.charCodeAt(0))).toString(16)).slice(-4);
    }
    return _CHARS[c];
}


/* functions used by parse */

/**
 * Traverses nested objects, applying a filter or reviver function to
 * each value.  The value returned from the function will replace the
 * original value in the key:value pair.  If the value returned is
 * undefined, the key will be omitted from the returned object.
 *
 * @method _revive
 * @param data {MIXED} Any JavaScript data
 * @param reviver {Function} filter or mutation function
 * @return {MIXED} The results of the filtered/mutated data structure
 * @private
 */
function _revive(data, reviver) {
    var walk = function (o,key) {
        var k,v,value = o[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (l.hasOwnProperty(value,k)) {
                    v = walk(value, k);
                    if (v === undefined) {
                        delete value[k];
                    } else {
                        value[k] = v;
                    }
                }
            }
        }
        return reviver.call(o,key,value);
    };

    return typeof reviver === 'function' ? walk({'':data},'') : data;
}

/**
 * Replace certain Unicode characters that may be handled incorrectly by
 * some browser implementations.
 *
 * @method _prepare
 * @param s {String} parse input
 * @return {String} sanitized JSON string ready to be validated/parsed
 * @private
 */
function _prepare(s) {
    return s.replace(_UNICODE_EXCEPTIONS, _char);
}

function _isSafe(str) {
    return l.isString(str) &&
            _UNSAFE.test(str.replace(_ESCAPES,'@').
                             replace(_VALUES,']').
                             replace(_BRACKETS,''));
}

function _parse(s,reviver) {
    // sanitize
    s = _prepare(s);

    // Ensure valid JSON
    if (_isSafe(s)) {
        // Eval the text into a JavaScript data structure, apply the
        // reviver function if provided, and return
        return _revive( eval('(' + s + ')'), reviver );
    }

    // The text is not valid JSON
    throw new SyntaxError('JSON.parse');
}



/* functions used by stringify */

// Utility function used to determine how to serialize a variable.
function _type(o) {
    var t = typeof o;
    return  _allowable[t] ||              // number, string, boolean, undefined
            _allowable[_toStr.call(o)] || // Number, String, Boolean, Date
            (t === OBJECT ?
                (o ? OBJECT : NULL) :     // object, array, null, misc natives
                UNDEFINED);               // function, unknown
}

// Enclose escaped strings in quotes
function _string(s) {
    return QUOTE + s.replace(_SPECIAL_CHARS, _char) + QUOTE;
}

// Adds the provided space to the beginning of every line in the input string
function _indent(s,space) {
    return s.replace(/^/gm, space);
}

// JavaScript implementation of stringify (see API declaration of stringify)
function _stringify(o,w,space) {
    if (o === undefined) {
        return undefined;
    }

    var replacer = isFunction(w) ? w : null,
        format   = _toStr.call(space).match(/String|Number/) || [],
        _date    = pega.lang.JSON.dateToString,
        stack    = [],
        tmp,i,len;

    if (replacer || !isArray(w)) {
        w = undefined;
    }

    // Ensure whitelist keys are unique (bug 2110391)
    if (w) {
        tmp = {};
        for (i = 0, len = w.length; i < len; ++i) {
            tmp[w[i]] = true;
        }
        w = tmp;
    }

    // Per the spec, strings are truncated to 10 characters and numbers
    // are converted to that number of spaces (max 10)
    space = format[0] === 'Number' ?
                new Array(Math.min(Math.max(0,space),10)+1).join(" ") :
                (space || EMPTY).slice(0,10);

    function _serialize(h,key) {
        var value = h[key],
            t     = _type(value),
            a     = [],
            colon = space ? COLON_SP : COLON,
            arr, i, keys, k, v;

        // Per the ECMA 5 spec, toJSON is applied before the replacer is
        // called.  Also per the spec, Date.prototype.toJSON has been added, so
        // Date instances should be serialized prior to exposure to the
        // replacer.  I disagree with this decision, but the spec is the spec.
        if (isObject(value) && isFunction(value.toJSON)) {
            value = value.toJSON(key);
        } else if (t === DATE) {
            value = _date(value);
        }

        if (isFunction(replacer)) {
            value = replacer.call(h,key,value);
        }

        if (value !== h[key]) {
            t = _type(value);
        }

        switch (t) {
            case DATE    : // intentional fallthrough.  Pre-replacer Dates are
                           // serialized in the toJSON stage.  Dates here would
                           // have been produced by the replacer.
            case OBJECT  : break;
            case STRING  : return _string(value);
            case NUMBER  : return isFinite(value) ? value+EMPTY : NULL;
            case BOOLEAN : return value+EMPTY;
            case NULL    : return NULL;
            default      : return undefined;
        }

        // Check for cyclical references in nested objects
        for (i = stack.length - 1; i >= 0; --i) {
            if (stack[i] === value) {
                throw new Error("JSON.stringify. Cyclical reference");
            }
        }

        arr = isArray(value);

        // Add the object to the processing stack
        stack.push(value);

        if (arr) { // Array
            for (i = value.length - 1; i >= 0; --i) {
                a[i] = _serialize(value, i) || NULL;
            }
        } else {   // Object
            // If whitelist provided, take only those keys
            keys = w || value;
            i = 0;

            for (k in keys) {
                if (keys.hasOwnProperty(k)) {
                    v = _serialize(value, k);
                    if (v) {
                        a[i++] = _string(k) + colon + v;
                    }
                }
            }
        }

        // remove the array from the stack
        stack.pop();

        if (space && a.length) {
            return arr ?
                OPEN_A + CR + _indent(a.join(COMMA_CR), space) + CR + CLOSE_A :
                OPEN_O + CR + _indent(a.join(COMMA_CR), space) + CR + CLOSE_O;
        } else {
            return arr ?
                OPEN_A + a.join(COMMA) + CLOSE_A :
                OPEN_O + a.join(COMMA) + CLOSE_O;
        }
    }

    // process the input
    return _serialize({'':o},'');
}


/* Public API */
pega.lang.JSON = {
    /**
     * Leverage native JSON parse if the browser has a native implementation.
     * In general, this is a good idea.  See the Known Issues section in the
     * JSON user guide for caveats.  The default value is true for browsers with
     * native JSON support.
     *
     * @property useNativeParse
     * @type Boolean
     * @default true
     * @static
     */
    useNativeParse : !!Native,

    /**
     * Leverage native JSON stringify if the browser has a native
     * implementation.  In general, this is a good idea.  See the Known Issues
     * section in the JSON user guide for caveats.  The default value is true
     * for browsers with native JSON support.
     *
     * @property useNativeStringify
     * @type Boolean
     * @default true
     * @static
     */
    useNativeStringify : !!Native,

    /**
     * Four step determination whether a string is safe to eval. In three steps,
     * escape sequences, safe values, and properly placed open square brackets
     * are replaced with placeholders or removed.  Then in the final step, the
     * result of all these replacements is checked for invalid characters.
     *
     * @method isSafe
     * @param str {String} JSON string to be tested
     * @return {boolean} is the string safe for eval?
     * @static
     */
    isSafe : function (s) {
        return _isSafe(_prepare(s));
    },

    /**
     * <p>Parse a JSON string, returning the native JavaScript
     * representation.</p>
     *
     * <p>When lang.JSON.useNativeParse is true, this will defer to the native
     * JSON.parse if the browser has a native implementation.  Otherwise, a
     * JavaScript implementation based on http://www.json.org/json2.js
     * is used.</p>
     *
     * @method parse
     * @param s {string} JSON string data
     * @param reviver {function} (optional) function(k,v) passed each key:value
     *          pair of object literals, allowing pruning or altering values
     * @return {MIXED} the native JavaScript representation of the JSON string
     * @throws SyntaxError
     * @static
     */
    parse : function (s,reviver) {
        return Native && pega.lang.JSON.useNativeParse ?
            Native.parse(s,reviver) : _parse(s,reviver);
    },

    /**
     * <p>Converts an arbitrary value to a JSON string representation.</p>
     *
     * <p>Objects with cyclical references will trigger an exception.</p>
     *
     * <p>If a whitelist is provided, only matching object keys will be
     * included.  Alternately, a replacer function may be passed as the
     * second parameter.  This function is executed on every value in the
     * input, and its return value will be used in place of the original value.
     * This is useful to serialize specialized objects or class instances.</p>
     *
     * <p>If a positive integer or non-empty string is passed as the third
     * parameter, the output will be formatted with carriage returns and
     * indentation for readability.  If a String is passed (such as "\t") it
     * will be used once for each indentation level.  If a number is passed,
     * that number of spaces will be used.</p>
     *
     * <p>When lang.JSON.useNativeStringify is true, this will defer to the
     * native JSON.stringify if the browser has a native implementation.
     * Otherwise, a JavaScript implementation is used.</p>
     *
     * @method stringify
     * @param o {MIXED} any arbitrary object to convert to JSON string
     * @param w {Array|Function} (optional) whitelist of acceptable object keys
     *                  to include OR a function(value,key) to alter values
     *                  before serialization
     * @param space {Number|String} (optional) indentation character(s) or
     *                  depthy of spaces to format the output 
     * @return {string} JSON string representation of the input
     * @throws Error
     * @static
     */
    stringify : function (o,w,space) {
        return Native && pega.lang.JSON.useNativeStringify ?
            Native.stringify(o,w,space) : _stringify(o,w,space);
    },

    /**
     * Serializes a Date instance as a UTC date string.  Used internally by
     * the JavaScript implementation of stringify.  If you need a different
     * Date serialization format, override this method.  If you change this,
     * you should also set useNativeStringify to false, since native JSON
     * implementations serialize Dates per the ECMAScript 5 spec.  You've been
     * warned.
     *
     * @method dateToString
     * @param d {Date} The Date to serialize
     * @return {String} stringified Date in UTC format YYYY-MM-DDTHH:mm:SSZ
     * @static
     */
    dateToString : function (d) {
        function _zeroPad(v) {
            return v < 10 ? '0' + v : v;
        }

        return d.getUTCFullYear()         + '-' +
            _zeroPad(d.getUTCMonth() + 1) + '-' +
            _zeroPad(d.getUTCDate())      + 'T' +
            _zeroPad(d.getUTCHours())     + COLON +
            _zeroPad(d.getUTCMinutes())   + COLON +
            _zeroPad(d.getUTCSeconds())   + 'Z';
    },

    /**
     * Reconstitute Date instances from the default JSON UTC serialization.
     * Reference this from a reviver function to rebuild Dates during the
     * parse operation.
     *
     * @method stringToDate
     * @param str {String} String serialization of a Date
     * @return {Date}
     */
    stringToDate : function (str) {
        var m = str.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d{3}))?Z$/);
        if (m) {
            var d = new Date();
            d.setUTCFullYear(m[1], m[2]-1, m[3]);
            d.setUTCHours(m[4], m[5], m[6], (m[7] || 0));
            return d;
        }
        return str;
    }
};

/**
 * <p>Four step determination whether a string is safe to eval. In three steps,
 * escape sequences, safe values, and properly placed open square brackets
 * are replaced with placeholders or removed.  Then in the final step, the
 * result of all these replacements is checked for invalid characters.</p>
 *
 * <p>This is an alias for isSafe.</p>
 *
 * @method isValid
 * @param str {String} JSON string to be tested
 * @return {boolean} is the string safe for eval?
 * @static
 * @deprecated use isSafe
 */
pega.lang.JSON.isValid = pega.lang.JSON.isSafe;

})();
pega.register("json", pega.lang.JSON, {version: "2.8.1", build: "19"});
//static-content-hash-trigger-GCC
if (typeof(pega) != "undefined") {
	/* HFIX-9650:BUG-161363: Kept if check to avoid exception when loaded in a new <iframe> when FilePath control is used. */
	(function (p) {

		if (!p.control) {
			p.c = p.namespace("pega.control");
		} else {
			p.c = pega.control;
		}
      /* var SKELETON={
          "LAUNCH_HARNESS":"launchHarnessSkeleton",
          "OPEN_WORK":"openWorkSkeleton"
        }*/
		/*
		@constructor
		@protected - Constructor description goes here.
		@return $undefined$ - return description goes here.
		 */
		p.c.Actions = function () {};
//cvbnml
		p.c.Actions.prototype = {
          	/*
            @protected- Set native transition on mobile.
			      @return $undefined$.
            */
          	setMobileTransition: function(){
              var mobileTransitionType;
              if(arguments && arguments[0]){
                mobileTransitionType = arguments[0];
              }
              if(pega.mobile && pega.mobile.hybrid && pega.mobile.hybrid.getLaunchBox() && pega.mobile.hybrid.getLaunchBox().NativePageSwitcher && mobileTransitionType) {               
                if(!mobileTransitionType.startsWith("pega.SKELETON")){
                  var transitionID = mobileTransitionType.replace("pega.mobile.transitions.", "");
        	        var transitionObj = pega.mobile.transitions[transitionID];
        	        if (transitionObj){
                    var typeName = transitionObj.transition.replace("launchbox.ui.transition.Type.", "");
                    var type = pega.mobile.hybrid.getLaunchBox().ui.transition.Type[typeName];
                     if(transitionObj.direction) {
                      var directionKey = transitionObj.direction.replace("launchbox.ui.transition.Direction.","");
                      var direction = pega.mobile.hybrid.getLaunchBox().ui.transition.Direction[directionKey];
                      if (type){
                        pega.mobile.hybrid.getLaunchBox().NativePageSwitcher.setNextTransition({"type": type, "duration" : transitionObj.duration, "delay": transitionObj.delay, "direction": direction});                         
                      }                                            
                    }
                  }
                } 
              }
              var isTargetOther = false;
              if(mobileTransitionType && mobileTransitionType.startsWith("pega.SKELETON")){                
                  var argArray = mobileTransitionType.split("~$~");
                  if(argArray && argArray.length > 2){                    
                    isTargetOther = argArray[3] == "true" ? true : false;
                  }               
              }
              var navUserAgent = navigator.userAgent;
              var isMobile =  navUserAgent.match(/Android/i) || navUserAgent.match(/BlackBerry/i) || navUserAgent.match(/iPhone|iPad|iPod/i) || navUserAgent.match(/Opera Mini/i) || navUserAgent.match(/IEMobile/i);
              var isTablet = navUserAgent.match(/Tablet|iPad|iPod/i);
              if(mobileTransitionType && mobileTransitionType.startsWith("pega.SKELETON") && ((pega.mobile && pega.mobile.hybrid && pega.mobile.hybrid.getLaunchBox() && pega.mobile.hybrid.getLaunchBox().NativePageSwitcher) || isTargetOther || (isMobile && !isTablet))){
                   pega.mobile.hybrid.showSkeleton = true;
                   /*pega.mobile.hybrid.skeletonName = "pyLaunchHarnessSkeleton"; 
                   pega.mobile.hybrid.classForSkeleton = "baseclass";*/
                   pega.mobile.hybrid.isTargetOther = isTargetOther;
                    
                   if(arguments && arguments[0]){
                     var argArray = arguments[0].split("~$~");
                     if(argArray && argArray.length > 1){
                       pega.mobile.hybrid.skeletonName = argArray[1]; 
                       pega.mobile.hybrid.classForSkeleton = argArray[2].replace("@","");
                       pega.mobile.hybrid.otherTargetName = argArray[4];
                     }
                   }
                } else{
                  pega.mobile.hybrid.isTargetOther = false;
                }
            },
            isVisible : function (elem){
	            return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
            },
            /* native fadeout implementation */
            nativeFadeOut : function(target, interval, callback){
              if(target && target.length >= 0){
                 for(var i = 0 ; i <target.length ; i++){
                   if(pega.control.Actions.prototype.isVisible(target[i])){                     
                     pega.control.Actions.prototype.nativeFadeOut(target[i], interval, callback);
                   }
                 }
              } else{
                var fadeEffect = setInterval(function () {
                  if (target && !target.style.opacity) {
                    target.style.opacity = 1;
                  }
                  if (target && target.style.opacity < 0.1) {
                    clearInterval(fadeEffect);
                    if(typeof callback == "function"){
                      callback();
                    }
                    target.style.opacity = "";
                    target.style.display = 'none'; 
                  } else {
                    if(target)
                    target.style.opacity -= 0.2;
                  }
                  return;
                }, interval);
              }
            },
			  showSkeleton:function(skeletonId, animDirection){

                  var navUserAgent = navigator.userAgent;
                  var isMobile =  navUserAgent.match(/Android/i) || navUserAgent.match(/BlackBerry/i) || navUserAgent.match(/iPhone|iPad|iPod/i) || navUserAgent.match(/Opera Mini/i) || navUserAgent.match(/IEMobile/i);
                  var isTablet = navUserAgent.match(/Tablet|iPad|iPod/i);
                  var isHybrid = (navUserAgent.toLowerCase().indexOf('pegamobilesdk') != -1) || (navUserAgent.toLowerCase().indexOf('ampwebcontrol') != -1) || (navUserAgent.toLowerCase().indexOf('pegaelectroncontainer') != -1) || (isMobile && !isTablet);
                    var isFrameBased = (window === window.parent) ? false : true;
                  if ((!isHybrid && pega.mobile.hybrid.isTargetOther !== true) || (pega.mobile && pega.mobile.hybrid && pega.mobile.hybrid.showSkeleton !== true) || (!pega.mobile.hybrid.isTargetOther && isFrameBased)) { return;}
                    if(!animDirection){
                      if(!pega.mobile.hybrid.isTargetOther || (isHybrid)){
                        /* BUG-378406 */
                        var nodeListMask = document.querySelectorAll("#pega_ui_mask");
                        for(var i =0; i < nodeListMask.length ; i++){
                          if(nodeListMask[i])
                            nodeListMask[i].style.display = "none";
                        }
                        pega.ui.busyIndicator.prototype.hide();
                        var nodeListFooter = document.querySelectorAll('.phone .screen-layout-footer > .screen-layout-region-footer');
                        for(var i =0; i < nodeListFooter.length ; i++){
                          if(nodeListFooter[i])
                            nodeListFooter[i].className += " modal-in-skeleton";
                        }
                      }
                      
                      var showSkeletonId = "#"+pega.mobile.hybrid.skeletonName+"-"+pega.mobile.hybrid.classForSkeleton;
                      if(pega.mobile && pega.mobile.hybrid && document.querySelectorAll(showSkeletonId).length > 0){
                        if(pega.mobile.hybrid.isTargetOther){
                          var otherTargetName = pega.mobile.hybrid.otherTargetName?pega.mobile.hybrid.otherTargetName:"acprimary";
                          var microdcElem = document.getElementById(otherTargetName);
                          /* In some cases id attribute is not populated for microdc. If it gets consistenetly generated then the below line can be removed*/
                          if(!microdcElem)
                             microdcElem = document.querySelector("[data-mdc-id='"+otherTargetName+"']");
                          if(microdcElem){
                          
                            var skeletonElem = document.querySelector(showSkeletonId);
                            if(skeletonElem){
                              skeletonElem = skeletonElem.cloneNode(true);
                              if(microdcElem && !microdcElem.querySelector(showSkeletonId)){
                                microdcElem.appendChild(skeletonElem);
                              }
                              if(skeletonElem){
                                microdcElem.style.position="relative";
                              }
                              skeletonElem.style.display = "block";
                              //microdcElem.lastChild.style.display = "block";
                              if(skeletonElem && skeletonElem.offsetHeight>0){
                                microdcElem.style.height=skeletonElem.offsetHeight+"px";
                                microdcElem.style.overflow="hidden";
                              }
                            }                            
                          }                         
                        } else{
                            var nodeListSkeleton = document.querySelectorAll(showSkeletonId);
                            for(var i =0; i < nodeListSkeleton.length ; i++){
                              if(nodeListSkeleton[i])
                                nodeListSkeleton[i].style.display = "block";
                            }
                        }
                      } /*else{
                         document.querySelectorAll("#"+skeletonId).forEach(function(element) {
                           if(element)
                           element.style.display = "block";
                         });
                      }*/                    
                    } /* not req. currently no animation option provided for skeleton else{
                      var $skeletonObj;
                      if(pega.mobile && pega.mobile.hybrid && $("#"+pega.mobile.hybrid.skeletonName+"-"+pega.mobile.hybrid.classForSkeleton).length > 0){
                         $skeletonObj = $("#"+pega.mobile.hybrid.skeletonName+"-"+pega.mobile.hybrid.classForSkeleton);
                      } else{
                         $skeletonObj = $("#"+skeletonId);  
                      }
                      
                      $skeletonObj.show("slide", { direction: animDirection }, 300, function(){ 
                              var start = new Date().getTime();
                              var end = start;
                              while(end < start + 500)  {
                                  end = new Date().getTime();
                              } 
                          });
                    }*/
                    $('body').append('<div class="no-event-skeleton" />');
                    setTimeout(function(){
                      $('.no-event-skeleton').remove();
                    },6000);
              },
			
			         hideSkeleton:function(referer,customTimeout){
                 var navUserAgent = navigator.userAgent;
                 var isMobile =  navUserAgent.match(/Android/i) || navUserAgent.match(/BlackBerry/i) || navUserAgent.match(/iPhone|iPod/i) || navUserAgent.match(/Opera Mini/i) || navUserAgent.match(/IEMobile/i);
                 var isTablet = navUserAgent.match(/Tablet|iPad|iPod/i);
                 var isHybrid = (navUserAgent.toLowerCase().indexOf('pegamobilesdk') != -1) || (navUserAgent.toLowerCase().indexOf('ampwebcontrol') != -1) || (navUserAgent.toLowerCase().indexOf('pegaelectroncontainer') != -1) || (isMobile && !isTablet);
                 var isFrameBased = (window === window.parent) ? false : true;
                 if (!isHybrid && pega.mobile.hybrid.isTargetOther !== true || (!pega.mobile.hybrid.isTargetOther && isFrameBased)) { return;}
                     if(!pega.mobile.hybrid.isTargetOther || (isHybrid)){
                       /* BUG-378406 */
                       var nodeListMask = document.querySelectorAll("#pega_ui_mask");
                       for(var i =0; i < nodeListMask.length ; i++){
                         if(nodeListMask[i])
                           nodeListMask[i].style.display = "none";
                       }
                       pega.ui.busyIndicator.prototype.hide();
                     }
                     if(referer){
                        if(pega.mobile && pega.mobile.hybrid && document.querySelectorAll("#"+pega.mobile.hybrid.skeletonName+"-"+pega.mobile.hybrid.classForSkeleton).length > 0){
                           pega.control.Actions.prototype.nativeFadeOut(document.querySelectorAll("#"+pega.mobile.hybrid.skeletonName+"-"+pega.mobile.hybrid.classForSkeleton),1); 
                        }/* else {
                           pega.control.Actions.prototype.nativeFadeOut(document.querySelectorAll("#"+SKELETON.OPEN_WORK),1);
                           pega.control.Actions.prototype.nativeFadeOut(document.querySelectorAll("#"+SKELETON.LAUNCH_HARNESS),1);
                        }*/
                         /* BUG-378406 */
                         var nodeListFooter = document.querySelectorAll(".phone .screen-layout-footer > .screen-layout-region-footer");
                         for(var i =0; i < nodeListFooter.length ; i++){
                           if(nodeListFooter[i])
                             nodeListFooter[i].className.replace("modal-in-skeleton","");
                         }
                     }else{
                         setTimeout(function(){
                             if(!pega.mobile.hybrid.isTargetOther){
                               /* BUG-378406 */
                               var nodeListMaskInner = document.querySelectorAll("#pega_ui_mask");
                               for(var i =0; i < nodeListMaskInner.length ; i++){
                                 if(nodeListMaskInner[i])
                                   nodeListMaskInner[i].style.display = "none";
                               }
                               pega.ui.busyIndicator.prototype.hide();
                             }
                             var hideSkeletonId = "#"+pega.mobile.hybrid.skeletonName+"-"+pega.mobile.hybrid.classForSkeleton;
                             if(pega.mobile && pega.mobile.hybrid && document.querySelectorAll(hideSkeletonId).length > 0){
                               if(pega.mobile.hybrid.isTargetOther){
                                 
                                 var otherTargetName = pega.mobile.hybrid.otherTargetName?pega.mobile.hybrid.otherTargetName:"acprimary";
                                 var microdcElem = document.getElementById(otherTargetName);
                                   /* In some cases id attribute is not populated for microdc. If it gets consistenetly generated then the below line can be removed*/
                                 if(!microdcElem)
                                   microdcElem = document.querySelector("[data-mdc-id='"+otherTargetName+"']");
                                 if(microdcElem){
                                   microdcElem.style.height="";                                    
                                   var skeletonElem = microdcElem.querySelector(hideSkeletonId);                              
                                   if(skeletonElem){
                                     pega.control.Actions.prototype.nativeFadeOut(skeletonElem, 50, function(){
                                       try{
                                         pega.mobile.hybrid.isTargetOther = false;
                                         microdcElem.removeChild(skeletonElem);
                                       }catch(e){
                                         
                                       }
                                       microdcElem.style.position="";
                                       microdcElem.style.overflow = "";
                                     });
                                   }
                                   microdcElem.style.height="";
                                 }
                               } else{
                                 pega.control.Actions.prototype.nativeFadeOut(document.querySelectorAll(hideSkeletonId), customTimeout ? customTimeout : 100);
                               }
                             } else{  
                               pega.mobile.hybrid.isTargetOther = false;
                               /*pega.control.Actions.prototype.nativeFadeOut(document.querySelectorAll("#"+SKELETON.OPEN_WORK), 100);
                               pega.control.Actions.prototype.nativeFadeOut(document.querySelectorAll("#"+SKELETON.LAUNCH_HARNESS), 100);*/
                             } 
                             /*if(pega.mobile && pega.mobile.hybrid){
                               pega.mobile.hybrid.skeletonName = "pyLaunchHarnessSkeleton";
                               pega.mobile.hybrid.classForSkeleton = "baseclass";
                             }*/                             
                         }, 500);
                         /* Removing footer z-index class after fadeout(100) and settimeout(150) */
                         setTimeout(function() {
                           $('.no-event-skeleton').remove();
                           var nodeListFooterInner = document.querySelectorAll(".phone .screen-layout-footer > .screen-layout-region-footer");
                           for(var i =0; i < nodeListFooterInner.length ; i++){
                             if(nodeListFooterInner[i])
                               nodeListFooterInner[i].className.replace("modal-in-skeleton","");
                           }
                         }, 700);
                     }
                     if(pega.mobile && pega.mobile.hybrid) {pega.mobile.hybrid.showSkeleton = false;}
			   },
      /* @protected- This API is used to append pages to an existing pageList/DataPage
			 */
			addToRepeatSource : function () {
				window.addToRepeatSource.apply(null, arguments);
			},
            /* @protected- This API is used to remove pages from an existing pageList/DataPage
			 */
			removeFromRepeatSource : function () {
				window.removeFromRepeatSource.apply(null, arguments);
			},
            /* @protected- This API is used to edit an item bound to a page list / data page
			 */
			editRepeatItem : function () {
				window.editRepeatItem.apply(null, arguments);
			},
			/*
			@protected- Function description goes here.
			@return $undefined$ - return description goes here.
			 */
			ShowSubscriptPrompt : function () {
				window.ShowSubscriptPrompt.apply(null, arguments);
			},
			/*
			@protected- Function description goes here.
			@return $undefined$ - return description goes here.
			 */
			AppendToList : function () {
				window.AppendToList.apply(null, arguments);
			},
			/*
			@protected- Function description goes here.
			@return $undefined$ - return description goes here.
			 */
			RemoveFromGroup : function () {
				window.RemoveFromGroup.apply(null, arguments);
			},
			/*
			@protected- Function description goes here.
			@return $undefined$ - return description goes here.
			 */
			RemoveFromList : function () {
				window.RemoveFromList.apply(null, arguments);
			},

			/*
			@protected- Function description goes here.
			@return $undefined$ - return description goes here.
			 */
			doFormSubmit : function () {
				pega.u.d.submit.apply(pega.u.d, arguments);
			},

			/*
			@protected- Function description goes here.
			@return $undefined$ - return description goes here.
			 */
			processAction : function () {
				/* in case of error message */
				if (arguments.length == 1) {
					alert(arguments[0]);
					return;
				}

				var actionURL = new SafeURL();
				if (arguments[3]) {
					actionURL.put("BaseReference", arguments[3]);
				}
				actionURL.put("IgnoreSectionSubmit", true);
				actionURL.put("bInvokedFromControl", true);
				var bModalDialog = true;
				/*for Replace Current and Modal Dialog target, bModalDialog will be set as boolean value. For Overlay mode, String "overlay" is passed - Autobots*/
				if (arguments[1]) {
					if (arguments[1].toUpperCase() == "FALSE") {
						bModalDialog = false;
					} else if (arguments[1].toUpperCase() == "OVERLAY") {
						bModalDialog = "overlay"
					}
				}

				/* US-58608: Determine if local action is invoked from processAction */
				if (typeof(Grids) != 'undefined' && bModalDialog) {
					var e = arguments[2];
					if (e) {
						var temp_gridObj = Grids.getActiveGrid(e) || e["cachedGridObj"];
						temp_gridObj && (temp_gridObj.__fromLocalAction = true);
					}
				}
        /* Changed arguments 7 and 8 as animations JSONStr and bMobileFullScreenModal respectively as part of US-265505 */
        var animObj,options={};
        if(arguments[7]) {
          options.isLocalAction = true;
          try {
            animObj = JSON.parse(decodeURIComponent(arguments[7]));
          } catch(e){
            animObj = {
              animIn : arguments[7],
              animOut :  arguments[8]
            };
          }
          options.animObj = animObj;
        }
        if(arguments[8]) {
          options.isMobileFullScreen = arguments[8];
        }
        if(arguments[9]) {
          options.fAObjClass = arguments[9];
        }

        if(arguments[10]) {
          options.mTObjClass = arguments[10];
        }
		              
        /*@sings9: Changed the arguments[12] to arguments[11] as the one argument has been reduced
		       	in the processAction call from actionLocalAction.
		      	*/
				/*US-58245: Send custom template name as the 8th argument if present */
				//US-79038 Disable clickaway configuration
			 	if(arguments[11]==null || typeof(arguments[11])=="undefined") {
			 		arguments[11]=false;
			 	}
				//Center Position Overlay
				if(arguments[12]==null || typeof(arguments[12])=="undefined") {
					options.isCenterOverlay = false;
			 	}
				else{
					options.isCenterOverlay = arguments[12];
				}
        
         /* added for US-229126 - parmn */
        if(arguments[13] && arguments[13] == "firstuse" && arguments[14]){
           options.loadBehaviour = arguments[13];
           options.uniqueId = arguments[14];
        }

				pega.u.d.processAction(arguments[0], '', arguments[4], '', '', bModalDialog, arguments[2], arguments[6] || "", actionURL, '', '', arguments.length > 5 ? arguments[5] : '','',options,arguments[11]);
			},
			/*
			@protected- Function description goes here.
			@return $undefined$ - return description goes here.
			 */
			setUserStart : function () {
				window.setUserStart.apply(null, arguments);
			},

			/*
			@protected- Function description goes here.
			@return $undefined$ - return description goes here.
			 */
			showList : function () {
				pega.d.showList.apply(pega.d, arguments);
			},

            /*
            @protected- Function description goes here.
            @return $undefined$ - return description goes here.
            */
            runScript : function () {
              try {
                var event = (arguments.caller || pega.control.Actions.prototype.runScript.caller.arguments)[0];
          var originalEvent = window.event;
          /* move "event" to global variable, because gcc compression will rename the local "event" 
             and eval will not work properly */
          window.event = event;
          
                eval(arguments[0]);

          /* restore window.event */
          window.event = originalEvent;
              } catch (e) {}
            },

			/*@protected chens3 - GRP-42698- action to fire apply conditions on element - end */
			fireACOnElem : function (e) {
                var target = e.target;
                var nameAtr = target.getAttribute("name");
                if(!nameAtr) nameAtr = "";
                target.setAttribute('PN', '.' + nameAtr.substring(nameAtr.lastIndexOf('$p') + 2));
                nameAtr = nameAtr.substring(0, nameAtr.lastIndexOf('$p'));
                var index = nameAtr.lastIndexOf('$l') == -1 ? (nameAtr.lastIndexOf('$g') == -1 ? -1 : nameAtr.substring(nameAtr.lastIndexOf('$g') + 2)) : nameAtr.substring(nameAtr.lastIndexOf('$l') + 2);
                handleClientEvent('CLIENT', '', '', index, e);
			},
			/*@protected chens3 - implicit action to fire apply condition on change list JSON of change tracker */
			evaluateClientConditions : function () {
				pega.u.d.evaluateClientConditionsOnChangeList();
			},

			/*@protected New logoff action added - Delta Touch */
			logOff : function (event) {
            	var parentWindow;
              pega.ui.EventsEmitter.publishSync("BeforeLogOff");
				if (pega.mobile && typeof pega.mobile.getDesktopWindow() === 'function') {
					parentWindow = pega.mobile.getDesktopWindow();
        } else {
          var tempWin = p.desktop.support.getDesktopWindow();
    			parentWindow = tempWin ? tempWin : window;
        }
        // If in Live Composer Mode then the parentWindow should be forced to composer window
        if (pega.ui && pega.ui.composer && pega.ui.composer.isActive()) {
          parentWindow = pega.ui.composer.getCurrentComposerWindow();
        }
              
        if (typeof parentWindow.prpcmobileapp != "undefined") {

				  var strUrlSF = SafeURL_createFromURL(pega.u.d.url);
			    strUrlSF.put("pyActivity", "LogOff");
				  strUrlSF.put("pzPrimaryPageName", "pyDisplayHarness");

				  var callback = {
					  success : function (responseObj) {
						  console.log("about to call plugin");
						  parentWindow.prpcmobileapp.showAppList();
					  },
					  failure : function (oResponse) {
						  alert("Your session may not have ended properly.");
						  parentWindow.prpcmobileapp.showAppList();
					  }
				  }

				  try {
					  parentWindow.navigator.splashscreen.show();
				  } catch (e) {}
					var response = pega.util.Connect.asyncRequest('GET', strUrlSF.toURL(), callback, null);
				} else if (pega.mobile && pega.mobile.hybrid && pega.mobile.hybrid.getLaunchBox()) { // Supported by HC and NativeSDK
                  
                  /*BUG-251569 : Add dirty check before triggering native logout which triggers the dirty check very late after actual logoff due to AccountManager.closeAccount */
                   var dirty = pega.u.d.isFormDirty(true);
                    if(dirty)
                      {
                        pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
                        return;
                      }
                  else
					p.m.hybrid.logOut();
                } else {

					event = event == undefined ? window.event : event;
					if (event) {
						pega.util.Event.stopEvent(event);
					}
					/* BUG-109795 */
					if (parentWindow != null) {
						parentWindow.logout = true;
					}

					var oSafeURL = SafeURL_createFromURL('pyActivity=LogOff&pzPrimaryPageName=pyDisplayHarness');
					/* BUG-117858 */
					var queryString = oSafeURL.toQueryString();
					var bEncryptURLs = pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty('bEncryptURLs');
					/* BUG-135434 - start - singp1 */
					if (typeof bEncryptURLs != "undefined" && bEncryptURLs && (queryString.indexOf("pyActivity") > -1 || queryString.indexOf("pyStream") > -1)) {
						queryString = URLObfuscation.encrypt(queryString);
					}
					/* BUG-135434 - end - singp1 */
                  	if (pega.u.MessagingManager && typeof(pega.u.MessagingManager.disconnect) == "function") {
                    	pega.u.MessagingManager.disconnect();  
                    }
					var delim = "?";
					var reqURI = "";
					if (typeof parentWindow.safeUrlRequestURI != "undefined") {
						reqURI = parentWindow.safeUrlRequestURI;
						parentWindow.location.href = reqURI + delim + queryString;
					} else {
						parentWindow.location.href = oSafeURL.toURL();
					}
                  
				}
			},
			/*@protected New Switch Portal Mode action added - Delta Touch */
			switchPortalMode : function () {

				// verify data connection is available
				if (!navigator.onLine) {
					alert('No network connection found.');
					return;
				}
				var parentWindow = pega.desktop.support.getDesktopWindow();
				var strUrlSF = new SafeURL("Data-Portal.pzSwitchPortalMode"),
				response,
				callback;
				strUrlSF.put("PortalMode", "mobile");

				callback = {
					success : function (responseObj) {
						var oShowDesktopUrl = new SafeURL("Data-Portal.ShowDesktop");
						var strUrlSF = new SafeURL("RedirectAndRun");
						strUrlSF.put("bPurgeTargetThread", "true");
						strUrlSF.put("Location", oShowDesktopUrl.toQueryString());
						strUrlSF.put("ThreadName", "");
						strUrlSF.put("AccessGroupName", "");
						parentWindow.location = strUrlSF.toURL();
					},
					failure : function (oResponse) {
						alert("Switch could not be completed successfully!! Please try later.");
					}
				}
				response = pega.util.Connect.asyncRequest('GET', strUrlSF.toURL(), callback, null);
			},
			doListAction: function() {
				pega.ui.template.DataRepeater.Actions.doListAction.apply(null, arguments);
			}, 
				publishEndOfQueue: function(e) {
              pega.u.ce.publish(pega.u.ce.EQ_COMPLETED, e);
	      },
		  };
	})(pega);

}
//static-content-hash-trigger-YUI
//<script>
/*
 This script defines the class IUIElement and the corresponding instance UIElement in pega.control namespace.
*/
if(typeof(pega) != "undefined") {/* HFIX-9650:BUG-161363: Kept if check to avoid exception when loaded in a new <iframe> when FilePath control is used. */
(function(p){
	if (!p.control) {
		p.c = p.namespace("pega.control");
	} else {
		p.c = pega.control;
	}
	
	p.c.IUIElement = function (type){
		this.type = type;
		this.Actions = new p.c.Actions();
	};
	p.c.IUIElement.prototype = {
		click: null,
		dblclick: null,
		focusin: null,
		focusout: null,
		change: null,
		keypress: null,
		keyup: null
	}
	p.c.UIElement = new p.c.IUIElement("UIElement");

	p.c.isActionableElement = function (elem) {
		/*BUG-192036 : In IE when button is clicked we always get button elem as target where as in chrome it is giving as inner div element, so checking for parent button element*/
      	var parentEle = elem;
      	var i = 0;
      	while(parentEle && i<=5){
           if(parentEle.tagName && parentEle.tagName.toLowerCase() == "button"){
             return true;
           }  
             parentEle = parentEle.parentNode;
             i++;
        }
      	/* BUG-309273: Ready only checkbox displayed as image */
      	if(elem.tagName && elem.tagName.toLowerCase() == "img") {		
          if(elem.classList && elem.classList.contains("checkbox") && elem.classList.contains("chkBxCtl")) {
            return false;		
          }		
        }
      	/* To avoid Null pointer Exception with right click on tree grid added navigation check */
		return elem.tagName.match(/^(a||img)$/gi) || /navigation/.test(elem.getAttribute("data-ctl"));
	};
	p.c.keyTypes = {13:"enter", 38:"up", 40:"down", 37:"left", 39:"right"};
	
         /*API to figure out if there are any keyUp listeners attached to an element with the given keyCode */
	p.c.hasKeyUpActions = function(elem, keyCode, isGrid) {
		if(isGrid ||(!this.isActionableElement(elem) && elem.getAttribute("data-ctl") && elem.getAttribute("data-ctl")!="")) {
			/*Check if the Auto generated control has keup behavior attached with the given keyCode or not*/
			var keyUpBehavior = elem.getAttribute("data-keyup");
			var bFlag = false;
			if(keyUpBehavior && keyUpBehavior.indexOf("[") == 0) {
				var parsedBehaviors=pega.c.eventParser.parseJSON(keyUpBehavior);
				var len = parsedBehaviors.length;
				for(var i=0; i<len; i++) {
					var evKeyCode = parsedBehaviors[i][parsedBehaviors[i].length-1];
					if(this.keyTypes[keyCode]==evKeyCode) {
						bFlag = true;
						break;
					}
				}
			}
			
			return bFlag;
		}
	};
	
	p.c.ImplicitKeyEvents = {
		"TEXTAREA" : ["enter","down","up"],
		"AUTOCOMPLETE" : ["enter","down","up"]
	};

	/*API to figure out if there are any implicit keyboard events attached to an element for a key code(e.g: TextArea - Enter,Up,Down)*/
	p.c.hasImplicitKeyBehaviorsForAuto = function(elem,keyCode) {
		var key = "",bFlag = false;
		if(!this.isActionableElement(elem) && elem.getAttribute("data-ctl") && elem.getAttribute("data-ctl")!="") {
			if(elem.tagName === "TEXTAREA") {
				key = "TEXTAREA";
			} else if(elem.tagName === "INPUT" && elem.getAttribute("data-ctl").toLowerCase().indexOf("autocomplete")!=-1) {
				key = "AUTOCOMPLETE";
				if(elem.getAttribute("data-ctl").toLowerCase().indexOf("autocompleteag")!=-1){
					if(keyCode === 13) {
						return false;
					}
				} else {
					if(p.c.ACSingleton && keyCode === 13) {
						return p.c.ACSingleton.isResultsPopupOpened(); // If results div of autocomplete is closed , then return false in case of Enter and allow grid actions to perform.
					}
				}
			} 

			if(key!="") {
				var imp_behaviors = p.c.ImplicitKeyEvents[key];
				if(imp_behaviors instanceof Array) {
					for(var i=0;i<imp_behaviors.length;i++) {
						if(this.keyTypes[keyCode] === imp_behaviors[i]) {
							bFlag = true;
							break;
						}
					}
				}
			}
			return bFlag;
		}
	};

	/*Returns true if the given element(non auto control) is allowed for keyboard actions inside grid*/
	p.c.isNonAutoControlAllowed = function(elem, keyCode) {
		/* Prompt Select control */
		if (elem.tagName.toUpperCase() == "SELECT") {
			if (keyCode == 13) {
				return true;
			}
		}
		/* Open Rule Advanced control */
		if(elem.tagName.toUpperCase() == "INPUT" && elem.getAttribute("ISNS_PROPERTYEXTRAS") && elem.getAttribute("ISNS_CLASS")) {
			if (keyCode == 13) {
				return true;
			}
		}
		return false;
	};

	p.c.PlaceHolder = {
		setFocus : function(elem) {
			setTimeout(function() { elem.blur(); setTimeout(function () { elem.focus(); }, 1); }, 1);
		},
		focusHandler : function(elem) {
			if(elem.getAttribute('isplaceholder') === 'true'){
				elem.removeAttribute('isplaceholder');
				p.c.PlaceHolder.removeClass(elem);
				elem.value = '';
              	elem.defaultValue=''; //Added for BUG-198210 - Autobots
			} else if(elem.getAttribute('ispassword') === 'true') {
				/* This is to change type from text to password after removing Placeholder text: START */
				var elem1 = pega.util.Dom.getPreviousSibling(elem);
				if(elem1) {
					elem.style.display = 'none';
					elem1.style.display = 'block';
					this.setFocus(elem1);
				}
				/* This is to change type from text to password after removing Placeholder text: END */
			}
		},
		blurHandler : function(elem) {
			var placeHolder = elem.getAttribute('ph');
			if(placeHolder && elem.value === '' && document.activeElement != elem) { /*BUG-60417 - Autobots*/
				if(elem.type === 'password'){
					var elem1 = pega.util.Dom.getNextSibling(elem);
					if(elem1) {
						elem.style.display = 'none';
						elem1.style.display = 'block';
					}
					/* This is to add validation to password field after replacing existing input element*/
					/* This is to Display Placeholder Text for password field : END */
				} else {
					elem.setAttribute('isplaceholder', 'true');
					p.c.PlaceHolder.addClass(elem);
					elem.value = placeHolder;
                  	elem.defaultValue=placeHolder; //Added for BUG-198210 - Autobots
				}
			}
		},
    getValue : function(elem) {
      if(elem.getAttribute('isplaceholder') === 'true') {
        return '';
      }
      var retValue = elem.value;
      /* US-59367: when input element selected to show readonly format when the element is not on focus,
				actual value will be available in data-value attribute */
      if (elem.tagName && elem.tagName.match(/^(input)$/gi)) {
        try {
          if (elem.getAttribute("data-formatting") === "done") {
            var originalValueStr = elem.getAttribute("data-value");
            if (typeof(originalValueStr) != undefined && originalValueStr != null) {
              retValue = originalValueStr;
            }
          }
          if (elem.getAttribute("data-auto-formatting") && elem.getAttribute("data-auto-formatting") === "true"){
            var dataValue = elem.getAttribute("data-value");
            if (typeof(dataValue) != undefined && dataValue != null) {
              retValue = pega.u.d.formatNumberWithOutSeparators(dataValue);
            }
          }
        } catch(e) { }
      }
      return retValue;
    },
		setValue : function(elem, value) {
			if(elem.getAttribute('ph')) {
				if(value === '' && document.activeElement != elem){ /*BUG-60417 - Autobots*/
					elem.value = value;
					p.c.PlaceHolder.blurHandler(elem);
				} else {
					if(document.activeElement != elem) /*BUG-60417 - Autobots*/
						p.c.PlaceHolder.focusHandler(elem);
					elem.value = value;
				}
			} else {
				elem.value = value;
        // BUG Fix setValue action not updating span when unchecked display read only on No text entry
        var elemName = elem.name;
        if(elem.type=="hidden" && (elem.getAttribute("data-calendar")=="Calendar" || elem.hasAttribute("data-datetype"))){ // added daterange check for setvalue
          var nextSibling = elem.nextSibling;
          if(nextSibling && nextSibling.tagName && nextSibling.tagName.toLowerCase()==="span" && nextSibling.getAttribute("name")===elemName){
            nextSibling.innerHTML= value;
          }
        }
			}
		},
		removePlaceHolderValues : function(formElem) {
			var elems = pega.util.Dom.getElementsByAttribute("isplaceholder", "true", "INPUT", formElem);
                    	for (var i = 0, l = elems.length; i< l; i++) {
				this.focusHandler(elems[i]);
                    	}
			var elems = pega.util.Dom.getElementsByAttribute("isplaceholder", "true", "TEXTAREA", formElem);
                    	for (var i = 0, l = elems.length; i< l; i++) {
				this.focusHandler(elems[i]);
                    	}
		},
		addPlaceHolderValues : function(formElem) {
			var elems = pega.util.Dom.getElementsByAttribute("ph", ".+", "INPUT", formElem);
			for (var i = 0, l = elems.length; i< l; i++) {
				this.blurHandler(elems[i]);
			}
			var elems = pega.util.Dom.getElementsByAttribute("ph", ".+", "TEXTAREA", formElem);
			for (var i = 0, l = elems.length; i< l; i++) {
				this.blurHandler(elems[i]);
			}
		},
		removeClass : function(elem) {
			pega.util.Dom.removeClass(elem, 'placeholder');
		},
		addClass : function(elem)  {
			pega.util.Dom.addClass(elem, 'placeholder');
		}
	};
})(pega);
}
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.template");

pega.ui.template.DataBinder = function () {

  var repeatingIndex = {}; /*USED ONLY BY TEMPLATIZED RDL to store a map of {RDLSourcePropertyName : UniqueIndexVariableNameForIteratingThisRDL}, e.g., {"D_pyUserWorkList" : "i1234567890", "D_pyUserSolutions" : "i6178239045"} which are generated by the RDL RUF*/

  /*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

  var resolveIndex = function (reference) {
    /*USED ONLY BY TEMPLATIZED RDL to resolve dashed squigglies, {-{i6178239045}-} with the corresponding current iteration's index value*/
    if (reference) {

      for (var ind in pega.ui.template.DataBinder.repeatingIndex) {

        var reg = "\\{\\-\\{" + ind + "\\}\\-\\}";

        reference = reference.replace(new RegExp(reg, "g"), pega.ui.template.DataBinder.repeatingIndex[ind]);
      }

      return reference;
    } else {

      return "";
    }
  };

  /* 
  	* Resolves the pattern to a path compatible with the When truth table
  	* i/p: "pyWorkPage.Features(2).CountriesList({-{i1481746750954}-}).StateList"
  	* o/p: "pyWorkPage.Features(2).CountriesList.2.StateList"
  	
  */
  var resolvePath = function (reference) {
    if (!reference) return "";

    for (var index in pega.ui.template.DataBinder.repeatingIndex) {
      var reg = "\\(\\{\\-\\{" + index + "\\}\\-\\}\\)";
      reference = reference.replace(new RegExp(reg, "g"), "." + (pega.ui.template.DataBinder.repeatingIndex[index] - 1) + "");
    }
    return reference;
  };

  /*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

  /* BEGIN HELPERS */
  var _databindHelper = { /*INTERNAL HELPER FUNCTIONS USED BY CUSTOM DATA BINDER, NOT EXPOSED IN THE RETURNED OBJECT IN THE LAST LINE OF THIS FILE*/

    getValueOf: function (el, item) {

      var $el = pega.ctx.dom.$(el);

      /*SANITIZE item*/

      item = $.trim(item);

      /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

      /* BEGIN SPECIAL CASES */

      if ((el.type == 'checkbox' || el.type == 'radio' || el.tagName.toUpperCase() == 'SELECT') && item == "value") {
        /*a checkbox or a radiobutton or a select tag with data-bindprops attribute present doesn't have squigglies in the RUF generated markup for its value attribute. so we generate it ourselves from the element's name attribute. these are special cases, thus handled differently from the generic code below.*/
        var elName = $el.attr("name");

        elName = pega.ui.property.toReference(elName);

        return "{{" + elName + "}}"; /*apparently, the name attribute in the handle format does not contain squigglies*/
      }

      /* END SPECIAL CASES */

      /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

      if (item == "value") /*value is treated differently in different browsers and their versions, let jQuery handle the intricacies in "value" case*/
        return $el.val();

      if (el.hasOwnProperty && el.hasAttribute) {

        var isDirectProperty = el.hasOwnProperty(item) || !el.hasAttribute(item); /*e.g., innerHTML is a direct property while name is an attribute*/

        return isDirectProperty ? el[item] : $el.attr(item);
      } else {
        /*handle ie quirks mode*/

        if ($el.attr(item)) return $el.attr(item);else return el[item];
      }
    },

    /*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

    setValueOf: function (el, item, value) {

      var $el = pega.ctx.dom.$(el);

      /*SANITIZE item*/

      item = $.trim(item);

      item = item.replace(/^\s*data\-cdb\-/, ""); /*fix data flash in custom data bound controls by using "data-cdb-value" instead of "value", etc. attributes in some controls like text input box, etc., where this value is directly shown in the UI. other controls like radiobutton, etc. can continue using the "value" attribute, as its not shown in the UI.*/

      if ((!value || value == "") && typeof value != "boolean") {
        /*Fix for BUG-192774 : DesignTime properties panel's default value not being picked up for a control*/
        value = $el.attr("data-bindDefaultValue") || ""; /*a value of type boolean from ClientCache.find(...) is a genuine value to be used, don't override it with default value in this case*/
      }

      /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

      /* BEGIN SPECIAL CASES */

      if (el.type == 'checkbox' && item == "value") {

        var evaluatedValue = false; /*by default, even if the below eval fails, we use a false or unchecked state for checkbox*/

        try {
          evaluatedValue = eval(value); /*should be one of boolean true or false*/
        } catch (ex) {
          var topWindow = pega.desktop.support.getDesktopWindow();
          if (window && window.console && window.console.log && topWindow && topWindow.showcdblogs) /*use this setting when debugging custom databinder in development*/
            window.console.log("custom databinder : _databindHelper.setValueOf(...) had an exception in evaluating an expected boolean value=" + value + ". This has been caught safely & checkbox value will be changed to a default false value / unchecked.");
        }

        if (!evaluatedValue) {
          /*boolean false*/
          $el.prop('checked', false);
          $el.removeAttr('checked');
        } else {
          /*boolean true*/
          $el.prop('checked', true);
          $el.attr('checked', 'checked');
        }

        /*THE BELOW CODE IS NOT NEEDED ANYMORE DUE TO : BUG-214576 : Checkbox value not retaining with templates - Please refer to all bug comments*/
        /*set "value" custom attribute to stringified "true" or "false", as, if "value" attribute exists for a checkbox - that is what gets submitted in a form submit*/
        /* $el.val(value); need this setter statement for the latest IWebView, etc. builds in iOS*/
        /* $el.attr(item,value); need this extra setter statement for the latest WebView, Chrome & Webkit like builds in Android*/

        return;
      }

      /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

      else if (el.type == 'radio' && item == "value") {

          /*reset each radio button to unchecked state, one at a time [one in each call to this setter helper function]*/

          if ($el.val() != value) {
            $el.prop('checked', false);
            $el.removeAttr('checked');
          }

          /*set "checked" actual attribute to boolean true or false only on the correct radio button [based on value attribute] in the radio group*/

          else {
              $el.prop('checked', true);
              $el.attr('checked', 'checked');
            }

          return;
        }

        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

        else if (el.tagName.toUpperCase() == 'SELECT' && item == "value") {

            if (pega && pega.env && pega.env.ua && pega.env.ua.mobile && /apple/i.test(pega.env.ua.mobile)) {
              /*Apple Mobile Safari WebView problem : Fix for BUG-227442:
              Drop down control not populated - Pega Mobile Hybrid Client*/

              $el.find("option:selected").prop("selected", false);

              $el.find("option[value='" + value + "']").prop("selected", true);
            } else {

              $el.find("option:selected").removeAttr('selected').removeAttr("checked").prop("selected", false); /*remove the current selection in the dropdown*/

              $el.find("option[value='" + value + "']").attr("selected", "selected").attr("checked", "checked").prop("selected", true); /*earlier, we relied upon $(select).val(value) - which was working then. now, rendering engine creates documentFragment [in memory], on which, bindData is invoked. for the dropdowns in this in-memory-docucmentFragment, the correct option gets selected fine. at the end of it all, RE does a document.someDiv.innerHTML = documentFragment.innerHTML; --> at this point, for some controls like dropdowns, checkboxes and radiobuttons - the selections & states are not retained in the html. therefore, we need to create explicit state/selection-retaining-html-attributes in the markup itself . so, now, changed it to generate explicit selected & checked attributes for the <option> to be <select>ed. UPDATE: After Chrome got updated to version 49, setting selected/checked attributes is not sufficient, hence needed to use $.prop(...) API in both the lines. Fix for BUG-239678: Dropdown values are reset to default value in template.*/
            }

            return;
          }

          /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

          else if (el.tagName.toUpperCase() == 'TEXTAREA' && item == "innerHTML") {

              /*EXTRA SPECIAL CASE for textarea in setter [cross-browser textarea issues with innerHTML vs value] - there's no corresponding special case in the getter*/

              if ((!value || value == "") && pega && pega.env && pega.env.ua && pega.env.ua.ie > 0) value = $el.attr("ph") || ""; /*FIX FOR BUG-214297: Special handling needed for textarea placeholder support in IE*/

              el.innerHTML = el.value = value;

              return;
            }

      /* END SPECIAL CASES */

      /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

      if (item == "value") {
        /*value is treated differently in different browsers and their versions, let jQuery handle the intricacies in "value" case*/
        $el.val(value);

        $el.attr(item, value); /*need this extra setter statement for the latest WebView, Chrome & Webkit like builds*/

        return;
      }

      if (el.hasOwnProperty && el.hasAttribute) {
        var isDirectProperty = el.hasOwnProperty(item) || !el.hasAttribute(item); /*e.g., innerHTML is a direct property while name is an attribute*/

        if (isDirectProperty) el[item] = value;else $el.attr(item, value);
      } else {
        /*handle ie quirks mode*/

        el[item] = value;

        $el.attr(item, value);
      }
    }

  };
  /* END HELPERS */

  /*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

  /*bindData accepts either 
  	a document,
      a documentFragment,
      a single HTMLElement,
      an array of HTMLElements,
      or a jQuery object
  to be custom data bound*/

  var bindData = function (inputResource) {

    /*COLLECT ALL THE ELEMENTS TO BE DATA BOUND, NORMALIZE THEM SUCH THAT THEY COULD BE LOOPED OVER SEAMLESSLY & SANITIZE THEM*/

    if (!inputResource) {
      /*empty input is a possibility due to aggressive databinder calls in pzpega_ui_events.js*/
      return;
    }

    var $collectionOfCustomDataBoundElements;

    //if(inputResource.tagName || $.isArray(inputResource) || (inputResource instanceof $))
    var bindpropsAttr = pega.ctx.dom.$(inputResource).attr("data-bindprops");
    if (typeof bindpropsAttr != "undefined" && bindpropsAttr != "") {

      $collectionOfCustomDataBoundElements = pega.ctx.dom.$(inputResource);
    } else {
      /*implies a document element or a documentFragment*/

      $collectionOfCustomDataBoundElements = pega.ctx.dom.$(inputResource).contents().find("[data-bindprops]");
    }

    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    $collectionOfCustomDataBoundElements.each(function (i, el) {
      /*LOOP OVER THE ELEMENTS*/
      var topWindow = pega.desktop.support.getDesktopWindow();
      var setOfBindProps = pega.ctx.dom.$(el).attr("data-bindprops");

      if (!setOfBindProps) {
        /*The current element in the iteration el does not have a data-bindprops attribute - possibility due to aggressive databinder calls in pzpega_ui_events.js*/
        return;
      }

      var arrayOfTargetAttributes = setOfBindProps.split(",");

      /*''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''*/

      $.each(arrayOfTargetAttributes, function (index, item) {
        /*LOOP OVER THE ATTRIBUTES OF ONE ELEMENT item refers to one attribute[like name] or property[like innerHTML] containing squigglies={{blahblah}}*/

        var templatedAttributeValue = _databindHelper.getValueOf(el, item);

        var squiggliesRegex = /\{\{([^\{\}]+?)\}\}/; /*REGEX TO MATCH INNER SQUIGGLIES FIRST AND OUTER SQUIGGLIES LATER, NEVERTHELESS MATCHES ALL SQUIGGLIES*/

        var match = squiggliesRegex.exec(templatedAttributeValue);

        /*''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''*/
        var previousMatch = "";
        while (match != null) {
          /*LOOP OVER THE SQUIGGLY MATCHES, REMEMBER THERE COULD BE MULTIPLE SQUIGGLIES IN A SINGLE EXPRESSION*/

          if (match && match[1]) {
            var clientCacheDataObject = pega.ui.ClientCache.find(match[1]);

            if (clientCacheDataObject) {
              replacedValue = clientCacheDataObject.getValue();

              if (replacedValue) replacedValue = replacedValue.toString();
            } else {
              if (window && window.console && window.console.log && topWindow && topWindow.showcdblogs) /*use this setting when debugging custom databinder in development*/
                window.console.log("custom databinder : VALUE_NOT_FOUND_IN_CLIENT_CACHE for property : " + match[1]);

              replacedValue = "";
            }
          }

          /*''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''*/

          else {
              if (window && window.console && window.console.log && topWindow && topWindow.showcdblogs) /*use this setting when debugging custom databinder in development*/
                window.console.log("custom databinder : ATTRIBUTE_HAS_BEEN_LISTED_IN_DATA-BINDPROPS_BUT_DOES_NOT_CONTAIN_VALID_SQUIGGLIES : attribute-name=" + item + ",attribute-value=" + templatedAttributeValue);

              replacedValue = "";
            }

          /*''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''*/
          /*BUG-287871 : $1 is a token in replace regex .Escaping it */
          if (replacedValue) replacedValue = replacedValue.replace("$1", "$$$1");
          templatedAttributeValue = templatedAttributeValue.replace(squiggliesRegex, replacedValue);
          previousMatch = match[1];
          match = squiggliesRegex.exec(templatedAttributeValue);
          if (match && previousMatch == match[1]) match = null;
        }

        _databindHelper.setValueOf(el, item, templatedAttributeValue);
      });

      /*''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''*/

      if (window && window.console && window.console.log && topWindow && topWindow.showcdblogs) /*use this setting when debugging custom databinder in development*/
        pega.ctx.dom.$(el).attr("debug-data-bindprops", pega.ctx.dom.$(el).attr("data-bindprops"));

      pega.ctx.dom.$(el).removeAttr("data-bindprops"); /*BEGIN AND END : Fix for BUG-203720 : offline refresh section seems to refresh whole screen*/
    });
  };

  /*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

  return {
    repeatingIndex: repeatingIndex,
    resolveIndex: resolveIndex,
    resolvePath: resolvePath,
    bindData: bindData
  };
}();
//static-content-hash-trigger-GCC
var conditionEngine = {
    elementsMadeVisible: null,
    /* contains list of sections refresh in ajax call*/
    ct_sectionsList: new Array(),
    AFTER_EXPRESSIONS_HANDLED_ON_PROPERTY_CHANGES: "AfterExpressionsHandledOnPropertyChanges",
    ct_postedProp: undefined,
    /* contains property posted in ajax call*/
    /* BUG-331101 Fix - See fn evaluate */
    elValuesSafe: null,
    /*
    @Handler
    @protected This function handles client events
    This function accepts the eventType,activityName,
    activityParams and the index as the parameters. Based on the sourceElement id value all the div tags
    whose id matches the name of the property are fetched and show_when attribute of the div
    tag's expression is evaluated and the particular div tag will be shown or hidden
    based on the return value. The index parameter will be the index, subscript or -1 elsewhere.
    @param $String$eventType - Type of the event ("onchange", "onblur", or "onclick")
    @param $String$activityName - Name of the activity
    @param $String$activityParams - Parameters of the activity
    @param $String$index - Index value
    @return $void$
     */
    handleClientEvent: function (eventType, activityName, activityParams, index, event, dataTransformLiteral) {
        event = (event == undefined) ? window.event : event;
        this.ClientEventAPI.eventType = eventType;
        this.ClientEventAPI.activityName = activityName;
        this.ClientEventAPI.activityParams = activityParams;
        this.ClientEventAPI.index = index;
        this.ClientEventAPI.ev = event;
        this.ClientEventAPI.src = event.target;
        /* ETCHASKETCH DATA TRANSFORM CHANGES - START */
        /* For now, just use the passed argument. Once Parameters are set, extract from object literal. */
        this.ClientEventAPI.dataTransformName = dataTransformLiteral;
        /* ETCHASKETCH DATA TRANSFORM CHANGES - END */
        /*List based triggering story - Autobots 6.2 Sprint 8 - banea1 - start*/
        this.ClientEventAPI.domEventType = event.type;
        /*Added to hold the event type. This is needed because in case of Post Value, after the AJAX the Event changes to AJAX success and hence the change, click or blurr event is lost*/
        this.ClientEventAPI.srcGrid = null;
        /*reset the grid object*/
        /*Check if the event occured in a grid or a Repeat Layout and set the grid data*/
        if (typeof (Grids) != 'undefined') {
            this.ClientEventAPI.srcGrid = Grids.getActiveGrid(event) || pega.ctx.activeGrid;
        }
        if (!this.ClientEventAPI.srcGrid) {
            this.ClientEventAPI.srcGrid = pega.u.d.getRepeatObject(this.ClientEventAPI.src);
        }
        /*List based triggering story - Autobots 6.2 Sprint 8 - banea1 - end*/
        this.ClientEventAPI.isClientEvent = true; // This flas is set only for client-events. It's reset in ClientEventAPI::applyConditions()
        /* in case of LG header cell item checkbox click we donot want to trigger the resize */
        if (!(event.target.type === "checkbox" && event.type === "change" && $(event.target).closest(".content-layout-group") && $(event.target).closest(".header") && $(event.target).closest(".content-layout-group").length > 0 && $(event.target).closest(".header").length > 0)) {
            this.ClientEventAPI.onload();
        }
        /* end */
    },
    /*
    @protected This function evaluates the expression
    and return the status to show/hide elements to the handleClientEvent() function
    @param $String$exp - Expression
    @param $String$val - Value in the form field
    @param $String$prop - Property name
    @return $boolean$
     */
    evaluate: function (exp, clientTargets, elValues) {
        /** BUG-331101 - Breaks Google compression */
        /** String to evaluate refers to param name changed during compression */
        /** Namespaced variable names remain static, so eval-safe */
        elValuesSafe = elValues;
        for (var i = 0; i < clientTargets.length; i++) {
            switch (elValuesSafe[i]) {
                case '':
                    //do nothing
                    break;
                case true:
                    elValuesSafe[i] = "true";
                    break;
                case false:
                    elValuesSafe[i] = "false";
                    break;
                case "true":
                    elValuesSafe[i] = "true";
                    break;
                case "false":
                    elValuesSafe[i] = "false";
            }
            if (elValuesSafe[i])
                elValuesSafe[i] = elValuesSafe[i].replace(/^\s+|\s+$/, '');
            /*Removed Inconsistent Type Conversion for Numbers - Autobots*/
            //BUG-182457 porting of Hfix-20085
            if (!isNaN(elValuesSafe[i]) && elValuesSafe[i] != "0") {
                if (!isNaN(parseFloat(elValuesSafe[i]))) {
                    elValuesSafe[i] = parseFloat(elValuesSafe[i]);
                }
            }
            var testExpression = new RegExp(clientTargets[i].replace(/[.()]/g, "\\$&") + '(?![a-zA-Z0-9_().])', "g");
            while (exp.search(testExpression) != -1) {
                exp = exp.replace(testExpression, 'elValuesSafe[' + i + ']');
            }
        }
        try {
            var andOrRegEx = /&&|\|\|/g;
            var booleanExpressionsArr = exp.split(andOrRegEx);
            var matchArr = exp.match(andOrRegEx);
            exp = "";
            for (var j = 0; j < booleanExpressionsArr.length; j++) {
                // Split the expression to change single equal sign (=) to double equal sign (==)
                var expArr = booleanExpressionsArr[j].split("=");
                for (var i = 0; i < expArr.length; i++) {
                    // Replace capitalized True/False with true/false
                    if ((pega.lang.trim(expArr[i].toLowerCase()) == "'true'") || (pega.lang.trim(expArr[i].toLowerCase()) == "'false'")) {
                        expArr[i] = expArr[i].toLowerCase();
                    }
                    else if (pega.lang.trim(expArr[i].toLowerCase()) == "true") {
                        expArr[i] = expArr[i].replace("true", "'true'");
                    }
                    else if (pega.lang.trim(expArr[i].toLowerCase()) == "false") {
                        expArr[i] = expArr[i].replace("false", "'false'");
                    }
                }
                for (var i = 0; i < expArr.length - 1; i++) {
                    expArr[i] += "=";
                }
                for (var i = 0; i < expArr.length - 1; i++) {
                    if ((expArr[i] != "=") && (expArr[i].charAt(expArr[i].length - 2) != "!") && (expArr[i].charAt(expArr[i].length - 2) != ">") && (expArr[i].charAt(expArr[i].length - 2) != "<") && (expArr[i + 1] != "=")) {
                        expArr[i] += "=";
                    }
                }
                // Rejoin the expression
                booleanExpressionsArr[j] = expArr.join("");
                if (j < booleanExpressionsArr.length - 1) {
                    exp += booleanExpressionsArr[j] + " " + matchArr[j] + " ";
                }
                else {
                    exp += booleanExpressionsArr[j];
                }
            }
            return eval(exp);
        }
        catch (Exception) {
            return false;
        }
    },
    /*This script executes all visible whens in offline */
    evaluateAllVisibleWhens: function () {
        /*begin helpers*/
        function _isFramelessPortalContext() {
            return pega.u.NavigateTopHandler;
            /*for now, to determine if we are in an iframeless environment or not, we rely on the presence of pega.u.NavigateTopHandler. In future, if this is not the case, then, this detection logic needs to be updated. Removing  && (window.top.frames.length == 0) */
        }
        /*end helpers*/
        if (pega && ((pega.u && pega.u.d && pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal()))) {
            var currentCT = pega.ui.ChangeTrackerMap.getTracker();
            pega.u.d.temp_currentCT = currentCT;
            // commented not required to build change list if we pass ALL to evaluateClientConditions
            //currentCT.merge(currentCT.trackedPropertiesList, currentCT.trackedPropertiesList, null, true, false);
            if (currentCT.trackedPropertiesList) {
                /*if (typeof updateExpressionTargetsFromList === 'function') {
                updateExpressionTargetsFromList(currentCT.trackedPropertiesList);
              }
              currentCT.changedPropertiesList.push("Declare_pyDisplay.pyDCDisplayState.pyActiveDocumentType");*/
                pega.u.d.evaluateClientConditions('ALL', null, true, false);
            }
            pega.u.d.ct_sectionsList = new Array();
            if (pega.u.d.temp_currentCT)
                pega.u.d.temp_currentCT = undefined;
        }
        if (typeof LayoutGroupModule != "undefined")
            LayoutGroupModule.updateStretchTabWidths();
    },
    invokeDataBinder: function () {
        try {
            pega.ui.template.DataBinder.bindData(document);
        }
        catch (exc) {
            var topWindow = pega.desktop.support.getDesktopWindow();
            if (window && window.console && window.console.log && topWindow && topWindow.showcdblogs)
                window.console.log("custom databinder :: invokeDataBinder in pzpega_ui_doc_EventsConditionsChaining.js exited with an exception(" + exc.message + ") - safely caught");
        }
    },
    evaluateClientConditionsOnChangeList: function (fireVisibleWhen, fireRefreshWhen) {
        var trackersMap = pega.ui.ChangeTrackerMap.getTrackers();
        for (var tmp_threadName in trackersMap) {
            var currentCT = trackersMap[tmp_threadName];
            pega.u.d.temp_currentCT = currentCT;
            if (typeof fireVisibleWhen == 'undefined') {
                fireVisibleWhen = true;
            }
            if (typeof fireRefreshWhen == 'undefined') {
                fireRefreshWhen = true;
            }
            var currentCtx = pega.ctx;
            pega.ctxmgr.setContext(pega.ctxmgr.getContextByThreadName(pega.u.d.temp_currentCT.threadName));
            if (pega.ctx && pega.ctx.bIsCTXUnloading == true) {
                pega.ctxmgr.setContext(currentCtx);
                continue;
            }
            if (currentCT.changedPropertiesList.length > 0) {
                if (typeof updateExpressionTargetsFromList === 'function')
                    updateExpressionTargetsFromList(currentCT.changedPropertiesList);
                pega.u.d.evaluateClientConditions('TCL', null, fireVisibleWhen, fireRefreshWhen);
            }
            else if (currentCT.addRemovePagesList.length > 0) {
                pega.u.d.evaluateClientConditions('TCL', null, false, true);
            }
            pega.ctxmgr.setContext(currentCtx);
        }
        if (pega.u.d.temp_currentCT)
            pega.u.d.temp_currentCT = undefined;
        pega.u.d.ct_sectionsList = new Array();
        //Publishing event after all expressions handled on property changes
        pega.ui.EventsEmitter.publishSync(pega.u.d.AFTER_EXPRESSIONS_HANDLED_ON_PROPERTY_CHANGES);
    },
    evaluateClientConditions: function (type, elementName, fireVisibleWhen, fireRefreshWhen, propertyElem) {
        var ccObj = {};
        var rmThreadCTs = false;
        var harCtxMgr = pega.ui.HarnessContextMgr;
        if (!pega.u.d.temp_currentCT || pega.u.d.temp_currentCT.threadName != pega.u.d.getThreadName())
            pega.u.d.temp_currentCT = pega.ui.ChangeTrackerMap.getTracker();
        pega.u.d.temp_currentCT.tempPropMap = {};
        pega.u.d.temp_currentCT.tempPropValuesMap = {};
        if (harCtxMgr.get('isUITemplatized')) {
            pega.ctx.ignoreCachingSectionList = true;
            pega.ui.ClientCache.pauseChangedPagesList();
            if (fireRefreshWhen == false) {
                pega.ui.ExpressionEvaluator.evaluateSpecificExpressionType(pega.ui.ExpressionEvaluator.NON_REFRESH_WHENS);
            }
            if (propertyElem) {
                pega.ui.ExpressionEvaluator.handlePropertyChange(propertyElem);
            }
            else if (type == "ELEM" && elementName) {
                pega.ui.ExpressionEvaluator.handlePropertyChange(elementName);
            }
            pega.ui.ClientCache.resumeChangedPagesList();
            pega.ui.ExpressionEvaluator.handleChangedProperties(pega.u.d.temp_currentCT);
            pega.ctx.ignoreCachingSectionList = false;
            if (!pega.ui.ExpressionEvaluator.getNTExpressionStatus()) {
                pega.u.d.temp_currentCT.clearChanges();
                pega.u.d.ct_sectionsList = new Array();
                //Publishing event after all expressions handled on property changes
                pega.ui.EventsEmitter.publishSync(pega.u.d.AFTER_EXPRESSIONS_HANDLED_ON_PROPERTY_CHANGES);
                return;
            }
        }
        if (typeof type == 'undefined') {
            ccObj.type = 'ALL';
        }
        else {
            ccObj.type = type;
        }
        if (typeof fireVisibleWhen == 'undefined') {
            fireVisibleWhen = true;
        }
        if (typeof fireRefreshWhen == 'undefined') {
            fireRefreshWhen = true;
        }
        ccObj.elementName = elementName;
        if (pega.ui.ChangeTrackerMap.isSingleTracker())
            ccObj.CTDivs = pega.ctx.dom.$("DIV#CT");
        else {
            if (pega.u.d.temp_currentCT.isPrimary) {
                ccObj.CTDivs = pega.ctx.dom.$("DIV#CT");
                rmThreadCTs = true;
            }
            else {
                if (pega.u.d.bModalDialogOpen && pega.u.d.modalDialog.body) {
                    ccObj.CTDivs = pega.ctx.dom.$(pega.u.d.modalDialog.body).find("DIV#CT");
                }
                else if (pega.ctx.isMDC || pega.ctx.bIsDCSPA) {
                    ccObj.CTDivs = pega.ctx.dom.$("DIV#CT");
                }
                else {
                    var PHDiv = pega.ctx.dom.getElementById("PEGA_HARNESS");
                    if (pega.u.d.ServerProxy.isDestinationRemote() && PHDiv && pega.u.d.temp_currentCT.threadName === PHDiv.getAttribute("thread_name")) {
                        ccObj.CTDivs = $(PHDiv).find("DIV#CT");
                    }
                    else {
                        var FADivs = pega.ctx.dom.$("DIV#pyFlowActionHTML");
                        for (var i = 0; i < FADivs.length; i++) {
                            if (pega.u.d.temp_currentCT.threadName === FADivs[i].getAttribute("THREAD_NAME")) {
                                ccObj.CTDivs = $(FADivs[i]).find("DIV#CT");
                                break;
                            }
                        }
                    }
                }
            }
        }
        ccObj.SWArray = [];
        ccObj.RWArray = [];
        ccObj.RCArray = [];
        pega.u.d.evaluateRequiredWhens();
        pega.u.d.evaluateActiveWhens();
        if (ccObj.CTDivs) {
            var divTagsLength = ccObj.CTDivs.length;
            var tempObj;
            for (var count = 0; count < divTagsLength; count++) {
                tempObj = ccObj.CTDivs[count];
                if (rmThreadCTs && tempObj.getAttribute("thread_name")) {
                    ccObj.CTDivs.splice(count, 1);
                    count--;
                    divTagsLength--;
                    continue;
                }
                if (fireVisibleWhen && tempObj.getAttribute("SWP") || tempObj.getAttribute("SHOW_WHEN")
                    || tempObj.getAttribute("DISABLE_WHEN") || tempObj.getAttribute("DISABLE_WHEN_RULE"))
                    ccObj.SWArray.push(tempObj);
                if (fireRefreshWhen && tempObj.getAttribute("RWP"))
                    ccObj.RWArray.push(tempObj);
                if (tempObj.getAttribute("RCW")) {
                    ccObj.RCArray.push(tempObj);
                }
            }
            if (fireVisibleWhen) {
                pega.u.d.evaluateVisibleWhens(ccObj);
            }
            if (fireRefreshWhen) {
                pega.u.d.evaluateRefreshWhens(ccObj);
            }
            if (ccObj.RCArray.length > 0) {
                pega.u.d.evaluateReloadCellWhen(ccObj);
            }
            /*HFix-30307 : call to set modal diamention will update the diamension if modal dialog is opened
            *Modal dialog for mobile not showing template button as template buttons have client side visible whens
            */
            if (pega.u.d && pega.u.d.setModalDimensions) {
                pega.u.d.setModalDimensions();
            }
        }
        pega.u.d.evaluateReloadLayoutWhen(ccObj);
        /* clearing changed properties list */
        pega.u.d.temp_currentCT.clearChanges();
        pega.u.d.temp_currentCT.tempPropMap = undefined;
        pega.u.d.temp_currentCT.tempPropValuesMap = undefined;
        pega.u.d.temp_currentCT = undefined;
        pega.u.d.ct_postedProp = undefined;
        pega.u.d.ClientEventAPI.ev = null;
        pega.u.d.ClientEventAPI.src = null;
        pega.u.d.ClientEventAPI.srcGrid = null;
        pega.u.d.ct_sectionsList = new Array();
        //Publishing event after all expressions handled on property changes
        pega.ui.EventsEmitter.publishSync(pega.u.d.AFTER_EXPRESSIONS_HANDLED_ON_PROPERTY_CHANGES);
    },
    evaluateRefreshWhens: function (ccObj) {
        var refreshTargets = pega.u.d.getAllRefreshableTargets(ccObj.type, ccObj.elementName);
        var sections = null;
        var preActivities = null;
        var dataTransforms = null;
        var declarePageParams = null;
        var grids = null;
        var gridsWithRowsToRefresh = null;
        ccObj.rw_preActivities = new Array();
        ccObj.dataTransforms = new Array();
        ccObj.at_sectionsTable = new Array();
        if (refreshTargets) {
            sections = refreshTargets.sections;
            preActivities = refreshTargets.preActivities;
            dataTransforms = refreshTargets.dataTransforms;
            declarePageParams = refreshTargets.declarePageParams;
            grids = refreshTargets.gridsToRefresh;
            gridsWithRowsToRefresh = refreshTargets.gridsWithRowsToRefresh;
        }
        if (sections) {
            for (var i = 0; i < sections.length; i++) {
                var isSectionPresent = false;
                for (var j = 0; j < ccObj.at_sectionsTable.length; j++) {
                    if (ccObj.at_sectionsTable[j] == sections[i]) {
                        isSectionPresent = true;
                        break;
                    }
                }
                if (!isSectionPresent) {
                    ccObj.at_sectionsTable.push(sections[i]);
                }
            }
        }
        if (preActivities) {
            for (var i = 0; i < preActivities.length; i++) {
                var isActivityPresent = false;
                for (var j = 0; j < ccObj.rw_preActivities.length; j++) {
                    if (ccObj.rw_preActivities[j] == preActivities[i]) {
                        isActivityPresent = true;
                        break;
                    }
                }
                if (!isActivityPresent) {
                    ccObj.rw_preActivities.push(preActivities[i]);
                }
            }
        }
        if (dataTransforms) {
            for (var i = 0; i < dataTransforms.length; i++) {
                var isDataTransformPresent = false;
                for (var j = 0; j < ccObj.dataTransforms.length; j++) {
                    if (ccObj.dataTransforms[j] == dataTransforms[i]) {
                        isDataTransformPresent = true;
                        break;
                    }
                }
                if (!isDataTransformPresent) {
                    ccObj.dataTransforms.push(dataTransforms[i]);
                }
            }
        }
        if (grids) {
            for (var i = 0; i < grids.length; i++) {
                grids[i].doGridAction({
                    target: grids[i].gridDiv
                }, "REFRESHLIST");
            }
        }
        if (gridsWithRowsToRefresh) {
            var gridQueue = null;
            for (var i = 0; i < gridsWithRowsToRefresh.length; i++) {
                if (i == 0)
                    gridQueue = new pega.tools.Queue();
                if (gridsWithRowsToRefresh[i].rowsToRefresh) {
                    gridQueue.enqueue({
                        GridToRefresh: gridsWithRowsToRefresh[i]
                    });
                }
            }
            if (gridQueue) {
                pega.u.d.gridLoadManager = new pega.ui.GridRowsLoadManager({
                    "loadQueue": gridQueue
                });
                pega.u.d.gridLoadManager.startLoading();
            }
        }
        if (ccObj.at_sectionsTable.length > 0) {
            var surl = '';
            if (ccObj.type == 'ELEM') {
                var propRef = pega.u.property.toHandle(ccObj.elementName);
                var propDomArr = pega.u.d.getCorrectPropertyElemFromDOM(propRef, pega.ui.ChangeTrackerMap.getTracker());
                if (propDomArr && propDomArr.length > 0 && propDomArr[0].id != 'CV') {
                    var srcValue = pega.u.d.getGroupElementValue(propDomArr);
                    surl = new SafeURL();
                    surl.put(propRef, srcValue);
                }
            }
            // ETCHASKETCH
            pega.u.d.reloadSections(surl, ccObj.at_sectionsTable, "", "", this.ClientEventAPI.index, this.ClientEventAPI.ev, ccObj.rw_preActivities, ccObj.dataTransforms, declarePageParams);
            ccObj.at_sectionsTable = null;
        }
        /*else{
        pega.u.d.resizeHarness(); // BUG-103226: Commented as Resize harness is already called by ajax engine if evaluatewhens results in a section refresh
        }*/
    },
    getSectionBaseReference: function (currDiv, rcw) {
        var sectionData = "";
        if (currDiv.getAttribute("data-simplelayout") || rcw == true) {
            sectionData = pega.u.d.calcAndAttachSectionBaseRef(currDiv, true);
        }
        else {
            sectionData = pega.u.d.calcAndAttachSectionBaseRef(currDiv);
        }
        var sectionBaseRef = sectionData.sectionBaseRef;
        if (sectionBaseRef == 'nosection') {
            var gridObj = null;
            if (typeof (Grids) != 'undefined') {
                gridObj = Grids.getElementsGrid(currDiv);
            }
            sectionBaseRef = pega.u.d.getBaseRef(currDiv, null, gridObj);
            if (sectionBaseRef == '') {
                sectionBaseRef = pega.u.d.getElementRowPageRef(currDiv);
            }
            sectionData.baseRef4ConditionEval = sectionBaseRef;
        }
        sectionData.sectionBaseRef = sectionBaseRef;
        return sectionData;
    },
    evaluateVisibleWhens: function (ccObj) {
        if (!pega.ctx.conditionsMap) {
            pega.ctx.conditionsMap = {};
        }
        for (var i = 0; i < ccObj.SWArray.length; i++) {
            var currDiv = ccObj.SWArray[i];
            /*Get Configured Expression*/
            var configuredCondition = currDiv.getAttribute('SHOW_WHEN');
            var isVisibleWhen = true;
            if (!configuredCondition) {
                configuredCondition = currDiv.getAttribute('DISABLE_WHEN');
                if (!configuredCondition) {
                    // disable when rules for offline
                    var disableWhenRule = currDiv.getAttribute('DISABLE_WHEN_RULE');
                    if (disableWhenRule && pega.ui.When) {
                        var disableWhenRuleResult = pega.ui.When.evaluate(disableWhenRule, pega.ui.ClientCache.find("pyWorkPage").get("pxObjClass").getValue());
                        pega.u.d.showHideCTDiv(currDiv, disableWhenRuleResult, false);
                    }
                    continue;
                }
                else {
                    isVisibleWhen = false;
                }
            }
            /*Get Section's Base Reference and included section*/
            var sectionBaseRef = null;
            if (isVisibleWhen) {
                var sectionData = "";
                sectionData = pega.u.d.getSectionBaseReference(currDiv, null);
                sectionBaseRef = sectionData.sectionBaseRef;
            }
            else {
                sectionBaseRef = pega.u.d.getBaseRef(currDiv);
                if (sectionBaseRef == '') {
                    sectionBaseRef = pega.u.d.getElementRowPageRef(currDiv);
                }
                var sectionData = {};
                sectionData.baseRef4ConditionEval = sectionBaseRef;
            }
            /*The DIV has ct div configuration is messed up*/
            if (sectionBaseRef == null || sectionBaseRef == 'nosection')
                continue;
            var complexCond = false;
            if (configuredCondition.indexOf("&&") != -1 && configuredCondition.indexOf("||") != -1) {
                complexCond = true;
            }
            var tempKey = configuredCondition + "~#~" + sectionData.baseRef4ConditionEval;
            var mapEntry = pega.ctx.conditionsMap[tempKey];
            if (mapEntry && !complexCond) {
                var propertiesInvolved = mapEntry.propsArr;
                var Changed = false;
                var clientTargetsTemp = [];
                var elValuesTemp = [];
                for (var m = 0; m < propertiesInvolved.length; m++) {
                    var currentProperty = propertiesInvolved[m].propName;
                    clientTargetsTemp[m] = currentProperty;
                    var propValue = "";
                    var operandValue = pega.u.d.getCorrectPropertyElemFromDOM(pega.u.property.toHandle(currentProperty), pega.u.d.temp_currentCT);
                    if (operandValue && operandValue.length > 0 && operandValue[0].id != 'CV') {
                        propValue = pega.u.d.getGroupElementValue(operandValue);
                    }
                    else {
                        propValue = pega.u.d.temp_currentCT.getPropertyValue(currentProperty);
                    }
                    elValuesTemp[m] = propValue;
                    pega.u.d.temp_currentCT.tempPropValuesMap[currentProperty] = propValue;
                    if (propValue != propertiesInvolved[m].propValue) {
                        Changed = true;
                        mapEntry.propsArr[m].propValue = elValuesTemp[m];
                    }
                }
                if (!Changed) {
                    var resultCalc = mapEntry.result;
                }
                else {
                    var resultCalc = pega.u.d.evaluate(mapEntry.fullExpression, clientTargetsTemp, elValuesTemp);
                    mapEntry.result = eval(resultCalc);
                    resultCalc = mapEntry.result;
                }
                pega.u.d.showHideCTDiv(currDiv, resultCalc, isVisibleWhen);
                continue;
            }
            var conditionTokensNOperator = pega.u.d.getConditionTokensAndOperator(configuredCondition);
            var conditionTokens = conditionTokensNOperator.conditionTokens;
            var combOperator = conditionTokensNOperator.combOperator;
            /* BUG-73035: performace issue - Start */
            if (ccObj.type == "OGRD" || ccObj.type == "OGRI") {
                var skipEvaluation = false;
                for (var j = 0; j < conditionTokens.length; j++) {
                    var currentToken = pega.lang.trim(conditionTokens[j]);
                    /* skip evaluation, when properties are not index based expression,
                    if this api called from grid insert or delete call back handles */
                    if (!(currentToken.match(/\([0-9]*\)/ig))) {
                        skipEvaluation = true;
                    }
                    else {
                        skipEvaluation = false;
                        break;
                    }
                }
                if (skipEvaluation) {
                    continue;
                }
            }
            /* BUG-73035: performace issue - End */
            /* BUG-68350: Visible when not evaluating double quotation marks correctly */
            if (currentToken != null)
                currentToken = currentToken.replace(/''/g, "'");
            /* BUG-68350 END*/
            var resultsArr = [];
            for (var j = 0; j < conditionTokens.length; j++) {
                var currentToken = pega.lang.trim(conditionTokens[j]);
                resultsArr[j] = pega.u.d.isRegularTarget(currentToken, sectionData.baseRef4ConditionEval, currDiv, true);
            }
            var rwcpValue = currDiv.getAttribute("FULLPROPS");
            var executeExpression = false;
            if (rwcpValue) {
                var rwcpArray = rwcpValue.split(",");
                for (var l = 0; l < rwcpArray.length; l++) {
                    if (ccObj.type == 'ALL') {
                        executeExpression = true;
                        break;
                    }
                    else if (ccObj.type == 'ELEM' && pega.u.d.isExpressionMatching(null, ccObj.elementName, rwcpArray[l], rwcpArray[l])) {
                        executeExpression = true;
                        break;
                    }
                    else if ((ccObj.type == 'TCL' || ccObj.type == 'ELEM') && pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(rwcpArray[l])) {
                        executeExpression = true;
                        break;
                    }
                    else if ((ccObj.type == 'OGRD' || ccObj.type == 'OGRI') && pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(rwcpArray[l], false, true)) {
                        executeExpression = true;
                        break;
                    }
                }
            }
            if (executeExpression) {
                var expression = "";
                var fullExpression = "";
                var resultObj = {};
                resultObj.propsArr = [];
                var x = 0;
                for (var k = 0; k < resultsArr.length; k++) {
                    var clientTargets = resultsArr[k].clientTargets;
                    var elValues = resultsArr[k].elValues;
                    for (var l = 0; l < clientTargets.length; l++) {
                        resultObj.propsArr[x] = {};
                        resultObj.propsArr[x].propName = clientTargets[l];
                        resultObj.propsArr[x].propValue = elValues[l];
                        x++;
                    }
                    var tempRes = pega.u.d.evaluate(resultsArr[k].expression, clientTargets, elValues);
                    if (k == 0) {
                        expression = tempRes;
                        fullExpression = resultsArr[k].expression;
                    }
                    else {
                        expression = expression + combOperator + tempRes;
                        fullExpression = fullExpression + combOperator + resultsArr[k].expression;
                    }
                }
                var result = eval(expression);
                resultObj["result"] = result;
                resultObj["fullExpression"] = fullExpression;
                var key = configuredCondition + "~#~" + sectionData.baseRef4ConditionEval;
                pega.ctx.conditionsMap[key] = resultObj;
                pega.u.d.showHideCTDiv(currDiv, result, isVisibleWhen);
            }
        }
    },
    showHideCTDiv: function (currDiv, result, isVisibleWhen) {
        var reserveSpace = currDiv.getAttribute('RESERVE_SPACE');
        var stringType = currDiv.getAttribute('STRING_TYPE');
        if (result) {
            if (isVisibleWhen) {
                if (reserveSpace == 'true') {
                    currDiv.style.visibility = "visible";
                    currDiv.setAttribute("aria-hidden", "false");
                }
                else {
                    conditionEngine.columnLayout_show(currDiv);
                    currDiv.style.display = "";
                    var isWrapperDiv = "false";
                    var child = $(currDiv).children().first()[0];
                    if (child) {
                        var wrapperClass = child.className.replace("layout-content", "");
                        if (wrapperClass != child.className)
                            isWrapperDiv = "true";
                    }
                    if (currDiv.className == "" && child && child.className == "content-inner" && isWrapperDiv == "false") {
                        var prevClass = 1;
                        //get content item number from previous sibling
                        if ($(currDiv).prev()) {
                            prevClass = $(currDiv).prev().className.match(/\d+/);
                            prevClass++;
                            currDiv.className = "content-item content-" + stringType + " item-" + prevClass;
                        }
                        else
                            currDiv.className = "content-item content-" + stringType + " item-" + prevClass;
                        // update content-item numbers for any content-items after the current one
                        var tempDiv = currDiv;
                        while ($(tempDiv).next()) {
                            if ($(tempDiv).next().className != "") {
                                prevClass++;
                                $(tempDiv).next().className = $(tempDiv).next().className.replace(/\d+/, "");
                                $(tempDiv).next().className = $(tempDiv).next().className.replace("item-", "item-" + prevClass.toString());
                            }
                            tempDiv = $(tempDiv).next();
                        }
                    }
                    else {
                        /* Handle layout group - if all layout are hidden - we need to activate this layout */
                        if (currDiv.parentNode && currDiv.parentNode.className.indexOf("content-layout-group") != -1 &&
                            currDiv.className.indexOf("layout") == 0) {
                            var bNoVisibleLayout = true;
                            var layoutGroupNode = currDiv.parentNode;
                            var layoutchild = $(layoutGroupNode).children().first()[0];
                            while ($(layoutchild).next()) {
                                layoutchild = $(layoutchild).next()[0];
                                if (!layoutchild) {
                                    break;
                                }
                                // look if layout is visible : BUG-269737
                                if (layoutchild && layoutchild.style.display != "none" &&
                                    layoutchild.className.indexOf("layout") == 0 && layoutchild.className.indexOf("layout-group-nav") != 0 && layoutchild.childNodes[0] && layoutchild.childNodes[0].getAttribute("aria-selected") == "true") {
                                    bNoVisibleLayout = false;
                                    break;
                                }
                            }
                            if (bNoVisibleLayout)
                                LayoutGroupModule.setLayoutActive(currDiv);
                        }
                    }
                }
            }
            else
                pega.u.d.controlDisabler(currDiv);
        }
        else {
            if (isVisibleWhen) {
                if (reserveSpace == 'true') {
                    currDiv.style.visibility = "hidden";
                    currDiv.setAttribute("aria-hidden", "true");
                }
                else {
                    conditionEngine.columnLayout_hide(currDiv);
                    currDiv.style.display = "none";
                    var isWrapperDiv = "false";
                    var child = $(currDiv).children().first()[0];
                    if (child) {
                        var wrapperClass = child.className.replace("layout-content", "");
                        if (wrapperClass != child.className)
                            isWrapperDiv = "true";
                    }
                    conditionEngine.columnLayout_hide(currDiv);
                    if (child && child.className == "content-inner" && isWrapperDiv == "false") {
                        var classNum = "1";
                        if (currDiv.className != "") {
                            classNum = currDiv.className.match(/\d+/);
                        }
                        else {
                            // get previous content item number
                            var tempDiv = $(currDiv).prev();
                            while (tempDiv && tempDiv.className == "")
                                tempDiv = $(tempDiv).prev();
                            if (tempDiv && tempDiv.className != "") {
                                classNum = tempDiv.className.match(/\d+/);
                                classNum++;
                            }
                        }
                        currDiv.className = "";
                        // renumber content items
                        while ($(currDiv).next()) {
                            currDiv = $(currDiv).next();
                            var nextClass = currDiv.className;
                            if (nextClass != "") {
                                currDiv.className = currDiv.className.replace(/\d+/, "");
                                currDiv.className = currDiv.className.replace("item-", "item-" + classNum.toString());
                                classNum++;
                            }
                        }
                    }
                    else {
                        /* Handle layout group - if this is the active layout we need to switch to another layout */
                        if (currDiv.parentNode && currDiv.parentNode.className.indexOf("content-layout-group") != -1 &&
                            currDiv.className.indexOf("layout") == 0 && currDiv.className.indexOf(" active") != -1) {
                            LayoutGroupModule.setLayoutInactive(currDiv);
                            var layoutGroupNode = currDiv.parentNode;
                            var layoutchild = $(layoutGroupNode).children().first()[0];
                            while ($(layoutchild).next()) {
                                layoutchild = $(layoutchild).next()[0];
                                if (!layoutchild) {
                                    break;
                                }
                                // look for the first visible layout : BUG-269737
                                if (layoutchild && layoutchild.style.display != "none" &&
                                    layoutchild.className.indexOf("layout") == 0 && layoutchild.className.indexOf("layout-group-nav") != 0 && layoutchild.childNodes[0] && layoutchild.childNodes[0].getAttribute("aria-selected") == "true") {
                                    LayoutGroupModule.setLayoutActive(layoutchild);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            else {
                pega.u.d.controlEnabler(currDiv);
            }
        }
    },
    evaluateRefreshWhensOSCO: function (refreshAll, refreshAddDelete) {
        var harCtxMgr = pega.ui.HarnessContextMgr;
        //BUG-343872 : Defer the expression evaluation when the DC home is being refreshed.
        if (pega.ui.DCUtil && pega.ui.DCUtil.isLoadingInProgress == true) {
            window.setTimeout(function () {
                pega.u.d.evaluateRefreshWhensOSCO(refreshAll, refreshAddDelete);
            }, 0);
            return;
        }
        if (harCtxMgr.get('isUITemplatized')) {
            pega.ui.ExpressionEvaluator.handleChangedProperties(null);
            if (!pega.ui.ExpressionEvaluator.getNTExpressionStatus() && pega.u.d.temp_currentCT) {
                pega.u.d.temp_currentCT.clearChanges && pega.u.d.temp_currentCT.clearChanges();
                //Publishing event after all expressions handled on property changes
                pega.ui.EventsEmitter.publishSync(pega.u.d.AFTER_EXPRESSIONS_HANDLED_ON_PROPERTY_CHANGES);
                return;
            }
        }
        var CTDivs = pega.ctx.dom.$("DIV#CT");
        var sections2refresh = null;
        var preActivities = null;
        var dataTransform = null;
        var dataTransforms = null;
        var secDeclarePageParams = null;
        var changesRegEx = /\s+changes/i;
        var addDelRegEx = /\s+adddelete/i;
        if (typeof (refreshAll) != "boolean" || refreshAll) {
            refreshAll = true;
            refreshAddDelete = false;
        }
        if (typeof (refreshAddDelete) != "boolean") {
            refreshAddDelete = false;
        }
        if (CTDivs) {
            for (var i = 0; i < CTDivs.length; i++) {
                var currDiv = CTDivs[i];
                if (!(currDiv.getAttribute("RWP"))) {
                    continue;
                }
                var isGrid = false;
                if (currDiv.rowRef && currDiv.rowRef != "") {
                    continue;
                }
                var sectionData = "";
                if (currDiv.getAttribute("data-simplelayout")) {
                    sectionData = pega.u.d.calcAndAttachSectionBaseRef(currDiv, true);
                }
                else {
                    sectionData = pega.u.d.calcAndAttachSectionBaseRef(currDiv);
                }
                var sectionBaseRef = sectionData.sectionBaseRef;
                /*The DIV has ct div configuration is messed up*/
                if (sectionBaseRef == null || sectionBaseRef == 'nosection') {
                    continue;
                }
                /*Get Configured Expression*/
                var configuredCondition = currDiv.getAttribute('RW');
                if (!configuredCondition) {
                    continue;
                }
                var conditionTokensNOperator = pega.u.d.getConditionTokensAndOperator(configuredCondition);
                var conditionTokens = conditionTokensNOperator.conditionTokens;
                var combOperator = conditionTokensNOperator.combOperator;
                var resultsArr = [];
                var dataPropValues = currDiv.getAttribute("data-property-value");
                var propValJson = {};
                var jsonUpdated = false;
                for (var j = 0; j < conditionTokens.length; j++) {
                    var currentToken = pega.lang.trim(conditionTokens[j]);
                    if (!refreshAddDelete && changesRegEx.test(currentToken)) {
                        var configuredCondition = currentToken.replace(/\s+changes/i, ""); //removing the changes keyword
                        var baseRef4ConditionEval = sectionData.baseRef4ConditionEval;
                        if (!baseRef4ConditionEval) {
                            baseRef4ConditionEval = SafeURL_createFromURL(pega.ctx.url).get('pzPrimaryPageName');
                        }
                        else if (baseRef4ConditionEval.charAt(0) == ".") {
                            baseRef4ConditionEval = SafeURL_createFromURL(pega.ctx.url).get('pzPrimaryPageName') + baseRef4ConditionEval;
                        }
                        var completeConfiguredCondition = this.buildFullReference(configuredCondition, baseRef4ConditionEval);
                        this.setFULLPROPS(currDiv, completeConfiguredCondition);
                        var clientCacheProp = pega.ui.ClientCache.find(completeConfiguredCondition);
                        if (clientCacheProp) {
                            var propCurrentValue = clientCacheProp.getValue();
                            if (dataPropValues) {
                                try {
                                    propValJson = JSON.parse(dataPropValues);
                                    if (propValJson && propValJson[configuredCondition] != propCurrentValue) {
                                        resultsArr[j] = true;
                                        propValJson[propName] = propCurrentValue;
                                        jsonUpdated = true;
                                    }
                                }
                                catch (e) { }
                            }
                            else {
                                propValJson[configuredCondition] = propCurrentValue;
                                jsonUpdated = true;
                                resultsArr[j] = true;
                            }
                        }
                    }
                    else if ((refreshAll || refreshAddDelete) && addDelRegEx.test(currentToken)) {
                        /* not supported case for OSCO */
                        resultsArr[j] = false;
                    }
                    else if (!refreshAddDelete) {
                        resultsArr[j] = pega.u.d.isRegularTarget(currentToken, sectionData.baseRef4ConditionEval, currDiv);
                    }
                }
                if (jsonUpdated) {
                    currDiv.setAttribute("data-property-value", JSON.stringify(propValJson));
                }
                var expression = "";
                for (var k = 0; k < resultsArr.length; k++) {
                    if (k == 0)
                        expression = resultsArr[k];
                    else
                        expression = expression + combOperator + resultsArr[k];
                }
                if (eval(expression) && !pega.u.d.isDuplicateRefresh(sectionData.includedSec.getAttribute('node_name'), sectionBaseRef, currDiv)) {
                    if (!sections2refresh)
                        sections2refresh = [];
                    var preActivity = currDiv.getAttribute("RWA");
                    if (preActivity) {
                        if (!preActivities)
                            preActivities = [];
                        preActivities.push(preActivity + "<||>" + sectionBaseRef);
                    }
                    var dataTransform = currDiv.getAttribute("PDT");
                    if (dataTransform) {
                        if (!dataTransforms)
                            dataTransforms = [];
                        dataTransforms.push(dataTransform + "<||>" + sectionBaseRef);
                    }
                    var declarePageParams = sectionData.includedSec.getAttribute("data-declare-params");
                    if (declarePageParams && declarePageParams != "") {
                        if (secDeclarePageParams == null) {
                            secDeclarePageParams = {};
                        }
                        try {
                            declarePageParams = pega.c.eventParser.replaceTokensWrapper(declarePageParams, "", "", false, false);
                            var paramsList = eval("(" + declarePageParams + ")");
                            if (paramsList) {
                                //var sectionName = sectionData.includedSec.getAttribute('node_name');
                                var uniqueId = sectionData.includedSec.getAttribute('uniqueid'); /*changed sectionname to unique id as same section can be used elsewhere, but uniqueid is unique*/
                                secDeclarePageParams[uniqueId] = {};
                                var key = "";
                                for (key in paramsList) {
                                    secDeclarePageParams[uniqueId][key] = paramsList[key];
                                }
                            }
                        }
                        catch (e) { }
                    }
                    sections2refresh.push(sectionData.includedSec);
                }
            }
            if (sections2refresh && sections2refresh.length > 0) {
                pega.u.d.reloadSections("", sections2refresh, "", "", null, null, preActivities, dataTransform, secDeclarePageParams);
            }
        }
        //Publishing event after all expressions handled on property changes
        pega.ui.EventsEmitter.publishSync(pega.u.d.AFTER_EXPRESSIONS_HANDLED_ON_PROPERTY_CHANGES);
    },
    columnLayout_show: function (currDiv) {
        var parentNode = currDiv.parentNode;
        var $parentNode = $(parentNode);
        $parentNode.removeClass("col-layout-hidden-s1");
        $parentNode.removeClass("col-layout-hidden-s2");
        $parentNode.removeClass("col-layout-hidden-both");
    },
    columnLayout_hide: function (currDiv) {
        var parentNode = currDiv.parentNode;
        var $parentNode = $(parentNode);
        //if I am a sidebar of a col layout and set class on my parent
        if (parentNode && $parentNode.attr('data-hidecolumns')) {
            //we are handling a three col layout
            if (parentNode.className.indexOf("three-col-sidebar-main-sidebar") != -1) {
                if (currDiv.className.indexOf("column-2") != -1 && ($parentNode.attr('data-hidecolumns') == "left" || $parentNode.attr('data-hidecolumns') == "both")) {
                    $parentNode.addClass("col-layout-hidden-s1");
                }
                else if (currDiv.className.indexOf("column-3") != -1 && ($parentNode.attr('data-hidecolumns') == "right" || $parentNode.attr('data-hidecolumns') == "both")) {
                    $parentNode.addClass("col-layout-hidden-s2");
                }
            }
            else {
                //2 col layout -- just hide both
                $parentNode.addClass("col-layout-hidden-both");
            }
        }
    },
    evaluateReloadCellWhen: function (ccObj) {
        var refreshTargets = pega.u.d.getAllRefreshableTargets(ccObj.type, ccObj.elementName, true);
        pega.u.d.reloadCells(refreshTargets);
    },
    evaluateReloadLayoutWhen: function (ccObj) {
        this.at_sectionsTable = new Array();
        this.rw_preActivities = [];
        this.dataTransforms = [];
        this.at_layouts2refresh = null;
        if (pega.u.property.toReference) {
            var refreshTargets = pega.u.d.getAllRefreshableTargets(ccObj.type, ccObj.elementName, false, true);
            var sections = null;
            var preActivities = null;
            var dataTransforms = null;
            var declarePageParams = null;
            var layouts2refresh = null;
            if (refreshTargets) {
                sections = refreshTargets.sections;
                preActivities = refreshTargets.preActivities;
                dataTransforms = refreshTargets.dataTransforms;
                declarePageParams = refreshTargets.declarePageParams;
                layouts2refresh = refreshTargets.cells2refresh;
            }
            if (layouts2refresh) {
                this.at_layouts2refresh = new Array();
            }
            if (sections) {
                for (var i = 0; i < sections.length; i++) {
                    var isSectionPresent = false;
                    for (var j = 0; j < this.at_sectionsTable.length; j++) {
                        if (this.at_sectionsTable[j] == sections[i] && this.at_layouts2refresh[j].getAttribute('data-methodName') == layouts2refresh[i].getAttribute('data-methodName')) {
                            isSectionPresent = true;
                            break;
                        }
                    }
                    if (!isSectionPresent) {
                        this.at_sectionsTable.push(sections[i]);
                        this.at_layouts2refresh.push(layouts2refresh[i]);
                    }
                }
            }
            if (preActivities) {
                for (var i = 0; i < preActivities.length; i++) {
                    var isActivityPresent = false;
                    for (var j = 0; j < this.rw_preActivities.length; j++) {
                        if (this.rw_preActivities[j] == preActivities[i]) {
                            isActivityPresent = true;
                            break;
                        }
                    }
                    if (!isActivityPresent) {
                        this.rw_preActivities.push(preActivities[i]);
                    }
                }
            }
            if (dataTransforms) {
                for (var i = 0; i < dataTransforms.length; i++) {
                    var isDataTransformPresent = false;
                    for (var j = 0; j < this.dataTransforms.length; j++) {
                        if (this.dataTransforms[j] == dataTransforms[i]) {
                            isDataTransformPresent = true;
                            break;
                        }
                    }
                    if (!isDataTransformPresent) {
                        this.dataTransforms.push(dataTransforms[i]);
                    }
                }
            }
        }
        /*Code for New Evaluation Engine - Autobots - end*/
        if (this.at_sectionsTable.length > 0) {
            var surl = '';
            if (ccObj.type == 'ELEM') {
                var propRef = pega.u.property.toHandle(ccObj.elementName);
                var propDomArr = pega.u.d.getCorrectPropertyElemFromDOM(propRef, pega.ui.ChangeTrackerMap.getTracker());
                if (propDomArr && propDomArr.length > 0 && propDomArr[0].id != 'CV') {
                    var srcValue = pega.u.d.getGroupElementValue(propDomArr);
                    surl = new SafeURL();
                    surl.put(propRef, srcValue);
                }
            }
            pega.u.d.reloadSections(surl, this.at_sectionsTable, '', '', null, null, this.rw_preActivities, this.dataTransforms, declarePageParams, this.at_layouts2refresh);
            this.serverRefresh = true;
            this.at_sectionsTable = null;
        }
    },
    getElementRowPageRef: function (ctDiv) {
        var gridObj = null;
        var rowPage = "";
        var rtRow = null;
        if (ctDiv && typeof (Grids) != 'undefined') {
            gridObj = Grids.getElementsGrid(ctDiv);
        }
        if (gridObj != null) {
            if (gridObj.bPageGroup) {
                var container = null;
                if (pega.util.Dom.isAncestor(gridObj.leftBodyUL, ctDiv)) {
                    container = gridObj.leftBodyUL;
                }
                else if (pega.util.Dom.isAncestor(gridObj.rightBodyTbl, ctDiv)) {
                    container = gridObj.rightBodyTbl;
                }
                var cell = gridObj.findCell(null, container, ctDiv);
                var rtRowIndex = gridObj.getRowIndex(cell);
                if (rtRowIndex) {
                    rtRowIndex = gridObj.getPGRowIndex(rtRowIndex);
                }
                rtRow = gridObj.getRightRow(rtRowIndex);
            }
            else {
                if (gridObj.bTreegrid) {
                    rtRow = pega.u.d.getRepeatRow(ctDiv, true);
                }
                else {
                    var rtRowIndex = pega.u.d.getRepeatRow(ctDiv);
                    if (gridObj.bPagingEnabled) {
                        for (row in gridObj.rightBodyTbl.rows) {
                            if (gridObj.rightBodyTbl.rows[row].getAttribute("pl_index") == rtRowIndex) {
                                rtRow = gridObj.rightBodyTbl.rows[row];
                                break;
                            }
                        }
                    }
                    else {
                        rtRow = gridObj.getRightRow(rtRowIndex);
                    }
                }
            }
            if (rtRow) {
                rowPage = rtRow.hpref ? rtRow.hpref : rtRow.id;
                rowPage = pega.u.property.toReference(rowPage);
            }
        }
        else if (pega.u.d.getRepeatObject(ctDiv)) {
            rtRow = pega.u.d.getRepeatRow(ctDiv, true);
            if (rtRow && rtRow.getAttribute("hPref"))
                rowPage = pega.u.property.toReference(rtRow.getAttribute("hPref"));
        }
        return rowPage;
    },
    isExpressionMatchingWithTrackedProps: function (configuredListName, addDelete, gridAddDelete) {
        var matched = false;
        var sourceChangeList;
        if (addDelete) {
            sourceChangeList = this.ct_addRemovePagesList;
        }
        else if (gridAddDelete) {
            sourceChangeList = this.ct_changedPropertiesList;
        }
        else {
            var domElem = pega.ctx.dom.$("*[name='" + pega.u.property.toHandle(configuredListName) + "']");
            if (domElem && domElem.length > 0 && domElem[0].id != 'CV') {
                // return false if element present on dom
                return false;
            }
            sourceChangeList = this.ct_changedPropertiesList;
        }
        configuredListName = configuredListName.replace(/\(\)/ig, "");
        var confArray = configuredListName.split('.');
        if (sourceChangeList && sourceChangeList.length >= 1) {
            for (var propIdx = 0; propIdx < sourceChangeList.length; propIdx++) {
                if (sourceChangeList[propIdx] == configuredListName) {
                    matched = true;
                    break;
                }
                else {
                    var sourceArray = sourceChangeList[propIdx].split('.');
                    if (sourceArray.length == confArray.length) {
                        var matching = true;
                        for (var i = 0; i < sourceArray.length; i++) {
                            if (sourceArray[i] != confArray[i]) {
                                if (confArray[i].lastIndexOf(')') != confArray[i].length - 1) {
                                    if (sourceArray[i].replace(/\([\w]*\)/ig, "") != confArray[i]) {
                                        matching = false;
                                        break;
                                    }
                                }
                                else {
                                    matching = false;
                                    break;
                                }
                            }
                        }
                        if (matching) {
                            matched = true;
                            break;
                        }
                    }
                }
            }
        }
        return matched;
    },
    isExpressionMatching: function (listProperties, completeListName, configuredListName, completeConfiguredListName) {
        if (pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal()) {
            if (!pega.u.d.temp_currentCT) {
                pega.u.d.temp_currentCT = pega.ui.ChangeTrackerMap.getTracker();
            }
            completeListName = pega.ui.AutopopulateSupport.resolveReference(completeListName, pega.u.d.temp_currentCT);
            configuredListName = pega.ui.AutopopulateSupport.resolveReference(configuredListName, pega.u.d.temp_currentCT);
            completeConfiguredListName = pega.ui.AutopopulateSupport.resolveReference(completeConfiguredListName, pega.u.d.temp_currentCT);
        }
        //Convert to lower case for case insensitive comparisons
        completeListName = completeListName.toLowerCase();
        configuredListName = configuredListName.toLowerCase();
        completeConfiguredListName = completeConfiguredListName.toLowerCase();
        //Remove paranthesis which do not have indexes/subscripts
        completeListName = completeListName.replace(/\(\)/ig, "");
        configuredListName = configuredListName.replace(/\(\)/ig, "");
        completeConfiguredListName = completeConfiguredListName.replace(/\(\)/ig, "");
        //Remove indexes  from the completeListName
        var completeListNameNoIndex = completeListName.replace(/\([\w]*\)/ig, "");
        //If the user has configured indexes, insert them back into the completeListNameNoIndex
        if (configuredListName.match(/\([\w]+\)/i) && completeListNameNoIndex.indexOf(configuredListName.replace(/\([\w]*\)/ig, "")) > -1) {
            var tmpCLN = completeListName.split(".");
            var tmpConfigLN = configuredListName.split(".");
            var diffLength = tmpCLN.length - tmpConfigLN.length;
            if (diffLength >= 0) {
                for (var i = 0; i < tmpConfigLN.length; i++) {
                    if (tmpConfigLN[i] && !tmpConfigLN[i].match(/\([\w]+\)/i) && tmpCLN[i + diffLength]) {
                        tmpCLN[i + diffLength] = tmpCLN[i + diffLength].replace(/\([\w]+\)/i, "");
                    }
                }
            }
            completeListNameNoIndex = "";
            for (var i = 0; i < tmpCLN.length; i++)
                completeListNameNoIndex += "." + tmpCLN[i];
            completeListNameNoIndex = completeListNameNoIndex.substring(1);
        }
        if (pega.u.d.evaluateSplKeyword(completeListName, configuredListName, completeConfiguredListName, completeListNameNoIndex))
            return true;
        else if (listProperties != null) {
            var primaryPage = listProperties.listPrimaryPage;
            if (!primaryPage && listProperties.listBaseRef && listProperties.listBaseRef.indexOf(".") > -1) {
                primaryPage = listProperties.listBaseRef.substr(0, listProperties.listBaseRef.indexOf("."));
            }
            if (primaryPage && (configuredListName == completeListName.replace(primaryPage.toLowerCase(), "") || configuredListName == completeListNameNoIndex.replace(primaryPage.toLowerCase(), ""))) {
                return true;
            }
        }
        else {
            var primaryPage = SafeURL_createFromURL(pega.ctx.url).get('pzPrimaryPageName');
            if (primaryPage) {
                completeListName = completeListName.replace(primaryPage.toLowerCase(), "");
                completeListNameNoIndex = completeListNameNoIndex.replace(primaryPage.toLowerCase(), "");
                return pega.u.d.evaluateSplKeyword(completeListName, configuredListName, completeConfiguredListName, completeListNameNoIndex);
            }
        }
        return false;
    },
    evaluateSplKeyword: function (completeListName, configuredListName, completeConfiguredListName, completeListNameNoIndex) {
        //Conditions checkes as per design doc availabe at: https://mesh.pega.com/docs/DOC-17206
        //Condition at step "b" : configuredListName = Section’s Refresh When condition after stripping AddDelete from it
        if (configuredListName == completeListName)
            return true;
        else if (configuredListName == completeListNameNoIndex)
            return true;
        else if (completeConfiguredListName == completeListName)
            return true;
        else if (completeConfiguredListName == completeListNameNoIndex)
            return true;
        return false;
    },
    evaluateActiveWhens: function () {
        pega.ctx.dom.$("span.layout-active-when").each(function () {
            var activeWhens = this.getAttribute("data-activewhen");
            if (activeWhens) {
                try {
                    activeWhens = JSON.parse(activeWhens);
                    var activeIndex = -1;
                    for (var i = 0; i < activeWhens.length; i++) {
                        var currentCond = activeWhens[i];
                        if (pega.u.d.evaluateExpression(this, null, currentCond['when'])) {
                            activeIndex = currentCond['index'];
                            try {
                                var layoutElem = $(this.parentNode).children('.layout').get(activeIndex - 1);
                                if (layoutElem.style.display == "none")
                                    continue;
                                $(this.parentNode).children('.layout.active').each(function () {
                                    LayoutGroupModule.setLayoutInactive(this);
                                });
                                LayoutGroupModule.setLayoutActive(layoutElem);
                                break;
                            }
                            catch (e) { }
                        }
                    }
                }
                catch (e) { }
            }
        });
    },
    cleanRequiredAttr: function () {
        pega.ctx.dom.$("[data-required='false']").each(function () {
            var temp = this.getAttribute("validationtype");
            if (temp && temp != "") {
                if (temp.length == 8) {
                    this.setAttribute("validationtype", "");
                }
                else if (temp.length > 8) {
                    temp = temp.replace("required,", "");
                    temp = temp.replace(",required", "");
                    this.setAttribute("validationtype", temp);
                }
            }
            this.setAttribute("data-required", "true");
        });
    },
    evaluateRequiredWhens: function () {
        pega.ctx.dom.$("[data-required='true']").each(function () {
            if (pega.u.d.evaluateExpression(this, 'data-required-when')) {
                var temp = this.getAttribute("validationtype");
                if (temp.indexOf("required") == -1) {
                    if (!temp || temp.length == 0) {
                        this.setAttribute("validationtype", "required");
                    }
                    else {
                        this.setAttribute("validationtype", "required," + temp);
                    }
                    $(this).parents('div .field-item').siblings('label').children().each(function () {
                        if (this.tagName == 'SPAN' && this.getAttribute("data-class")) {
                            this.setAttribute('class', this.getAttribute("data-class"));
                            this.removeAttribute('data-class');
                        }
                        else if (this.tagName == 'STRONG') {
                            $(this).removeClass('display-none');
                        }
                    });
                }
            }
            else {
                var temp = this.getAttribute("validationtype");
                if (temp.indexOf("required") != -1) {
                    if (temp && temp != "") {
                        temp = temp.replace("required,", "");
                        temp = temp.replace(",required", "");
                        temp = temp.replace("required", "");
                        this.setAttribute("validationtype", temp.replace("required,", ""));
                    }
                    if ($(this).val() == '') {
                        getErrorDB().clearError(this.name);
                        $(this).siblings('div .iconErrorDiv').attr('style', 'display: none;');
                        $(this).parents('div .field-item').siblings('label').removeClass('labelError');
                    }
                    $(this).parents('div .field-item').siblings('label').children().each(function () {
                        if (this.tagName == 'SPAN' && this.getAttribute("class")) {
                            this.setAttribute('data-class', this.getAttribute("class"));
                            this.removeAttribute('class');
                        }
                        else if (this.tagName == 'STRONG') {
                            $(this).addClass('display-none');
                        }
                    });
                }
            }
        });
    },
    evaluateExpression: function (elem, condAttr, condition) {
        var configuredCondition;
        if (condition) {
            configuredCondition = condition;
        }
        else {
            configuredCondition = elem.getAttribute(condAttr);
        }
        if (configuredCondition == null || configuredCondition == '') {
            return true;
        }
        var sectionData = "";
        sectionData = pega.u.d.getSectionBaseReference(elem, true);
        /*
        var sectionData = pega.u.d.calcAndAttachSectionBaseRef(elem, true);
        var sectionBaseRef = sectionData.sectionBaseRef;
        if (sectionBaseRef == 'nosection') {
          var gridObj = null;
          if (typeof (Grids) != 'undefined') {
            gridObj = Grids.getElementsGrid(elem);
          }
          sectionBaseRef = pega.u.d.getBaseRef(elem, null, gridObj);
          if (sectionBaseRef == '') { //Element might be a column in a repeat layout
            sectionBaseRef = pega.u.d.getElementRowPageRef(elem);
          }
        }
        */
        if (sectionData.sectionBaseRef == null || sectionData.sectionBaseRef == 'nosection')
            return false;
        var conditionTokensNOperator = pega.u.d.getConditionTokensAndOperator(configuredCondition);
        var conditionTokens = conditionTokensNOperator.conditionTokens;
        var combOperator = conditionTokensNOperator.combOperator;
        var resultsArr = [];
        for (var j = 0; j < conditionTokens.length; j++) {
            var currentToken = pega.lang.trim(conditionTokens[j]);
            resultsArr[j] = pega.u.d.isRegularTarget(currentToken, sectionData.sectionBaseRef, elem);
        }
        var expression = "";
        for (var k = 0; k < resultsArr.length; k++) {
            if (k == 0)
                expression = resultsArr[k];
            else
                expression = expression + combOperator + resultsArr[k];
        }
        return eval(expression);
    },
    mixedExpressionAddGridRowsToCTDivs: function (ctDivs, gridObj, configuredCondition) {
        var gridRows = gridObj.rightBodyTbl.rows;
        var noOfRows = gridRows.length;
        for (var row = 0; row < noOfRows; row++) {
            var rowEl = gridRows[row];
            var reference = "";
            if (rowEl && rowEl.id) {
                reference = pega.ui.property.toReference(rowEl.id);
            }
            else {
                continue;
            }
            if (gridObj.pageMode == "Progressive Load" && gridObj.isDummyRow(rowEl.rowIndex))
                continue;
            rowEl.configuredCondition = configuredCondition;
            rowEl.rowRef = reference;
            rowEl.gridObj = gridObj;
            ctDivs.push(rowEl);
        }
    },
    getGridObjFromCTDiv: function (CTDiv) {
        var gridDiv = CTDiv.firstChild;
        if (gridDiv && gridDiv.id)
            return pega.ctx.Grid.map[gridDiv.id];
    },
    cleanGridRow: function (rowEl) {
        if (rowEl.configuredCondition)
            rowEl.configuredCondition = null;
        if (rowEl.rowRef)
            rowEl.rowRef = null;
        if (rowEl.gridObj)
            rowEl.gridObj = null;
        rowEl.removeAttribute("FULLPROPS");
    },
    localsExpressionAddGridRowsToCTDivs: function (ctDivs, gridObj, expressionProps, configuredCondition, clientSideChangedProperty) {
        var dataSource = gridObj.dataSourceRef;
        var changedProps = [];
        if (clientSideChangedProperty && clientSideChangedProperty.name) {
            changedProps.push(pega.ui.property.toReference(clientSideChangedProperty.name));
        }
        else {
            changedProps = pega.u.d.temp_currentCT.changedPropertiesList;
        }
        var length = changedProps.length;
        var processedRows = [];
        for (var i = 0; i < length; i++) {
            var prop = changedProps[i];
            var indexOfDotAfterDataSrc = prop.indexOf('.', dataSource.length);
            if (prop.indexOf(dataSource) > -1) {
                var trackedProp = prop.substring(indexOfDotAfterDataSrc);
                if (jQuery.inArray(trackedProp, expressionProps) > -1) {
                    var rowRef = prop.substring(0, indexOfDotAfterDataSrc);
                    if (jQuery.inArray(rowRef, processedRows) > -1)
                        continue;
                    else
                        processedRows.push(rowRef);
                    var rowEntryHandle = pega.ui.property.toHandle(rowRef);
                    var rowEl = $(gridObj.gridDiv).find("#" + rowEntryHandle.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&"));
                    if (rowEl && rowEl.length)
                        rowEl = rowEl[0];
                    else
                        continue;
                    if (gridObj.pageMode == "Progressive Load" && gridObj.isDummyRow(rowEl.rowIndex))
                        continue;
                    rowEl.rowRef = rowRef;
                    rowEl.gridObj = gridObj;
                    rowEl.configuredCondition = configuredCondition;
                    ctDivs.push(rowEl);
                }
            }
        }
    },
    addGridRowsToCTDivs: function (ctDivs, currDiv, gridsWithRowsToRefresh, clientSideChangedProperty) {
        var gridObj = this.getGridObjFromCTDiv(currDiv);
        if (!gridObj)
            return;
        gridsWithRowsToRefresh.push(gridObj);
        if (currDiv.getAttribute("type") == "mixed" || gridObj.bTreegrid)
            this.mixedExpressionAddGridRowsToCTDivs(ctDivs, gridObj, currDiv.getAttribute("RRW"));
        else if (currDiv.getAttribute("type") == "allLocals") {
            this.localsExpressionAddGridRowsToCTDivs(ctDivs, gridObj, currDiv.getAttribute("RRLocalsP").split(','), currDiv.getAttribute("RRW"), clientSideChangedProperty);
        }
    },
    getAllRefreshableTargets: function (type, elementName, rcw, layoutrefresh) {
        var sections2refresh = null;
        var preActivities = null;
        var dataTransforms = null;
        var cells2refresh = null;
        var secDeclarePageParams = null;
        var gridsToRefresh = null;
        var gridsWithRowsToRefresh = [];
        var ctDivs = null;
        var elemEntryHandle = pega.u.property.toHandle(elementName);
        var srcElem = elemEntryHandle ? pega.ctx.dom.querySelector("*[name='" + elemEntryHandle + "']") : null;
        var rwAttrList = (rcw ? ["RC"] : ["RW", "data-dprw", "IRW", "RRW"]);
        if (type == 'ALL')
            type = 'TCL';
        if (layoutrefresh) {
            rcw = true;
            ctDivs = pega.ctx.dom.querySelectorAll("div[data-refresh='true']");
        }
        else {
            ctDivs = pega.ctx.dom.querySelectorAll("DIV#CT");
        }
        if (ctDivs) {
            for (var i = 0; i < ctDivs.length; i++) {
                var currDiv = ctDivs[i];
                var isGrid = false;
                if (currDiv.getAttribute("RLW")) {
                    isGrid = true;
                }
                // Refresh Rows : Start
                var gridMixed = false;
                if (currDiv.getAttribute("RRW") && currDiv.getAttribute("type") != "allGlobals") {
                    this.addGridRowsToCTDivs(ctDivs, currDiv, gridsWithRowsToRefresh, srcElem);
                    continue;
                }
                if (currDiv.rowRef && currDiv.rowRef != "") {
                    isGrid = true;
                    gridMixed = true;
                }
                // Refresh Rows : end
                if (!isGrid) {
                    /*Get Section's Base Reference and included section*/
                    var sectionData = pega.u.d.calcAndAttachSectionBaseRef(currDiv, rcw);
                    var sectionBaseRef = sectionData.sectionBaseRef;
                    /*The DIV has ct div configuration, but has no section inside it*/
                    if (sectionBaseRef == 'nosection')
                        continue;
                    var baseRef4ConditionEval = sectionData.baseRef4ConditionEval;
                }
                else {
                    if (gridMixed) {
                        var baseRef4ConditionEval = currDiv.rowRef;
                        var sectionBaseRef = currDiv.rowRef;
                    }
                    else {
                        var baseRef4ConditionEval = this.getBaseRef(currDiv);
                        var sectionBaseRef = baseRef4ConditionEval;
                    }
                }
                for (var idx = 0; idx < rwAttrList.length; idx++) {
                    /*Get Configured Expression*/
                    if (gridMixed && rwAttrList[idx] == "RRW") {
                        var configuredCondition = currDiv.configuredCondition;
                    }
                    else {
                        var configuredCondition = currDiv.getAttribute(rwAttrList[idx]);
                    }
                    if (!configuredCondition)
                        continue;
                    /*Break the condition into tokens at the combimation operators*/
                    var conditionTokensNOperator = pega.u.d.getConditionTokensAndOperator(configuredCondition);
                    var conditionTokens = conditionTokensNOperator.conditionTokens;
                    var combOperator = conditionTokensNOperator.combOperator;
                    var harnessContext = pega.ui.HarnessContextMgr.getCurrentHarnessContext();
                    var resultsArr = [];
                    var changesRegEx = /\s+changes/i;
                    var addDelRegEx = /\s+adddelete/i;
                    for (var j = 0; j < conditionTokens.length; j++) {
                        var currentToken = pega.lang.trim(conditionTokens[j]);
                        if (changesRegEx.test(currentToken)) {
                            var configuredCondition = currentToken.replace(/\s+changes/i, ""); //removing the changes keyword
                            if (!isGrid && !sectionBaseRef) {
                                sectionBaseRef = SafeURL_createFromURL(harnessContext.getProperty("url")).get('pzPrimaryPageName');
                            }
                            if (!baseRef4ConditionEval) {
                                baseRef4ConditionEval = SafeURL_createFromURL(harnessContext.getProperty("url")).get('pzPrimaryPageName');
                            }
                            else if (baseRef4ConditionEval.charAt(0) == ".") {
                                baseRef4ConditionEval = SafeURL_createFromURL(harnessContext.getProperty("url")).get('pzPrimaryPageName') + baseRef4ConditionEval;
                            }
                            var completeConfiguredCondition = this.buildFullReference(configuredCondition, baseRef4ConditionEval);
                            this.setFULLPROPS(currDiv, completeConfiguredCondition);
                            if (type == 'ELEM' && pega.u.d.isExpressionMatching(null, elementName, configuredCondition, completeConfiguredCondition))
                                resultsArr[j] = true;
                            else if ((type == 'TCL' || type == 'ELEM') && pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(completeConfiguredCondition))
                                resultsArr[j] = true;
                            else if ((type == 'OGRD' || type == 'OGRI') && pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(completeConfiguredCondition, false, true)) {
                                resultsArr[j] = true;
                            }
                            else
                                resultsArr[j] = false;
                        }
                        else if (addDelRegEx.test(currentToken)) {
                            var configuredListName = currentToken.replace(/\s+adddelete/i, ""); //removing the adddelete keyword
                            if (!isGrid && !sectionBaseRef) {
                                sectionBaseRef = SafeURL_createFromURL(harnessContext.getProperty("url")).get('pzPrimaryPageName');
                            }
                            if (!baseRef4ConditionEval) {
                                baseRef4ConditionEval = SafeURL_createFromURL(harnessContext.getProperty("url")).get('pzPrimaryPageName');
                            }
                            else if (baseRef4ConditionEval.charAt(0) == ".") {
                                baseRef4ConditionEval = SafeURL_createFromURL(harnessContext.getProperty("url")).get('pzPrimaryPageName') + baseRef4ConditionEval;
                            }
                            var completeConfiguredListName = this.buildFullReference(configuredListName, baseRef4ConditionEval);
                            this.setFULLPROPS(currDiv, completeConfiguredListName, "adddelete");
                            if (type == 'ELEM' && pega.u.d.isExpressionMatching(null, elementName, configuredCondition, completeConfiguredListName))
                                resultsArr[j] = true;
                            else if ((type == 'TCL' || type == 'ELEM') && pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(completeConfiguredListName, true))
                                resultsArr[j] = true;
                            else if ((type == 'OGRD' || type == 'OGRI') && pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(completeConfiguredListName, true)) {
                                resultsArr[j] = true;
                            }
                            else
                                resultsArr[j] = false;
                        }
                        else {
                            resultsArr[j] = pega.u.d.isRegularTarget(currentToken, baseRef4ConditionEval, currDiv);
                        }
                    }
                    var rwcpValue = currDiv.getAttribute("FULLPROPS");
                    var executeExpression = false;
                    if (rwcpValue) {
                        var rwcpArray = rwcpValue.split(",");
                        for (var l = 0; l < rwcpArray.length; l++) {
                            var correctConfig = rwcpArray[l];
                            var listProp = false;
                            if (rwcpArray[l].indexOf("-A$D") != -1) {
                                correctConfig = rwcpArray[l].replace("-A$D", "");
                                listProp = true;
                            }
                            if (type == 'TCL' && pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(correctConfig, listProp)) {
                                executeExpression = true;
                                break;
                            }
                            else {
                                if (type == 'ELEM') {
                                    if (pega.u.d.isExpressionMatching(null, elementName, correctConfig, correctConfig) || pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(correctConfig, listProp)) {
                                        executeExpression = true;
                                        break;
                                    }
                                }
                                else if (listProp) {
                                    if ((type == 'OGRD' || type == 'OGRI') && pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(correctConfig, true)) {
                                        executeExpression = true;
                                        break;
                                    }
                                }
                                else {
                                    if ((type == 'OGRD' || type == 'OGRI') && pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(correctConfig, false, true)) {
                                        executeExpression = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (executeExpression) {
                        var expression = "";
                        for (var k = 0; k < resultsArr.length; k++) {
                            if (k == 0)
                                expression = resultsArr[k];
                            else
                                expression = expression + combOperator + resultsArr[k];
                        }
                        if (!isGrid && eval(expression) && sectionData.includedSec.getAttribute('node_name') != null && !pega.u.d.isDuplicateRefresh(sectionData.includedSec.getAttribute('node_name'), sectionBaseRef, currDiv)) {
                            if (!sections2refresh)
                                sections2refresh = [];
                            var preActivity = currDiv.getAttribute("RWA");
                            if (preActivity) {
                                if (!preActivities)
                                    preActivities = [];
                                preActivities.push(preActivity + "<||>" + sectionBaseRef);
                            }
                            var dataTransform = currDiv.getAttribute("PDT");
                            if (dataTransform) {
                                if (!dataTransforms)
                                    dataTransforms = [];
                                dataTransforms.push(dataTransform + "<||>" + sectionBaseRef);
                            }
                            var declarePageParams = sectionData.includedSec.getAttribute("data-declare-params");
                            if (declarePageParams && declarePageParams != "") {
                                if (secDeclarePageParams == null) {
                                    secDeclarePageParams = {};
                                }
                                try {
                                    declarePageParams = pega.c.eventParser.replaceTokensWrapper(declarePageParams, "", "", false, false);
                                    var paramsList = eval("(" + declarePageParams + ")");
                                    if (paramsList) {
                                        //var sectionName = sectionData.includedSec.getAttribute('node_name');
                                        var uniqueId = sectionData.includedSec.getAttribute('uniqueid'); /*changed sectionname to unique id as same section can be used elsewhere, but uniqueid is unique*/
                                        secDeclarePageParams[uniqueId] = {};
                                        var key = "";
                                        for (key in paramsList) {
                                            secDeclarePageParams[uniqueId][key] = paramsList[key];
                                        }
                                    }
                                }
                                catch (e) { }
                            }
                            sections2refresh.push(sectionData.includedSec);
                            if (!cells2refresh)
                                cells2refresh = [];
                            cells2refresh.push(currDiv);
                        }
                        if (isGrid && eval(expression)) {
                            if (!gridsToRefresh) {
                                gridsToRefresh = [];
                            }
                            if (!gridMixed && $(currDiv).children().first()[0]) {
                                var gridID = $(currDiv).children().first()[0].id;
                                gridsToRefresh.push(pega.ctx.Grid.map[gridID]);
                            }
                            if (gridMixed && currDiv.gridObj) {
                                if (!currDiv.gridObj.rowsToRefresh) {
                                    currDiv.gridObj.rowsToRefresh = [];
                                }
                                currDiv.gridObj.rowsToRefresh.push(currDiv.rowRef);
                                this.cleanGridRow(currDiv);
                            }
                        }
                    }
                }
            }
        }
        return {
            "sections": sections2refresh,
            "preActivities": preActivities,
            "dataTransforms": dataTransforms,
            "cells2refresh": cells2refresh,
            "gridsToRefresh": gridsToRefresh,
            "declarePageParams": secDeclarePageParams,
            "gridsWithRowsToRefresh": gridsWithRowsToRefresh
        };
    },
    isDuplicateRefresh: function (sectionRef, baseRef, ctDiv) {
        var retVal = false;
        var insidePopover = false;
        var plevel = pega.u.d.getPopOverLevel(ctDiv);
        if (plevel >= 0) {
            insidePopover = pega.u.d.getPopOver(plevel).isActive();
        }
        /*BUG-220280 :Added an extra condition to check for the presence of ctDiv in popover element*/
        if (!insidePopover && pega.u.d.bModalDialogOpen && pega.u.d.modalDialog.body && !pega.util.Dom.isAncestor(pega.u.d.modalDialog.body, ctDiv)) {
            return true;
        }
        if (pega.u.d.ct_sectionsList.length > 0) {
            for (var i = 0; i < pega.u.d.ct_sectionsList.length; i++) {
                if (pega.u.d.ct_sectionsList[i] == (sectionRef + "~" + baseRef)) {
                    retVal = true;
                    break;
                }
                var secRef = pega.u.d.ct_sectionsList[i].split("~");
                var secElem = pega.u.d.getSectionByName(secRef[0], secRef[1], pega.ctx.dom.getContextRoot());
                if (pega.util.Dom.isAncestor(secElem, ctDiv)) {
                    retVal = true;
                    break;
                }
            }
        }
        return retVal;
    },
    isChangesTarget: function (completeSrcReference, configuredCondition, sectionBaseRef, currentDiv) {
        configuredCondition = configuredCondition.replace(/\s+changes/i, ""); //removing the changes keyword
        var completeConfiguredCondition = this.buildFullReference(configuredCondition, sectionBaseRef);
        this.setFULLPROPS(currentDiv, completeConfiguredCondition);
        if (pega.u.d.isExpressionMatching(null, completeSrcReference, configuredCondition, completeConfiguredCondition)) {
            return true;
        }
        else {
            /* BUG-84533 - Start : we should calculate proper section base reference to set full property reference */
            if (!sectionBaseRef) {
                sectionBaseRef = SafeURL_createFromURL(pega.ctx.url).get('pzPrimaryPageName');
            }
            else if (sectionBaseRef.charAt(0) == ".") {
                sectionBaseRef = SafeURL_createFromURL(pega.ctx.url).get('pzPrimaryPageName') + sectionBaseRef;
            }
            completeConfiguredCondition = this.buildFullReference(configuredCondition, sectionBaseRef);
            this.setFULLPROPS(currentDiv, completeConfiguredCondition);
            /* BUG-84533 - End */
            if (!pega.u.d.temp_currentCT) {
                pega.u.d.temp_currentCT = pega.ui.ChangeTrackerMap.getTracker();
            }
            if (pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(completeConfiguredCondition))
                return true;
            else
                return false;
        }
    },
    isAddDeleteTarget: function (listProperty, configuredListName, sectionBaseRef, currentDiv) {
        var completeListName = this.getCompleteListName(listProperty);
        configuredListName = configuredListName.replace(/\s+adddelete/i, ""); //removing the adddelete keyword
        var completeConfiguredListName = this.buildFullReference(configuredListName, sectionBaseRef);
        this.setFULLPROPS(currentDiv, completeConfiguredListName, "adddelete");
        if (this.isExpressionMatching(listProperty, completeListName, configuredListName, completeConfiguredListName))
            return true;
        else if (pega.u.d.temp_currentCT.isExpressionMatchingWithTrackedProps(completeConfiguredListName, true))
            return true;
        else
            return false;
    },
    getCompleteListName: function (listProperty) {
        var completeListName = listProperty.listName;
        var appendString = "";
        listProperty.listBaseRef ? appendString = listProperty.listBaseRef : appendString = listProperty.listPrimaryPage;
        //Generate the complete List name by appending the base ref of the list of the primary page of the list with the list name
        if (appendString)
            completeListName = appendString + listProperty.listName;
        return completeListName;
    },
    isRegularTarget: function (configuredCondition, sectionBaseRef, currentDiv, isFromVisibleWhen) {
        if (configuredCondition.indexOf("(") == 0) {
            configuredCondition = configuredCondition.substring(1);
        }
        if (configuredCondition.lastIndexOf(")") == configuredCondition.length - 1) {
            var li = configuredCondition.lastIndexOf("(");
            if (li == -1 || configuredCondition.indexOf(")", li) != configuredCondition.length - 1) {
                configuredCondition = configuredCondition.substring(0, configuredCondition.length - 1);
            }
        }
        /*Extracting LHS and RHS*/
        var operandArray = [];
        var operator = "";
        if (configuredCondition.indexOf("!=") != -1) {
            operandArray = configuredCondition.split("!=");
            operator = "!=";
        }
        else if (configuredCondition.indexOf(">=") != -1) {
            operandArray = configuredCondition.split(">=");
            operator = ">=";
        }
        else if (configuredCondition.indexOf("<=") != -1) {
            operandArray = configuredCondition.split("<=");
            operator = "<=";
        }
        else if (configuredCondition.indexOf(">") != -1) {
            operandArray = configuredCondition.split(">");
            operator = ">";
        }
        else if (configuredCondition.indexOf("<") != -1) {
            operandArray = configuredCondition.split("<");
            operator = "<";
        }
        else if (configuredCondition.indexOf("==") != -1) {
            operandArray = configuredCondition.split("==");
            operator = "==";
        }
        else if (configuredCondition.indexOf("=") != -1) {
            operandArray = configuredCondition.split("=");
            operator = "=";
        }
        else {
            operandArray[0] = configuredCondition;
        }
        var elValues = [];
        var clientTargets = [];
        for (var i = 0; i < operandArray.length; i++) {
            var currentOperand = pega.lang.trim(operandArray[i]);
            try {
                if (!sectionBaseRef) {
                    sectionBaseRef = SafeURL_createFromURL(pega.ctx.url).get('pzPrimaryPageName');
                }
                var fullOperand = this.buildFullReference(currentOperand, sectionBaseRef);
                var fullOperandValue = pega.u.d.temp_currentCT.tempPropValuesMap[fullOperand];
                var operandValue = pega.u.d.getCorrectPropertyElemFromDOM(pega.u.property.toHandle(fullOperand), pega.u.d.temp_currentCT);
                if (operandValue && operandValue.length > 0 && operandValue[0].id != 'CV') {
                    if (pega.u.d.temp_currentCT.tempPropMap)
                        pega.u.d.temp_currentCT.tempPropMap[fullOperand] = 'dom';
                    if (elValues.length == 0) {
                        clientTargets[0] = fullOperand;
                        if (fullOperandValue == undefined) {
                            elValues[0] = pega.u.d.getGroupElementValue(operandValue);
                        }
                        else {
                            elValues[0] = fullOperandValue;
                        }
                    }
                    else {
                        clientTargets[clientTargets.length] = fullOperand;
                        if (fullOperandValue == undefined) {
                            elValues[elValues.length] = pega.u.d.getGroupElementValue(operandValue);
                        }
                        else {
                            elValues[elValues.length] = fullOperandValue;
                        }
                    }
                    operandArray[i] = fullOperand;
                    this.setFULLPROPS(currentDiv, fullOperand);
                }
                else {
                    if (pega.u.d.temp_currentCT.tempPropMap)
                        pega.u.d.temp_currentCT.tempPropMap[fullOperand] = 'ct';
                    if (fullOperandValue == undefined) {
                        var propValue = pega.u.d.temp_currentCT.getPropertyValue(fullOperand);
                    }
                    else {
                        var propValue = fullOperandValue;
                    }
                    if (propValue != null) {
                        if (elValues.length == 0) {
                            clientTargets[0] = fullOperand;
                            elValues[0] = propValue;
                        }
                        else {
                            clientTargets[clientTargets.length] = fullOperand;
                            elValues[elValues.length] = propValue;
                        }
                        operandArray[i] = fullOperand;
                        this.setFULLPROPS(currentDiv, fullOperand);
                    }
                }
            }
            catch (e) {
                continue;
            }
        }
        var expression = "";
        if (operandArray.length == 1) {
            expression = operandArray[0];
        }
        else {
            expression = operandArray[0] + operator + operandArray[1];
        }
        if (!isFromVisibleWhen) {
            return pega.u.d.evaluate(expression, clientTargets, elValues);
        }
        else {
            return { expression: expression, clientTargets: clientTargets, elValues: elValues };
        }
    },
    getCorrectPropertyElemFromDOM: function (propRef, currentCT) {
        var operandValue;
        if (pega.ui.ChangeTrackerMap.isSingleTracker()) {
            if (typeof propRef == "string" && propRef.trim().length <= 0) {
                operandValue = null;
                return operandValue;
            }
            if (propRef.indexOf('$P') === 0) {
                operandValue = document.getElementsByName(propRef);
            }
        }
        else {
            if (currentCT.isPrimary) {
                operandValue = pega.ctx.dom.getElementsByName(propRef);
                /*converting collection object to array*/
                var temp_arr = [];
                for (var i = 0; i < operandValue.length; i++)
                    temp_arr.push(operandValue[i]);
                operandValue = temp_arr;
                if (operandValue && operandValue.length > 0) {
                    var FADivs = pega.ctx.dom.$("DIV#pyFlowActionHTML");
                    if (FADivs && FADivs.length > 0) {
                        for (var i = 0; i < FADivs.length; i++) {
                            if (FADivs[i].getAttribute("THREAD_NAME") && (FADivs[i].getAttribute("THREAD_NAME").indexOf("/$WorkProcessing") != -1 || FADivs[i].getAttribute("THREAD_NAME").indexOf("/$FlowModalProcess") != -1)) {
                                var len = operandValue.length;
                                for (var j = 0; j < len; j++) {
                                    if ($.contains(FADivs[i], operandValue[j])) {
                                        operandValue.splice(j, 1);
                                        j--;
                                        len--;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else {
                if (pega.u.d.bModalDialogOpen && pega.u.d.modalDialog.body) {
                    if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.bIsOverlay == "true") {
                        operandValue = pega.ctx.dom.$("DIV#_popOversContainer").find("*[name='" + propRef.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&") + "']");
                    }
                    else {
                        operandValue = pega.ctx.dom.$(pega.u.d.modalDialog.body).find("*[name='" + propRef.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&") + "']");
                    }
                }
                else if (pega.ctx.isMDC) {
                    operandValue = pega.ctx.dom.$("[name='" + propRef.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&") + "']");
                }
                else {
                    if (pega.u.d.ServerProxy.isDestinationRemote()) {
                        var PHDiv = pega.ctx.dom.getElementById("PEGA_HARNESS");
                        if (PHDiv && (!PHDiv.hasAttribute("thread_name") || currentCT.threadName === PHDiv.getAttribute("thread_name"))) {
                            return $(PHDiv).find("[name='" + propRef.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&") + "']");
                        }
                    }
                    var FADivs = pega.ctx.dom.$("DIV#pyFlowActionHTML");
                    if (FADivs.length === 0) {
                        operandValue = pega.ctx.dom.$("[name='" + propRef.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&") + "']");
                    }
                    else {
                        for (var i = 0; i < FADivs.length; i++) {
                            if (currentCT.threadName === FADivs[i].getAttribute("THREAD_NAME")) {
                                operandValue = $(FADivs[i]).find("*[name='" + propRef.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&") + "']");
                                break;
                            }
                        }
                    }
                }
            }
        }
        return operandValue;
    },
    buildFullReference: function (configuredReference, sectionBaseRef) {
        var dot = ".";
        var completeConfiguredCondition = configuredReference;
        //Create the complete Section Name by appending the section name with the base ref.
        if (configuredReference.replace(/ /g, "").charAt(0) == ".") {
            //in case the configured name is Page1.xyz, dot is not required.
            dot = "";
            if (sectionBaseRef) {
                completeConfiguredCondition = sectionBaseRef + dot + configuredReference;
            }
        }
        return completeConfiguredCondition;
    },
    setFULLPROPS: function (currentDiv, value, origin) {
        var FULLPROPS = currentDiv.getAttribute("FULLPROPS");
        if (origin && origin == "adddelete") {
            value = value + "-A$D";
        }
        if (FULLPROPS) {
            if (FULLPROPS.indexOf(value) == -1) {
                currentDiv.setAttribute("FULLPROPS", FULLPROPS + "," + value);
            }
        }
        else {
            currentDiv.setAttribute("FULLPROPS", value);
        }
    },
    getConditionTokensAndOperator: function (configuredCondition) {
        var conditionTokens = [];
        var combOperator = "";
        if (configuredCondition.indexOf("||") != -1) {
            conditionTokens = configuredCondition.split("||");
            combOperator = "||";
        }
        else if (configuredCondition.indexOf("&&") != -1) {
            conditionTokens = configuredCondition.split("&&");
            combOperator = "&&";
        }
        else
            conditionTokens[0] = configuredCondition; //Single Expression
        return {
            "conditionTokens": conditionTokens,
            "combOperator": combOperator
        };
    }
};
pega.lang.augmentObject(pega.ui.Doc.prototype, conditionEngine);
//static-content-hash-trigger-GCC
pega.ui.ArrayUtil = (function() {
	function find(arr, fn) {
		if (typeof fn == 'function' && arr instanceof Array) {
			for (var i = 0; i < arr.length; i++) {
				if (fn.call(arr[i], i)) return arr[i];
			}
		} else {
			throw "Please pass array and a predicate";
		}
	}

	function merge(arr1, arr2) {
		var i;
		if (arr1 instanceof Array && arr2 instanceof Array) {
			for (var i = 0; i < arr2.length; i++) {arr1.push(arr2[i]);}
			return arr1;
		} else {
			throw "Please pass two arrays.";
		}
	}

	function unique(arr) {
		var i, map = {};
		if (arr instanceof Array) {
			for (i = 0; i < arr.length; i++) {map[arr[i]] = true;}
			return Object.keys(map);
		} else {
			throw "Please pass an array.";
		}
	}

	function sort(inputArray, sortOptions) {
		if (inputArray instanceof Array) {
			inputArray.sort(function(source, target) {
				//if source < target return 1 if you want ascending or -1 if not the case
				//if source > target return 1 if you want descending or -1 if not the case

				for (var index = 0; index < sortOptions.length; index++) {
					var sourceValue, targetValue, order, property;
					property = sortOptions[index].property;
					order = sortOptions[index].order;
					if (source[property] === undefined || source[property] === null) {
						sourceValue = "";
					} else {
						sourceValue = isNaN(source[property]) ? source[property].toLowerCase() : Number.parseFloat(source[property]);
					}

					if (target[property] === undefined || target[property] === null) {
						targetValue = "";
					} else {
						targetValue = isNaN(target[property]) ? target[property].toLowerCase() : Number.parseFloat(target[property]);
					}

					if (order === "ASCENDING") {
						if (sourceValue < targetValue) {
							return -1;
						}
						if (sourceValue > targetValue) {
							return 1;
						}
					}

					if (order === "DESCENDING") {
						if (sourceValue > targetValue) {
							return -1;
						}
						if (sourceValue < targetValue) {
							return 1;
						}
					}

				}
			});
		} else {
			throw "Invalid input. Please pass array as input for sorting";
		}
	}

	return {
		find: find,
		merge: merge,
		unique: unique,
		sort: sort
	};
})();
//static-content-hash-trigger-GCC
/*
 @api
 This function will open the tag deck based on the specified parameters. Calling this API will attempt to
 open a new tab per tabName. If a Tag Deck with the same tab name is already open, then the existing
 tab will be reloaded with the new context.
 @param $Object$event – Javascript event object that triggered this call
 @param $String$tagName – The tag that will used for reporting context by the Tag Deck
 @param $String$tabName – (Optional) Defaults to “Tag Deck”.  Visible tab name in the work area gadget [OR] Incase of popup, the title of the popup window.
 @return $void$
 */
pega.desktop.openTagDeck = function(event, tagName, tabName) {
  var app = pega.desktop.support.getDesktopApplication();
  var WAgadget = null;
  if (app) {
    var gadgetPool = app.gadgetPool;
    if (gadgetPool) {
      WAgadget = gadgetPool.findAvailableGadget();
    }
  }
  if (WAgadget && WAgadget.gadgetAvailable) {
    var args = arguments[0];
    if (typeof args == "object" && args.name == "safeURL") {
      var oSafeURL = SafeURL_clone(args);
    }
    if (!oSafeURL) {
      var oSafeURL = new SafeURL();
      if (tabName == ""){
        tabName = "Tag Deck";
      }
      oSafeURL.put("name", tabName);
      oSafeURL.put("ClassName", 'Data-Social-Tag');
      oSafeURL.put("HarnessName", 'pyTagDeck');
      oSafeURL.put("Page", "");
      oSafeURL.put("Model", "");
      oSafeURL.put("ReadOnly", "");
      oSafeURL.put("preActivityName", "pzGetTagDeck");
      oSafeURL.put("preActivityParams", "tagName:" + tagName);
      oSafeURL.put("SkipConflictCheck", true);
    }
    if (!pega.desktop.support.openSpace("Work", oSafeURL, "display")) {


      /*strUserId= oSafeURL.toQueryString();
       var strURL= pega.desktop.support.constructUrl(strUserId, "getnextwork");
       pega.desktop.openUrlInWindow(strURL, "pyWorkPage", WorkFormSize + PopupWindowFeatures);*/
    }
  } else {
    if (pega.desktop.support.getDesktopWindow()) {
      if (pega.desktop.support.getDesktopWindow().pega.composite)
        var mgr = pega.desktop.support.getDesktopWindow().pega.composite.objMultiView._objGadget.manager;
    }
    if (tabName == ""){
      tabName = "Tag Deck";
    }
    if (mgr)
      var gadget = mgr.getGadgetByKey(tabName);
    var preActivity = "pzGetTagDeck", preActivityParams = "tagName:" + tagName;
    if (gadget) {
      var tab = mgr.getTabByGadgetName(gadget.gadgetName);
      if (tab)
        mgr.replaceTab(tab, tabName, {close: "yes", key: ""}, {action: "display", page: "", model: "", harnessName: 'pyTagDeck', className: 'Data-Social-Tag',
          configObj: {}, preActivity: preActivity, preActivityParams: preActivityParams,
          readOnly: "", tabName: tabName});

    } else
      pega.desktop.showHarnessWrapper('newDocument', 'Data-Social-Tag', 'pyTagDeck', preActivity, preActivityParams, strPrimaryPage, tabName, "", "", event);
  }
};
//static-content-hash-trigger-GCC
/*
 @api
 This function will open the tag deck based on the specified parameters. Calling this API will attempt to
 open a new tab per tabName. If a Tag Deck with the same tab name is already open, then the existing
 tab will be reloaded with the new context.
 @param $Object$event – Javascript event object that triggered this call
 @param $String$searchPage – Pulse search results page
 @param $String$searchText – Search Text
 @return $void$
 */
pega.desktop.openPulseSearchResults = function(event, searchPage, threadName, searchText) {
  var app = pega.desktop.support.getDesktopApplication();
  var WAgadget = null;
  if (app) {
    var gadgetPool = app.gadgetPool;
    if (gadgetPool) {
      WAgadget = gadgetPool.findAvailableGadget();
    }
  }
  if (WAgadget && WAgadget.gadgetAvailable) {
    var args = arguments[0];
    if (typeof args == "object" && args.name == "safeURL") {
      var oSafeURL = SafeURL_clone(args);
    }
    if (!oSafeURL) {
      var oSafeURL = new SafeURL();
      var tabName = "Social Search";
      oSafeURL.put("name", tabName);
      oSafeURL.put("ClassName", 'PegaSocial-Message');
      oSafeURL.put("HarnessName", 'pyPulseSearchResults');
      oSafeURL.put("Page", "");
      oSafeURL.put("Model", "");
      oSafeURL.put("ReadOnly", "");
      oSafeURL.put("preActivityName", "pzGetPulseStream");
      oSafeURL.put("preActivityParams", "searchPageName:" + searchPage + ",searchText:" + searchText + ",threadName:" + threadName);
      oSafeURL.put("SkipConflictCheck", true);
    }
    if (!pega.desktop.support.openSpace("Work", oSafeURL, "display")) {


      /*strUserId= oSafeURL.toQueryString();
       var strURL= pega.desktop.support.constructUrl(strUserId, "getnextwork");
       pega.desktop.openUrlInWindow(strURL, "pyWorkPage", WorkFormSize + PopupWindowFeatures);*/
    }
  } else {
    if (pega.desktop.support.getDesktopWindow().pega.composite)
      var mgr = pega.desktop.support.getDesktopWindow().pega.composite.objMultiView._objGadget.manager;
    var tabName = "Social Search";
    if (mgr)
      var gadget = mgr.getGadgetByKey(tabName);
    var preActivity = "pzGetPulseStream", preActivityParams = "searchPageName:" + searchPage + ",searchText:" + searchText + ",threadName:" + threadName;

    if (gadget) {
      var tab = mgr.getTabByGadgetName(gadget.gadgetName);
      if (tab)
        mgr.replaceTab(tab, tabName, {close: "yes", key: ""}, {action: "display", page: "", model: "", harnessName: 'pyPulseSearchResults', className: 'PegaSocial-Message',
          configObj: {}, preActivity: preActivity, preActivityParams: preActivityParams,
          readOnly: "", tabName: tabName});

    } else
      pega.desktop.showHarnessWrapper('newDocument', 'PegaSocial-Message', 'pyPulseSearchResults', preActivity, preActivityParams, strPrimaryPage, tabName, "", "", event);
  }
};
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.dynamicnavigation");

pega.ui.dynamicnavigation.showharness = (function () {
    var publicAPI = {};
    /////////////////////////////////////////////////////////////////////////////////
    //                                  CONSTANTS                                  //
    /////////////////////////////////////////////////////////////////////////////////
   

    /////////////////////////////////////////////////////////////////////////////////
    //                                   GLOBALS                                   //
    /////////////////////////////////////////////////////////////////////////////////
    /* -- PRIVATE GLOBALS -- */
    /* -- PUBLIC GLOBALS -- */

    /////////////////////////////////////////////////////////////////////////////////
    //                              PRIVATE FUNCTIONS                              //
    /////////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////////
    //                               PUBLIC FUNCTIONS                              //
    /////////////////////////////////////////////////////////////////////////////////
  /**
    * launchHarnessForDynamicNavigation : Using launchHarness api call to show harness with required parameter for dynamic navigation
    * @param harnessName - harness name
    * @param harnessClass - harness class
    * @param tabName - harness tab name, always expecting a string
    * @param readOnly - readOnly Yes/No
    * @param activityName - preactivity name
    * @param activityParam - preactivity paramsto be passed
    * @param dataTransformName - predataTransform name
    * @param dataTransformParam - predataTransformParam params to be passed
    * @param event
    */
    publicAPI.launchHarnessForDynamicNavigation = function(harnessName, harnessClass, tabName, readOnly, activityName, activityParam, dataTransformName, dataTransformParam, event, stepPageRef ){
      var oDynNavOptions = {};
      oDynNavOptions.harness = harnessName;
      oDynNavOptions.harnessClass = harnessClass;
      oDynNavOptions.displayMode = pega.api.ui.constants.NEW_DOCUMENT;
      oDynNavOptions.tabName = tabName;
      oDynNavOptions.readOnly = readOnly;
      oDynNavOptions.activity = {};
      oDynNavOptions.activity.name = activityName;
      oDynNavOptions.dataTransform = {};
      oDynNavOptions.dataTransform.name = dataTransformName;
      
      if (tabName === null || typeof tabName === undefined) {
        tabName = "";
      }
     
      // launchHarness API expects an object so since the tabName comes in as a string build it as an object
      oDynNavOptions.tabName = {value: tabName, isProperty: false};
      if(activityName){
        var activityParamsArray = [];
        if (typeof activityParam !== "undefined" && activityParam !== "" ) {
          var activityParamsJson = JSON.parse(activityParam), key;

          for (key in activityParamsJson) {
            activityParamsArray.push({name: key, value: activityParamsJson[key], isProperty: false});
          }
        }
        if(stepPageRef){
          activityParamsArray.push({name: "InitializationContext", value: stepPageRef, isProperty: false});
        }
      }

      if(dataTransformName){
        var dataTransformParamArray = [];
        if (typeof dataTransformParam !== "undefined" && dataTransformParam !== "" ) {
          var dataTransformParamJson = JSON.parse(dataTransformParam), key;
          for (key in dataTransformParamJson) {
            dataTransformParamArray.push({name: key, value: dataTransformParamJson[key], isProperty: false});
          }
        }

        if(stepPageRef){
          dataTransformParamArray.push({name: "InitializationContext", value: stepPageRef, isProperty: false});
        }
      }
      
      oDynNavOptions.activity.parameters = activityParamsArray;
      oDynNavOptions.dataTransform.parameters = dataTransformParamArray;
      oDynNavOptions.event = event;
      /* Call preshowHarness if present */
      if (pega.ui.dynamicnavigation && typeof pega.ui.dynamicnavigation.preShowHarness === "function") {
        pega.ui.dynamicnavigation.preShowHarness(harnessClass, harnessName);
      }
      pega.api.ui.actions.launchHarness(oDynNavOptions);
      /* Call postshowHarness if present */
      if (pega.ui.dynamicnavigation && typeof pega.ui.dynamicnavigation.postShowHarness === "function") {
        pega.ui.dynamicnavigation.postShowHarness(harnessClass, harnessName);
      }
    }
    
        publicAPI.handleCurrentSelectedNavItem = function () {
          const sidebar = document.getElementById("sidebar-region-one");
          if (!sidebar) {
            return;
          }
          const primaryMenuAnchors = sidebar.querySelectorAll(
            "ul.menu-format-primary-navigation > .menu-item-enabled > a"
          );
          if(primaryMenuAnchors.length === 0) {
            return;
          }
          setTimeout(function () {
            for (let i = 0; i < primaryMenuAnchors.length; i++) {
              if (
                  primaryMenuAnchors[i]
                  .closest("li")
                  .classList.contains("menu-item-active")
              ) {
                  primaryMenuAnchors[i].setAttribute("aria-current", true);
                 } else {
                    primaryMenuAnchors[i].setAttribute("aria-current", false);
                 }
            }
          }, 10);
        };
    
    return publicAPI;
}());
//static-content-hash-trigger-GCC
/*!
 * GSAP 3.10.4
 * https://greensock.com
 * 
 * @license Copyright 2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).window=t.window||{})}(this,function(e){"use strict";function _inheritsLoose(t,e){t.prototype=Object.create(e.prototype),(t.prototype.constructor=t).__proto__=e}function _assertThisInitialized(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function o(t){return"string"==typeof t}function p(t){return"function"==typeof t}function q(t){return"number"==typeof t}function r(t){return void 0===t}function s(t){return"object"==typeof t}function t(t){return!1!==t}function u(){return"undefined"!=typeof window}function v(t){return p(t)||o(t)}function M(t){return(h=mt(t,ot))&&he}function N(t,e){return console.warn("Invalid property",t,"set to",e,"Missing plugin? gsap.registerPlugin()")}function O(t,e){return!e&&console.warn(t)}function P(t,e){return t&&(ot[t]=e)&&h&&(h[t]=e)||ot}function Q(){return 0}function $(t){var e,r,i=t[0];if(s(i)||p(i)||(t=[t]),!(e=(i._gsap||{}).harness)){for(r=pt.length;r--&&!pt[r].targetTest(i););e=pt[r]}for(r=t.length;r--;)t[r]&&(t[r]._gsap||(t[r]._gsap=new Lt(t[r],e)))||t.splice(r,1);return t}function _(t){return t._gsap||$(xt(t))[0]._gsap}function aa(t,e,i){return(i=t[e])&&p(i)?t[e]():r(i)&&t.getAttribute&&t.getAttribute(e)||i}function ba(t,e){return(t=t.split(",")).forEach(e)||t}function ca(t){return Math.round(1e5*t)/1e5||0}function da(t){return Math.round(1e7*t)/1e7||0}function ea(t,e){var r=e.charAt(0),i=parseFloat(e.substr(2));return t=parseFloat(t),"+"===r?t+i:"-"===r?t-i:"*"===r?t*i:t/i}function fa(t,e){for(var r=e.length,i=0;t.indexOf(e[i])<0&&++i<r;);return i<r}function ga(){var t,e,r=ht.length,i=ht.slice(0);for(lt={},t=ht.length=0;t<r;t++)(e=i[t])&&e._lazy&&(e.render(e._lazy[0],e._lazy[1],!0)._lazy=0)}function ha(t,e,r,i){ht.length&&ga(),t.render(e,r,i),ht.length&&ga()}function ia(t){var e=parseFloat(t);return(e||0===e)&&(t+"").match(at).length<2?e:o(t)?t.trim():t}function ja(t){return t}function ka(t,e){for(var r in e)r in t||(t[r]=e[r]);return t}function na(t,e){for(var r in e)"__proto__"!==r&&"constructor"!==r&&"prototype"!==r&&(t[r]=s(e[r])?na(t[r]||(t[r]={}),e[r]):e[r]);return t}function oa(t,e){var r,i={};for(r in t)r in e||(i[r]=t[r]);return i}function pa(e){var r=e.parent||I,i=e.keyframes?function _setKeyframeDefaults(i){return function(t,e){for(var r in e)r in t||"duration"===r&&i||"ease"===r||(t[r]=e[r])}}(J(e.keyframes)):ka;if(t(e.inherit))for(;r;)i(e,r.vars.defaults),r=r.parent||r._dp;return e}function ra(t,e,r,i,n){void 0===r&&(r="_first"),void 0===i&&(i="_last");var a,s=t[i];if(n)for(a=e[n];s&&s[n]>a;)s=s._prev;return s?(e._next=s._next,s._next=e):(e._next=t[r],t[r]=e),e._next?e._next._prev=e:t[i]=e,e._prev=s,e.parent=e._dp=t,e}function sa(t,e,r,i){void 0===r&&(r="_first"),void 0===i&&(i="_last");var n=e._prev,a=e._next;n?n._next=a:t[r]===e&&(t[r]=a),a?a._prev=n:t[i]===e&&(t[i]=n),e._next=e._prev=e.parent=null}function ta(t,e){!t.parent||e&&!t.parent.autoRemoveChildren||t.parent.remove(t),t._act=0}function ua(t,e){if(t&&(!e||e._end>t._dur||e._start<0))for(var r=t;r;)r._dirty=1,r=r.parent;return t}function xa(t){return t._repeat?gt(t._tTime,t=t.duration()+t._rDelay)*t:0}function za(t,e){return(t-e._start)*e._ts+(0<=e._ts?0:e._dirty?e.totalDuration():e._tDur)}function Aa(t){return t._end=da(t._start+(t._tDur/Math.abs(t._ts||t._rts||V)||0))}function Ba(t,e){var r=t._dp;return r&&r.smoothChildTiming&&t._ts&&(t._start=da(r._time-(0<t._ts?e/t._ts:((t._dirty?t.totalDuration():t._tDur)-e)/-t._ts)),Aa(t),r._dirty||ua(r,t)),t}function Ca(t,e){var r;if((e._time||e._initted&&!e._dur)&&(r=za(t.rawTime(),e),(!e._dur||bt(0,e.totalDuration(),r)-e._tTime>V)&&e.render(r,!0)),ua(t,e)._dp&&t._initted&&t._time>=t._dur&&t._ts){if(t._dur<t.duration())for(r=t;r._dp;)0<=r.rawTime()&&r.totalTime(r._tTime),r=r._dp;t._zTime=-V}}function Da(t,e,r,i){return e.parent&&ta(e),e._start=da((q(r)?r:r||t!==I?Tt(t,r,e):t._time)+e._delay),e._end=da(e._start+(e.totalDuration()/Math.abs(e.timeScale())||0)),ra(t,e,"_first","_last",t._sort?"_start":0),vt(e)||(t._recent=e),i||Ca(t,e),t}function Ea(t,e){return(ot.ScrollTrigger||N("scrollTrigger",e))&&ot.ScrollTrigger.create(e,t)}function Fa(t,e,r,i){return Xt(t,e),t._initted?!r&&t._pt&&(t._dur&&!1!==t.vars.lazy||!t._dur&&t.vars.lazy)&&f!==Dt.frame?(ht.push(t),t._lazy=[e,i],1):void 0:1}function Ka(t,e,r,i){var n=t._repeat,a=da(e)||0,s=t._tTime/t._tDur;return s&&!i&&(t._time*=a/t._dur),t._dur=a,t._tDur=n?n<0?1e10:da(a*(n+1)+t._rDelay*n):a,0<s&&!i?Ba(t,t._tTime=t._tDur*s):t.parent&&Aa(t),r||ua(t.parent,t),t}function La(t){return t instanceof Ut?ua(t):Ka(t,t._dur)}function Oa(e,r,i){var n,a,s=q(r[1]),o=(s?2:1)+(e<2?0:1),u=r[o];if(s&&(u.duration=r[1]),u.parent=i,e){for(n=u,a=i;a&&!("immediateRender"in n);)n=a.vars.defaults||{},a=t(a.vars.inherit)&&a.parent;u.immediateRender=t(n.immediateRender),e<2?u.runBackwards=1:u.startAt=r[o-1]}return new $t(r[0],u,r[1+o])}function Pa(t,e){return t||0===t?e(t):e}function Ra(t,e){return o(t)&&(e=st.exec(t))?e[1]:""}function Ua(t,e){return t&&s(t)&&"length"in t&&(!e&&!t.length||t.length-1 in t&&s(t[0]))&&!t.nodeType&&t!==i}function Ya(t){return t.sort(function(){return.5-Math.random()})}function Za(t){if(p(t))return t;var c=s(t)?t:{each:t},m=Bt(c.ease),g=c.from||0,v=parseFloat(c.base)||0,y={},e=0<g&&g<1,T=isNaN(g)||e,b=c.axis,w=g,x=g;return o(g)?w=x={center:.5,edges:.5,end:1}[g]||0:!e&&T&&(w=g[0],x=g[1]),function(t,e,r){var i,n,a,s,o,u,h,l,f,d=(r||c).length,_=y[d];if(!_){if(!(f="auto"===c.grid?0:(c.grid||[1,Y])[1])){for(h=-Y;h<(h=r[f++].getBoundingClientRect().left)&&f<d;);f--}for(_=y[d]=[],i=T?Math.min(f,d)*w-.5:g%f,n=f===Y?0:T?d*x/f-.5:g/f|0,l=Y,u=h=0;u<d;u++)a=u%f-i,s=n-(u/f|0),_[u]=o=b?Math.abs("y"===b?s:a):G(a*a+s*s),h<o&&(h=o),o<l&&(l=o);"random"===g&&Ya(_),_.max=h-l,_.min=l,_.v=d=(parseFloat(c.amount)||parseFloat(c.each)*(d<f?d-1:b?"y"===b?d/f:f:Math.max(f,d/f))||0)*("edges"===g?-1:1),_.b=d<0?v-d:v,_.u=Ra(c.amount||c.each)||0,m=m&&d<0?Ft(m):m}return d=(_[t]-_.min)/_.max||0,da(_.b+(m?m(d):d)*_.v)+_.u}}function $a(r){var i=Math.pow(10,((r+"").split(".")[1]||"").length);return function(t){var e=Math.round(parseFloat(t)/r)*r*i;return(e-e%1)/i+(q(t)?0:Ra(t))}}function _a(u,t){var h,l,e=J(u);return!e&&s(u)&&(h=e=u.radius||Y,u.values?(u=xt(u.values),(l=!q(u[0]))&&(h*=h)):u=$a(u.increment)),Pa(t,e?p(u)?function(t){return l=u(t),Math.abs(l-t)<=h?l:t}:function(t){for(var e,r,i=parseFloat(l?t.x:t),n=parseFloat(l?t.y:0),a=Y,s=0,o=u.length;o--;)(e=l?(e=u[o].x-i)*e+(r=u[o].y-n)*r:Math.abs(u[o]-i))<a&&(a=e,s=o);return s=!h||a<=h?u[s]:t,l||s===t||q(t)?s:s+Ra(t)}:$a(u))}function ab(t,e,r,i){return Pa(J(t)?!e:!0===r?!!(r=0):!i,function(){return J(t)?t[~~(Math.random()*t.length)]:(r=r||1e-5)&&(i=r<1?Math.pow(10,(r+"").length-2):1)&&Math.floor(Math.round((t-r/2+Math.random()*(e-t+.99*r))/r)*r*i)/i})}function eb(e,r,t){return Pa(t,function(t){return e[~~r(t)]})}function hb(t){for(var e,r,i,n,a=0,s="";~(e=t.indexOf("random(",a));)i=t.indexOf(")",e),n="["===t.charAt(e+7),r=t.substr(e+7,i-e-7).match(n?at:tt),s+=t.substr(a,e-a)+ab(n?r:+r[0],n?0:+r[1],+r[2]||1e-5),a=i+1;return s+t.substr(a,t.length-a)}function kb(t,e,r){var i,n,a,s=t.labels,o=Y;for(i in s)(n=s[i]-e)<0==!!r&&n&&o>(n=Math.abs(n))&&(a=i,o=n);return a}function mb(t){return ta(t),t.scrollTrigger&&t.scrollTrigger.kill(!1),t.progress()<1&&Ot(t,"onInterrupt"),t}function rb(t,e,r){return(6*(t+=t<0?1:1<t?-1:0)<1?e+(r-e)*t*6:t<.5?r:3*t<2?e+(r-e)*(2/3-t)*6:e)*Pt+.5|0}function sb(t,e,r){var i,n,a,s,o,u,h,l,f,d,_=t?q(t)?[t>>16,t>>8&Pt,t&Pt]:0:Mt.black;if(!_){if(","===t.substr(-1)&&(t=t.substr(0,t.length-1)),Mt[t])_=Mt[t];else if("#"===t.charAt(0)){if(t.length<6&&(t="#"+(i=t.charAt(1))+i+(n=t.charAt(2))+n+(a=t.charAt(3))+a+(5===t.length?t.charAt(4)+t.charAt(4):"")),9===t.length)return[(_=parseInt(t.substr(1,6),16))>>16,_>>8&Pt,_&Pt,parseInt(t.substr(7),16)/255];_=[(t=parseInt(t.substr(1),16))>>16,t>>8&Pt,t&Pt]}else if("hsl"===t.substr(0,3))if(_=d=t.match(tt),e){if(~t.indexOf("="))return _=t.match(et),r&&_.length<4&&(_[3]=1),_}else s=+_[0]%360/360,o=_[1]/100,i=2*(u=_[2]/100)-(n=u<=.5?u*(o+1):u+o-u*o),3<_.length&&(_[3]*=1),_[0]=rb(s+1/3,i,n),_[1]=rb(s,i,n),_[2]=rb(s-1/3,i,n);else _=t.match(tt)||Mt.transparent;_=_.map(Number)}return e&&!d&&(i=_[0]/Pt,n=_[1]/Pt,a=_[2]/Pt,u=((h=Math.max(i,n,a))+(l=Math.min(i,n,a)))/2,h===l?s=o=0:(f=h-l,o=.5<u?f/(2-h-l):f/(h+l),s=h===i?(n-a)/f+(n<a?6:0):h===n?(a-i)/f+2:(i-n)/f+4,s*=60),_[0]=~~(s+.5),_[1]=~~(100*o+.5),_[2]=~~(100*u+.5)),r&&_.length<4&&(_[3]=1),_}function tb(t){var r=[],i=[],n=-1;return t.split(Ct).forEach(function(t){var e=t.match(rt)||[];r.push.apply(r,e),i.push(n+=e.length+1)}),r.c=i,r}function ub(t,e,r){var i,n,a,s,o="",u=(t+o).match(Ct),h=e?"hsla(":"rgba(",l=0;if(!u)return t;if(u=u.map(function(t){return(t=sb(t,e,1))&&h+(e?t[0]+","+t[1]+"%,"+t[2]+"%,"+t[3]:t.join(","))+")"}),r&&(a=tb(t),(i=r.c).join(o)!==a.c.join(o)))for(s=(n=t.replace(Ct,"1").split(rt)).length-1;l<s;l++)o+=n[l]+(~i.indexOf(l)?u.shift()||h+"0,0,0,0)":(a.length?a:u.length?u:r).shift());if(!n)for(s=(n=t.split(Ct)).length-1;l<s;l++)o+=n[l]+u[l];return o+n[s]}function xb(t){var e,r=t.join(" ");if(Ct.lastIndex=0,Ct.test(r))return e=At.test(r),t[1]=ub(t[1],e),t[0]=ub(t[0],e,tb(t[1])),!0}function Gb(t){var e=(t+"").split("("),r=zt[e[0]];return r&&1<e.length&&r.config?r.config.apply(null,~t.indexOf("{")?[function _parseObjectInString(t){for(var e,r,i,n={},a=t.substr(1,t.length-3).split(":"),s=a[0],o=1,u=a.length;o<u;o++)r=a[o],e=o!==u-1?r.lastIndexOf(","):r.length,i=r.substr(0,e),n[s]=isNaN(i)?i.replace(Et,"").trim():+i,s=r.substr(e+1).trim();return n}(e[1])]:function _valueInParentheses(t){var e=t.indexOf("(")+1,r=t.indexOf(")"),i=t.indexOf("(",e);return t.substring(e,~i&&i<r?t.indexOf(")",r+1):r)}(t).split(",").map(ia)):zt._CE&&Rt.test(t)?zt._CE("",t):r}function Ib(t,e){for(var r,i=t._first;i;)i instanceof Ut?Ib(i,e):!i.vars.yoyoEase||i._yoyo&&i._repeat||i._yoyo===e||(i.timeline?Ib(i.timeline,e):(r=i._ease,i._ease=i._yEase,i._yEase=r,i._yoyo=e)),i=i._next}function Kb(t,e,r,i){void 0===r&&(r=function easeOut(t){return 1-e(1-t)}),void 0===i&&(i=function easeInOut(t){return t<.5?e(2*t)/2:1-e(2*(1-t))/2});var n,a={easeIn:e,easeOut:r,easeInOut:i};return ba(t,function(t){for(var e in zt[t]=ot[t]=a,zt[n=t.toLowerCase()]=r,a)zt[n+("easeIn"===e?".in":"easeOut"===e?".out":".inOut")]=zt[t+"."+e]=a[e]}),a}function Lb(e){return function(t){return t<.5?(1-e(1-2*t))/2:.5+e(2*(t-.5))/2}}function Mb(r,t,e){function em(t){return 1===t?1:i*Math.pow(2,-10*t)*Z((t-a)*n)+1}var i=1<=t?t:1,n=(e||(r?.3:.45))/(t<1?t:1),a=n/X*(Math.asin(1/i)||0),s="out"===r?em:"in"===r?function(t){return 1-em(1-t)}:Lb(em);return n=X/n,s.config=function(t,e){return Mb(r,t,e)},s}function Nb(e,r){function mm(t){return t?--t*t*((r+1)*t+r)+1:0}void 0===r&&(r=1.70158);var t="out"===e?mm:"in"===e?function(t){return 1-mm(1-t)}:Lb(mm);return t.config=function(t){return Nb(e,t)},t}var B,I,i,n,a,h,l,f,d,c,m,g,y,T,b,w,x,k,C,A,D,S,z,R,E,F,U={autoSleep:120,force3D:"auto",nullTargetWarn:1,units:{lineHeight:""}},L={duration:.5,overwrite:!1,delay:0},Y=1e8,V=1/Y,X=2*Math.PI,j=X/4,K=0,G=Math.sqrt,W=Math.cos,Z=Math.sin,H="function"==typeof ArrayBuffer&&ArrayBuffer.isView||function(){},J=Array.isArray,tt=/(?:-?\.?\d|\.)+/gi,et=/[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,rt=/[-+=.]*\d+[.e-]*\d*[a-z%]*/g,it=/[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,nt=/[+-]=-?[.\d]+/,at=/[^,'"\[\]\s]+/gi,st=/^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,ot={},ut={},ht=[],lt={},ft={},dt={},_t=30,pt=[],ct="",mt=function _merge(t,e){for(var r in e)t[r]=e[r];return t},gt=function _animationCycle(t,e){var r=Math.floor(t/=e);return t&&r===t?r-1:r},vt=function _isFromOrFromStart(t){var e=t.data;return"isFromStart"===e||"isStart"===e},yt={_start:0,endTime:Q,totalDuration:Q},Tt=function _parsePosition(t,e,r){var i,n,a,s=t.labels,u=t._recent||yt,h=t.duration()>=Y?u.endTime(!1):t._dur;return o(e)&&(isNaN(e)||e in s)?(n=e.charAt(0),a="%"===e.substr(-1),i=e.indexOf("="),"<"===n||">"===n?(0<=i&&(e=e.replace(/=/,"")),("<"===n?u._start:u.endTime(0<=u._repeat))+(parseFloat(e.substr(1))||0)*(a?(i<0?u:r).totalDuration()/100:1)):i<0?(e in s||(s[e]=h),s[e]):(n=parseFloat(e.charAt(i-1)+e.substr(i+1)),a&&r&&(n=n/100*(J(r)?r[0]:r).totalDuration()),1<i?_parsePosition(t,e.substr(0,i-1),r)+n:h+n)):null==e?h:+e},bt=function _clamp(t,e,r){return r<t?t:e<r?e:r},wt=[].slice,xt=function toArray(t,e,r){return!o(t)||r||!n&&St()?J(t)?function _flatten(t,e,r){return void 0===r&&(r=[]),t.forEach(function(t){return o(t)&&!e||Ua(t,1)?r.push.apply(r,xt(t)):r.push(t)})||r}(t,r):Ua(t)?wt.call(t,0):t?[t]:[]:wt.call((e||a).querySelectorAll(t),0)},kt=function mapRange(e,t,r,i,n){var a=t-e,s=i-r;return Pa(n,function(t){return r+((t-e)/a*s||0)})},Ot=function _callback(t,e,r){var i,n,a=t.vars,s=a[e];if(s)return i=a[e+"Params"],n=a.callbackScope||t,r&&ht.length&&ga(),i?s.apply(n,i):s.call(n)},Pt=255,Mt={aqua:[0,Pt,Pt],lime:[0,Pt,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,Pt],navy:[0,0,128],white:[Pt,Pt,Pt],olive:[128,128,0],yellow:[Pt,Pt,0],orange:[Pt,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[Pt,0,0],pink:[Pt,192,203],cyan:[0,Pt,Pt],transparent:[Pt,Pt,Pt,0]},Ct=function(){var t,e="(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";for(t in Mt)e+="|"+t+"\\b";return new RegExp(e+")","gi")}(),At=/hsl[a]?\(/,Dt=(x=Date.now,k=500,C=33,A=x(),D=A,z=S=1e3/240,T={time:0,frame:0,tick:function tick(){Vk(!0)},deltaRatio:function deltaRatio(t){return b/(1e3/(t||60))},wake:function wake(){l&&(!n&&u()&&(i=n=window,a=i.document||{},ot.gsap=he,(i.gsapVersions||(i.gsapVersions=[])).push(he.version),M(h||i.GreenSockGlobals||!i.gsap&&i||{}),y=i.requestAnimationFrame),m&&T.sleep(),g=y||function(t){return setTimeout(t,z-1e3*T.time+1|0)},c=1,Vk(2))},sleep:function sleep(){(y?i.cancelAnimationFrame:clearTimeout)(m),c=0,g=Q},lagSmoothing:function lagSmoothing(t,e){k=t||1e8,C=Math.min(e,k,0)},fps:function fps(t){S=1e3/(t||240),z=1e3*T.time+S},add:function add(n,t,e){var a=t?function(t,e,r,i){n(t,e,r,i),T.remove(a)}:n;return T.remove(n),R[e?"unshift":"push"](a),St(),a},remove:function remove(t,e){~(e=R.indexOf(t))&&R.splice(e,1)&&e<=w&&w--},_listeners:R=[]}),St=function _wake(){return!c&&Dt.wake()},zt={},Rt=/^[\d.\-M][\d.\-,\s]/,Et=/["']/g,Ft=function _invertEase(e){return function(t){return 1-e(1-t)}},Bt=function _parseEase(t,e){return t&&(p(t)?t:zt[t]||Gb(t))||e};function Vk(t){var e,r,i,n,a=x()-D,s=!0===t;if(k<a&&(A+=a-C),(0<(e=(i=(D+=a)-A)-z)||s)&&(n=++T.frame,b=i-1e3*T.time,T.time=i/=1e3,z+=e+(S<=e?4:S-e),r=1),s||(m=g(Vk)),r)for(w=0;w<R.length;w++)R[w](i,b,n,t)}function Dm(t){return t<F?E*t*t:t<.7272727272727273?E*Math.pow(t-1.5/2.75,2)+.75:t<.9090909090909092?E*(t-=2.25/2.75)*t+.9375:E*Math.pow(t-2.625/2.75,2)+.984375}ba("Linear,Quad,Cubic,Quart,Quint,Strong",function(t,e){var r=e<5?e+1:e;Kb(t+",Power"+(r-1),e?function(t){return Math.pow(t,r)}:function(t){return t},function(t){return 1-Math.pow(1-t,r)},function(t){return t<.5?Math.pow(2*t,r)/2:1-Math.pow(2*(1-t),r)/2})}),zt.Linear.easeNone=zt.none=zt.Linear.easeIn,Kb("Elastic",Mb("in"),Mb("out"),Mb()),E=7.5625,F=1/2.75,Kb("Bounce",function(t){return 1-Dm(1-t)},Dm),Kb("Expo",function(t){return t?Math.pow(2,10*(t-1)):0}),Kb("Circ",function(t){return-(G(1-t*t)-1)}),Kb("Sine",function(t){return 1===t?1:1-W(t*j)}),Kb("Back",Nb("in"),Nb("out"),Nb()),zt.SteppedEase=zt.steps=ot.SteppedEase={config:function config(t,e){void 0===t&&(t=1);var r=1/t,i=t+(e?0:1),n=e?1:0;return function(t){return((i*bt(0,.99999999,t)|0)+n)*r}}},L.ease=zt["quad.out"],ba("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",function(t){return ct+=t+","+t+"Params,"});var It,Lt=function GSCache(t,e){this.id=K++,(t._gsap=this).target=t,this.harness=e,this.get=e?e.get:aa,this.set=e?e.getSetter:Ht},Nt=((It=Animation.prototype).delay=function delay(t){return t||0===t?(this.parent&&this.parent.smoothChildTiming&&this.startTime(this._start+t-this._delay),this._delay=t,this):this._delay},It.duration=function duration(t){return arguments.length?this.totalDuration(0<this._repeat?t+(t+this._rDelay)*this._repeat:t):this.totalDuration()&&this._dur},It.totalDuration=function totalDuration(t){return arguments.length?(this._dirty=0,Ka(this,this._repeat<0?t:(t-this._repeat*this._rDelay)/(this._repeat+1))):this._tDur},It.totalTime=function totalTime(t,e){if(St(),!arguments.length)return this._tTime;var r=this._dp;if(r&&r.smoothChildTiming&&this._ts){for(Ba(this,t),!r._dp||r.parent||Ca(r,this);r&&r.parent;)r.parent._time!==r._start+(0<=r._ts?r._tTime/r._ts:(r.totalDuration()-r._tTime)/-r._ts)&&r.totalTime(r._tTime,!0),r=r.parent;!this.parent&&this._dp.autoRemoveChildren&&(0<this._ts&&t<this._tDur||this._ts<0&&0<t||!this._tDur&&!t)&&Da(this._dp,this,this._start-this._delay)}return(this._tTime!==t||!this._dur&&!e||this._initted&&Math.abs(this._zTime)===V||!t&&!this._initted&&(this.add||this._ptLookup))&&(this._ts||(this._pTime=t),ha(this,t,e)),this},It.time=function time(t,e){return arguments.length?this.totalTime(Math.min(this.totalDuration(),t+xa(this))%(this._dur+this._rDelay)||(t?this._dur:0),e):this._time},It.totalProgress=function totalProgress(t,e){return arguments.length?this.totalTime(this.totalDuration()*t,e):this.totalDuration()?Math.min(1,this._tTime/this._tDur):this.ratio},It.progress=function progress(t,e){return arguments.length?this.totalTime(this.duration()*(!this._yoyo||1&this.iteration()?t:1-t)+xa(this),e):this.duration()?Math.min(1,this._time/this._dur):this.ratio},It.iteration=function iteration(t,e){var r=this.duration()+this._rDelay;return arguments.length?this.totalTime(this._time+(t-1)*r,e):this._repeat?gt(this._tTime,r)+1:1},It.timeScale=function timeScale(t){if(!arguments.length)return this._rts===-V?0:this._rts;if(this._rts===t)return this;var e=this.parent&&this._ts?za(this.parent._time,this):this._tTime;return this._rts=+t||0,this._ts=this._ps||t===-V?0:this._rts,this.totalTime(bt(-this._delay,this._tDur,e),!0),Aa(this),function _recacheAncestors(t){for(var e=t.parent;e&&e.parent;)e._dirty=1,e.totalDuration(),e=e.parent;return t}(this)},It.paused=function paused(t){return arguments.length?(this._ps!==t&&((this._ps=t)?(this._pTime=this._tTime||Math.max(-this._delay,this.rawTime()),this._ts=this._act=0):(St(),this._ts=this._rts,this.totalTime(this.parent&&!this.parent.smoothChildTiming?this.rawTime():this._tTime||this._pTime,1===this.progress()&&Math.abs(this._zTime)!==V&&(this._tTime-=V)))),this):this._ps},It.startTime=function startTime(t){if(arguments.length){this._start=t;var e=this.parent||this._dp;return!e||!e._sort&&this.parent||Da(e,this,t-this._delay),this}return this._start},It.endTime=function endTime(e){return this._start+(t(e)?this.totalDuration():this.duration())/Math.abs(this._ts||1)},It.rawTime=function rawTime(t){var e=this.parent||this._dp;return e?t&&(!this._ts||this._repeat&&this._time&&this.totalProgress()<1)?this._tTime%(this._dur+this._rDelay):this._ts?za(e.rawTime(t),this):this._tTime:this._tTime},It.globalTime=function globalTime(t){for(var e=this,r=arguments.length?t:e.rawTime();e;)r=e._start+r/(e._ts||1),e=e._dp;return r},It.repeat=function repeat(t){return arguments.length?(this._repeat=t===1/0?-2:t,La(this)):-2===this._repeat?1/0:this._repeat},It.repeatDelay=function repeatDelay(t){if(arguments.length){var e=this._time;return this._rDelay=t,La(this),e?this.time(e):this}return this._rDelay},It.yoyo=function yoyo(t){return arguments.length?(this._yoyo=t,this):this._yoyo},It.seek=function seek(e,r){return this.totalTime(Tt(this,e),t(r))},It.restart=function restart(e,r){return this.play().totalTime(e?-this._delay:0,t(r))},It.play=function play(t,e){return null!=t&&this.seek(t,e),this.reversed(!1).paused(!1)},It.reverse=function reverse(t,e){return null!=t&&this.seek(t||this.totalDuration(),e),this.reversed(!0).paused(!1)},It.pause=function pause(t,e){return null!=t&&this.seek(t,e),this.paused(!0)},It.resume=function resume(){return this.paused(!1)},It.reversed=function reversed(t){return arguments.length?(!!t!==this.reversed()&&this.timeScale(-this._rts||(t?-V:0)),this):this._rts<0},It.invalidate=function invalidate(){return this._initted=this._act=0,this._zTime=-V,this},It.isActive=function isActive(){var t,e=this.parent||this._dp,r=this._start;return!(e&&!(this._ts&&this._initted&&e.isActive()&&(t=e.rawTime(!0))>=r&&t<this.endTime(!0)-V))},It.eventCallback=function eventCallback(t,e,r){var i=this.vars;return 1<arguments.length?(e?(i[t]=e,r&&(i[t+"Params"]=r),"onUpdate"===t&&(this._onUpdate=e)):delete i[t],this):i[t]},It.then=function then(t){var i=this;return new Promise(function(e){function Un(){var t=i.then;i.then=null,p(r)&&(r=r(i))&&(r.then||r===i)&&(i.then=t),e(r),i.then=t}var r=p(t)?t:ja;i._initted&&1===i.totalProgress()&&0<=i._ts||!i._tTime&&i._ts<0?Un():i._prom=Un})},It.kill=function kill(){mb(this)},Animation);function Animation(t){this.vars=t,this._delay=+t.delay||0,(this._repeat=t.repeat===1/0?-2:t.repeat||0)&&(this._rDelay=t.repeatDelay||0,this._yoyo=!!t.yoyo||!!t.yoyoEase),this._ts=1,Ka(this,+t.duration,1,1),this.data=t.data,c||Dt.wake()}ka(Nt.prototype,{_time:0,_start:0,_end:0,_tTime:0,_tDur:0,_dirty:0,_repeat:0,_yoyo:!1,parent:null,_initted:!1,_rDelay:0,_ts:1,_dp:0,ratio:0,_zTime:-V,_prom:0,_ps:!1,_rts:1});var Ut=function(n){function Timeline(e,r){var i;return void 0===e&&(e={}),(i=n.call(this,e)||this).labels={},i.smoothChildTiming=!!e.smoothChildTiming,i.autoRemoveChildren=!!e.autoRemoveChildren,i._sort=t(e.sortChildren),I&&Da(e.parent||I,_assertThisInitialized(i),r),e.reversed&&i.reverse(),e.paused&&i.paused(!0),e.scrollTrigger&&Ea(_assertThisInitialized(i),e.scrollTrigger),i}_inheritsLoose(Timeline,n);var e=Timeline.prototype;return e.to=function to(t,e,r){return Oa(0,arguments,this),this},e.from=function from(t,e,r){return Oa(1,arguments,this),this},e.fromTo=function fromTo(t,e,r,i){return Oa(2,arguments,this),this},e.set=function set(t,e,r){return e.duration=0,e.parent=this,pa(e).repeatDelay||(e.repeat=0),e.immediateRender=!!e.immediateRender,new $t(t,e,Tt(this,r),1),this},e.call=function call(t,e,r){return Da(this,$t.delayedCall(0,t,e),r)},e.staggerTo=function staggerTo(t,e,r,i,n,a,s){return r.duration=e,r.stagger=r.stagger||i,r.onComplete=a,r.onCompleteParams=s,r.parent=this,new $t(t,r,Tt(this,n)),this},e.staggerFrom=function staggerFrom(e,r,i,n,a,s,o){return i.runBackwards=1,pa(i).immediateRender=t(i.immediateRender),this.staggerTo(e,r,i,n,a,s,o)},e.staggerFromTo=function staggerFromTo(e,r,i,n,a,s,o,u){return n.startAt=i,pa(n).immediateRender=t(n.immediateRender),this.staggerTo(e,r,n,a,s,o,u)},e.render=function render(t,e,r){var i,n,a,s,o,u,h,l,f,d,_,p,c=this._time,m=this._dirty?this.totalDuration():this._tDur,g=this._dur,v=t<=0?0:da(t),y=this._zTime<0!=t<0&&(this._initted||!g);if(this!==I&&m<v&&0<=t&&(v=m),v!==this._tTime||r||y){if(c!==this._time&&g&&(v+=this._time-c,t+=this._time-c),i=v,f=this._start,u=!(l=this._ts),y&&(g||(c=this._zTime),!t&&e||(this._zTime=t)),this._repeat){if(_=this._yoyo,o=g+this._rDelay,this._repeat<-1&&t<0)return this.totalTime(100*o+t,e,r);if(i=da(v%o),v===m?(s=this._repeat,i=g):((s=~~(v/o))&&s===v/o&&(i=g,s--),g<i&&(i=g)),d=gt(this._tTime,o),!c&&this._tTime&&d!==s&&(d=s),_&&1&s&&(i=g-i,p=1),s!==d&&!this._lock){var T=_&&1&d,b=T===(_&&1&s);if(s<d&&(T=!T),c=T?0:g,this._lock=1,this.render(c||(p?0:da(s*o)),e,!g)._lock=0,this._tTime=v,!e&&this.parent&&Ot(this,"onRepeat"),this.vars.repeatRefresh&&!p&&(this.invalidate()._lock=1),c&&c!==this._time||u!=!this._ts||this.vars.onRepeat&&!this.parent&&!this._act)return this;if(g=this._dur,m=this._tDur,b&&(this._lock=2,c=T?g:-1e-4,this.render(c,!0),this.vars.repeatRefresh&&!p&&this.invalidate()),this._lock=0,!this._ts&&!u)return this;Ib(this,p)}}if(this._hasPause&&!this._forcing&&this._lock<2&&(h=function _findNextPauseTween(t,e,r){var i;if(e<r)for(i=t._first;i&&i._start<=r;){if("isPause"===i.data&&i._start>e)return i;i=i._next}else for(i=t._last;i&&i._start>=r;){if("isPause"===i.data&&i._start<e)return i;i=i._prev}}(this,da(c),da(i)))&&(v-=i-(i=h._start)),this._tTime=v,this._time=i,this._act=!l,this._initted||(this._onUpdate=this.vars.onUpdate,this._initted=1,this._zTime=t,c=0),!c&&i&&!e&&(Ot(this,"onStart"),this._tTime!==v))return this;if(c<=i&&0<=t)for(n=this._first;n;){if(a=n._next,(n._act||i>=n._start)&&n._ts&&h!==n){if(n.parent!==this)return this.render(t,e,r);if(n.render(0<n._ts?(i-n._start)*n._ts:(n._dirty?n.totalDuration():n._tDur)+(i-n._start)*n._ts,e,r),i!==this._time||!this._ts&&!u){h=0,a&&(v+=this._zTime=-V);break}}n=a}else{n=this._last;for(var w=t<0?t:i;n;){if(a=n._prev,(n._act||w<=n._end)&&n._ts&&h!==n){if(n.parent!==this)return this.render(t,e,r);if(n.render(0<n._ts?(w-n._start)*n._ts:(n._dirty?n.totalDuration():n._tDur)+(w-n._start)*n._ts,e,r),i!==this._time||!this._ts&&!u){h=0,a&&(v+=this._zTime=w?-V:V);break}}n=a}}if(h&&!e&&(this.pause(),h.render(c<=i?0:-V)._zTime=c<=i?1:-1,this._ts))return this._start=f,Aa(this),this.render(t,e,r);this._onUpdate&&!e&&Ot(this,"onUpdate",!0),(v===m&&this._tTime>=this.totalDuration()||!v&&c)&&(f!==this._start&&Math.abs(l)===Math.abs(this._ts)||this._lock||(!t&&g||!(v===m&&0<this._ts||!v&&this._ts<0)||ta(this,1),e||t<0&&!c||!v&&!c&&m||(Ot(this,v===m&&0<=t?"onComplete":"onReverseComplete",!0),!this._prom||v<m&&0<this.timeScale()||this._prom())))}return this},e.add=function add(t,e){var r=this;if(q(e)||(e=Tt(this,e,t)),!(t instanceof Nt)){if(J(t))return t.forEach(function(t){return r.add(t,e)}),this;if(o(t))return this.addLabel(t,e);if(!p(t))return this;t=$t.delayedCall(0,t)}return this!==t?Da(this,t,e):this},e.getChildren=function getChildren(t,e,r,i){void 0===t&&(t=!0),void 0===e&&(e=!0),void 0===r&&(r=!0),void 0===i&&(i=-Y);for(var n=[],a=this._first;a;)a._start>=i&&(a instanceof $t?e&&n.push(a):(r&&n.push(a),t&&n.push.apply(n,a.getChildren(!0,e,r)))),a=a._next;return n},e.getById=function getById(t){for(var e=this.getChildren(1,1,1),r=e.length;r--;)if(e[r].vars.id===t)return e[r]},e.remove=function remove(t){return o(t)?this.removeLabel(t):p(t)?this.killTweensOf(t):(sa(this,t),t===this._recent&&(this._recent=this._last),ua(this))},e.totalTime=function totalTime(t,e){return arguments.length?(this._forcing=1,!this._dp&&this._ts&&(this._start=da(Dt.time-(0<this._ts?t/this._ts:(this.totalDuration()-t)/-this._ts))),n.prototype.totalTime.call(this,t,e),this._forcing=0,this):this._tTime},e.addLabel=function addLabel(t,e){return this.labels[t]=Tt(this,e),this},e.removeLabel=function removeLabel(t){return delete this.labels[t],this},e.addPause=function addPause(t,e,r){var i=$t.delayedCall(0,e||Q,r);return i.data="isPause",this._hasPause=1,Da(this,i,Tt(this,t))},e.removePause=function removePause(t){var e=this._first;for(t=Tt(this,t);e;)e._start===t&&"isPause"===e.data&&ta(e),e=e._next},e.killTweensOf=function killTweensOf(t,e,r){for(var i=this.getTweensOf(t,r),n=i.length;n--;)Yt!==i[n]&&i[n].kill(t,e);return this},e.getTweensOf=function getTweensOf(t,e){for(var r,i=[],n=xt(t),a=this._first,s=q(e);a;)a instanceof $t?fa(a._targets,n)&&(s?(!Yt||a._initted&&a._ts)&&a.globalTime(0)<=e&&a.globalTime(a.totalDuration())>e:!e||a.isActive())&&i.push(a):(r=a.getTweensOf(n,e)).length&&i.push.apply(i,r),a=a._next;return i},e.tweenTo=function tweenTo(t,e){e=e||{};var r,i=this,n=Tt(i,t),a=e.startAt,s=e.onStart,o=e.onStartParams,u=e.immediateRender,h=$t.to(i,ka({ease:e.ease||"none",lazy:!1,immediateRender:!1,time:n,overwrite:"auto",duration:e.duration||Math.abs((n-(a&&"time"in a?a.time:i._time))/i.timeScale())||V,onStart:function onStart(){if(i.pause(),!r){var t=e.duration||Math.abs((n-(a&&"time"in a?a.time:i._time))/i.timeScale());h._dur!==t&&Ka(h,t,0,1).render(h._time,!0,!0),r=1}s&&s.apply(h,o||[])}},e));return u?h.render(0):h},e.tweenFromTo=function tweenFromTo(t,e,r){return this.tweenTo(e,ka({startAt:{time:Tt(this,t)}},r))},e.recent=function recent(){return this._recent},e.nextLabel=function nextLabel(t){return void 0===t&&(t=this._time),kb(this,Tt(this,t))},e.previousLabel=function previousLabel(t){return void 0===t&&(t=this._time),kb(this,Tt(this,t),1)},e.currentLabel=function currentLabel(t){return arguments.length?this.seek(t,!0):this.previousLabel(this._time+V)},e.shiftChildren=function shiftChildren(t,e,r){void 0===r&&(r=0);for(var i,n=this._first,a=this.labels;n;)n._start>=r&&(n._start+=t,n._end+=t),n=n._next;if(e)for(i in a)a[i]>=r&&(a[i]+=t);return ua(this)},e.invalidate=function invalidate(){var t=this._first;for(this._lock=0;t;)t.invalidate(),t=t._next;return n.prototype.invalidate.call(this)},e.clear=function clear(t){void 0===t&&(t=!0);for(var e,r=this._first;r;)e=r._next,this.remove(r),r=e;return this._dp&&(this._time=this._tTime=this._pTime=0),t&&(this.labels={}),ua(this)},e.totalDuration=function totalDuration(t){var e,r,i,n=0,a=this,s=a._last,o=Y;if(arguments.length)return a.timeScale((a._repeat<0?a.duration():a.totalDuration())/(a.reversed()?-t:t));if(a._dirty){for(i=a.parent;s;)e=s._prev,s._dirty&&s.totalDuration(),o<(r=s._start)&&a._sort&&s._ts&&!a._lock?(a._lock=1,Da(a,s,r-s._delay,1)._lock=0):o=r,r<0&&s._ts&&(n-=r,(!i&&!a._dp||i&&i.smoothChildTiming)&&(a._start+=r/a._ts,a._time-=r,a._tTime-=r),a.shiftChildren(-r,!1,-Infinity),o=0),s._end>n&&s._ts&&(n=s._end),s=e;Ka(a,a===I&&a._time>n?a._time:n,1,1),a._dirty=0}return a._tDur},Timeline.updateRoot=function updateRoot(t){if(I._ts&&(ha(I,za(t,I)),f=Dt.frame),Dt.frame>=_t){_t+=U.autoSleep||120;var e=I._first;if((!e||!e._ts)&&U.autoSleep&&Dt._listeners.length<2){for(;e&&!e._ts;)e=e._next;e||Dt.sleep()}}},Timeline}(Nt);ka(Ut.prototype,{_lock:0,_hasPause:0,_forcing:0});function Ub(t,e,r,i,n,a){var u,h,l,f;if(ft[t]&&!1!==(u=new ft[t]).init(n,u.rawVars?e[t]:function _processVars(t,e,r,i,n){if(p(t)&&(t=Qt(t,n,e,r,i)),!s(t)||t.style&&t.nodeType||J(t)||H(t))return o(t)?Qt(t,n,e,r,i):t;var a,u={};for(a in t)u[a]=Qt(t[a],n,e,r,i);return u}(e[t],i,n,a,r),r,i,a)&&(r._pt=h=new oe(r._pt,n,t,0,1,u.render,u,0,u.priority),r!==d))for(l=r._ptLookup[r._targets.indexOf(n)],f=u._props.length;f--;)l[u._props[f]]=h;return u}function $b(t,r,e,i){var n,a,s=r.ease||i||"power1.inOut";if(J(r))a=e[t]||(e[t]=[]),r.forEach(function(t,e){return a.push({t:e/(r.length-1)*100,v:t,e:s})});else for(n in r)a=e[n]||(e[n]=[]),"ease"===n||a.push({t:parseFloat(t),v:r[n],e:s})}var Yt,qt,Vt=function _addPropTween(t,e,r,i,n,a,s,u,h){p(i)&&(i=i(n||0,t,a));var l,f=t[e],d="get"!==r?r:p(f)?h?t[e.indexOf("set")||!p(t["get"+e.substr(3)])?e:"get"+e.substr(3)](h):t[e]():f,_=p(f)?h?Zt:Wt:Gt;if(o(i)&&(~i.indexOf("random(")&&(i=hb(i)),"="===i.charAt(1)&&(!(l=ea(d,i)+(Ra(d)||0))&&0!==l||(i=l))),d!==i||qt)return isNaN(d*i)||""===i?(f||e in t||N(e,i),function _addComplexStringPropTween(t,e,r,i,n,a,s){var o,u,h,l,f,d,_,p,c=new oe(this._pt,t,e,0,1,ee,null,n),m=0,g=0;for(c.b=r,c.e=i,r+="",(_=~(i+="").indexOf("random("))&&(i=hb(i)),a&&(a(p=[r,i],t,e),r=p[0],i=p[1]),u=r.match(it)||[];o=it.exec(i);)l=o[0],f=i.substring(m,o.index),h?h=(h+1)%5:"rgba("===f.substr(-5)&&(h=1),l!==u[g++]&&(d=parseFloat(u[g-1])||0,c._pt={_next:c._pt,p:f||1===g?f:",",s:d,c:"="===l.charAt(1)?ea(d,l)-d:parseFloat(l)-d,m:h&&h<4?Math.round:0},m=it.lastIndex);return c.c=m<i.length?i.substring(m,i.length):"",c.fp=s,(nt.test(i)||_)&&(c.e=0),this._pt=c}.call(this,t,e,d,i,_,u||U.stringFilter,h)):(l=new oe(this._pt,t,e,+d||0,i-(d||0),"boolean"==typeof f?te:Jt,0,_),h&&(l.fp=h),s&&l.modifier(s,this,t),this._pt=l)},Xt=function _initTween(e,r){var i,n,a,s,o,u,h,l,f,d,p,c,m,g=e.vars,v=g.ease,y=g.startAt,T=g.immediateRender,b=g.lazy,w=g.onUpdate,x=g.onUpdateParams,k=g.callbackScope,O=g.runBackwards,P=g.yoyoEase,M=g.keyframes,C=g.autoRevert,A=e._dur,D=e._startAt,S=e._targets,z=e.parent,R=z&&"nested"===z.data?z.parent._targets:S,E="auto"===e._overwrite&&!B,F=e.timeline;if(!F||M&&v||(v="none"),e._ease=Bt(v,L.ease),e._yEase=P?Ft(Bt(!0===P?v:P,L.ease)):0,P&&e._yoyo&&!e._repeat&&(P=e._yEase,e._yEase=e._ease,e._ease=P),e._from=!F&&!!g.runBackwards,!F||M&&!g.stagger){if(c=(l=S[0]?_(S[0]).harness:0)&&g[l.prop],i=oa(g,ut),D&&(ta(D.render(-1,!0)),D._lazy=0),y)if(ta(e._startAt=$t.set(S,ka({data:"isStart",overwrite:!1,parent:z,immediateRender:!0,lazy:t(b),startAt:null,delay:0,onUpdate:w,onUpdateParams:x,callbackScope:k,stagger:0},y))),r<0&&!T&&!C&&e._startAt.render(-1,!0),T){if(0<r&&!C&&(e._startAt=0),A&&r<=0)return void(r&&(e._zTime=r))}else!1===C&&(e._startAt=0);else if(O&&A)if(D)C||(e._startAt=0);else if(r&&(T=!1),a=ka({overwrite:!1,data:"isFromStart",lazy:T&&t(b),immediateRender:T,stagger:0,parent:z},i),c&&(a[l.prop]=c),ta(e._startAt=$t.set(S,a)),r<0&&e._startAt.render(-1,!0),e._zTime=r,T){if(!r)return}else _initTween(e._startAt,V);for(e._pt=e._ptCache=0,b=A&&t(b)||b&&!A,n=0;n<S.length;n++){if(h=(o=S[n])._gsap||$(S)[n]._gsap,e._ptLookup[n]=d={},lt[h.id]&&ht.length&&ga(),p=R===S?n:R.indexOf(o),l&&!1!==(f=new l).init(o,c||i,e,p,R)&&(e._pt=s=new oe(e._pt,o,f.name,0,1,f.render,f,0,f.priority),f._props.forEach(function(t){d[t]=s}),f.priority&&(u=1)),!l||c)for(a in i)ft[a]&&(f=Ub(a,i,e,p,o,R))?f.priority&&(u=1):d[a]=s=Vt.call(e,o,a,"get",i[a],p,R,0,g.stringFilter);e._op&&e._op[n]&&e.kill(o,e._op[n]),E&&e._pt&&(Yt=e,I.killTweensOf(o,d,e.globalTime(r)),m=!e.parent,Yt=0),e._pt&&b&&(lt[h.id]=1)}u&&se(e),e._onInit&&e._onInit(e)}e._onUpdate=w,e._initted=(!e._op||e._pt)&&!m,M&&r<=0&&F.render(Y,!0,!0)},Qt=function _parseFuncOrString(t,e,r,i,n){return p(t)?t.call(e,r,i,n):o(t)&&~t.indexOf("random(")?hb(t):t},jt=ct+"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",Kt={};ba(jt+",id,stagger,delay,duration,paused,scrollTrigger",function(t){return Kt[t]=1});var $t=function(R){function Tween(e,r,i,n){var a;"number"==typeof r&&(i.duration=r,r=i,i=null);var o,u,h,l,f,d,_,p,c=(a=R.call(this,n?r:pa(r))||this).vars,m=c.duration,g=c.delay,y=c.immediateRender,T=c.stagger,b=c.overwrite,w=c.keyframes,x=c.defaults,k=c.scrollTrigger,P=c.yoyoEase,M=r.parent||I,C=(J(e)||H(e)?q(e[0]):"length"in r)?[e]:xt(e);if(a._targets=C.length?$(C):O("GSAP target "+e+" not found. https://greensock.com",!U.nullTargetWarn)||[],a._ptLookup=[],a._overwrite=b,w||T||v(m)||v(g)){if(r=a.vars,(o=a.timeline=new Ut({data:"nested",defaults:x||{}})).kill(),o.parent=o._dp=_assertThisInitialized(a),o._start=0,T||v(m)||v(g)){if(l=C.length,_=T&&Za(T),s(T))for(f in T)~jt.indexOf(f)&&((p=p||{})[f]=T[f]);for(u=0;u<l;u++)(h=oa(r,Kt)).stagger=0,P&&(h.yoyoEase=P),p&&mt(h,p),d=C[u],h.duration=+Qt(m,_assertThisInitialized(a),u,d,C),h.delay=(+Qt(g,_assertThisInitialized(a),u,d,C)||0)-a._delay,!T&&1===l&&h.delay&&(a._delay=g=h.delay,a._start+=g,h.delay=0),o.to(d,h,_?_(u,d,C):0),o._ease=zt.none;o.duration()?m=g=0:a.timeline=0}else if(w){pa(ka(o.vars.defaults,{ease:"none"})),o._ease=Bt(w.ease||r.ease||"none");var A,D,S,z=0;if(J(w))w.forEach(function(t){return o.to(C,t,">")});else{for(f in h={},w)"ease"===f||"easeEach"===f||$b(f,w[f],h,w.easeEach);for(f in h)for(A=h[f].sort(function(t,e){return t.t-e.t}),u=z=0;u<A.length;u++)(S={ease:(D=A[u]).e,duration:(D.t-(u?A[u-1].t:0))/100*m})[f]=D.v,o.to(C,S,z),z+=S.duration;o.duration()<m&&o.to({},{duration:m-o.duration()})}}m||a.duration(m=o.duration())}else a.timeline=0;return!0!==b||B||(Yt=_assertThisInitialized(a),I.killTweensOf(C),Yt=0),Da(M,_assertThisInitialized(a),i),r.reversed&&a.reverse(),r.paused&&a.paused(!0),(y||!m&&!w&&a._start===da(M._time)&&t(y)&&function _hasNoPausedAncestors(t){return!t||t._ts&&_hasNoPausedAncestors(t.parent)}(_assertThisInitialized(a))&&"nested"!==M.data)&&(a._tTime=-V,a.render(Math.max(0,-g))),k&&Ea(_assertThisInitialized(a),k),a}_inheritsLoose(Tween,R);var e=Tween.prototype;return e.render=function render(t,e,r){var i,n,a,s,o,u,h,l,f,d=this._time,_=this._tDur,p=this._dur,c=_-V<t&&0<=t?_:t<V?0:t;if(p){if(c!==this._tTime||!t||r||!this._initted&&this._tTime||this._startAt&&this._zTime<0!=t<0){if(i=c,l=this.timeline,this._repeat){if(s=p+this._rDelay,this._repeat<-1&&t<0)return this.totalTime(100*s+t,e,r);if(i=da(c%s),c===_?(a=this._repeat,i=p):((a=~~(c/s))&&a===c/s&&(i=p,a--),p<i&&(i=p)),(u=this._yoyo&&1&a)&&(f=this._yEase,i=p-i),o=gt(this._tTime,s),i===d&&!r&&this._initted)return this._tTime=c,this;a!==o&&(l&&this._yEase&&Ib(l,u),!this.vars.repeatRefresh||u||this._lock||(this._lock=r=1,this.render(da(s*a),!0).invalidate()._lock=0))}if(!this._initted){if(Fa(this,t<0?t:i,r,e))return this._tTime=0,this;if(d!==this._time)return this;if(p!==this._dur)return this.render(t,e,r)}if(this._tTime=c,this._time=i,!this._act&&this._ts&&(this._act=1,this._lazy=0),this.ratio=h=(f||this._ease)(i/p),this._from&&(this.ratio=h=1-h),i&&!d&&!e&&(Ot(this,"onStart"),this._tTime!==c))return this;for(n=this._pt;n;)n.r(h,n.d),n=n._next;l&&l.render(t<0?t:!i&&u?-V:l._dur*l._ease(i/this._dur),e,r)||this._startAt&&(this._zTime=t),this._onUpdate&&!e&&(t<0&&this._startAt&&this._startAt.render(t,!0,r),Ot(this,"onUpdate")),this._repeat&&a!==o&&this.vars.onRepeat&&!e&&this.parent&&Ot(this,"onRepeat"),c!==this._tDur&&c||this._tTime!==c||(t<0&&this._startAt&&!this._onUpdate&&this._startAt.render(t,!0,!0),!t&&p||!(c===this._tDur&&0<this._ts||!c&&this._ts<0)||ta(this,1),e||t<0&&!d||!c&&!d||(Ot(this,c===_?"onComplete":"onReverseComplete",!0),!this._prom||c<_&&0<this.timeScale()||this._prom()))}}else!function _renderZeroDurationTween(t,e,r,i){var n,a,s,o=t.ratio,u=e<0||!e&&(!t._start&&function _parentPlayheadIsBeforeStart(t){var e=t.parent;return e&&e._ts&&e._initted&&!e._lock&&(e.rawTime()<0||_parentPlayheadIsBeforeStart(e))}(t)&&(t._initted||!vt(t))||(t._ts<0||t._dp._ts<0)&&!vt(t))?0:1,h=t._rDelay,l=0;if(h&&t._repeat&&(l=bt(0,t._tDur,e),a=gt(l,h),t._yoyo&&1&a&&(u=1-u),a!==gt(t._tTime,h)&&(o=1-u,t.vars.repeatRefresh&&t._initted&&t.invalidate())),u!==o||i||t._zTime===V||!e&&t._zTime){if(!t._initted&&Fa(t,e,i,r))return;for(s=t._zTime,t._zTime=e||(r?V:0),r=r||e&&!s,t.ratio=u,t._from&&(u=1-u),t._time=0,t._tTime=l,n=t._pt;n;)n.r(u,n.d),n=n._next;t._startAt&&e<0&&t._startAt.render(e,!0,!0),t._onUpdate&&!r&&Ot(t,"onUpdate"),l&&t._repeat&&!r&&t.parent&&Ot(t,"onRepeat"),(e>=t._tDur||e<0)&&t.ratio===u&&(u&&ta(t,1),r||(Ot(t,u?"onComplete":"onReverseComplete",!0),t._prom&&t._prom()))}else t._zTime||(t._zTime=e)}(this,t,e,r);return this},e.targets=function targets(){return this._targets},e.invalidate=function invalidate(){return this._pt=this._op=this._startAt=this._onUpdate=this._lazy=this.ratio=0,this._ptLookup=[],this.timeline&&this.timeline.invalidate(),R.prototype.invalidate.call(this)},e.resetTo=function resetTo(t,e,r,i){c||Dt.wake(),this._ts||this.play();var n,a=Math.min(this._dur,(this._dp._time-this._start)*this._ts);return this._initted||Xt(this,a),n=this._ease(a/this._dur),function _updatePropTweens(t,e,r,i,n,a,s){var o,u,h,l=(t._pt&&t._ptCache||(t._ptCache={}))[e];if(!l)for(l=t._ptCache[e]=[],u=t._ptLookup,h=t._targets.length;h--;){if((o=u[h][e])&&o.d&&o.d._pt)for(o=o.d._pt;o&&o.p!==e;)o=o._next;if(!o)return qt=1,t.vars[e]="+=0",Xt(t,s),qt=0,1;l.push(o)}for(h=l.length;h--;)(o=l[h]).s=!i&&0!==i||n?o.s+(i||0)+a*o.c:i,o.c=r-o.s,o.e&&(o.e=ca(r)+Ra(o.e)),o.b&&(o.b=o.s+Ra(o.b))}(this,t,e,r,i,n,a)?this.resetTo(t,e,r,i):(Ba(this,0),this.parent||ra(this._dp,this,"_first","_last",this._dp._sort?"_start":0),this.render(0))},e.kill=function kill(t,e){if(void 0===e&&(e="all"),!(t||e&&"all"!==e))return this._lazy=this._pt=0,this.parent?mb(this):this;if(this.timeline){var r=this.timeline.totalDuration();return this.timeline.killTweensOf(t,e,Yt&&!0!==Yt.vars.overwrite)._first||mb(this),this.parent&&r!==this.timeline.totalDuration()&&Ka(this,this._dur*this.timeline._tDur/r,0,1),this}var i,n,a,s,u,h,l,f=this._targets,d=t?xt(t):f,p=this._ptLookup,c=this._pt;if((!e||"all"===e)&&function _arraysMatch(t,e){for(var r=t.length,i=r===e.length;i&&r--&&t[r]===e[r];);return r<0}(f,d))return"all"===e&&(this._pt=0),mb(this);for(i=this._op=this._op||[],"all"!==e&&(o(e)&&(u={},ba(e,function(t){return u[t]=1}),e=u),e=function _addAliasesToVars(t,e){var r,i,n,a,s=t[0]?_(t[0]).harness:0,o=s&&s.aliases;if(!o)return e;for(i in r=mt({},e),o)if(i in r)for(n=(a=o[i].split(",")).length;n--;)r[a[n]]=r[i];return r}(f,e)),l=f.length;l--;)if(~d.indexOf(f[l]))for(u in n=p[l],"all"===e?(i[l]=e,s=n,a={}):(a=i[l]=i[l]||{},s=e),s)(h=n&&n[u])&&("kill"in h.d&&!0!==h.d.kill(u)||sa(this,h,"_pt"),delete n[u]),"all"!==a&&(a[u]=1);return this._initted&&!this._pt&&c&&mb(this),this},Tween.to=function to(t,e,r){return new Tween(t,e,r)},Tween.from=function from(t,e){return Oa(1,arguments)},Tween.delayedCall=function delayedCall(t,e,r,i){return new Tween(e,0,{immediateRender:!1,lazy:!1,overwrite:!1,delay:t,onComplete:e,onReverseComplete:e,onCompleteParams:r,onReverseCompleteParams:r,callbackScope:i})},Tween.fromTo=function fromTo(t,e,r){return Oa(2,arguments)},Tween.set=function set(t,e){return e.duration=0,e.repeatDelay||(e.repeat=0),new Tween(t,e)},Tween.killTweensOf=function killTweensOf(t,e,r){return I.killTweensOf(t,e,r)},Tween}(Nt);ka($t.prototype,{_targets:[],_lazy:0,_startAt:0,_op:0,_onInit:0}),ba("staggerTo,staggerFrom,staggerFromTo",function(r){$t[r]=function(){var t=new Ut,e=wt.call(arguments,0);return e.splice("staggerFromTo"===r?5:4,0,0),t[r].apply(t,e)}});function gc(t,e,r){return t.setAttribute(e,r)}function oc(t,e,r,i){i.mSet(t,e,i.m.call(i.tween,r,i.mt),i)}var Gt=function _setterPlain(t,e,r){return t[e]=r},Wt=function _setterFunc(t,e,r){return t[e](r)},Zt=function _setterFuncWithParam(t,e,r,i){return t[e](i.fp,r)},Ht=function _getSetter(t,e){return p(t[e])?Wt:r(t[e])&&t.setAttribute?gc:Gt},Jt=function _renderPlain(t,e){return e.set(e.t,e.p,Math.round(1e6*(e.s+e.c*t))/1e6,e)},te=function _renderBoolean(t,e){return e.set(e.t,e.p,!!(e.s+e.c*t),e)},ee=function _renderComplexString(t,e){var r=e._pt,i="";if(!t&&e.b)i=e.b;else if(1===t&&e.e)i=e.e;else{for(;r;)i=r.p+(r.m?r.m(r.s+r.c*t):Math.round(1e4*(r.s+r.c*t))/1e4)+i,r=r._next;i+=e.c}e.set(e.t,e.p,i,e)},re=function _renderPropTweens(t,e){for(var r=e._pt;r;)r.r(t,r.d),r=r._next},ie=function _addPluginModifier(t,e,r,i){for(var n,a=this._pt;a;)n=a._next,a.p===i&&a.modifier(t,e,r),a=n},ne=function _killPropTweensOf(t){for(var e,r,i=this._pt;i;)r=i._next,i.p===t&&!i.op||i.op===t?sa(this,i,"_pt"):i.dep||(e=1),i=r;return!e},se=function _sortPropTweensByPriority(t){for(var e,r,i,n,a=t._pt;a;){for(e=a._next,r=i;r&&r.pr>a.pr;)r=r._next;(a._prev=r?r._prev:n)?a._prev._next=a:i=a,(a._next=r)?r._prev=a:n=a,a=e}t._pt=i},oe=(PropTween.prototype.modifier=function modifier(t,e,r){this.mSet=this.mSet||this.set,this.set=oc,this.m=t,this.mt=r,this.tween=e},PropTween);function PropTween(t,e,r,i,n,a,s,o,u){this.t=e,this.s=i,this.c=n,this.p=r,this.r=a||Jt,this.d=s||this,this.set=o||Gt,this.pr=u||0,(this._next=t)&&(t._prev=this)}ba(ct+"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",function(t){return ut[t]=1}),ot.TweenMax=ot.TweenLite=$t,ot.TimelineLite=ot.TimelineMax=Ut,I=new Ut({sortChildren:!1,defaults:L,autoRemoveChildren:!0,id:"root",smoothChildTiming:!0}),U.stringFilter=xb;var ue={registerPlugin:function registerPlugin(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];e.forEach(function(t){return function _createPlugin(t){var e=(t=!t.name&&t.default||t).name,r=p(t),i=e&&!r&&t.init?function(){this._props=[]}:t,n={init:Q,render:re,add:Vt,kill:ne,modifier:ie,rawVars:0},a={targetTest:0,get:0,getSetter:Ht,aliases:{},register:0};if(St(),t!==i){if(ft[e])return;ka(i,ka(oa(t,n),a)),mt(i.prototype,mt(n,oa(t,a))),ft[i.prop=e]=i,t.targetTest&&(pt.push(i),ut[e]=1),e=("css"===e?"CSS":e.charAt(0).toUpperCase()+e.substr(1))+"Plugin"}P(e,i),t.register&&t.register(he,i,oe)}(t)})},timeline:function timeline(t){return new Ut(t)},getTweensOf:function getTweensOf(t,e){return I.getTweensOf(t,e)},getProperty:function getProperty(i,t,e,r){o(i)&&(i=xt(i)[0]);var n=_(i||{}).get,a=e?ja:ia;return"native"===e&&(e=""),i?t?a((ft[t]&&ft[t].get||n)(i,t,e,r)):function(t,e,r){return a((ft[t]&&ft[t].get||n)(i,t,e,r))}:i},quickSetter:function quickSetter(r,e,i){if(1<(r=xt(r)).length){var n=r.map(function(t){return he.quickSetter(t,e,i)}),a=n.length;return function(t){for(var e=a;e--;)n[e](t)}}r=r[0]||{};var s=ft[e],o=_(r),u=o.harness&&(o.harness.aliases||{})[e]||e,h=s?function(t){var e=new s;d._pt=0,e.init(r,i?t+i:t,d,0,[r]),e.render(1,e),d._pt&&re(1,d)}:o.set(r,u);return s?h:function(t){return h(r,u,i?t+i:t,o,1)}},quickTo:function quickTo(t,i,e){function iw(t,e,r){return n.resetTo(i,t,e,r)}var r,n=he.to(t,mt(((r={})[i]="+=0.1",r.paused=!0,r),e||{}));return iw.tween=n,iw},isTweening:function isTweening(t){return 0<I.getTweensOf(t,!0).length},defaults:function defaults(t){return t&&t.ease&&(t.ease=Bt(t.ease,L.ease)),na(L,t||{})},config:function config(t){return na(U,t||{})},registerEffect:function registerEffect(t){var i=t.name,n=t.effect,e=t.plugins,a=t.defaults,r=t.extendTimeline;(e||"").split(",").forEach(function(t){return t&&!ft[t]&&!ot[t]&&O(i+" effect requires "+t+" plugin.")}),dt[i]=function(t,e,r){return n(xt(t),ka(e||{},a),r)},r&&(Ut.prototype[i]=function(t,e,r){return this.add(dt[i](t,s(e)?e:(r=e)&&{},this),r)})},registerEase:function registerEase(t,e){zt[t]=Bt(e)},parseEase:function parseEase(t,e){return arguments.length?Bt(t,e):zt},getById:function getById(t){return I.getById(t)},exportRoot:function exportRoot(e,r){void 0===e&&(e={});var i,n,a=new Ut(e);for(a.smoothChildTiming=t(e.smoothChildTiming),I.remove(a),a._dp=0,a._time=a._tTime=I._time,i=I._first;i;)n=i._next,!r&&!i._dur&&i instanceof $t&&i.vars.onComplete===i._targets[0]||Da(a,i,i._start-i._delay),i=n;return Da(I,a,0),a},utils:{wrap:function wrap(e,t,r){var i=t-e;return J(e)?eb(e,wrap(0,e.length),t):Pa(r,function(t){return(i+(t-e)%i)%i+e})},wrapYoyo:function wrapYoyo(e,t,r){var i=t-e,n=2*i;return J(e)?eb(e,wrapYoyo(0,e.length-1),t):Pa(r,function(t){return e+(i<(t=(n+(t-e)%n)%n||0)?n-t:t)})},distribute:Za,random:ab,snap:_a,normalize:function normalize(t,e,r){return kt(t,e,0,1,r)},getUnit:Ra,clamp:function clamp(e,r,t){return Pa(t,function(t){return bt(e,r,t)})},splitColor:sb,toArray:xt,selector:function selector(r){return r=xt(r)[0]||O("Invalid scope")||{},function(t){var e=r.current||r.nativeElement||r;return xt(t,e.querySelectorAll?e:e===r?O("Invalid scope")||a.createElement("div"):r)}},mapRange:kt,pipe:function pipe(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return function(t){return e.reduce(function(t,e){return e(t)},t)}},unitize:function unitize(e,r){return function(t){return e(parseFloat(t))+(r||Ra(t))}},interpolate:function interpolate(e,r,t,i){var n=isNaN(e+r)?0:function(t){return(1-t)*e+t*r};if(!n){var a,s,u,h,l,f=o(e),d={};if(!0===t&&(i=1)&&(t=null),f)e={p:e},r={p:r};else if(J(e)&&!J(r)){for(u=[],h=e.length,l=h-2,s=1;s<h;s++)u.push(interpolate(e[s-1],e[s]));h--,n=function func(t){t*=h;var e=Math.min(l,~~t);return u[e](t-e)},t=r}else i||(e=mt(J(e)?[]:{},e));if(!u){for(a in r)Vt.call(d,e,a,"get",r[a]);n=function func(t){return re(t,d)||(f?e.p:e)}}}return Pa(t,n)},shuffle:Ya},install:M,effects:dt,ticker:Dt,updateRoot:Ut.updateRoot,plugins:ft,globalTimeline:I,core:{PropTween:oe,globals:P,Tween:$t,Timeline:Ut,Animation:Nt,getCache:_,_removeLinkedListItem:sa,suppressOverwrites:function suppressOverwrites(t){return B=t}}};ba("to,from,fromTo,delayedCall,set,killTweensOf",function(t){return ue[t]=$t[t]}),Dt.add(Ut.updateRoot),d=ue.to({},{duration:0});function sc(t,e){for(var r=t._pt;r&&r.p!==e&&r.op!==e&&r.fp!==e;)r=r._next;return r}function uc(t,n){return{name:t,rawVars:1,init:function init(t,i,e){e._onInit=function(t){var e,r;if(o(i)&&(e={},ba(i,function(t){return e[t]=1}),i=e),n){for(r in e={},i)e[r]=n(i[r]);i=e}!function _addModifiers(t,e){var r,i,n,a=t._targets;for(r in e)for(i=a.length;i--;)(n=(n=t._ptLookup[i][r])&&n.d)&&(n._pt&&(n=sc(n,r)),n&&n.modifier&&n.modifier(e[r],t,a[i],r))}(t,i)}}}}var he=ue.registerPlugin({name:"attr",init:function init(t,e,r,i,n){var a,s;for(a in e)(s=this.add(t,"setAttribute",(t.getAttribute(a)||0)+"",e[a],i,n,0,0,a))&&(s.op=a),this._props.push(a)}},{name:"endArray",init:function init(t,e){for(var r=e.length;r--;)this.add(t,r,t[r]||0,e[r])}},uc("roundProps",$a),uc("modifiers"),uc("snap",_a))||ue;$t.version=Ut.version=he.version="3.10.4",l=1,u()&&St();function dd(t,e){return e.set(e.t,e.p,Math.round(1e4*(e.s+e.c*t))/1e4+e.u,e)}function ed(t,e){return e.set(e.t,e.p,1===t?e.e:Math.round(1e4*(e.s+e.c*t))/1e4+e.u,e)}function fd(t,e){return e.set(e.t,e.p,t?Math.round(1e4*(e.s+e.c*t))/1e4+e.u:e.b,e)}function gd(t,e){var r=e.s+e.c*t;e.set(e.t,e.p,~~(r+(r<0?-.5:.5))+e.u,e)}function hd(t,e){return e.set(e.t,e.p,t?e.e:e.b,e)}function id(t,e){return e.set(e.t,e.p,1!==t?e.b:e.e,e)}function jd(t,e,r){return t.style[e]=r}function kd(t,e,r){return t.style.setProperty(e,r)}function ld(t,e,r){return t._gsap[e]=r}function md(t,e,r){return t._gsap.scaleX=t._gsap.scaleY=r}function nd(t,e,r,i,n){var a=t._gsap;a.scaleX=a.scaleY=r,a.renderTransform(n,a)}function od(t,e,r,i,n){var a=t._gsap;a[e]=r,a.renderTransform(n,a)}function sd(t,e){var r=fe.createElementNS?fe.createElementNS((e||"http://www.w3.org/1999/xhtml").replace(/^https/,"http"),t):fe.createElement(t);return r.style?r:fe.createElement(t)}function td(t,e,r){var i=getComputedStyle(t);return i[e]||i.getPropertyValue(e.replace(Ne,"-$1").toLowerCase())||i.getPropertyValue(e)||!r&&td(t,je(e)||e,1)||""}function wd(){(function _windowExists(){return"undefined"!=typeof window})()&&window.document&&(le=window,fe=le.document,de=fe.documentElement,pe=sd("div")||{style:{}},sd("div"),Ve=je(Ve),Xe=Ve+"Origin",pe.style.cssText="border-width:0;line-height:0;position:absolute;padding:0",me=!!je("perspective"),_e=1)}function xd(t){var e,r=sd("svg",this.ownerSVGElement&&this.ownerSVGElement.getAttribute("xmlns")||"http://www.w3.org/2000/svg"),i=this.parentNode,n=this.nextSibling,a=this.style.cssText;if(de.appendChild(r),r.appendChild(this),this.style.display="block",t)try{e=this.getBBox(),this._gsapBBox=this.getBBox,this.getBBox=xd}catch(t){}else this._gsapBBox&&(e=this._gsapBBox());return i&&(n?i.insertBefore(this,n):i.appendChild(this)),de.removeChild(r),this.style.cssText=a,e}function yd(t,e){for(var r=e.length;r--;)if(t.hasAttribute(e[r]))return t.getAttribute(e[r])}function zd(e){var r;try{r=e.getBBox()}catch(t){r=xd.call(e,!0)}return r&&(r.width||r.height)||e.getBBox===xd||(r=xd.call(e,!0)),!r||r.width||r.x||r.y?r:{x:+yd(e,["x","cx","x1"])||0,y:+yd(e,["y","cy","y1"])||0,width:0,height:0}}function Ad(t){return!(!t.getCTM||t.parentNode&&!t.ownerSVGElement||!zd(t))}function Bd(t,e){if(e){var r=t.style;e in Fe&&e!==Xe&&(e=Ve),r.removeProperty?("ms"!==e.substr(0,2)&&"webkit"!==e.substr(0,6)||(e="-"+e),r.removeProperty(e.replace(Ne,"-$1").toLowerCase())):r.removeAttribute(e)}}function Cd(t,e,r,i,n,a){var s=new oe(t._pt,e,r,0,1,a?id:hd);return(t._pt=s).b=i,s.e=n,t._props.push(r),s}function Ed(t,e,r,i){var n,a,s,o,u=parseFloat(r)||0,h=(r+"").trim().substr((u+"").length)||"px",l=pe.style,f=Ue.test(e),d="svg"===t.tagName.toLowerCase(),p=(d?"client":"offset")+(f?"Width":"Height"),c="px"===i,m="%"===i;return i===h||!u||Ke[i]||Ke[h]?u:("px"===h||c||(u=Ed(t,e,r,"px")),o=t.getCTM&&Ad(t),!m&&"%"!==h||!Fe[e]&&!~e.indexOf("adius")?(l[f?"width":"height"]=100+(c?h:i),a=~e.indexOf("adius")||"em"===i&&t.appendChild&&!d?t:t.parentNode,o&&(a=(t.ownerSVGElement||{}).parentNode),a&&a!==fe&&a.appendChild||(a=fe.body),(s=a._gsap)&&m&&s.width&&f&&s.time===Dt.time?ca(u/s.width*100):(!m&&"%"!==h||(l.position=td(t,"position")),a===t&&(l.position="static"),a.appendChild(pe),n=pe[p],a.removeChild(pe),l.position="absolute",f&&m&&((s=_(a)).time=Dt.time,s.width=a[p]),ca(c?n*u/100:n&&u?100/n*u:0))):(n=o?t.getBBox()[f?"width":"height"]:t[p],ca(m?u/n*100:u/100*n)))}function Fd(t,e,r,i){var n;return _e||wd(),e in qe&&"transform"!==e&&~(e=qe[e]).indexOf(",")&&(e=e.split(",")[0]),Fe[e]&&"transform"!==e?(n=He(t,i),n="transformOrigin"!==e?n[e]:n.svg?n.origin:Je(td(t,Xe))+" "+n.zOrigin+"px"):(n=t.style[e])&&"auto"!==n&&!i&&!~(n+"").indexOf("calc(")||(n=Ge[e]&&Ge[e](t,e,r)||td(t,e)||aa(t,e)||("opacity"===e?1:0)),r&&!~(n+"").trim().indexOf(" ")?Ed(t,e,n,r)+r:n}function Gd(t,e,r,i){if(!r||"none"===r){var n=je(e,t,1),a=n&&td(t,n,1);a&&a!==r?(e=n,r=a):"borderColor"===e&&(r=td(t,"borderTopColor"))}var s,o,u,h,l,f,d,_,p,c,m,g=new oe(this._pt,t.style,e,0,1,ee),v=0,y=0;if(g.b=r,g.e=i,r+="","auto"===(i+="")&&(t.style[e]=i,i=td(t,e)||i,t.style[e]=r),xb(s=[r,i]),i=s[1],u=(r=s[0]).match(rt)||[],(i.match(rt)||[]).length){for(;o=rt.exec(i);)d=o[0],p=i.substring(v,o.index),l?l=(l+1)%5:"rgba("!==p.substr(-5)&&"hsla("!==p.substr(-5)||(l=1),d!==(f=u[y++]||"")&&(h=parseFloat(f)||0,m=f.substr((h+"").length),"="===d.charAt(1)&&(d=ea(h,d)+m),_=parseFloat(d),c=d.substr((_+"").length),v=rt.lastIndex-c.length,c||(c=c||U.units[e]||m,v===i.length&&(i+=c,g.e+=c)),m!==c&&(h=Ed(t,e,f,c)||0),g._pt={_next:g._pt,p:p||1===y?p:",",s:h,c:_-h,m:l&&l<4||"zIndex"===e?Math.round:0});g.c=v<i.length?i.substring(v,i.length):""}else g.r="display"===e&&"none"===i?id:hd;return nt.test(i)&&(g.e=0),this._pt=g}function Id(t){var e=t.split(" "),r=e[0],i=e[1]||"50%";return"top"!==r&&"bottom"!==r&&"left"!==i&&"right"!==i||(t=r,r=i,i=t),e[0]=$e[r]||r,e[1]=$e[i]||i,e.join(" ")}function Jd(t,e){if(e.tween&&e.tween._time===e.tween._dur){var r,i,n,a=e.t,s=a.style,o=e.u,u=a._gsap;if("all"===o||!0===o)s.cssText="",i=1;else for(n=(o=o.split(",")).length;-1<--n;)r=o[n],Fe[r]&&(i=1,r="transformOrigin"===r?Xe:Ve),Bd(a,r);i&&(Bd(a,Ve),u&&(u.svg&&a.removeAttribute("transform"),He(a,1),u.uncache=1))}}function Nd(t){return"matrix(1, 0, 0, 1, 0, 0)"===t||"none"===t||!t}function Od(t){var e=td(t,Ve);return Nd(e)?We:e.substr(7).match(et).map(ca)}function Pd(t,e){var r,i,n,a,s=t._gsap||_(t),o=t.style,u=Od(t);return s.svg&&t.getAttribute("transform")?"1,0,0,1,0,0"===(u=[(n=t.transform.baseVal.consolidate().matrix).a,n.b,n.c,n.d,n.e,n.f]).join(",")?We:u:(u!==We||t.offsetParent||t===de||s.svg||(n=o.display,o.display="block",(r=t.parentNode)&&t.offsetParent||(a=1,i=t.nextSibling,de.appendChild(t)),u=Od(t),n?o.display=n:Bd(t,"display"),a&&(i?r.insertBefore(t,i):r?r.appendChild(t):de.removeChild(t))),e&&6<u.length?[u[0],u[1],u[4],u[5],u[12],u[13]]:u)}function Qd(t,e,r,i,n,a){var s,o,u,h=t._gsap,l=n||Pd(t,!0),f=h.xOrigin||0,d=h.yOrigin||0,_=h.xOffset||0,p=h.yOffset||0,c=l[0],m=l[1],g=l[2],v=l[3],y=l[4],T=l[5],b=e.split(" "),w=parseFloat(b[0])||0,x=parseFloat(b[1])||0;r?l!==We&&(o=c*v-m*g)&&(u=w*(-m/o)+x*(c/o)-(c*T-m*y)/o,w=w*(v/o)+x*(-g/o)+(g*T-v*y)/o,x=u):(w=(s=zd(t)).x+(~b[0].indexOf("%")?w/100*s.width:w),x=s.y+(~(b[1]||b[0]).indexOf("%")?x/100*s.height:x)),i||!1!==i&&h.smooth?(y=w-f,T=x-d,h.xOffset=_+(y*c+T*g)-y,h.yOffset=p+(y*m+T*v)-T):h.xOffset=h.yOffset=0,h.xOrigin=w,h.yOrigin=x,h.smooth=!!i,h.origin=e,h.originIsAbsolute=!!r,t.style[Xe]="0px 0px",a&&(Cd(a,h,"xOrigin",f,w),Cd(a,h,"yOrigin",d,x),Cd(a,h,"xOffset",_,h.xOffset),Cd(a,h,"yOffset",p,h.yOffset)),t.setAttribute("data-svg-origin",w+" "+x)}function Td(t,e,r){var i=Ra(e);return ca(parseFloat(e)+parseFloat(Ed(t,"x",r+"px",i)))+i}function $d(t,e,r,i,n){var a,s,u=360,h=o(n),l=parseFloat(n)*(h&&~n.indexOf("rad")?Be:1)-i,f=i+l+"deg";return h&&("short"===(a=n.split("_")[1])&&(l%=u)!==l%180&&(l+=l<0?u:-u),"cw"===a&&l<0?l=(l+36e9)%u-~~(l/u)*u:"ccw"===a&&0<l&&(l=(l-36e9)%u-~~(l/u)*u)),t._pt=s=new oe(t._pt,e,r,i,l,ed),s.e=f,s.u="deg",t._props.push(r),s}function _d(t,e){for(var r in e)t[r]=e[r];return t}function ae(t,e,r){var i,n,a,s,o,u,h,l=_d({},r._gsap),f=r.style;for(n in l.svg?(a=r.getAttribute("transform"),r.setAttribute("transform",""),f[Ve]=e,i=He(r,1),Bd(r,Ve),r.setAttribute("transform",a)):(a=getComputedStyle(r)[Ve],f[Ve]=e,i=He(r,1),f[Ve]=a),Fe)(a=l[n])!==(s=i[n])&&"perspective,force3D,transformOrigin,svgOrigin".indexOf(n)<0&&(o=Ra(a)!==(h=Ra(s))?Ed(r,n,a,h):parseFloat(a),u=parseFloat(s),t._pt=new oe(t._pt,i,n,o,u-o,dd),t._pt.u=h||0,t._props.push(n));_d(i,l)}var le,fe,de,_e,pe,ce,me,ge=zt.Power0,ve=zt.Power1,ye=zt.Power2,Te=zt.Power3,be=zt.Power4,we=zt.Linear,xe=zt.Quad,ke=zt.Cubic,Oe=zt.Quart,Pe=zt.Quint,Me=zt.Strong,Ce=zt.Elastic,Ae=zt.Back,De=zt.SteppedEase,Se=zt.Bounce,ze=zt.Sine,Re=zt.Expo,Ee=zt.Circ,Fe={},Be=180/Math.PI,Ie=Math.PI/180,Le=Math.atan2,Ne=/([A-Z])/g,Ue=/(left|right|width|margin|padding|x)/i,Ye=/[\s,\(]\S/,qe={autoAlpha:"opacity,visibility",scale:"scaleX,scaleY",alpha:"opacity"},Ve="transform",Xe=Ve+"Origin",Qe="O,Moz,ms,Ms,Webkit".split(","),je=function _checkPropPrefix(t,e,r){var i=(e||pe).style,n=5;if(t in i&&!r)return t;for(t=t.charAt(0).toUpperCase()+t.substr(1);n--&&!(Qe[n]+t in i););return n<0?null:(3===n?"ms":0<=n?Qe[n]:"")+t},Ke={deg:1,rad:1,turn:1},$e={top:"0%",bottom:"100%",left:"0%",right:"100%",center:"50%"},Ge={clearProps:function clearProps(t,e,r,i,n){if("isFromStart"!==n.data){var a=t._pt=new oe(t._pt,e,r,0,0,Jd);return a.u=i,a.pr=-10,a.tween=n,t._props.push(r),1}}},We=[1,0,0,1,0,0],Ze={},He=function _parseTransform(t,e){var r=t._gsap||new Lt(t);if("x"in r&&!e&&!r.uncache)return r;var i,n,a,s,o,u,h,l,f,d,_,p,c,m,g,v,y,T,b,w,x,k,O,P,M,C,A,D,S,z,R,E,F=t.style,B=r.scaleX<0,I="deg",L=td(t,Xe)||"0";return i=n=a=u=h=l=f=d=_=0,s=o=1,r.svg=!(!t.getCTM||!Ad(t)),m=Pd(t,r.svg),r.svg&&(P=(!r.uncache||"0px 0px"===L)&&!e&&t.getAttribute("data-svg-origin"),Qd(t,P||L,!!P||r.originIsAbsolute,!1!==r.smooth,m)),p=r.xOrigin||0,c=r.yOrigin||0,m!==We&&(T=m[0],b=m[1],w=m[2],x=m[3],i=k=m[4],n=O=m[5],6===m.length?(s=Math.sqrt(T*T+b*b),o=Math.sqrt(x*x+w*w),u=T||b?Le(b,T)*Be:0,(f=w||x?Le(w,x)*Be+u:0)&&(o*=Math.abs(Math.cos(f*Ie))),r.svg&&(i-=p-(p*T+c*w),n-=c-(p*b+c*x))):(E=m[6],z=m[7],A=m[8],D=m[9],S=m[10],R=m[11],i=m[12],n=m[13],a=m[14],h=(g=Le(E,S))*Be,g&&(P=k*(v=Math.cos(-g))+A*(y=Math.sin(-g)),M=O*v+D*y,C=E*v+S*y,A=k*-y+A*v,D=O*-y+D*v,S=E*-y+S*v,R=z*-y+R*v,k=P,O=M,E=C),l=(g=Le(-w,S))*Be,g&&(v=Math.cos(-g),R=x*(y=Math.sin(-g))+R*v,T=P=T*v-A*y,b=M=b*v-D*y,w=C=w*v-S*y),u=(g=Le(b,T))*Be,g&&(P=T*(v=Math.cos(g))+b*(y=Math.sin(g)),M=k*v+O*y,b=b*v-T*y,O=O*v-k*y,T=P,k=M),h&&359.9<Math.abs(h)+Math.abs(u)&&(h=u=0,l=180-l),s=ca(Math.sqrt(T*T+b*b+w*w)),o=ca(Math.sqrt(O*O+E*E)),g=Le(k,O),f=2e-4<Math.abs(g)?g*Be:0,_=R?1/(R<0?-R:R):0),r.svg&&(P=t.getAttribute("transform"),r.forceCSS=t.setAttribute("transform","")||!Nd(td(t,Ve)),P&&t.setAttribute("transform",P))),90<Math.abs(f)&&Math.abs(f)<270&&(B?(s*=-1,f+=u<=0?180:-180,u+=u<=0?180:-180):(o*=-1,f+=f<=0?180:-180)),e=e||r.uncache,r.x=i-((r.xPercent=i&&(!e&&r.xPercent||(Math.round(t.offsetWidth/2)===Math.round(-i)?-50:0)))?t.offsetWidth*r.xPercent/100:0)+"px",r.y=n-((r.yPercent=n&&(!e&&r.yPercent||(Math.round(t.offsetHeight/2)===Math.round(-n)?-50:0)))?t.offsetHeight*r.yPercent/100:0)+"px",r.z=a+"px",r.scaleX=ca(s),r.scaleY=ca(o),r.rotation=ca(u)+I,r.rotationX=ca(h)+I,r.rotationY=ca(l)+I,r.skewX=f+I,r.skewY=d+I,r.transformPerspective=_+"px",(r.zOrigin=parseFloat(L.split(" ")[2])||0)&&(F[Xe]=Je(L)),r.xOffset=r.yOffset=0,r.force3D=U.force3D,r.renderTransform=r.svg?ar:me?nr:tr,r.uncache=0,r},Je=function _firstTwoOnly(t){return(t=t.split(" "))[0]+" "+t[1]},tr=function _renderNon3DTransforms(t,e){e.z="0px",e.rotationY=e.rotationX="0deg",e.force3D=0,nr(t,e)},er="0deg",rr="0px",ir=") ",nr=function _renderCSSTransforms(t,e){var r=e||this,i=r.xPercent,n=r.yPercent,a=r.x,s=r.y,o=r.z,u=r.rotation,h=r.rotationY,l=r.rotationX,f=r.skewX,d=r.skewY,_=r.scaleX,p=r.scaleY,c=r.transformPerspective,m=r.force3D,g=r.target,v=r.zOrigin,y="",T="auto"===m&&t&&1!==t||!0===m;if(v&&(l!==er||h!==er)){var b,w=parseFloat(h)*Ie,x=Math.sin(w),k=Math.cos(w);w=parseFloat(l)*Ie,b=Math.cos(w),a=Td(g,a,x*b*-v),s=Td(g,s,-Math.sin(w)*-v),o=Td(g,o,k*b*-v+v)}c!==rr&&(y+="perspective("+c+ir),(i||n)&&(y+="translate("+i+"%, "+n+"%) "),!T&&a===rr&&s===rr&&o===rr||(y+=o!==rr||T?"translate3d("+a+", "+s+", "+o+") ":"translate("+a+", "+s+ir),u!==er&&(y+="rotate("+u+ir),h!==er&&(y+="rotateY("+h+ir),l!==er&&(y+="rotateX("+l+ir),f===er&&d===er||(y+="skew("+f+", "+d+ir),1===_&&1===p||(y+="scale("+_+", "+p+ir),g.style[Ve]=y||"translate(0, 0)"},ar=function _renderSVGTransforms(t,e){var r,i,n,a,s,o=e||this,u=o.xPercent,h=o.yPercent,l=o.x,f=o.y,d=o.rotation,_=o.skewX,p=o.skewY,c=o.scaleX,m=o.scaleY,g=o.target,v=o.xOrigin,y=o.yOrigin,T=o.xOffset,b=o.yOffset,w=o.forceCSS,x=parseFloat(l),k=parseFloat(f);d=parseFloat(d),_=parseFloat(_),(p=parseFloat(p))&&(_+=p=parseFloat(p),d+=p),d||_?(d*=Ie,_*=Ie,r=Math.cos(d)*c,i=Math.sin(d)*c,n=Math.sin(d-_)*-m,a=Math.cos(d-_)*m,_&&(p*=Ie,s=Math.tan(_-p),n*=s=Math.sqrt(1+s*s),a*=s,p&&(s=Math.tan(p),r*=s=Math.sqrt(1+s*s),i*=s)),r=ca(r),i=ca(i),n=ca(n),a=ca(a)):(r=c,a=m,i=n=0),(x&&!~(l+"").indexOf("px")||k&&!~(f+"").indexOf("px"))&&(x=Ed(g,"x",l,"px"),k=Ed(g,"y",f,"px")),(v||y||T||b)&&(x=ca(x+v-(v*r+y*n)+T),k=ca(k+y-(v*i+y*a)+b)),(u||h)&&(s=g.getBBox(),x=ca(x+u/100*s.width),k=ca(k+h/100*s.height)),s="matrix("+r+","+i+","+n+","+a+","+x+","+k+")",g.setAttribute("transform",s),w&&(g.style[Ve]=s)};ba("padding,margin,Width,Radius",function(e,r){var t="Right",i="Bottom",n="Left",o=(r<3?["Top",t,i,n]:["Top"+n,"Top"+t,i+t,i+n]).map(function(t){return r<2?e+t:"border"+t+e});Ge[1<r?"border"+e:e]=function(e,t,r,i,n){var a,s;if(arguments.length<4)return a=o.map(function(t){return Fd(e,t,r)}),5===(s=a.join(" ")).split(a[0]).length?a[0]:s;a=(i+"").split(" "),s={},o.forEach(function(t,e){return s[t]=a[e]=a[e]||a[(e-1)/2|0]}),e.init(t,s,n)}});var sr,or,ur,hr={name:"css",register:wd,targetTest:function targetTest(t){return t.style&&t.nodeType},init:function init(t,e,r,i,n){var a,s,u,h,l,f,d,_,p,c,m,g,v,y,T,b=this._props,w=t.style,x=r.vars.startAt;for(d in _e||wd(),e)if("autoRound"!==d&&(s=e[d],!ft[d]||!Ub(d,e,r,i,t,n)))if(l=typeof s,f=Ge[d],"function"===l&&(l=typeof(s=s.call(r,i,t,n))),"string"===l&&~s.indexOf("random(")&&(s=hb(s)),f)f(this,t,d,s,r)&&(T=1);else if("--"===d.substr(0,2))a=(getComputedStyle(t).getPropertyValue(d)+"").trim(),s+="",Ct.lastIndex=0,Ct.test(a)||(_=Ra(a),p=Ra(s)),p?_!==p&&(a=Ed(t,d,a,p)+p):_&&(s+=_),this.add(w,"setProperty",a,s,i,n,0,0,d),b.push(d);else if("undefined"!==l){if(x&&d in x?(a="function"==typeof x[d]?x[d].call(r,i,t,n):x[d],o(a)&&~a.indexOf("random(")&&(a=hb(a)),Ra(a+"")||(a+=U.units[d]||Ra(Fd(t,d))||""),"="===(a+"").charAt(1)&&(a=Fd(t,d))):a=Fd(t,d),h=parseFloat(a),(c="string"===l&&"="===s.charAt(1)&&s.substr(0,2))&&(s=s.substr(2)),u=parseFloat(s),d in qe&&("autoAlpha"===d&&(1===h&&"hidden"===Fd(t,"visibility")&&u&&(h=0),Cd(this,w,"visibility",h?"inherit":"hidden",u?"inherit":"hidden",!u)),"scale"!==d&&"transform"!==d&&~(d=qe[d]).indexOf(",")&&(d=d.split(",")[0])),m=d in Fe)if(g||((v=t._gsap).renderTransform&&!e.parseTransform||He(t,e.parseTransform),y=!1!==e.smoothOrigin&&v.smooth,(g=this._pt=new oe(this._pt,w,Ve,0,1,v.renderTransform,v,0,-1)).dep=1),"scale"===d)this._pt=new oe(this._pt,v,"scaleY",v.scaleY,(c?ea(v.scaleY,c+u):u)-v.scaleY||0),b.push("scaleY",d),d+="X";else{if("transformOrigin"===d){s=Id(s),v.svg?Qd(t,s,0,y,0,this):((p=parseFloat(s.split(" ")[2])||0)!==v.zOrigin&&Cd(this,v,"zOrigin",v.zOrigin,p),Cd(this,w,d,Je(a),Je(s)));continue}if("svgOrigin"===d){Qd(t,s,1,y,0,this);continue}if(d in Ze){$d(this,v,d,h,c?ea(h,c+s):s);continue}if("smoothOrigin"===d){Cd(this,v,"smooth",v.smooth,s);continue}if("force3D"===d){v[d]=s;continue}if("transform"===d){ae(this,s,t);continue}}else d in w||(d=je(d)||d);if(m||(u||0===u)&&(h||0===h)&&!Ye.test(s)&&d in w)u=u||0,(_=(a+"").substr((h+"").length))!==(p=Ra(s)||(d in U.units?U.units[d]:_))&&(h=Ed(t,d,a,p)),this._pt=new oe(this._pt,m?v:w,d,h,(c?ea(h,c+u):u)-h,m||"px"!==p&&"zIndex"!==d||!1===e.autoRound?dd:gd),this._pt.u=p||0,_!==p&&"%"!==p&&(this._pt.b=a,this._pt.r=fd);else if(d in w)Gd.call(this,t,d,a,c?c+s:s);else{if(!(d in t)){N(d,s);continue}this.add(t,d,a||t[d],c?c+s:s,i,n)}b.push(d)}T&&se(this)},get:Fd,aliases:qe,getSetter:function getSetter(t,e,i){var n=qe[e];return n&&n.indexOf(",")<0&&(e=n),e in Fe&&e!==Xe&&(t._gsap.x||Fd(t,"x"))?i&&ce===i?"scale"===e?md:ld:(ce=i||{})&&("scale"===e?nd:od):t.style&&!r(t.style[e])?jd:~e.indexOf("-")?kd:Ht(t,e)},core:{_removeProperty:Bd,_getMatrix:Pd}};he.utils.checkPrefix=je,ur=ba((sr="x,y,z,scale,scaleX,scaleY,xPercent,yPercent")+","+(or="rotation,rotationX,rotationY,skewX,skewY")+",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",function(t){Fe[t]=1}),ba(or,function(t){U.units[t]="deg",Ze[t]=1}),qe[ur[13]]=sr+","+or,ba("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",function(t){var e=t.split(":");qe[e[1]]=ur[e[0]]}),ba("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",function(t){U.units[t]="px"}),he.registerPlugin(hr);var lr=he.registerPlugin(hr)||he,fr=lr.core.Tween;e.Back=Ae,e.Bounce=Se,e.CSSPlugin=hr,e.Circ=Ee,e.Cubic=ke,e.Elastic=Ce,e.Expo=Re,e.Linear=we,e.Power0=ge,e.Power1=ve,e.Power2=ye,e.Power3=Te,e.Power4=be,e.Quad=xe,e.Quart=Oe,e.Quint=Pe,e.Sine=ze,e.SteppedEase=De,e.Strong=Me,e.TimelineLite=Ut,e.TimelineMax=Ut,e.TweenLite=$t,e.TweenMax=fr,e.default=lr,e.gsap=lr;if (typeof(window)==="undefined"||window!==e){Object.defineProperty(e,"__esModule",{value:!0})} else {delete e.default}});
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.anim");

/*****animation reveal effect constants***/
ANIM_SLIDE_FADE_OPEN = "anim-fade-open";
ANIM_SLIDE_GROW_OPEN = "anim-grow-open";
ANIM_SLIDE_SHRINK_OPEN = "anim-shrink-open";
ANIM_SLIDE_VERT_FLIP_OPEN = "anim-vert-flip-open";
ANIM_SLIDE_TOP_OPEN = "anim-top-open";
ANIM_SLIDE_LEFT_OPEN = "anim-left-open";
ANIM_SLIDE_BOTTOM_OPEN = "anim-bottom-open";
ANIM_SLIDE_RIGHT_OPEN = "anim-right-open";
ANIM_SLIDE_OFF_TOP_OPEN = "anim-offtop-open";
ANIM_SLIDE_OFF_LEFT_OPEN = "anim-offleft-open";
ANIM_SLIDE_OFF_RIGHT_OPEN = "anim-offright-open";
ANIM_SLIDE_OFF_BOTTOM_OPEN = "anim-offbottom-open";

/***animation dismiss effect constants***/
ANIM_SLIDE_FADE_CLOSE = "anim-fade-close";
ANIM_SLIDE_GROW_CLOSE = "anim-grow-close";
ANIM_SLIDE_SHRINK_CLOSE = "anim-shrink-close";
ANIM_SLIDE_VERT_FLIP_CLOSE = "anim-vert-flip-close";
ANIM_SLIDE_TOP_CLOSE = "anim-top-close";
ANIM_SLIDE_LEFT_CLOSE = "anim-left-close";
ANIM_SLIDE_BOTTOM_CLOSE = "anim-bottom-close";
ANIM_SLIDE_RIGHT_CLOSE = "anim-right-close";
ANIM_SLIDE_OFF_TOP_CLOSE = "anim-offtop-close";
ANIM_SLIDE_OFF_LEFT_CLOSE = "anim-offleft-close";
ANIM_SLIDE_OFF_RIGHT_CLOSE = "anim-offright-close";
ANIM_SLIDE_OFF_BOTTOM_CLOSE = "anim-offbottom-close";

  /**Expand Collapse Animation Configs**/
ANIM_SLIDE_EXPANDX_OPEN = "anim-expandx-open";
ANIM_SLIDE_COLLAPSEX_CLOSE = "anim-collapsex-close";
ANIM_SLIDE_EXPANDY_OPEN = "anim-expandy-open";
ANIM_SLIDE_COLLAPSEY_CLOSE = "anim-collapsey-close";

    /*****animation speed constants****/
ANIM_SPEED_DEFAULT = "default";
ANIM_SPEED_FAST = "fast";
ANIM_SPEED_SLOW = "slow";
ANIM_SPEED_VERY_FAST = "vfast";
ANIM_SPEED_VERY_SLOW = "vslow";

/*****animation acceleration constants****/
ANIM_ACCEL_STANDARD = "standard";
ANIM_ACCEL_LINEAR = "linear";
ANIM_ACCEL_START_SLOWLY = "easein_slowly";
ANIM_ACCEL_START_PULLBACK = "easein_pullback";
ANIM_ACCEL_START_ELASTIC = "easein_elastic";
ANIM_ACCEL_END_SLOWLY = "easeout_slowly";
ANIM_ACCEL_END_PULLBACK = "easeout_pullback";
ANIM_ACCEL_END_ELASTIC = "easeout_elastic";
ANIM_ACCEL_STARTEND_SLOWLY = "easeinout_slowly";
ANIM_ACCEL_STARTEND_PULLBACK = "easeinout_pullback";
ANIM_ACCEL_STARTEND_ELASTIC = "easeinout_elastic";

pega.ui.anim = (function() {
    var speed = {
        "default": 0.33,
        "fast": 0.167,
        "slow": 0.5,
        "vfast": 0.1,
        "vslow": 0.67
    }
    var easeConfig = {
        "standard": "SlowMo.ease.config(0.1, 0.4, false)",
        "linear": "Power0.easeNone",
        "easein_slowly": "Power1.easeIn",
        "easein_pullback": "Back.easeIn",
        "easein_elastic": "Elastic.easeIn",
        "easeout_slowly": "Power1.easeOut",
        "easeout_pullback": "Back.easeOut",
        "easeout_elastic": "Elastic.easeOut",
        "easeinout_slowly": "Power1.easeInOut",
        "easeinout_pullback": "Back.easeInOut",
        "easeinout_elastic": "Elastic.easeInOut"
    }
    
    var effectConfig = {
        "anim-fade-open" : {
          "set" : { "x": "0%", 'y': "0%","opacity":"0","transform": "none"},
          "to" : {"opacity": 1}
        },
        "anim-grow-open" : {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"scale": 0.9,"opacity": 0}
        },
        "anim-shrink-open": {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"scale": 1.1,"opacity": 0}
        },
        "anim-top-open": {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"y": "-25%","opacity": 0}   
        },
        "anim-left-open": {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"x": "-25%","opacity": 0}   
        },
        "anim-bottom-open": {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"y": "25%","opacity": 0} 
        },
        "anim-right-open": {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"x": "25%","opacity": 0} 
        },
        "anim-offtop-open": {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"y": "-150%","opacity": 0}     
        },
        "anim-offleft-open": {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"x": "-150%","opacity": 0} 
        },
        "anim-offright-open": {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"x": "150%","opacity": 0} 
        },
        "anim-offbottom-open": {
          "set" : { "x": "0%", 'y': "0%","transform": "none"},
          "from" : {"y": "150%","opacity": 0} 
        },
        "anim-vert-flip-open": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "from" : {"transform": "rotateY(180deg)","opacity": 0} 
        },
        "anim-expandx-open": {
          "set" : { "x": "0", 'y': "0", "transform": "none", "width":0},
          "to" : {"width":"100%"} 
        },
        "anim-expandy-open": {
          "set" : { "x": "0", 'y': "0", "transform": "none", "height":0},
          "to" : {"height":"100%"} 
        },
        "anim-fade-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"opacity": 0}
        },
        "anim-grow-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"scale": 1.1,"opacity": 0}  
        },
        "anim-shrink-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"scale": 0.9,"opacity": 0}  
        },
        "anim-top-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"y": "-25%","opacity": 0}       
        },
        "anim-left-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"x": "-25%","opacity": 0}
        },
        "anim-bottom-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"y": "25%","opacity": 0}
        },
        "anim-right-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"x": "25%","opacity": 0}
        },
        "anim-offtop-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"y": "-150%","opacity": 0}   
        },
        "anim-offleft-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"x": "-150%","opacity": 0}   
        },
        "anim-offright-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"x": "150%","opacity": 0}
        },
        "anim-offbottom-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : { "y": "150%","opacity": 0} 
        },
        "anim-vert-flip-close": {
          "set" : { "x": "0", 'y': "0","transform": "none"},
          "to" : {"transform": "rotateY(180deg)","opacity": 0}
        },
        "anim-collapsex-close": {
          "set" : { "x": "0", 'y': "0","transform": "none","width":"auto"},
          "to" : {"width":0} 
        },
        "anim-collapsey-close": {
          "set" : { "x": "0", 'y': "0","transform": "none","height":"auto"},
          "to" : {"height":0} 
        }
    }
    var reverseEffects = {
        "reverse-anim-fade-open": "anim-fade-close",
        "reverse-anim-grow-open": "anim-shrink-close",
        "reverse-anim-shrink-open": "anim-grow-close",
        "reverse-anim-top-open": "anim-top-close",
        "reverse-anim-left-open": "anim-left-close",
        "reverse-anim-bottom-open": "anim-bottom-close",
        "reverse-anim-right-open": "anim-right-close",
        "reverse-anim-offtop-open": "anim-offtop-close",
        "reverse-anim-offleft-open": "anim-offleft-close",
        "reverse-anim-offright-open": "anim-offright-close",
        "reverse-anim-offbottom-open": "anim-offbottom-close",
        "reverse-anim-vert-flip-open": "anim-vert-flip-close",
        "reverse-anim-expandx-open": "anim-collapsex-close",
        "reverse-anim-expandy-open": "anim-collapsey-close"    
    }

    function _getDismissEffectForReveal(effect) {
        return reverseEffects[effect];
    }

    function _getEase(ease) {
        return easeConfig[ease] ? easeConfig[ease] : easeConfig[ANIM_ACCEL_LINEAR];
    }

    function _getAnimParams(animType) {
        return effectConfig[animType] ? effectConfig[animType] : {};
    }

    function _getDuration(duration) {
        return  !isNaN(parseFloat(duration)) ? parseFloat(duration) : (speed[duration] ? speed[duration] : speed[ANIM_SPEED_DEFAULT]);
    }
    return {
        getAnimParams: _getAnimParams,
        getEase: _getEase,
        getDuration: _getDuration,
        getDismissEffectForReveal: _getDismissEffectForReveal
    }
})();
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.animations");
pega.ui.animations = (function() {
    var stringConstructor = "".constructor;
    //    var arrayConstructor = [].constructor;
    var objectConstructor = {}.constructor;
   
    function _animateTo(element, animObj) {
        try {
            return gsap.to(element, animObj);
        } catch (e) {
            console.log("Error animating elements - " + e);
        }
    }

    function _animateFrom(element, animObj) {
        try {
            return gsap.from(element, animObj);
        } catch (e) {
            console.log("Error animating elements - " + e);
        }
    }

    function _setAnimateSetParams(element, animObj) {
        try {
            return gsap.set(element, animObj);
        } catch (e) {
            console.log("Error animating elements - " + e);
        }
    }

    function _staggerTo(element, duration, animObj) {
        try {
            var resultVarForFrom = checkAnimationType(animObj) || {};
            resultVarForFrom.stagger = duration;
            return gsap.to(element, resultVarForFrom);
        } catch (e) {
            console.log("Error animating elements - " + e);
        }
    }

    function _getTimelineMaxObj(callbacksObj) {
        var callbacks = {};
        if (callbacksObj) {
            if(callbacksObj.onAnimStart){
                callbacks.onStart = callbacksObj.onAnimStart;
            }
            if (callbacksObj.onAnimEnd) {
                callbacks.onComplete = callbacksObj.onAnimEnd;
            }
        }
        return gsap.timeline(callbacks);
    }

    function _cloneJSON(jsonObj) {
        return Object.assign({}, jsonObj);
    }

    function _bObjectHasKey(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
    }
    
    function _constructEffectParams(_effect){
        var vars = {};
        if (_effect) {
            var _effectVars = {};
            _effect = _effect.indexOf("reverse") === 0 ? pega.ui.anim.getDismissEffectForReveal(_effect) : _effect;
            try {
                _effect = eval(_effect);
                _effectVars = pega.ui.anim.getAnimParams(_effect);
            } catch (e) {
                _effectVars = pega.ui.anim.getAnimParams(_effect);
            }
            vars = _cloneJSON(_effectVars);
        }
        return vars;
    }
  
    function _constructParams(paramsObj) {
        if (paramsObj && paramsObj.className) {
            var isAdd = _bObjectHasKey(paramsObj, "addOrRemoveClass") ? paramsObj.addOrRemoveClass : false;
            var className = isAdd ? "+=" + paramsObj.className : "-=" + paramsObj.className;
            paramsObj.css = paramsObj.css ? paramsObj.css : {};
            paramsObj.css.className = className;
            delete paramsObj.className;
            delete paramsObj.addOrRemoveClass;
        }
        paramsObj.ease = pega.ui.anim.getEase(paramsObj.ease);
        return paramsObj;
    }
      
    function checkAnimationType(obj){
        return obj.from ? obj.from : (obj.to ? obj.to : obj);
    } 
    function _getAnimParams(obj){
        return obj.from ? obj.from : (obj.to ? obj.to : obj);
    }
    function _getAnimSetParams(obj){
        return obj.set ? obj.set : {};
    }
    function _animateElementsWithSameAnim(element, params, commonJSON) {
        if (gsap.isTweening(element)) {
          return false;
        }
        if (commonJSON) {
            params = Object.assign(_cloneJSON(commonJSON), _cloneJSON(params));
        }
        var duration = pega.ui.anim.getDuration(params.duration);
        var effectObj = _constructEffectParams(params.effect);
        var varsObj = _constructParams(params);
        varsObj.duration = duration;
        delete varsObj.effect;
        var animSetParams = _getAnimSetParams(effectObj);
        _setAnimateSetParams(element, animSetParams);
        var _animVars = _getAnimParams(effectObj);
        Object.assign(_animVars, varsObj);
        
        if (params.bAllAnimateSequentially) {
            delete _animVars.bAllAnimateSequentially;
            return _staggerTo(element, duration, _animVars)
        }
        if(effectObj.from){
            return _animateFrom(element, _animVars);
        } else {
            return _animateTo(element, _animVars);
        }
    }

    function _animateMultipleElementsDiffAnims(elements, commonJSON) {
        var tl = _getTimelineMaxObj();
        for (var i = 0; i < elements.length; i++) {
            var obj = elements[i];
            var element = obj["element"];
            var varsOfElements = obj["paramsObj"];
            var delay = _bObjectHasKey(obj, "delay") ? obj["delay"] : (_bObjectHasKey(commonJSON, "delay") ?
                commonJSON["key"] : 0);
            var singleAnim = _animateElementsWithSameAnim(element, varsOfElements, commonJSON);
            if(singleAnim){
                tl.add(singleAnim, delay);    
            }
        }
        return tl;
    }
    function _validateInputParams(element, paramsObj){
        if(!element || !paramsObj){
            console.log("Animate API - Invalid input parameters element/paramsObj");
            return false;
        }
        if (typeof paramsObj === 'string') {
            try {
                paramsObj = eval(paramsObj);
            } catch (e) {
                paramsObj = {
                    "effect": paramsObj
                };
            }
        }
        paramsObj.ease = paramsObj.ease
        return true;
    }
    function _animate(element, paramsObj, commonJSON) {
        if (!Array.isArray(element) || (element.length > 0 && element[0].constructor !== objectConstructor)) {
            return _animateElementsWithSameAnim(element, paramsObj, commonJSON);
        }
        if (element.length > 0 && element[0].constructor === objectConstructor) {
            return _animateMultipleElementsDiffAnims(element, paramsObj, commonJSON);
        }
    }
  
    function _animateMain(element, paramsObj, callbacksObj) {
        var isValidInputs = _validateInputParams(element, paramsObj);
        if(!isValidInputs){
            return
        }
        try {
            var tl = _getTimelineMaxObj(callbacksObj);
            var tween = _animate(element, paramsObj);
            if(tween){
                tl.add(tween);
                tl.play();
            }
        } catch (e) {
            console.log("Error animating elements - " + e);
        }
    }
    return {
        "animate": _animateMain
    }
})();
//static-content-hash-trigger-NON
pega.control.Actions.prototype.guidedTour = function(tourClass, tourName, actionToTake, continueTour, template) {
	if(actionToTake==="Start") {
		if (continueTour==="true") {
			// Call the continue tour function, passing in the template parameter
			pega.desktop.automation.support.continueTour(tourName, tourClass,"", template);
		} else {
			// Call the start tour function, passing in the template parameter
			pega.desktop.automation.support.startTour(tourName, tourClass,"", template);
		}
	} else if(actionToTake==="Dismiss") {
		pega.desktop.automation.support.dismissTour();
	} else {
		//Do nothing, not a valid action
	}
}
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.openWizard = function () {
	pega.desktop.support.openWizard.apply(pega.desktop.support, arguments);
};
//static-content-hash-trigger-GCC
/*
 @api
 This function is to
 @param $String$action - “display | createNewWork”.
 @param $Object$actionParams - Match IAC parameters for these IAC actions.
 @param $Object$subNavigation – {levelA:”XX”, levelB:”XX”, levelC:”XX};  - support three levels of navigation.
 @param $Object$optionalParams- additional params on query string.
 @return $void$
 */

pega.desktop.openLandingPage = function(name, action, actionParams, navigation) {
  pega.desktop.support.openLandingPage(name, action, actionParams, navigation);

}

/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.openLandingPage = function () {
  /*HFIX-4560*/
  /*Code has been coditionalized to send out different argument object for Composite and Non-Composite portals*/
  if (pega.d.s.getDesktopType() != "Composite") {
    var actionParamObj = {};
    for (var actionParam in arguments[2]) {
      if (actionParam != "customParams") {
        actionParamObj[actionParam] = arguments[2][actionParam];
      }
    }

    var tempCustomParam = arguments[2]["customParams"];
    for (var customParam in tempCustomParam) {
      actionParamObj[customParam] = tempCustomParam[customParam];
    }

    var landingPageArgs = [];
    landingPageArgs[0] = arguments[0];
    landingPageArgs[1] = arguments[1];
    landingPageArgs[2] = actionParamObj;
    landingPageArgs[3] = arguments[3];
    pega.d.openLandingPage.apply(pega.d, landingPageArgs);
  } else {
    pega.d.openLandingPage.apply(pega.d, arguments);
  }
};
//static-content-hash-trigger-GCC
/*
 @api
 This wrapper function will open a form in a new window.
 @param $String$oUrl - A string specifying the URL to open in the new window.
 @param $String$sName - A string specifying the window name to use in the TARGET attribute of a FORM or A tag. windowName can contain only alphanumeric or underscore (_) characters.
 @param $String$sOptions - A string containing a comma-separated list determining whether or not to create various standard window features.
 @param $boolean$bReplace - A Boolean parameter that specifies whether the sURL creates a new entry or replaces the current entry in the window's history list.
 @return $Object$ - Opens form in window.
 */
pega.desktop.openUrlInWindow = function(oUrl, sName, sOptions, bReplace, isAlternateBaseUrl) {
  return pega.desktop.support.openUrlInWindow(oUrl, sName, sOptions, bReplace, isAlternateBaseUrl);
}

/*
@api
This wrapper function will open a form in a new window.
@param $String$oUrl - A string specifying the URL to open in the new window.
@param $String$sName - A string specifying the window name to use in the TARGET attribute of a FORM or A tag. windowName can contain only alphanumeric or underscore (_) characters.
@param $String$sOptions - A string containing a comma-separated list determining whether or not to create various standard window features.
@param $boolean$bReplace - A Boolean parameter that specifies whether the sURL creates a new entry or replaces the current entry in the window's history list.
@return $Object$ - Opens form in window.
*/
function openUrlInWindow(oUrl, sName, sOptions, bReplace) {
    return pega.desktop.support.openUrlInWindow(oUrl, sName, sOptions, bReplace);
}

/* BUG-342028: Handling opening attachments from iframe without pega_ui_harness */
if (typeof pega.control == 'undefined') {
  pega.control = pega.namespace("pega.control")
}
if (typeof pega.control.Actions == 'undefined') {
  pega.control.Actions = function () {};
  pega.control.Actions.prototype = { };
}

/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.openUrlInWindow = function () {
  pega.u.d.openUrlInWindow.apply(pega.u.d, arguments);
};

/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.customActivityInPopup = function () {
  pega.u.d.customActivityInPopup.apply(pega.u.d, arguments);
};
//static-content-hash-trigger-GCC
/*
 @api
 Get the next most urgent work item for a given a user.
 @param $String$strUserId - The id of the user for whom the next work item will be acquired.
 @return $void$
 */
pega.desktop.getNextWorkItem = function(strUserId, contentID, dynamicContainerID,configParams) {
  
  var args = arguments[0];
  if (typeof args == "object" && args.name == "safeURL") {
    var oSafeURL = SafeURL_clone(args);
    var strUserId = oSafeURL.get("strUserId");
    var contentID = oSafeURL.get("contentID");
    var dynamicContainerID = oSafeURL.get("dynamicContainerID");

  }

  if (!oSafeURL) {
    var oSafeURL = new SafeURL();
  }
  if (typeof strUserId == "string") {
    oSafeURL.put("param", strUserId);
  }

  if (dynamicContainerID && dynamicContainerID != "")
    oSafeURL.put("dynamicContainerID", dynamicContainerID);
  if (contentID && contentID != "")
    oSafeURL.put("contentID", contentID);
  
  //augment config params to oSafeURL
  pega.desktop.augmentConfigParams(configParams, oSafeURL);
  
  if (!pega.desktop.support.openSpace("Work", oSafeURL, "getnextwork")) {
    strUserId = oSafeURL.toQueryString();
    var strURL = pega.desktop.support.constructUrl(strUserId, "getnextwork");
    pega.desktop.openUrlInWindow(strURL, "pyWorkPage", WorkFormSize + PopupWindowFeatures);
  }
}

/*
@api
Get the next most urgent work item for a given a user.
@param $String$strUserId - The id of the user for whom the next work item will be acquired.
@return $void$
*/
function getNextWorkItem(strUserId,contetnID,dynamicContainerID,configParams) {
	return pega.desktop.getNextWorkItem(strUserId,contetnID,dynamicContainerID,configParams);
}

/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.getNextWorkItem = function () {
  pega.desktop.getNextWorkItem.apply(pega.d, arguments);
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.toggleExpandCollapse = function () {
  if (typeof pega.u.d.toggleExpandCollapse === "function") {
    pega.u.d.toggleExpandCollapse.apply(pega.u.d, arguments);
  }
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.runSpellChecker = function () {
  if (pega.u && pega.u.d && pega.u.d.spellChecker) {
    pega.u.d.spellChecker.spellCheck.apply(null, arguments);
  }
  window.runSpellChecker.apply(null, arguments);
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.openRule = function () {
  pega.d.openRule.apply(pega.d, arguments);
};
//static-content-hash-trigger-GCC
/*
 @api
 This function is to opend a rule with the given name and class in desktop or in a popup if a desktop rules space isn't found. Since the rule is opened by insName rule resolution is performed.
 @param $String$insName - Specifies the instance name.
 @param $Object$objClass - The pxObjClass of the class to open.
 @return $void$
 */
pega.desktop.openRuleByClassAndName = function(insName, objClass, contentID, dynamicContainerID) {

  var sourceString = new SafeURL();

  // trim strings to avoid common JavaScript errors
  insName = pega.tools.SUtils.trim(insName);
  objClass = pega.tools.SUtils.trim(objClass);

  sourceString.put("objClass", objClass);
  sourceString.put("insName", insName);
  if (contentID && contentID != "") {
    sourceString.put("contentID", contentID);
  }
  if (dynamicContainerID && dynamicContainerID != "") {
    sourceString.put("dynamicContainerID", dynamicContainerID);
  }
  var success;
  if (pega && pega.ui && pega.ui.NavigateTopHandler) {
    success = false;
  } else {
    success = pega.desktop.support.openSpace("Rules", sourceString, "rulebyclassandname");
  }
  if (!success) {
    if (insName.length > 0 && objClass.length > 0) {
      var safekey = insName.replace(/\W/g, '_');
      var oSafeURL = new SafeURL("WBOpenLaunch");
      oSafeURL.put("InsName", insName);
      oSafeURL.put("Action", "Open");
      oSafeURL.put("ObjClass", objClass);
      if (contentID && contentID != "") {
        oSafeURL.put("contentID", contentID);
      }
      if (dynamicContainerID && dynamicContainerID != "") {
        oSafeURL.put("dynamicContainerID", dynamicContainerID);
      }
      oSafeURL.put("target", "popup");

      pega.desktop.openUrlInWindow(oSafeURL, safekey, RuleFormSize + PopupWindowFeatures);
    } else {
      window.status = "Can't open rule; no name or class.";
    }
  }
}

/*
@api
This function is to opend a rule with the given name and class in desktop or in a popup if a desktop rules space isn't found. Since the rule is opened by insName rule resolution is performed.
@param $String$insName - Specifies the instance name.     
@param $Object$objClass - The pxObjClass of the class to open.
@return $void$ 
*/
function openRuleByClassAndName(insName, objClass,contentID,dynamicContainerID) {
	return pega.desktop.openRuleByClassAndName(insName,objClass,contentID,dynamicContainerID);
}

/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.openRuleByClassAndName = function () {
  pega.d.openRuleByClassAndName.apply(pega.d, arguments);
};
//static-content-hash-trigger-GCC
/*
 @api
 Given an array of keys in query string format and an objClass this function opens the rule in desktop or in a popup if a desktop rules space isn't found.
 @param $object$objClass - The pxObjClass of the class to open.
 @param $String$strKeyParams - All other key params in URL concatentation.
 @return $void$
 */
pega.desktop.openRuleByKeys = function(objClass, strKeyParams, contentID, dynamicContainerID) {

  var theParamsString = null;
  var success;
  if (typeof strKeyParams == "object" && strKeyParams.name == "safeURL") {
    strKeyParams.put("pxObjClass", objClass);
    if (contentID && contentID != "") {
      strKeyParams.put("contentID", contentID);
    }
    if (dynamicContainerID && dynamicContainerID != "") {
      strKeyParams.put("dynamicContainerID", dynamicContainerID);
    }
    var success;
    if (pega && pega.ui && pega.ui.NavigateTopHandler) {
      success = false;
    } else {
      success = pega.desktop.support.openSpace("Rules", strKeyParams, "rulebykeys");
    }
  }
  else {
    var oSafeURL = SafeURL_createFromURL(strKeyParams);
    oSafeURL.put("pxObjClass", objClass);
    if (contentID && contentID != "") {
      oSafeURL.put("contentID", contentID);
    }
    if (dynamicContainerID && dynamicContainerID != "") {
      oSafeURL.put("dynamicContainerID", dynamicContainerID);
    }
    var success;
    if (pega && pega.ui && pega.ui.NavigateTopHandler) {
      success = false;
    } else {
      success = pega.desktop.support.openSpace("Rules", oSafeURL, "rulebykeys");
    }
  }
  if (!success) {

    if (typeof strKeyParams == "object" && strKeyParams.name == "safeURL") {
      strKeyParams.put("ObjClass", objClass);
      strKeyParams.put("pyActivity", objClass + ".WBOpen");
      theParamsString = strKeyParams;
    }
    else {
      var oSafeURL = SafeURL_createFromURL(strKeyParams);
      oSafeURL.put("ObjClass", objClass);
      oSafeURL.put("pyActivity", objClass + ".WBOpen");
      theParamsString = oSafeURL;
    }
    theParamsString.put("target", "popup");
    if (contentID && contentID != "") {
      theParamsString.put("contentID", contentID);
    }
    if (dynamicContainerID && dynamicContainerID != "") {
      theParamsString.put("dynamicContainerID", dynamicContainerID);
    }
    pega.desktop.openUrlInWindow(theParamsString, "Rules");
  }
}

/*
@api
Given an array of keys in query string format and an objClass this function opens the rule in desktop or in a popup if a desktop rules space isn't found.
@param $object$objClass - The pxObjClass of the class to open.
@param $String$strKeyParams - All other key params in URL concatentation.
@return $void$
*/
function openRuleByKeys(objClass, strKeyParams,contentID,dynamicContainerID) {
	return pega.desktop.openRuleByKeys(objClass,strKeyParams,contentID,dynamicContainerID);
}

/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.openRuleByKey = function () {
  pega.d.openRuleByKeys.apply(pega.d, arguments);
};
/*
 @api
 Runs the Report Definition based on the specified parameters.
 @param $Object$reportClass - Applies to class of report definition.
 @param $String$reportName - Name of the report definition rule..
 @param $String$displayMode - Pass dataonly/chartonly.
 @param $String$displayTarget - Display output, 'newDocument' or 'popup' (undefined, null, and '' are treated as popup)
 @param $String$shortcutHandle - Optional shortcut handle used by RD to update during save operation.  Value of * indicates new.
 @param $String$reportAction- Optional.  'open', 'shortcut', 'new' (null/undefined/empty treated as open)
 @return $void$
 */
pega.desktop.showReportDefinition = function(reportClass, reportName, displayMode, displayTarget, shortcutHandle, reportAction) {
  var strURL;
  var oSafeURL = null;
  if (typeof reportClass == "object" && reportClass.name == "safeURL") {
    //keep old support when reportClass is a SafeURL, this is a bad operation, this would just open any old URL in a space.
    //TODO: Find usages (if any) and replace them
    oSafeURL = reportClass;
    pega.desktop.support.openUrlInSpace(oSafeURL);
    return;
  }
  //cleanup target
  if (displayTarget == null || typeof displayTarget == 'undefined' || displayTarget == "") {
    displayTarget = 'popup';
  }
  //cleanup report action
  if (typeof reportAction == 'undefined' || reportAction == null || reportAction == 'open') {
    reportAction = 'open';
  }
  //if open or new and report name is empty, abort
  if ((reportAction == 'open' || reportAction == 'new') && (reportName == null || typeof reportName == 'undefined' || reportName == '')) {
    return;
  }
  //if shortcut and shortcuthandle is empty, abort
  if ((reportAction == 'shortcut') && (shortcutHandle == null || typeof shortcutHandle == 'undefined' || shortcutHandle == '')) {
    return;
  }
  // call function
  openURLAsRD(reportClass, reportName, displayMode, displayTarget, shortcutHandle, reportAction, new SafeURL());
}

pega.desktop.showReportDefinitionWithParams = function (reportClass, reportName, displayMode, displayTarget, shortcutHandle, reportAction, paramObj) {
  var safeURL = new SafeURL();
  var paramNames = Object.keys(paramObj);
  for (var i = 0; i < paramNames.length; i++) {
    var paramName = paramNames[i];
    safeURL.put(paramName, paramObj[paramName]);
  }
  
  openURLAsRD(reportClass, reportName, displayMode, displayTarget, shortcutHandle, reportAction, safeURL);
}

function openURLAsRD(reportClass, reportName, displayMode, displayTarget, shortcutHandle, reportAction, oSafeURL) {
  var desktopWindow = pega.desktop.support.getDesktopWindow();
  var wad = null;
  if (desktopWindow != null) {
    wad = desktopWindow.document.getElementById("workarea");
  }
  var isMV = wad != null && (wad.getAttribute("data-multiview") != "0");
  if (isMV) {
    oSafeURL.put("isMultiView", "" + isMV);
  }
  if (displayTarget == 'popup') {
    //Launch popup using openUrlInSpace with activity @baseclass.doUIAction
    if (reportClass != null && reportClass != "") {
      reportClass = pega.desktop.support.getClassForReports(reportClass);
      oSafeURL.put("pyReportClass", reportClass);
    }
    if (reportAction != 'shortcut') {
      var params = "";
      var iAmp = reportName.indexOf("&");
      var tempArr = [];
      if (iAmp > 0) {
        params = reportName.substr(iAmp + 1);
        reportName = reportName.substring(0, iAmp);
        paramsList = params.split("&");
        for (var i = 0; i < paramsList.length; i++) {
          var pos = paramsList[i].indexOf("=");
          if (pos > -1) {
            var key = "";
            var value = "";
            key = paramsList[i].substring(0, pos);
            if (pos < paramsList[i].length)
              value = paramsList[i].substring(pos + 1);
            tempArr[key] = value;
          }
        }
      }
      if (reportName != null && reportName != "") {
        oSafeURL.put("pyReportName", reportName);
      }
      if (displayMode != null && displayMode != "") {
        oSafeURL.put("pyReportDisplay", displayMode);
      }
      oSafeURL.put("pyNew", (reportAction == 'new') + "");
      if (iAmp > 0) {
        for (var j in tempArr)
          oSafeURL.put(j, tempArr[j]);
      }
      oSafeURL.put("pyActivity", "@baseclass.doUIAction");
      oSafeURL.put("action", "reportDefinition");
      oSafeURL.put("ReportAction", reportAction);
    } else {
      oSafeURL.put("pyActivity", "@baseclass.doUIAction");
      oSafeURL.put("pyShortcutHandle", shortcutHandle);
      oSafeURL.put("action", "reportDefinition");
      oSafeURL.put("ReportAction", "shortcut");
    }
    oSafeURL.put("pyDisplayTarget", "popup");
    oSafeURL.put("target", "popup");
    pega.desktop.support.openUrlInSpace(oSafeURL, "RD_POPUP");
  } else {
    //New multi-view code
    if (reportClass != null && reportClass != "") {
      reportClass = pega.desktop.support.getClassForReports(reportClass);
      oSafeURL.put("ReportClass", reportClass);
    }
    //TODO: PASS PARAMETERS TO REPORT
    if (reportAction != 'shortcut') {
      var params = "";
      var iAmp = reportName.indexOf("&");
      var tempArr = [];
      if (iAmp > 0) {
        params = reportName.substr(iAmp + 1);
        reportName = reportName.substring(0, iAmp);
      }
      oSafeURL.put("ParamKeys", params);
    }
    oSafeURL.put("ReportName", reportName);
    if (displayMode != null && displayMode != "") {
      oSafeURL.put("pyReportDisplay", displayMode);
    }
    if (shortcutHandle != null && typeof shortcutHandle != 'undefined' && shortcutHandle != "") {
      oSafeURL.put("ShortcutHandle", shortcutHandle);
    }
    if (reportAction != null && typeof reportAction != 'undefined' && reportAction != "") {
      oSafeURL.put("ReportAction", reportAction);
    }
    if (displayTarget != null && typeof displayTarget != 'undefined' && displayTarget == 'current') {
      oSafeURL.put("replaceCurrent", "true");
    } else {
      oSafeURL.put("replaceCurrent", "false");
    }
    //Report parameters
    pega.desktop.support.openSpace("Work", oSafeURL, "reportDefinition");
  }
}

/*
@api
Runs the Report Definition based on the specified parameters.
@param $Object$reportClass - Applies to class of report definition.
@param $String$reportName - Name of the report definition rule..
@param $String$displayMode - Pass dataonly/chartonly.
@param $String$displayTarget - Display output, popup to show in new window, auto to open in tab.
@param $String$shortcutHandle - Optional shortcut handle used by RD to update during save operation.
@param $String$reportAction- Optional.  'open', 'shortcut', 'new' (null/undefined/empty treated as open)
@return $void$
*/
function showReportDefinition(reportClass , reportName, displayMode,displayTarget,shortcutHandle,reportAction) {
    var desktopType = pega.ui.HarnessContextMgr.get("desktopType");
    var desktopSubType = pega.ui.HarnessContextMgr.get("desktopSubType");
	if(desktopType == "Developer" && desktopSubType == "Composite") {
		pega.desktop.showNextInWindow();
	}
	return pega.desktop.showReportDefinition(reportClass, reportName, displayMode,displayTarget,shortcutHandle,reportAction);
}


/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.reportDefinition = function () {
  window.showReportDefinition.apply(null, arguments);
};
//static-content-hash-trigger-YUI
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.runActivity = function () {
  pega.u.invoke.runActivity(arguments);
};
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.runDataTransform = function () {
  pega.u.invoke.runDataTransform(arguments);
};
//static-content-hash-trigger-GCC
/*
 @api
 Opens a work item in the current work pool.
 @param $String$strItemId - The id of the work item.
 @param $String$workpool - Name of desired workpool, default is current workpool (Deprecated Use for HarnessVersion: 0 or 1, 0 is heritage (v3) harness, 1 is v4 harness.)
 @return $void$
 */
pega.desktop.openWorkItem = function(strItemId, workpool, contentID, dynamicContainerID, configParams) {

  var args = arguments[0];
  if (typeof args == "object" && args.name == "safeURL") {
    var oSafeURL = SafeURL_clone(args);
    var strItemId = oSafeURL.get("ID");
    var workpool = oSafeURL.get("workpool");
  }

  var harnessVersion;
  if (workpool == 0 || workpool == 1) {
    harnessVersion = workpool + "";
  }

  var sourceString = "";

  if (!oSafeURL) {
    var oSafeURL = new SafeURL();
  }
  if (strItemId && strItemId != "") {
    oSafeURL.put("param", strItemId);
  }
  if (harnessVersion && harnessVersion != "") {
    oSafeURL.put("version", harnessVersion);
  }
  if (contentID && contentID != "") {
    oSafeURL.put("contentID", contentID);
  }
  if (dynamicContainerID && dynamicContainerID != "") {
    oSafeURL.put("dynamicContainerID", dynamicContainerID);
  }
  if (workpool && workpool != 1 && workpool != 0) {
    oSafeURL.put("workpool", workpool);
  }
  
  
  //augment config params to oSafeURL
  pega.desktop.augmentConfigParams(configParams, oSafeURL);
  
  
  if (!openSpace("Work", oSafeURL, "openbyworkItem")) {
    sourceString = oSafeURL.toQueryString();
    var strURL = pega.desktop.support.constructUrl(sourceString, "openbyworkItem");
    pega.desktop.openUrlInWindow(strURL, "pyWorkPage", WorkFormSize + PopupWindowFeatures);
  }
}

/*
@api
Opens a work item in the current work pool.
@param $String$strItemId - The id of the work item.
@param $String$workpool - Name of desired workpool, default is current workpool (Deprecated Use for HarnessVersion: 0 or 1, 0 is heritage (v3) harness, 1 is v4 harness.)
@return $void$
*/
function openWorkItem(strItemId, workpool,contentID,dynamicContainerID, configParams) {
	if(strItemId=="" || strItemId.replace(/^\s+|\s+$/g, "") == "()"){
		/*BUG-163412: Using getLocalString API instead of string for localization*/
                var msgEmptyWorkItemId = pega.u.d.fieldValuesList.get("Empty Work Item ID");
		alert (msgEmptyWorkItemId);
         }else {  
		return pega.desktop.openWorkItem(strItemId, workpool,contentID,dynamicContainerID,configParams);
	}
}

/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.openWorkItem = function () {
  pega.control && pega.control.Actions && pega.control.Actions.prototype.showSkeleton && pega.control.Actions.prototype.showSkeleton();
  window.openWorkItem.apply(null, arguments);
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.openWorkByHandle = function () {
  pega.control && pega.control.Actions && pega.control.Actions.prototype.showSkeleton && pega.control.Actions.prototype.showSkeleton();
  window.openWorkByHandle.apply(null, arguments);
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.openAssignment = function () {
  pega.control && pega.control.Actions && pega.control.Actions.prototype.showSkeleton && pega.control.Actions.prototype.showSkeleton();
  window.openAssignment.apply(null, arguments);
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.launchFlowInModal = function () {
  //Class	Flow Params    Using Page
  /* US-58245: Send custom template name as 4th argument if present. */
  var oParams = [arguments[1], arguments[2], arguments[3], arguments[6] || ""];
  //First arg is flowName
  pega.u.d.launchFlow.showFlowInModal(arguments[0], oParams, arguments[4], arguments.length > 5 ? arguments[5] : '');
};
//static-content-hash-trigger-GCC
/*@protected chens3 - GRP-39284 - changes for postValue behaviour - start */
pega.control.Actions.prototype.postValue = function (e, updateDOM) {
  if(pega.u.d.ServerProxy.isDestinationLocal()){
    var src = pega.util.Event.getTarget(e);
    var srcValue = pega.u.d.getDOMElementValue(src);
    var spanEle = src;
    while(spanEle && spanEle.tagName && spanEle.tagName.toLowerCase()!="span"){
      spanEle = spanEle.parentNode;
    }
    if(src.getAttribute("data-ctl")=='["DatePicker"]' && (isNaN(srcValue) && srcValue.indexOf("GMT") == -1)){
      srcValue = pega.DateTimeUtil.convertDateTimeToGMT(srcValue,spanEle);
    }
    var propEntryHandle = src.name;
    if(!propEntryHandle){
      return;
    }
    /* To avoid posting value when field has error */
    if(window.getErrorDB && propEntryHandle && window.getErrorDB().isHavingError(propEntryHandle)) {
      return;
    }
    var srcProp = pega.ui.property.toReference(propEntryHandle);
    var srcProp_cc = pega.ui.ClientCache.find(srcProp);
    if(srcProp_cc){
      srcProp_cc.setValue(srcValue);
    }

  }else {
    pega.control.postValue.initiatePost(e, "ControlEvent", updateDOM);
  }

};
//static-content-hash-trigger-GCC
/*@protected New Close Container action added - Autobots. This action has been enhanced to handle modal dialog as well with the pop-over preempting the modal dialog*/
pega.control.Actions.prototype.closeContainer = function (e) {
  var popObj = null;
  if (e) {
    var target = pega.util.Event.getTarget(e);
    /* Open section MDC code */
    var mdcTarget = target.closest("div[data-mdc-recordid]");
    if(mdcTarget && mdcTarget.getAttribute("action") === "openSection") {
      var acName = mdcTarget.closest("div[data-mdc-id]").getAttribute("data-mdc-id");
      pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.CLOSE, {"mdcTarget":acName, "isFromOpenSection": true, "recordId": mdcTarget.getAttribute("data-mdc-recordid")}));
      if(pega.Mashup)
        {
          pega.u.d.resizeActionIFrame(true);
        }
      return;
    }
    
    /*BUG-342070 : target element is becoming stale*/
    if($(target).closest('body').length == 0){
      target = $('[name="'+target.name+'"]').get(0);
    }
    var level = pega.u.d.getPopOverLevel(target);
    if (level >= 0) {
      popObj = pega.u.d.getPopOver(level);
    }

  } else {
    popObj = pega.u.d.getPopOver();
  }
  if (popObj) {
    popObj.close("","","",target);
  } else if(pega.u.d.bModalDialogOpen && document.getElementById("modaldialog_con_dirty") && document.getElementById("modaldialog_con_dirty").offsetHeight!=0){
    /*BUG-160704 : just hide the modal window no need to send ajax request in case of dirty dialog*/
    if (pega.c && pega.c.actionSequencer && !pega.u.d.gIsScriptsLoading && !pega.u.d.isAjaxInProgress()) {
      pega.c.actionSequencer.resume();
    }
    pega.u.d.hideModalWindow();
  } else if (pega.u.d.bModalDialogOpen) {
    doModalAction("", e);
  }
};
//static-content-hash-trigger-GCC
pega.control.Actions.prototype.scanCode = function (e, propertyEntryHandle) {
/*
  // Uncomment this code to test property update and skip scan.

  var safeURL = SafeURL_createFromURL(pega.u.d.url),
  postData = propertyEntryHandle + "=" + "Test Bar Code!";
  callback = {
    success:function(response){
      alert(1);
    },
    failure:function(response){
      alert(0);
    }
  };

  safeURL.put("pyActivity", "pzScanCode");
  pega.u.d.asyncRequest("POST", safeURL, callback, postData);

  return;
*/

  // TODO: Read from field value reference.
  var notSupportedMessage = pega.u.d.fieldValuesList.get("ScanOnlyAvailableOnMobileApp");

  // @AUTOMATION to test property update and skip scan.
  if (pega.automation && pega.automation.scanCodeReturnMessage) {
    var launchBox = pega.mobile && pega.mobile.hybrid && pega.mobile.hybrid.getLaunchBox();
    if (launchBox  && !launchBox.BarcodeScanner) return; // also check if native api's are available
    var propRef = pega.u.property.toReference(propertyEntryHandle);
    var propNm = propRef.substr(propRef.indexOf('.')); ;
    var pageNm = propRef.substr(0, propRef.indexOf('.'));
    var tempResult = pega.automation.scanCodeReturnMessage;
    pega.u.d.setProperty(propNm, tempResult, pageNm);
    // Build the async request payload and send it.
    var safeURL = SafeURL_createFromURL(pega.ctx.url);
    // No need to encode the data as asyncRequest does that.
    //postData = propertyEntryHandle + "=" + tempResult,
    var postData = new SafeURL();
    postData.put(propertyEntryHandle, resultJson.data);
    callback = {
      success: function (response) {
        // alert("Property update succeeded.");
      },
      failure: function (response) {
        // alert("Property update failed.");
      }
    };
    safeURL.put("pyActivity", "pzScanCode");
    /*Call activity in online and skip it in OSCO*/
    var oscoHandler = {
      scope: this,
      online: function(oSafeURL, postData, callback) {
        try {
          pega.u.d.asyncRequest("POST", oSafeURL, callback, postData);
        } catch (exc) {
          //alert("Property update AJAX failed.");
          pega.u.d.resumeAjaxSequencer();
        }
      },
      offline: function() {
        /*RAIDV - Non need to set value in Client Cache because ServerProxy sets all postData appropriately*/
        pega.u.d.resumeAjaxSequencer();
      }
    };
    pega.u.d.ServerProxy.doAction(safeURL, postData, oscoHandler, callback);
    return;
  }

  function resolve(barcode) {
    pega.u.d.resumeAjaxSequencer();
    /*If editable control references this property, set the value on client first before sending it to the server*/
    /*RAIDV(BUG-178356): For embedded page property, pagename is just the top level page name
              so replaced lastIndexOf with indexOf. For property ref A.B.C, propNm is .B.C and pageNm is A*/
    var propRef = pega.u.property.toReference(propertyEntryHandle);
    var propNm, pageNm;
    if (propertyEntryHandle.indexOf("$l1$") >= 0) {
      propNm = propRef.substr(propRef.lastIndexOf("."));
      pageNm = pega.u.d.getBaseRef(e.srcElement) || SafeURL_createFromURL(pega.ctx.url).get("pzPrimaryPageName");
      propertyEntryHandle = pega.u.property.toHandle(pageNm + propNm);
      pega.u.d.setProperty(pageNm + propNm, barcode.data || barcode.value);
    } else {
      propNm = propRef.substr(propRef.indexOf('.'));
      pageNm = propRef.substr(0, propRef.indexOf('.'));
      pega.u.d.setProperty(propNm, barcode.data || barcode.value, pageNm);
    }
    // Build the async request payload and send it.
    var safeURL = SafeURL_createFromURL(pega.ctx.url);
    // No need to encode the data as asyncRequest does that.
    //var postData = propertyEntryHandle + "=" + resultJson.data,
    var postData = new SafeURL();
    postData.put(propertyEntryHandle, barcode.data || barcode.value);
    callback = {
      success : function (response) {
        // alert("Property update succeeded.");
      },
      failure : function (response) {
        // alert("Property update failed.");
      }
    };
    safeURL.put("pyActivity", "pzScanCode");
    /*Call activity in online and skip it in OSCO*/
    var oscoHandler = {
      scope: this,
      online: function(oSafeURL, postData, callback) {
        try {
          pega.u.d.asyncRequest("POST", oSafeURL, callback, postData);
        } catch (exc) {
          //alert("Property update AJAX failed.");
          pega.u.d.resumeAjaxSequencer();
        }
      },
      offline: function() {
        /*RAIDV - Non need to set value in Client Cache because ServerProxy sets all postData appropriately*/
        pega.u.d.resumeAjaxSequencer();
      }
    };
    pega.u.d.ServerProxy.doAction(safeURL, postData, oscoHandler, callback);
  }

  function reject(error) {
    pega.u.d.resumeAjaxSequencer();
  }
  if (typeof pmcRuntimeFeatures !== "undefined" && pmcRuntimeFeatures.pxBarcodeScanner) {
    // Support for PMC 8.x
    var options = { shutterMode: "auto" };
    pega.u.d.pauseAjaxSequencer();
    pega.mobile.sdk.plugins.barcode.scan(options).then(resolve).catch(reject);
  } else if (window.launchbox && window.launchbox.BarcodeScanner) {
    // Support for HC 7.x
    pega.u.d.pauseAjaxSequencer();
    var options = {scanMode: window.launchbox.BarcodeScanner.SCAN_MODE_ALL};
    try {
      window.launchbox.BarcodeScanner.scan(options, {onSuccess: resolve, onCancel: reject, onFailure: reject});
    } catch (ex) {
      alert(notSupportedMessage);
      pega.u.d.resumeAjaxSequencer();
    }
  } else {
    // Not a mobile client.
    alert(notSupportedMessage);
  }
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.setValue = function () {
  var arrLength = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    var name = arguments[i][0];
    var namePage = arguments[i][1];
    var value = arguments[i][2];
    var valuePage = arguments[i][3];
    var serverValue = arguments[i][4];
    if (value == '' && valuePage == '') {
      pega.u.d.setProperty(name, serverValue, namePage);
    } else {
      var clientValue = pega.u.d.getProperty(value, valuePage);
      // Date Time Timezone get source input element's timezone
      var propertyEntryHandle = null;
		  if (valuePage) {
			  propertyEntryHandle = pega.u.property.toHandle(value, valuePage);
		  } else {
			  propertyEntryHandle = pega.u.property.toHandle(value);
		  }
      var customTimezone;
		  var elements = pega.util.Dom.getElementsByName(propertyEntryHandle);
      if(elements && elements.length!=0){
        var firstElement = elements[0];
        if(firstElement.type=="hidden"){ // Value is already converted to operator timezone and set to hidden input value in case of allow text entry no
          customTimezone = pega.u.d.TimeZone || "America/New_York";
        } else{
          customTimezone = firstElement.getAttribute("data-custom-timezone");  
        }
      }
      
      if (clientValue) {
        pega.u.d.setProperty(name, clientValue, namePage, customTimezone);
      } else {
        pega.u.d.setProperty(name, serverValue, namePage, customTimezone);
      }
    }
  }
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.setItemFocus = function () {
  var arrLength = arguments.length;
  var propertyName = arguments[0];
  var pageName = arguments[1];
  try {
    var propertyEntryHandle = null;
    if (pageName) {
      propertyEntryHandle = pega.u.property.toHandle(propertyName, pageName);
    } else {
      propertyEntryHandle = pega.u.property.toHandle(propertyName);
    }
    if (propertyEntryHandle) {
      targetElem = pega.ctx.dom.getElementsByName(propertyEntryHandle);
      if (targetElem != null && targetElem != undefined) {
        var found = false;
        for (var l = 0; l < targetElem.length; l++) {
          if (targetElem[l] && targetElem[l].type != 'hidden' && targetElem[l].style.display != "none" && targetElem[l].style.visibility != "hidden") {
            targetElem = targetElem[l];
            found = true;
            break;
          }else if(targetElem[l].nodeName == "TEXTAREA" && targetElem[l].id && targetElem[l].id.indexOf("PEGACKEDITOR")>-1){
            if(CKEDITOR && CKEDITOR.instances){
              var ckEle = CKEDITOR.instances[targetElem[l].id];
              if(ckEle){
                targetElem = ckEle;
                found = true;
                break;
              }
            }
          }
        }
        // composite property like datetime with dropdown
        if (!found) {
          var elem = targetElem[0].parentNode;
          if (elem) {
            if (elem.hasChildNodes()) {
              var collection = elem.getElementsByTagName('*');
              var colLength = collection.length;
              for (var i = 0; i < colLength; i++) {
                var currentElem = collection[i];
                if (currentElem != null && (currentElem.nodeName == "INPUT" || currentElem.nodeName == "SPAN" || currentElem.nodeName == "SELECT" || currentElem.nodeName == "TEXTAREA") && (currentElem.type != "hidden" && currentElem.style.display != "none")) {
                  targetElem = currentElem;
                  found = true;
                  break;
                }
              }
            }
          }
        }
        if (found) {
          /* BUG-159574 - START: In IOS touch screen, setting focus by button click causing focus and immediate blur event on respective input element,
								adding a dummy blue handler which set focus again in to the input element and removing handler after some time out. */
          if (pega.cl && pega.cl.isTouchAble() &&
              (typeof(navigator.platform) == "string" && (navigator.platform.toLowerCase() == "ipad" || navigator.platform.toLowerCase() == "iphone"))) {
            var _targetElem = targetElem;
            var tempBlurHandler = function () {
              if (_targetElem) {
                _targetElem.focus();
                if (_targetElem.type == "textarea")
                  pega.u.d.setCursorAtEndofText(_targetElem);
                else if (_targetElem.select && _targetElem.select != undefined) {
                  _targetElem.select();
                }
              }
              setTimeout(function () {
                pega.util.Event.removeListener(_targetElem, "blur", tempBlurHandler);
              },10);
            }
            pega.util.Event.removeListener(_targetElem, "blur", tempBlurHandler);
            pega.util.Event.addListener(_targetElem, "blur", tempBlurHandler);
            /*Adding settimeout to remove the blurhandler incase the blur event is not invoked at all in iOS*/
            setTimeout(function () {
              pega.util.Event.removeListener(_targetElem, "blur", tempBlurHandler);
            }, 700);
            /* BUG-159574 - END */
          }
         /*BUG-371089-To avoid backward compatibility issues when using focus action on tab key */
          setTimeout(function(){
            targetElem.focus();
          if (targetElem.type == "textarea") {
            pega.u.d.setCursorAtEndofText(targetElem);
          } else if (targetElem.select && targetElem.select != undefined) {
            targetElem.select();
          }},0);  
        }
      }
    }
  } catch (e) {}
};
//static-content-hash-trigger-GCC
/*
 @protected - This function will show a harness in a new tab of work area gadget.
 @param $String$tabName – Tab name of the work area gadget.
 @param $String$className - Class where harness and activity belongs.
 @param $String$harnessName -  Name of the harness to be shown.
 @param $String$preActivityName - Activity name before displaying harness.
 @param $String$preActivityParams  - Parameters of preActivity. Format: Comma sperated key:value string.
 @param $String$keyValue - unique id to open work object or data instance
 @param $String$readOnly - attribute to define whether to open harness in readonly or read/write mode
 @return $void$ - .
 */

pega.desktop.showHarness = function(tabName, className, harnessName, preActivityName, preActivityParams, keyValue, readOnly, preDataTransformName, replaceCurrent, skipConflictCheck, contentID, dynamicContainerID, skipReload, usingPage, accessFromServer, pmcOptions) {  
  
  var oSafeURL = new SafeURL();
  oSafeURL.put("name", tabName);
  oSafeURL.put("ClassName", className);
  oSafeURL.put("HarnessName", harnessName);
  oSafeURL.put("preActivityName", preActivityName);
  oSafeURL.put("preActivityParams", preActivityParams);
  try {
    if (typeof preActivityParams === 'object' || JSON.parse(preActivityParams)){
      preActivityParams = JSON.parse(preActivityParams);
      preActivityDynamicParams = JSON.stringify(preActivityParams.preActivityDynamicParams);
      delete preActivityParams.preActivityDynamicParams;
      preActivityParams = JSON.stringify(preActivityParams);
      if(preActivityDynamicParams && preActivityDynamicParams != "null"){
        oSafeURL.put("preActivityDynamicParams", preActivityDynamicParams);
      }
      oSafeURL.put("preActivityParams", preActivityParams);
    }
  } catch (e) {
  }

  /*US-102708: passing accessFromServer value*/
  if (accessFromServer) {
    oSafeURL.put("accessFromServer", accessFromServer);
  }
  /*BUG-211401: passing the using page for replace current scenario*/
  if (usingPage) {
    oSafeURL.put("page", usingPage);
  }
  // BUG-96226 03/06/2013 GUJAS1 Added null check for ContentID & DCID.
  if (contentID != null) {
    oSafeURL.put("contentID", contentID);
  }
  if (dynamicContainerID != null) {
    oSafeURL.put("dynamicContainerID", dynamicContainerID);
  }
  if (skipConflictCheck != null)
    oSafeURL.put("SkipConflictCheck", skipConflictCheck);
  if (keyValue != null) {
    oSafeURL.put("key", keyValue);
  }
  if (readOnly != null) {
    oSafeURL.put("readOnly", readOnly);
  }
  if (skipReload != null) {
    oSafeURL.put("pySkipReload", skipReload);
  }
  if (pmcOptions != null) {
    oSafeURL.put("pmcOptions", pmcOptions);
  }

  if (preDataTransformName != null) {



    // BUG-68359 05/11/2012 GUJAS1 Append Data Transform and Params together as Model.
    //BUG-161102 -HFix-9642 : changing the encoding logic of data transform params
    var dataTransformParamsStr = '';
    var dataTransformName = '';
    if (preDataTransformName.indexOf("pyDataTransform=") != "-1") {
      if (preDataTransformName.indexOf("&") != "-1") {
        var dataTransformArr = preDataTransformName.split("&");
        for (var i = 0; i < dataTransformArr.length; i++) {
          var paramPair = dataTransformArr[i].split("=");
          if (paramPair[0] == "pyDataTransformParams") {
            dataTransformParamsStr = paramPair[1]; //unescaped value with [ and " characters escaped.

          }
        }
      }
      oSafeURL.put("model", encodeURIComponent(preDataTransformName.replace(dataTransformParamsStr, '')) + dataTransformParamsStr);

    } else {

      try {
        //remove the encoding done to the datatransform parameters - effectively returns the proper JSON string
        //The parameter values themselves should not be encoded
        preDataTransformName = decodeURIComponent(preDataTransformName);
      } catch (e) {
        //will get an error is the input string is indeed not a fully encoded string but has '%' character in it
        // no action required in that case
      }
      // The decode-encode pairing is required to reset partial encoded values coming in the preDataTransformName argument.
      /* BUG-377206: HFix-44806 Check if the preDataTransformName is a proper JSON and donot encode again if it is */
      var jsonParams = false;
      try{
        if(JSON.parse(preDataTransformName)){
          jsonParams = true;
        }
      }catch(e){}
      if(jsonParams){
        var preDTConfig = preDataTransformName;
        try{
          preDataTransformName = JSON.parse(preDataTransformName);
          var dtdynamicParams = preDataTransformName.pyDataTransformDynamicParams;
          if(dtdynamicParams){
            oSafeURL.put("pyDataTransformDynamicParams", JSON.stringify(dtdynamicParams));
          }
          delete preDataTransformName.pyDataTransformDynamicParams;
          oSafeURL.put("model", JSON.stringify(preDataTransformName));
        }catch(e){
          oSafeURL.put("model", preDTConfig);
        }
      }else{
         oSafeURL.put("model", encodeURIComponent(preDataTransformName));
      }
       
    }

  }
  
  /* set tabname for MDC */
  oSafeURL.put("tabName", tabName);

  //augment config params to oSafeURL
  pega.desktop.augmentConfigParams({}, oSafeURL);


  if (replaceCurrent != null) {
    oSafeURL.put("replaceCurrent", replaceCurrent);
  }
  return pega.desktop.support.openSpace("Work", oSafeURL, "showHarness");
}

pega.desktop.showHarnessWrapperForNoRefresh = function() {
  var target = arguments[0];
  var tabName = arguments[1];
  var className = arguments[2];
  var harnessName = arguments[3];
  var readOnly = arguments[4];
  var key = arguments[5];
  var preActivity = arguments[6];
  var activityParameters = {};
  var ruleClass = arguments[7];
  var appliesToClass = arguments[8];
  var action = arguments[9];
  var showInstances = arguments[10];
  var label = arguments[11];
  
  var preActivityDynamicParams = {};
  
  preActivityDynamicParams["RuleClass"] = ruleClass;
  preActivityDynamicParams["AppliesToClass"] = appliesToClass;
  activityParameters["preActivityDynamicParams"] = preActivityDynamicParams;
  
  activityParameters["Action"] = action;
  activityParameters["ShowInstances"] = showInstances;
  activityParameters["Label"] = label;
  
  var dataTransform = arguments[12];

  if (target === "newDocument") {
    pega.desktop.showHarnessWrapper(target, className, harnessName, preActivity, activityParameters, "", tabName, "", readOnly, dataTransform, "false", "", "", "", "true", "true");
  }
}


pega.desktop.showHarnessWrapper = function() {
  var harCtxMgr = pega.ui.HarnessContextMgr;
  var target = arguments[0];
  var className = arguments[1];
  var harnessName = arguments[2];
  var preActivityName = arguments[3];
  var preActivityParams, receivedActParams, preActivityDynamicParams;
  try {
    if (typeof arguments[4] === 'object' || JSON.parse(arguments[4])){
      preActivityParams = arguments[4];
      receivedActParams = JSON.stringify(arguments[4]);
      preActivityDynamicParams = JSON.stringify(preActivityParams.preActivityDynamicParams);
      delete preActivityParams.preActivityDynamicParams;
      preActivityParams = JSON.stringify(preActivityParams);
    }
  } catch (e) {
       receivedActParams = preActivityParams = arguments[4];
  }

  var pzPrimaryPage = arguments[5];
  var pyUsingPage = arguments[11];
  var contentID = "";
  var skipConflictCheck = arguments[14];
  var skipReload = arguments[15];
  var accessFromServer = arguments[16];
  var pmcOptions = arguments[18];

  
  // inform perfmon of work in progress - triggers update to PAL on ui completion
  if (pega && pega.ui && pega.ui.statetracking) pega.ui.statetracking.setPALInteraction("abc?action=display&className="+className+"&harnessName="+harnessName);

  // TASK-153772 GUJAS1 Default skipConflictCheck value to true.
  if (skipConflictCheck == null || skipConflictCheck == "" || typeof skipConflictCheck == "undefined") {
    skipConflictCheck = true;
  }

  if (typeof (arguments[12]) != "undefined") {
    contentID = arguments[12];
  }

  var dynamicContainerID = "";
  if (typeof (arguments[13]) != "undefined") {
    dynamicContainerID = arguments[13];
  }
  var usingPage = pyUsingPage ? pyUsingPage : pzPrimaryPage; // BUG-70794 & BUG-70797: check usingPage


  var event = arguments[arguments.length - 1];
  var preDataTransformName,receivedDTParams,pyDataTransformDynamicParams;
  try {
    if (typeof arguments[9] === 'object' || JSON.parse(arguments[9])){
      preDataTransformName = ((arguments[9] === event) ? "" : arguments[9]);
      receivedDTParams = JSON.stringify((arguments[9] === event) ? "" : arguments[9]);
      pyDataTransformDynamicParams = JSON.stringify(preDataTransformName.pyDataTransformDynamicParams);
      delete preDataTransformName.pyDataTransformDynamicParams;
      preDataTransformName = JSON.stringify(preDataTransformName);
    }
  } catch (e) {
      receivedDTParams = preDataTransformName = (arguments[9] === event) ? "" : arguments[9];
  }
  
  var replaceCurrent = false;
  if (event === "null")
    event = undefined;
  // BUG-79596 GUJAS1 10/10/2012 Use pega.u.d.url when possible to preserve thread names.
  var oSafeURL;
  if (pega.u.d && pega.u.d.url) {
    oSafeURL = SafeURL_createFromURL(pega.u.d.url);
    // Bug-122271 : kumad1 9/13/2013 - code added to fix transaction mismatch
    if (pega.u.d.fixBaseThreadTxnId) {
      pega.u.d.fixBaseThreadTxnId(oSafeURL);
    }
  }
  else {
    oSafeURL = new SafeURL();
  }
  var name = undefined
    , result = undefined
    , windowName = undefined
    , keyValue = undefined
    , readOnly = false;
  if (pmcOptions) {
    oSafeURL.put("pmcOptions", pmcOptions);
  }
  if(target === "microDC_static"){
    target = "microDC";
    oSafeURL.put("isStatic", "true");
  }
  if (target === "microDC") {
    var acTargetName = arguments[6];
    oSafeURL.put("action", "display");
    oSafeURL.put("mdcTarget", acTargetName);
    oSafeURL.put("harnessName", harnessName);
    oSafeURL.put("className", className);
    readOnly = arguments[8] === "Yes" ? "true" : "false";
    oSafeURL.remove('pzPrimaryPageName');
    oSafeURL.remove('pzFromFrame');
    oSafeURL.put("preActivity", preActivityName);
    oSafeURL.put("preActivityParams", preActivityParams);
    if(preActivityDynamicParams && preActivityDynamicParams != "null"){
      oSafeURL.put("preActivityDynamicParams", preActivityDynamicParams);
    }

    oSafeURL.put("model", preDataTransformName);
    if(pyDataTransformDynamicParams){
      oSafeURL.put("pyDataTransformDynamicParams", pyDataTransformDynamicParams);
    }
    oSafeURL.put("pyPreActivity", "doUIAction");
    oSafeURL.put("readOnly", readOnly);
    
   
    if (arguments[17]) {
      oSafeURL.put("tabName", arguments[17]);
      oSafeURL.put("name", arguments[17]);
    }

   
    
    if (pega.desktop.support.openSpace("Work", oSafeURL, "showHarness")) {
      return true;
    }
    oSafeURL.remove("target");
    target = "newDocument";
  }
  if (target === "newDocument") {
    name = arguments[6];
    keyValue = arguments[7];
    readOnly = arguments[8] === "Yes" ? "true" : "false";

    if (pega.d.s.getDesktopType() == "Composite") {
      result = pega.d.showHarness(name, className, harnessName, preActivityName, receivedActParams, keyValue, readOnly, receivedDTParams, replaceCurrent, skipConflictCheck, contentID, dynamicContainerID, skipReload, "", accessFromServer, pmcOptions);
      //pega && pega.control && pega.control.Actions && pega.control.Actions.prototype.hideSkeleton && pega.control.Actions.prototype.hideSkeleton();
    }
  }
  /* In case of replace current as target we need to call hideSkeleton */
  /* BUG-383963 */
  if((pega && pega.ctx && !pega.ctx.isUITemplatized) || target === "newDocument" || target === "current"){
    pega.control && pega.control.Actions && pega.control.Actions.prototype && pega.control.Actions.prototype.hideSkeleton(undefined,600);
  }
  if (arguments[17]) {
    oSafeURL.put("pzKeepPageMessages", arguments[17]);
  }
  if (target === "popup" || target === "current" || (target === "newDocument" && !result)) {
    oSafeURL.put("preActivity", preActivityName);
    oSafeURL.put("preActivityParams", preActivityParams);
    oSafeURL.put("action", "display");
    oSafeURL.put("harnessName", harnessName);
    oSafeURL.put("className", className);
    if(preActivityDynamicParams && preActivityDynamicParams != "null"){
      oSafeURL.put("preActivityDynamicParams", preActivityDynamicParams);
    }

  }

  if (target === "popup" || target === "current") {
    // Line below is commented out to fix BUG-68570
    //oSafeURL.put("Model", preDataTransformName);

    oSafeURL.put("pyActivity", "@baseclass.pzTransformAndRun");
    oSafeURL.put("pyDataTransform", preDataTransformName);
    if(pyDataTransformDynamicParams){
      oSafeURL.put("pyDataTransformDynamicParams", pyDataTransformDynamicParams);
    }
    oSafeURL.put("pyPreActivity", "doUIAction");

    if (contentID == "" && target === "current")
      contentID = "_blank";

    // BUG-70794 & BUG-70797: Added usingPage if present or pzPrimaryPage is used.

    if (usingPage != "") {
      oSafeURL.put("pzPrimaryPage", usingPage);
      oSafeURL.put("pzPrimaryPageName", usingPage);
    } else {
      // BUG-86200 - show harness action for grid action needs to determine the usingPage at runtime -
      // The usingPage is empty in generation for these actions
      if (arguments[10] != null && typeof (Grids) != "undefined" && Grids)
      {
        var grid = Grids.getActiveGrid(arguments[10]);
        if (grid != null) { //Check if source is in Sequoia
          if (!grid.isLastEventFromRow) { //Check whether event was from row or action top/bottom
            oSafeURL.put("pzPrimaryPage", grid.gridReferencePage);
            oSafeURL.put("pzPrimaryPageName", grid.gridReferencePage);
          } else {
            var rtRow = grid.getRightRow();
            if (rtRow) {
              var rowPage = rtRow.hpref ? rtRow.hpref : rtRow.id;
              var contextPage = pega.u.property.toReference(rowPage);
              oSafeURL.put("pzPrimaryPage", contextPage);
              oSafeURL.put("pzPrimaryPageName", contextPage);
            }
          }
        }
      }
    }

    oSafeURL.put("checkForNewPage", true);
  }


  if (target === "newDocument" && !result) {
    oSafeURL.put("pyActivity", "@baseclass.doUIAction");
    oSafeURL.put("model", preDataTransformName);
    if(pyDataTransformDynamicParams){
      oSafeURL.put("pyDataTransformDynamicParams", pyDataTransformDynamicParams);
    }
    windowName = name;
    oSafeURL.put("frameName", windowName);
    oSafeURL.put("readOnly", readOnly);
    if (pega.u.d.portalName !== undefined && pega.u.d.portalName !== ""){
      oSafeURL.put("portalName", pega.u.d.portalName);
    }

    if(window.pms) {
      var pxReqURI = pega.ctx.pxReqURI;
      var tabName = arguments[6].replace(/\s/g, '');
      
      pxReqURI = pxReqURI.substring(0,pxReqURI.indexOf("*/!")+3)+tabName;
      oSafeURL.put("pxReqURI", pxReqURI);
    }
    oSafeURL.put("target", "popup");
    pega.desktop.support.openUrlInWindow(oSafeURL, windowName, windowOptions, true);
  } else if (target === "popup") {
     
    var readOnly = arguments[6] === "Yes" ? "true" : "false";
    var windowOptions = arguments[7];
    windowName = arguments[8];
    oSafeURL.put("readOnly", readOnly);
    oSafeURL.put("frameName", windowName);
    oSafeURL.put("target", target);
    pega.desktop.support.openUrlInWindow(oSafeURL, windowName, windowOptions, true);
  } else if (target === "current") {
    if(pega.ctx &&  pega.ctx.isAPopupWindow){
        oSafeURL.put("target", "popup");
    }
    if (!pega.ctx.bIsDCSPA && !pega.ctx.isMDC) {
      oSafeURL.put("switchtoPOST", "true");
    }
    if (pega.u.d.portalName != undefined && pega.u.d.portalName != "")
      oSafeURL.put("portalName", pega.u.d.portalName);
    if (pega.u.d.getThreadName() != undefined && pega.u.d.getThreadName() != "" && pega.u.NavigateTopHandler)
      oSafeURL.put("portalThreadName", pega.u.d.getThreadName());

    var bSubmit = arguments[6];
    readOnly = arguments[8] === "Yes" ? "true" : "false";
    var tabName = arguments[7];
    oSafeURL.put("contentID", contentID);
    if (bSubmit != 'Yes' || (pega.mobile && pega.mobile.isMultiWebViewOfflinePegaMobileClient))
      oSafeURL.put("readOnlyMode", readOnly);


    var app = pega.desktop.support.getDesktopApplication();
    var WAgadget = null;

    if (app) {
      var gadgetPool = app.gadgetPool;
      if (gadgetPool) {
        WAgadget = gadgetPool.findAvailableGadget();
      }
    }

    if (WAgadget && WAgadget.gadgetAvailable) {
      replaceCurrent = true;
      if (bSubmit == 'Yes' && !harCtxMgr.get("bIsDCSPA")) {
        oSafeURL.put("label", tabName);
        // Replace current in ajax container
        if (pega.ctx.isMDC) {
          oSafeURL.put("tabName", tabName);
        }
        oSafeURL.put("api", "setDocumentLabel");
        oSafeURL.put("readOnlyMode", readOnly);

        var noOfForms = document.forms.length;
        if (noOfForms > 0) {
          try {
            var desktopWin = pega.desktop.support.getDesktopWindow();
            if ((desktopWin && desktopWin.pega.ctx && !desktopWin.pega.ctx.bIsDCSPA && !pega.ctx.isMDC) && !desktopWin.pega.desktop.PopupCtrl.isWindowPopped(window.name) && !pega.u.NavigateTopHandler) { /* shasi - US-33167- No need of this action when an action occurs in the popup*/
              if (!(window.opener && /Ifr$/g.test(window.opener.name))) { /* BUG-168049: Popup window is sending the event to change the document label. Avoiding it for popup window whch is opened from DC iframe */
                pega.desktop.sendEvent("DesktopAction", oSafeURL, "SYNC");
              }
            }
          } catch (e) {
          }
          //BUG-161102 - for HFix-9642 - sending safeurl object instead of the string value as sendig string will create double encoding in form submit
          pega.u.d.submit(oSafeURL, this, '', event);
          return;
        }

        if (pega.offline && pega.offline.NetworkStatus.STATE_OFFLINE == pega.offline.NetworkStatus.isDataNetworkAvailable()) {
          // is offline
          toggleLeftSidebar();
          removeScreenLayoutMask();
          /* BUG-383963 */
          if((pega && pega.ctx && !pega.ctx.isUITemplatized) || target === "newDocument" || target === "current"){
            pega.control && pega.control.Actions && pega.control.Actions.prototype && pega.control.Actions.prototype.hideSkeleton(undefined,600);
          }
        } else {
          //is Online
          oSafeURL.put("api", "submitDocumentContent");
          oSafeURL.put("callbackFn",
            function() {
              pega.d.showHarness(tabName, className, harnessName, preActivityName, receivedActParams, keyValue, readOnly, receivedDTParams, replaceCurrent, skipConflictCheck, contentID, dynamicContainerID, skipReload, usingPage, null, pmcOptions);
            });
          var tabcontent = pega.desktop.sendEvent("DesktopAction", oSafeURL, "SYNC");
        }

      } else {
        // BUG-92910 02/01/2013 GUJAS1 Specified "false" for skipConflictCheck param in showHarness calls.
        if (pega.offline) {
          pega.d.showHarness(tabName, className, harnessName, preActivityName, receivedActParams, keyValue, readOnly, receivedDTParams, replaceCurrent, skipConflictCheck, contentID, dynamicContainerID, skipReload, "", accessFromServer, pmcOptions);
        } else {
          if(harCtxMgr.get("bIsDCSPA") && pega.u.d.UIActionRouter.singlePageRenderer && !pega.ctx.isMDC){
            oSafeURL.put("isURLReady","true");
            oSafeURL.put("readOnlyMode", readOnly);
            oSafeURL.put("submitCurrent", bSubmit);
            var postSubmitData;
            if(bSubmit == 'Yes'){
              if (document.forms && document.forms.length) {
                var formEle = document.forms[0];
                if(formEle.encoding == "multipart/form-data"){
                  postSubmitData = new FormData(formEle);
                } else {
                  postSubmitData = pega.u.d.getQueryString(formEle);
                }
              } else if (document.getElementsByTagName("main").length) {
                postSubmitData = pega.u.d.getQueryString(document.getElementsByTagName("main")[0]);
              }
            }
            pega.u.d.UIActionRouter.singlePageRenderer(oSafeURL, postSubmitData);
          }else{
            pega.u.d.replace(oSafeURL.toURL());
          }
        }
        return;
      }

    } else {
      var win = pega.desktop.support.getDesktopWindow();

      var t;
      if (pega.d.s.getDesktopType() == 'Composite') {
        // [ BUG-70664 05/16/2012 GUJAS1 - Ensure WA is multiview before fetching tab details.
        if (WAgadget && WAgadget._multiView) {
          // BUG-70664 05/16/2012 GUJAS1 - Ensure WA is multiview before fetching tab details. ]
          var objGadget = win.pega.composite.objMultiView._objGadget.manager.getGadgetByKey(tabName);

          if (!objGadget)
            t = win.pega.composite.container.tabDisplay.getCurrentTab();
          else
            t = win.pega.composite.objMultiView._objGadget.manager.getTabByGadgetName(objGadget.gadgetName);

          if (!tabName)
            tabName = t.label;

          if (bSubmit != 'Yes') {
            // BUG-70794 & BUG-70797: "preDataTransformName" should be filtered
            receivedDTParams = encodeURIComponent(decodeURIComponent(receivedDTParams));
            win.pega.composite.objMultiView._objGadget.manager.replaceTab(t, tabName, {close: "yes", key: ""},
            {action: "display", page: "", model: receivedDTParams, harnessName: harnessName, className: className,
              configObj: {}, preActivity: preActivityName, preActivityParams: receivedActParams,
              readOnly: readOnly, tabName: tabName});
          }

          win.pega.composite.objMultiView._objGadget.manager.focusTab(t);
          //[ BUG-70664 05/16/2012 GUJAS1 - Ensure WA is multiview before fetching tab details.
        }
        else {
          if (WAgadget) {

            // Handle replace current for single view.
            // TASK-153772 GUJAS1 Send skipConflictCheck value as true.
            pega.d.showHarness("", className, harnessName, preActivityName, receivedActParams,
              "", readOnly, receivedDTParams, replaceCurrent, true, contentID, dynamicContainerID, null, null, null, pmcOptions);
          }
          else {
            pega.u.d.replace(oSafeURL.toURL());
            return;
          }
        }
        // BUG-70664 05/16/2012 GUJAS1 - Ensure WA is multiview before fetching tab details. ]
      } else {
        if (win && win.pega.desktop.DesktopTabControl) {

          t = win.pega.desktop.DesktopTabControl.tabArray.activeTab;
          if (!tabName){
            tabName = t.label;
 	      }
          t.setTitle(tabName);
        }
        if (bSubmit !== 'Yes'){
          pega.u.d.replace(oSafeURL.toURL());
        }
      }

      if (bSubmit == 'Yes') {
        if (tabName && t && t.setLabel) {
          t.setLabel(tabName);
        }

        oSafeURL.put("readOnlyMode", readOnly);
        pega.u.d.submit(oSafeURL, this, '', event);
      }
    }

  }
}


/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.showHarnessWrapper = function () {
  pega.control && pega.control.Actions && pega.control.Actions.prototype.showSkeleton && pega.control.Actions.prototype.showSkeleton();  
  pega.d.showHarnessWrapper.apply(pega.d, arguments);
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@param $undefined$strSectioName – parameter description goes here.
@param $undefined$strHeader – parameter description goes here.
@param $undefined$event – parameter description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.showSmartInfo = function (strSectioName, strHeader, event, dismissSmartInfo, format) {
  pega.u.smartinfo.showSmartInfo(strSectioName, strHeader, event, dismissSmartInfo, format);
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@param $undefined$event – parameter description goes here.
@param $undefined$format – parameter description goes here.
@param $undefined$tipMsg – parameter description goes here.
@param $undefined$headerMsg – parameter description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.showSmartTip = function (event, format, tipMsg, headerMsg) {
  var targetElement = pega.util.Event.getTarget(event);
  if (targetElement.__SmartTipVisible == undefined || targetElement.__SmartTipVisible == null) {
    targetElement.__SmartTipVisible = true;
    var bodyMouseMoveHandler = function (e) {
      var sourceEle = pega.util.Event.getTarget(e);
      var eventX = pega.util.Event.getPageX(e);
      var eventY = pega.util.Event.getPageY(e);
      var currEle = pega.c.mouseOverEle;
      var eleLeft = Math.round(pega.util.Dom.getX(currEle));
      var eleTop = Math.round(pega.util.Dom.getY(currEle));
      var eleRight = eleLeft + currEle.offsetWidth;
      var eleBottom = eleTop + currEle.offsetHeight;

      if (!((eventX >= eleLeft && eventX <= eleRight) && (eventY >= eleTop && eventY <= eleBottom)) && !$(targetElement).is(":hover")) {
        var isMultiselect = (sourceEle && sourceEle.classList && sourceEle.classList.contains("ms-primary-option"))? true : false;
        if(!isMultiselect)
        pega.u.d.getPopOver(targetElement).close();
      }
    };
    
    var targetFocusOutHandler = function () {
      if (!$(targetElement).is(":focus") && targetElement.__SmartTipVisible ) {
        pega.u.d.getPopOver(targetElement).close();
      }
    };

    var smartTipBeforeCloseHandle = function () {
      pega.util.Event.removeListener(document.body, 'mousemove', bodyMouseMoveHandler);
      pega.util.Event.removeListener(targetElement, 'focusout', targetFocusOutHandler);
      targetElement.__SmartTipVisible = undefined;

      //begin accessibility task for smart tip, US-39833

      var idOfHiddenATSpanElement = targetElement.getAttribute("aria-describedby");

      var hiddenATSpanElement = document.getElementById(idOfHiddenATSpanElement);
      if (hiddenATSpanElement)
        document.body.removeChild(hiddenATSpanElement);

      if (!window.chrome)
        targetElement.removeAttribute("role");
      targetElement.removeAttribute("aria-describedby");
      targetElement.removeAttribute("aria-controls");
      targetElement.removeAttribute("aria-owns");

      //end accessibility task for smart tip, US-39833

      return true;
    };

    var contElem = document.createElement("div");
    //contElem.className = "smartTipContent";
    if (headerMsg !== undefined) {
      var header = document.createElement("div");
      //BUG-427619-START
      if(typeof(headerMsg) === "string" && headerMsg.toLowerCase().indexOf("<script>") != -1 && headerMsg.toLowerCase().indexOf("</script>") != -1){
        headerMsg = new Option(headerMsg).innerHTML;
      }
      //BUG-427619-END
      //HFix-49284 added call to filterRichText
      //BUG-672775, filterRichText api is not able to fix all usecases: using Dompurify to prevent XSS
      headerMsg = DOMPurify.sanitize(headerMsg)
      header.innerHTML = headerMsg;
      header.className = "smarttip-header";
      contElem.appendChild(header);
    }

    var tip = document.createElement("div");
    if(typeof(tipMsg) === "string" && tipMsg.toLowerCase().indexOf("<script>") != -1 && tipMsg.toLowerCase().indexOf("</script>") != -1){
      tipMsg = new Option(tipMsg).innerHTML;
    }
    //HFix-49284 added call to filterRichText
    //BUG-672775, filterRichText api is not able to fix all usecases: using Dompurify to prevent XSS
    tipMsg = DOMPurify.sanitize(tipMsg)
    tip.innerHTML = tipMsg;
    tip.className = "smarttip-content";
    contElem.appendChild(tip);

    var tempElem = document.createElement("div");
    tempElem.appendChild(contElem);

    var _popOver = pega.u.d.getPopOver(targetElement);
    var contentClass = 'smarttip-container';
    if (format != '')
      contentClass += ' smarttip-container-' + format;
    _popOver.open({
      content : {
        type : 'domElement',
        element : tempElem
      },
      buttons : {
        ok : false,
        cancel : false
      },
      bindings : {
        associatedElement : targetElement
      },
      visual : {
        displayLoader : false,
        contentClass : contentClass,
        arrowDivClasses : ['arrow top', 'arrow bottom', 'arrow right', 'arrow left']
      },
      position : {
        fieldAttach : 'leftBottom',
        popOverAttach : 'leftTop',
        mouseOrTouchPositionX : pega.util.Event.getPageX(event),
        size : {
          min : {
            x : 20,
            y : 20
          }
        },
        offsetAttach : {
          y : 7
        }
      },
      extraParams : {
        refresh : false,
        overflow : false
      },
      callbacks : {
        onBeforeClose : smartTipBeforeCloseHandle
      }
    });

    //begin accessibility task for smart tip, US-39833
    if(pega && pega.u && pega.u.d && pega.u.d.isAccessible){
      targetElement.blur();
    }


    function _generateAccessibleText(tMsg, hMsg) {
      if (!hMsg || (typeof hMsg != "string"))
        hMsg = "";
      else if (/\.$/.test(hMsg)) //string ends with a fullstop
        hMsg += " ";
      else
        hMsg += ". ";

      if (!tMsg || (typeof tMsg != "string"))
        tMsg = "";
      else if (!(/\.$/.test(tMsg))) //string does not end with a fullstop
        tMsg += ".";

      var accessibleSmartTipText = hMsg + tMsg;

      return (accessibleSmartTipText);

    }

    function _generateUniqueHTMLElementId() {
      var rndNum = Math.random();
      rndNum = rndNum.toString().replace("0.", "");
      return ("stc" + rndNum);
    }

    var idOfHiddenATSpanElement = _generateUniqueHTMLElementId();

    var readableATText = _generateAccessibleText(tipMsg, headerMsg);

    var hiddenATSpanElement = document.createElement("span");

    hiddenATSpanElement.innerHTML = readableATText;

    hiddenATSpanElement.setAttribute("id", idOfHiddenATSpanElement);

    hiddenATSpanElement.setAttribute("role", "tooltip");

    hiddenATSpanElement.style.display = "none";

    document.body.appendChild(hiddenATSpanElement);

    if (!window.chrome)
      targetElement.setAttribute("role", "dialog");
    targetElement.setAttribute("aria-describedby", idOfHiddenATSpanElement);
    targetElement.setAttribute("aria-controls", idOfHiddenATSpanElement);
    targetElement.setAttribute("aria-owns", idOfHiddenATSpanElement);

    //our focus() call should not trigger anything else, e.g. :: on focus of input field, refresh section
    //also for $.one, the events cross-browser might have to be focus, focusin, focusout, etc.
    //finally, ensure that doing event.stopImmediatePropagation() does not also prevent JAWS itself from announcing what is focused
    //have not yet come across a use case where this is needed, this line has been retained for possible future usage
    //$(targetElement).one("focus", function(e){e.stopImmediatePropagation(); return false;});

    //Bug-163495 Added isAccessible condition to set focus only for accessibility cases
    if(pega && pega.u && pega.u.d && pega.u.d.isAccessible){
      targetElement.focus();
    }
    //end accessibility task for smart tip, US-39833

    pega.c.mouseOverEle = targetElement;
    pega.util.Event.addListener(document.body, 'mousemove', bodyMouseMoveHandler);
    pega.util.Event.addListener(document.body, 'touchmove', bodyMouseMoveHandler);
    //dismiss smarttip on focusout in nested popups
    if((document.getElementById("_popOversContainer")).contains(targetElement))
      pega.util.Event.addListener(targetElement, 'focusout', targetFocusOutHandler);
    
    var popOverContainerElem = _popOver.getContentContainerElement();
    var arrowBorderDiv = pega.util.Dom.getElementsById("arrow-border", popOverContainerElem, "DIV");
    if (headerMsg == undefined) {
      if (arrowBorderDiv[0].className.indexOf("noHeader") === -1) {
        pega.util.Dom.addClass(arrowBorderDiv[0], "noHeader");
      }
    } else if (arrowBorderDiv[0].className.indexOf("noHeader") !== -1) {
      pega.util.Dom.removeClass(arrowBorderDiv[0], "noHeader");
    }
  }
};
//static-content-hash-trigger-YUI
/*@protected Autobots Sprint 12 & BUG-42030 - Show Menu Action - Start */
pega.control.Actions.prototype.showMenu = function (paramObj, event, gridObj) {
  var navRuleName = paramObj.dataSource,
      className = paramObj.className,
      menuAlign = paramObj.menuAlign,
      format = paramObj.format,
      ellipsisAfter = paramObj.ellipsisAfter,
      usingPage = paramObj.usingPage,
      target = {},
      posObj = {};

  var pzMenu = (paramObj.isNavTypeCustom === "false"),
      useNewMenu = (paramObj.useNewMenu === "true");
  /* BUG-196024: Setting useNewMenu to false for quirks. */
  if(pega && pega.u && pega.u.d && pega.u.d.inStandardsMode === false) {
    useNewMenu = false;
  }

  if (typeof(usingPage) == "undefined" || usingPage == null) {
    var usingPage = "";
  }
  if (event) {
    target = pega.util.Event.getTarget(event);
    /* To position the menu correctly, we need to climb up to the parent-node that has data-ctl attribute */
    while (target && target.attributes && !target.attributes['data-ctl']) {
      target = target.parentNode;
    }
    /* Added this code for grid actions - will be refactored */
    if (target && !target.attributes) {
      target = pega.util.Event.getTarget(event);
    }
  }
  posObj = {
    x : pega.util.Event.getPageX(event),
    y : pega.util.Event.getPageY(event),
    relativeElement : target,
    align : menuAlign,
    pyFormat : format,
    maxChars : ellipsisAfter,
    usingPage : usingPage
  };
  // BUG-325854: Not from Server Grid (Template Grid seems to get an extra argument though unused)
  if(gridObj && !gridObj.gridDiv)
    gridObj = null;

  if (window.Grids && pega.ctx.Grid) {
    if(!gridObj)
      gridObj = Grids.getActiveGrid(event);

    /* BUG-265106: Check if there is a section in the grid cell */
    var sectionDiv = pega.u.d.getSectionDiv(event.target);
    if(gridObj && jQuery.contains(gridObj.gridDiv, sectionDiv) && gridObj.gridcontDiv && jQuery(gridObj.gridcontDiv).find("[data-repeat-source]").length > 0) {
      gridObj = null;
    }
  }

  //Bug-64767: check if the event is from a repeat layout to set the right page context
  if (event != null) {
    var contextPage = pega.u.d.getBaseRef(pega.util.Event.getTarget(event));
    if (pega.u.d.isInRepeat(pega.util.Event.getTarget(event))) { //Check whether event came from a repeat grid
      var row = pega.u.d.getRepeatRow(pega.util.Event.getTarget(event), true);
      if (row && row.hPref) {
        contextPage = pega.u.property.toReference(row.hPref);
        paramObj.pzPrimaryPageName = contextPage;
      } else {
        paramObj.ContextPage = contextPage;
      }
    } else if ($(event.target).parents('div#PEGAADDRESSMAP').length > 0) {
      /*Check whether the event originated from within Address Maps*/
      contextPage = posObj.usingPage;
      paramObj.ContextPage = contextPage;
    } else {
      paramObj.ContextPage = contextPage;
    }

    // BUG-154451 : Use the contextpage as primary page.
    if (contextPage && contextPage != "") {
      paramObj.pzPrimaryPageName = contextPage;
    }
  }
  //Render New Menus in offline as well
  /*var isOffline = false;
				if(pega.offline && pega.offline.NetworkStatus && !window.pega.offline.NetworkStatus.isDataNetworkAvailable())
					isOffline = true;*/
  
  /* BUG-368190: Check if the target is inside the grid's details section. */
  var isInGridDetails = false;
  var targetParentFA = null;
  var gridParentFA = null;
  if(target && target.querySelector)
    targetParentFA = pega.ctx.dom.closest(target,"#pyFlowActionHTML");
  if(gridObj && gridObj.rightBodyTbl)
     gridParentFA = pega.ctx.dom.closest(gridObj.rightBodyTbl,"#pyFlowActionHTML");
  if(target && gridObj && gridObj.modalAction && targetParentFA && (gridParentFA != targetParentFA)){
    isInGridDetails = true;
  }
  
  if (!gridObj || (gridObj && isInGridDetails)) {
    if (useNewMenu && pzMenu) {// removed "&& !offline" in this if
      pega.control.menu.showContextMenu(paramObj, target,event);
    } else {
      if(pega.mobile && pega.mobile.hybrid && !pega.mobile.hybrid.getLaunchBox()){ /*render old menu only in online scenario*/
        pega.u.contextMenu.renderContextMenu(posObj, navRuleName, className, event);
      }else { /*BUG-204969: Show an alert if old menu is coming up in HC*/
        var oldMenuNotSupportedMessage = pega.u.d.fieldValuesList.get("OldMenuNotSupportedInHC")
        alert(oldMenuNotSupportedMessage);
      }
    }
  } else {
    if (event.type == "contextmenu") {
      /*For right-click show menu, added the restrictions.*/
      var parentTbl = pega.util.Dom.isAncestor(gridObj.rightBodyTbl, target) ? gridObj.rightBodyTbl : gridObj.leftBodyUL;
      var cell = gridObj.findCell(event, parentTbl);
      var rowIndex = gridObj.getRowIndex(cell);
      if (!cell || !rowIndex) {
        return;
      }
      if (target.attributes['data-ctl'] || target.tagName.toUpperCase() == "A" || target.tagName.toUpperCase() == "BUTTON") {
        /*for read-write/inline grid, input field is going as relativeElement. change it  as cell.*/
        posObj.relativeElement = cell;
      }
      //BUG-324524, passing event
      gridObj.selectPage(event, null, rowIndex);
      var row = gridObj.rightBodyTbl.rows[rowIndex];
      /*BUG-106984: Do not show context menu if the grid has inline row editing configuration and the row is editable.*/
      if (gridObj.editConfig == gridObj.EDIT_ROW && pega.util.Dom.hasClass(row, "editMode")) {
        return;
      }
      if (gridObj.editConfig == gridObj.EDIT_EXPANDPANE) {

        if (row.id == "") {
          /*If user has done right click on row details, then return*/
          return;
        }
      }
      if (gridObj.editConfig == gridObj.EDIT_HARNESS) {
        if (cell && pega.util.Dom.isAncestor(gridObj.gridDetailsDiv, cell)) {
          /*If user has done right click on grid details, then return.*/
          return;
        }
      }
      if (gridObj.bTreegrid) {
        var leftRow = gridObj.getLeftRow();
        var ul = pega.util.Dom.getFirstChild(leftRow);
        if (gridObj.bReportDefinition && gridObj.bTreegrid) {
          className = gridObj.RDAppliesToClass;
          /*for summary report, send the RD Applies to Class*/
        } else {
          className = ul.getAttribute("objclass");
        }
      }
    }
    gridObj.renderContextMenu("py" + navRuleName + className.replace(/-/g, '').replace(/@/g, ''), posObj, navRuleName, className, paramObj, useNewMenu && pzMenu, event);

  }

};
//static-content-hash-trigger-GCC
/*@protected Autobots Sprint 12 & BUG-42030 - Show Menu Action - End */
pega.control.Actions.prototype.takeAction = function (paramObj, event) {
  if (paramObj.errorMessage) {
    alert(paramObj.errorMessage);
    return;
  }
  var taskStatus = paramObj.taskStatus,
      taskIndex = paramObj.taskIndex,
      streamType = paramObj.streamType,
      uiRef = paramObj.uiRef,
      uiType = paramObj.uiType,
      ele;
  if (event) {
    ele = pega.util.Event.getTarget(event);
    while (ele && ele.attributes && !ele.attributes['data-ctl']) {
      ele = ele.parentNode;
    }
    /* Added this code for grid actions - will be refactored */
    if (ele && !ele.attributes) {
      ele = pega.util.Event.getTarget(event);
    }
  }
  takeAction(taskStatus, taskIndex, streamType, uiRef, uiType, ele, event);
};
//static-content-hash-trigger-GCC
/*
 @api
 Brings up the New Harness for the specified type of object.
 @param $String$strClassName - Type of object(work item, cover, covered item).
 @param $Integer$harnessVersion - 0 or 1, 0 is heritage (v3) harness, 1 is v4 harness.
 @param $String$strFlowName - Name of flow to start for this work object.
 @param $String$flowParams - Parameters for the flow in &param1=value1&param2=value2 format.
 @param $String$actionRequestID - actionRequestID to support URL Tampering feature.
 @param $String$caseInitProperties  - Properties for the case in &property1=value1&property2=value2 format.
 @return $void$
 */
pega.desktop.createNewWork = function(strClassName, harnessVersion, strFlowName, flowParams, contentID, dynamicContainerID, skipConflictCheck, configParams,caseInitProperties) {
  function refactorValInOparams(oParams){
    // BUG- 550103- Start Fixing
      for (var index = 1; index < oParams.length; index++){
        if(oParams[index] && oParams[index].indexOf("=") === -1) {
          oParams[index-1]+="&"+oParams[index];
          oParams.splice(index,1);
        }
      }
    return oParams;
    // BUG-550103- End
  }
  
	var args = arguments[0];
	if (typeof args == "object" && args.name == "safeURL") {
		var oSafeURL = SafeURL_clone(args);
		var strClassName = oSafeURL.get("className");
		var strFlowName = oSafeURL.get("flowType");
		var harnessVersion = oSafeURL.get("HarnessVersion");
		var contentID = oSafeURL.get("contentID");
		var dynamicContainerID = oSafeURL.get("dynamicContainerID");
	}

	// inform perfmon of work in progress - triggers update to PAL on ui completion
	if (pega && pega.ui && pega.ui.statetracking) pega.ui.statetracking.setPALInteraction("abc?&action=createNewWork&className=" + strClassName);

	if (!oSafeURL) {
		var oSafeURL = new SafeURL();
	}
	var sourceString = "";
	if (strClassName && strClassName != "") {
		oSafeURL.put("param", strClassName);
	}
	if (harnessVersion && harnessVersion != "") {
		oSafeURL.put("version", harnessVersion);
	}
	if (contentID && contentID != "")
		oSafeURL.put("contentID", contentID);
	if (dynamicContainerID && dynamicContainerID != "") {
		oSafeURL.put("dynamicContainerID", dynamicContainerID);
	}

	/*BUG-226445: Adding pyLatitude and pyLongitude values */
	try {
		var pyLatitude = pega.util.Dom.getElementsById("pxRequestorPyLatitude", document.forms[0], "INPUT");
		var pyLongitude = pega.util.Dom.getElementsById("pxRequestorPyLongitude", document.forms[0], "INPUT");
		if (pyLatitude && pyLatitude.length == 1 && pyLongitude && pyLongitude.length == 1) {
			oSafeURL.put(pyLatitude[0].getAttribute("name"), pyLatitude[0].value);
			oSafeURL.put(pyLongitude[0].getAttribute("name"), pyLongitude[0].value);
		}
	} catch (e) { /* console.log("Error in setting latitude and longitude"); */}

	if (strFlowName && strFlowName != "") {
		oSafeURL.put("FlowType", strFlowName);
		// 09/27/2012 TASK-118705 GUJAS1 Add flow parameters to the safe URL.
		var paramKeys = "";
		if (flowParams && flowParams != '') {
			// At this point, each parameter is encoded,
			//the complete string can be split on '&'
			var oParams = flowParams.split("&");
      // BUG- 550103- Start Fixing
      oParams= refactorValInOparams(oParams)
      // BUG-550103- End
			for (var i = 0; i < oParams.length; i++) {
				if (oParams[i] != '') {
					var oParamNMPair = oParams[i].split("=");
					// Unescaping first will convert the %2B to + which will be replaced by space.
					//Avoid this by replacing the + with space and then unescaping
					/* Unescape is deprecated, so changed it with decodeURIComponent : kumad1 */
					//oSafeURL.put(oParamNMPair[0], decodeURIComponent(oParamNMPair[1].replace(/\+/g, " ")));
					oSafeURL.put(oParamNMPair[0], oParamNMPair[1].replace(/\+/g, " "));/*BUG-219306 removing decodeURIComponent as decoded values are put in oSafeURL and same is later passed to SafeURL_createFromURL api in which url is splitted based on &*/
					paramKeys += oParamNMPair[0] + "&";
				}
			}
			//Adding a paramKey string to be split at server-side, so that RecentGadget can have the custom parameters also. JAINB1- BUG-129094.
			paramKeys = paramKeys.substring(0, paramKeys.lastIndexOf("&"));
			if (paramKeys != "" || paramKeys != null) {
				oSafeURL.put("flowParamNames", paramKeys);
			}
		}

		// TASK-149427: GUJAS1 If skipConflictCheck has been specified, put in in the parameters.
		if (skipConflictCheck != null) {
			oSafeURL.put("SkipConflictCheck", skipConflictCheck);
		}

		/* BUG-524557: Sending the opener window name info to opened window as it is required to refresh the opener window. Eg: To refresh worklist */
		if (pega.mobile.isMultiWebViewOfflinePegaMobileClient) {
			oSafeURL.put("openerWindowName", window.name);
		}

		//augment config params to oSafeURL
		pega.desktop.augmentConfigParams(configParams, oSafeURL);

		if (!pega.desktop.support.openSpace("Work", oSafeURL, "EnterNewWorkFromFlow")) {
			sourceString = oSafeURL.toQueryString();
			var strURL = pega.desktop.support.constructUrl(sourceString, "EnterNewWorkFromFlow");
			pega.desktop.openUrlInWindow(strURL, "pyWorkPage", WorkFormSize + PopupWindowFeatures);
		}
	}
	else {
    var propertiesKeys = "";
    		if (caseInitProperties && caseInitProperties != '') {
			// At this point, each parameter is encoded,
			//the complete string can be split on '&'
			var oParams = caseInitProperties.split("&");     
      oParams= refactorValInOparams(oParams)
     
			for (var i = 0; i < oParams.length; i++) {
				if (oParams[i] != '') {
					var oParamNMPair = oParams[i].split("=");
					// Unescaping first will convert the %2B to + which will be replaced by space.
					//Avoid this by replacing the + with space and then unescaping
					/* Unescape is deprecated, so changed it with decodeURIComponent : kumad1 */
					//oSafeURL.put(oParamNMPair[0], decodeURIComponent(oParamNMPair[1].replace(/\+/g, " ")));
					oSafeURL.put(oParamNMPair[0], oParamNMPair[1].replace(/\+/g, " "));/*BUG-219306 removing decodeURIComponent as decoded values are put in oSafeURL and same is later passed to SafeURL_createFromURL api in which url is splitted based on &*/
					propertiesKeys += oParamNMPair[0] + "&";
				}
			}
			//Adding a paramKey string to be split at server-side, so that RecentGadget can have the custom parameters also. JAINB1- BUG-129094.
			propertiesKeys = propertiesKeys.substring(0, propertiesKeys.lastIndexOf("&"));
			if (propertiesKeys != "" || propertiesKeys != null) {
				oSafeURL.put("caseIntializationProperties", propertiesKeys);
			}
		}
    
    
    //BUG-561437 : fix create new work action in ajax container
    if (skipConflictCheck != null) {
			oSafeURL.put("SkipConflictCheck", skipConflictCheck);
		}
		if (pega.mobile.isMultiWebViewOfflinePegaMobileClient) {
			oSafeURL.put("openerWindowName", window.name);
		}
		pega.desktop.augmentConfigParams(configParams, oSafeURL);
  
		if (!openSpace("Work", oSafeURL, "EnterNewWork")) {
			sourceString = oSafeURL.toQueryString();
			var strURL = pega.desktop.support.constructUrl(sourceString, "EnterNewWork");
			pega.desktop.openUrlInWindow(strURL, "pyWorkPage", WorkFormSize + PopupWindowFeatures);
		}
	}
}

/*
@api
Brings up the New Harness for the specified type of object.
@param $String$strClassName - Type of object(work item, cover, covered item).
@param $Integer$harnessVersion - 0 or 1, 0 is heritage (v3) harness, 1 is v4 harness.
@param $String$strFlowName - Name of flow to start for this work object.
@param $String$strFlowParams - Parameters for the flow in the format &param1=value1&param2=value2.
@return $void$
*/
//BUG-182022 : updated signature by removing actionRequestId param as these is not being generated now.
function createNewWork(strClassName, harnessVersion, strFlowName, strFlowParams, contentID, dynamicContainerID, skipConflictCheck, configParams,caseInitProperties) {
	// 09/27/2012 TASK-118705 GUJAS1 Added flow params.
	return pega.desktop.createNewWork(strClassName, harnessVersion, strFlowName, strFlowParams, contentID, dynamicContainerID, skipConflictCheck, configParams,caseInitProperties);
}

/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.createNewWork = function() {
	pega.control && pega.control.Actions && pega.control.Actions.prototype.showSkeleton && pega.control.Actions.prototype.showSkeleton();
	window.createNewWork.apply(null, arguments);
};
  //static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.doSave = function () {
  pega.u.d.doSave.apply(pega.u.d, arguments);
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.handleUpdate = function () {
  pega.u.d.handleUpdate.apply(pega.u.d, arguments);
};
//static-content-hash-trigger-GCC
/*@protectedbanea1 - BUG-42260 - start*/
pega.control.Actions.prototype.changeStyle = function (e, styleText, isStyleClass) {
  e = pega.util.Event.getEvent(e);
  var targetEle = pega.util.Event.getTarget(e);
  var cldTargetEle = targetEle;
  /*BUG-245881: Added code to move to parent depending upto number of dots.*/
  if(targetEle.getAttribute('data-hover')){ 
    var ele = targetEle.getAttribute('data-hover');
    if ((typeof ele == 'string') && (ele.charAt(0) == '.')) {
      var eleLevels = ele.length;
      for (; eleLevels; eleLevels--) {
        targetEle = targetEle.parentNode;
      }
    }
  }
  //chens3 BUG-54025 - adding __styleChangedFlag to avoid multiple executions
  if (targetEle.__styleChangedFlag == undefined || targetEle.__styleChangedFlag == null) {
    targetEle.__styleChangedFlag = true;
    var bodyMouseMoveHandler = function (e) {
      var sourceEle = pega.util.Event.getTarget(e);
      var eventX = pega.util.Event.getPageX(e);
      var eventY = pega.util.Event.getPageY(e);
      var currEle = pega.c.mouseOverEle;
      var eleLeft = pega.util.Dom.getX(currEle);
      var eleTop = pega.util.Dom.getY(currEle);
      var eleRight = eleLeft + currEle.offsetWidth;
      var eleBottom = eleTop + currEle.offsetHeight;

      if (!((eventX >= eleLeft && eventX <= eleRight) && (eventY >= eleTop && eventY <= eleBottom))) {
        if (isStyleClass == "1") {
          currEle.style.cssText = currEle.oldStyle;
        } else {
          pega.util.Dom.removeClass(currEle, styleText);
        }
        pega.util.Event.removeListener(document.body, 'mousemove', bodyMouseMoveHandler);
        //chens3 BUG-54025 - clearing __styleChangedFlag
        targetEle.__styleChangedFlag = undefined;
        /*Bug-63245 Autobots start*/
        if (currEle.disabled && currEle.getAttribute("IsSprite")) {
          var bgPos = currEle.style.backgroundPosition.split(" ");
          var disabledPos = currEle.style.height.replace("px", "");
          currEle.style.backgroundPosition = bgPos[0] + " -" + 2 * disabledPos + 'px';
        }
        /*Bug-63245 End*/
      }
    };

    if (e.type == "focus" || e.type == "focusin") {
      var eventType;
      if (e.type == "focus") {
        eventType = "blur";
      } else {
        eventType = "focusout";
      }
      pega.util.Event.addListener(targetEle, eventType, function (e) {
        e = pega.util.Event.getEvent(e);
        var targetEle = pega.util.Event.getTarget(e);
        if (isStyleClass == "1") {
          if (!targetEle.oldStyle) {
            targetEle.oldStyle = targetEle.style.cssText;
          }
          pega.util.Dom.changeStyle(targetEle, e.type);
        } else {
          pega.util.Dom.removeClass(pega.util.Event.getTarget(e), styleText);

        }
        pega.util.Event.removeListener(targetEle, eventType);
        //chens3 BUG-54025 - clearing __styleChangedFlag
        targetEle.__styleChangedFlag = undefined;
      });
      if (isStyleClass == "1") {
        pega.util.Dom.changeStyle(pega.util.Event.getTarget(e), e.type, styleText);
      } else {
        pega.util.Dom.addClass(pega.util.Event.getTarget(e), styleText);
      }
    } else if (e.type == "mouseover") {
      if (isStyleClass == "1") {
        if (!targetEle.oldStyle) {
          targetEle.oldStyle = targetEle.style.cssText;
        }
        pega.util.Dom.changeStyle(targetEle, e.type, styleText);
      } else {
        pega.util.Dom.addClass(pega.util.Event.getTarget(e), styleText);
      }
      if(cldTargetEle!=targetEle){
        cldTargetEle.__styleChangedFlag = undefined;
      }

      pega.c.mouseOverEle = targetEle;
      //chens3 BUG-54025 - commenting code since __styleChangedFlag is added
      /*var mouseMoveListeners = pega.util.Event.getListeners(document.body, 'mousemove');
						var isMMPresent = false;
						for (var i = 0; mouseMoveListeners && i < mouseMoveListeners.length; i++) {
						if (mouseMoveListeners[i].fn == bodyMouseMoveHandler) {
						isMMPresent = true;
						break;
						}
						}
						if (!isMMPresent) {*/
      pega.util.Event.addListener(document.body, 'mousemove', bodyMouseMoveHandler);
      //}
    }
  }
};
//static-content-hash-trigger-GCC
/*@protectedbanea1 - BUG-42260 - end*/
pega.control.Actions.prototype.refresh = function () {
  var target = arguments[0];
  var section = arguments[1];
  var preActivity = arguments[2];
  var preActivityParams = arguments[3];
  if (preActivityParams.indexOf("&=") == 0) {
    preActivityParams = preActivityParams.substring(2);
  }
  var usingPage = arguments[4];
  var preDataTransform = arguments[5];
  var event = arguments[6];
  var disableSubmit = arguments[7];
  var encryptedURL = null;
  if(arguments.length === 10) {
    encryptedURL = arguments[8];
  }
  var actDTPage = arguments[arguments.length - 1];
  /*BUG-589276  Instead of assigning the last param of refresh() to the pagename, added a type check*/
  if(typeof actDTPage !== 'string'){
    actDTPage = "";
  }
  var oDataTransform = [];
  if (typeof(usingPage) == "undefined" || usingPage == null) {
    var usingPage = "";
  }

  // set durations to be captured for export to PAL/PDC
  pega.ui.statetracking.setPALInteraction("abc?&action=refresh&key="+section);

  if (target == "thisSection") {
    var sectionNode = null;
    oDataTransform.push(preDataTransform);
    if (event && event["RefreshSectionNode"])
      sectionNode = event["RefreshSectionNode"];
    /*BUG-228728: search for the element with eventTarget's name in DOM and recalculate section node by using new target*/
    var eventTarget;
    if(event) {
      eventTarget = pega.util.Event.getTarget(event);  
    } 
    if(eventTarget && !pega.util.Dom.isAncestor(document.body,eventTarget)){
      var newTarget;
      if(eventTarget.tagName && eventTarget.tagName.toLowerCase() == 'label'){
        if(eventTarget.getAttribute("for") != null){
          if(eventTarget.control){
            eventTarget = eventTarget.control;  
          } else {
            var sinput = $(eventTarget).siblings("#"+eventTarget.getAttribute("for"));
            if(sinput.length == 1){
              eventTarget = $(eventTarget).get(0);
            }
          }

        }
      }
      if(eventTarget.name){
        var targetsList = pega.ctx.dom.getElementsByName(eventTarget.name);
        if(targetsList) {
          for(var i=0; i < targetsList.length; i++) {
            if(targetsList[i].type == eventTarget.type) {
              newTarget = targetsList[i];
              break;
            }
          }
        }
      }
      if(newTarget){
        sectionNode = pega.u.d.getSectionDiv(newTarget);
      }                     
    }
    pega.u.d.reloadSectionEncoded(sectionNode, preActivity, preActivityParams, false, disableSubmit !== "1", -1, false, event, oDataTransform, encryptedURL);
  } else if (target == "otherSection") {
    if (pega.u.d.reloadAllSectionsByName) {
      var oRwPreActivitiesArr = [];
      var sectionNodes = pega.ctx.dom.querySelectorAll('[id="RULE_KEY"][node_type="MAIN_RULE"][node_name="'+section+ '"]');
      if (sectionNodes && sectionNodes.length) {
        var sectionsLen = sectionNodes.length;
        for (i = 0; i < sectionsLen; i++) {
          var sectionNode = sectionNodes[i];
          var baseRef = "";
          if (sectionNode) {
            baseRef = pega.u.d.getBaseRef(sectionNode);
          }
          if (preDataTransform && preDataTransform != "") {
            oDataTransform.push(preDataTransform + "<||>" + baseRef);
          }
          if (preActivity && preActivity != "") {
            oRwPreActivitiesArr.push(preActivity + "," + preActivityParams + "<||>" + baseRef);
          }
        }

        var oArgs = {
          reloadElement : sectionNodes,
          bFormSubmit : false,
          bSectionSubmit : disableSubmit !== "1",
          bDoNotSetAll : true,
          event : event,
          strReloadType : 'MultipleSections',
          rwPreActivities : oRwPreActivitiesArr,
          oDataTransform : oDataTransform,
          sourceString : ''
        }
        if(encryptedURL) {
          oArgs.preActivity = preActivity;
          oArgs.preActivityParams = preActivityParams;
          oArgs.appendExtraQueryString = encryptedURL;
        }
        pega.u.d.useHashDP = true;
        pega.u.d.reload(oArgs);
        pega.u.d.useHashDP = false;
      }
    } else {
      oDataTransform.push(preDataTransform);
      var sectionNode = pega.u.d.getSectionByName(section, usingPage, document);
      if (sectionNode) {
        pega.u.d.reloadSectionEncoded(sectionNode, preActivity, preActivityParams, false, disableSubmit !== "1", -1, false, event, oDataTransform, encryptedURL);
      }
    }
  } else if (target == "currentharness") {
    oDataTransform.push(preDataTransform);
    var strPreDataTransform = "";
    var strPreDataTransformParams = "";
    if (oDataTransform.length > 0) {
      var commaIndex = oDataTransform[0].indexOf(",");
      strPreDataTransform = oDataTransform[0];
      if (commaIndex != -1) {
        strPreDataTransform = oDataTransform[0].substring(0, commaIndex);
        strPreDataTransformParams = oDataTransform[0].substring(commaIndex + 1);
      }
    }
    if (pega.u.d.ServerProxy.isDestinationLocal()) {
      /* HALLJ US-86221 support refresh within OSCO/offline */
      pega.process.engine.refresh(function(){},function(){});
    } else if (disableSubmit !== "1") {
      pega.u.d.submitWhenFail(preActivity, preActivityParams, "", strPreDataTransform, strPreDataTransformParams, false, actDTPage,event);
    } else {
      pega.u.d.submitWhenFail(preActivity, preActivityParams, "", strPreDataTransform, strPreDataTransformParams, true, actDTPage,event);
    }
  }
};
//static-content-hash-trigger-GCC
/*@protected New logoff action added - Delta Touch */
pega.control.Actions.prototype.logOff = function (event) {
  var parentWindow;
  
  // US-269696 Clear usage data in session storage on log off -- Start
  function clearUsageDataInStorage(){
    window.sessionStorage.removeItem("pega.usage.index");
    window.sessionStorage.removeItem("pega.usage.applicationStack");
    window.sessionStorage.removeItem("pega.usage.portalName");
    window.sessionStorage.removeItem("pega.usage.accessGroup");
    window.sessionStorage.removeItem("pega.usage.targettime");
    window.sessionStorage.removeItem("pega.usage.counter");
    for(i=1;i<=5;i++){
      window.sessionStorage.removeItem("pega.usage.json" + i);
      window.sessionStorage.removeItem("pega.usage.eventtime" + i);
    }
  }
  clearUsageDataInStorage();
  // US-269696 -- End 
  
  pega.ui.EventsEmitter.publishSync("BeforeLogOff");
  pega.control && pega.control.menu && pega.control.menu.clearState();
  
  if (pega.mobile && typeof pega.mobile.getDesktopWindow() === 'function') {
    parentWindow = pega.mobile.getDesktopWindow();
  } else {
    var tempWin = pega.desktop.support.getDesktopWindow();
    parentWindow = tempWin ? tempWin : window;
  }

  // If in Live Composer Mode then the parentWindow should be forced to composer window
  if (pega.ui && pega.ui.composer && pega.ui.composer.isActive()) {
    parentWindow = pega.ui.composer.getCurrentComposerWindow();
  }

  if (typeof parentWindow.prpcmobileapp != "undefined") {

    var strUrlSF = SafeURL_createFromURL(pega.u.d.url);
    strUrlSF.put("pyActivity", "LogOff");
    strUrlSF.put("pzPrimaryPageName", "pyDisplayHarness");

    var callback = {
      success : function (responseObj) {
        console.log("about to call plugin");
        parentWindow.prpcmobileapp.showAppList();
      },
      failure : function (oResponse) {
        alert("Your session may not have ended properly.");
        parentWindow.prpcmobileapp.showAppList();
      }
    }

    try {
      parentWindow.navigator.splashscreen.show();
    } catch (e) {}
    var response = pega.util.Connect.asyncRequest('GET', strUrlSF.toURL(), callback, null);
  } else if(pega.mobile.sdk) {
      pega.mobile.sdk.authentication.invalidate();
  } else if (pega.mobile && pega.mobile.hybrid && pega.mobile.hybrid.getLaunchBox()) { // Supported by HC and NativeSDK

    /*BUG-251569 : Add dirty check before triggering native logout which triggers the dirty check very late after actual logoff due to AccountManager.closeAccount */
    var dirty = pega.u.d.isFormDirty(true);
    if(dirty) {
      pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
      return;
    } else {
      pega.m.hybrid.logOut(function() {
        if (pega.offline && pega.offline.browser) {
          parentWindow.location.href = SafeURL_createFromURL(pega.u.d.url).toURL();
        }
      });
    }
  } else {
    event = event == undefined ? window.event : event;
    if (event) {
      pega.util.Event.stopEvent(event);
    }
    /* BUG-109795 */
    if (parentWindow != null) {
      parentWindow.logout = true;
    }

    var oSafeURL = SafeURL_createFromURL('pyActivity=LogOff&pzPrimaryPageName=pyDisplayHarness');
    /* BUG-117858 */
    var queryString = oSafeURL.toQueryString();
    var bEncryptURLs = pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty('bEncryptURLs');
    /* BUG-135434 - start - singp1 */
    if (typeof bEncryptURLs != "undefined" && bEncryptURLs && (queryString.indexOf("pyActivity") > -1 || queryString.indexOf("pyStream") > -1)) {
      queryString = URLObfuscation.encrypt(queryString);
    }
    /* BUG-135434 - end - singp1 */
    if (pega.u.MessagingManager && typeof(pega.u.MessagingManager.disconnect) == "function") {
      pega.u.MessagingManager.disconnect();  
    }
    var delim = "?";
    var reqURI = "";
    if (typeof parentWindow.safeUrlRequestURI != "undefined") {
      
      /* For inner workspace, find the top level workspace */
      if(parentWindow.pega && parentWindow.pega.desktop && parentWindow.pega.desktop.portalCategory === "workspace" && parentWindow.name == parentWindow.pega.desktop.portalName) {
        if (parentWindow.parent && parentWindow.parent != parentWindow && typeof parentWindow.parent.safeUrlRequestURI != "undefined") {
          parentWindow = parentWindow.parent;  
        }
      }
      
      /*BUG-589870 to trigger logoff in root context - As it is not owned by WebWiz team, added safe changes to logoff action to handle this issue.*/
      if(parentWindow.pega && parentWindow.pega.ctxmgr){
          parentWindow.pega.ctxmgr.setRootDocumentContext();
          reqURI = parentWindow.pega.ctx.pxReqURI;
      }else{
        reqURI = parentWindow.safeUrlRequestURI;
      }
      parentWindow.location.href = reqURI + delim + queryString;
    } else {
      parentWindow.pega.ctxmgr.setRootDocumentContext();
      parentWindow.location.href = oSafeURL.toURL();
    }

  }
};


//static-content-hash-trigger-GCC
pega.control.Actions.prototype.openMobileApp = function(){
  var scheme = arguments[0];
  var authorithyAndPath = (arguments[1] ? arguments[1].replace('?', '') : "");
  var queryJSON = arguments[2];

  if (!scheme) {
    console.error("Cannot open mobile app without scheme");
    return;
  }

  var URL = scheme + "://" + authorithyAndPath;           
  if (queryJSON) {
    try {
      var queryParams = JSON.parse(queryJSON);
      if (queryParams) {
        URL += "?";
        for (var prop in queryParams){
          if (queryParams.hasOwnProperty(prop)){
            URL += (URL.indexOf('?') !== URL.length-1 ? "&" : "" ) + prop + "=" + queryParams[prop];
          }
        }
      }
    } catch(e) {
      console.error("Invalid query parameters for action openMobileApp");
    }
  }

  if (pega.mobile && pega.mobile.hybrid && pega.mobile.hybrid.getLaunchBox() 
      && pega.mobile.hybrid.getLaunchBox().Container && pega.mobile.hybrid.getLaunchBox().Container.OpenURL) {
    // Pause event queue Sequencer
    pega.u.d.pauseAjaxSequencer();
    pega.mobile.hybrid.getLaunchBox().Container.OpenURL.open(URL).then(function() {
      pega.u.d.resumeAjaxSequencer();     
      console.info("Application started successfully from URL: " + URL);
    }).catch(function(error){
      pega.u.d.resumeAjaxSequencer();
      console.error(error);
    });
  } else if (pega.mobile.sdk && pega.mobile.sdk.application) {
    pega.mobile.sdk.application.openUrl(URL).catch(function(error) {
      console.error("Cannot open application " + URL + " due to: " + error.toString());
    });
  } else {
    pega.desktop.support.getDesktopWindow().open(URL);
  }
};
//static-content-hash-trigger-GCC
pega.control.Actions.prototype.getDirections = function(event, startCurrent, startAddress, dAddress) {
	var myLocationTxt = pega.u.d.fieldValuesList.get("GetDirectionsActionMyLocation"),
		currentLocationTxt = pega.u.d.fieldValuesList.get("GetDirectionsActionCurrentLocation");
  
  var NoNetworkConnectionFound = pega.u.d.fieldValuesList.get("NoNetworkConnectionFound");
  var OpenPopupWindowFailedLabel = pega.u.d.fieldValuesList.get("OpenPopupWindowFailedLabel");

	// verify data connection is available
	if (!navigator.onLine) {
		//alert('No network connection found.');
    alert(NoNetworkConnectionFound);
		return;
	}

	startAddress = (startAddress === null ? '' : startAddress);
	dAddress = (dAddress === null ? '' : dAddress);

	function currentPositionSuccess(pos) {
		var coords = pos.coords;
		var currentLatLng = coords.latitude + "," + coords.longitude;

		var mapURL = getMapURL(currentLatLng, dAddress);
		return showDirections(mapURL);
	}

	function currentPostionFailure(err) {
		console.error('Failed to get current position - ' + err.code + ": " + err.message);
		var mapURL = getMapURL(startAddress, dAddress);
		return showDirections(mapURL);
	}

	if (startCurrent === 1) {
		var options = {
			enableHighAccuracy: true,
			timeout: 5000,
			maximumAge: 0
		};

		navigator.geolocation.getCurrentPosition(currentPositionSuccess, currentPostionFailure, options);
	} else {
		var mapURL = getMapURL(startAddress, dAddress);
		return showDirections(mapURL);
	}

	function getMapURL(startAddress, dAddress) {
		var userPlatform = navigator.userAgent.toLowerCase();
		var mapsURL = '';
		if (userPlatform.indexOf('iphone') !== -1 || userPlatform.indexOf('ipad') !== -1 || userPlatform.indexOf('ipod') !== -1) {
			var versionStart = userPlatform.indexOf('os') + 2;
			var versionEnd = userPlatform.indexOf('like') > -1 ? userPlatform.indexOf('like') : userPlatform.indexOf(')');
			var iosVersion = userPlatform.substring(versionStart, versionEnd);
			var iosMajorVersion = iosVersion.split('_').length > 0 ? iosVersion.split('_')[0] : 8;

			// Show Google Maps incase of iOS version >= 8  
			if (iosMajorVersion >= 8) {
				mapsURL = 'http://maps.google.com/maps?saddr=';
				mapsURL += (startAddress || myLocationTxt) + '&daddr=' + dAddress;
			} else {
				mapsURL = 'http://maps.apple.com/maps?saddr=';
				mapsURL += (startCurrent === 1 ? currentLocationTxt : (startAddress !== '' ? startAddress : currentLocationTxt)) + '&daddr=' + dAddress;
			}
		} else {
			mapsURL = (window.location.protocol==="https:")?'https://maps.google.com/?saddr=':'http://maps.google.com/?saddr='
			mapsURL += (startAddress || myLocationTxt) + '&daddr=' + dAddress;
		}

		return encodeURI(mapsURL);
	}

	function showDirections(mapsURL) {
		if (pega.mobile && pega.mobile.hybrid && pega.mobile.hybrid.getLaunchBox() && pega.mobile.hybrid.getLaunchBox().Browser) {
			pega.mobile.hybrid.getLaunchBox().Browser.start(mapsURL, {
				'external': true
			});
		} else if (pega.mobile.sdk) {
			pega.mobile.sdk.application.openUrl(mapsURL);
		} else {
			var newWindow = null;
			var current = window.self;

			try {
				newWindow = current.open(mapsURL);
			} catch (ex) {
				return null;
			}

			try {
				if (newWindow && (typeof newWindow.opener === "object")) {
					//The current window is closed and opened again if the opener is not the current window::B-7171
					if (newWindow.opener !== current && newWindow !== current) {
						newWindow.close();
						newWindow = current.open(mapsURL);
					}

					if (newWindow && (typeof newWindow.opener === "object")) {
						try {
							newWindow.focus();
							newWindow.focus(); //Call focus twice: BUG-1018
						} catch (e) { // fix cross-domain issue
							newWindow.close();
							newWindow = current.open(mapsURL);
						}

					} else {
						newWindow = null;
						//alert("An attempt to open a popup window failed. A popup blocker may be enabled.");
            alert(OpenPopupWindowFailedLabel);
					}
				} else {
					newWindow = null;
					//alert("An attempt to open a popup window failed. A popup blocker may be enabled.");
          alert(OpenPopupWindowFailedLabel);
				}
			} catch (ex) {
				newWindow = null;
				//alert("An attempt to open a popup window failed. A popup blocker may be enabled.");
        alert(OpenPopupWindowFailedLabel);
			}
		}
	}

};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.doClose = function () {
  var isNativeSDK = (navigator.userAgent.toLowerCase().indexOf('pegamobilesdk') != -1);
  pega.control && pega.control.menu && pega.control.menu.clearState();
  if ((pega.ui.NavigateTopHandler && pega.ui.NavigateTopHandler.isWithPortalController() && !isNativeSDK && !pega.ctx.isMDC) || pega.mobile.isMultiWebViewOfflinePegaMobileClient) { // We are in nav top frameless DC
    // When Preflight Optimized, DC_lite js is always included, so must check if we are with portal controller
    if (!pega.u.d.bIsDCSPA && pega.ui.hasAjaxContainer) {
      if(pega.u.d.closeOnlyMDCDocs) {
        pega.u.d.closeOnlyMDCDocs(null,true, true);
      }
    } 
    pega.desktop.activateDocument(0);
    return;
  }
  pega.u.d.doClose.apply(pega.u.d, arguments);
};
//static-content-hash-trigger-GCC
/*
@protected- Function description goes here.
@return $undefined$ - return description goes here.
*/
pega.control.Actions.prototype.doGridAction = function () {
  if (pega.ui.grid && window.doGridAction) {
    window.doGridAction.apply(null, arguments);
  }
};

function isTemplateGrid(event, element){
  var targetEle = null;
  if(!event && !element){
    return;
  } 
  if(element){
    targetEle = $(element);
  }else{
    targetEle = $(event.target);
  }

  var tableDom = targetEle.closest("table[id='gridLayoutTable']");
  if(tableDom.attr("uniqueid") && tableDom.attr("uniqueid")!==""){
    return  true;
  }else{
    return false;
  }
}
//static-content-hash-trigger-GCC
(function() {
    var resolveActionString = function(categoryActionString, item) {
        if (!categoryActionString && item.pyActionString) {
            return item.pyActionString;
        }
        var resolveItemActionStringFromTemplate = pega.mobile && pega.mobile.support && pega.mobile.support.resolveItemActionStringFromTemplate ||
            // this is ugly, but pega.mobile.support.resolveItemActionStringFromTemplate is not available for HC
            function(templateActionString, item) {
                var allowedPageRefs = ["pySearchContext", "\\$TOP\\$", "\\$CTX\\$", "\\$PRIMARY\\$"].join("|");
                var itemKeys = Object.keys(item).join("|");
                // regex is capturing keys like #~pySearchContext.pzInsKey~# but also #~pySearchContext.Embeded.pzInsKey~# and #~$CTX$.pzInsKey~#
                var regex = new RegExp("#~(?:" + allowedPageRefs + ")\\.(" + itemKeys + ")((?:\\.\\w+)*)~#",
                    "gi");
                return templateActionString.replace(regex, function(match, group1, group2) {
                    var firstMatchedValue = item[group1];
                    if (!group2) {
                        // when there is no embeded values, just return matched value
                        return firstMatchedValue ? firstMatchedValue : match;
                    }
                    // when there is an embeded object, try to decode it
                    var matchedKeys = group2.split(".");
                    matchedKeys.shift(); // removing first dot (.) from the chain
                    var matchedValue = matchedKeys.reduce(function(prev, curr) {
                        return prev ? prev[curr] : prev;
                    }, firstMatchedValue);
                    return matchedValue ? matchedValue : match;
                });
            }
        return resolveItemActionStringFromTemplate(categoryActionString, item);
    };
    var simulateClick = function(actionString) {
        var mockButton = document.createElement('button');
        mockButton.style.display = 'none';
        mockButton.setAttribute('data-click', actionString);
        document.body.appendChild(mockButton);
        mockButton.dispatchEvent(new MouseEvent('click', {
            bubbles: true,
            view: window
        }));
        document.body.removeChild(mockButton);
    };
    pega.control.Actions.prototype.showSearch = function(event, displayOnlySelectedCategories, selectedCategories,
        bgColor, defaultCategory) {
        var search = window.launchbox && window.launchbox.Search || pega.mobile.sdk && pega.mobile.sdk.plugins &&
            pega.mobile.sdk.plugins.search;
        if (!search) {
            console.debug(
                "Mobile search action can’t be used outside of Mobile Client and from within an iframe");
            return;
        }
        var shouldDisplaySelectedCategoriesOnly = displayOnlySelectedCategories === "true";
        var options = {};
        if (shouldDisplaySelectedCategoriesOnly) {
            options.categories = JSON.parse(selectedCategories);
        }
        if (bgColor) {
            options.barBackgroundColor = bgColor;
        }
        if (defaultCategory) {
            options.defaultCategory = defaultCategory;
        }
        if (event && event.srcElement && event.srcElement.hasAttribute("data-pmc")) {
            var pmcOptions = JSON.parse(event.srcElement.getAttribute("data-pmc"));
            var windowName = pmcOptions.navigationId;
            var searchWindow = pega.mobile.components.open("search", windowName, options);
            searchWindow.addEventListener("userselect", function(e) {
                console.log("User selected an item");
                var result = e.detail;
                var categoryActionString = result.category && result.category.actionString || "";
                var resolvedActionString = resolveActionString(categoryActionString, result.item);
                simulateClick(resolvedActionString);
            });
            return;
        }
        search.show(options).then(function(result) {
            var categoryActionString = result.category && result.category.actionString || "";
            var resolvedActionString = resolveActionString(categoryActionString, result.item);
            var eventDescriptor = "data-click";
            if (event) {
                // just clone the target of original event and pass it to the next call, replacing only 'data-click' attribute
                var clonedTarget = event.target.cloneNode();
                clonedTarget.setAttribute(eventDescriptor, resolvedActionString);
                event.target = clonedTarget;
            }
            pega.c.ControlBehaviorExecutor.processBehavior(event, eventDescriptor);
        }).catch(function(e) {
            console.debug("Search cancelled" + e);
        });
    };
})();
//static-content-hash-trigger-GCC
/**
 * 
 * API to navigate to the home document in the given AjaxContainer
 * 
 * @method showHome
 * @param {String} targetACName Name of the AjaxContainer to target this action
 * @param {DOMEvent} event The DOM event object
 */
pega.control.Actions.prototype.showHome = function (targetACName, event) {

  if(!targetACName){
    targetACName = pega.u.d.getTargetACName(event);
  }
   
  if(targetACName) {
    
    // BUG-488476: As we dont stamp harness id for static document getting the closet harness id which is body in this case.
    var acDiv;
    var parentHarnessId;
    if (pega.redux.Utils.getAjaxContainerState(targetACName).mdcDocs[0].isStatic == "true") {      
      acDiv = document.querySelector("div[data-mdc-recordid='" + targetACName+"_0" + "']");
      if (pega.ctx.bIsDCSPA) {
        parentHarnessId = acDiv.closest("main[data-harness-id]").getAttribute("data-harness-id");
      } else {
        parentHarnessId = acDiv.closest("body[data-harness-id]").getAttribute("data-harness-id");
      }
    }

    if(pega.ui.hasAjaxContainer){
      pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.SWITCH, {
        "recordId": targetACName+"_0",
        "mdcTarget": targetACName,
        "parentHarnessId" : parentHarnessId
      }));    
    }
  } else{
    pega.desktop.activateDocument(0);
  }
  if(pega.Mashup) {
    pega.u.d.doHarnessResize();
  }
  
};
//static-content-hash-trigger-GCC
/**
 *
 * API to navigate to the next document in the given AjaxContainer
 *
 * @method goPrev
 * @param {String} targetACName Name of the AjaxContainer to target this action
 * @param {DOMEvent} event The DOM event object
 * @returns {Boolean} Returns true if the action is successful
 */
pega.control.Actions.prototype.goNext = function (targetACName, event) {
    if (!targetACName) {
        targetACName = pega.u.d.getTargetACName(event);
        if (!targetACName)
            return;
    }
    var ACState = pega.redux.Utils.getAjaxContainerState(targetACName);
    var ACDocsLen = ACState.mdcDocs.length;
    if (!ACDocsLen)
        return;
    var activeACDoc = document.querySelector('[data-mdc-id="' + targetACName + '"] .show');
    if (ACState.isTabbedMDC) {
        activeACDoc = document.querySelector('[data-mdc-id="' + targetACName + '"] .mdc-content-body .mdc-tabs .active');
    }
    var nextDoc = activeACDoc.nextElementSibling;
    var activeRecordID = nextDoc && nextDoc.getAttribute("data-mdc-recordid");
    if (activeRecordID) {
        pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.SWITCH, {
            "recordId": activeRecordID,
            "mdcTarget": targetACName
        }));
        return true;
    }
};
//static-content-hash-trigger-GCC
/**
 *
 * API to navigate to the previous document in the given AjaxContainer
 *
 * @method goPrev
 * @param {String} targetACName Name of the AjaxContainer to target this action
 * @param {DOMEvent} event The DOM event object
 * @returns {Boolean} Returns true if the action is successful
 */
pega.control.Actions.prototype.goPrev = function (targetACName, event) {
    if (!targetACName) {
        targetACName = pega.u.d.getTargetACName(event);
        if (!targetACName)
            return;
    }
    var ACState = pega.redux.Utils.getAjaxContainerState(targetACName);
    var ACDocsLen = ACState.mdcDocs.length;
    if (!ACDocsLen)
        return;
    var activeACDoc = document.querySelector('[data-mdc-id="' + targetACName + '"] .show');
    if (ACState.isTabbedMDC) {
        activeACDoc = document.querySelector('[data-mdc-id="' + targetACName + '"] .mdc-content-body .mdc-tabs .active');
    }
    var previousDoc = activeACDoc.previousElementSibling;
    var activeRecordID = previousDoc && previousDoc.getAttribute("data-mdc-recordid");
    if (activeRecordID) {
        var prevIndex = activeRecordID.substring(targetACName.length + 1);
        pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.SWITCH, {
            "recordId": activeRecordID,
            "mdcTarget": targetACName
        }));
        return true;
    }
};
//static-content-hash-trigger-GCC
(function() {
    var resolveWindowName = function(event) {
        if (!event) {
            console.warn("Event not defined");
            return undefined;
        }
        if (event.target && event.target.hasAttribute("data-pmc")) {
            var pmcOptions = JSON.parse(event.srcElement.getAttribute("data-pmc"));
            return pmcOptions.navigationId;
        }
    }
    pega.control.Actions.prototype.showMobileView = function(event, componentID, configurationJSON) {
        if (typeof pmcRuntimeFeatures === "undefined") {
            console.debug("Action can’t be used outside of Mobile Client");
            return;
        }
        if (!componentID) {
            console.error("Required ID parameter is missing");
            return;
        }
        var windowName = resolveWindowName(event);
        pega.mobile.components.open(componentID, windowName, configurationJSON);
    };
})();
//static-content-hash-trigger-GCC
