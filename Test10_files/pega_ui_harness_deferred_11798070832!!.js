//<script>
/*Extending pega.ui.Doc constructor for modal dialogs.
Client runtime infrastructure needed to support modal dialog
facilities to:
@asis
    - resize logic
    - setting size
    - submit or ajax functionality
    - hide/show behaviour
@endasis
*/
/* Instantiate the Dialog */
pega.ui.Doc.prototype.modalDialogInit = function() {
    pega.u.d.useOldModalDialog = true;
    // BUG-339861: Variable to track if the modal is in closig state. Applicable for modals in mobile with animation 
    pega.u.d.isModalClosing = false;
    pega.u.d.submitModalDlgParamStack = new Array();
    if (pega.u.d.inStandardsMode) pega.u.d.useOldModalDialog = false;
    if (pega.u.d.useOldModalDialog) {
        var mdlDlg = document.getElementById("modaldialog");
        pega.u.d.modalDialog = new pega.widget.ResizePanel("modaldialog", {
            width: pega.u.d.MODALDIALOG_MIN_WIDTH + "px",
            visible: false,
            modal: true,
            fixedcenter: true,
            draggable: false,
            constraintoviewport: true,
            monitorresize: false,
            underlay: "none",
            close: false
        });
        // Subscribing to the resize event of the harness
        pega.u.d.registerResize(function() {
            // Resize modal mask when open and the harness is resized
            if (pega.u.d.bModalDialogOpen) {
                pega.u.d.sizeHarnessMask.call(pega.u.d.modalDialog);
            }
        });
        // Subscribe to the renderEvent
        pega.u.d.modalDialog.renderEvent.subscribe(pega.u.d.modalDialogRendered);
        pega.u.d.modalDialog.subscribe("resizeEvent", pega.u.d._resizeModalDialogComponents);
        pega.u.d.modalDialog.mask = document.getElementById("modalDialog_mask");
    } else {
        var mdlDlg = document.getElementById("modalOverlay");
        pega.u.d.modalDialog = new pega.ui.modalDialog();
        pega.u.d.registerResize(pega.u.d.setModalDimensions);
        $(window).resize(pega.u.d.setModalDimensions); // because registerResize is not working for modal
    }
    pega.u.d.modalDialog.subscribe("hide", function() {
        var harCtxMgr = pega.ui.HarnessContextMgr;
        if (pega.u.d.useOldModalDialog) {
            /*BUG-67132 : On resize, pega.u.d.modalDialog.body is getting modified in pega_yui_resize*/
            pega.u.d.modalDialog.body = document.getElementById("modaldialog_bd");
        }
        pega.u.d.bModalDialogOpen = false;
        pega.u.d.isModalClosing = false;
        pega.u.d.bIsModelessDialog = false;
        pega.u.d.modalTabElementsWidth = 0;
        pega.u.d.modalTabContentWidth = 0;
        pega.u.d.MODALDIALOG_MAX_WIDTH = 0;
        pega.u.d.MODALDIALOG_MIN_HEIGHT = 0;
        pega.u.d.MODALDIALOG_BUTTONS_HEIGHT = 0;
        pega.u.d.resetSubmitModalDlgParam();
        /* pega.ctx.gridObj will be set to grid obj  before calling showsubscriptprompt in pega_ui_grid.js file*/
        if (pega.ctx.gridObj && !pega.ctx.activeGrid) {
            pega.ctx.activeGrid = pega.ctx.gridObj;
            pega.ctx.gridObj = null;
        }
        if (pega.ctx.activeGrid) {
            delete pega.ctx.activeGrid.isOpenLocalAction;
            delete pega.ctx.activeGrid.__fromLocalAction;
            delete pega.ctx.activeGrid.bNoThreadProcess;
        }
        /* In case of grid(not RRL) with data src as pagegrp with inline edit mode , the cancel dlg of subscript prompt need to set incall to false else next grid actions will not  work*/
        if (pega.u.d.inCall && pega.ctx.activeGrid && pega.ctx.activeGrid.bPageGroup && (pega.ctx.activeGrid
                .bGrid == false || pega.ctx.activeGrid.editConfig == pega.ctx.activeGrid.EDIT_ROW)) {
            pega.u.d.inCall = false;
            if (pega.u.d.changeInEventsArray) pega.u.d.changeInEventsArray.fire();
        }
        var modalDialog = pega.u.d.modalDialog.innerElement;
        if (!pega.u.d.usesModalTemplate) {
            pega.u.d.deleteModalHeader();
        }
        pega.u.d.usesModalTemplate = false;
        if (pega.util.Event.isIE) {
            pega.u.d.modalDialog.cfg.setProperty("height", "0");
        }
        var modalDialogBody = pega.u.d.modalDialog.body;
        pega.util.Event.removeListener(modalDialog, "keydown", pega.u.d.restrictFocus);
        //BUG-244464 : removing browser specific key event listener as before chrome was listening to keyup and other broser were listening to keypress causing inconsistent behaviour in browsers
        pega.util.Event.removeListener(modalDialog.ownerDocument, "keydown", pega.u.d.handleModaldlgKeyPress);
        pega.util.Event.removeListener(document.body, "beforeactivate", pega.u.d.checkAccessKeys);
        pega.u.d.removeModalBtnListeners(modalDialog);
        var closeButton = document.getElementById("container_close");
        if (closeButton) {
            pega.util.Event.removeListener(closeButton, 'click', pega.u.d.closeModalFlowAction);
            pega.util.Event.removeListener(closeButton, "click", pega.u.d.hideModalWindow);
        }
        /*Cleanup menu DIVs in the body after modal hide.*/
        if (pega && pega.c && pega.c.menu && (typeof pega.c.menu.doMenuBarCleanup == "function") && (typeof pega
                .c.menu.doShowMenuCleanup == "function")) {
            pega.c.menu.doMenuBarCleanup(modalDialogBody);
            pega.c.menu.doShowMenuCleanup();
        }
        pega.u.d.nullifyComplexElementsInModal();
        pega.u.d.setAutoCompList();
        pega.u.d.removeElemListeners(modalDialogBody);
        pega.ui.EventsEmitter.publishSync("BeforeModalHide", {
            targets: modalDialogBody
        });
        modalDialogBody.innerHTML = "";
        if (pega.u.d.useOldModalDialog) {
            modalDialogBody.style.width = "";
            modalDialogBody.style.height = "";
            modalDialogBody.style.overflow = "";
            modalDialog.style.width = "";
            modalDialog.style.height = "";
        }
        if (!pega.ctx.activeGrid) {
            if (pega.u.d.regHeavyOperations && pega.u.d.regHeavyOperations == true) {
                pega.u.d.HeavyOperations.registerOnceOnInit("resizeHarness");
            } else {
                pega.u.d.resizeHarness();
            }
        }
        if (document.forms[0] != null) {
            if (document.forms[0].name == "actionForm") {
                parent.pega.u.d.enableElements(true, true, true);
            } /*Bug 57350 Autobots resetting the value*/
            if (harCtxMgr.get("formEncodingType") != null) {
                document.forms[0].encoding = harCtxMgr.get("formEncodingType");
                pega.ctx.modalHasFileEncoding = false;
            }
        }
        pega.ctx.activeGrid = null;
        if (pega.c && pega.c.actionSequencer && !pega.u.d.isAjaxInProgress()) {
            pega.c.actionSequencer.resume();
        }
        var maskDiv = document.getElementById("modaldialog_mask");
        if (maskDiv) {
            pega.util.Event.removeListener(document, "keydown", pega.u.d.restrictFocus);
        }
    });
    pega.u.d.modalDialog.subscribe("show", function() {
        if (pega.c && pega.c.actionSequencer) {
            pega.c.actionSequencer.pause(true);
        }
        if (pega.u.d.useOldModalDialog) {
            pega.u.d.setModalDialogResizeHandle();
        }
        pega.u.d.bModalDialogOpen = true; // moved this up
        pega.u.d.setModalDimensions(); // added this for fixing BUG-195720 bajaa
        if ((document.forms[0] != null) && (document.forms[0].name == "actionForm")) {
            parent.pega.u.d.disableElements(true, true, true);
        }
        if (!pega.u.d.usesModalTemplate) {
            pega.u.d.addModalHeader();
        }
        if (pega.util.Event.isIE) {
            pega.util.Event.addListener(document.body, "beforeactivate", pega.u.d.checkAccessKeys);
        }
        /*Begin Code Change to ensure that FirstFocusableElement Gets the focus on opening the dialog */
       var modalContent = document.querySelector("#modalContent");
        var closeIcon = modalContent.querySelector("#container_close");
        if (closeIcon && pega.cl && pega.cl.isTouchAble()) {
            closeIcon.focus();
        }
        else {
            var firstFocusElem = pega.u.d.getFirstFocusableElement(pega.u.d.modalDialog.innerElement.id);
            if (firstFocusElem && !(firstFocusElem.getAttribute && firstFocusElem.getAttribute(
                    "validationType") && firstFocusElem.getAttribute("validationType").indexOf(
                    "required") > -1)) {
                firstFocusElem.focus();
                pega.u.d.fixFocusInIE(firstFocusElem);
            }
        }
        /* End Code Change to ensure that FirstFocusableElement Gets the focus on opening the dialog */
        /* Begin Code changes for BUG-52047 - moving this code from outer function - chens3*/
        if (mdlDlg) {
            /*BUG-61559 Autobots Start*/
            if (pega.c && pega.c.TextArea) {
                pega.c.TextArea.AutosizeAll(mdlDlg);
            } /*BUG-61559 End*/
            /*Bug-144335 */
            /* BUG-185518: Enter key press event not generating in chrome */
            //BUG-244464 : removing browser specific key event listener as before chrome was listening to keyup and other               browser were listening to keypress causing inconsistent behaviour in browsers
            pega.util.Event.addListener(mdlDlg.ownerDocument, "keydown", pega.u.d.handleModaldlgKeyPress);
        }
        /* End Code changes for BUG-52047 - chens3*/
        /* BUG-70231 adding listener to restrict focus with in the modaldialog*/
        var maskDiv = document.getElementById("modaldialog_mask");
        if (maskDiv) {
            var lastBoundary = pega.u.d.getLastFocusableElement(pega.u.d.modalDialog.innerElement.id);
            pega.util.Event.addListener(document, "keydown", pega.u.d.restrictFocus, [firstFocusElem,
                lastBoundary]);
        }
    });
    if(pega && pega.mobile && pega.mobile.isHybrid){
      try{
        window.addEventListener("orientationchange", function (){
          if (!pega.u.d.useOldModalDialog) {
            pega.u.d.setModalDimensions();
          }
        });
      }catch(e){}
    }
};
/*Start BUG-196987*/
pega.ui.Doc.prototype.fixFocusInIE = function(element) {
    try {
        if (element.setSelectionRange && pega.env && pega.env.ua && pega.env.ua.ie) {
            element.setSelectionRange(0, 0);
        }
    } catch (e) {}
};
/*End BUG-196987*/
/* Reset pega.u.d.submitModalDlgParam variable */
pega.ui.Doc.prototype.resetSubmitModalDlgParam = function() {
    if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.associatedElement) {
        var popOver = pega.u.d.getPopOver(pega.u.d.submitModalDlgParam.associatedElement);
        if (popOver) {
            var popOverContainerElem = popOver.getContentContainerElement();
            if (popOverContainerElem != null) {
                pega.util.Event.removeListener(popOverContainerElem, "keydown", pega.u.d.focusOffOverlay);
            }
            pega.u.d.resetVarInOverlay();
        }
    }
    if (pega.u.d.submitModalDlgParamStack.length > 0) {
        pega.u.d.submitModalDlgParam = pega.u.d.submitModalDlgParamStack.pop();
        pega.u.d.insertButton = pega.u.d.submitModalDlgParam.associatedElement || pega.u.d.submitModalDlgParam.reloadElement;
        if ((pega.ctx.activeGrid == null || typeof(pega.ctx.activeGrid) == "undefined") && (pega.u.d.submitModalDlgParam
                .activeGrid != null && typeof(pega.u.d.submitModalDlgParam.activeGrid) != "undefined")) {
            pega.ctx.activeGrid = pega.u.d.submitModalDlgParam.activeGrid;
        }
    } else {
        pega.u.d.submitModalDlgParam = null;
    }
    if (pega.u.d.bCallModalClose) {
        if (pega.u.d.modalBtnElem) {
            pega.util.Event.fireEvent(pega.u.d.modalBtnElem, 'click');
        }
        pega.u.d.bCallModalClose = false;
        pega.u.d.modalBtnElem = null;
    }
};
/* Reset Global variables when Overlay closes */
pega.ui.Doc.prototype.resetVarInOverlay = function() {
    if (pega.ctx.gridObj && !pega.ctx.activeGrid) {
        pega.ctx.activeGrid = pega.ctx.gridObj;
        pega.ctx.gridObj = null;
    }
    if (pega.ctx.activeGrid) {
      /*BUG-439186 : Associated element not present in dom coz of refresh layout*/
      associatedElement = pega.u.d.submitModalDlgParam.associatedElement;
      if(pega.u.d.submitModalDlgParam.associatedElement.nodeType==1 && !pega.ctx.dom.getContextRoot().contains(pega.u.d.submitModalDlgParam.associatedElement) && pega.u.d.submitModalDlgParam.associatedElement.id ){
         associatedElement = pega.ctx.dom.getElementById(pega.u.d.submitModalDlgParam.associatedElement.id);
      }
        /* BUG-218295 / BUG-206794: Remove grid related properties only when the overlay / modal is launched from Grid row */
        /*BUG-241366: Remove grid related properties when the overlay is launched from embedded pane flow action */
        if (pega.util.Dom.isAncestor(pega.ctx.activeGrid.gridDiv, associatedElement) ||
            (pega.ctx.activeGrid.gridDetailsDiv && pega.util.Dom.isAncestor(pega.ctx.activeGrid.gridDetailsDiv, associatedElement))) {
            delete pega.ctx.activeGrid.isOpenLocalAction;
            delete pega.ctx.activeGrid.__fromLocalAction;
            delete pega.ctx.activeGrid.bNoThreadProcess;
            pega.ctx.activeGrid = null;
        }
    }
};

pega.ui.Doc.prototype.isSrcFromLastTable = function(src, lastBoundary) {
  var table = pega.u.d.findParentTable(lastBoundary);
  if (table && table.getAttribute("uniqueid")) {
    return pega.u.d.findParentTable(src) && pega.u.d.findParentTable(src).getAttribute("uniqueid") !== "";
  }
  return false;
}

/*
Restricts the focus to be within the boundary elements. Used for Modal dialog.
*/
pega.ui.Doc.prototype.restrictFocus = function(keyPressEvent, boundaryElts) {
    if (!boundaryElts || !(boundaryElts instanceof Array) || boundaryElts.length < 2) {
        return;
    }
    var errorSectionUl = document.getElementsByClassName("pageErrorList layout-noheader-errors");
    if (pega.u.d.isAccessible && errorSectionUl[0]) {
        boundaryElts[0] = errorSectionUl[0];
    }
    var src = pega.util.Event.getTarget(keyPressEvent);
    /*key code for TAB is 9*/
    if (keyPressEvent.keyCode == 9) {
        if (keyPressEvent.shiftKey) {
            if (src.id == "container_close") {
                try {
                    boundaryElts[1].focus();
                } catch (e) {}
                pega.util.Event.stopEvent(keyPressEvent);
            } else if (src && src.getAttribute('id') == "modaldialog_mask") {
                try {
                    boundaryElts[1].focus();
                } catch (e) {}
                pega.util.Event.stopEvent(keyPressEvent);
            } else if (!(pega.util.Dom.isAncestor(pega.u.d.modalDialog.body, src)  || pega.u.d.isIframeInsideModal(boundaryElts, src) || document.querySelector('div[role="dialog"]'))) {
                try {
                    boundaryElts[1].focus();
                } catch (e) {}
                pega.util.Event.stopEvent(keyPressEvent);
            } else if (src === boundaryElts[0]) {
                var _closeIcon = document.querySelector("#container_close[title]");
                if (_closeIcon != null) {
                  _closeIcon.focus();
                } else {
                  try {
                      var table = pega.u.d.findParentTable(boundaryElts[1]);
                      if (table && table.getAttribute("uniqueid")) {
                        table.getElementsByTagName("th")[1].focus();
                      } else {
                        boundaryElts[1].focus();
                      }
                  } catch (e) {}
                }
                pega.util.Event.stopEvent(keyPressEvent);
            }
        } else if (src == boundaryElts[1] || (boundaryElts[1] && pega.u.d.isSrcFromLastTable(src, boundaryElts[1]))) {
          // BUG-765690 : restrict focus within modal when template grid without pagination is present at end of the section in modal
            var closeIcon = document.querySelector("#container_close[title]");
            if (closeIcon != null) {
                closeIcon.focus();
            } else {
                /*BUG-141002: Removed the case for Accordion and Tab anchors which were made for accessibility.*/
                /*if(boundaryElts[0].tagName == "A" && (boundaryElts[0].id.indexOf("ACCORANCHOR") != -1 || boundaryElts[0].id.indexOf("TABANCHOR") != -1) && boundaryElts[0].parentNode.className.indexOf("selected") != -1){
                    try{
                        boundaryElts[0].parentNode.focus();
                    }catch(e){}
                }
                else{*/
                /*BUG-149186:Added case when first focusable element is RTE.*/
                if (boundaryElts[0] && boundaryElts[0].nodeName == 'TEXTAREA' && boundaryElts[0].className.indexOf(
                        'PEGACKEDITOR') != -1) {
                    if (CKEDITOR.instances[boundaryElts[0].id].instanceReady) {
                        try {
                            CKEDITOR.instances[boundaryElts[0].id].focus();
                        } catch (e) {}
                    }
                } else {
                    try {
                        boundaryElts[0].focus();
                    } catch (e) {}
                }
                /* } */
            }
            pega.util.Event.stopEvent(keyPressEvent);
        }
    }
};
pega.ui.Doc.prototype.isFocusableNode = function(currentElem) {
        var focusableNode = true;
        switch (currentElem.nodeName) {
            case "BUTTON":
            case "INPUT":
            case "SELECT":
            case "TEXTAREA":
            case "A":
                break;
            default:
                focusableNode = false;
        }
        if ((focusableNode || (currentElem.attributes.tabIndex && currentElem.tabIndex != -1)) && (currentElem.disabled !=
                true && currentElem.offsetHeight > 0 && (currentElem.readOnly != true || currentElem.hasAttribute("data-editable")) && currentElem.type != "hidden" &&
                currentElem.style.display != "none" && currentElem.id != "ModalHelpButton" && currentElem.id !=
                "container_close")) {
            return true;
        } else return false;
    }

/*
Returns the first input, select, button or radio in the given element with id elementID
@return $object$
*/
pega.ui.Doc.prototype.getFirstFocusableElement = function(elementID, container, iframeID) {
    if (elementID == undefined || elementID == null) {
        return;
    }
    var container = (container == undefined) ? document : container;
    var elem = document.getElementById(elementID);
    if (elem) {
        if (elem.hasChildNodes()) {
            var collection;
            if(iframeID) {
              collection = elem.querySelector("#" + iframeID).contentWindow.document.getElementsByTagName('*');
            } else {
              collection = elem.getElementsByTagName('*');
            }
            var colLength = collection.length;
            for (var i = 0; i < colLength; i++) {
                var currentElem = collection[i];
                /*BUG-145256: We need to return the CKEDITOR textarea element before the below check on all the focusable elements is performed as the condition "currentElem.style.display" will always return "none" for readonly/editable RTE.*/
                if (currentElem.nodeName == "TEXTAREA" && currentElem.className.indexOf('PEGACKEDITOR') != -1) {
                    var editorData = currentElem.getAttribute("data-config");
                    var parsedData = JSON.parse(editorData);
                    if (parsedData[1].readOnly == "false") {
                        return currentElem;
                    }
                }
                /* BUG-70231  added button element to conditional check to get first focuable button element, which is not a container close button and etc */
                if (currentElem != null && pega.u.d.isFocusableNode(currentElem)) {
                    if (!(currentElem.nodeName.toLowerCase() == "a" && currentElem.className.indexOf('cke_') == 0)) { /*BUG-149186: Do not include ckeditor anchors.*/
                        if (currentElem.nodeName.toLowerCase() == "a" && currentElem.id == "ACCORANCHOR" &&
                            currentElem.tabIndex == -1) {
                            /*BUG-138734:If currentElem is accordion anchor, focus the parent LI, as anchors for accordions are not focusable.*/
                            return currentElem.parentNode;
                        }
                        /*Check if this is not the dropdown in a tabbed layout */
                        else if (currentElem.parentNode.parentNode.tagName != "OL" && currentElem.parentNode.parentNode
                            .style.display != "none") {
                            return currentElem;
                        }
                    }
                }
            }
            //If there is no focussable element and close icon is present, return close icon
            var closeIcon = document.querySelector("#container_close[title]");
            if (closeIcon != null) {
                return closeIcon;
            }
        } else {
            //no children, check if nodeName is input
            if (elem.nodeName == "INPUT") {
                if (elem.type != null && elem.type == "radio" && elem.checked) return elem;
                else if (elem.type != null && elem.type != "radio") return elem;
            }
        }
    }
    return;
};
/*
Returns the last input, select, button or radio in the given element with id elementID
@return $object$
*/
pega.ui.Doc.prototype.getLastFocusableElement = function(elementID, container, iframeID) {
    if (elementID == undefined || elementID == null) {
        return;
    }
    var container = (container == undefined) ? document : container;
    /*var elemArray = pega.util.Dom.getElementsById(elementID, container);*/ // can't we just use document.getElementById()??
    var elem = document.getElementById(elementID);
    if (elem) {
        if (elem.hasChildNodes()) {
            var collection;
            if(iframeID) {
              collection = elem.querySelector("#" + iframeID).contentWindow.document.getElementsByTagName('*');
            } else {
              collection = elem.getElementsByTagName('*');
            }
            var colLength = collection.length;
            for (var i = colLength - 1; i >= 0; i--) {
                var currentElem = collection[i];
                if (currentElem != null && (currentElem.nodeName.toUpperCase() == "BUTTON" || currentElem.nodeName ==
                        "INPUT" || currentElem.nodeName == "SELECT" || currentElem.nodeName == "TEXTAREA" ||
                        currentElem.nodeName == "A" || ((currentElem.nodeName === "TD" || currentElem.nodeName === "TH" 
                        || currentElem.nodeName === "DIV") && currentElem.attributes.tabIndex &&
                        currentElem.tabIndex != -1)) && (currentElem.type != "hidden" && currentElem.style
                        .display != "none" && currentElem.offsetHeight > 0) && (!currentElem.disabled)) {
                    return currentElem;
                }
            }
        } else {
            //no children, check if nodeName is input
            if (elem.nodeName == "INPUT") {
                if (elem.type != null && elem.type == "radio" && elem.checked) return elem;
                else if (elem.type != null && elem.type != "radio") return elem;
            }
        }
    }
    return;
};


pega.ui.Doc.prototype.setBoundaryElementsFromIframe = function(iframeID) {
    var modalEl = document.getElementById("modalContent");
    var iframeElem = modalEl.querySelector("#" + iframeID).contentWindow.document.body;
    pega.util.Event.removeListener(modalEl, "keydown", pega.u.d.restrictFocus);
    pega.util.Event.removeListener(iframeElem, "keydown", pega.u.d.restrictFocus);
    var firstBoundary = pega.u.d.getFirstFocusableElement('modalContent', undefined, iframeID);
    var lastBoundary = pega.u.d.getLastFocusableElement('modalContent', undefined, iframeID);
    pega.util.Event.addListener(modalEl, "keydown", pega.u.d.restrictFocus, [firstBoundary, lastBoundary, {iframeID: iframeID}]);
    pega.util.Event.addListener(iframeElem, "keydown", pega.u.d.restrictFocus, [firstBoundary, lastBoundary, {iframeID: iframeID}]);
    if(firstBoundary) {
      pega.u.d.focusDomElement(firstBoundary);
    }
}

pega.ui.Doc.prototype.isIframeInsideModal = function(boundaryElts, src) {
  if(boundaryElts.length >=3 && boundaryElts[2].iframeID) {
    var iframe = document.getElementById(boundaryElts[2].iframeID);
    if(pega.util.Dom.isAncestor(pega.u.d.modalDialog.body, iframe)) {
      return pega.util.Dom.isAncestor(iframe.contentWindow.document, src)
    }
  }
  return false;
}


pega.ui.Doc.prototype.modalDialogRendered = function() {
    pega.u.d.bModalRendered = true;
};
pega.ui.Doc.prototype.modalDialogLoaded = function() {
    if (pega.u.d.useOldModalDialog) return pega.u.d.modalDialog.cfg.getProperty("visible");
    else return pega.u.d.modalDialog.bModalOpen;
};
/*
@private  hides the modaldialog div rendered as Modal Window
@return $void$
*/
pega.ui.Doc.prototype.hideModalWindow = function() {
   // BUG-527695 : Dirty confirm modal and flow action modal are using same modal outer markup. Modal outer markup never get clean from DOM even though no modal is active. Dirty confirm modal add max height and width to modal wrapper which cause problem when we launch flow action modal again with overflow in it.
  
  if(pega.u.d.isDirtyDialogOpen){
       $(".modal-overlay .modal-wrapper > .modal-content").css({'max-height': 'none', 'max-width': 'none'});
       delete pega.u.d.isDirtyDialogOpen;
    }
  
    pega.ui.HarnessContextMgr.set("KeepMessages", "false");
    pega.u.d.modalDialog.hide();
};
pega.ui.Doc.prototype.unregisterModalListener = function(modalCallbackFunc) {
    var modalCallbackLength = this.modalCallback.length;
    for (var i = 0; i < modalCallbackLength; i++) {
        if (this.modalCallback[i] == modalCallbackFunc) {
            this.modalCallback.splice(i, 1);
        }
    }
};
/*
@protected Deprecated.displays the section using the arguments passed. used by grid control for editing a page in a pagelist
@param $String$sectionName - Name of the section
@param $String$pageName - Page Name to be used as the Primary page of the section
@param $HTMLElement$parentDiv - Div object that hosts the section content
@param $boolean$sectionOnly - If true, returns only Section stream without buttons. If false, returns with submit and cancel buttons
@param $Object$onAfterSubmit - callback method to be invoked after successful submit, Optional
@param $Object$onAfterCancel - callback method to be invoked if cancel from the modal window, Optional
@param $Object$specialButtons - special buttons to be included in the stream
@param $Object$displayAtClick - Set this to show the position modal dialog at the click location. Default behaviour is to center the dialog wrt screen.
@param $Object$templateModalSecName- Template name of modal dialog which can configure ok, cancel buttons. Default - pyModalTemplate.
@param $Object$sectionParams - Pass Section parameters to $sectionName.
@Deprecated. Use displaySectionInTemplate.
@return $HTMLElement$ - Element representing the div that hosts the section
*/
pega.ui.Doc.prototype.displaySection = function(sectionName, pageName, parentDiv, sectionOnly, onAfterSubmit,
    onAfterCancel, specialButtons, displayAtClick, templateModalSecName, sectionParams) {
    var bShowAsModal = false;
    pega.u.d.usesModalTemplate = true;
    var eventArr = null;
    if (pega.u.d.useOldModalDialog) displayAtClick = false;
    if (displayAtClick) {
        try {
            var ev = pega.util.Event.getEvent();
            eventArr = [ev, ev.clientX, ev.clientY];
        } catch (e) {}
    }
    if (!parentDiv) {
        parentDiv = pega.u.d.modalDialog.innerElement;
        if (typeof(templateModalSecName) == "undefined" || templateModalSecName == null || templateModalSecName ==
            "") {
            templateModalSecName = 'pyModalTemplate';
        }
        bShowAsModal = true;
    } else {
        templateModalSecName = sectionName;
    }
    var oArgs = {
        reloadElement: parentDiv,
        bFormSubmit: false,
        bSectionSubmit: false,
        bDoNotSetAll: true,
        strReloadType: 'ShowSection',
        streamName: templateModalSecName,
        pageName: pageName,
        onAfterSubmit: onAfterSubmit,
        onAfterCancel: onAfterCancel,
        bShowAsModal: bShowAsModal,
        includedStreamName: sectionName,
        sectionOnly: sectionOnly,
        specialButtons: specialButtons,
        displayAtClick: eventArr,
        sectionParams: sectionParams
    };
    this.reload(oArgs);
    return parentDiv;
};
/*
 @private Callback api for Overlay. Gets called from processActionModal_Success.
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.overlayCallBack = function() {
    var overlayNode = pega.u.d.gCallbackArgs.overlayNode;
    /* BUG-79165: loadHTMLEleCallback api calling internally from popOver.open api. Two calls to this api causing the issue. */
    /* pega.u.d.loadHTMLEleCallback(overlayNode); */
    var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
    pega.u.d.submitModalDlgParam.associatedElement = pega.u.d.insertButton;
    /* TASK:265560 GUJAS1 01/16/2015 Added onContentReady callback argument to the call to open*/
    // Added code for Center Position Overlay
    popOver.open({
        content: {
            type: 'domElement',
            element: overlayNode
        },
        bindings: {
            associatedElement: pega.u.d.insertButton
        },
        buttons: {
            ok: false,
            cancel: false
        },
        callbacks: {
            onContentDisplayed: [pega.u.d.focusOverlay, '', pega.u.d],
            onClose: [pega.u.d.closeOverlay, '', pega.u.d],
            onContentReady: [pega.u.d.handleOverlayContentReady, '', pega.u.d]
        },
        position: {
            fieldAttach: 'leftBottom',
            popOverAttach: 'leftTop',
            size: {
                min: {
                    y: 20
                }
            }
        },
        visual: {
            animations: pega.u.d.submitModalDlgParam.animObj,
            displayLoader: false,
            contentClass: 'overlayPO',
            isMobileFullScreen: pega.u.d.submitModalDlgParam.isMobileFullScreen,
            isLocalAction: pega.u.d.submitModalDlgParam.isLocalAction
        },
        extraParams: {
            refresh: true,
            setMaxHeightAndWidth: true,
            modalStyle: pega.u.d.gCallbackArgs.modalStyle,
            bIsDisableClickaway: "" + pega.u.d.gCallbackArgs.bIsDisableClickaway,
            bIsCenterOverlay: "" + pega.u.d.gCallbackArgs.bIsCenterOverlay
        }
    });
    pega.u.d.gBusyInd.hide();
    pega.u.d.gCallbackArgs = null;
};
/* TASK:265560 GUJAS1 01/16/2015 Added onContentReady callback */
/*
 @private Callback api for onContentReady event in Overlay.
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.handleOverlayContentReady = function(poContainer) {
    // poContainer is a reference to the top level pop over container element.
    // Add "Close" icon to the overlay only on mobile.
    if (pega.u.d.allowTransition()) {
        var closeIcon = $("<div></div>").addClass("container-close").click(function(event) {
            if (typeof(pega) != 'undefined' && pega.u.d) setUserStart();
            doOverlayAction('', event);
        });
        $(poContainer).prepend(closeIcon);
    }
};
pega.ui.Doc.prototype.focusOffOverlay = function(keyPressEvent, boundaryElts) {
    var src = pega.util.Event.getTarget(keyPressEvent);
    /*key code for TAB is 9*/
    if (keyPressEvent.keyCode == 9) {
        /*US-91158:Overlay accessibility */
        /* Since this block closes the overlay once the tab goes past the last element of overlay, this will not be called. */
        return;
        /*if(keyPressEvent.shiftKey) {
            if(src == boundaryElts[0]) {
                try{
                    boundaryElts[1].focus();
                }catch(e){}
                pega.util.Event.stopEvent(keyPressEvent);
            }
        } else if(src == boundaryElts[1]) {
            var activeOverlay = boundaryElts[2];
            var currentPopOver = pega.u.d.getPopOverLevel(activeOverlay);
            var rootPopOver = pega.u.d.getPopOver(currentPopOver);
            pega.util.Event.stopEvent(keyPressEvent);
            rootPopOver.close("tabclickaway");
        }*/
    }
};
pega.ui.Doc.prototype.focusOverlay = function(activeOverlay) {
    /* BUG-169932: removing auto focus to first field for touchable control */
    if (pega.cl && pega.cl.isTouchAble() && pega.u.d.isMobile()) {
        return;
    }
    var firstFocusElem = pega.u.d.getFirstFocusableElement(activeOverlay.id);
    var lastFocusElem = pega.u.d.getLastFocusableElement(activeOverlay.id);
    if (firstFocusElem) {
        if (firstFocusElem && firstFocusElem.nodeName == 'TEXTAREA' && firstFocusElem.className.indexOf(
                'PEGACKEDITOR') != -1) {
            setTimeout(function() {
                if (CKEDITOR) {
                    for (var i in CKEDITOR.instances) {
                        if (firstFocusElem.id == CKEDITOR.instances[i].name) {
                            if (CKEDITOR.instances[i].loaded && ((pega.env.ua.gecko > 0) ? CKEDITOR.instances[
                                    i]._.instanceReady : true)) {
                                if ((window.chrome != null && typeof(window.chrome) != "undefined") || pega.util
                                    .Event.isIE) {
                                    window.setTimeout(function() {
                                        CKEDITOR.instances[i].focus();
                                    }, 200);
                                } else {
                                    CKEDITOR.instances[i].focus();
                                }
                            } else {
                                CKEDITOR.instances[i].on('instanceReady', function() {
                                    try {
                                        CKEDITOR.instances[i].focus();
                                    } catch (e) {}
                                });
                            }
                            break;
                        }
                    }
                }
            }, 70);
        } else if (firstFocusElem) {
            var _isInputElment = true;
            try {
                var associateElement = pega.u.d.submitModalDlgParam.associatedElement;
                if (pega.u.d.submitModalDlgParam && associateElement) {
                    var _associatedElemType = associateElement.type;
                    var IsAssociatedElemInsideModal = pega.u.d.modalDialog && 
                        pega.util.Dom.isAncestor(pega.u.d.modalDialog.body, associateElement) ? true : false;
                    if (typeof(_associatedElemType) === "string" && ((_associatedElemType === "button" && !IsAssociatedElemInsideModal) ||
                            _associatedElemType === "a")) {
                        _isInputElment = false;
                    }
                }
            } catch (e) {}
            /* BUG-169089: In chrome & firefox, set time out delay causing issue when set focus event following by launch overlay */
            if (_isInputElment && ((window.chrome != null && typeof(window.chrome) != "undefined") || navigator.userAgent
                    .indexOf('Firefox/') >= 0)) {
                firstFocusElem.focus();
            } else {
                window.setTimeout(function() {
                    try {
                        firstFocusElem.focus();
                        pega.u.d.fixFocusInIE(firstFocusElem);
                    } catch (e) {}
                }, 50);
            }
        }
        var faContent = pega.util.Dom.getElementsById("pyFlowActionHTML", activeOverlay, "DIV");
        var overlayTitle;
        if (faContent && faContent.length > 0) {
            overlayTitle = faContent[0].getAttribute("FA_TITLE");
            overlayTitle = overlayTitle.replace(/^\s+|\s+$/g, "");
        } else {
            overlayTitle = "";
        }
        activeOverlay.setAttribute("role", "dialog");
        activeOverlay.setAttribute("aria-label", overlayTitle);
        pega.util.Event.addListener(activeOverlay, "keydown", pega.u.d.focusOffOverlay, [firstFocusElem,
            lastFocusElem, activeOverlay]);
    } else {
        activeOverlay.setAttribute("role", "tooltip");
    }
    /* US-91158: Overlay accessibility */
    /* Focus the popover body if there is no focussable element*/
    var liContainingpopOver = $(activeOverlay).find("li:eq(0)")[0];
    if (!($(':not(.dummyBtn):tabbable:first', liContainingpopOver).length)) {
        var dialogBody = pega.util.Dom.getElementsByClassName('sectionDivStyle', 'div', liContainingpopOver);
        if (dialogBody.length > 0) {
            dialogBody[0].setAttribute('tabindex', 0);
            dialogBody[0].focus();
        }
    }
};
/*
 @private Callback api for modal dialog. Gets called from processActionModal_Success.
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.modalDialogCallBack = function() {
    var callbackArgs = pega.u.d.gCallbackArgs;
    if (pega.u.d.useOldModalDialog) {
        callbackArgs.modalDialogBody.parentNode.style.width = ""; /*Added this line befor loadHTMLEleCallback to avoid the auto increamental of width */
    }
    /* Set the modal style on the fly */
    if (callbackArgs.modalDialogBody.parentNode.parentNode) {
        var dialogc_Class = callbackArgs.modalDialogBody.parentNode.parentNode.className.split(" ");
        if (callbackArgs.modalStyle && callbackArgs.modalStyle != "") {
            callbackArgs.modalDialogBody.parentNode.parentNode.className = dialogc_Class[0] + " " + callbackArgs.modalStyle;
        } else {
            /*
                BUG-174640: From the assumption of the above line that the modal dialog has only one default class.
                            Changing dialogc_Class.join(' ') to dialogc_Class[0] as modalStyle from previous modal is populating to new modal without modalStyle.
            */
            callbackArgs.modalDialogBody.parentNode.parentNode.className = dialogc_Class[0];
        }
    }
    if (!pega.u.d.useOldModalDialog) {
        pega.u.d.setModalDimensions();
    }
    pega.u.d.bResizeModalDlg = false;
    /* pega.u.d callresizeharness variable is set to false to avoid  resizeharness call  in loadHTMLEleCallback when opening a modal dialog */
    pega.u.d.callResizeHarness = false;
    pega.u.d.loadHTMLEleCallback(callbackArgs.domObj);
    pega.u.d.callResizeHarness = true;
    var closeBtnApi = "";
    var displayAtClick = "";
    var paramObj = "";
    if (callbackArgs.bShowAsModal || callbackArgs.bIsFlowActionModal || pega.u.d.bModalDialogOpen) {
        if (pega.u.d.useOldModalDialog) {
            if (pega.u.d.modalTabContentWidth == 0) {
                callbackArgs.modalDialogBody.parentNode.style.width = parseInt(callbackArgs.modalDialogBody.scrollWidth) +
                    pega.u.d.SCROLL_ADJUSTMENT + 'px';
            }
            pega.u.d.resizeModalDialog();
            if (typeof(callbackArgs.displayAtClick) != "undefined" && callbackArgs.displayAtClick) {
                displayAtClick = callbackArgs.displayAtClick;
            }
        }
    }
    if (callbackArgs.bIsFlowActionModal) {
        //callbackArgs.returnNode.innerHTML = callbackArgs.strResponse;
        //pega.u.d.handleFormErrors(callbackArgs.returnNode);
        if (pega.u.d.useOldModalDialog) {
            pega.u.d.positionModalDialog(callbackArgs);
        }
        pega.u.d.processModalCallbak("OPEN");
        closeBtnApi = pega.u.d.closeModalFlowAction;
    }
    if (pega.u.d.useOldModalDialog) {
        pega.u.d.bResizeModalDlg = true;
    }
    if (callbackArgs.sectionOnly === false) {
        paramObj = {
            parentDiv: callbackArgs.parentDiv,
            onAfterSubmit: callbackArgs.onAfterSubmit,
            onAfterCancel: callbackArgs.onAfterCancel,
            bShowAsModal: callbackArgs.bShowAsModal,
            streamName: callbackArgs.streamName,
            pageName: callbackArgs.pageName,
            specialButtons: callbackArgs.specialButtons,
            label: "",
            bClose: true,
            includedStreamName: callbackArgs.includedStreamName,
            sectionOnly: callbackArgs.sectionOnly,
            sectionParams: callbackArgs.sectionParams
        };
        pega.u.d.attachModalBtnListeners({
            submitClickApi: pega.u.d.submitSection,
            cancelClickApi: pega.u.d.cancelSection
        }, paramObj);
        if (callbackArgs.bShowAsModal) {
            closeBtnApi = pega.u.d.cancelSection;
        }
    }
    if (callbackArgs.bShowAsModal || callbackArgs.bIsFlowActionModal) {
        pega.u.d.attachCloseBtnListeners({
            closeBtnApi: closeBtnApi
        }, paramObj);
    }
    if (callbackArgs.specialButtons) {
        var button = null;
        var spButton = null;
        paramObj = null;
        var length = callbackArgs.specialButtons.length
        for (var i = 0; i < length; i++) {
            spButton = callbackArgs.specialButtons[i];
            button = pega.util.Dom.getElementsById("Modal" + spButton.caption, callbackArgs.parentDiv);
            if (button && button.length > 0) {
                button = button[0];
                if (spButton.disable == true) {
                    button.disabled = true;
                } else {
                    button.disabled = false;
                    paramObj = {
                        parentDiv: callbackArgs.parentDiv,
                        onAfterSubmit: callbackArgs.onAfterSubmit,
                        onAfterCancel: callbackArgs.onAfterCancel,
                        bShowAsModal: callbackArgs.bShowAsModal,
                        streamName: callbackArgs.streamName,
                        pageName: callbackArgs.pageName,
                        specialButtons: callbackArgs.specialButtons,
                        label: spButton.caption,
                        bClose: spButton.close,
                        includedStreamName: callbackArgs.includedStreamName,
                        sectionOnly: callbackArgs.sectionOnly,
                        sectionParams: callbackArgs.sectionParams
                    };
                    pega.util.Event.addListener(button, "click", pega.u.d.submitSection, paramObj, this);
                }
            }
        }
    }
    if (callbackArgs.bShowAsModal && (displayAtClick)) {
        var modalDialogDiv = pega.u.d.modalDialog.innerElement;
        var scrollObject = pega.u.d.getScrollObj(modalDialogDiv);
        var currWindow = "";
        var scrollObj = "";
        var winTop = 0;
        if (scrollObject) {
            scrollObj = scrollObject[0];
            currWindow = scrollObject[1];
            winTop = scrollObject[2];
        } else {
            scrollObj = window.document.body;
            currWindow = window;
            winTop = 0;
        }
        if (currWindow == window) {
            if (displayAtClick) {
                displayAtClick[2] = displayAtClick[2] + scrollObj.scrollTop;
            }
        }
        var top = pega.u.d.getCoordinates(modalDialogDiv)[1] + parseInt(winTop) - pega.u.d.getCoordinates(scrollObj)[
            1];
        var offsetHeight = scrollObj.offsetHeight;
        if (scrollObj == currWindow.document.body && !pega.util.Event.isIE) offsetHeight = currWindow.innerHeight;
        var diff = top + modalDialogDiv.offsetHeight - parseInt(scrollObj.scrollTop) - parseInt(offsetHeight);
        if (diff > 0) {
            if (displayAtClick) pega.u.d.modalDialog.cfg.setProperty("y", displayAtClick[2] - diff - 10);
            else pega.u.d.modalDialog.cfg.setProperty("y", (pega.u.d.modalDialog.cfg.getProperty("y")) - diff - 10);
        } else if (displayAtClick) {
            pega.u.d.modalDialog.cfg.setProperty("y", displayAtClick[2]);
        }
    } else if (callbackArgs.bShowAsModal && pega.u.d.bModalDialogOpen && pega.u.d.useOldModalDialog) {
        pega.u.d.positionModalDialog(callbackArgs);
    }
    if (pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide) {
        pega.u.d.gBusyInd.hide(null, true);
    }
    pega.u.d.gCallbackArgs = null;
    if (typeof LayoutGroupModule != "undefined") {
        LayoutGroupModule.checkForErrors();
    }
    setTimeout(function() {
        pega.u.d.focusOnModalDialogFirstElement();
    }, 0);
};
pega.ui.Doc.prototype.positionModalDialog = function(callbackArgs) {
    if (!pega.u.d.useOldModalDialog) return;
    if (!callbackArgs.bFixedCenter) {
        var left = 10;
        if (document.body.offsetWidth > callbackArgs.modalDialogBody.offsetWidth) {
            left = parseInt(document.body.offsetWidth - callbackArgs.modalDialogBody.offsetWidth) / 2 + document.body
                .scrollLeft;
        }
        pega.u.d.modalDialog.cfg.setProperty("x", left);
        var wagIframeEle = null;
        var isPortal = false;
        var panelDiv = null;
        var portalHarnessBody = null;
        var isActionIframe = (window.frames.name == "actionIFrame");
        if (isActionIframe) {
            wagIframeEle = window.parent.frameElement;
            if (wagIframeEle != null && typeof(wagIframeEle.PegaWebGadget) != "undefined" && typeof(window.parent.parent
                    .pega) != "undefined" && typeof(window.parent.parent.pega.u) != "undefined" && typeof(window.parent
                    .parent.pega.u.d) != "undefined" && window.parent.parent.pega.u.d.isPortal()) {
                isPortal = true;
                panelDiv = parent.pega.u.d.getPanelDiv();
                portalHarnessBody = parent.parent.document.body;
            }
        } else {
            wagIframeEle = window.frameElement;
            if (wagIframeEle != null && typeof(wagIframeEle.PegaWebGadget) != "undefined" && typeof(window.parent.pega) !=
                "undefined" && typeof(window.parent.pega.u) != "undefined" && typeof(window.parent.pega.u.d) !=
                "undefined" && window.parent.pega.u.d.isPortal()) {
                isPortal = true;
                panelDiv = pega.u.d.getPanelDiv();
            }
        }
        if (isPortal && panelDiv) {
            if (panelDiv.parentNode.offsetHeight < callbackArgs.modalDialogBody.offsetHeight) {
                pega.u.d.modalDialog.cfg.setProperty("y", 0);
            }
        } else if (parent.document.body.offsetHeight < callbackArgs.modalDialogBody.offsetHeight) {
            pega.u.d.modalDialog.cfg.setProperty("y", 0);
        }
        var top = pega.u.d.modalDialog.cfg.getProperty("y");
        top = callbackArgs.top;
        var offset = 0;
        if (isPortal && panelDiv) {
            if (isActionIframe) {
                offset = pega.u.d.getOffSet(window.frameElement, window.parent.frameElement.contentWindow.document.body) +
                    pega.u.d.getOffSet(wagIframeEle, portalHarnessBody) - pega.u.d.getOffSet(panelDiv,
                        portalHarnessBody);
            } else {
                offset = pega.u.d.getOffSet(window.frameElement, panelDiv.parentNode);
            }
            if (isActionIframe) {
                if ((panelDiv.parentNode.scrollTop - offset) > 0) {
                    if ((top - (panelDiv.parentNode.scrollTop - offset)) < (callbackArgs.modalDialogBody.offsetHeight /
                            2)) {
                        top = panelDiv.parentNode.scrollTop - offset;
                    }
                } else {
                    if ((top - (offset - panelDiv.parentNode.scrollTop)) < (callbackArgs.modalDialogBody.offsetHeight /
                            2)) {
                        top = 0;
                    }
                }
            } else {
                if (panelDiv.parentNode.scrollTop > offset && ((top - (callbackArgs.modalDialogBody.offsetHeight / 2)) <
                        (panelDiv.parentNode.scrollTop - offset))) {
                    top = panelDiv.parentNode.scrollTop - offset + ((document.body.offsetHeight - (panelDiv.parentNode
                        .scrollTop - offset)) / 2);
                }
                if (top > (callbackArgs.modalDialogBody.offsetHeight / 2)) {
                    top = top - (callbackArgs.modalDialogBody.offsetHeight / 2);
                } else {
                    top = top - (callbackArgs.modalDialogBody.offsetHeight / 2 - top) - (callbackArgs.modalDialogBody
                        .offsetHeight / 2);
                    if (top < 0) {
                        top = 0;
                    }
                }
            }
        } else if (isActionIframe) {
            offset = pega.u.d.getOffSet(window.frameElement, window.parent.document.body);
            if (offset > parent.document.body.scrollTop) {
                if ((parent.document.body.clientHeight - offset) > callbackArgs.modalDialogBody.offsetHeight) {
                    if (top > (callbackArgs.modalDialogBody.offsetHeight / 2)) {
                        top = top - (callbackArgs.modalDialogBody.offsetHeight / 2);
                    }
                } else {
                    top = 0;
                }
            } else {
                if (parent.document.body.clientHeight > callbackArgs.modalDialogBody.offsetHeight) {
                    top = top - (callbackArgs.modalDialogBody.offsetHeight / 2);
                } else {
                    top = parent.document.body.scrollTop - offset;
                }
            }
        }
        if (((top + callbackArgs.modalDialogBody.offsetHeight) > document.body.offsetHeight)) {
            top = document.body.offsetHeight - callbackArgs.modalDialogBody.offsetHeight;
        }
        if (top >= 0) {
            pega.u.d.modalDialog.cfg.setProperty("y", top);
        }
    } else {
        /* set fixed center to true so that the Modal dialog positions it self to the center of the screen*/
        pega.u.d.modalDialog.cfg.setProperty("fixedcenter", true);
    }
    if (callbackArgs.modalDialogBody.style.overflow == "auto") {
        callbackArgs.modalDialogBody.scrollTop = 0;
    }
};
pega.ui.Doc.prototype.prePositionModalDialog = function() {
    if (!pega.u.d.useOldModalDialog) {
        return new Array(true, 0);
    }
    try { // added try catch for cross-domain exceptions.
        var isQuirks = (parent.document.compatMode == "BackCompat");
        var bFixedCenter = true;
        var wagIframeEle = null;
        var isPortal = false;
        var panelDiv = null;
        var portalHarnessBody = null;
        if (window.frames.name == "actionIFrame") {
            wagIframeEle = window.parent.frameElement;
            if (wagIframeEle != null && typeof(wagIframeEle.PegaWebGadget) != "undefined" && typeof(window.parent.parent
                    .pega) != "undefined" && typeof(window.parent.parent.pega.u) != "undefined" && typeof(window.parent
                    .parent.pega.u.d) != "undefined" && window.parent.parent.pega.u.d.isPortal()) {
                isPortal = true;
                panelDiv = parent.pega.u.d.getPanelDiv();
                portalHarnessBody = parent.parent.document.body;
            }
        } else {
            wagIframeEle = window.frameElement;
            if (wagIframeEle != null && typeof(wagIframeEle.PegaWebGadget) != "undefined" && typeof(window.parent.pega) !=
                "undefined" && typeof(window.parent.pega.u) != "undefined" && typeof(window.parent.pega.u.d) !=
                "undefined" && window.parent.pega.u.d.isPortal()) {
                isPortal = true;
                panelDiv = pega.u.d.getPanelDiv();
            }
        }
        if (isPortal && panelDiv) {
            if (panelDiv.parentNode.offsetHeight < document.body.offsetHeight) bFixedCenter = false;
        } else if (window.frameElement && window.frameElement.tagName.toUpperCase() == "IFRAME" && parent.document.body) {
            var parentClientHeight = isQuirks ? parent.document.body.clientHeight : parent.document.documentElement.clientHeight;
            if (parentClientHeight < document.body.clientHeight) {
                bFixedCenter = false;
            }
        }
        var top = 0;
        if (!bFixedCenter) {
            pega.u.d.modalDialog.cfg.setProperty("fixedcenter", false);
            if (isPortal && panelDiv) {
                var offset = 0;
                if (window.frames.name == "actionIFrame") {
                    offset = pega.u.d.getOffSet(window.frameElement, window.parent.frameElement.contentWindow.document
                        .body) + pega.u.d.getOffSet(wagIframeEle, portalHarnessBody) - pega.u.d.getOffSet(
                        panelDiv, portalHarnessBody);
                } else {
                    offset = pega.u.d.getOffSet(window.frameElement, panelDiv.parentNode);
                }
                if (panelDiv.parentNode.offsetHeight < document.body.offsetHeight) {
                    top = ((panelDiv.parentNode.offsetHeight) / 2) - (offset) + panelDiv.parentNode.scrollTop;
                    if (top > 0) {
                        pega.u.d.modalDialog.cfg.setProperty("y", top);
                    }
                }
            } else {
                var parentClientHeight = isQuirks ? parent.document.body.clientHeight : parent.document.documentElement
                    .clientHeight;
                var parentScrollTop = parent.document.body.scrollTop || parent.document.documentElement.scrollTop;
                if (parentClientHeight < document.body.clientHeight) {
                    // BUG-75718 : added code for modal dialogs loaded inside IAC gadget.
                    if (window.frames.name == "actionIFrame" || (window.frameElement && window.frameElement.parentNode &&
                            window.frameElement.parentNode.attributes["PegaGadget"] && window.frameElement.parentNode
                            .attributes["PegaGadget"].nodeValue)) {
                        var offset = 0;
                        offset = pega.u.d.getOffSet(window.frameElement, window.parent.document.body);
                        if (parentScrollTop > offset) {
                            top = parentScrollTop - offset + (parentClientHeight / 3);
                        } else {
                            var frameTop = (offset - parentScrollTop);
                            top = (parentClientHeight - frameTop) / 3;
                        }
                    } else {
                        top = pega.u.d.MODALDIALOG_ADJUSTMENT + parentScrollTop;
                    }
                    pega.u.d.modalDialog.cfg.setProperty("y", top);
                }
            }
        }
        return new Array(bFixedCenter, top);
    } catch (e) {}
    return new Array(true, 0);
};
/*
@protected callback function after getting the section content, when Success. loads the response stream to the parentDiv and renders the modal dialog. also attaches the onclick events to the submit and cancel buttons with arguments
@param $Object$responseObj - Response Object
@return $void$
*/
pega.ui.Doc.prototype.handleShowSectionSuccess = function(responseObj) {
    var parentDiv = responseObj.argument[0];
    var onAfterSubmit = responseObj.argument[1];
    var onAfterCancel = responseObj.argument[2];
    var bShowAsModal = responseObj.argument[3];
    var streamName = responseObj.argument[4];
    var sectionOnly = responseObj.argument[5];
    var responseStream = responseObj.responseText;
    var pageName = responseObj.argument[7];
    var specialButtons = responseObj.argument[8];
    var displayAtClick = responseObj.argument[9];
    var includedStreamName = responseObj.argument[10];
    var sectionParams = responseObj.argument[11];
    if (!pega.u.d.useOldModalDialog) {
        displayAtClick = false;
    }
    var mainNodes = pega.util.Dom.getElementsByAttribute("node_type", "MAIN_RULE", "DIV", parentDiv);
    if (mainNodes) {
        var len = mainNodes.length;
        for (var i = 0; i < len; i++) {
            var node = mainNodes[i];
            var uniqueId = mainNodes[i].getAttribute("uniqueID");
            if (node.id = "RULE_KEY" && uniqueId && uniqueId != "") {
                this.removeFromMemory(uniqueId);
            }
        }
    }
    var modalDialogBody = pega.u.d.modalDialog.body;
    //var returnNode = document.createElement("DIV");
    //returnNode.innerHTML = responseStream;
    var top = 0;
    var bFixedCenter = true;
    if (!displayAtClick && pega.u.d.bModalDialogOpen && pega.u.d.useOldModalDialog) {
        var returnData = pega.u.d.prePositionModalDialog();
        top = returnData[1];
        bFixedCenter = returnData[0];
    }
    pega.u.d.gCallbackArgs = {
        bShowAsModal: bShowAsModal,
        modalDialogBody: modalDialogBody,
        parentDiv: parentDiv,
        onAfterSubmit: onAfterSubmit,
        onAfterCancel: onAfterCancel,
        streamName: streamName,
        pageName: pageName,
        specialButtons: specialButtons,
        displayAtClick: displayAtClick,
        sectionOnly: sectionOnly,
        includedStreamName: includedStreamName,
        sectionParams: sectionParams,
        top: top,
        bFixedCenter: bFixedCenter
    }
    var callback = pega.u.d.modalDialogCallBack;
    var callbackInterceptor = function() {
        if (bShowAsModal) {
            parentDiv.style.display = "block";
            if (!pega.u.d.bModalRendered) {
                pega.u.d.renderModal();
            }
            if (displayAtClick) {
                pega.u.d.modalDialog.cfg.setProperty("fixedcenter", false);
                pega.u.d.modalDialog.cfg.setProperty("y", displayAtClick[2]);
                pega.u.d.modalDialog.cfg.setProperty("x", displayAtClick[1]);
            }
            if (pega.u.d.modalDialog.setTransitions && pega.u.d.submitModalDlgParam) pega.u.d.modalDialog.setTransitions(
                pega.u.d.submitModalDlgParam.animObj, pega.u.d.submitModalDlgParam.isLocalAction, pega.u.d.submitModalDlgParam
                .isMobileFullScreen);
            pega.u.d.modalDialog.show();
            var errorMarkers = pega.util.Dom.getElementsById("PegaRULESErrorFlag", document);
            if (!errorMarkers || pega.u.d.alwaysShowFormLevelErrors == "true") {
                pega.u.d.handleFormErrors(modalDialogBody);
            }
            var errrTableNode = pega.util.Dom.getElementsById("ERRORTABLE", modalDialogBody);
            if (errrTableNode) {
                errrTableNode.id = "ERRORTABLEONMODAL";
                if (errrTableNode[0]) {
                    var errrTableNodeLen = errrTableNode.length;
                    for (var i = 0; i < errrTableNodeLen; i++) {
                        errrTableNode[i].parentNode.removeChild(errrTableNode[i]);
                    }
                }
            }
            pega.u.d.modalDialogExtras();
        }
        pega.u.d.modalDialogCallBack.call();
    }
    var onlyOnceEle;
    if (bShowAsModal) {
        pega.u.d.gCallbackArgs.domObj = modalDialogBody;
        pega.u.d.loadDOMObject(modalDialogBody, responseStream, callbackInterceptor);
        onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", modalDialogBody);
    } else {
        pega.util.Dom.setStyle(parentDiv, "display", "inline");
        pega.u.d.gCallbackArgs.domObj = parentDiv;
        pega.u.d.loadDOMObject(parentDiv, responseStream, callbackInterceptor);
        onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", parentDiv);
    }
    if (onlyOnceEle) {
        onlyOnceEle.id = "PegaOnlyOnceOnModal";
        if (onlyOnceEle[0]) {
            pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
            onlyOnceEle[0].parentNode.removeChild(onlyOnceEle[0]);
        }
    }
};
/*
@protected callback function after getting the section content, when Fail
@param $Object$responseObj - Response Object
@return $void$
*/
pega.ui.Doc.prototype.handleShowSectionFail = function(responseObj) {
    pega.u.d.gBusyInd.hide();
    alert("Failed to get the section stream.");
};
/*
@protected function which renders the modal Dialog.
@return $void$
*/
pega.ui.Doc.prototype.renderModal = function() {
    if (pega.u.d.useOldModalDialog) {
        pega.u.d.bModalDialogOpen = true;
        pega.u.d.modalDialog.render();
        pega.u.d.modalDialog.unsubscribe("beforeShow", pega.u.d.modalDialog.showMask);
        pega.u.d.modalDialog.subscribe("beforeShow", pega.u.d.showHarnessMask, pega.u.d.modalDialog, true);
        pega.u.d.modalDialog.unsubscribe("hide", pega.u.d.modalDialog.hideMask);
        pega.u.d.modalDialog.subscribe("hide", pega.u.d.hideHarnessMask, pega.u.d.modalDialog, true);
        pega.u.d.modalDialog.unsubscribe("beforeShow", pega.u.d.modalDialog.bringToTop);
    }
};
/*
@protected Displays the section using the arguments passed. used by grid control for editing a page in a pagelist.
@param $Object$templateModalSecName- Template name of modal dialog which can configure ok, cancel buttons. Default - pyModalTemplate.
@param $String$sectionName - Name of the section
@param $Object$sectionParams - Pass Section parameters to $sectionName.
@param $String$pageName - Page Name to be used as the Primary page of the section
@param $HTMLElement$parentDiv - Div object that hosts the section content
@param $boolean$sectionOnly - If true, returns only Section stream without buttons. If false, returns with submit and cancel buttons
@param $Object$onAfterSubmit - callback method to be invoked after successful submit, Optional
@param $Object$onAfterCancel - callback method to be invoked if cancel from the modal window, Optional
@param $Object$specialButtons - special buttons to be included in the stream
@param $Object$displayAtClick - Set this to show the position modal dialog at the click location. Default behaviour is to center the dialog wrt screen.

@return $HTMLElement$ - Element representing the div that hosts the section
*/
pega.ui.Doc.prototype.displaySectionInTemplate = function(templateModalSecName, sectionName, sectionParams, pageName,
    parentDiv, onAfterSubmit, onAfterCancel, displayAtClick) {
    this.displaySection(sectionName, pageName, parentDiv, false, onAfterSubmit, onAfterCancel, null, displayAtClick,
        templateModalSecName, sectionParams);
};
/*
@protected Used to call the performFlowAction when close button is clicked
@param $e - Event
@param $Obj$args - Args passed to the function
*/
pega.ui.Doc.prototype.closeModalFlowAction = function(e, args) {
    var bchildOverlayOpen = pega.u.d.closeChildOverLay(e);
    if (bchildOverlayOpen) {
        return;
    }
    var buttonObj = pega.util.Dom.getElementsById("ModalButtonCancel", pega.u.d.modalDialog.innerElement);
    if (buttonObj && buttonObj.length > 0) {
        pega.util.Event.fireEvent(buttonObj[0], 'click');
    } else {
        if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.taskStatus != "") {
            //call cancelModal of the grid from which the modal is launched.            
            var gridObj = pega.ctx.activeGrid;
            if (typeof(pega.u.d.submitModalDlgParam.activeGrid) != "undefined" && pega.u.d.submitModalDlgParam.activeGrid) {
                gridObj = pega.u.d.submitModalDlgParam.activeGrid;
            }
            if (typeof(gridObj) != "undefined" && gridObj && gridObj.gridDiv && pega.util.Dom.isAncestor(gridObj.gridDiv,
                    pega.u.d.submitModalDlgParam.associatedElement)) {
                gridObj.cancelModal(e, "pyGridModalTemplate");
            } else {
                pega.u.d.performFlowAction("", e, "", pega.u.d.submitModalDlgParam.taskStatus);
            }
        } else {
            pega.u.d.hideModalWindow();
        }
    }
};
/*
@protected Finds form element with a given ID. If not found returns first one
@param $String$formId - id of the form element
*/
pega.ui.Doc.prototype.findForm = function(formId) {
    var forms = document.forms;
    var result;
    for (var i = 0; i < forms.length; i++) {
        var form = document.forms[i];
        if (form.hasAttribute("id") && form.id === formId) {
            result = form;
            break;
        }
    }
    if (!result) {
        result = document.forms[0];
    }
    return result;
};
/*
@protected Used to submit the flowaction
@param $String$taskStatus - Name of the FlowAction
@param $e - Event
@param $String$tempInterestPage - InterestPage for the flow action
@param $Obj$args - Args passed to the function
@param $Obj$overlayNode - overlay container
*/
pega.ui.Doc.prototype.performFlowAction = function(taskStatus, event, tempInterestPage, tempTaskStatus, overlayNode,
    showOnlyMask, closeReason, formId) {
    if (pega.u.d.useOldModalDialog) {
        /*BUG-67132 : On resize, pega.u.d.modalDialog.body is getting modified in pega_yui_resize*/
        pega.u.d.modalDialog.body = document.getElementById("modaldialog_bd");
    }
    if (pega.u.d.overLaySubmit) {
        pega.u.d.overLaySubmit = false;
        return;
    }
    var containerNode = pega.u.d.modalDialog.innerElement;
    if (overlayNode) {
        containerNode = overlayNode;
        if (typeof pega.u.d.actionName == "undefined") {
            pega.u.d.actionName = "";
        }
        if (pega.u.d.actionName != "") {
            taskStatus = pega.u.d.actionName;
            pega.u.d.actionName = "";
        }
    }
    if (taskStatus && !pega.u.d.shouldSubmitProceed(event, containerNode)) return;
    event = (event == undefined) ? window.event : event;
    if (event && event.keyCode == 13) {
        pega.util.Event.stopPropagation(event);
        pega.util.Event.preventDefault(event);
    }
    pega.u.d.disableAllOtherButtons(null, containerNode);
    //Please keep response as the last Parameter as it's being passed by pusing at the end to callbackparams by robotic automation script file
    var performFlowActionInner = function(taskStatus, event, tempInterestPage, tempTaskStatus, overlayNode,
            showOnlyMask, closeReason, formId, response) {
            var harCtxMgr = pega.ui.HarnessContextMgr;
            var oSafeURL = SafeURL_createFromURL(harCtxMgr.get('url'));
            var activityName = "SubmitModalFlowAction";
            if (taskStatus == "" && pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.isAddingNewRow) {
                activityName = pega.u.d.submitModalDlgParam.cancelModalActivity;
            }
            /* RDL Master Details modal submission logic - Start */
            var MDOverlayOpen = pega.ctx.RDL.masterDetailsParams && pega.ctx.RDL.masterDetailsParams.isShowDetailsOpen;
            var isWOInitialized = MDOverlayOpen && pega.ctx.RDL.masterDetailsParams && pega.ctx.RDL.masterDetailsParams
                .__RDLWOThreadInitialized;
            var RDLMetaInfoObj = null;
            if (pega.ui.rdlMasterDetails) {
                RDLMetaInfoObj = pega.ui.rdlMasterDetails.getActiveRDLMetaInfo();
            }
            if (pega.u.d.ServerProxy.isDestinationRemote() && taskStatus && MDOverlayOpen && isWOInitialized &&
                RDLMetaInfoObj) { /* When modal is launched from RDL master details */
                oSafeURL.put("BaseThreadContext", pega.u.d.baseThreadName);
                var baseThreadName = pega.u.d.baseThreadName;
                var baseThreadCT = pega.u.ChangeTrackerMap.getTrackerByThread(baseThreadName);
                if (baseThreadCT && baseThreadCT.id) {
                    oSafeURL.put("BaseThreadAJAXTrackID", baseThreadCT.id);
                }
                /* OSCO RDL-online MD submit case */
                var rowPage = RDLMetaInfoObj.rowPage;
                //var DPName = rowPage.substring(0,rowPage.indexOf("_pa"));
                if (pega.u.d.ServerProxy.isDestinationRemote() && pega.u.d.ServerProxy.isHybridClient() && pega.ui.ParametrizedDPUtils
                    .isParametrizedDataPageInstance(rowPage, baseThreadCT)) {
                    //if(pega.u.d.ServerProxy.isDestinationRemote() && rowPage.indexOf("D_") == 0 || rowPage.indexOf("Declare_") == 0) {
                    oSafeURL.put("isRDLFromOSCO", "true");
                    //pega.u.d.switchThread(baseThreadName);
                }
                oSafeURL.put("rowPage", RDLMetaInfoObj.rowPage);
                oSafeURL.put("pzPrimaryPageName", "pyWorkPage");
            }
            if (MDOverlayOpen) {
                activityName = "ShowStream";
                oSafeURL.put("pyTargetStream", "pzRDLWOProcessing");
                if (taskStatus == "") { /* If taskStatus is empty then it is coming from cancel button. */
                    oSafeURL.put("releaseWOLock", true);
                } else {
                    oSafeURL.put("RDLSectionContext", RDLMetaInfoObj.RDLSectionContext);
                    /*
                          GetRDLRow_1(listSource, index) -- > row markup of the passed index.
                      */
                    oSafeURL.put("StreamName", RDLMetaInfoObj.RDLSectionName);
                    oSafeURL.put("StreamClass", "Rule-HTML-Section");
                    oSafeURL.put("pyCallStreamMethod", RDLMetaInfoObj.rowMethodName); // method name stamped on RDLShowDetails Div
                    oSafeURL.put("listSource", RDLMetaInfoObj.RDLSource);
                    oSafeURL.put("index", RDLMetaInfoObj.rowIndex);
                    // Couple isDestinationRemote with isHybridClient
                    if (pega.u.d.ServerProxy.isHybridClient()) {
                        oSafeURL.put("isRemoteCase", pega.u.d.ServerProxy.isDestinationRemote());
                    }
                }
            }
            /*In RDL AddItem Last,sending streamList as string that contains all rdls info to retrieve last row*/
            var streamList = "";
            /* BUG-392147: Adding a null check for pega.u.d.submitModalDlgParam */
            if (pega.ui.RDL && pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.isAddingNewRow && pega.u
                .d.submitModalDlgParam.position === "INSERTLAST" && taskStatus != "") {
                var rdlNodesInfo = pega.ui.RDL.getAndUpdateAllRDLsForPartialRefresh(pega.u.d.submitModalDlgParam.datasource);
                var rdlInfo = [];
                for (var i = 0; i < rdlNodesInfo.length; i++) {
                    var RDLSectionNode = pega.u.d.getSectionDiv(rdlNodesInfo[i].RDLNode);
                    var RDLSectionContext = pega.u.d.getBaseRef(RDLSectionNode) || pega.u.d.primaryPageName;
                    var RDLSectionName = RDLSectionNode.getAttribute("node_name");
                    var templatingStatus = rdlNodesInfo[i].templatingStatus;
                    var rowMethod = rdlNodesInfo[i].RDLNode.getAttribute("data-rowmethodname") || "";
                    rdlInfo.push(RDLSectionContext + "," + RDLSectionName + "," + rowMethod + "," + templatingStatus);
                }
                streamList = rdlInfo.join("||");
                // Fallback to normal flow in calling submit modal flowaction if the streamlist is empty
                if (streamList) {
                    activityName = "ShowStream";
                    oSafeURL.put("listSource", pega.u.d.submitModalDlgParam.datasource);
                    oSafeURL.put("pyTargetStream", "pzGetRowMarkup");
                }
            }
            /* RDL Master Details modal submission logic - End */
            oSafeURL.put("pyActivity", activityName);
            oSafeURL.put("actionName", taskStatus);
            var fullPath = $(containerNode).find("#RULE_KEY").attr('data-fullpath');
            if (fullPath) {
                oSafeURL.put("pxRemoveTemplate", fullPath);
            }
            oSafeURL.put("KeepMessages", pega.u.d.KeepMessages);
            if (pega.ctx.activeGrid && pega.ctx.activeGrid.bNoThreadProcess) { /* BUG-153696: On Cancel of modal dialog send "noThreadProcess" param */
                oSafeURL.put("noThreadProcess", pega.ctx.activeGrid.bNoThreadProcess);
            }
            /*BUG-252499 - releaseWOLock only when Modal Launched from Grid */
            /*BUG-743430 - releaseWOLock on cancel of modal dialog, when modal is launched from readOnly Grid having openLocalAction action configured */
            if (pega.ctx.activeGrid && pega.ctx.activeGrid.threadProcessing && (pega.ctx.activeGrid.editConfig ==
                "modal" || pega.ctx.activeGrid.isOpenLocalAction) && !overlayNode) { /* BUG-157807: For WO bound grid, send releaseWOLock param on cancel of modal dialog */
                oSafeURL.put("releaseWOLock", pega.ctx.activeGrid.threadProcessing);
                oSafeURL.put("pzPrimaryPageName", "pyWorkPage"); //BUG-402534
            }
            if (tempTaskStatus) {
                oSafeURL.put("ModalActionName", tempTaskStatus);
            }
           //BUG-484806 - undefined check before putting on Safeurl
            if (harCtxMgr.get("fieldErrorType")) oSafeURL.put("FieldError", harCtxMgr.get("fieldErrorType"));
            if (harCtxMgr.get("formErrorType")) oSafeURL.put("FormError", harCtxMgr.get("formErrorType"));
            if (harCtxMgr.get("pyCustomError")) oSafeURL.put("pyCustomError", harCtxMgr.get("pyCustomError"));
      
            if (pega.u.d.submitModalDlgParam) {
                var modalSection = pega.u.d.submitModalDlgParam.modalSection;
                if (modalSection) oSafeURL.put("modalSection", modalSection);
                var bIsOverlay = pega.u.d.submitModalDlgParam.bIsOverlay;
                if (!bIsOverlay) bIsOverlay = "false";
                oSafeURL.put("bIsOverlay", bIsOverlay);
            }
            var flowActionContent = pega.util.Dom.getElementsById("pyFlowActionHTML", containerNode, "DIV");
            if (flowActionContent && flowActionContent.length > 0) {
                flowActionContent = flowActionContent[0];
                var interestPage = flowActionContent.getAttribute("PRIM_PAGE");
                /*Send the interest page always in the request while submitting modal dialog so that we always get the proper pyInterestPage*/
                if (interestPage) {
                    oSafeURL.put("InterestPage", interestPage);
                }
            }
            if (tempInterestPage) {
                oSafeURL.put("pyTempInterestPage", tempInterestPage);
            } else if (flowActionContent) {
                tempInterestPage = flowActionContent.getAttribute("TEMP_BASE_REF");
                if (tempInterestPage) {
                    oSafeURL.put("pyTempInterestPage", tempInterestPage);
                }
            }
            var containerBody = pega.u.d.modalDialog.body;
            var harnessContext = pega.ui.HarnessContextMap.getCurrentHarnessContext();
            if (overlayNode) {
                containerBody = containerNode;
            }
            if (harnessContext.getProperty('strHarnessMode') != "ACTION") oSafeURL.put("HarnessType", "NEW");
            if (pega.ctx.isUITemplatized) {
                oSafeURL.put("UITemplatingStatus", "Y");
            }
            try {
                if (response) {
                    //var responseData = JSON.parse(response.responseText);
                    var postAutomationDiv = $(containerNode).find("#postAutomationMeta")[0];
                    var autoPrimaryPage = postAutomationDiv.getAttribute("data-automation-primaryPage");
                    var _data = response;
                    for (key in _data) {
                        //postData.put(pega.u.property.toHandle(autoPrimaryPage+"." + key), _data[key]);
                        var name = pega.u.property.toHandle(autoPrimaryPage + "." + key);
                        $(containerNode).find('[name = "' + name + '"]').val(_data[key]);
                    }
                }
            } catch (e) {
                console.log("Failure in updating the DOM with automation data");
            }
            var reloadElement = pega.util.Dom.getElementsById("RULE_KEY", containerBody);
            var considerFormData = true;
            if (reloadElement && reloadElement.length > 0) {
                reloadElement = reloadElement[0];
                queryString = pega.u.d.getQueryString(reloadElement, false, false, considerFormData);
                if (isWOInitialized) {
                    var submittedProperties = "";
                    for (var key in queryString.hashtable) {
                        var ref = pega.ui.property.toReference(key);
                        submittedProperties += ref.substr(ref.indexOf(".")) + ",";
                    }
                    queryString.put("submittedProperties", submittedProperties.substr(0, submittedProperties.lastIndexOf(
                        ",")));
                }
            } else {
                queryString = pega.u.d.getQueryString(containerBody, false, false, considerFormData);
            }
            var callback;
            //Pass streamlist in post for ADDITEM LAST
            if (streamList) {
                queryString.put("streamList", streamList);
            }
            /*BUG-108153: When performFlowAction is called from grid, showOnlyMask is set to true. Pass it to setBusyIndicator method.*/
            pega.u.d.setBusyIndicator(null, false, showOnlyMask);
            var asyncConfigOptions;
            if (overlayNode) {
                callback = {
                    success: function(oResponse) {
                        pega.u.d.performOverlayCallback(oResponse, overlayNode, closeReason);
                    },
                    failure: function(oResponse) {
                        pega.u.d.gBusyInd.hide();
                        pega.u.d.resetSubmitModalDlgParam();
                    },
                    scope: pega.u.d
                };
            } else {
                callback = {
                    success: pega.u.d.performFlowACallback,
                    failure: function(oResponse) {
                        pega.u.d.gBusyInd.hide();
                        pega.u.d.hideModalWindow();
                    },
                    scope: pega.u.d
                };
            }
            /* Mark as request from action invoked from native component (separate WebView) in PIMC */
            if (harCtxMgr.get("strHarnessPurpose") && harCtxMgr.get("strHarnessPurpose").indexOf("pzPMCModalTemplate") !== -1) {
              oSafeURL.put("autoSaveRequired", "true");
            }
      
            /* Submit to tke place using ServerProxy
             */
            var oscoHandler = {
                scope: pega.u.d,
                online: function(oSafeURL, postData, callback) {
                    pega.u.d.asyncRequest('POST', oSafeURL, callback, postData, asyncConfigOptions);
                },
                offline: function() {
                    pega.ui.ProcessActionOffline.submitLocalAction(bIsOverlay, closeReason, taskStatus, taskStatus == "" ?
                        "" : queryString);
                    pega.u.d.resumeAjaxSequencer();
                }
            };
            pega.u.d.ServerProxy.doAction(oSafeURL, taskStatus == "" ? "" : queryString, oscoHandler, callback);
        }
        //Robotic Desktop Automation related code
    if (pega.ui.roboticAutomation) {
        var postAutomationDiv = pega.ui.roboticAutomation.isAutomationConfigured("submit", containerNode);
        if (postAutomationDiv && taskStatus != "" && pega.ui.roboticAutomation.skipAutomation(containerNode) ==
            "false") {
            pega.ui.roboticAutomation.runAutomation("submit", containerNode, performFlowActionInner, [taskStatus,
                event, tempInterestPage, tempTaskStatus, overlayNode, showOnlyMask, closeReason, formId]);
        } else {
            //setting the arrtibute to false if true for subsequent automation calls 
            if (postAutomationDiv && postAutomationDiv.getAttribute("skipAutomation") == "true") postAutomationDiv.setAttribute(
                "skipAutomation", "false");
            performFlowActionInner(taskStatus, event, tempInterestPage, tempTaskStatus, overlayNode, showOnlyMask,
                closeReason, formId);
        }
    } else {
        performFlowActionInner(taskStatus, event, tempInterestPage, tempTaskStatus, overlayNode, showOnlyMask,
            closeReason, formId);
    }
};
pega.ui.Doc.prototype.performOverlayCallback = function(oResponse, containerNode, closeReason) {
    pega.u.d.performFlowACallback(oResponse, containerNode, closeReason);
};
/*
 @private callback function for performFlowAction
 */
pega.ui.Doc.prototype.performFlowACallback = function(oResponse, containerNode, closeReason) {
    var associatedElement;
    if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.associatedElement) {
        associatedElement = pega.u.d.submitModalDlgParam.associatedElement;
    }
    if (oResponse.responseText == "CANCEL") {
        /*
            BUG-229947 : Calling removeThread only if Modal dialog param stack length is less than or equal to 0.
            WorkProcessing can occur only on level 1 ie. first modal dialog or overlay but not in nested overlay so targetted Modal dialog param stack length to 0.
        */
        var modalDlgStackLength = pega.u.d.submitModalDlgParamStack.length;
        if (pega.ctx.activeGrid && modalDlgStackLength <= 0) {
            var grid = pega.ctx.activeGrid;
            /* TASK-118164: In case of bNoThreadProcess == true stop request to "removeThread" */
            if (typeof(grid.modalThreadContext) != "undefined" && grid.baseThreadContext && grid.modalThreadContext !=
                "" && grid.modalThreadContext != grid.baseThreadContext && !grid.bNoThreadProcess) {
                pega.u.d.switchThread(grid.baseThreadContext);
                this.switchPrimaryPage(this.basePrimaryPageName);
                var threadDeleteURL = SafeURL_createFromURL(this.url);
                threadDeleteURL.put("pyActivity", "removeThead");
                threadDeleteURL.put("threadName", grid.modalThreadContext);
                var request = this.asyncRequest('POST', threadDeleteURL);
            }
            /* BUG-144263
            In case of cancel button the correct index must be calculated hence             calling  selectPage
            */
            var index = pega.ctx.activeGrid.getIndex(pega.ctx.activeGrid.activeRow);
            pega.ctx.activeGrid.selectPage(null, null, index);
        }
        if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.userCallbackObj && (typeof pega.u.d.submitModalDlgParam
                .userCallbackObj.cancel === "function")) {
            var userCallbackObj = pega.u.d.submitModalDlgParam.userCallbackObj;
        }
        if (!containerNode) {
            pega.u.d.hideModalWindow();
            pega.u.d.processModalCallbak("CLOSE");
            if (pega.u.d.insertButton) {
                pega.u.d.focusDomElement(pega.u.d.insertButton);
            }
            pega.u.d.insertButton = null;
        } else {
            pega.u.d.insertButton = null;
            pega.u.d.resetSubmitModalDlgParam();
            if (associatedElement) {
                if (closeReason == "tabclickaway") {
                    var nextFocusElement = pega.u.d.getNextFocusableElement(associatedElement, document);
                    if (nextFocusElement) {
                        try {
                            pega.u.d.focusDomElement(nextFocusElement);
                        } catch (e) {
                            return;
                        };
                    }
                } else {
                    try {
                        /* BUG-187592: focusing associate element causing issu when we click on editable input elements (text input) */
                        if (closeReason != "clickaway") {
                            if (pega.util.Event.isIE) {
                                pega.u.d.focusElement = associatedElement;
                            }
                            pega.u.d.focusDomElement(associatedElement);
                        }
                    } catch (e) {
                        return;
                    }
                }
            }
        }
        /* This is to support cancel callback for processAction API : START */
        if (userCallbackObj && (typeof userCallbackObj.cancel === "function")) {
            var cancelCallback = userCallbackObj.cancel;
            if (userCallbackObj.scope) {
                cancelCallback.call(pega.u.d.submitModalDlgParam.userCallbackObj.scope);
            } else {
                cancelCallback();
            }
        }
        /* This is to support success callback for processAction API : END */
    } else if (oResponse.responseText.indexOf("COMMIT||") > -1 && oResponse.responseText.indexOf("<!--COMMIT") == -1) {
        var commitArray = oResponse.responseText.split("||");
        var newTransID = commitArray[1].trim();
        /*
         *  clientFrame is the value for "pxClientFrame" available in the current thread.
         *  "pxClientFrame" holds the frame name which did the latest Commit on the thread.
         */
        var clientFrame = commitArray.length > 2 && commitArray[2] && commitArray[2].indexOf("pxClientFrame:") == 0 ?
            commitArray[2].substring(14) : ""; /* 14 is the length of the string "pxClientFrame:" */
        var newurl = SafeURL_createFromURL(pega.u.d.url);
        if (newTransID) newurl.put("pzTransactionId", newTransID);
        else delete newurl.hashtable.pzTransactionId;
        pega.u.d.url = newurl.toURL();
        /* AJAX Change tracker does not return any changed value.
         * update the value of pxThread.pxClientExchange in AJAX Change tracker Values by setting it
         * same as that returned now if the current thread is same as the base thread and the clientFrame is same as baseFrame.
         */
        if (pega.u.d.baseThreadName === pega.u.d.getThreadName() || pega.ctx.isMDC) {
            var updateTrackerWithNewTransID = false;
            if (clientFrame) {
                if ((clientFrame == pega.ctx.baseFrameName) || pega.u.d.bIsDCSPA) {
                    updateTrackerWithNewTransID = true;
                }
            } else {
                /*
                 *  Only @baseclass.SubmitModalFlowAction activity has been updated to return the latest value of "pxClientFrame"
                 *  Other instances of the activity in various other classes still do not return this value.
                 *  Hence continue updating the tracker to keep intact the existing behavior if clientFrame value is not found as activity in other classes are yet to be fixed
                 */
                updateTrackerWithNewTransID = true;
            }
            var changeTracker = pega.ui.ChangeTrackerMap.getTracker();
            if (updateTrackerWithNewTransID && changeTracker.trackedPropertiesList && changeTracker.trackedPropertiesList
                .pxThread) {
                changeTracker.trackedPropertiesList.pxThread.pxClientExchange = newTransID;
            }
            if (pega.u.d.bIsDCSPA && (changeTracker.threadName == pega.u.d.getThreadName())) {
                changeTracker.trackedPropertiesList.pxThread = changeTracker.trackedPropertiesList.pxThread || {};
                changeTracker.trackedPropertiesList.pxThread.pxClientFrame = clientFrame;
                pega.ctx.baseFrameName = clientFrame;
            }
        }
        if (document && document.forms[0]) {
            var url = document.forms[0].action;
            var formURL = SafeURL_createFromURL(url);
            if (newTransID) formURL.put("pzTransactionId", newTransID);
            else delete newurl.hashtable.pzTransactionId;
            document.forms[0].action = formURL.toURL();
        }
        if (containerNode) {
            var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
            pega.u.d.overLaySubmit = true;
            popOver.close();
            if (associatedElement) {
                pega.u.d.focusDomElement(associatedElement);
            }
        } else {
            if (pega.u.d.insertButton) {
                pega.u.d.focusDomElement(pega.u.d.insertButton);
            }
        }
        if (!pega.u.d.submitModalDlgParam || typeof(pega.u.d.submitModalDlgParam.bReload) == "undefined" || pega.u.d
            .submitModalDlgParam.bReload != false) {
            if (!containerNode && pega.u.d.submitModalDlgParam.associatedElement) pega.u.d.reloadSection(pega.u.d.submitModalDlgParam
                .associatedElement, '', '', false, false, '', false);
            else pega.u.d.reloadSection(pega.u.d.insertButton, '', '', false, false, '', false);
        }
        if (pega.ctx.activeGrid) {
            /* BUG-154743: when we open overlay inside overlay, we should not focus to grid until outer most overlay gets closed */
            if (!pega.u.d.submitModalDlgParamStack || (pega.u.d.submitModalDlgParamStack && pega.u.d.submitModalDlgParamStack
                    .length <= 0)) {
                pega.ctx.activeGrid.focusOnNewEditableRow();
            }
        }
        /* This is to support submit callback for processAction API : START */
        if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.userCallbackObj) {
            var submitCallback = pega.u.d.submitModalDlgParam.userCallbackObj;
            if (typeof submitCallback === "function") {
                submitCallback();
            } else if (typeof submitCallback.submit === "function") {
                if (submitCallback.scope) {
                    submitCallback.submit.call(submitCallback.scope);
                } else {
                    submitCallback = submitCallback.submit;
                    var rdlmasterdetails = pega.ui.rdlMasterDetails;
                    var RDLMetaInfo = rdlmasterdetails && rdlmasterdetails.getActiveRDLMetaInfo();
                    var isRDLMDOpen = RDLMetaInfo && RDLMetaInfo.showDetailsNode;
                    if (isRDLMDOpen || (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.isAddingNewRow &&
                            pega.u.d.submitModalDlgParam.position === "INSERTLAST")) { /* Send response object as part of submit callback for RDL with master details */
                        submitCallback(oResponse);
                    } else {
                        submitCallback();
                    }
                }
            }
        }
        /* This is to support success callback for processAction API : END */
        if (!containerNode) {
            if (!pega.u.d.submitModalDlgParam || typeof(pega.u.d.submitModalDlgParam.bReload) == "undefined" || pega
                .u.d.submitModalDlgParam.bReload != false) {
                /*Register resizeHarness in heavyOperations Manager to avoid multiple calls to resize harness on click of OK button in Modal Dialog.*/
                pega.u.d.regHeavyOperations = true;
            }
            pega.u.d.hideModalWindow();
            if (pega.u.d.regHeavyOperations) {
                delete pega.u.d.regHeavyOperations;
            }
            pega.u.d.processModalCallbak("CLOSE");
        } else {
            pega.u.d.resetSubmitModalDlgParam();
        }
    } else {
        if (oResponse.argument && oResponse.argument[6] && typeof(oResponse.argument[7]) != "undefined" && oResponse
            .argument[7] && oResponse.argument[7].editConfig && (oResponse.argument[7].editConfig == "harness" ||
                oResponse.argument[7].editConfig == "expandPane")) {
            var activeGridObj = oResponse.argument[7];
            if (oResponse.argument[7].editConfig == "harness") {
                var bEditHarness = true;
            }
            if (oResponse.argument[7].editConfig == "expandPane") {
                var bEditExpandPane = true;
            }
        }
        if (bEditHarness || bEditExpandPane) { // TBD : remove duplication of code
            var strResponse = oResponse.responseText;
            var returnNode = document.createElement("DIV");
            returnNode.innerHTML = strResponse;
            var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", returnNode);
            if (onlyOnceEle && onlyOnceEle[0]) {
                pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
                onlyOnceEle[0].parentNode.removeChild(onlyOnceEle[0]);
            }
            var modalHTMLNode = pega.util.Dom.getElementsById("modaldialog_con", returnNode);
            if (modalHTMLNode && modalHTMLNode[0]) {
                var childElements = pega.util.Dom.getChildren(modalHTMLNode[0]);
                var childEleLength = childElements.length;
                var childElement = null;
                for (var i = 0; i < childEleLength; i++) {
                    childElement = childElements[i];
                    if (childElement && childElement.id != "pyFlowActionHTML") {
                        /* modalHTMLNode[0].removeChild(childElement);  // Bug-120664 : kumad1 */
                        $(childElement).remove();
                    }
                }
            }
            if (bEditExpandPane) {
                var activeTR = activeGridObj.getRightRow();
                if (activeTR) {
                    var detailsTR = pega.util.Dom.getNextSibling(activeTR);
                }
                if (detailsTR) {
                    var detailsDiv = pega.util.Dom.getFirstChild(pega.util.Dom.getFirstChild(detailsTR));
                    if (detailsDiv) pega.u.d.loadDOMObject(detailsDiv, returnNode.innerHTML);
                }
            } else {
                pega.u.d.loadDOMObject(activeGridObj.gridDetailsDiv, returnNode.innerHTML);
            }
            var flowActionContent = pega.util.Dom.getElementsById("pyFlowActionHTML", activeGridObj.gridDetailsDiv,
                "DIV");
            if (flowActionContent && flowActionContent.length > 0 && activeGridObj && activeGridObj.editConfig ==
                activeGridObj.EDIT_HARNESS) { /* When modal dialog content gets returned */
                var grid = activeGridObj;
                flowActionContent = flowActionContent[0];
                grid.modalThreadContext = flowActionContent.getAttribute("THREAD_NAME");
                grid.isLocked = (flowActionContent.getAttribute("LOCKED") == "true");
                if (grid.isLocked) {
                    grid.DONOT_SUBMIT = "true";
                }
                pega.u.d.attachClickForGridButtons(grid, activeGridObj.gridDetailsDiv, grid.templateName ||
                    "pyGridDetails");
            }
            returnNode.innerHTML = strResponse;
            var errorMarkers = pega.util.Dom.getElementsById("PegaRULESErrorFlag", document);
            if (!errorMarkers || pega.u.d.alwaysShowFormLevelErrors == "true") {
                this.handleFormErrors(returnNode);
            }
        } else {
            if (pega.util.Event.isIE && !containerNode) pega.u.d.modalDialog.cfg.setProperty("height", "0");
            var strResponse = oResponse.responseText;
            if ((strResponse.indexOf("<html>") > -1) && pega.ctx.activeGrid) {
                var grid = pega.ctx.activeGrid;
                if (typeof(grid.modalThreadContext) != "undefined" && grid.modalThreadContext != "" && grid.modalThreadContext !=
                    grid.baseThreadContext) {
                    pega.u.d.switchThread(grid.baseThreadContext);
                    this.switchPrimaryPage(this.basePrimaryPageName);
                    var threadDeleteURL = SafeURL_createFromURL(this.url);
                    threadDeleteURL.put("pyActivity", "removeThead");
                    threadDeleteURL.put("threadName", grid.modalThreadContext);
                    var request = this.asyncRequest('POST', threadDeleteURL);
                }
            }
            /* get the hidden commit comment with latest transaction id  */
            var txnIdPos = strResponse.indexOf("<!--COMMIT||");
            if (txnIdPos != -1) {
                var newTransID = strResponse.substring(txnIdPos + 12, strResponse.lastIndexOf("||COMMIT-->"));
                var newurl = SafeURL_createFromURL(pega.u.d.url);
                newurl.put("pzTransactionId", newTransID);
                pega.u.d.url = newurl.toURL();
                /* AJAX Change tracker does not return any changed value.
                 * update the value of pxThread.pxClientExchange in AJAX Change tracker Values by setting it
                 * same as that returned now if the current thread is same as the base thread
                 */
                if (pega.u.d.baseThreadName === pega.u.d.getThreadName()) {
                    var tracker = pega.ui.ChangeTrackerMap.getTracker();
                    if (tracker.trackedPropertiesList.pxThread) {
                        pega.ui.ChangeTrackerMap.getTracker().trackedPropertiesList.pxThread.pxClientExchange =
                            newTransID;
                    }
                }
                if (document && document.forms && document.forms[0]) {
                    var url = document.forms[0].action;
                    var formURL = SafeURL_createFromURL(url);
                    formURL.put("pzTransactionId", newTransID);
                    document.forms[0].action = formURL.toURL();
                }
            }
            var returnNode = document.createElement("DIV");
            returnNode.innerHTML = strResponse;
            var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", returnNode);
            if (onlyOnceEle && onlyOnceEle[0]) {
                pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
                onlyOnceEle[0].parentNode.removeChild(onlyOnceEle[0]);
            }
            var modalHTMLNode = pega.util.Dom.getElementsById("modaldialog_con", returnNode);
            if (modalHTMLNode && modalHTMLNode[0]) {
                var childElements = pega.util.Dom.getChildren(modalHTMLNode[0]);
                var childEleLength = childElements.length;
                var childElement = null;
                for (var i = 0; i < childEleLength; i++) {
                    childElement = childElements[i];
                    if (childElement && childElement.id != "pyFlowActionHTML") {
                        /* modalHTMLNode[0].removeChild(childElement);  // Bug-120664 : kumad1 */
                        $(childElement).remove();
                    }
                }
            }
            var containerBody = pega.u.d.modalDialog.body;
            if (containerNode) {
                var tempContainerBody = pega.util.Dom.getElementsByAttribute("node_type", "MAIN_RULE", "DIV",
                    containerNode);
                if (tempContainerBody && tempContainerBody.length > 0) {
                    containerBody = tempContainerBody[0];
                }
            }
          
          //BUG-583294 Nullify complex elements in case of submit with server errors 
            pega.u.d.cleanUpHarnessElements(null, [containerBody]);
          
            pega.u.d.loadDOMObject(containerBody, returnNode.innerHTML);
            if(containerBody && docFocus){ setTimeout(function(){docFocus.focusToFirstInvalidField(containerBody);},0)} 
            var flowActionContent = pega.util.Dom.getElementsById("pyFlowActionHTML", containerBody, "DIV");
            /* BUG-276504: Additionally Check the editConfig of the grid */
            /* BUG-287381: Check that the reloadelement is inside the active grid instead of the grid's edit mode */
            //BUG-289924 : Added check to figure out Modal is opened from grid
            if (flowActionContent && flowActionContent.length > 0 && pega.ctx.activeGrid && ((pega.u.d.submitModalDlgParam &&
                    $.contains(pega.ctx.activeGrid.gridDiv, pega.u.d.submitModalDlgParam.reloadElement) || (!
                        pega.u.d.submitModalDlgParam && pega.ctx.activeGrid.editConfig === pega.ctx.activeGrid.EDIT_MODAL
                    )))) { /* When modal dialog content gets returned */
                var grid = pega.ctx.activeGrid;
                flowActionContent = flowActionContent[0];
                grid.modalThreadContext = flowActionContent.getAttribute("THREAD_NAME");
                grid.isLocked = (flowActionContent.getAttribute("LOCKED") == "true");
                if (grid.isLocked) {
                    grid.DONOT_SUBMIT = "true";
                }
                if (!containerNode) {
                    /* BUG-169462: In case of error in modal dialog during submission, get the custom template name from the section div hosted by modal dialog */
                    var containerBodyChild = containerBody.children[0];
                    var __templateName;
                    if (containerBodyChild) {
                        __templateName = containerBodyChild.getAttribute("node_name");
                    }
                    if (!__templateName) {
                        __templateName = "pyGridModalTemplate";
                    }
                    pega.u.d.attachClickForGridButtons(grid, containerBody, __templateName);
                }
            }
            if (!containerNode && pega.util.Event.isIE) pega.u.d.modalDialog.cfg.setProperty("height", "0");
            returnNode.innerHTML = strResponse;
            var errorMarkers = pega.util.Dom.getElementsById("PegaRULESErrorFlag", document);
            if (!errorMarkers || pega.u.d.alwaysShowFormLevelErrors == "true") {
                this.handleFormErrors(returnNode);
            }
            if (!containerNode) {
                pega.u.d.processModalCallbak("ERROR");
                pega.u.d.attachCloseBtnListeners({
                    closeBtnApi: pega.u.d.closeModalFlowAction
                }, null);
                if (pega.u.d.submitModalDlgParam) pega.u.d.modalDialogExtras(pega.u.d.submitModalDlgParam.ModalWindowSize);
            } else if (containerNode) {
                var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
                
                  var activePopOverElement = popOver.getActivePopOverElement();
                  /* focus error field in overlay for edit validate and error table */
                  if(activePopOverElement) {
                    var popOverTables = activePopOverElement.getElementsByTagName("table");
                    var hasErrorTable = false;
                    var hasError = false;
                    for(var j =0; j<popOverTables.length; j++) {
                      if(popOverTables[j].getAttribute("id") === "ERRORTABLE") {
                        hasErrorTable = true; 
                        break;
                      }
                    }
                    if(!hasErrorTable) {
                       var popOverSpans = activePopOverElement.getElementsByTagName("span");
                       for(var k = 0; k<popOverSpans.length; k++) {
                        if(popOverSpans[k].getAttribute("class") === "iconError dynamic-icon-error") {
                         hasError = true;
                         break;
                        }
                      }
                    }
                    var firstFocusElem = pega.u.d.getFirstFocusableElement(activePopOverElement.id);
                    window.setTimeout(function() {
                        try {
                            if(!hasError && !hasErrorTable){
                              pega.u.d.focusDomElement(firstFocusElem);
                            }
                        } catch (e) {
                            return;
                        }
                    }, 50);
                  }
                
            }
        }
    }
    if (typeof LayoutGroupModule != "undefined") {
        LayoutGroupModule.checkForErrors();
    }
    pega.u.d.gBusyInd.hide(null, true);
};
/*
@protected- This function is used to nullify the Complex elements in modal dialog.
@param - eleType is an array added to nullify specific elements only.
@return $void$
*/
pega.ui.Doc.prototype.nullifyComplexElementsInModal = function(eleTypes) {
    var complexElements = pega.u.d.getHarnessElements(false, false, true);
    var len = complexElements.length;
    for (var i = 0; i < len; i++) {
        var complexObject = complexElements[i];
        var ele = complexObject.element;
        if (ele && (typeof ele.isRichTextEditor != undefined && ele.isRichTextEditor == true && ele.myEditor !=
                undefined && ele.myEditor.get != undefined && pega.util.Dom.isAncestor(pega.u.d.modalDialog.innerElement,
                    ele.myEditor.get("element")) || (typeof ele.isRichTextEditor != undefined && ele.isRichTextEditor ==
                    true && ele.txtAreaEl != undefined && pega.util.Dom.isAncestor(pega.u.d.modalDialog.innerElement,
                        ele.txtAreaEl)) || (ele.bFocusibleGrid || ele.bGrid || ele.bTree || ele.bTreegrid) && pega.util
                .Dom.isAncestor(pega.u.d.modalDialog.innerElement, ele.gridDiv))) {
            if (typeof ele.nullify != undefined) {
                if (!eleTypes || (eleTypes && $ && ($.inArray("RTE", eleTypes) > -1) && ele.isRichTextEditor)) {
                    ele.nullify();
                    this.harnessElements.splice(i, 1);
                    complexObject.element = null;
                    complexObject = null;
                }
            }
        }
    }
};
/*
@protected- This function is a callback from modal window open/close for local actions.
@param $String$status - modal window status (OPEN/CLOSE/ERROR)
@return $void$
*/
pega.ui.Doc.prototype.processModalCallbak = function(status) {
    var modalCallbackLength = this.modalCallback.length;
    for (var i = 0; i < modalCallbackLength; i++) {
        var modalCallbackFunc = this.modalCallback[i];
        modalCallbackFunc(status);
    }
};
/*
@public focusOnModalDialogFirstElement is used to set the focus on first editable element in modal dialog and restrict the cursor within modal.
 @Handler
@return $void$
*/
pega.ui.Doc.prototype.focusOnModalDialogFirstElement = function() {
    var modalContent = document.querySelector("#modalContent");
    var closeIcon = modalContent.querySelector("#container_close");
    if (closeIcon && pega.cl && pega.cl.isTouchAble()) {
        closeIcon.focus();
    }
    else {
        var firstFocusElem = pega.u.d.getFirstFocusableElement('modalContent');
        if (firstFocusElem && firstFocusElem.nodeName == 'TEXTAREA' && firstFocusElem.className.indexOf(
                'PEGACKEDITOR') != -1) {
            for (var i in CKEDITOR.instances) {
                if (firstFocusElem.id == CKEDITOR.instances[i].name) {
                    CKEDITOR.instances[i].on('instanceReady', function() {
                        try {
                            CKEDITOR.instances[i].focus();
                        } catch (e) {}
                    });
                    break;
                }
            }
        } else if (firstFocusElem) {
            try {
                firstFocusElem.focus();
                pega.u.d.fixFocusInIE(firstFocusElem);
            } catch (e) {}
        }
    }
    /*Add a listener to listen for TAB and restrict the focus within the modal dialog.*/
    var modalEl = document.getElementById("modalContent");
    pega.util.Event.removeListener(modalEl, "keydown", pega.u.d.restrictFocus);
    var firstBoundary = pega.u.d.getFirstFocusableElement('modalContent');
    var lastBoundary = pega.u.d.getLastFocusableElement('modalContent');
    pega.util.Event.addListener(modalEl, "keydown", pega.u.d.restrictFocus, [firstBoundary, lastBoundary]);
};
pega.ui.Doc.prototype.offlineModalSuccessCallback = function(resultsArray) {
    var content = '';
    if (resultsArray && resultsArray.length > 0) {
        content = resultsArray[0].content
    }
    pega.u.d.processActionModal_Success({
        "responseText": content
    });
};
pega.ui.Doc.prototype.offlineModalFailCallback = function(code, message) {
    console.log("Error " + code + " loading ClientStore item: " + message);
};
pega.ui.Doc.prototype.processActionNetworkStatusCallback = function(actionURL, reloadElement, event, bCalledFromGrid,
    callbackObj, options, bIsDisableClickaway) {
    //var isOnline = !window.pega.offline;
    if (!pega.u.d.modalDialog) pega.u.d.modalDialogInit();
    //if(isOnline){
    //Let the call always go through online handler.
    pega.u.d._processActionModalOnlineHandler(actionURL, reloadElement, event, bCalledFromGrid, callbackObj, options,
        bIsDisableClickaway);
    /*}else{
        //This hardcoded string should be replaced with a proper PRPC type
        pega.mobile.hybrid.callWhenLaunchboxLoaded(function() {
            var launchBox = pega.mobile.hybrid.getLaunchBox();
            if(launchBox.PRPC && launchBox.PRPC.ClientStore){
                launchBox.PRPC.ClientStore.getItems("localaction", actionURL.get("NewTaskStatus"), pega.u.d.offlineModalSuccessCallback, pega.u.d.offlineModalFailCallback);
            }
        });
    }*/
};
/*
 @public Process Action Modal is called when modal dialog is opened
 @Handler
 @param $Object$actionURL contains the parameters that are to be passed in the url.
 @return $void$
*/
//US-79038 Added Disable clickaway configuration
pega.ui.Doc.prototype.processActionModal = function(actionURL, reloadElement, event, bCalledFromGrid, callbackObj,
    options, bIsDisableClickaway) { // added options for task TASK-265558 21-012015 bajaj 
    if (bIsDisableClickaway == null || typeof(bIsDisableClickaway) == "undefined") {
        bIsDisableClickaway = false;
    }
    //Center Position Overlay
    if (options != null && (options.isCenterOverlay == null || typeof(options.isCenterOverlay) == "undefined")) {
        options.isCenterOverlay = false;
    }
    if (pega.u.d.ServerProxy.isDestinationLocal()) {
        pega.u.d.processActionNetworkStatusCallback(actionURL, reloadElement, event, bCalledFromGrid, callbackObj,
            options, bIsDisableClickaway);
    } else {
        pega.u.d._processActionModalOnlineHandler(actionURL, reloadElement, event, bCalledFromGrid, callbackObj,
            options, bIsDisableClickaway);
    }
};
// added options for task TASK-265558 21-012015 bajaj
//US-79038 Added Disable clickaway configuration
pega.ui.Doc.prototype._processActionModalOnlineHandler = function(actionURL, reloadElement, event, bCalledFromGrid,
    callbackObj, options, bIsDisableClickaway) {
    var harCtxMgr = pega.ui.HarnessContextMgr;
    if (pega.u.d.ServerProxy.isHybridClient()) {
        pega.u.d.url = pega.u.d.url.replace("/PRRestService/", "/PRServlet/");
    }
    if (typeof(reloadElement) == "undefined" || !reloadElement) {
        reloadElement = pega.util.Event.getTarget(event);
        //BUG-185952 The overlay needs to be aligned with button in Chrome browser also
        //Making the target to align to the entire button and not just the middle div element of the button
        if (window.chrome != null && typeof(window.chrome) != "undefined") {
            if (reloadElement.nodeName != "BUTTON" && (pega.util.Dom.hasClass(reloadElement, "pzbtn-rnd") > -1 ||
                    pega.util.Dom.hasClass(reloadElement, "pzbtn-lft") > -1 || pega.util.Dom.hasClass(reloadElement,
                        "pzbtn-rgt") > -1 || pega.util.Dom.hasClass(reloadElement, "pzbtn-mid") > -1)) {
                while (reloadElement.nodeName != "BUTTON") {
                    reloadElement = reloadElement.parentNode;
                    if (reloadElement == null || typeof(reloadElement) == "undefined") {
                        reloadElement = pega.util.Event.getTarget(event);
                        break;
                    }
                }
            }
        }
        //BUG-185952 - END
    }
    var flowActionTarget = null;
    if (typeof(actionURL.get("FlowActionTarget")) != "undefined" && actionURL.get("FlowActionTarget") == "overlay") {
        flowActionTarget = "overlay";
    }
    if (flowActionTarget == "overlay" && reloadElement && !pega.util.Dom.inDocument(reloadElement)) {
        return;
    }
    pega.u.d.usesModalTemplate = true;
    this.insertButton = reloadElement;
    var reloadTable = null;
    if (typeof isTemplateGrid === 'function' && !isTemplateGrid(event)) { //API defined in doGridAction file
        reloadTable = (typeof this.getRepeatObject == 'function') ? this.getRepeatObject(reloadElement, true) : null;
    }
    // BUG-93793 : if getRepeatObject returns grid's bodyTbl_right then set it to null.
    if (reloadTable && reloadTable.id == "bodyTbl_right") {
        reloadTable = null;
    }
    var index = (typeof this.getRepeatRow == 'function') ? this.getRepeatRow(reloadElement) : null;
    var taskStatus = actionURL.get("NewTaskStatus");
    var modalStyle = "";
    var modalWindowSize = "";
    var bIsOverlay = "false";
    if (actionURL.get("modalStyle") != null) modalStyle = actionURL.get("modalStyle");
    if (actionURL.get("modalWindowSize") != null) modalWindowSize = actionURL.get("modalWindowSize");
    var baseRefCtrl = "";
    var baseRef = "";
    if (typeof(actionURL.get("BaseReference")) == "undefined") {
        // No Using Page if invoked from control
        if (actionURL.get("bInvokedFromControl") == true) {
            baseRefCtrl = "";
        }
        if (reloadTable) {
            baseRef = this.getBaseRef(reloadTable, event);
        }
        /*else {
                   var baseRef = this.getBaseRef(reloadElement,event);
               }*/
        if (baseRef == "") {
            baseRef = this.getBaseRef(reloadElement, event, null);
        }
        actionURL.put("BaseReference", baseRef);
    } else {
        baseRefCtrl = actionURL.get("BaseReference");
    }
    if (actionURL.get("bInvokedFromControl") == true) {
        // Add the control  baseref in case of start with .
        if (baseRefCtrl != "") {
            if (baseRefCtrl.slice(0, 1) == ".") {
                if (reloadTable) {
                    var baseRef = this.getBaseRef(reloadTable, event);
                } else {
                    var baseRef = this.getBaseRef(reloadElement, event);
                }
                baseRef = baseRef + baseRefCtrl;
                actionURL.put("BaseReference", baseRef);
            }
        }
    }
    if (actionURL.get("KeepMessages") == "true" || actionURL.get("KeepMessages") === true) {
        harCtxMgr.set("KeepMessages", "true");
    }
    if (document.forms[0] != null) {
        harCtxMgr.set("formEncodingType", document.forms[0].encoding);
        document.forms[0].encoding = "application/x-www-form-urlencoded";
    }
    var bSetPageListProp = true;
    if (this.firstBaseRefElement && (this.firstBaseRefElement.tagName.toUpperCase() == "TD" && (!reloadTable || !
            index))) {
        bSetPageListProp = false;
    }
    while ((reloadElement.id != "RULE_KEY") || (reloadElement.getAttribute("node_type") != "MAIN_RULE")) {
        if (reloadElement.id == "PEGA_HARNESS") {
            break;
        }
        reloadElement = reloadElement.parentNode;
        if (reloadElement == null) {
            var bReload = false;
            break;
        }
    }
    if (!this.isSafeToReload(reloadElement)) {
        if (bCalledFromGrid && pega.ctx.activeGrid && pega.ctx.activeGrid.action == "FLOWACTION" && pega.ctx.activeGrid
            .isOpenLocalAction) { /*BUG-199905: openlocalaction triggers row submit in case of inline edit. Due to submit action isSafeToReload() returns false. Now we have to clear properties which are set during "FLOWACTION" action initiation. */
            delete pega.ctx.activeGrid.isOpenLocalAction; /* This is set in doGridAction() for "FLOWACTION"(Open local action) action */
            delete pega.ctx.activeGrid.__fromLocalAction; /* This is set in processAction() for "Launch->Local action" action in grid */
            delete pega.ctx.activeGrid.bNoThreadProcess; /* This is set in doGridAction() for "FLOWACTION"(Open local action) action */
        }
        return;
    }
    if (reloadTable && index && (bSetPageListProp || actionURL.get("BaseReference") == "") && typeof(actionURL.get(
            "PageListProp")) == "undefined") {
        var pageVar = reloadTable.getAttribute("PL_PROP") || reloadTable.getAttribute("PG_PROP");
        actionURL.put("PageListProp", pageVar + "(" + index + ")");
    }
    actionURL.put("isModalFlowAction", "true");
    actionURL.put("bIsModal", "true");
    actionURL.put("bIsOverlay", bIsOverlay);
    //US-44112 - Updated to check for pyActivity in actionURL and use that so that edit at runtime could have its own processAction activity
    var pyActivity = actionURL.get("pyActivity");
    if (pyActivity && pyActivity != "") {
        actionURL.put("pyActivity", pyActivity);
    } else {
        actionURL.put("pyActivity", "ProcessAction");
    }
    actionURL.put("StreamClass", "Rule-HTML-Section");
    //actionURL.put("addtemplatepath","true"); 
    if (pega.ctx.isUITemplatized) { /* BUG-273463 - Set UITemplatingStatus only if it is not already set */
        if (!actionURL.get("UITemplatingStatus")) {
            actionURL.put("UITemplatingStatus", "Y");
        }
        if (actionURL.get("UITemplatingStatus") == "Y") {
            actionURL.put("UITemplatingScriptLoad", "true");
        }
    }
    var safeURL = SafeURL_createFromURL(harCtxMgr.get("url"));
    var modalSection = actionURL.get("ModalSection");
    /*
    if(!reloadTable && event!=null && typeof(Grids)!="undefined" && Grids && (typeof(pega.ctx.activeGrid)=="undefined" || !pega.ctx.activeGrid || !(pega.util.Dom.isAncestor(pega.ctx.activeGrid.gridDiv,pega.util.Event.getTarget(event))) )){
            var tempActiveGrid = Grids.getActiveGrid(event);
            if (tempActiveGrid) {
                pega.ctx.activeGrid = tempActiveGrid;
            }
    }
    */
    /*
    BUG-164804 : In the above commented if condition, "!(pega.util.Dom.isAncestor(this.activeGrid.gridDiv,pega.util.Event.getTarget(event))" - will be true only when event didn't originate from current active Grid i.e pega.ctx.activeGrid. If the event starts from a grid which is inside pega.ctx.activeGrid(nested grid scenario) then this will be false. Hence pega.ctx.activeGrid is not set to proper activeGrid.
    */
    if (!reloadTable && event != null && typeof(Grids) != "undefined" && Grids && (typeof(pega.ctx.activeGrid) ==
            "undefined" || !pega.ctx.activeGrid || !(pega.util.Dom.isAncestor(pega.ctx.activeGrid.gridDiv, pega.util
                .Event.getTarget(event))) || (Grids.getActiveGrid(event) && pega.util.Dom.isAncestor(Grids.getActiveGrid(
                event).gridDiv, pega.util.Event.getTarget(event))))) {
        var tempActiveGrid = Grids.getActiveGrid(event);
        if (tempActiveGrid) {
            pega.ctx.activeGrid = tempActiveGrid;
        }
    }
    /*
    BUG-83631 (RAIDV) - No use case could be found which requires executing scripts on opening a modal dialog when those scripts are meant to be
    executed on form submit, hence commenting the code to process onBeforeSubmits on modal open.
    */
    //pega.u.d.processOnBeforeSubmit();
    /*var isOverlay =  (flowActionTarget == "overlay");*/
    var postData = (options && options.doNotSubmit) ? null : this.getQueryString(reloadElement);
    var grid = null;
    var busyIndIntervalOriginal;
    /*
    if((modalSection == "pyGridDetails" || modalSection == "pyGridRowDetails") && typeof(actionURL.get("activeGridObj"))!="undefined" && typeof(actionURL.get("activeGridObj"))=="object"){
        grid = actionURL.get("activeGridObj");
    }else if(typeof(pega.ctx.activeGrid)!="undefined" && pega.ctx.activeGrid && (bCalledFromGrid || (pega.util.Dom.isAncestor(pega.ctx.activeGrid.gridDiv,event.srcElement) || pega.util.Dom.isAncestor(pega.ctx.activeGrid.gridDiv,pega.util.Event.getTarget(event))))){
        grid = pega.ctx.activeGrid;
        // BUG-153533 : Updating grid object to object returned from getActiveGrid based on event.
        if(actionURL.get("bInvokedFromControl") == true){
            var activeGridFromEvent = Grids.getActiveGrid(event);
            if(flowActionTarget == "overlay" && grid !== activeGridFromEvent){
                grid = activeGridFromEvent;
        if(grid)pega.ctx.activeGrid = grid;
            }
        }
        if((modalSection != "pyGridDetails" && modalSection != "pyGridRowDetails")) {
            grid.bCalledFromGrid = true;
        }
    }
    */
    // US-102365: Added the bShowDetails variable 
    var bEditInHarness, bEditExpandPane, bShowDetails;
    // US-102365: Setting the value of bShowDetails from the options
    if (options && options.isShowDetails) {
        bShowDetails = options.isShowDetails;
    }
    if (typeof(actionURL.get("activeGridObj")) != "undefined" && typeof(actionURL.get("activeGridObj")) == "object") {
        grid = actionURL.get("activeGridObj");
        /* BUG-277207 & SE-30724 - START, reseting __fromLocalAction (same is set by localaction not from grid) */
        if (bCalledFromGrid && pega.ctx.activeGrid && pega.ctx.activeGrid.action == "EDITITEM" && grid.editConfig ==
            grid.EDIT_EXPANDPANE) {
            delete pega.ctx.activeGrid.__fromLocalAction;
        }
        /* BUG-277207 & SE-30724 - END */
        // US-58608: Support custom templates in Grid Master-Detail
        bEditInHarness = (grid.editConfig == grid.EDIT_HARNESS && (!grid.isOpenLocalAction && !grid.__fromLocalAction));
        bEditExpandPane = ((grid.editConfig == grid.EDIT_EXPANDPANE || modalSection == "pyGridRowDetails") && (!grid
            .isOpenLocalAction && !grid.__fromLocalAction));
    }
    var pui_colmenuflag = true;
    if (event) {
        var targetNode = pega.util.Event.getTarget(event);
        var requiredTarget = jQuery(targetNode).closest('a');
        if (requiredTarget && requiredTarget.attr('id') == "pui_colmenu") {
            pui_colmenuflag = false;
        }
    }
    //tails- ProcessAction from grid header, It does not need any row context so skip the grid code.
    if (modalSection == "pyModalTemplateDataViewAddColumn" || modalSection == "pyModalTemplateDataViewRenameColumn") {
        pui_colmenuflag = false
    }
    
    /*BUG-584024 : Launching local action issue from Hierarchical table
      Checking if RDL is in middle of Grid and Local Action Target.
      BUG-590288: regression fix
    */
    var rdlInMiddle = false;
    if(pega.ctx.activeGrid && event){
      var eventTarget = event.target || event;
      /* TASK-1157292 Child Case comments pop-up is not working
       BUG-661109 - Adding a safe check for eventTarget.closest method. If eventTarget is set to pega.ui.grid then eventTarget.closest() method is not available because pega.ui.grid is a Grid object. For eventTarget.closest() method to be available, eventTarget has to be a dom element.*/
      rdlInMiddle = pega.u.d.isRdlInMiddle(eventTarget, pega.ctx.activeGrid.gridDiv);
    }
    //BUG-740792 - Removing active grid in case when even is triggered from RDL
    if(rdlInMiddle) pega.ctx.activeGrid = null;
  
    if (typeof(pega.ctx.activeGrid) != "undefined" && pega.ctx.activeGrid && (bCalledFromGrid || (pega.util.Dom.isAncestor(
            pega.ctx.activeGrid.gridDiv, pega.util.Event.getTarget(event)) || pega.util.Dom.isAncestor(pega.ctx
            .activeGrid.gridDiv, pega.util.Event.getTarget(event)))) && (!bEditInHarness && !bEditExpandPane)) {
        grid = pega.ctx.activeGrid;
        // US-58608: Support custom templates in Grid Master-Detail
        bEditInHarness = (grid.editConfig == grid.EDIT_HARNESS && (!grid.isOpenLocalAction && !grid.__fromLocalAction));
        bEditExpandPane = ((grid.editConfig == grid.EDIT_EXPANDPANE || modalSection == "pyGridRowDetails") && (!grid
            .isOpenLocalAction && !grid.__fromLocalAction));
        /*BUG-153533 : Updating grid object to object returned from getActiveGrid based on event.*/
        if (actionURL.get("bInvokedFromControl") == true) {
            var activeGridFromEvent = Grids.getActiveGrid(event);
            if (flowActionTarget == "overlay" && grid !== activeGridFromEvent) {
                grid = activeGridFromEvent;
            }
        }
        if (!bEditInHarness && !bEditExpandPane && pui_colmenuflag) {
            //if(!bEditInHarness && !bEditExpandPane){
            grid.bCalledFromGrid = true;
        }
    }
    /*GRP-37800 ActionSection is reset to pyOverlayTemplate if the FlowActionTarget is overlay*/
    if (flowActionTarget == "overlay") {
        actionURL.put("ActionSection", "pyOverlayTemplate");
        bIsOverlay = "true";
        actionURL.put("bIsOverlay", "true");
        modalSection = "pyOverlayTemplate";
        actionURL.remove("FlowActionTarget");
    }
    /*BUG-157823 and later BUG-213754 - Checking if control triggering Local Action is configured in gridAction / gridActionBottom. If it is then perform ProcessAction instead of pzPerformGridAction.*/
    if (actionURL.get("bInvokedFromControl") == true && grid) {
        //see if the source element is Grid Action Top/Bottom
        //Using className for DOM identification.
        //Values: gridActionTop / gridActionBottom
        var bIsControlInGridActionArea = false;
        var currentDOMElement = pega.util.Event.getTarget(event);
        var gridObj = $(grid.gridDiv);
        var actionTop = gridObj.find(".gridActionTop");
        if (actionTop.length > 0) {
            bIsControlInGridActionArea = actionTop.find(currentDOMElement).length > 0;
        }
        if (!bIsControlInGridActionArea) {
            var actionBottom = gridObj.find(".gridActionBottom");
            if (actionBottom.length > 0) {
                bIsControlInGridActionArea = actionBottom.find(currentDOMElement).length > 0;
            }
        }
        if (bIsControlInGridActionArea) {
            grid = null; // skip grid related actions
            if (bIsOverlay != "true") {
                pega.ctx.activeGrid = null; //This is isnt really required and is causing BUG-192794 
            }
        }
    }
  
    if (grid && pui_colmenuflag && !rdlInMiddle) {
        try {
            if(grid.rightBodyTbl.contains(event.target))
              grid.selectPage(event, grid.rightBodyTbl);
            else
              grid.selectPage(event, grid.gridDiv);
        } catch (ex) {}
        //if no row is selected in the grid, alert the user and return
        if (!grid.getActiveRowIndex()) {
            delete grid.__fromLocalAction;
            //alert("Please select a row ");
            alert(pega.u.d.fieldValuesList.get("Please_select_a_row"));
            return false;
        }
        postData = this.getQueryString(grid.getLeftRow());
        if (modalSection == null || modalSection == "") {
            modalSection = "pyGridModalTemplate";
        }
        actionURL.put("ActionSection", modalSection);
        grid.isGridAction = true;
        grid.modalAction = taskStatus;
        if (grid.editFormat) modalStyle = grid.editFormat;
        grid.sectionName = this.getSectionDiv(grid.gridDiv).getAttribute("NODE_NAME");
        grid.usingPage = this.getBaseRef(grid.gridDiv);
        grid.baseThreadContext = this.getThreadName();
        grid.modalThreadContext = "";
        var gridClass = grid.propertyClass;
        grid.propRef = pega.ui.property.toReference(grid.getLeftRow().id);
        if (actionURL.get("bInvokedFromControl") == true) {
            var rowPage = "";
            var parent = this.insertButton.parentNode;
            while (parent && !parent.getElementById) {
                if ((parent.tagName.toUpperCase() == "TR" || parent.tagName.toUpperCase() == "LI") && parent.id ==
                    grid.getLeftRow().id) { //  tr hit first
                    rowPage = grid.propRef;
                    break;
                }
                //BUG-159656 : Added pyFlowActionHTML check for EmbedPane and ExpandPane scenarios.
                if (parent.id == "RULE_KEY" && parent.getAttribute("node_type") == "MAIN_RULE" && parent.getAttribute(
                        "BASE_REF") || (parent.tagName.toUpperCase() == "TD" && parent.getAttribute("BASE_REF")) ||
                    parent.id == "pyFlowActionHTML") {
                    // baseref hit first
                    var baseRefUI = "";
                    if (reloadTable) {
                        baseRefUI = this.getBaseRef(reloadTable, event);
                    } else {
                        baseRefUI = this.getBaseRef(reloadElement, event);
                    }
                    if (baseRefUI.slice(0, 1) == ".") {
                        rowPage = grid.propRef + baseRefUI;
                    } else {
                        rowPage = baseRefUI;
                    }
                    break;
                }
                parent = parent.parentNode;
            }
            if (baseRefCtrl != "") {
                if (baseRefCtrl.slice(0, 1) == ".") {
                    // Embed page
                    rowPage = rowPage + baseRefCtrl;
                } else {
                    rowPage = baseRefCtrl;
                }
            }
            actionURL.put("rowPage", rowPage);
        } else {
            actionURL.put("rowPage", grid.propRef);
        }
        actionURL.put("GridAction", "true");
        /*BUG-326078 : in case of redirect and run, isRemoteCase paramter is not propagating*/
        if (pega.u.d.ServerProxy.isDestinationRemote() && pega.offline) {
            actionURL.put("isRemoteCase", "true");
        }
        /*Passed as the parameter to RedirectAndRun*/
        actionURL.put("pyActivity", "pzPrepareAssignment");
        actionURL.put("BaseThread", grid.baseThreadContext);
        safeURL.put("pyActivity", "pzPerformGridAction");
        /*  BUG-294282 */
        if (grid.editConfig === "expandPane") safeURL.put("gridExpandPane", "true");
        safeURL.put("ThreadName", "");
        if (grid.editConfig == grid.EDIT_HARNESS) {
            safeURL.put("EditConfig", "harness");
        }
        if (grid.bReadOnlyShowDetails && modalSection == "pyGridRowDetails") {
            safeURL.put("EditConfig", "ROexpandPane");
            actionURL.put("EditConfig", "ROexpandPane");
        }
        // BUG-266907: RO + EmbedPane
        else if (grid.editConfig == "harness" && grid.bRODetails == true && modalSection == "pyGridDetails") {
            safeURL.put("EditConfig", "ROEmbedPane");
            actionURL.put("EditConfig", "ROEmbedPane");
        }
        /* TASK-118164: Added noThreadProcess param  */
        /*BUG-277496,BUG-309752: Removed the check for bRODetails as it is side effect for the work object in Work-*/
        if (grid.isOpenLocalAction && grid.bNoThreadProcess) {
            safeURL.put("noThreadProcess", "true");
        }
        safeURL.put("rowPage", grid.propRef);
        // BUG-409915 : pass true param to toQueryString to avoid extra encoding as asyncrequest already does that.
        safeURL.put("Location", actionURL.toQueryString(true));
        safeURL.put("PagesToCopy", grid.propRef.substring(0, grid.propRef.indexOf('.')));
        /* BUG-170323: Put pzKeepPageMessages in safeURL  */
        if (actionURL.get("KeepMessages") == "true" && harCtxMgr.get("KeepMessages") == "true") {
            safeURL.put("pzKeepPageMessages", "true");
        }
        var rightRow = pega.util.Dom.getElementsById(grid.getLeftRow().id, grid.rightBodyTbl);
        if (rightRow && rightRow[0]) {
            rightRow = rightRow[0];
            postData.copy(this.getQueryString(rightRow));
            if (grid.editConfig == "expandPane") {
                expandPaneNode = pega.util.Dom.getNextSibling(rightRow);
                if (expandPaneNode && expandPaneNode.getAttribute("expanded") == "true") {
                    postData.copy(this.getQueryString(expandPaneNode));
                }
            } else if (grid.editConfig == grid.EDIT_HARNESS && pega.util.Dom.getElementsById("pyFlowActionHTML",
                    grid.gridDetailsDiv)) {
                postData.copy(this.getQueryString(grid.gridDetailsDiv));
            }
        }
    } else {
        if (modalSection) {
            actionURL.put("ActionSection", modalSection);
        } else {
            actionURL.put("ActionSection", "pyModalTemplate");
            modalSection = "pyModalTemplate";
        }
    }
    // Couple isDestinationRemote with isHybridClient
    if (pega.u.d.ServerProxy.isDestinationRemote() && pega.u.d.ServerProxy.isHybridClient()) {
        actionURL.put("isRemoteCase", true);
    }
    // US-108746: Augmenting processAction to invoke pzdoRDLAction
    if (bShowDetails && options.isOnlineWOBound && pega.ctx.RDL.masterDetailsParams && pega.ctx.RDL.masterDetailsParams
        .__RDLThreadSetup) {
        var rowPage = options.fAObjClass;
        var sourcePage = rowPage.substring(0, rowPage.indexOf('.'));
        var insKey;
        // Params for RedirectAndRun activity
        var staticActionURL = new SafeURL();
        // US-270508: Move the static params into a different request param (other than location)
        //actionURL.put("pyActivity", "pzRDLWorkProcessing");
        staticActionURL.put("pyActivity", "pzRDLWorkProcessing");
        staticActionURL.put("StreamType", actionURL.get("StreamType"));
        staticActionURL.put("ModalSection", actionURL.get("ModalSection"));
        staticActionURL.put("StreamClass", actionURL.get("StreamClass"));
        staticActionURL.put("ActionSection", actionURL.get("ActionSection"));
        staticActionURL.put("NewTaskStatus", actionURL.get("NewTaskStatus"));
        staticActionURL.put("pxReqURI", "rdlmasterdetails");//To prevent pzHarnessID being added to StaticLocation
      
        // US-270508: Delete the static params from actionURL
        delete actionURL.hashtable["StreamType"];
        delete actionURL.hashtable["ModalSection"];
        delete actionURL.hashtable["StreamClass"];
        delete actionURL.hashtable["ActionSection"];
        delete actionURL.hashtable["NewTaskStatus"];
        actionURL.put("rowPage", rowPage);
        if (options.noThreadProcess) {
            actionURL.put("noThreadProcess", "true");
        }
        if (options.bRODetails) { /*BUG-369520: Sending bRODetails param to prevent the secondary details flowaction from acquiring WO lock */
            actionURL.put("bRODetails", "true");
        }
        // Params for pzdoRDLAction
        safeURL.put("pyActivity", "pzdoRDLAction");
        safeURL.put("listAction", "EDITDETAILS");
        safeURL.put("PagesToCopy", sourcePage);
        safeURL.put("ThreadSetup", "true");
        /* OSCO RDL - online MD secondary details case */
        //var DPName = rowPage.substring(0,rowPage.indexOf("_pa"));
        if (pega.u.d.ServerProxy.isDestinationRemote()) {
            //if(pega.u.d.ServerProxy.isDestinationRemote() && rowPage.indexOf("D_") == 0 || rowPage.indexOf("Declare_") == 0) {
            var cc_rowPage = pega.ui.ClientCache.find(rowPage);
            if (cc_rowPage && cc_rowPage.get("pzInsKey")) {
                insKey = cc_rowPage.get("pzInsKey").getValue();
            }
            if (insKey) { /*BUG-266633: Moved everything except deleting noThreadProcess inside the isHybridClient if block */
                delete actionURL.hashtable.noThreadProcess;
                if (pega.u.d.ServerProxy.isHybridClient() && pega.ui.ParametrizedDPUtils.isParametrizedDataPageInstance(
                        rowPage)) {
                    safeURL.put("WOInsKey", insKey);
                    if (cc_rowPage.get("pxObjClass")) safeURL.put("WOObjClass", cc_rowPage.get("pxObjClass").getValue());
                    delete actionURL.hashtable.BaseReference;
                    delete actionURL.hashtable.rowPage;
                    delete safeURL.hashtable.PagesToCopy;
                }
            }
        }
        safeURL.put("Location", actionURL.toQueryString());
        safeURL.put("StaticLocation",staticActionURL.toQueryString()); //US-270508: Set the static params as a separate param
    } else {
        if (safeURL.get("ThreadName") == undefined) {
            safeURL.copy(actionURL, true);
        }
    }
    if (pega.ctx.RDL.masterDetailsParams && pega.ctx.RDL.masterDetailsParams.__RDLWOThreadInitialized) {
        safeURL.put("pzPrimaryPageName", "pyWorkPage");
        /* OSCO RDL - online MD Edit case */
        var detailsDiv = pega.ui.rdlMasterDetails.getActiveRDLMetaInfo().showDetailsNode;
        if (detailsDiv) {
            var secondaryFADiv = $(detailsDiv).find("#pyFlowActionHTML");
            if (secondaryFADiv && secondaryFADiv.get(0)) {
                safeURL.put("rowPage", secondaryFADiv.attr("temp_assign_ref"));
                safeURL.put("BaseReference", secondaryFADiv.attr("temp_assign_ref"));
            }
        }
    }
    /*BUG-195703 (RAIDV) - Added the to make modals full screen when invoked from List -> Open Local action. This code has hard-coded animation and if in future grid needs its own animation, this code should be removed and grid's processAction must pass proper anim object.*/
    if (bCalledFromGrid) {
        options = {};
        var animObj = {
            animIn: 'anim-bottom',
            animOut: 'anim-bottom'
        };
        options.animObj = animObj;
        options.isLocalAction = true;
    }
    //if((modalSection != "pyGridDetails" && modalSection != "pyGridRowDetails") {
    //US-102365: Adding a check for bShowDetails
    if (!bEditInHarness && !bEditExpandPane && !bShowDetails) {
        if (pega.u.d.submitModalDlgParam != null) {
            var eventLevel = pega.u.d.getPopOverLevel(event.target);
            if (pega.u.d.submitModalDlgParamStack.length == 0 || eventLevel != pega.u.d.submitModalDlgParamStack[
                    pega.u.d.submitModalDlgParamStack.length - 1].level) {
                pega.u.d.submitModalDlgParam.level = eventLevel;
                pega.u.d.submitModalDlgParamStack.push(pega.u.d.submitModalDlgParam);
            }
        }
        //US-79038 Disable clickaway configuration
        if (bIsDisableClickaway == null || typeof(bIsDisableClickaway) == "undefined") {
            bIsDisableClickaway = false;
        }
        //Center Position Overlay
        if (options != null && (options.isCenterOverlay == null || typeof(options.isCenterOverlay) == "undefined")) {
            options.isCenterOverlay = false;
        }
        pega.u.d.submitModalDlgParam = {
            taskStatus: taskStatus,
            modalSection: modalSection,
            bReload: bReload,
            StreamType: actionURL.get("StreamType"),
            flowActionTarget: flowActionTarget,
            ModalStyle: modalStyle,
            bIsOverlay: bIsOverlay,
            reloadElement: reloadElement,
            ModalWindowSize: modalWindowSize,
            associatedElement: this.insertButton,
            activeGrid: pega.ctx.activeGrid,
            userCallbackObj: callbackObj,
            animObj: (options) ? options.animObj : undefined,
            isMobileFullScreen: options ? options.isMobileFullScreen : "false",
            fAObjClass: (options) ? options.fAObjClass : '',
            mTObjClass: (options) ? options.mTObjClass : '',
            bIsDisableClickaway: bIsDisableClickaway,
            bIsCenterOverlay: (options) ? options.isCenterOverlay : '',
            isLocalAction: (options) ? options.isLocalAction : undefined
        };
        if (options) { /* US-97933: Add below properties to handle flow in OSCO for add item action */
            if (options.contextParams) {
                pega.u.d.submitModalDlgParam.contextParams = options.contextParams;
            }
            if (options.doNotRefresh) {
                pega.u.d.submitModalDlgParam.bReload = (pega.u.d.submitModalDlgParam.bReload == undefined) ? (!
                    options.doNotRefresh) : pega.u.d.submitModalDlgParam.bReload;
            }
            if (options.isAddingNewRow) {
                pega.u.d.submitModalDlgParam.isAddingNewRow = options.isAddingNewRow;
                pega.u.d.submitModalDlgParam.cancelModalActivity = options.cancelModalActivity;
                pega.u.d.submitModalDlgParam.datasource = options.datasource;
                pega.u.d.submitModalDlgParam.position = options.position;
            }
        }
        var callback = {
            success: pega.u.d.processActionModal_Success,
            failure: pega.u.d.processActionModal_Failure,
            preRenderer: pega.u.d.processActionModal_Pre_Success,
            scope: this
        };
    } else if (bShowDetails) { //US-102365: Preparing callbacks for show details
        if (pega.u.d.submitModalDlgParam) {
            pega.u.d.submitModalDlgParam.modalSection = options.modalSection;
            pega.u.d.submitModalDlgParam.mTObjClass = options.mTObjClass;
            pega.u.d.submitModalDlgParam.fAObjClass = options.pxObjClass;
            pega.u.d.submitModalDlgParam.taskStatus = options.taskStatus;
            pega.u.d.submitModalDlgParam.contextParams = options.contextParams;
            pega.u.d.submitModalDlgParam.isShowDetails = options.isShowDetails;
        } else {
            pega.u.d.submitModalDlgParam = {
                modalSection: options.modalSection,
                mTObjClass: options.mTObjClass,
                fAObjClass: options.pxObjClass,
                taskStatus: options.taskStatus,
                contextParams: options.contextParams,
                isShowDetails: options.isShowDetails
            };
        }
        var callback = {
            success: pega.u.d.showDetailsFlowAction_Success,
            failure: pega.u.d.processActionModal_Failure,
            scope: this
        };
        /* BUG-324470: Defining a pre-renderer to switchthread for RDL secondary details */
        if (options.isOnlineWOBound && pega.ctx.RDL.masterDetailsParams && pega.ctx.RDL.masterDetailsParams.__RDLThreadSetup) {
            callback.preRenderer = pega.u.d.showDetails_PreSuccess;
        }
    } else {
        var callback = {
            success: pega.u.d.processActionGridDetail_Success,
            failure: pega.u.d.processActionModal_Failure,
            scope: this
        };
    }
    var MDOverlayOpen = pega.ctx.RDL.masterDetailsParams && pega.ctx.RDL.masterDetailsParams.isShowDetailsOpen;;
    // Desktop: When modal is launched from master detail overlay, then don't do section refresh
    if (pega.u.d.ServerProxy.isDestinationRemote() && MDOverlayOpen) {
        if (pega.u.d.submitModalDlgParam) {
            pega.u.d.submitModalDlgParam.bReload = !options.doNotRefresh;
        }
    }
    callback.argument = [grid];
    if (!grid) {
        this.setBusyIndicator(reloadElement, false);
    } else {
        this.setBusyIndicator(reloadElement, false, true); /* BUG-108153: Show only mask immediately for grid related actions.*/
    }
    /*
    RAIDV - To allow for minimum changes in existing processAction, asyncRequest call is replaced with ProcessActionOffline APIs for offline enabled portals, case or harnesses. The computation done above in this function, processActionModalOnlineHandler are useful even in offline cases so reatain all those and use submitModalDlgParam to display overlay/modal in success callbacks.
    */
    //TODO - Use correct isOfflineEnabled flag because ProcessActionOffline must be invoked even in cases when device is offline and case is offline enabled.
    var oscoHandler = {
        scope: this,
        offline: function() {
            pega.ui.ProcessActionOffline.initStreamDisplay((arguments[0] && arguments[0].hashtable) ?
                arguments[0].hashtable : {}); // passing SafeURL obj bajaa BUG-226415
        },
        online: function(safeURL, postData, callback) {
            this.asyncRequest('POST', safeURL, callback, postData);
        }
    };
    /* added for US-229126 - parmn */
    var domClickElement = this.gFocusElement ? this.gFocusElement : (this.focusElement ? this.focusElement : null);
    var responseLA;
    if (options && options.loadBehaviour == "firstuse") {
        responseLA = pega.ui.ClientDataProvider.getMetadataStoreByType("LOCALACTION")[options.uniqueId];
    }
    if (options && options.loadBehaviour == "firstuse" && domClickElement && domClickElement.getAttribute(
            'data-fetched') && responseLA) {
        pega.ui.TemplateEngine.enableDataUpdate();

        function uiRenderedCallback(responseText, isTemplateCB) {
            if (responseText != null) responseLA = responseText;
        }
        pega.ui.TemplateEngine.renderUI(responseLA, uiRenderedCallback, undefined);
        pega.u.d.processActionModal_Success({
            "responseText": responseLA
        });
        pega.ui.TemplateEngine.disableDataUpdate();
    } else {
        if (options && options.loadBehaviour == "firstuse") {
            this.loadBehaviour = "firstuse";
            this.uniqueId = options.uniqueId;
        }
        this.ServerProxy.doAction(safeURL, postData, oscoHandler, callback);
    }
};
// US-102365: Success callback for showDetails
pega.ui.Doc.prototype.showDetailsFlowAction_Success = function(oResponse) {
    if (oResponse && oResponse.responseText) {
        pega.ui.rdlMasterDetails.showDetailsFlowAction_Success(oResponse);
    }
};
/* BUG-324470: Defining a pre-renderer to switchthread for RDL secondary details */
pega.ui.Doc.prototype.showDetails_PreSuccess = function(oResponse) {
    if (oResponse && oResponse.responseText) {
        pega.ui.rdlMasterDetails.showDetails_PreSuccess(oResponse);
    }
};
/*
 @public pre Success Callback api for ProcessActionModal function
 @Handler
 @param $Object$oResponse contains theresponse
 @return $void$
*/
pega.ui.Doc.prototype.processActionModal_Pre_Success = function(oResponse) {
        //Set the Harness ID on Modal overlay DIV
        if (pega.u.d.modalDialog && pega.u.d.modalDialog.element && (!pega.u.d.submitModalDlgParam || pega.u.d.submitModalDlgParam.bIsOverlay !== "true")) {
            pega.ctxmgr.registerContextSwitching(pega.u.d.modalDialog.element);
        }
    }
    /*BUG-414328
     @public Success Callback api for ProcessActionModal function
     @Handler
     @param $Object$oResponse contains theresponse
     @return $void$
    */
pega.ui.Doc.prototype.processActionModal_Success = function(oResponse) {
    var strResponse = oResponse.responseText;
    if (strResponse && strResponse.match("ENGINE_ERRORS")) {
        var errorNode = document.createElement("div");
        errorNode.innerHTML = strResponse.substr(strResponse.indexOf("||"));
        pega.u.d.handleFormErrors(errorNode);
        alert(localCorrectErrors);
        pega.u.d.gBusyInd.hide();
        return;
    }
    var stream_no_ui = pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.StreamType && pega.u.d.submitModalDlgParam
        .StreamType == "NO_UI";
    var loadDOMReq = !(stream_no_ui || strResponse == "ERROR");
    //var returnNode = document.createElement("DIV");
    //returnNode.innerHTML = strResponse;
    var overlayNode = null;
    var modalStyle = "";
    var modalWindowSize = "";
    if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.ModalStyle) modalStyle = pega.u.d.submitModalDlgParam
        .ModalStyle;
    if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.ModalWindowSize) modalWindowSize = pega.u.d.submitModalDlgParam
        .ModalWindowSize;
    //US-79038 Disable clickaway configuration
    var bIsDisableClickAway = "";
    var bIsCenterOverlay = "";
    if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.flowActionTarget && pega.u.d.submitModalDlgParam
        .flowActionTarget == "overlay") {
        overlayNode = document.createElement("DIV");
        //US-79038 Disable clickaway configuration
        bIsDisableClickAway = pega.u.d.submitModalDlgParam.bIsDisableClickaway ? pega.u.d.submitModalDlgParam.bIsDisableClickaway :
            false;
        //Center Position Overlay
        bIsCenterOverlay = pega.u.d.submitModalDlgParam.bIsCenterOverlay ? pega.u.d.submitModalDlgParam.bIsCenterOverlay :
            false;
    } else {
        var modalDialogBody = pega.u.d.modalDialog.body;
        var top = 0;
        if (!pega.u.d.bModalRendered) {
            pega.u.d.renderModal();
        }
        if (pega.u.d.useOldModalDialog) {
            var returnData = pega.u.d.prePositionModalDialog();
            top = returnData[1];
            var bFixedCenter = true;
            bFixedCenter = returnData[0];
        } else {
            var bFixedCenter = true;
        }
    }
    var currentScope = this;
    var callbackInterceptor = function() {
        //US-79038 Disable clickaway configuration
        pega.u.d.gCallbackArgs = {
            modalDialogBody: modalDialogBody,
            returnNode: modalDialogBody,
            strResponse: strResponse,
            domObj: modalDialogBody,
            bIsFlowActionModal: true,
            top: top,
            bFixedCenter: bFixedCenter,
            overlayNode: overlayNode,
            modalStyle: modalStyle,
            bIsDisableClickaway: bIsDisableClickAway,
            bIsCenterOverlay: bIsCenterOverlay
        };
        var nodeToRender = modalDialogBody;
        if (overlayNode) {
            nodeToRender = overlayNode;
        } else {
            pega.u.d.modalDialogExtras(modalWindowSize);
        }
        if (currentScope.activeGrid && currentScope.activeGrid.bCalledFromGrid) {
            currentScope.activeGrid.bCalledFromGrid = false;
            var grid = currentScope.activeGrid;
            // Set the params like TEMP_ASSIGN_REF, PRIM_PAGE to activegrid.
            var flowActionContent = pega.util.Dom.getElementsById("pyFlowActionHTML", nodeToRender, "DIV");
            if (flowActionContent && flowActionContent.length > 0) { /* When modal dialog content gets returned */
                flowActionContent = flowActionContent[0];
                grid.propRef = flowActionContent.getAttribute("TEMP_ASSIGN_REF");
                if (grid.editFormat && grid.editFormat != "") pega.u.d.gCallbackArgs.modalStyle = grid.editFormat;
                grid.primaryPage = flowActionContent.getAttribute("PRIM_PAGE");
                grid.tempInterestPage = flowActionContent.getAttribute("TEMP_BASE_REF");
                grid.modalThreadContext = flowActionContent.getAttribute("THREAD_NAME");
                grid.isLocked = (flowActionContent.getAttribute("LOCKED") == "true");
                if (grid.isLocked) {
                    grid.DONOT_SUBMIT = "true";
                }
                var templateName = "pyGridModalTemplate";
                var templateNode = nodeToRender.children[0];
                if (templateNode && templateNode.getAttribute("node_name")) templateName = templateNode.getAttribute(
                    "node_name");
                pega.u.d.attachClickForGridButtons(grid, nodeToRender, templateName);
                if (grid.threadProcessing && !grid.bNoThreadProcess && !(grid.getModalAction() == "PREV" || grid
                        .getModalAction() == "NEXT" || grid.getModalAction() == "ADD")) {
                    currentScope.switchThread(grid.modalThreadContext);
                    currentScope.switchPrimaryPage("pyWorkPage");
                }
            } else {
                if (loadDOMReq) {
                    pega.u.d.loadHTMLEleCallback(nodeToRender);
                }
                if (strResponse == "ERROR") {
                    grid.primaryPage = grid.propRef.substring(0, grid.propRef.indexOf('.'));
                    grid.tempInterestPage = "";
                    switch (grid.getModalAction()) {
                        case "INSERTAFTER":
                        case "INSERTBEFORE":
                        case "ADDCHILD":
                        case "APPENDLAST":
                        case "ADDFIRSTCHILD":
                            grid.setModalAction("REMOVELAST");
                            break;
                        default:
                            grid.setModalAction("ERROR");
                    }
                } else {
                    var responseArray = strResponse.split("||");
                    if (responseArray && responseArray[0] == "NO_UI") {
                        grid.NO_UI = true;
                        grid.setModalAction("SUBMIT");
                        grid.primaryPage = responseArray[1];
                        grid.tempInterestPage = responseArray[2];
                        grid.modalThreadContext = responseArray[3];
                        currentScope.url = currentScope.url.replace(grid.baseThreadContext, grid.modalThreadContext);
                        currentScope.switchPrimaryPage("pyWorkPage");
                    } else {
                        grid.primaryPage = grid.propRef.substring(0, grid.propRef.indexOf('.'));
                        grid.tempInterestPage = "";
                        grid.setModalAction("ERROR");
                    }
                }
                grid.performModalAction();
                return;
            }
        }
        //US-102365: Adding a check for showDetails
        var bShowDetails = pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.isShowDetails;
        if (!overlayNode && !bShowDetails) {
            if (pega.u.d.modalDialog.setTransitions && pega.u.d.submitModalDlgParam) pega.u.d.modalDialog.setTransitions(
                pega.u.d.submitModalDlgParam.animObj, pega.u.d.submitModalDlgParam.isLocalAction, pega.u.d.submitModalDlgParam
                .isMobileFullScreen);
            /* BUG-263125 */
            var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
            if (popOver && popOver.getState() != "closing") {
                var popOverContainerElem = popOver.getContentContainerElement();
                if (popOverContainerElem != null && popOverContainerElem.style.visibility != "hidden") {
                    $(popOverContainerElem).css("z-index", "8");
                }
            }
            pega.u.d.modalDialog.show();
            // BUG-264449: Dont focus the element it is done by pega.u.d.modalDialogCallBack call.
            /* 
              if(!(pega.cl && pega.cl.isTouchAble())) {
              var eleToFocus = pega.u.d.getFirstFocusableElement(pega.u.d.modalDialog.innerElement.id);
              if(eleToFocus) {
                  try{
                      eleToFocus.focus();
                      pega.u.d.fixFocusInIE(eleToFocus);
                  }catch(e){}
              }
              }
              */
        }
        var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", nodeToRender);
        if (onlyOnceEle && onlyOnceEle[0]) {
            pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
            onlyOnceEle[0].parentNode.removeChild(onlyOnceEle[0]);
        }
        var errorNode = pega.util.Dom.getElementsById("ERRORTABLE", nodeToRender);
        if (errorNode) errorNode = errorNode[0];
        /* Added below code to extract skeleton EPIC-30602 - Start */
        if (overlayNode) {
            if (nodeToRender && nodeToRender.getElementsByClassName) {
                var elementNode = nodeToRender.getElementsByClassName("skeleton");
                if (elementNode && elementNode.length > 0) {
                    var elementToInsert = "";
                    for (var i = 0; i < elementNode.length; i++) {
                        if (!document.getElementById(elementNode[i].id)) elementToInsert += elementNode[i].outerHTML;
                    }
                    $('body').append(elementToInsert);
                    elementToInsert = null;
                }
            }
        }
        /* Added below code to extract skeleton EPIC-30602 - End */
        var modalHTMLNode = pega.util.Dom.getElementsById("modaldialog_con", nodeToRender);
        if (modalHTMLNode && modalHTMLNode[0]) {
            var childElements = pega.util.Dom.getChildren(modalHTMLNode[0]);
            var childEleLength = childElements.length;
            var childElement = null;
            for (var i = 0; i < childEleLength; i++) {
                childElement = childElements[i];
                if (childElement && childElement.id != "pyFlowActionHTML") {
                    childElement.parentNode.removeChild(childElement);
                }
            }
        }
        if (errorNode) {
            var tmpDiv = document.createElement("DIV");
            tmpDiv.appendChild(errorNode);
            pega.u.d.handleFormErrors(tmpDiv);
            tmpDiv = null;
        }
        if (overlayNode) {
            pega.u.d.overlayCallBack.call();
        } else {
            pega.u.d.modalDialogCallBack.call();
        }
    }
    var callback = callbackInterceptor;
    if (loadDOMReq) {
        if (overlayNode) {
            /*pega.u.d.loadDOMObject(overlayNode,strResponse,callback);*/
            overlayNode.innerHTML = strResponse;
            callback.call();
        } else {
            pega.u.d.loadDOMObject(modalDialogBody, strResponse, callback);
        }
    } else callback.call();
    if (pega.u.d.inCall) {
        pega.ctx.activeGrid.resetInCall();
    }
};
pega.ui.Doc.prototype.closeOverlay = function() {
    if (arguments[1]) {
        var el = $("#" + $(arguments[3]).attr("id") + " .container-close");
        el[0] ? el[0].remove() : false;
        pega.u.d.localActionContainerOpened(false);
    }
    pega.u.d.performFlowAction("", "", "", pega.u.d.submitModalDlgParam ? pega.u.d.submitModalDlgParam.taskStatus :
        '', arguments[2].popOverElement, undefined, arguments[0]);
};
/*
 @public Success Callback api for processActionGridDetail_Success function
 @Handler
 @param $Object$oResponse contains theresponse
 @return $void$
*/
pega.ui.Doc.prototype.processActionGridDetail_Success = function(oResponse) {
    var strResponse = oResponse.responseText;
    var activeGridObj = oResponse.argument[0];
    if (strResponse && strResponse.match("ENGINE_ERRORS")) {
        var errorNode = document.createElement("div");
        errorNode.innerHTML = strResponse.substr(strResponse.indexOf("||"));
        pega.u.d.handleFormErrors(errorNode);
        if (activeGridObj && activeGridObj.expandCollapseAnchor) { /* BUG-111936: call changeExpandCollapseIconState() in case of errors. */
            activeGridObj.changeExpandCollapseIconState();
        }
        alert(localCorrectErrors);
        pega.u.d.gBusyInd.hide();
        return;
    }
    var stream_no_ui = pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.StreamType && pega.u.d.submitModalDlgParam
        .StreamType == "NO_UI";
    var loadDOMReq = !(stream_no_ui || strResponse == "ERROR");
    var gridEditMode = activeGridObj.editConfig;
    if (gridEditMode == "harness") {
        var gridDetailBody = activeGridObj.gridDetailsDiv;
    } else if (gridEditMode == activeGridObj.EDIT_EXPANDPANE) {
        var selectedRow = activeGridObj.getRightRow();
        var rowdetailsDiv = pega.util.Dom.getElementsById("rowDetail" + selectedRow.id, activeGridObj.rightBodyTbl,
            "DIV");
        if (rowdetailsDiv && rowdetailsDiv[0]) {
            gridDetailBody = rowdetailsDiv[0];
        } else {
            var rowIndex = selectedRow.rowIndex;
            var totalCells = selectedRow.cells.length;
            if (totalCells == 0 && selectedRow.id == "yui_modalrownew") {
                var prevSibling = pega.util.Dom.getPreviousSibling(selectedRow);
                totalCells = (prevSibling) ? prevSibling.cells.length : 1;
            } else if (totalCells == 1 && (selectedRow.id == "" || selectedRow.id == null)) {
                totalCells = selectedRow.cells[0].colSpan;
            }
            var newTR = activeGridObj.rightBodyTbl.insertRow(rowIndex + 1);
            newTR.setAttribute("expanded", "true");
            var newTD = newTR.insertCell(-1);
            newTD.colSpan = totalCells;
            var detailsDiv = document.createElement("DIV");
            detailsDiv.id = "rowDetail" + selectedRow.id;
            newTD.appendChild(detailsDiv);
            var gridDetailBody = detailsDiv;
        }
    }
    //BUG-338624
    /* BUG-359374: Additionally check for bReadOnlyShowDetails in the case where "Show details" is configured */
    if (!strResponse.trim() && !activeGridObj.bReadOnlyShowDetails) {
        gridDetailBody.innerHTML = strResponse;
        return;
    }
    var currentScope = this;
    var callbackInterceptor = function() {
        if (activeGridObj) {
            var grid = activeGridObj;
            grid.refreshLayout = (grid.bFilteredGrid) ? true : grid.refreshLayout;
            // Set the params like TEMP_ASSIGN_REF, PRIM_PAGE to activegrid.
            var flowActionContent = pega.util.Dom.getElementsById("pyFlowActionHTML", gridDetailBody, "DIV");
            if (flowActionContent && flowActionContent.length > 0) { /* When modal dialog content gets returned */
                flowActionContent = flowActionContent[0];
                grid.propRef = flowActionContent.getAttribute("TEMP_ASSIGN_REF");
                grid.primaryPage = flowActionContent.getAttribute("PRIM_PAGE");
                grid.tempInterestPage = flowActionContent.getAttribute("TEMP_BASE_REF");
                grid.modalThreadContext = flowActionContent.getAttribute("THREAD_NAME");
                grid.gridDetailsThreadContext = grid.modalThreadContext;
                grid.isLocked = (flowActionContent.getAttribute("LOCKED") == "true");
                if (grid.isLocked) {
                    grid.DONOT_SUBMIT = "true";
                }
                //var template = (grid.editConfig==grid.EDIT_EXPANDPANE)?"pyGridRowDetails":"pyGridDetails";
                var template = grid.getFATemplateName();
                pega.u.d.attachClickForGridButtons(grid, gridDetailBody, template);
                /*HFIX-48862 - Set execution thread whenever we have deferloaded layouts in FA section*/
                if ((grid.editConfig == grid.EDIT_EXPANDPANE || grid.editConfig == grid.EDIT_HARNESS) && grid.threadProcessing) {
                    var bDeferLoadLayoutsInFA = gridDetailBody.querySelectorAll("div[data-deferinvoke]").length !=
                        0;
                    if (bDeferLoadLayoutsInFA) grid.setExecutionThread();
                }
                if (grid.editConfig == grid.EDIT_EXPANDPANE) {
                    /*Attach events to switch threads for expand pane with thread processing*/
                    if (grid.threadProcessing) {
                        grid.gridDetailsDiv = gridDetailBody;
                        if (pega.env.ua.ie) {
                            pega.util.Event.addListener(gridDetailBody, "focusin", grid.setExecutionThread, grid,
                                true);
                            pega.util.Event.addListener(gridDetailBody, "focusout", grid.resetExecutionThread,
                                grid, true);
                        } else {
                            grid.wrapperSetET = function(event) {
                                grid.setExecutionThread(event);
                            }
                            grid.wrapperReSetET = function(event) {
                                grid.resetExecutionThread(event);
                            }
                            gridDetailBody.addEventListener("focus", grid.wrapperSetET, true);
                            gridDetailBody.addEventListener("click", grid.wrapperSetET, true);
                            gridDetailBody.addEventListener("blur", grid.wrapperReSetET, true);
                        }
                        /*update the height to grid's property*/
                        grid.expDetailsHeight = gridDetailBody.offsetHeight;
                    } else {
                        /*add the height to grid's property*/
                        //grid.expDetailsHeight += gridDetailBody.offsetHeight;
                        /* BUG-141981: Invoke updateExpandedDtlsHeight() to update "expDetailsHeight" instead of direct update of value. */
                        grid.updateExpandedDtlsHeight();
                    }
                }
            } else {
                if (loadDOMReq) {
                    pega.u.d.loadHTMLEleCallback(gridDetailBody);
                }
                if (strResponse == "ERROR") {
                    grid.primaryPage = grid.propRef.substring(0, grid.propRef.indexOf('.'));
                    grid.tempInterestPage = "";
                    switch (grid.getModalAction()) {
                        case "INSERTAFTER":
                        case "INSERTBEFORE":
                        case "ADDCHILD":
                        case "APPENDLAST":
                        case "ADDFIRSTCHILD":
                            grid.setModalAction("REMOVELAST");
                            break;
                        default:
                            grid.setModalAction("ERROR");
                    }
                } else {
                    var responseArray = strResponse.split("||");
                    if (responseArray && responseArray[0] == "NO_UI") {
                        grid.NO_UI = true;
                        grid.setModalAction("SUBMIT");
                        grid.primaryPage = responseArray[1];
                        grid.tempInterestPage = responseArray[2];
                        grid.modalThreadContext = responseArray[3];
                        grid.gridDetailsThreadContext = grid.modalThreadContext;
                    } else {
                        grid.primaryPage = grid.propRef.substring(0, grid.propRef.indexOf('.'));
                        grid.tempInterestPage = "";
                        grid.setModalAction("ERROR");
                    }
                }
                grid.performModalAction();
                return;
            }
            if (grid.editConfig == grid.EDIT_EXPANDPANE) {
                grid.setHeadersWidth();
                grid.gridResized();
            }
        }
        var onlyOnceEle = pega.util.Dom.getElementsById("PegaOnlyOnce", gridDetailBody);
        if (onlyOnceEle && onlyOnceEle[0]) {
            pega.u.d.handleOnlyOnce(onlyOnceEle[0]);
            onlyOnceEle[0].parentNode.removeChild(onlyOnceEle[0]);
        }
        var errorNode = pega.util.Dom.getElementsById("ERRORTABLE", gridDetailBody);
        if (errorNode) {
            errorNode = errorNode[0];
        }
        var modalHTMLNode = pega.util.Dom.getElementsById("modaldialog_con", gridDetailBody);
        if (modalHTMLNode && modalHTMLNode[0]) {
            var childElements = pega.util.Dom.getChildren(modalHTMLNode[0]);
            var childEleLength = childElements.length;
            var childElement = null;
            for (var i = 0; i < childEleLength; i++) {
                childElement = childElements[i];
                if (childElement && childElement.id != "pyFlowActionHTML") {
                    /* modalHTMLNode[0].removeChild(childElement);  // Bug-120664 : kumad1 */
                    $(childElement).remove();
                }
            }
        }
        if (errorNode) {
            var tmpDiv = document.createElement("DIV");
            tmpDiv.appendChild(errorNode);
            pega.u.d.handleFormErrors(tmpDiv);
            tmpDiv = null;
        }
        pega.u.d.loadHTMLEleCallback(gridDetailBody);
        if (grid.editConfig == grid.EDIT_EXPANDPANE) {
            grid.autoAdjustProgressiveGridHeight({
                expandPane: "true"
            });
        }
        pega.u.d.gBusyInd.hide();
        /*BUG-107758: When bDoNotFocusFADetails=true, we don't focus the field in the FA details.*/
        if (!grid.bSelectRowOnLoad && !grid.bDoNotFocusFADetails) {
            var couldfocus = pega.u.d.focusFirstElement("pyFlowActionHTML", gridDetailBody);
            if (!couldfocus) {
                /* could not focus in the details thus the focus remains in the grid containing context;
                 * hence resetExecutionThread such that the thread context is that of the grid ;
                 */
                if (grid.threadProcessing && !bDeferLoadLayoutsInFA) {
                    grid.resetExecutionThread();
                }
            }
        } else {
            grid.bSelectRowOnLoad = false;
            if (grid.threadProcessing && !bDeferLoadLayoutsInFA) {
                grid.resetExecutionThread();
            }
        }
        if (grid.bDoNotFocusFADetails) { /*BUG-107758: When bDoNotFocusFADetails=true, we don't focus the field in the FA details. And, we focus the focusible field in the grid.*/
            grid.focusOnNewEditableRow();
        }
        if (currentScope.inCall) {
            activeGridObj.resetInCall();
        }
    }
    var callback = callbackInterceptor;
    if (loadDOMReq) {
        if (gridEditMode == "harness") {
            /*BUG-107948: By calling cleanUpHarnessElements() API, all the complex objects in grid details section are removed from memory*/
            this.cleanUpHarnessElements(null, [gridDetailBody]);
        }
        pega.u.d.loadDOMObject(gridDetailBody, strResponse, callback);
        /*BUG-201178 - For Safari Browser Reflow of gridDetailBody .This is for treegrid embedded pane */
        var navigatorUserAgent = navigator.userAgent;
        if (navigatorUserAgent.indexOf('Safari') != -1 && navigatorUserAgent.indexOf('Chrome') == -1) {
            gridDetailBody.style.height = "100%";
            gridDetailBody.style.height = "";
        }
    } else {
        callback.call();
        if (this.inCall) {
            activeGridObj.resetInCall();
        }
    }
};
pega.ui.Doc.prototype.attachClickForGridButtons = function(grid, flowActionDiv, templateName) {
    var Event = pega.util.Event;
    var $$ = pega.util.Dom.getElementsById;
    var codeCompact = function(id, fn) {
        var B = $$(id, flowActionDiv, "BUTTON");
        if (B && B.length > 0) {
            if (id == "ModalReleaseLock") {
                B = B[0];
            } else {
                var len = B.length;
                B = B[len - 1];
            }
            B.onclick = null;
            if (id == "ModalReleaseLock") {
                /* BUG-149002: Modal dialog events are fired twice in IE10 */
                Event.removeListener(B, "click", fn);
                Event.addListener(B, "click", fn, grid, true);
            } else {
                Event.removeListener(B, "click", fn);
                Event.addListener(B, "click", fn, templateName, grid, true);
                /* SE-50341: adding grid template name to submitModalDlgParam */
                if (pega.u.d.submitModalDlgParam && templateName && templateName != "") {
                    pega.u.d.submitModalDlgParam.gridTemplateName = templateName;
                }
            }
        }
    };
    codeCompact("ModalPrevious", grid.goToPrevious);
    codeCompact("ModalNext", grid.goToNext);
    codeCompact("ModalButtonSubmit", grid.submitModal);
    codeCompact("ModalButtonCancel", grid.cancelModal);
    codeCompact("ModalReleaseLock", function() {
        grid.releaseLock(grid.propRef, templateName);
    });
    /* US-58608: Adding event handler to Add to facilitate passing template name */
    codeCompact("IconAdd", grid.addRow);
};
/*
 @private Used to get offset between two elements in dom
 @return offset
*/
pega.ui.Doc.prototype.getOffSet = function(childEle, parentEle) {
    var offset = 0;
    var continueLoop = true;
    while (continueLoop) {
        offset += childEle.offsetTop;
        childEle = childEle.offsetParent;
        if (childEle == parentEle || childEle == null) {
            continueLoop = false;
        }
    }
    return offset;
};
pega.ui.Doc.prototype.modalResizeCB = function() {
    if (pega.u.d.bModalDialogOpen) {
        pega.util.Dom.addClass("modalWrapper", "resized");
    }
};
pega.ui.Doc.prototype.getComputedStyleModal = function(el, property) {
    if (el) {
        var retVal = parseInt(el.currentStyle ? el.currentStyle[property] : (getComputedStyle(el, null) ?
            getComputedStyle(el, null)[property] : 0));
        return isNaN(retVal) ? 0 : retVal;
    }
    return 0;
};
pega.ui.Doc.prototype.initModalElements = function() {
    if (pega.u.d.modalResizeObj) {
        pega.u.d.modalResizeObj.set("animate", false);
        pega.u.d.modalResizeObj.reset();
        pega.u.d.modalResizeObj.set("animate", true);
    }
    var mWrap = document.getElementById("modalWrapper");
    mWrap.style.width = "auto";
    mWrap.style.height = "auto";
    pega.util.Dom.removeClass("modalWrapper", "resized")
};
pega.ui.Doc.prototype.setModalDimensions = function() {
    if (pega.u.d.bModalDialogOpen) {
        if (!pega.util.Dom.hasClass("modalWrapper", "resized")) {
            var mOverlay = document.getElementById("modalOverlay");
            // dharj: BUG-316864 - If full screen modal take clientWidth, clientHeight of body
            var moch = pega.u.d.allowTransition() ? document.body.clientHeight : mOverlay.clientHeight;
            var mocw = pega.u.d.allowTransition() ? document.body.clientWidth : mOverlay.clientWidth;
            var modalDialogBody = document.getElementById("modalContent");
            //BUG-244529 : verifying and pick modal action section if inside modal dialog
            var modalActionParent = document.getElementById("modalOverlay") || document.getElementById("modaldialog");
            var modalDialogContent = $("#modaldialog_con", modalActionParent).get(0);
            if (modalDialogContent) {
                while (modalDialogContent.parentNode.nodeName != "DIV") {
                    modalDialogContent = modalDialogContent.parentNode;
                }
                modalDialogContent = modalDialogContent.parentNode;
            } else {
                modalDialogContent = modalDialogBody;
            }
          
            /* BUG-595475 : max-height and max-width properties needs to be set to none before calculating modalDialogBody Height, when max-height is already set to the modalContent the calculated height of modalDialogBodyHeight is the restricted height */
            if (pega.u.d.submitModalDlgParam && (!pega.u.d.submitModalDlgParam.isMobileFullScreen || pega.u.d.submitModalDlgParam.isMobileFullScreen === "false") && pega.mobile && pega.mobile.sdk) { 
                modalDialogContent.style.maxHeight = 'none';
                modalDialogContent.style.maxWidth = 'none'; 
            }
            
            // patep2: initializing with modalDialog body full height
            var modalDialogBodyHeight = modalDialogBody.scrollHeight;
            if (modalDialogBodyHeight < moch && $("html.phone")[0]) {
              moch = modalDialogBodyHeight;
            }
            var modalHeader = $("#modalContent #modaldialog_hd")[0];
            // US-270123: pzHeaderActionsModalTemplate has header class
            var newModalHeader = $("#modalContent .header")[0];
            modalHeader = modalHeader ? modalHeader : newModalHeader ? newModalHeader : null;
            var modalHeaderOffsetHeight = modalHeader ? modalHeader.offsetHeight : 0;
        
            // patep2: getting full modal header height including margin
            var modalHeaderTotalHeight = modalHeader? $(modalHeader).outerHeight(true): 0;
            if (modalHeaderTotalHeight > modalHeaderOffsetHeight) {
              modalHeaderOffsetHeight = modalHeaderTotalHeight;
            }
        
            if (pega.env.ua.ie) {
                if (modalHeader) {
                    // BUG-145147: maxWidth 0 to none
                    modalHeader.style.maxWidth = (mocw <= 0 ? "none" : mocw + "px");
                }
            }
            var scrollbarWidth = 0;
            if (!window.pud_modalScrollBarWidth) {
                if (pega.env.ua.ie == 8 || (document.documentMode && document.documentMode == 8) || pega.env.ua.gecko) {
                    var scrollDiv = document.createElement("div");
                    scrollDiv.className = "scrollbar-measure";
                    document.body.appendChild(scrollDiv);
                    scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
                    window.pud_modalScrollBarWidth = scrollbarWidth;
                    document.body.removeChild(scrollDiv);
                }
            } else {
                scrollbarWidth = window.pud_modalScrollBarWidth;
            }
            //if(pega.env.ua.ie == 8 || (document.documentMode && document.documentMode == 8) || pega.env.ua.gecko) {
            moch = moch - scrollbarWidth;
            moch = moch - pega.u.d.getComputedStyleModal(modalDialogContent, "borderTopWidth");
            moch = moch - pega.u.d.getComputedStyleModal(modalDialogContent, "borderBottomWidth");
            moch = moch - pega.u.d.getComputedStyleModal(modalDialogContent, "paddingTop");
            moch = moch - pega.u.d.getComputedStyleModal(modalDialogContent, "paddingBottom");
            moch = moch - pega.u.d.getComputedStyleModal(mOverlay, "paddingTop");
            moch = moch - pega.u.d.getComputedStyleModal(mOverlay, "paddingBottom");
            //}
            //if(pega.env.ua.ie == 8 || (document.documentMode && document.documentMode == 8) || pega.env.ua.gecko) {
            //mocw = mocw - scrollbarWidth;
            mocw = mocw - pega.u.d.getComputedStyleModal(modalDialogContent, "paddingLeft");
            mocw = mocw - pega.u.d.getComputedStyleModal(modalDialogContent, "paddingRight");
            mocw = mocw - pega.u.d.getComputedStyleModal(modalDialogContent, "borderRightWidth");
            mocw = mocw - pega.u.d.getComputedStyleModal(modalDialogContent, "borderLeftWidth");
            mocw = mocw - pega.u.d.getComputedStyleModal(mOverlay, "paddingRight");
            mocw = mocw - pega.u.d.getComputedStyleModal(mOverlay, "paddingLeft");
            //}
            if (pega.u.d.allowTransition()) { // BUG-195720 check for local-action dialogs which are only full screen bajaa
                // dharj: BUG-317937 - Checking if element exist or not before getting outerHeight
                var modalArrayButtonElement = $(modalDialogBody).find(".layout-noheader-modal_button_array")[0];
                if($(modalArrayButtonElement).is(":visible")) {
                moch -= modalArrayButtonElement ? $(modalArrayButtonElement).outerHeight() : 0;
                }
                moch -= modalHeaderOffsetHeight;
            } else {
                moch = moch - (modalDialogBody.offsetHeight - modalDialogContent.offsetHeight);
            }
            var $modalDialogContent = $(modalDialogContent);
            // BUG-145147: maxWidth & maxHeight 0 to none
            moch = moch <= 0 ? "none" : moch;
            mocw = mocw <= 0 ? "none" : mocw;
            // if max-height < min-height, then have max-height override it
            $modalDialogContent.css('min-height', ''); // reset so we're getting the stylesheet value
            var cssMinHeight = parseInt($modalDialogContent.css('min-height'));
            if (moch != 'none' && moch < cssMinHeight) {
                $modalDialogContent.css('min-height', moch);
            }
            // patep2 : get height padding/margin heights
            var modalContentExtraHeight = Math.floor($modalDialogContent.outerHeight(true) - $modalDialogContent[0].offsetHeight);
            moch = moch - modalContentExtraHeight;
            $modalDialogContent.css('max-height', moch);
            $modalDialogContent.css('max-width', mocw);
            if (modalDialogContent.children[0].getAttribute('node_name') != "pyDirtyCheckConfirm") {
                pega.util.Dom.addClass(modalDialogContent, "modal-scroll-panel");
            }
        }
      if(pega.Mashup){
         pega.u.d.modalAlignInMultiIframe({});
      }
    }
};
/*
 @public Used to size the mask on the harness
 @return $void$
*/
pega.ui.Doc.prototype.sizeHarnessMask = function() {
    if (this.cfg.getProperty("modal") && this.mask) {
        var docBody = document.body;
        var appendCSSText = [];
        var frame = window.frameElement;
        //BUG-57786 23/12/2011 KODUC setting mask height to either to offset or scrollHeight which ever is higher.
        //var docBodyScrollHeight = docBody.scrollHeight;
        var docBodyScrollHeight;
        if (docBody.offsetHeight >= docBody.scrollHeight) {
            docBodyScrollHeight = docBody.offsetHeight;
        } else {
            docBodyScrollHeight = docBody.scrollHeight;
        }
        //End of BUG-57786
        var docBodyScrollWidth = docBody.scrollWidth;
        appendCSSText.push("height: " + docBodyScrollHeight + "px;");
        if (frame) {
            appendCSSText.push("width: " + docBodyScrollWidth + "px;");
        } else {
            appendCSSText.push("width: 100%;");
        }
        this.mask.style.cssText += ";" + appendCSSText.join("");
    }
}
pega.ui.Doc.prototype.setCursorAtEndofText = function(oTextbox) {
    if (oTextbox.createTextRange) {
        var r = (oTextbox.createTextRange());
        r.moveStart('character', (oTextbox.value.length));
        r.collapse();
        r.select();
    }
};
pega.ui.Doc.prototype.checkAccessKeys = function(event) {
    if (pega.u.d.bModalDialogOpen && event.altKey && !pega.util.Dom.isAncestor(pega.u.d.modalDialog.body.id, pega.util
            .Event.getTarget(event))) {
        pega.util.Event.stopEvent(event);
        if (event.fromElement) {
            try {
                event.fromElement.focus();
                pega.u.d.setCursorAtEndofText(event.fromElement);
            } catch (event) {}
        }
    }
};
/*
 @public Used to show the Mask on the harness
 @return $void$
*/
pega.ui.Doc.prototype.showHarnessMask = function() {
    // Setting callResizeHarness to false as we do not want the resize harness callbacks to be triggered when the mask is rendering
    pega.u.d.callResizeHarness = false;
    if (this.cfg.getProperty("modal") && this.mask) {
        var docBody = document.body;
        var docBodyStyle = docBody.style;
        if (typeof(window.bodyOverflow) == "undefined" || window.bodyOverflow == "") {
            window.bodyOverflow = docBodyStyle.overflow;
        }
        if (typeof(window.bodyOverflowX) == "undefined" || window.bodyOverflowX == "") {
            window.bodyOverflowX = docBodyStyle.overflowX;
        }
        if (typeof(window.bodyOverflowY) == "undefined" || window.bodyOverflowY == "") {
            window.bodyOverflowY = docBodyStyle.overflowY;
        }
        if (pega.env.ua.ie == 6) {
            pega.util.Dom.addClass(document.body, "masked");
        }
        pega.u.d.sizeHarnessMask.call(this);
        this.mask.style.display = "block";
        this.showMaskEvent.fire();
    }
    pega.u.d.callResizeHarness = true;
};
/*
 @public Used to hide the Mask on the harness
 @return $void$
*/
pega.ui.Doc.prototype.hideHarnessMask = function() {
    if (this.cfg.getProperty("modal") && this.mask) {
        this.mask.style.display = "none";
        var docBody = document.body;
        var docBodyStyle = docBody.style;
        if (docBodyStyle.overflow != bodyOverflow) {
            docBodyStyle.overflow = (bodyOverflow === "") ? "" : bodyOverflow;
            bodyOverflow = "";
        }
        if (docBodyStyle.overflowX != bodyOverflowX) {
            docBodyStyle.overflowX = (bodyOverflowX === "") ? "" : bodyOverflowX;
            bodyOverflowX = "";
        }
        if (docBodyStyle.overflowY != bodyOverflowY) {
            docBodyStyle.overflowY = (bodyOverflowY === "") ? "" : bodyOverflowY;
            bodyOverflowY = "";
        }
        this.hideMaskEvent.fire();
        if (pega.env.ua.ie == 6) {
            pega.util.Dom.removeClass(document.body, "masked");
        }
    }
};
/*
 @public Failure Callback api for ProcessActionModal function
 @Handler
 @param $Object$oResponse contains theresponse
 @return $void$
*/
pega.ui.Doc.prototype.processActionModal_Failure = function(oResponse) {
    //handle an unsuccessful request
    pega.u.d.gBusyInd.hide();
    if (pega.u.d.ServerProxy.isDestinationLocal()) {
        var taskStatus = pega.u.d.submitModalDlgParam.taskStatus;
        //This hardcoded string should be replaced with a proper PRPC type
        pega.mobile.hybrid.callWhenLaunchboxLoaded(function() {
            var launchBox = pega.mobile.hybrid.getLaunchBox();
            if (launchBox.PRPC && launchBox.PRPC.ClientStore) {
                launchBox.PRPC.ClientStore.getItems("localaction", taskStatus, pega.u.d.offlineModalSuccessCallback,
                    pega.u.d.offlineModalFailCallback);
            }
        });
    }
};
/*
 @private Used to set the Modal dialog Height.It will be called by resizeModalDialog api
 @Handler
 @param $Obj$modalDialogBody Modal dialog body div object
 @param $Obj$dimensionObj - Contains the width and height dimensions
*/
pega.ui.Doc.prototype.setModalDialogHeight = function(modalDialogBody, actionIframeSec, dimensionObj) {
    var scrollTop = 0;
    if (!pega.u.d.useOldModalDialog) return;
    var modalDialogBodySH = modalDialogBodySHNonIe = 0;
    if (pega.util.Event.isIE) {
        modalDialogBodySH = pega.u.d.getDivScrollHeight(modalDialogBody, false);
    } else {
        // BUG-75741: In firefox modaldialog is not resized properly when there is decrease in content height.
        //modalDialogBodySH = pega.u.d.getDivScrollHeight(document.getElementById("modaldialog_bd"),false);
        scrollTop = modalDialogBody.scrollTop;
        modalDialogBody.style.height = "auto";
        modalDialogBodySH = modalDialogBodySHNonIe = pega.u.d.getDivScrollHeight(modalDialogBody, false);
    }
    if (pega.u.d.MODALDIALOG_MIN_HEIGHT < parseInt(modalDialogBodySH)) {
        pega.u.d.MODALDIALOG_MIN_HEIGHT = parseInt(modalDialogBodySH);
    }
    var contentHieght = dimensionObj.height;
    var wagIframeEle = null;
    var isPortal = false;
    var panelDiv = null;
    var portalHarnessBody = null;
    var isActionIframe = (window.frames.name == "actionIFrame");
    if (isActionIframe) {
        wagIframeEle = window.parent.frameElement;
        if (wagIframeEle != null && typeof(wagIframeEle.PegaWebGadget) != "undefined" && typeof(window.parent.parent
                .pega) != "undefined" && typeof(window.parent.parent.pega.u) != "undefined" && typeof(window.parent.parent
                .pega.u.d) != "undefined" && window.parent.parent.pega.u.d.isPortal()) {
            isPortal = true;
            panelDiv = parent.pega.u.d.getPanelDiv();
            portalHarnessBody = parent.parent.document.body;
        }
    } else {
        wagIframeEle = window.frameElement;
        if (wagIframeEle != null && typeof(wagIframeEle.PegaWebGadget) != "undefined" && typeof(window.parent.pega) !=
            "undefined" && typeof(window.parent.pega.u) != "undefined" && typeof(window.parent.pega.u.d) !=
            "undefined" && window.parent.pega.u.d.isPortal()) {
            isPortal = true;
            panelDiv = pega.u.d.getPanelDiv();
        }
    }
    if (isPortal && panelDiv) {
        var offset = 0;
        if (isActionIframe) {
            offset = pega.u.d.getOffSet(window.frameElement, window.parent.frameElement.contentWindow.document.body) +
                pega.u.d.getOffSet(wagIframeEle, portalHarnessBody) - pega.u.d.getOffSet(panelDiv, portalHarnessBody);
        } else {
            offset = pega.u.d.getOffSet(window.frameElement, panelDiv.parentNode);
        }
        var panelParentNode = panelDiv.parentNode;
        var panelScrollTop = panelParentNode.scrollTop;
        var panelOffSetHt = panelParentNode.offsetHeight;
        var docOffSetHt = document.body.offsetHeight;
        if (panelParentNode.scrollTop - offset > 0) {
            contentHieght = panelOffSetHt;
        } else {
            contentHieght = panelOffSetHt - (offset - panelScrollTop);
        }
        if ((docOffSetHt - panelScrollTop - offset) < (panelOffSetHt - offset)) {
            contentHieght = docOffSetHt - panelScrollTop - offset;
        }
    }
    if (contentHieght > pega.u.d.MODALDIALOG_ADJUSTMENT) {
        contentHieght = contentHieght - pega.u.d.MODALDIALOG_ADJUSTMENT;
    }
    var styleCssText = "",
        headerHeight = 0,
        footerHeight = 0;
    if (pega.u.d.MODALDIALOG_BUTTONS_HEIGHT == 0) {
        var sectionTable = pega.util.Dom.getElementsById("EXPAND-OUTERFRAME", document.getElementById(
            "modaldialog_bd"), "TABLE");
        if (sectionTable != null && sectionTable.length > 0) {
            sectionTable = sectionTable[0];
            var buttonsTable = sectionTable.nextSibling;
            if (buttonsTable != null) {
                while (buttonsTable.nodeType != 1) {
                    buttonsTable = buttonsTable.nextSibling;
                    if (buttonsTable == null) break;
                }
                if (buttonsTable != null) {
                    pega.u.d.MODALDIALOG_BUTTONS_HEIGHT = buttonsTable.offsetHeight;
                }
            }
        }
    }
    //BUG-58465 1/4/2012 koduc if condition is commented because modaldialog_bd height must be set to auto in all browsers if not rezise icon will not be visible.
    // This change is no longer needed for 7.1 after implementing the support for custom width and height modal window size - the style is set to auto in the skin for "modaldialog .bd" is the width is set to auto
    // otherwise it is set to the actual width
    //if(pega.util.Event.isIE) {
    //document.getElementById("modaldialog_bd").style.height = "auto";
    //}
    //End of BUG-58465
    if (document.getElementById("modaldialog_hd") != null) {
        headerHeight = document.getElementById("modaldialog_hd").offsetHeight;
    }
    if (document.getElementById("modaldialog_ft") != null) {
        footerHeight = document.getElementById("modaldialog_ft").offsetHeight;
    }
    // BUG-75718: In IAC when modaldialog is loaded at the bottom and dialog content height is increased scrollbars are not coming for dialog.
    var modalContainerTop = 0;
    if (pega.u.d.modalDialog.cfg.getProperty("fixedcenter") === false) {
        var modalContainer = this.modalDialog ? this.modalDialog.element : null;
        modalContainerTop = modalContainer ? modalContainer.offsetTop : 0;
    }
    if ((modalDialogBodySH + headerHeight + pega.u.d.MODALDIALOG_BUTTONS_HEIGHT + footerHeight + modalContainerTop) >
        contentHieght && !actionIframeSec) {
        modalDialogBody.style.height = contentHieght - headerHeight - pega.u.d.MODALDIALOG_BUTTONS_HEIGHT -
            modalContainerTop + 'px';
        pega.u.d.MODALDIALOG_MIN_HEIGHT = contentHieght - headerHeight - pega.u.d.MODALDIALOG_BUTTONS_HEIGHT -
            modalContainerTop;
        /* add scollbar adjustment to width. else we get an unnecessary horizontal scrollbar*/
        // reset modaldialog height - BUG-161850 - HFix-9710 
        document.getElementById('modaldialog').style.height = contentHieght + footerHeight + 'px';
        if (modalDialogBody.style.overflow != "auto") {
            var borderWidth = parseInt(window.getComputedStyle ? (window.getComputedStyle(modalDialogBody, null)[
                "borderLeftWidth"] || modalDialogBody.style.overflow) : (modalDialogBody.currentStyle ?
                modalDialogBody.currentStyle["borderLeftWidth"] : modalDialogBody.style.borderLeftWidth || 0
            )) + parseInt(window.getComputedStyle ? (window.getComputedStyle(modalDialogBody, null)[
                "borderRightWidth"] || modalDialogBody.style.overflow) : (modalDialogBody.currentStyle ?
                modalDialogBody.currentStyle["borderRightWidth"] : modalDialogBody.style.borderRightWidth ||
                0));
            borderWidth = isNaN(borderWidth) ? 0 : borderWidth;
            document.getElementById("modaldialog").style.width = parseInt(modalDialogBody.scrollWidth) + pega.u.d.SCROLL_ADJUSTMENT +
                borderWidth + 'px';
        }
        styleCssText += "overflow: auto;";
    } else {
        var styleCssText = "";
        if (parseInt(modalDialogBodySH) > pega.u.d.MODALDIALOG_MIN_HEIGHT && (pega.u.d.modalTabContentWidth != 0)) {
            var height = pega.u.d.MODALDIALOG_MIN_HEIGHT + pega.u.d.SCROLL_ADJUSTMENT;
            styleCssText += "height: " + height + "px;";
        } else {
            if (pega.util.Event.isIE) {
                var height = modalDialogBodySH;
                /*BUG-190270: Check whether scrollWidth is greater than offsetWidth, then only add the scroll adjustment.*/
                if (modalDialogBody.scrollWidth > modalDialogBody.offsetWidth) {
                    height = height + pega.u.d.SCROLL_ADJUSTMENT;
                }
            } else {
                var height = modalDialogBodySHNonIe;
                if (modalDialogBody.scrollWidth > modalDialogBody.offsetWidth) {
                    height = height + pega.u.d.SCROLL_ADJUSTMENT;
                }
            }
            styleCssText += "height: " + height + "px;";
        }
        if (modalDialogBody.style.overflow != "") {
            pega.u.d.modalDialog.cfg.setProperty("height", "");
            styleCssText += "overflow:auto;";
        }
    }
    // Change is no longer needed after adding support for custom width and height for the modal window
    //if(pega.util.Event.isIE) {
    //  document.getElementById("modaldialog_bd").style.height = "auto";
    //}
    modalDialogBody.style.cssText += ";" + styleCssText;
    if (scrollTop) { /* BUG-275647: SE-30537: Assign scroll top only when it is greater than 0. */
        modalDialogBody.scrollTop = scrollTop;
    }
};
/*
 @private Used to set the Modal dialog Width.It will be called by resizeModalDialog api
 @Handler
 @param $Obj$modalDialogBody Modal dialog body div object
 @param $Obj$dimensionObj - Contains the width and height dimensions
*/
pega.ui.Doc.prototype.setModalDialogWidth = function(modalDialogBody, actionIframeSec, dimensionObj) {
    if (!pega.u.d.useOldModalDialog) return;
    var contentWidth = dimensionObj.width;
    var modalTabWidth = 0;
    var adjustment = 2,
        borderAdjustment = 16;
    if (pega.u.d.modalTabContentWidth != 0) {
        modalDialogBody.style.width = pega.u.d.MODALDIALOG_MAX_WIDTH + 'px';
        if (pega.u.d.modalTabElementsWidth > pega.u.d.modalTabContentWidth) {
            modalTabWidth = pega.u.d.modalTabElementsWidth;
        } else {
            modalTabWidth = pega.u.d.modalTabContentWidth;
        }
        if (modalDialogBody.scrollWidth > modalTabWidth) {
            /* When modal dialog contains tabs, on dynamically loading the content, modal dialog was increasing the width continuously. Added this condition to fix that.*/
            if ((modalDialogBody.scrollWidth - parseInt(modalDialogBody.style.width)) > pega.u.d.SCROLL_ADJUSTMENT) {
                modalTabWidth = modalDialogBody.scrollWidth;
            }
        }
        if (modalTabWidth > pega.u.d.MODALDIALOG_MAX_WIDTH) {
            pega.u.d.MODALDIALOG_MAX_WIDTH = modalTabWidth;
        } else {
            modalTabWidth = pega.u.d.MODALDIALOG_MAX_WIDTH;
        }
    }
    document.getElementById("modaldialog_bd").style.overflowX = "visible";
    if (contentWidth > pega.u.d.MODALDIALOG_ADJUSTMENT) {
        contentWidth = contentWidth - pega.u.d.MODALDIALOG_ADJUSTMENT;
    }
    if (modalDialogBody.scrollWidth > contentWidth) {
        pega.u.d.MODALDIALOG_MAX_WIDTH = contentWidth;
        modalDialogBody.style.width = (contentWidth - adjustment) + 'px';
        document.getElementById("modaldialog").style.width = contentWidth + 'px';
    } else if (modalTabWidth != 0) {
        if (pega.u.d.bIsModelessDialog) {
            /* 30/11/2011 GADES BUG-54913  scroll bars in specification modal from Discovery map
               Commented the following code as modalTabWidth is not calculated properly. */
            //modalDialogBody.style.width = modalTabWidth + 'px';
            modalDialogBody.style.width = "";
            var modalBodySW = document.getElementById("modaldialog_bd").scrollWidth;
            if (modalBodySW >= modalTabWidth) {
                modalDialogBody.style.width = modalBodySW;
            } else {
                modalDialogBody.style.width = (modalTabWidth + pega.u.d.SCROLL_ADJUSTMENT - adjustment) + 'px';
            }
        } else {
            modalDialogBody.style.width = "100%";
        }
        /*RTE always sets 800px as width for modal dialog div. Because of which modal dialog was increasing width continuously. Added this condition to fix this. Need to refactor this logic*/
        /* BUG-45642 Scrollbar issues in use case modal in 1024x768, to fix this issue added width as 100% and removed addition of scroll adjustment, replaced boxSizing to avoid this*/
        if (document.getElementById("modaldialog").style.width == "" || (modalTabWidth > parseInt(document.getElementById(
                    "modaldialog").style.width) && parseInt(document.getElementById("modaldialog").style.width) !=
                800)) {
            /* 07/22/2011 GUJAS1 BUG-47685 Toggle the Close button visibility to force correct rendering in IE. { */
            var closeButton = document.getElementById("container_close");
            if (closeButton) {
                var closeButtonStyle = closeButton.style;
                document.getElementById("container_close").style.visibility = "hidden";
            }
            /* 07/22/2011 GUJAS1 BUG-47685 Toggle the Close button visibility to force correct rendering in IE. } */
            document.getElementById("modaldialog").style.width = modalTabWidth + pega.u.d.SCROLL_ADJUSTMENT + 'px';
            if (!pega.u.d.bIsModelessDialog) {
                document.getElementById("modaldialog").style.boxSizing = "border-box";
            }
            /* 07/22/2011 GUJAS1 BUG-47685 Toggle the Close button visibility to force correct rendering in IE. { */
            if (closeButton) {
                closeButtonStyle.visibility = "visible";
            }
            /* 07/22/2011 GUJAS1 BUG-47685 Toggle the Close button visibility to force correct rendering in IE. } */
        }
    } /*In IE8, the scrollWidth of modaldialog returns wrongly, hence use offsetWidth*/
    else if (document.getElementById("modaldialog_bd").scrollWidth > document.getElementById("modaldialog").offsetWidth &&
        document.getElementById("modaldialog_bd").scrollWidth > ((pega.env.ua.ie == 8) ? document.getElementById(
            "modaldialog").offsetWidth : document.getElementById("modaldialog").scrollWidth)) {
        document.getElementById("modaldialog").style.width = (document.getElementById("modaldialog_bd").scrollWidth +
            adjustment) + 'px';
    }
    if (parseInt(modalDialogBody.scrollWidth) < pega.u.d.MODALDIALOG_MIN_WIDTH || (modalTabWidth != 0 &&
            modalTabWidth < pega.u.d.MODALDIALOG_MIN_WIDTH)) {
        document.getElementById("modaldialog_bd").style.width = (pega.u.d.MODALDIALOG_MIN_WIDTH - adjustment) + 'px';
        document.getElementById("modaldialog").style.width = (pega.u.d.MODALDIALOG_MIN_WIDTH + borderAdjustment) +
            'px';
    }
};
/*
 @private Used to set the Modal dialog resize Handler.It will be called by modaldialoginit api
 @Handler
*/
pega.ui.Doc.prototype.setModalDialogResizeHandle = function() {
    var modalDialogFt = document.getElementById("modaldialog_ft");
    var modalDialogResizeDiv = document.getElementById("modaldialog_r");
    if (modalDialogFt && modalDialogResizeDiv) {
        var childNodesLen = modalDialogFt.childNodes.length;
        var resizeHandle = false;
        if (childNodesLen != 0) {
            for (var i = 0; i < childNodesLen; i++) {
                if (modalDialogFt.childNodes[i].id == "modaldialog_r") {
                    resizeHandle = true;
                    break;
                }
            }
        }
        if (!resizeHandle) {
            modalDialogFt.appendChild(modalDialogResizeDiv);
        }
    }
};
/*
 @public Used to resize the Modal dialog.
 @Handler
*/
pega.ui.Doc.prototype.resizeModalDialog = function() {
    var isInstancePresentInCurrentModal = false;
    /*SE-27331 (BUG-246609) fix start*/
    if (window.CKEDITOR) {
        for (var ck_instance in window.CKEDITOR.instances) {
            if ($("#cke_" + ck_instance).find('.cke_inner').hasClass('cke_maximized')) {
                if ($("#PEGA_HARNESS").find("#cke_" + ck_instance).length > 0) {
                    isInstancePresentInCurrentModal = true;
                }
            }
        }
    }
    /*SE-27331 (BUG-246609) fix end*/
    if ((pega.u.d.useOldModalDialog && pega.u.d.bModalDialogOpen && isInstancePresentInCurrentModal)) {
        return;
    }
    try {
        var modalEl = document.getElementById("modalContent");
        pega.util.Event.removeListener(modalEl, "keydown", pega.u.d.restrictFocus);
        var firstBoundary = pega.u.d.getFirstFocusableElement('modalContent');
        var lastBoundary = pega.u.d.getLastFocusableElement('modalContent');
        pega.util.Event.addListener(modalEl, "keydown", pega.u.d.restrictFocus, [firstBoundary, lastBoundary]);
    } catch (e) {}
    if (!pega.u.d.useOldModalDialog) return;
    //BUG-76499 @cherj, setting modaldialog height to auto before resizing the modaldialog content. Added the following if block.
    if (document.getElementById("modaldialog")) {
        document.getElementById("modaldialog").style.height = 'auto';
    }
    var modalDialogBody = document.getElementById("modaldialog_bd");
    var modalDialogContent = $("#modaldialog_con", document.getElementById("modaldialog")).get(0);
    if (modalDialogContent) {
        while (modalDialogContent.parentNode.nodeName != "DIV") {
            modalDialogContent = modalDialogContent.parentNode;
        }
        modalDialogContent = modalDialogContent.parentNode;
    } else {
        modalDialogContent = modalDialogBody;
    }
    var dimensionObj = null;
    var frameFound = false;
    try {
        if (window.frameElement != null && typeof(window.frameElement.PegaWebGadget) != "undefined") {
            dimensionObj = {
                height: (window.frameElement.style.height != "" ? window.frameElement.style.height : window.frameElement
                    .height),
                width: (window.frameElement.style.width != "" ? window.frameElement.style.width : window.frameElement
                    .width)
            };
            if (dimensionObj.height.indexOf("%") > 0 || dimensionObj.width.indexOf("%")) {
                frameFound = false;
            } else {
                dimensionObj.height = parseInt(dimensionObj.height);
                dimensionObj.width = parseInt(dimensionObj.width);
                frameFound = true;
            }
        }
    } catch (ex) {}
    if (!frameFound) {
        var height = 0;
        var hbDiv = document.getElementById("HARNESS_BUTTONS");
        if (!hbDiv) {
            if (pega.util.Event.isIE || pega.util.Event.isSafari) {
                height = document.body.offsetHeight;
            } else {
                /*FF is not giving offsetHeight properly*/
                height = document.body.clientHeight;
            }
        } else {
            height = pega.u.d.getDocumentHeight();
        }
        dimensionObj = {
            height: height,
            width: document.body.offsetWidth
        };
    }
    var actionIframe = window.parent.frames.actionIFrame;
    var actionIframeSec = false;
    if (typeof(actionIframe) != "undefined") {
        pega.u.d.resizeActionIFrame(false);
        actionIframeSec = true;
    }
    if (dimensionObj.height) pega.u.d.setModalDialogHeight(modalDialogContent, actionIframeSec, dimensionObj);
    if (dimensionObj.width) pega.u.d.setModalDialogWidth(modalDialogContent, actionIframeSec, dimensionObj);
    /* Fix for BUG-43752, BUG-47692, and BUG-47875 - START */
    if (modalDialogContent) {
        modalDialogContent.style.position = 'relative';
        if (pega.util.Event.isIE) { /* BUG-70719 overflow auto causing the unnecessary scroll bar in crome*/
            modalDialogContent.style.overflow = 'auto';
        } /* Fix for BUG-62064 content should have overflow:auto to have scrollbar within content. */
    }
    /* Fix for BUG-43752, BUG-47692, and BUG-47875 - END */
    /* BUG-50333 Modal dialog needs to be recentered after resize if it has fixed center. */
    if (pega.u.d.modalDialog.cfg.getProperty("fixedcenter") === true) {
        pega.u.d.modalDialog.center();
    }
    // BUG-81883 : JALDS, when it is being set to 100%(default), the modaldialogbody occupies the whole modaldialog and there by pushing the footer beyond the visible viewport.
    modalDialogBody.style.height = "auto";
    pega.u.d._resizeModalDialogComponents();
};
/*
 @private resizeModalDialogComponents is used to resize the components inside modal dialog
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype._resizeModalDialogComponents = function() {
        /* Resizes Tab Scroller when modaldialog resizes */
        var modalTabViewId, modalTabViewMap = pega.u.d.modalTabViewMap;
        if (modalTabViewMap) {
            for (modalTabViewId in modalTabViewMap) {
                modalTabViewMap[modalTabViewId].resizeTabsScroll();
            }
        }
    }
    /*
     @public modalDialogExtras is used to set the styles to the modal dialog header
     @Handler
     @return $void$
    */
pega.ui.Doc.prototype.modalDialogExtras = function(modalWindowSize) {
    if (pega.u.d.useOldModalDialog) {
        var modalDialogHeader = pega.u.d.modalDialog.header;
        var modalDialogBody = pega.u.d.modalDialog.body;
        var handleNode = null;
        /* modalDialogBody.style.padding = '0px'; */
        if (!pega.u.d.usesModalTemplate) {
            handleNode = modalDialogHeader;
        } else {
            var outerframe = pega.util.Dom.getElementsById("EXPAND-OUTERFRAME", modalDialogBody);
            if (outerframe && outerframe.length > 0) {
                var outerFrameCell = null;
                if (outerframe[0].rows && outerframe[0].rows.length > 0) {
                    var outerFrameRow = outerframe[0].rows[0];
                    if (outerFrameRow && outerFrameRow.cells && outerFrameRow.cells.length > 0) outerFrameCell =
                        outerFrameRow.cells[0];
                }
                if (outerFrameCell == null) return;
                var childNodes = pega.util.Dom.getChildren(outerFrameCell);
                /*when layout has header and body*/
                if (childNodes && childNodes.length == 2) {
                    handleNode = childNodes[0]; /*header*/
                    if (handleNode.id == 'RULE_KEY') {
                        while (handleNode.tagName != "TD") {
                            handleNode = pega.util.Dom.getFirstChild(handleNode);
                        }
                        handleNode = pega.util.Dom.getNextSibling(handleNode);
                    }
                }
            }
        }
        if (handleNode) {
            if (pega.u.d.modalDialog.ddDragdrop) {
                pega.u.d.modalDialog.ddDragdrop.setHandleElId(handleNode);
            }
            pega.util.Dom.setStyle(handleNode, 'cursor', 'move');
        }
    }
    /*Add a listener to listen for TAB and restrict the focus within the modal dialog.*/
    var firstBoundary = pega.u.d.getFirstFocusableElement(pega.u.d.modalDialog.innerElement.id);
    var lastBoundary = pega.u.d.getLastFocusableElement(pega.u.d.modalDialog.innerElement.id);
    pega.util.Event.addListener(pega.u.d.modalDialog.innerElement, "keydown", pega.u.d.restrictFocus, [firstBoundary,
        lastBoundary]);
    if (!pega.u.d.useOldModalDialog) {
        pega.u.d.initModalElements();
        var modalDialogBody = document.getElementById("modalContent");
        var modalDialogContent = document.getElementById("modaldialog_con");
        if (modalDialogContent) {
            while (modalDialogContent.parentNode.nodeName != "DIV") {
                modalDialogContent = modalDialogContent.parentNode;
            }
            modalDialogContent = modalDialogContent.parentNode;
        } else {
            modalDialogContent = modalDialogBody;
        }
        var height = "auto";
        var width = "auto";
        if (modalWindowSize) {
            var windowSettings = modalWindowSize.split(",");
            height = windowSettings[0];
            width = windowSettings[1];
        }
        if (pega.u.d.modalResizeObj) {
            pega.u.d.modalResizeObj.destroy();
            pega.u.d.modalResizeObj = null;
        }
        // HFIX-42554 Call model resize only for desktop
        if (!pega.mobile.isHybrid) {
            pega.u.d.modalResizeObj = new pega.util.Resize(modalDialogContent, {
                proxy: true,
                handles: "br",
                minHeight: 100,
                minWidth: 200,
                height: height,
                width: width,
                draggable: false
            });
            pega.u.d.modalResizeObj.on("resize", pega.u.d.modalResizeCB);
        }
    }
};
/*
 @public handleModaldlgKeyPress is used to handle keypress events in modal dialog
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.handleModaldlgKeyPress = function(event) {
    if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.bIsOverlay === "true") return;
    if (pega.u.d.bModalDialogOpen) {
        var modaldialog = pega.u.d.modalDialog.innerElement;
        var srcObj = pega.util.Event.getTarget(event);
        var elemTagName = srcObj.tagName.toUpperCase();
        switch (event.keyCode) {
            case 13:
                /* If the ENTER key is pressed */ var controlType = null;
                if (srcObj.type) {
                    controlType = srcObj.type.toUpperCase();
                }
                /*BUG-201880: Skip submitting for icon also.*/
                if (controlType == null && srcObj.getAttribute("data-ctl")) {
                    controlType = srcObj.getAttribute("data-ctl").toUpperCase();
                }
                if (elemTagName == 'TEXTAREA' || elemTagName == 'A' || elemTagName == 'SELECT' || elemTagName ==
                    'BUTTON' || controlType == 'BUTTON' || controlType == 'SUBMIT' || controlType == 'ICON' ||
                    srcObj.id == 'ModalButtonSubmit' || srcObj.id == 'ModalButtonCancel' || typeof(srcObj.AutoComplete) !=
                    "undefined" || srcObj.getAttribute("data-ctl") == '["AutoCompleteAG"]') {
                    pega.util.Event.stopPropagation(event);
                    return;
                }
                /*BUG-360345 - Avoid modal submit if focus is on actionable element, Adding a check for the element who has on-
                click handler on it. INfeature we can add more checks for other handlers.*/
                if (event.target.getAttribute("onClick") != '') {
                    pega.util.Event.stopPropagation(event);
                    return;
                }
                var buttonObj = pega.util.Dom.getElementsById("ModalButtonSubmit", modaldialog);
                if (buttonObj && buttonObj.length > 0) {
                    pega.util.Event.fireEvent(buttonObj[0], 'click');
                    pega.util.Event.stopPropagation(event);
                    pega.util.Event.preventDefault(event);
                }
                break;
            case 27:
                /* If the ESC key is pressed */ pega.u.d.handleModalCancel(event);
            case 38:
            case 40: // up and down arrow
                // Bug-144335
                /*if (navigator.userAgent.indexOf('Firefox/') >= 0)
                    pega.util.Event.stopEvent(event);*/
                break;
        }
    }
};
pega.ui.Doc.prototype.handleModalCancel = function(event) {
        if (pega.u.d != null && pega.u.d.bIsFlowInModal == true) {
            pega.u.d.launchFlow.handleModalCancel();
        } else {
          var buttonObj = pega.util.Dom.getElementsById("ModalButtonCancel", pega.u.d.modalDialog.innerElement);
            if (buttonObj && buttonObj.length > 0) {
              pega.util.Event.fireEvent(buttonObj[0], 'click');
              return;
            } 
          doModalAction('', event);
          
        }
    }
    /*
     @public AttachModalBtnListeners is used to attach the listeners on the Modal Dialog default buttons
     @Handler
     @param $Object$modalDialogBtnObj contains the api names that are to be fired for the buttons .
     @param $Object$paramObj Containes the parameters that are to be passed
     @return $void$
    */
pega.ui.Doc.prototype.attachModalBtnListeners = function(modalDialogBtnObj, paramObj) {
    pega.u.d.removeModalBtnListeners(paramObj.parentDiv);
    var submitButton = pega.util.Dom.getElementsById("ModalButtonSubmit", paramObj.parentDiv);
    var cancelButton = pega.util.Dom.getElementsById("ModalButtonCancel", paramObj.parentDiv);
    if (submitButton && submitButton.length > 0) {
        pega.util.Event.addListener(submitButton[0], "click", modalDialogBtnObj.submitClickApi, paramObj, this);
    }
    if (cancelButton && cancelButton.length > 0) {
        pega.util.Event.addListener(cancelButton[0], "click", modalDialogBtnObj.cancelClickApi, paramObj, this);
    }
};

pega.ui.Doc.prototype.addMouseDownEvent = function(closeButton) {
        pega.util.Event.addListener(closeButton, 'mousedown', function(event) {
            pega.u.d.handleModalCancel(event);
        });
    }
    /*
     @public AttachCloseBtnListeners is used to attach the listeners on the Modal Dialog close buttons
     @Handler
     @param $Object$closeBtnObj contains the api names that are to be fired for the close button .
     @param $Object$paramObj Containes the parameters that are to be passed
     @param $boolean$bIsFlowActionModal  Used to know if it is FlowAction
     @return $void$
    */
pega.ui.Doc.prototype.attachCloseBtnListeners = function(closeBtnObj, paramObj) {
    var modalContent = document.querySelector("#modalContent");
    var closeButton = modalContent.querySelector("#container_close");
    if (closeButton) {
        pega.util.Event.removeListener(closeButton, 'mousedown');
        pega.util.Event.removeListener(closeButton, 'click', closeBtnObj.closeBtnApi);
        if (closeBtnObj.closeBtnApi != "") {
            pega.util.Event.addListener(closeButton, "click", closeBtnObj.closeBtnApi, paramObj, this);
            if (pega.u.d != null && pega.u.d.bIsFlowInModal == true) {
                pega.u.d.addMouseDownEvent(closeButton);
            } else {
                pega.util.Event.addListener(closeButton, 'mousedown', closeBtnObj.closeBtnApi, paramObj, this);
            }
        } else {
            pega.util.Event.addListener(closeButton, "click", pega.u.d.hideModalWindow);
            pega.u.d.addMouseDownEvent(closeButton);
        }
    }
};
/*
 @public RemoveModalBtnListeners is used to remove the listeners on the Modal Dialog default buttons
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.removeModalBtnListeners = function(btnContentDiv) {
    var submitButton = pega.util.Dom.getElementsById("ModalButtonSubmit", btnContentDiv);
    var cancelButton = pega.util.Dom.getElementsById("ModalButtonCancel", btnContentDiv);
    if (submitButton && submitButton.length > 0) {
        pega.util.Event.removeListener(submitButton[0], 'click', pega.u.d.submitSection);
    }
    if (cancelButton && cancelButton.length > 0) {
        pega.util.Event.removeListener(cancelButton[0], 'click', pega.u.d.cancelSection);
    }
};
/*
 @public closeChildOverLay is used to check if an over lay is opened
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.closeChildOverLay = function(event) {
    var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
    /* BUG-263125 */
    var modalDialogContainer = $("#modalContent")[0];
    var popOverLaunchingElement = popOver.getAssociatedElement();
    var popOverLaunchedFromModalDialog = false;
    if (modalDialogContainer && ($(modalDialogContainer).find(popOverLaunchingElement).length || (
            popOverLaunchingElement && popOverLaunchingElement.name && $(modalDialogContainer).find($("[name='" +
                popOverLaunchingElement.name + "']")).length))) {
        popOverLaunchedFromModalDialog = true;
        var smartInfoCloseIconSpan = $("#SinfoCloseIcon")[0];
        if (smartInfoCloseIconSpan) smartInfoCloseIconSpan.removeAttribute("clickableSmartInfo");
    } else if (modalDialogContainer && popOverLaunchingElement && popOverLaunchingElement.name && $("[name='" +
            popOverLaunchingElement.name + "']").length == 0) {
        /* BUG-284265: When section containing popOverLaunchingElement got refreshed and
           popOverLaunchingElement not rendered after refresh, above if condition fails */
        popOverLaunchedFromModalDialog = true;
    }
    pega.u.d.bCallModalClose = false;
    if (popOver && popOverLaunchedFromModalDialog) {
        if (popOver.getState() === "closing") return false;
        var popOverContainerElem = popOver.getContentContainerElement();
        if (popOverContainerElem != null && popOverContainerElem.style.visibility != "hidden") {
            pega.u.d.modalBtnElem = pega.util.Event.getTarget(event);
            pega.u.d.bCallModalClose = true;
            popOver.close();
            return true;
        }
    }
    return false;
};
/*
 @public doModalAction is used to perform action when buttons on modal are clicked on modal dialog
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.doModalAction = function(submitModalDlgParam, event) {
    var bchildOverlayOpen = pega.u.d.closeChildOverLay(event);
    if (bchildOverlayOpen) {
        return;
    }
    var actionName = "";
    if (submitModalDlgParam) {
        actionName = submitModalDlgParam.taskStatus;
        pega.u.d.performFlowAction(actionName, event);
    } else {
        var tempActionName = "";
        if (pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.taskStatus != "") {
            tempActionName = pega.u.d.submitModalDlgParam.taskStatus;
        }
        pega.u.d.performFlowAction(actionName, event, "", tempActionName);
    }
};
/*
 @public doOverlayAction is used to perform action when buttons on overlay are clicked
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.doOverlayAction = function(submitModalDlgParam, event) {
    //alert("in overlay");
    var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
    if (submitModalDlgParam) {
        pega.u.d.actionName = submitModalDlgParam.taskStatus;
        pega.u.d.performFlowAction(submitModalDlgParam.taskStatus, event, "", "", popOver.getContentContainerElement());
    } else {
        popOver.close();
    }
};
/*
 @public addModalHeader is used to add header when pyModalTemplate is not used
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.addModalHeader = function() {
    if (!document.getElementById("modaldialog_hd")) {
        var hDiv = document.createElement('div');
        hDiv.setAttribute('id', 'modaldialog_hd');
        hDiv.setAttribute('customHeader', 'true');
        //BUG-117427 Removed for header height issue  --DeltaTouch
        //pega.util.Dom.setStyle(hDiv,"height","20px");
        var bDiv = pega.u.d.modalDialog.body;
        pega.util.Dom.insertBefore(hDiv, bDiv);
        if (pega.u.d.modalDialog.ddDragdrop) {
            pega.u.d.modalDialog.ddDragdrop.setHandleElId(hDiv);
            pega.util.Dom.setStyle(hDiv, 'cursor', 'move');
            pega.u.d.modalDialog.cfg.setProperty('close', true);
        }
        pega.util.Dom.addClass('modaldialog_hd', 'hd');
        pega.u.d.modalDialog.header = hDiv;
    }
};
/*
 @author sings9
 @public getOfflineMetaDataForModal is used to get the value of the data-json attirbute from the
        metadata div based on the div id passed as the arugment. 
         <div style='display:none;' id='FAMETA' data-json= '{"pyShowFAButtons":"false","modalHeaderTitle":"Modal Header"}' ></div>
 @return Returns the value of data-json attribute as mentioned in the stream if it is available otherwise returns undefined
*/
pega.ui.Doc.prototype.getOfflineMetaDataForModal = function(meta_data_div_id) {
    if ($(meta_data_div_id) != undefined && $(meta_data_div_id).length > 0) {
        var data = $(meta_data_div_id).attr("data-json");
        return JSON.parse(data);
    }
    return undefined;
};
/*
 @author sings9
 @public isShowFAButtons is used to get the value of the pyShowFAButtons which is 
         is added as an attribute to the #FAMETA div  on attribute data-json. e.g.
         <div style='display:none;' id='FAMETA' data-json= '{"pyShowFAButtons":"false","modalHeaderTitle":"Modal Header"}' ></div>
 @return Returns the value of pyShowFAButtons as mentioned in the stream if it is available otherwise returns undefined
*/
pega.ui.Doc.prototype.isShowFAButtons = function(meta_data_div_id) {
    var jsonObj = pega.u.d.getOfflineMetaDataForModal(meta_data_div_id);
    if (jsonObj != undefined) {
        return jsonObj.pyShowFAButtons;
    }
    return undefined;
};
/*
 @author sings9
 @public getOfflineHeaderTitle is used to get the value of the Modal Header Title which is 
         is added as an attribute to the #FAMETA div  on attribute data-json. e.g.
         <div style='display:none;' id='FAMETA' data-json= '{"pyShowFAButtons":"false","modalHeaderTitle":"Modal Header"}' ></div>
 @return Returns the value of modalHeaderTitle as mentioned in the stream if it is available otherwise returns undefined
*/
pega.ui.Doc.prototype.getOfflineHeaderTitle = function(meta_data_div_id) {
    var jsonObj = pega.u.d.getOfflineMetaDataForModal(meta_data_div_id);
    if (jsonObj != undefined) {
        return jsonObj.modalHeaderTitle;
    }
    return undefined;
};
/*
 @author sings9
 @public getSubmitCustomLabel is used to get the value of the Modal Sumbit Button Label which is 
         is added as an attribute to the #FAMETA div  on attribute data-json. e.g.
         <div style='display:none;' id='FAMETA' data-json= '{"pyShowFAButtons":"false","modalHeaderTitle":"Modal Header","pySubmitLabel":"Submit"}' ></div>
 @return Returns the value of modalHeaderTitle as mentioned in the stream if it is available otherwise returns undefined
*/
pega.ui.Doc.prototype.getSubmitCustomLabel = function(meta_data_div_id) {
    var jsonObj = pega.u.d.getOfflineMetaDataForModal(meta_data_div_id);
    if (jsonObj != undefined) {
        return jsonObj.pySubmitLabel;
    }
    return undefined;
};
/*
 @author sings9
 @public getCancelCustomLabel is used to get the value of the Modal Header Title which is 
         is added as an attribute to the #FAMETA div  on attribute data-json. e.g.
         <div style='display:none;' id='FAMETA' data-json= '{"pyShowFAButtons":"false","modalHeaderTitle":"Modal Header","pyCancelLabel":"Cancel"}' ></div>
 @return Returns the value of modalHeaderTitle as mentioned in the stream if it is available otherwise returns undefined
*/
pega.ui.Doc.prototype.getCancelCustomLabel = function(meta_data_div_id) {
    var jsonObj = pega.u.d.getOfflineMetaDataForModal(meta_data_div_id);
    if (jsonObj != undefined) {
        return jsonObj.pyCancelLabel;
    }
    return undefined;
};
pega.ui.Doc.prototype.hideFooter = function(meta_data_div_id) {
    var modalSec = pega.u.d.submitModalDlgParam.modalSection;
    /*Removing the footer div. If the class gets changed then this code will break.*/
    var metaDataDiv = null;
    var modalDialogBody = document.getElementById("modalContent");
    var modalArrayButtonElement = $(modalDialogBody).find(".layout-noheader-modal_button_array")[0];
    if (pega.u.d.submitModalDlgParam != null && pega.u.d.submitModalDlgParam.bIsOverlay == "true") {
        var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
        metaDataDiv = $(popOver.getActivePopOverElement()).find(meta_data_div_id);
        metaDataDiv.closest("div[node_name='" + modalSec + "']").find("table").first().siblings().css("display",
            "none");
    } else {
        if (modalArrayButtonElement != undefined) {
            $(modalArrayButtonElement).css("display", "none");
        }
    }
};
pega.ui.Doc.prototype.setSubmitButtonLabel = function(meta_data_div_id, submitButtonLabel) {
    var modalSec = pega.u.d.submitModalDlgParam.modalSection;
    if (pega.u.d.submitModalDlgParam != null && pega.u.d.submitModalDlgParam.bIsOverlay == "true") {
        var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
        var metaDataDiv = $(popOver.getActivePopOverElement()).find(meta_data_div_id);
        var button = $(metaDataDiv.closest("div[node_name='" + modalSec + "']").find("table").first().siblings().find(
            "button")[0]);
        var checkAttrVal = button.attr("onClick");
        //If onclick attribute is not there then check for data-click
        if (checkAttrVal == undefined) {
            checkAttrVal = button.attr("data-click");
        }
        //If both onclick and data-click attribute are not there then leave the name
        if (checkAttrVal == undefined) {
            console.log("Could not apply custom label to button.");
            return;
        }
        /*Checking with the regex if the doOverlayAction has a blank argument or not. If it is blank argument then it is a cancel button.*/
        if (checkAttrVal.search(/doOverlayAction\s*\(\s*(\'\'|\"\"|\\\'\\\'|\\\"\\\")/) == -1) {
            button.html(submitButtonLabel);
        } else {
            button = $($(meta_data_div_id).closest("div[node_name='" + modalSec + "']").find("table").first().siblings()
                .find("button")[1]);
            button.html(submitButtonLabel);
        }
    } else { /*Setting the Label for the Submit Button of the Modal Dialog.*/
        $(meta_data_div_id).closest("div[node_name='" + modalSec + "']").find("table").first().siblings().find(
            "button[id='ModalButtonSubmit']").html(submitButtonLabel);
    }
};
pega.ui.Doc.prototype.setCancelButtonLabel = function(meta_data_div_id, cancelButtonLabel) {
    var modalSec = pega.u.d.submitModalDlgParam.modalSection;
    if (pega.u.d.submitModalDlgParam != null && pega.u.d.submitModalDlgParam.bIsOverlay == "true") {
        var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
        var metaDataDiv = $(popOver.getActivePopOverElement()).find(meta_data_div_id);
        var button = $(metaDataDiv.closest("div[node_name='" + modalSec + "']").find("table").first().siblings().find(
            "button")[0]);
        var checkAttrVal = button.attr("onClick");
        //If onclick attribute is not there then check for data-click
        if (checkAttrVal == undefined) {
            checkAttrVal = button.attr("data-click");
        }
        //If both onclick and data-click attribute are not there then leave the name
        if (checkAttrVal == undefined) {
            console.log("Could not apply custom label to button.");
            return;
        }
        /*Checking with the regex if the doOverlayAction has a blank argument or not. If it is blank argument then it is a cancel button.*/
        if (checkAttrVal.search(/doOverlayAction\s*\(\s*(\'\'|\"\"|\\\'\\\'|\\\"\\\")/) != -1) {
            button.html(cancelButtonLabel);
        } else {
            button = $($(meta_data_div_id).closest("div[node_name='" + modalSec + "']").find("table").first().siblings()
                .find("button")[1]);
            button.html(cancelButtonLabel);
        }
    } else { /*Setting the Label for the Submit Button of the Modal Dialog.*/
        $(meta_data_div_id).closest("div[node_name='" + modalSec + "']").find("table").first().siblings().find(
            "button[id='ModalButtonCancel']").html(cancelButtonLabel);
    }
};
/*
 @public deleteModalHeader is used to delete header when pyModalTemplate is not used
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.deleteModalHeader = function() {
    var hdiv = document.getElementById("modaldialog_hd");
    if (hdiv) {
        /** Removing for loop as it is never used. Fix for BUG-121681 - Double headers are displayed **/
        /***HFix-20694, start***/
        /*Check for parent child relationship before removing*/
        if (hdiv.parentNode && (hdiv.parentNode == pega.u.d.modalDialog.innerElement))
        /***HFix-20694, end***/
            pega.u.d.modalDialog.innerElement.removeChild(hdiv);
    }
};
/*
 @public setAutoCompList is used to set the Autocomplte List
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.setAutoCompList = function() {
    var autoComDiv = pega.util.Dom.getElementsByClassName("autocomplete_main");
    var autoComDivLen = autoComDiv.length;
    for (var i = 0; i < autoComDivLen; i++) {
      if(autoComDiv[i].getAttribute("AutoComplete")){
        pega.u.d.autoCompList.put(autoComDiv[i].getAttribute("AutoComplete")._id, autoComDiv[i]);
      }
        
    }
};
/*
 @public removeElemListeners is used to remove the Listeners attached to elements that are not handled by the respective element
 @Handler
 @return $void$
*/
pega.ui.Doc.prototype.removeElemListeners = function(domElement) {
    if (!domElement) return;
    var descendants = [];
    var currLoc = 0;
    descendants[0] = domElement;
    while (descendants.length > currLoc) {
        domElement = descendants[currLoc];
        var elemChildNodes = domElement.childNodes;
        var len = elemChildNodes.length;
        for (var i = 0; i < len; i += 1) {
            descendants[descendants.length] = elemChildNodes[i];
        }
        currLoc += 1;
    }
    window.setTimeout(function() {
        pega.u.d.remListenersFromList(descendants, 0);
    }, 0);
};
pega.ui.Doc.prototype.remListenersFromList = function(listOfElements, beginIndex) {
    var endIndex = beginIndex + 10;
    if (endIndex > listOfElements.length) endIndex = listOfElements.length;
    for (var i = beginIndex; i < endIndex; i++) {
        var domElement = listOfElements[i];
        if (!domElement) continue;
        //if(pega.util.Event.getListeners(domElement) && pega.util.Event.getListeners(domElement).length > 0){
        pega.util.Event.removeListener(domElement);
        //}
        //if (domElement) {
        /*Start this is used to remove the listeners added to the autocomplete main div*/
        if (domElement.nodeType == 1 && domElement.getAttribute("AutoComplete")) { // Bug-37531 : dom Element nodes have nodetype 1, converting into positive check.
            var autoCompDiv = pega.u.d.autoCompList.get(domElement.id);
            if (autoCompDiv) {
                pega.util.Event.removeListener(autoCompDiv);
            }
        }
        /*End this is used to remove the listeners added to the autocomplete main div*/
        //}
    }
    if (endIndex < listOfElements.length) window.setTimeout(function() {
        pega.u.d.remListenersFromList(listOfElements, endIndex)
    }, 0);
};
/*
 @public isModalLoaded is used to know whether modal dialog is loaded or not
 @return $boolean$
*/
pega.ui.Doc.prototype.isModalLoaded = function() {
    return pega.u.d.bModalDialogOpen;
};
pega.ui.Doc.prototype.allowTransition = (function() {
    var bFlag = $('html').hasClass('phone');
    var f = function() {
        return bFlag && pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.animObj;
    }
    return f;
})();
pega.ui.Doc.prototype.localActionContainerOpened = (function() {
    var numOfContainersOpen = 0;
    var f = function(bflag) {
        if (bflag) {
            if (++numOfContainersOpen == 1) {
                $(".screen-layout-region-main-middle").css("-webkit-overflow-scrolling", "auto");
                $("div#PEGA_HARNESS").css("-webkit-overflow-scrolling", "auto");
            }
        } else {
            if (--numOfContainersOpen <= 0) {
                numOfContainersOpen = 0;
                $(".screen-layout-region-main-middle").css("-webkit-overflow-scrolling", "touch");
                $("div#PEGA_HARNESS").css("-webkit-overflow-scrolling", "touch");
            }
        }
    };
    return f;
})();
pega.ui.Doc.prototype.runTransitionTimeout = function(animClassStr, scope, callback) {
    var delay = $(animClassStr).css("transition-delay"),
        duration = $(animClassStr).css("transition-duration");
    duration = (duration.indexOf("ms") > -1) ? parseFloat(duration) : parseFloat(duration) * 1000;
    delay = (delay.indexOf("ms") > -1) ? parseFloat(delay) : parseFloat(delay) * 1000;
    setTimeout(function() {
        callback.call(scope);
    }, duration + delay);
};
pega.ui.modalDialog = function() {
    this.init();
}
pega.ui.modalDialog.prototype = {
    bModalOpen: false,
    header: null,
    footer: null,
    body: null,
    innerElement: null,
    resizeHandle: null,
    element: null,
    mask: null,
    animIn: "",
    animOut: "",
    isLocalAction: null,
    init: function(userConfig) {
        this.cfg = new pega.util.Config(this);
        if (userConfig) this.cfg.applyConfig(userConfig, true);
        /*elements*/
        this.innerElement = document.getElementById("modalWrapper");
        this.header = document.getElementById("modaldialog_hd");
        this.footer = document.getElementById("modalFooter");
        this.body = document.getElementById("modalContent");
        this.mask = this.element = document.getElementById("modalOverlay");
        /*events*/
        pega.lang.augmentProto(pega.ui.modalDialog, pega.util.EventProvider);
        this.showEvent = this.createEvent("show");
        this.showEvent.signature = pega.util.CustomEvent.LIST;
        this.hideEvent = this.createEvent("hide");
        this.hideEvent.signature = pega.util.CustomEvent.LIST;
        this.beforeShowEvent = this.createEvent("beforeShow");
        this.beforeShowEvent.signature = pega.util.CustomEvent.LIST;
        this.beforeHideEvent = this.createEvent("beforeHide");
        this.beforeHideEvent.signature = pega.util.CustomEvent.LIST;
        /*configuration properties*/
        this.cfg.addProperty("visible", {
            value: false,
            handler: this.configVisible
        });
        this.cfg.addProperty("close", {
            value: true,
            handler: this.configClose
        });
        this.cfg.addProperty("width", {
            value: "auto",
            handler: this.configWidth
        });
        this.cfg.addProperty("height", {
            value: "auto",
            handler: this.configHeight
        });
        this.cfg.addProperty("fixedCenter", {
            value: true,
            handler: this.configFixedCenter
        });
        this.cfg.addProperty("x", {
            handler: this.configX
        });
        this.cfg.addProperty("y", {
            handler: this.configY
        });
        this.cfg.addProperty("xy", {
            handler: this.configXY
        });
    },
    configVisible: function(type, args, obj) {
        var isMobile = $('html').hasClass('phone');
        var visible = args[0];
        var $innerEl = $(this.innerElement);
        var that = this;
        var isOffline = pega.u.d.ServerProxy.isDestinationLocal();
        if (visible) {
            this.beforeShowEvent.fire();
            that.mask.style.display = "block";
            //TASK-265558 21-01-2015 bajaj 
          var eleObj = [
              {
                "element":this.innerElement
              },
              {
                "element":this.mask,
                "paramsObj" : {
                  "effect": ANIM_SLIDE_FADE_OPEN,
                  "delay" : 0
                 }
              }
           ];
            if(!isMobile){
                pega.u.d.modalDialog._revealDismissAnimation(eleObj, this.animObj, "reveal", undefined);
            } else {
                if(pega.u.d.allowTransition()){
                     pega.u.d.modalDialog._revealDismissAnimation(eleObj, that.animObj, "reveal", function(){
                       if (pega.u.d.portalName) {
                         that.mask.style.top = "1px";
                         that.mask.offsetHeight
                         that.mask.style.top = "0px";
                       }
                    });
                    pega.u.d.localActionContainerOpened(true);
                    $(".screen-layout-region-main-middle").css("overflow-y", "visible");
                    $(".screen-layout-region-main-middle").css("overflow-x", "visible");
                    $(".screen-layout-region-main-middle").css("overflow", "visible");
                }
            }
            if (pega.env.ua.ie == 8 && window.isChartForIE8) {
                this.mask.style.zIndex = "11";
            }
            this.bModalOpen = true;
            this.showEvent.fire();
        } else {
            // BUG-339861: Modal is in closing state set isModalClosing to true

            //TASK-265558 21-01-2015 bajaj 
            
            that.mask.style.display = "none";
            that.bModalOpen = false;
            that.hideEvent.fire();
            $innerEl.removeClass("local-action");
            pega.u.d.localActionContainerOpened(false);
            $(".screen-layout-region-main-middle").css("overflow-y", "auto");
            $(".screen-layout-region-main-middle").css("overflow-x", "auto");
            $(".screen-layout-region-main-middle").css("overflow", "auto");
        }
    },
    configClose: function(type, args, obj) {
        var close = args[0];
        var closeIcon = document.getElementById("container_close");
        if (close) {
            if (!closeIcon) {
                closeIcon = document.createElement("button");
                pega.util.Dom.addClass(closeIcon, "container-close");
                closeIcon.setAttribute("type", "button");
                closeIcon.innerHTML = "&#160;";
                this.header.appendChild(closeIcon);
                pega.util.Event.addListener(closeIcon, "click", pega.u.d.modalDialog.hide, pega.u.d.modalDialog);
            } else if (closeIcon.style.display == "none") {
                closeIcon.style.display = "";
            }
        } else if (closeIcon) {
            closeIcon.style.display = "none";
        }
    },
    configWidth: function(type, args, obj) {
        var width = args[0];
        if (width == "auto") {
            this.element.style.width = "auto";
        } else {
            this.element.style.width = parseInt(width) + "px";
        }
    },
    configHeight: function(type, args, obj) {
        /*var height = args[0];
        if(height == "auto") {
            this.element.style.height = "auto";
        }else {
            this.element.style.height =parseInt(height) + "px";
        }*/
    },
    configFixedCenter: function(type, args, obj) {
        var fixedCenter = args[0];
        if (fixedCenter) {
            this.element.style.removeProperty("position");
        } else {
            this.element.style.position = "absolute";
        }
    },
    configX: function(type, args, obj) {
        var x = parseInt(args[0]);
        this.element.style.left = x + "px";
    },
    configY: function(type, args, obj) {
        var y = parseInt(args[0]);
        this.element.style.top = y + "px";
    },
    configXY: function(type, args, obj) {
        var pos = args[0]
        var x = parseInt(pos[0]);
        this.element.style.left = x + "px";
        var y = parseInt(pos[1]);
        this.element.style.top = y + "px";
    },
    render: function() {
        /*to support backward compatibility for controls which are already calling render. Nothing needs to be done as the elements are already present*/
    },
    setHeader: function(headerContent) {
        if (this.header) var oHeader = this.header;
        else {
            pega.u.d.addModalHeader();
            var oHeader = this.header;
        }
        if (headerContent.nodeName) {
            oHeader.innerHTML = "";
            oHeader.appendChild(headerContent);
        } else {
            if (!document.getElementById("modaldialog_hd_title")) {
                var span = document.createElement("span");
                span.id = "modaldialog_hd_title";
                oHeader.appendChild(span);
            }
            document.getElementById("modaldialog_hd_title").innerHTML = headerContent;
        }
    },
    setHeaderLabel: function(meta_data_div_id, headerContent) {
        /*TASK-584936 : If FA is referred in both localaction and connector then meta_div_id is not present in DOM*/
        //Setting modal dialog title from rule cache directly.
        $("#modaldialog_hd_title").text(headerContent);
    },
    _getEffect: function(oldAnimEffect) {
        var newEffect = "";
        switch (oldAnimEffect) {
            case "anim-bottom":
                newEffect = "anim-offbottom";
                break;
            case "anim-top":
                newEffect = "anim-offtop";
                break;
            case "anim-right":
                newEffect = "anim-offright";
                break;
            case "anim-left":
                newEffect = "anim-offleft";
                break;
            default:
                newEffect = oldAnimEffect
                break;
        }
        return newEffect;
    },
    _getNewAnimInEffectForOldEffect: function(oldAnimEffect){
        if(oldAnimEffect.indexOf("null") !== -1){
            return "none";
        }
        var effect = "none";
        if(pega.u.d.modalDialog._getEffect){
            effect = pega.u.d.modalDialog._getEffect(oldAnimEffect);
            if(effect !== oldAnimEffect || !effect.endsWith("-open")){
                effect = effect + "-open";
            }
        }
        return effect;
    },
    _getNewAnimOutEffectForOldEffect: function(oldAnimEffect, animInEffect){
        if(oldAnimEffect.indexOf("null") !== -1){
            return "none";
        }
        var newAnimOutEffect = "none";
        if (oldAnimEffect === "anim-in-animation") {
            newAnimOutEffect = "reverse-" + animInEffect;
        } else {
            newAnimOutEffect = pega.u.d.modalDialog._getEffect(oldAnimEffect);
            if(newAnimOutEffect !== oldAnimEffect || !newAnimOutEffect.endsWith("-close")){
                newAnimOutEffect = newAnimOutEffect + "-close";
            }
        }
        return newAnimOutEffect;
    },
    setTransitions: function(animObj, isLocalAction, isMobileFullScreen) {
        this.isLocalAction = isLocalAction;
        var animationObj = {};
        /* For backward compatibility US-265505 */
        if (animObj && animObj.animIn && animObj.animOut) {
            /* For backward compatibility - Checking for string null because in case of no animations set, animIn and animOut values are set as "anim-null" */
            if (animObj.animIn.indexOf("null") == -1 && animObj.animOut.indexOf("null") == -1) {
                $(this.innerElement).addClass("local-action");
                animationObj.mobile = {
                    "reveal": {
                        "effect": pega.u.d.modalDialog._getNewAnimInEffectForOldEffect(animObj.animIn)
                    },
                    "dismiss": {
                        "effect": pega.u.d.modalDialog._getNewAnimOutEffectForOldEffect(animObj.animOut)
                    }
                }
                isMobileFullScreen = "true";
                pega.u.d.submitModalDlgParam.isMobileFullScreen = isMobileFullScreen;
            }
        } else {
            if (animObj && pega.u.d.modalDialog._processAnimObj) {
                animationObj = pega.u.d.modalDialog._processAnimObj(animObj);
            }
        }
        if (isMobileFullScreen === "true") {
            if(!this.innerElement.classList.contains("local-action")){
                this.innerElement.classList.add("local-action");    
            }
        } else {
            this.innerElement.classList.remove("local-action");
        }
        this.animObj = animationObj;
    },
    _processAnimObj: function(animObj) {
        try {
            if (animObj) {
                if(animObj.desktop){
                    if(animObj.desktop.reveal){
                        var newDesktopRevealEffect = pega.u.d.modalDialog._getNewAnimInEffectForOldEffect(animObj.desktop.reveal.effect);
                        animObj.desktop.reveal.effect = newDesktopRevealEffect;    
                    }
                    if(animObj.desktop.isCustomDismiss === "false") {
                         animObj.desktop.dismiss = JSON.parse(JSON.stringify(animObj.desktop.reveal));
                         animObj.desktop.dismiss.effect = "reverse-" + animObj.desktop.dismiss.effect;   
                    }
                }
                if (animObj.isCustomMobileAnim === "false") {
                    animObj.mobile = JSON.parse(JSON.stringify(animObj.desktop));
                    return animObj;
                }
                if(animObj.mobile) {
                    if(animObj.mobile.reveal){
                        var newMobileRevealEffect = pega.u.d.modalDialog._getNewAnimInEffectForOldEffect(animObj.mobile.reveal.effect);
                        animObj.mobile.reveal.effect = newMobileRevealEffect;    
                    }
                    if(animObj.mobile.isCustomDismiss === "false") {
                        animObj.mobile.dismiss = JSON.parse(JSON.stringify(animObj.mobile.reveal));
                        animObj.mobile.dismiss.effect = "reverse-" + animObj.mobile.dismiss.effect;    
                    } else {
                        var newMobileDismissEffect = pega.u.d.modalDialog._getNewAnimOutEffectForOldEffect(animObj.mobile.dismiss.effect, animObj.mobile.reveal.effect);
                        animObj.mobile.dismiss.effect = newMobileDismissEffect;    
                    }
                }
            }
        } catch (exception) {}
        return animObj;
    },
    _hasAnimations: function(animObj, revealOrDismiss){
        var isMobile = $('html').hasClass('phone');
        var device = isMobile ? "mobile" : "desktop";
        var hasAnimations =  animObj && animObj[device] && animObj[device][revealOrDismiss];
        return hasAnimations && hasAnimations.effect.indexOf("none") === -1;
    },
    _revealDismissAnimation: function(element, animObj, revealOrDismiss, callback, otherParamObj) {
        var isMobile = $('html').hasClass('phone');
        var effect, ease, speed;
        var device = isMobile ? "mobile" : "desktop";
        var hasAnimations = pega.u.d.modalDialog._hasAnimations(animObj, revealOrDismiss);
        if (hasAnimations) {
            var config = {
                "effect": animObj[device][revealOrDismiss]["effect"],
                "ease": animObj[device][revealOrDismiss]["ease"],
                "duration": animObj[device][revealOrDismiss]["speed"]
            }
            var callbacksObj = {
                "onAnimEnd": callback
            }
            if(otherParamObj){
                config = Object.assign(config, otherParamObj);
            }
            if (config.effect !== "none") {
                pega.ui.animations.animate(element, config, callbacksObj);
            } else {
                if (callback) callback();
            }
        } else {
            if (callback) callback();
        }
    },
    // end
    show: function() {
        // EPIC-37368: PIMC changes native components appearance while showing modal
        if (pega.mobile && pega.mobile.sdk && pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.isMobileFullScreen) {
          window.dispatchEvent(new CustomEvent("mobile-modal-show", {detail: {fullScreen: pega.u.d.submitModalDlgParam.isMobileFullScreen === "true"}}));
        }
        //Set harness id and click event on modal dialogue
        /*commenting as its handled in pre success handler against BUG-414328
        if(pega.u.d.modalDialog && pega.u.d.modalDialog.element){
          pega.ctxmgr.registerContextSwitching(pega.u.d.modalDialog.element);
        }*/
        this.cfg.setProperty("close", this.cfg.getProperty("close"));
        this.cfg.setProperty("visible", true);
        //BUG-210031-Avoiding scrolling of parent when modal is open
        var docBody = document.body;
        var docBodyStyle = docBody.style;
        if (typeof(window.bodyOverflow) == "undefined" || window.bodyOverflow == "") {
            window.bodyOverflow = docBodyStyle.overflow;
        }
        if (typeof(window.bodyOverflowX) == "undefined" || window.bodyOverflowX == "") {
            window.bodyOverflowX = docBodyStyle.overflowX;
        }
        if (typeof(window.bodyOverflowY) == "undefined" || window.bodyOverflowY == "") {
            window.bodyOverflowY = docBodyStyle.overflowY;
        }
        document.body.style.overflow = "hidden";
        if (pega.mobile.nativenav) {
            this.nativeNavHistId = pega.mobile.nativenav.addToHistory(this.hide, this);
        }
    },
    hide: function() {
       if (pega.util.Event.isIE) {
        pega.util.Event.removeListener(document.body, "beforeactivate", pega.u.d.checkAccessKeys);
        }
        if (pega.u.d.modalResizeObj) {
        pega.u.d.modalResizeObj.destroy();
        pega.u.d.modalResizeObj = null;
        }
        // EPIC-37368: PIMC changes native components appearance while hiding modal
        if (pega.mobile && pega.mobile.sdk && pega.u.d.submitModalDlgParam && pega.u.d.submitModalDlgParam.isMobileFullScreen) {
          window.dispatchEvent(new CustomEvent("mobile-modal-hide", {detail: {fullScreen: pega.u.d.submitModalDlgParam.isMobileFullScreen === "true"}}));   
        }

        //Remove harness id and click event listener
        if (pega.u.d.modalDialog && pega.u.d.modalDialog.element) {
            pega.ctxmgr.unregisterContextSwitching(pega.u.d.modalDialog.element);
        }
        if (!this.cfg) {
            this.cfg = new pega.util.Config(this);
        }
        var scopeObj = this;
        var eleObj = [
              {
                "element":this.innerElement
              },
              {
                "element":this.mask,
                "paramsObj" : {
                  "effect": ANIM_SLIDE_FADE_CLOSE,
                  "delay" : 0
                 }
              }
          ];
        pega.u.d.isModalClosing = true;
        this.beforeHideEvent.fire();
        pega.u.d.modalDialog._revealDismissAnimation(eleObj, this.animObj, "dismiss", function() {
            scopeObj.innerElement.style.removeProperty("opacity");
            scopeObj.innerElement.style.removeProperty("visibility");
            scopeObj.innerElement.style.removeProperty("transform");
            scopeObj.cfg.setProperty("visible", false);
            scopeObj.mask.style.removeProperty("opacity");
            scopeObj.mask.style.removeProperty("transform");
        });
        //BUG-210031-Resetting back overflow so that parent of modal can scroll after hide
        var docBody = document.body;
        var docBodyStyle = docBody.style;
        if (typeof bodyOverflow != "undefined" && docBodyStyle.overflow != bodyOverflow) {
            docBodyStyle.overflow = (bodyOverflow === "") ? "" : bodyOverflow;
            bodyOverflow = "";
        }
        if (typeof bodyOverflowX != "undefined" && docBodyStyle.overflowX != bodyOverflowX) {
            docBodyStyle.overflowX = (bodyOverflowX === "") ? "" : bodyOverflowX;
            bodyOverflowX = "";
        }
        if (typeof bodyOverflowY != "undefined" && docBodyStyle.overflowY != bodyOverflowY) {
            docBodyStyle.overflowY = (bodyOverflowY === "") ? "" : bodyOverflowY;
            bodyOverflowY = "";
        }
        if (pega.mobile.nativenav) {
            pega.mobile.nativenav.removeFromHistory(this.nativeNavHistId);
        }
    }
};

pega.ui.Doc.prototype.modalAlignInMultiIframe = function(details) {
    var _ref2 = details,
        windowScroll = _ref2.windowScroll || 0,
        offset = _ref2.offset || {
            top: 0,
            left: 0
        },
        windowHeight = _ref2.windowHeight;
  
    var modaldialog = document.getElementsByClassName("modal-align-cell")[0];
    var modalWrapper = document.getElementsByClassName("modal-wrapper")[0];
      if (modaldialog) {
           modaldialog.style.verticalAlign = "baseline";
           modaldialog.style.paddingTop = "50px";
      }
    var modalcontentHeight = modalWrapper.offsetHeight;
    var iframeclientheight = document.documentElement.clientHeight;
    var scrolledHeight = windowScroll || 0;
    var actualHeight;
    var someFixedTopWIthinIframe = 50;
    if (modalcontentHeight < windowHeight) {
        someFixedTopWIthinIframe = parseInt((windowHeight - modalcontentHeight) / 2);
    }
    if (iframeclientheight < windowHeight) {
        someFixedTopWIthinIframe = parseInt((iframeclientheight - modalcontentHeight) / 2);
    }
    if (scrolledHeight < offset.top) {
        actualHeight = someFixedTopWIthinIframe;
    } else {
        actualHeight = scrolledHeight - offset.top + someFixedTopWIthinIframe;
        if (scrolledHeight - offset.top + someFixedTopWIthinIframe > iframeclientheight - modalcontentHeight) {
            actualHeight = iframeclientheight - modalcontentHeight
        }
    }
    modaldialog.style.paddingTop = "".concat(actualHeight, "px");
};

//static-content-hash-trigger-GCC
/*
 Change #1 :Updated proto.DOMEventHandler() to resolve the click event issue in the Accordion content Div

 Change#2 : Added harness wevent handler for handling both window resize and layout resize
 */

pega.namespace("pega.ui");

(function() {

    /**
     * The tabview module provides a widget for managing content bound to tabs.
     * @module tabview
     * @requires pega, dom, event, element
     *
     */
    /**
     * A widget to control tabbed views.
     * @namespace pega.ui
     * @class TabView
     * @extends pega.util.Element
     * @constructor
     * @param {HTMLElement | String | Object} el(optional) The html
     * element that represents the TabView, or the attribute object to use.
     * An element will be created if none provided.
     * @param {Object} attr (optional) A key map of the tabView's
     * initial attributes.  Ignored if first arg is attributes object.
     */

    pega.ui.TabView = function(el, attr) {
        attr = attr || {};
        if (arguments.length == 1 && !pega.lang.isString(el) && !el.nodeName) {
            attr = el; // treat first arg as attr object
            el = attr.element || null;
        }

        if (!el && !attr.element) { // create if we dont have one
            el = _createTabViewElement.call(this, attr);
        }
        this._left = 0;
        this._menuButtonListWidth = null;
        this._currentMenuButtonWidth = 0;
        this._tabContainerWidth = null;
        this.isDCTabView = false;
        pega.ui.TabView.superclass.constructor.call(this, el, attr);
        if (this._scrollContainer && this._isHorizontal) {
            this._hideScrollers = this._scrollContainer.getAttribute('data-hide-tab-scroll');
            this._initEvents();
            this._setLastOffset();
            //oldWidth was used to set a conditional call to resizeTabScroll in the TabView resize handler
            //We are turning off this condition. So no need to calculate this
            //this._oldWidth = this._contentParent.parentNode.offsetWidth;
        }
    };

    pega.extend(pega.ui.TabView, pega.util.Element);

    var proto = pega.ui.TabView.prototype;
    var Dom = pega.util.Dom;
    var Event = pega.util.Event;
    var Tab = pega.ui.Tab;

    //Moving this functionality outside the initEvents method so it can leverage isDCTabView optimiztion
    //Currently this info is not available at the time of object instantiation.
    //TODO: possible scope for rewrite here to get this information to the contructor.
    proto.setHarnessHeaderIconsHeightWidth = function() {
        var isFormatSubTabbed, processFurther, ele;
        ele = this.get("element");
        if (ele) {
            isFormatSubTabbed = Dom.hasClass(ele, "subTabbed");
        }
        processFurther = false;
        if (this._harnessHeaderIcons && ((!this.isDCTabView) || (this.isDCTabView && isFormatSubTabbed))) {
            processFurther = true;
        }
        if (processFurther) {
            var tabsUL = this._tabParent;
            if (tabsUL && tabsUL.offsetHeight != 0) {
                //var tabsULHeight = tabsUL.offsetHeight + "px";
                // Initialize width and height dynamicly.
                //this._harnessHeaderIcons.style.height = Event.isIE ? (parseInt(tabsULHeight, 10) - 2 + "px") : tabsULHeight;
                this._harnessHeaderIcons.style.height = tabsUL.lastChild.offsetHeight + "px";
            }
            this._harnessHeaderIcons.style.width = this._harnessHeaderIcons.firstChild.offsetWidth + "px";
        }
    }

    proto._initEvents = function() {
        var tabsUL = this._tabParent;
        /* ---------
         //perf mod -  moved the initialization of harness header icon
         //to outside tabview construction code and into the tabsupprt
         //initializeTabs method using using setHarnessHeaderIconsHeightWidth
         //
         // BUG-70791 START
         if (this._harnessHeaderIcons) {

         if(tabsUL && tabsUL.offsetHeight != 0){
         //var tabsULHeight = tabsUL.offsetHeight + "px";
         // Initialize width and height dynamicly.
         //this._harnessHeaderIcons.style.height = Event.isIE ? (parseInt(tabsULHeight, 10) - 2 + "px") : tabsULHeight;
         this._harnessHeaderIcons.style.height = tabsUL.lastChild.offsetHeight + "px";
         }
         this._harnessHeaderIcons.style.width = this._harnessHeaderIcons.firstChild.offsetWidth + "px";
         }
         perf mod end
         --------  */
        // BUG-70791 END
        if (this._menuButton) {
            Event.addListener(this._menuButton, 'click', this.showTabsMenu, null, this);
            Event.addListener(this._menuButton, 'keydown', this.showTabsMenu, null, this);
            if (Event.isIE) {
                this._menuButton.parentNode.onselectstart = function() {
                    return false;
                };
            }
            this.objMenuXML = pega.tools.XMLDocument.get();
            this.onBeforeShowMenu = new pega.util.CustomEvent("onBeforeShowMenu", this);
        }

        var that = this;
        this.on("activeTabChange", this.focusActiveTab, null, this);
        //HFix-20746
        pega.u.d.registerResize(function() {
            if (!that.isDCTabView) {
                if (that._harnessHeaderIcons && that._harnessHeaderIcons.offsetWidth != that._harnessHeaderIcons.firstChild.offsetWidth) {
                    that._harnessHeaderIcons.style.width = that._harnessHeaderIcons.firstChild.offsetWidth + "px";
                }
            }
            window.setTimeout(function() {
                /* if ( that._contentParent && that._contentParent.parentNode ) {
                 //	var newWidth = that._contentParent.parentNode.offsetWidth;
                 //	if (newWidth != that._oldWidth) {
                 //		that._oldWidth = newWidth;*/
                if (!that.isDCTabView) {
                    that.resizeTabsScroll();
                }
                /* 	}
                 //}*/
            }, 5);

        });
        //Required  - these resize calls are attached to different events and
        //are required for different scenarios
        //We will optimize the toggleQuickMenu itself or totally turn it off
        //At that point we can remove these
        pega.ui.d.attachOnload(function() {
            that._toggleQuickMenu();
        }, false);
        /* BUG-118069, BUG-177986 */
        Event.addListener(window, 'resize', function() {
            //HFix-20746
            if (that.isDCTabView) {
                that.resizeTabsScroll();
            } else {
                that._toggleQuickMenu();
            }
        }, null, this);
        /* BUG-118069, BUG-177986 */
    };

    proto.resizeTabsScroll = function() {
        //BUG-64430 3/13/2012 Script Error when loading portals
        if (this._scrollContainer && this._isHorizontal) {
            //HFix-20746
            if (!this.isDCTabView) {
                this._setLastOffset();
            }
            this._resizeScrollContainer();
            this.hideTabsMenu();
            this._toggleQuickMenu();
        }
        //BUG-64430 3/13/2012 Script Error when loading portals
    }

    pega.ui.TabView.selectTab = function(index) {
        var tabView = pega.ui.TabView.activeTabView;
        tabView.set("activeTab", tabView.getTab(index));
    };

    pega.ui.TabView.activeTabView = null;

    proto.hideTabsMenu = function() {
        pega.ui.TabView.activeTabView = this;
        if (this.currentlyOpenedMenus) {
            this.currentlyOpenedMenus._hideAll();
        }
    }

    proto.showTabsMenu = function(e) {
        //If the keydown event is not from enter or space then ignore it.
        if (e.type == "keydown" && !(e.keyCode == 13 || e.keyCode == 32)) {
            return;
        }
        var activeTabView = pega.ui.TabView.activeTabView;
        if (activeTabView && activeTabView.currentlyOpenedMenus) {
            activeTabView.currentlyOpenedMenus._hideAll();
        }
        pega.ui.TabView.activeTabView = this;

        this.currentlyOpenedMenus = new pega.ui.menubar.Manager();

        var tabStrip = this._tabParent.parentNode,
                scrollContainerWidth = tabStrip.offsetWidth,
                scrollLeft = Math.abs(this._left),
                leftOffset = scrollLeft + scrollContainerWidth,
                aTabs = this.get("tabs"),
                activeIndex = this.get("activeIndex"),
                dataXML = "<pagedata>\n<Menu>",
                tabsLength = (this._tabPos == "Top") ? aTabs.length - 1 : aTabs.length,
                ln = 4; // ln is the length of the longest title.
        if (!Event.isIE || pega.u.d.inStandardsMode)
            this._fixTabsDisplay("inline-block"); // BUG-73011 : This will help to get correct offset values
        for (var i = 0; i < tabsLength; i++) {
            var oTab = aTabs[i],
                    styleOverrides = {},
                    leftStyleOverrides = {},
                    tabEl = oTab.get("element"),
                    itemLeft = tabEl.offsetLeft,
                    itemWidth = tabEl.offsetWidth,
                    itemOffset = itemLeft + itemWidth,
                    /* BUG-102407 GUJAS1 05/15/2013 Send tab instance */
                    tabIconLabelTooltip = this.getTabLabelIconAndTooltip(tabEl, oTab),
                    icon = tabIconLabelTooltip.icon,
                    imageClass = "",
                    styleString = "",
                    leftStyleString = "",
                    activeStyle = "",
                    label = tabIconLabelTooltip.label || tabIconLabelTooltip.tooltip || "",
                    strToolTip = tabIconLabelTooltip.tooltip || tabIconLabelTooltip.label || "",
                    strValue = label;

            if (itemLeft < scrollLeft || itemOffset > leftOffset) {
                styleOverrides["background-color"] = "#dbdbdb";
                leftStyleOverrides["background-color"] = "#dbdbdb";
            }

            if (activeIndex == i) {
                styleOverrides["font-weight"] = "bold";
                leftStyleOverrides["font-weight"] = "bold";
            }
            if (icon) {
                leftStyleOverrides["background-image"] = "url('" + icon + "')";
                leftStyleOverrides["background-repeat"] = "no-repeat";
                leftStyleOverrides["background-position"] = "center";
                imageClass = "tabsMenuEmptyImageDiv";
            }
            for (var o in styleOverrides) {
                styleString += o + ":" + styleOverrides[o] + ";";
            }
            for (var lo in leftStyleOverrides) {
                leftStyleString += lo + ":" + leftStyleOverrides[lo] + ";";
            }
            if (leftStyleString.length > 0) {
                activeStyle += ("leftstyle = \"" + leftStyleString + "\"");
            }
            if (styleString.length > 0) {
                activeStyle += (" middlestyle = \"" + styleString + "\" rightstyle = \"" + styleString + "\"");
            }

            if (label.length > 16) {
                label = label.substring(0, 13) + "...";
            }
            if (label.length > ln) {
                ln = label.length;
            }
            strValue = label;
          
          	// SE-34391 : Changes to escape special characters.
          	strToolTip = strToolTip.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;')
               .replace(/"/g, '&quot;')
               .replace(/'/g, '&apos;');
          	strValue = strValue.replace(/&/g,"&amp;");
          	activeStyle = activeStyle.replace(/&/g,"&amp;");
            imageClass = imageClass.replace(/&/g,"&amp;");

            // BUG-62486 GUJAS1 03/20/2012 Added index of the tab to the menu key.
            var snippet = '\n<Item Value="' + strValue + i + '" Caption="' + strValue + '" ToolTip="'
                    + strToolTip + '" ' + activeStyle + ' ImageClass="' + imageClass
                    + '" onClick="pega.ui.TabView.selectTab(' + i + ');"></Item>';
            dataXML += snippet;
        }
        if (!Event.isIE || pega.u.d.inStandardsMode)
            this._fixTabsDisplay("inline"); // BUG-73011 : Reset display value to inline
        dataXML += "\n</Menu>\n</pagedata>";

        var isLoaded = this.objMenuXML.loadXML(dataXML);
        var xmlMenuNode = this.objMenuXML.documentElement.selectSingleNode("//Menu");

        this.currentlyOpenedMenus.setStylePrefix("");

        this.currentlyOpenedMenus.desktopClickHandler.srcElement = this._menuButtonList;
        this.onBeforeShowMenu.fire();
        this.currentlyOpenedMenus.doContextMenu(xmlMenuNode, {relativeElement: this._menuButtonList, align: "right"});
        Event.stopEvent(e);
        return false;
    };

    proto._onDOMScroll = function(evt) {
        var target = evt.target ? evt.target : evt.srcElement;
        if (this._isHorizontal) {
            var scrollLeft = target.scrollLeft;
            var maxScroll = (this._lastItemOffset - this._tabContainerWidth);
            if (scrollLeft > maxScroll) {
                target.scrollLeft = scrollLeft = maxScroll;
            }
            this._left = scrollLeft;
        }
        this._toggleQuickMenu();
    };

    proto.focusActiveTab = function(evt) {
        var newEl = this._tabParent.childNodes[this.get("activeIndex")];
        this.scrollToElement(newEl);
    };

    proto._setLastOffset = function() {
        //intentional global
        //try {
        if (typeof gCloseAllTabsInProgress != "undefined" && gCloseAllTabsInProgress) {
            return;
        }
        //} catch (e) {
        //currently gCloseAllTabsInProgress is not initialized and throws exception unless coming from closeAllDocuments
        //}

        if (this._scrollContainer && this._isHorizontal) {
            var childEl = this._tabParent.lastChild;
            if (childEl && this._tabPos == "Top") {
                childEl = childEl.previousSibling;
            }
            while (childEl) {
                if (childEl.style.display == "none") {
                    childEl = childEl.previousSibling;
                } else {
                    break;
                }
            }

            //The calls to fixTabsDisplay is no longer required as the default styling is inline-block and no toggling is required
            if (childEl && !(Dom.hasClass(childEl, "rightborder"))) {
                // BUG-77009 07/25/2012 GUJAS1 Set the display of all tabs to inline-block to correctly calculate width.
                //if(!Event.isIE || pega.u.d.inStandardsMode) this._fixTabsDisplay("inline-block");

                this._lastItemOffset = (childEl.offsetLeft + childEl.offsetWidth);

                // BUG-77009 07/25/2012 GUJAS1 Reset the display of all tabs to inline.
                //if(!Event.isIE || pega.u.d.inStandardsMode) this._fixTabsDisplay("inline");//childEl.style.display = "inline";
            }
            this._toggleQuickMenu();
        }
    };

    proto._toggleQuickMenu = function() {
      if(!this._tabContainerWidth){
        //tabstrip is not ready yet. Possibly because this is the initial load of the tab group
        //We will not need to toggle the menu in this case
        return;
      }
      
      
        var tabStrip = this._tabParent.parentNode;
        if (tabStrip) {
            var aTabs = this.get("tabs"),
                    controlsWidth = (this._left == 0) ? this._currentMenuButtonWidth : 0,
                    tabsLength = (this._tabPos == "Top") ? aTabs.length - 1 : aTabs.length;
            if (this._tabContainerWidth == 0) {
                return;
            }
            //For DC Tabs to always have Quick Menu
            if (this.isDCTabView && this._menuButton) {
                if (this._menuButtonList.style.display != "inline-block") {
                    this._menuButtonList.style.display = "inline-block";
                }
                
                // Fix for BUG-392611
                // Hide the dc tabs overflow menu when gIsCustomTabHeaderEnabled is enabled
                if(window.gIsCustomTabHeaderEnabled) {
                    this._menuButtonList.style.visibility = "hidden";
                }
                return;
            }
            this._reachedStart = (tabsLength == 0 || this._left <= 0);
            this._reachedEnd = (tabsLength == 0 || (this._tabContainerWidth + controlsWidth + this._left) >= this._lastItemOffset);

            if (this._reachedStart && this._reachedEnd) {
                if (this._menuButton) {
                    this._menuButtonList.style.display = "none";
                    this._currentMenuButtonWidth = 0;
                }
                if (this.currentlyOpenedMenus) {
                    this.hideTabsMenu();
                }
            }
            else {
                if (this._menuButton) {
                    this._menuButtonList.style.display = "inline-block";
                    if (this._menuButtonListWidth == null) {
                        this._menuButtonListWidth = this._menuButton.offsetWidth;
                    }
                    this._currentMenuButtonWidth = this._menuButtonListWidth;
                }
            }
        }
    };

    proto.scrollToElement = function(idOrEl) {
        var scrollEl;
        if (typeof (idOrEl) == "string") {
            scrollEl = document.getElementById(idOrEl);
        } else {
            scrollEl = idOrEl;
        }
        if (scrollEl && scrollEl.nodeType && !(Dom.hasClass(scrollEl, "rightborder"))) {
            var anchorElement = scrollEl.querySelector("span#TABANCHOR");
            if (this._isHorizontal && anchorElement) {
                scrollEl = anchorElement;
                var tabStrip = this._tabParent.parentNode,
                        scrollContainerWidth,
                        tabList,
                        itemLeft = scrollEl.offsetLeft,
                        itemWidth = scrollEl.offsetWidth,
                        scrollLeft = Math.abs(this._left),
                        leftOffset,
                        itemOffset = itemLeft + itemWidth;
                if (this._tabContainerWidth == null) {
                    scrollContainerWidth = this._tabContainerWidth = tabStrip.offsetWidth;
                } else {
                    scrollContainerWidth = this._tabContainerWidth;
                }
                leftOffset = scrollLeft + scrollContainerWidth;
                if (itemLeft > scrollLeft && itemOffset < leftOffset) {
                    this._toggleQuickMenu();
                    return; // Already in visible area.
                }
                if (itemOffset >= leftOffset) {
                    itemLeft = scrollLeft + (itemOffset - leftOffset);
                }
                if (itemLeft < 0) {
                    itemLeft = 0;
                }
                this._left = itemLeft;
                if(window.gIsCustomTabHeaderEnabled){
                   tabList = tabStrip.firstElementChild;
                   tabList.scrollLeft = this._left;
                }else{
                   tabStrip.scrollLeft = this._left;   
                }
            }
        }
        this._toggleQuickMenu();
    };

    proto._fixTabsDisplay = function(value) {
        /*BUG-121808: to remove the hardcoded 10000px width for tabs
         * this function needs to be turned off
         */
        return;
        //var length = this._tabParent.lastChild.className.indexOf("rightborder") != -1 ? this._tabParent.childNodes.length - 1 : this._tabParent.childNodes.length;
        //var length = this._tabPos == "Top" ? this._tabParent.childNodes.length - 1 : this._tabParent.childNodes.length;
        for (var i = 0; i < this._tabParent.childNodes.length; i++) {
            var node = this._tabParent.childNodes[i];
            if (node.className.indexOf("rightborder") == -1) {
                node.style.display = value;
            }
        }
    }

    proto._resizeScrollContainer = function() {
        //HFix-20746
//intentional global
        //try {
        if (typeof gCloseAllTabsInProgress != "undefined" && gCloseAllTabsInProgress) {
            return;
        }
        //} catch (e) {
//currently gCloseAllTabsInProgress is not initialized and throws exception unless coming from closeAllDocuments
        //}
        var tabStrip = this._tabParent.parentNode;
        if (tabStrip && this._isHorizontal) {
            var scrollContainerWidth = tabStrip.offsetWidth,
                    scrollLeft = Math.abs(this._left),
                    itemLeft = 0,
                    lastItemOffset = this._lastItemOffset,
                    leftOffset = lastItemOffset - scrollLeft;
            if (scrollLeft > 0 && leftOffset <= scrollContainerWidth) {
                itemLeft = scrollContainerWidth - leftOffset;
            }
            itemLeft = this._left + itemLeft;
            if (itemLeft >= 0) {
                itemLeft = 0;
            }
            this._left = itemLeft;
            this._tabContainerWidth = scrollContainerWidth;
            tabStrip.scrollLeft = this._left;
            this.focusActiveTab();
        }
    };

    /* BUG-102407 GUJAS1 05/15/2013 Added new param to pass tab instance, */
    proto.getTabLabelIconAndTooltip = function(tabEl, oTab) {
        var labelElement = tabEl.querySelector("span[data-stl]"),
                tabIconElement = tabEl.getElementsByTagName("img"),
                anchorElement = tabEl.querySelector("span[id='TABANCHOR']"),
                customTabHeaderEle = tabEl.querySelector("div[node_name='pyCustomDCTabSection']"),
                label = "", icon = "", tooltip = "";

        /* BUG-102407 GUJAS1 05/15/2013 Read label/tooltip/icon from cached properties if available */

      if(window.gIsCustomTabHeaderEnabled && customTabHeaderEle){
        label = customTabHeaderEle.innerText;
        var toolTipEle = customTabHeaderEle.querySelector("[title]");
        if(toolTipEle){
          tooltip = toolTipEle.title;
        }
      } else if (oTab) {
            if (typeof oTab.label == "string" && oTab.label.length > 0) {
                label = oTab.label;
            }
            if (typeof oTab.ToolTip == "string" && oTab.ToolTip.length > 0) {
                tooltip = oTab.ToolTip;
            }
            if (typeof oTab.iconPath == "string" && oTab.iconPath.length > 0) {
                icon = oTab.iconPath;
            }
        }

        if (label == "" && labelElement) {
            label = Dom.getInnerText(labelElement);
        }
        if (tooltip == "" && anchorElement) {
            tooltip = anchorElement.title;
        }
        if (icon == "" && tabIconElement.length > 0) {
            icon = tabIconElement[0].src;
            tooltip = tabIconElement[0].title;
        }
      	if(icon && tooltip==""){
            tooltip = tabIconElement[0].title;
        }
        return {"label": label, "icon": icon, "tooltip": tooltip};
    };
    /**
     * The className to add when building from scratch.
     * @property CLASSNAME
     * @default "navset"
     */
    proto.CLASSNAME = 'yui-navset';

    /**
     * The className of the HTMLElement containing the TabView's tab elements
     * to look for when building from existing markup, or to add when building
     * from scratch.
     * All childNodes of the tab container are treated as Tabs when building
     * from existing markup.
     * @property TAB_PARENT_CLASSNAME
     * @default "nav"
     */
    proto.TAB_PARENT_CLASSNAME = 'yui-nav';

    /**
     * The className of the HTMLElement containing the TabView's label elements
     * to look for when building from existing markup, or to add when building
     * from scratch.
     * All childNodes of the content container are treated as content elements when
     * building from existing markup.
     * @property CONTENT_PARENT_CLASSNAME
     * @default "nav-content"
     */
    proto.CONTENT_PARENT_CLASSNAME = 'yui-content';

    proto._tabParent = null;
    proto._contentParent = null;

    /**
     * Adds a Tab to the TabView instance.
     * If no index is specified, the tab is added to the end of the tab list.
     * @method addTab
     * @param {pega.ui.Tab} tab A Tab instance to add.
     * @param {Integer} index The position to add the tab.
     * @return void
     */
    proto.addTab = function(tab, index) {
        var tabs = this.get('tabs');
        if (!tabs) { // not ready yet
            this._queue[this._queue.length] = ['addTab', arguments];
            return false;
        }

        index = (index === undefined) ? tabs.length : index;
        tab.tabview = this;
        var before = this.getTab(index);

        var self = this;
        var el = this.get('element');
        var tabParent = this._tabParent;
        var contentParent = this._contentParent;

        var tabElement = tab.get('element');
        var contentEl = tab.get('contentEl');
        //BUG-156444 : hide tabs list container when there are no tabs
        var contentElements = _getChildNodes(this._contentParent);
        if (this._scrollContainer && contentElements.length > 0) {
            this._scrollContainer.style.display = "";
        }
        if (before) {
            tabParent.insertBefore(tabElement, before.get('element'));
        } else {
            tabParent.appendChild(tabElement);
        }

        if (contentEl && !Dom.isAncestor(contentParent, contentEl)) {
            contentParent.appendChild(contentEl);
        }

        if (!tab.get('active')) {
            tab.set('contentVisible', false, true); /* hide if not active */
        } else {
            this.set('activeTab', tab, true);

        }

        var activate = function(e, tabObj) {
          // BUG-44883 Checkbox doesn’t work in Tab and Accordian header modes becuase of preventing the default behavior of the event. To fix this bug added below tagName condition.
          var target = pega.util.Event.getTarget(e);
          if (!target || !target.tagName || !target.tagName.match(/^(input|select|textarea)$/gi)) {
            pega.util.Event.preventDefault(e);
          }
          
          var existingActiveTab = self.get('activeTab');
          self.set('activeTab', tabObj);
          
          if(tabObj.tabview.isDCTabView){
            pega.desktop.sendEvent('DCTabSwitch', {
              fromTab: {
                id: existingActiveTab.label,
                handle: existingActiveTab.key,
                GadgetName: existingActiveTab.GadgetName  
              },
              toTab: {
                id: tabObj.label,
                handle: tabObj.key,
                GadgetName: tabObj.GadgetName
              }
            }); 
          }
        };
        if (this.hasClass("with-fixed-header")) {
            Event.addListener(tabElement, tab.get('activationEvent'), activate, tab);
        } else {
            tab.addListener(tab.get('activationEvent'), activate, tab);
        }

        tab.addListener('activationEventChange', function(e) {
            if (e.prevValue != e.newValue) {
                if (this.tabview.hasClass("with-fixed-header")) {
                    Event.removeListener(tab.get('element'), e.prevValue, activate, tab);
                    Event.addListener(tab.get('element'), e.newValue, activate, tab);
                } else {
                    tab.removeListener(e.prevValue, activate, tab);
                    tab.addListener(e.newValue, activate, tab);
                }
            }
        });

        tabs.splice(index, 0, tab);
        //this._setLastOffset(); //not required - has perf penalty
        this.fireEvent("tabAdded", {"tabs": this.get("tabs"), "addedTab": tab});
    };

    /**
     * Routes childNode events.
     * @method DOMEventHandler
     * @param {event} e The Dom event that is being handled.
     * @return void
     */
    proto.DOMEventHandler = function(e) {
        var el = this.get('element');
        var target = pega.util.Event.getTarget(e);
        var tabParent = this._tabParent;

        var inAccordion = false;
        if (el && el.id && el.id.indexOf("PEGA_ACCORDION") == 0) {
            inAccordion = true;
        }
        if (Dom.isAncestor(tabParent, target)) {
            var tabEl;
            var tab = null;
            var contentEl;
            var tabs = this.get('tabs');
            for (var i = 0, len = tabs.length; i < len; i++) {
                tabEl = tabs[i].get('element');
                contentEl = tabs[i].get('contentEl');
                if (inAccordion) {
                    var firstChild = pega.util.Dom.getChildren(tabEl)[0];
                    if (target == tabEl || target == firstChild || Dom.isAncestor(firstChild, target)) {
                        tab = tabs[i];
                        break; // note break
                    }
                } else {
                    if ((target == tabEl || Dom.isAncestor(tabEl, target)) && (tabEl.className == null || tabEl.className.indexOf('addTab') < 0)) {
                        tab = tabs[i];
                        break; // note break
                    }
                }
            }
            if (tab) {
                tab.fireEvent(e.type, e);
            }
        }
    };
    /**
     * Returns the Tab instance at the specified index.
     * @method getTab
     * @param {Integer} index The position of the Tab.
     * @return pega.ui.Tab
     */
    proto.getTab = function(index) {
        return this.get('tabs')[index];
    };

    /**
     * Returns the index of given tab.
     * @method getTabIndex
     * @param {pega.ui.Tab} tab The tab whose index will be returned.
     * @return int
     */
    proto.getTabIndex = function(tab) {
        var index = null;
        var tabs = this.get('tabs');
        for (var i = 0, len = tabs.length; i < len; ++i) {
            if (tab == tabs[i]) {
                index = i;
                break;
            }
        }

        return index;
    };

    /**
     * Removes the specified Tab from the TabView.
     * @method removeTab
     * @param {pega.ui.Tab} item The Tab instance to be removed.
     * @param {boolean} pass true if MRU like mechanism is present to change active indexes. Desired by Workarea layouts.
     * @return void
     */
    proto.removeTab = function(tab, keepActiveIndex) {
        var tabCount = this.get('tabs').length;

        var index = this.getTabIndex(tab);
        var nextIndex = index + 1;
        if (!keepActiveIndex && tab == this.get('activeTab')) { // select next tab
            if (tabCount > 1) {
                if (index + 1 == tabCount) {
                    this.set('activeIndex', index - 1);
                } else {
                    this.set('activeIndex', index + 1);
                }
            }
        }

        this._tabParent.removeChild(tab.get('element'));
        this._contentParent.removeChild(tab.get('contentEl'));
        this._configs.tabs.value.splice(index, 1);

        //this._setLastOffset();
        //this._resizeScrollContainer();
        this.resizeTabsScroll(); //this does both the above calls and properly handles the tabs menu toggle

        this.fireEvent("tabRemoved", {"tabs": this.get("tabs"), "removedTab": tab});
    };

    /**
     * Provides a readable name for the TabView instance.
     * @method toString
     * @return String
     */
    proto.toString = function() {
        var name = this.get('id') || this.get('tagName');
        return "TabView " + name;
    };

    /**
     * The transiton to use when switching between tabs.
     * @method contentTransition
     */
    proto.contentTransition = function(newTab, oldTab) {
        newTab.set('contentVisible', true);
        oldTab.set('contentVisible', false);
    };

    /**
     * setAttributeConfigs TabView specific properties.
     * @method initAttributes
     * @param {Object} attr Hash of initial attributes
     */
    proto.initAttributes = function(attr) {
        pega.ui.TabView.superclass.initAttributes.call(this, attr);

        if (!attr.orientation) {
            attr.orientation = 'top';
        }

        var el = this.get('element');

        /**
         * The Tabs belonging to the TabView instance.
         * @config tabs
         * @type Array
         */
        this.setAttributeConfig('tabs', {
            value: [],
            readOnly: true
        });

        /**
         * The container of the tabView's label elements.
         * @property _tabParent
         * @private
         * @type HTMLElement
         */
        var tabParentCandidate = Dom.getFirstChild(el);
        this._isCSSResize = false;
        var scrollContainerEl;
        /* BUG-139599 - If Accordion has a TabGroup, then the accordion is detecting as it contains scroll container. Because of it the _tabParent was set incorrectly.: KUMAD1 */
        if (el.id.indexOf("PEGA_ACCORDION") != 0) {
            scrollContainerEl = Dom.getChildrenBy(el, function(obj) {
                return (obj.className && obj.className.indexOf("scrlCntr") != -1);
            })[0];
        }
        if (this.hasClass("with-fixed-header")) {
            this._isCSSResize = true;
            scrollContainerEl = Dom.getFirstChild(document.getElementById("dummyDiv"));
        }
        if (scrollContainerEl) {
            this._scrollContainer = scrollContainerEl;
            var tabPos = el.getAttribute('data-pos');
            this._isHorizontal = (tabPos == "Top" || tabPos == "Bottom");
            this._tabPos = tabPos;

            if (tabPos == "Top") { //Horizontal top tabs case
                if (this._isCSSResize) {
                    tabParentCandidate = Dom.getFirstChild(document.getElementById("dummyDiv"));
                }
                this._tabParent = tabParentCandidate.lastChild.firstChild;
            } else if (tabPos == "Left" || tabPos == "Right") { //Vertical tabs case
                var tblElement = tabParentCandidate;
                if (this._isCSSResize) {
                    tabParentCandidate = $(".dc-" + tabPos.toLowerCase() + " .contents .pegaTabGrp .tab-ul")[0];
                }
                else {
                    tabParentCandidate = Dom.getFirstChild(tblElement.rows[0].cells[0]);
                }
                if (tabParentCandidate && tabPos == "Left") { // Vertical tabs on the left case
                    //BUG-69633 05/10/2012 GUJAS1 Markup changes have caused the UL to be the first cell element.
                    //this._tabParent = tabParentCandidate.lastChild;
                    this._tabParent = tabParentCandidate;
                } else {
                    if (this._isCSSResize) {
                        tabParentCandidate = $(".dc-" + tabPos.toLowerCase() + " .contents .pegaTabGrp .tab-ul")[0];
                    }
                    else {
                        tabParentCandidate = Dom.getFirstChild(tblElement.rows[0].cells[1]);
                    }
                    if (tabParentCandidate && tabPos == "Right") { // Vertical tabs on the right case
                        //BUG-69633 05/10/2012 GUJAS1 Markup changes have caused the UL to be the first cell element.
                        //this._tabParent = tabParentCandidate.lastChild;
                        this._tabParent = tabParentCandidate;
                    }
                }
            } else if (tabPos == "Bottom") {
                if (this._isCSSResize) {
                    tabParentCandidate = Dom.getFirstChild(document.getElementById("dummyDiv"));
                } else {
                    tabParentCandidate = Dom.getLastChild(el);
                }
                this._tabParent = tabParentCandidate.lastChild.firstChild;
            } else {
                this._tabParent = _createTabParent.call(this);
            }
            // BUG-70791 START
            var harnessHeaderIcons = Dom.getElementsByClassName("harnessHeaderIcons", "div", tabParentCandidate);
            if (harnessHeaderIcons.length > 0) {
                this._harnessHeaderIcons = harnessHeaderIcons[0];
            }
            // BUG-70791 END
            var tabButtonsList = tabParentCandidate.getElementsByTagName("ol");
            // If tabButtonsList has children, initialize scroller elements.
            if (tabButtonsList.length > 0) {
                /*
                 this._prevButtonList = tabButtonsList[0];
                 this._prevButton = this._prevButtonList.getElementsByTagName("a")[0];
                 this._nextButtonList = (tabButtonsList.length == 3) ? tabButtonsList[2] : tabButtonsList[1];
                 this._nextButton = this._nextButtonList.getElementsByTagName("a")[0];
                 */
                this._menuButtonList = tabButtonsList[0];
                this._menuButton = this._menuButtonList ? this._menuButtonList.getElementsByTagName("a")[0] : null;
            }
        } else {
            if (tabParentCandidate.nodeName === 'UL') { //Horizontal top tabs case
                this._tabParent = tabParentCandidate;
            } else if (tabParentCandidate.nodeName === 'TABLE') { //Vertical tabs case
                var tblElement = tabParentCandidate;
                tabParentCandidate = Dom.getFirstChild(tblElement.rows[0].cells[0]);
                if (tabParentCandidate && tabParentCandidate.nodeName === 'UL') { // Vertical tabs on the left case
                    this._tabParent = tabParentCandidate;
                } else {
                    tabParentCandidate = Dom.getFirstChild(tblElement.rows[0].cells[1]);
                    if (tabParentCandidate && tabParentCandidate.nodeName === 'UL') { // Vertical tabs on the right case
                        this._tabParent = tabParentCandidate;
                    }
                }
            } else if (tabParentCandidate.nodeName === 'DIV') {
                this._tabParent = Dom.getLastChild(el);
            } else {
                this._tabParent = _createTabParent.call(this);
            }
        }

        /**
         * The container of the tabView's content elements.
         * @property _contentParent
         * @type HTMLElement
         * @private
         */
        this._contentParent =
                this.getElementsByClassName(this.CONTENT_PARENT_CLASSNAME,
                        'div')[0] || _createContentParent.call(this);

        /**
         * How the Tabs should be oriented relative to the TabView.
         * @config orientation
         * @type String
         * @default "top"
         */
        this.setAttributeConfig('orientation', {
            value: attr.orientation,
            method: function(value) {
                var current = this.get('orientation');
                //this.addClass('yui-navset-' + value);

                if (current != value) {
                    this.removeClass('yui-navset-' + current);
                }

                switch (value) {
                    case 'bottom':
                        this.appendChild(this._tabParent);
                        break;
                }
            }
        });

        /**
         * The index of the tab currently active.
         * @config activeIndex
         * @type Int
         */
        this.setAttributeConfig('activeIndex', {
            value: attr.activeIndex,
            method: function(value) {
                this.set('activeTab', this.getTab(value));
            },
            validator: function(value) {
                return !this.getTab(value).get('disabled'); // cannot activate if disabled
            }
        });

        /**
         * The tab currently active.
         * @config activeTab
         * @type pega.ui.Tab
         */
        this.setAttributeConfig('activeTab', {
            value: attr.activeTab,
            method: function(tab) {
                var activeTab = this.get('activeTab');

                if (tab) {
                    tab.set('active', true);
                    this._configs['activeIndex'].value = this.getTabIndex(tab); // keep in sync
                }

                if (activeTab && activeTab != tab) {
                    activeTab.set('active', false);
                }

                if (activeTab && tab != activeTab) { // no transition if only 1
                    this.contentTransition(tab, activeTab);
                } else if (tab) {
                    tab.set('contentVisible', true);
                }
            },
            validator: function(value) {
                return !value.get('disabled'); // cannot activate if disabled
            }
        });

        if (this._tabParent) {
            _initTabs.call(this);
        }

        for (var type in this.DOM_EVENTS) {
            if (pega.lang.hasOwnProperty(this.DOM_EVENTS, type)) {
                this.addListener.call(this, type, this.DOMEventHandler);
            }
        }
    };

    /**
     * Creates Tab instances from a collection of HTMLElements.
     * @method createTabs
     * @private
     * @param {Array|HTMLCollection} elements The elements to use for Tabs.
     * @return void
     */
    var _initTabs = function() {
        var tab,
                attr,
                contentEl;

        var el = this.get('element');
        var tabs = _getChildNodes(this._tabParent);
        var contentElements = _getChildNodes(this._contentParent);
        if (this._scrollContainer && contentElements.length == 0) {
            this._scrollContainer.style.display = "none";
        }
        for (var i = 0, len = tabs.length; i < len; ++i) {
            attr = {};

            if (contentElements[i]) {
                attr.contentEl = contentElements[i];
            }

            tab = new pega.ui.Tab(tabs[i], attr);
            this.addTab(tab);

            if (tab.hasClass(tab.ACTIVE_CLASSNAME)) {
                this._configs.activeTab.value = tab; // dont invoke method
            }
        }
    };

    var _createTabViewElement = function(attr) {
        var el = document.createElement('div');

        if (this.CLASSNAME) {
            el.className = this.CLASSNAME;
        }

        return el;
    };

    var _createTabParent = function(attr) {
        var el = document.createElement('ul');

        if (this.TAB_PARENT_CLASSNAME) {
            el.className = this.TAB_PARENT_CLASSNAME;
        }

        this.get('element').appendChild(el);

        return el;
    };

    var _createContentParent = function(attr) {
        var el = document.createElement('div');

        if (this.CONTENT_PARENT_CLASSNAME) {
            el.className = this.CONTENT_PARENT_CLASSNAME;
        }

        this.get('element').appendChild(el);

        return el;
    };

    var _getChildNodes = function(el) {
        var nodes = [];
        var childNodes = el.childNodes;

        for (var i = 0, len = childNodes.length; i < len; ++i) {
            if (childNodes[i].nodeType == 1) {
                nodes[nodes.length] = childNodes[i];
            }
        }

        return nodes;
    };
})();

(function() {
    var Dom = pega.util.Dom,
            Event = pega.util.Event;

    /**
     * A representation of a Tab's label and content.
     * @namespace pega.widget
     * @class Tab
     * @extends pega.util.Element
     * @constructor
     * @param element {HTMLElement | String} (optional) The html element that
     * represents the TabView. An element will be created if none provided.
     * @param {Object} properties A key map of initial properties
     */
    var Tab = function(el, attr) {
        attr = attr || {};
        if (arguments.length == 1 && !pega.lang.isString(el) && !el.nodeName) {
            attr = el;
            el = attr.element;
        }

        if (!el && !attr.element) {
            el = _createTabElement.call(this, attr);
        }

        this.loadHandler = {
            success: function(o) {
                this.set('content', o.responseText);
            },
            failure: function(o) {
                pega.log('loading failed: ' + o.statusText,
                        'error', 'Tab');
            }
        };

        Tab.superclass.constructor.call(this, el, attr);

        this.DOM_EVENTS = {}; // delegating to tabView
    };

    pega.extend(Tab, pega.util.Element);
    var proto = Tab.prototype;

    /**
     * The default tag name for a Tab's inner element.
     * @property LABEL_INNER_TAGNAME
     * @type String
     * @default "em"
     */
    proto.LABEL_TAGNAME = 'em';

    /**
     * The class name applied to active tabs.
     * @property ACTIVE_CLASSNAME
     * @type String
     * @default "on"
     */
    proto.ACTIVE_CLASSNAME = 'selected';

    /**
     * The class name applied to disabled tabs.
     * @property DISABLED_CLASSNAME
     * @type String
     * @default "disabled"
     */
    proto.DISABLED_CLASSNAME = 'disabled';

    /**
     * The class name applied to dynamic tabs while loading.
     * @property LOADING_CLASSNAME
     * @type String
     * @default "disabled"
     */
    proto.LOADING_CLASSNAME = 'loading';

    /**
     * Provides a reference to the connection request object when data is
     * loaded dynamically.
     * @property dataConnection
     * @type Object
     */
    proto.dataConnection = null;

    /**
     * Object containing success and failure callbacks for loading data.
     * @property loadHandler
     * @type object
     */
    proto.loadHandler = null;

    /**
     * Provides a readable name for the tab.
     * @method toString
     * @return String
     */
    proto.toString = function() {
        var el = this.get('element');
        var id = el.id || el.tagName;
        return "Tab " + id;
    };

    /**
     * setAttributeConfigs TabView specific properties.
     * @method initAttributes
     * @param {Object} attr Hash of initial attributes
     */
    proto.initAttributes = function(attr) {
        attr = attr || {};
        Tab.superclass.initAttributes.call(this, attr);

        var el = this.get('element');

        /**
         * The event that triggers the tab's activation.
         * @config activationEvent
         * @type String
         */
        this.setAttributeConfig('activationEvent', {
            value: attr.activationEvent || 'click'
        });

        /**
         * The element that contains the tab's label.
         * @config labelEl
         * @type HTMLElement
         */
        this.setAttributeConfig('labelEl', {
            value: attr.labelEl || _getlabelEl.call(this),
            method: function(value) {
                var current = this.get('labelEl');

                if (current) {
                    if (current == value) {
                        return false; // already set
                    }

                    this.replaceChild(value, current);
                } else if (el.firstChild) { // ensure label is firstChild by default
                    this.insertBefore(value, el.firstChild);
                } else {
                    this.appendChild(value);
                }
            }
        });

        /**
         * The tab's label text (or innerHTML).
         * @config label
         * @type String
         */
        this.setAttributeConfig('label', {
            value: attr.label || _getLabel.call(this),
            method: function(value) {
                var labelEl = this.get('labelEl');
                if (!labelEl) { // create if needed
                    this.set('labelEl', _createlabelEl.call(this));
                }

                _setLabel.call(this, value);
            }
        });

        /**
         * The HTMLElement that contains the tab's content.
         * @config contentEl
         * @type HTMLElement
         */
        this.setAttributeConfig('contentEl', {
            value: attr.contentEl || document.createElement('div'),
            method: function(value) {
                var current = this.get('contentEl');

                if (current) {
                    if (current == value) {
                        return false; // already set
                    }
                    this.replaceChild(value, current);
                }
            }
        });

        /**
         * The tab's content.
         * @config content
         * @type String
         */
        this.setAttributeConfig('content', {
            value: attr.content,
            method: function(value) {
                this.get('contentEl').innerHTML = value;
            }
        });

        var _dataLoaded = false;

        /**
         * The tab's data source, used for loading content dynamically.
         * @config dataSrc
         * @type String
         */
        this.setAttributeConfig('dataSrc', {
            value: attr.dataSrc
        });

        /**
         * Whether or not content should be reloaded for every view.
         * @config cacheData
         * @type Boolean
         * @default false
         */
        this.setAttributeConfig('cacheData', {
            value: attr.cacheData || false,
            validator: pega.lang.isBoolean
        });

        /**
         * The method to use for the data request.
         * @config loadMethod
         * @type String
         * @default "GET"
         */
        this.setAttributeConfig('loadMethod', {
            value: attr.loadMethod || 'GET',
            validator: pega.lang.isString
        });

        /**
         * Whether or not any data has been loaded from the server.
         * @config dataLoaded
         * @type Boolean
         */
        this.setAttributeConfig('dataLoaded', {
            value: false,
            validator: pega.lang.isBoolean,
            writeOnce: true
        });

        /**
         * Number if milliseconds before aborting and calling failure handler.
         * @config dataTimeout
         * @type Number
         * @default null
         */
        this.setAttributeConfig('dataTimeout', {
            value: attr.dataTimeout || null,
            validator: pega.lang.isNumber
        });

        /**
         * Whether or not the tab is currently active.
         * If a dataSrc is set for the tab, the content will be loaded from
         * the given source.
         * @config active
         * @type Boolean
         */
        this.setAttributeConfig('active', {
            value: attr.active || this.hasClass(this.ACTIVE_CLASSNAME),
            method: function(value) {
                if (value === true) {
                    this.addClass(this.ACTIVE_CLASSNAME);
                    Dom.addClass(this.get('element'), this.get('element').getAttribute("sel_prefix") + "-" + "selected");
                    // BUG-54795 12/13/2011 GUJAS1 Removed the title update on focus/blur of tab
                    // this.set('title', 'active');
                } else {
                    this.removeClass(this.ACTIVE_CLASSNAME);
                    Dom.removeClass(this.get('element'), this.get('element').getAttribute("sel_prefix") + "-" + "selected");
                    // BUG-54795 12/13/2011 GUJAS1 Removed the title update on focus/blur of tab
                    //this.set('title', '');
                }
            },
            validator: function(value) {
                return pega.lang.isBoolean(value) && !this.get('disabled');
            }
        });

        /**
         * Whether or not the tab is disabled.
         * @config disabled
         * @type Boolean
         */
        this.setAttributeConfig('disabled', {
            value: attr.disabled || this.hasClass(this.DISABLED_CLASSNAME),
            method: function(value) {
                if (value === true) {
                    Dom.addClass(this.get('element'), this.DISABLED_CLASSNAME);
                } else {
                    Dom.removeClass(this.get('element'), this.DISABLED_CLASSNAME);
                }
            },
            validator: pega.lang.isBoolean
        });

        /**
         * The href of the tab's anchor element.
         * @config href
         * @type String
         * @default '#'
         */
        this.setAttributeConfig('href', {
            value: attr.href || '#',
            method: function(value) {
                this.getElementsByTagName('a')[0].href = value;
            },
            validator: pega.lang.isString
        });

        /**
         * The Whether or not the tab's content is visible.
         * @config contentVisible
         * @type Boolean
         * @default false
         */
        this.setAttributeConfig('contentVisible', {
            value: attr.contentVisible,
            method: function(value) {
                var contentEl = this.get('contentEl');
                if (value) {
                    if (contentEl.style.display != "" && contentEl.style.display != "block")
                        contentEl.style.display = 'block';
                    if (this.get('dataSrc')) {
                        // load dynamic content unless already loaded and caching
                        if (!this.get('dataLoaded') || !this.get('cacheData')) {
                            _dataConnect.call(this);
                        }
                    }
                } else if (contentEl.style.display != "none") {
                    contentEl.style.display = 'none';
                  	/*SE-37672 : calling scrollIntoViewIfOutOfView for active accordion to be in view*/
                    var parentUl = this.get('element').parentNode;
                  	var liEl = parentUl && parentUl.getElementsByClassName('selected') && parentUl.getElementsByClassName('selected').length > 0 && parentUl.getElementsByClassName('selected')[0];
                  	var anchorEl = liEl && pega.util.Dom.getElementsById('ACCORANCHOR', liEl) && pega.util.Dom.getElementsById('ACCORANCHOR', liEl).length > 0 && pega.util.Dom.getElementsById('ACCORANCHOR', liEl)[0];
                  	anchorEl && pega.u.d.scrollIntoViewIfOutOfView(anchorEl);
                  
                }
            },
            validator: pega.lang.isBoolean
        });
    };

    var _createTabElement = function(attr) {
        //If user is already specifying syntactically proper LI to be added, just set this li as the labelEl.
        if (attr && attr.labelEl && attr.labelEl.tagName == 'LI') {
            return attr.labelEl;
        }
        var el = document.createElement('li');
        var a = document.createElement('a');

        a.href = attr.href || '#';

        el.appendChild(a);

        var label = attr.label || null;
        var labelEl = attr.labelEl || null;

        if (labelEl) { // user supplied labelEl
            if (!label) { // user supplied label
                label = _getLabel.call(this, labelEl);
            }
        } else {
            labelEl = _createlabelEl.call(this);
        }

        a.appendChild(labelEl);

        return el;
    };

    var _getlabelEl = function() {
        return this.getElementsByTagName(this.LABEL_TAGNAME)[0];
    };

    var _createlabelEl = function() {
        var el = document.createElement(this.LABEL_TAGNAME);
        return el;
    };

    var _setLabel = function(label) {
        var el = this.get('labelEl');
        el.innerHTML = label;
    };

    var _getLabel = function() {
        var label,
                el = this.get('labelEl');

        if (!el) {
            return undefined;
        }

        return el.innerHTML;
    };

    var _dataConnect = function() {
        if (!pega.util.Connect) {
            pega.log('pega.util.Connect dependency not met',
                    'error', 'Tab');
            return false;
        }

        Dom.addClass(this.get('contentEl').parentNode, this.LOADING_CLASSNAME);

        this.dataConnection = pega.util.Connect.asyncRequest(
                this.get('loadMethod'),
                this.get('dataSrc'),
                {
                    success: function(o) {
                        this.loadHandler.success.call(this, o);
                        this.set('dataLoaded', true);
                        this.dataConnection = null;
                        Dom.removeClass(this.get('contentEl').parentNode,
                                this.LOADING_CLASSNAME);
                    },
                    failure: function(o) {
                        this.loadHandler.failure.call(this, o);
                        this.dataConnection = null;
                        Dom.removeClass(this.get('contentEl').parentNode,
                                this.LOADING_CLASSNAME);
                    },
                    scope: this,
                    timeout: this.get('dataTimeout')
                }
        );
    };
    pega.ui.Tab = Tab;
})();
//static-content-hash-trigger-GCC
pega.namespace("pega.desktop");

// BEGIN RESIZEPANEL SUBCLASS //
pega.widget.ResizePanel = function(el, userConfig) {
	if (arguments.length > 0) {
		pega.widget.ResizePanel.superclass.constructor.call(this, el, userConfig);
	}
}

pega.extend(pega.widget.ResizePanel, pega.widget.Panel);

pega.widget.ResizePanel.CSS_PANEL_RESIZE = "resizepanel";
pega.widget.ResizePanel.CSS_RESIZE_HANDLE = "resizehandle";

pega.widget.ResizePanel.prototype.init = function(el, userConfig) {
	
	pega.widget.ResizePanel.superclass.init.call(this, el);
	this.createEvent("resizeEvent");
	this.beforeInitEvent.fire(pega.widget.ResizePanel);
	pega.util.Dom.addClass(this.innerElement, pega.widget.ResizePanel.CSS_PANEL_RESIZE);

	this.resizeHandle = document.createElement("div");
	this.resizeHandle.id = this.id + "_r";
	this.resizeHandle.className = pega.widget.ResizePanel.CSS_RESIZE_HANDLE;
	this.beforeRenderEvent.subscribe(function() {
		if (! this.footer) {
			this.setFooter("");
		}
	},
	this, true
	);

	this.renderEvent.subscribe(function() {
		var me = this;
		/*Attach drag drop to modal dialog header*/
		this.ddDragdrop = new pega.util.DD('modaldialog_c');		
		this.ddDragdrop.addInvalidHandleType("INPUT");
		this.ddDragdrop.addInvalidHandleType("TEXTAREA");
		this.ddDragdrop.addInvalidHandleType("SELECT");
		this.ddDragdrop.addInvalidHandleType("LABEL");
		this.ddDragdrop.addInvalidHandleType("BUTTON");
		this.ddDragdrop.addInvalidHandleType("IMG");

		this.ddDragdrop.startDrag = function() {
			var offsetHeight,
			offsetWidth,
			viewPortWidth,
			viewPortHeight,
			scrollX,
			scrollY;
			if (me.cfg.getProperty("constraintoviewport")) {
								
				var nViewportOffset = pega.widget.Overlay.VIEWPORT_OFFSET;
				offsetHeight = me.element.offsetHeight;
				offsetWidth = me.element.offsetWidth;

				viewPortWidth = pega.util.Dom.getViewportWidth();
				viewPortHeight = pega.util.Dom.getViewportHeight();
								
				scrollX = pega.util.Dom.getDocumentScrollLeft();
				scrollY = pega.util.Dom.getDocumentScrollTop();
			
				if (offsetHeight + nViewportOffset < viewPortHeight) {
					this.minY = scrollY + nViewportOffset;
					this.maxY = scrollY + viewPortHeight - offsetHeight - nViewportOffset;
				} else {
					this.minY = scrollY + nViewportOffset;
					this.maxY = scrollY + nViewportOffset;
				}
								
				if (offsetWidth + nViewportOffset < viewPortWidth) {
					this.minX = scrollX + nViewportOffset;
					this.maxX = scrollX + viewPortWidth - offsetWidth - nViewportOffset;
				} else {
					this.minX = scrollX + nViewportOffset;
					this.maxX = scrollX + nViewportOffset;
				}

				this.constrainX = true;
				this.constrainY = true;
			} else {
				this.constrainX = false;
				this.constrainY = false;
			}
							
 		me.dragEvent.fire("startDrag", arguments);

		};
						
		this.ddDragdrop.endDrag = function(){
			me.syncPosition();
			me.cfg.refireEvent("iframe");
			if (this.platform == "mac" && pega.env.ua.gecko) {
				this.showMacGeckoScrollbars();
			}
			me.dragEvent.fire("onDrag", arguments);
		};		

		me.innerElement.appendChild(me.resizeHandle);
		this.ddResize = new pega.util.DragDrop(this.resizeHandle.id,this.id);
		this.ddResize.setHandleElId(this.resizeHandle.id);
		this.ddResize.onMouseDown = function(e) {
			this.startWidth = me.innerElement.offsetWidth;
			this.startHeight = me.innerElement.offsetHeight;

			me.cfg.setProperty("width", this.startWidth + "px");
			me.cfg.setProperty("height", this.startHeight + "px");
			this.startPos = [pega.util.Event.getPageX(e),
			pega.util.Event.getPageY(e)];

			me.innerElement.style.overflow = "hidden";
			var modalDialogBody = document.getElementById("modaldialog_bd");
			if(!pega.util.Event.isIE){
				modalDialogBody.style.height = "auto";
			}
			var modalDialogContent = $("#modaldialog_con", document.getElementById("modaldialog")).get(0);
			if(modalDialogContent) {
				while(modalDialogContent.parentNode.nodeName != "DIV"){
					modalDialogContent = modalDialogContent.parentNode;
				}
				modalDialogContent = modalDialogContent.parentNode;
			}else {
				modalDialogContent = modalDialogBody;
			}
			me.body = modalDialogContent;
			me.body.style.overflow = "auto";
		}
		
		this.ddResize.endDrag = function(e) {
			var adjustment = 2;
			/*var adjustHeight = 20;
			if(pega.util.Event.isIE) {
				adjustHeight = 50;
			}*/

			//BUG-58180 12/29/2011 KODUC removing the extra space for the modal dialog		
			var adjustHeight = document.getElementById("modaldialog_ft").offsetHeight;
			//End of the BUG-58180

			var dimensionObj = {height: "0px", width: "0px"};
			var newPos = [pega.util.Event.getPageX(e), pega.util.Event.getPageY(e)];
			var offsetX = newPos[0] - this.startPos[0];
			var offsetY = newPos[1] - this.startPos[1];

			//BUG-55153 1-12-2011 KODUC setting content height and width based on the modal dialog height and width
			//var newWidth = Math.max(this.startWidth + offsetX, 10);
			//var newHeight = Math.max(this.startHeight + offsetY, 10);
			//dimensionObj.height = newHeight;
			//dimensionObj.width = newWidth;
			
			var newWidth = this.actualWidth;
			var newHeight = this.actualHeight;
			dimensionObj.height = this.actualHeight;
			dimensionObj.width = this.actualWidth;
			//End of BUG-55153
			
			var modalDialogBody = document.getElementById("modaldialog_bd");
			var modalDialogContent = $("#modaldialog_con", document.getElementById("modaldialog")).get(0);
			if(modalDialogContent) {
				while(modalDialogContent.parentNode.nodeName != "DIV"){
					modalDialogContent = modalDialogContent.parentNode;
				}
				modalDialogContent = modalDialogContent.parentNode;
			}
			else {
				modalDialogContent = modalDialogBody;
			}
			var actionIframe = window.parent.frames.actionIFrame;
			var actionIframeSec = false;
			if(typeof(actionIframe)!="undefined"){			
				pega.u.d.resizeActionIFrame(false);
				actionIframeSec = true;
			}
			var headerHeight = 0;
			var buttonsHeight = 0;
			var sectionTable = pega.util.Dom.getElementsById("EXPAND-OUTERFRAME", document.getElementById("modaldialog_bd"), "TABLE");
			if(sectionTable != null){
				sectionTable = sectionTable[0];				
				var buttonsTable = sectionTable.nextSibling;
				if(buttonsTable != null){
					while(buttonsTable.nodeType !=1){
						buttonsTable = buttonsTable.nextSibling;
						if(buttonsTable == null) break;
					}
					if(buttonsTable != null) {
						buttonsHeight = buttonsTable.offsetHeight;
					}
				}
			}
			if(document.getElementById("modaldialog_hd") != null ){
				headerHeight = document.getElementById("modaldialog_hd").offsetHeight;
			}
			//BUG-58180 12/29/2011 KODUC removing the extra space for the modal dialog. This code is added so that modal dialogs in DCO will not break when buttons height not able to get
			if(buttonsHeight == 0){
				buttonsHeight = 40;
			}
			//End of BUG-58180


			//BUG-81883 : issue with modaldialog resizing.
			//document.getElementById("modaldialog_bd").style.overflow = "hidden";
			document.getElementById("modaldialog_bd").style.overflow = pega.u.d.useOldModalDialog ? "visible":"hidden";

			if( newHeight <= (headerHeight + buttonsHeight) ){
				modalDialogContent.style.height = (headerHeight + buttonsHeight + 20) + 'px';
			}else if((newHeight - (headerHeight + buttonsHeight + adjustHeight)) > 0 ){
				modalDialogContent.style.height = (dimensionObj.height - headerHeight - buttonsHeight - adjustHeight + 5) + 'px';
			}else{
				modalDialogContent.style.height = (dimensionObj.height - headerHeight - buttonsHeight + 5) + 'px';
			}
			//BUG-59071 koduc 1/4/2012 to extra spaces in the modal dialog if Buttons Table is not present
			var modalDialog = document.getElementById("modaldialog");
			var modalDialogHeight = modalDialog.offsetHeight;
			var modalDialogFeet = document.getElementById("modaldialog_ft");
			var differenceHeight = modalDialogFeet.offsetTop + modalDialogFeet.offsetHeight;
			

			if(modalDialogHeight != differenceHeight){				
				//BUG-81883 : issue with modaldialog resizing.
				modalDialog.style.height = ((modalDialogHeight > differenceHeight)? modalDialogHeight : differenceHeight) + 'px';
			}
			//End of BUG-59071
			modalDialogContent.style.width = (dimensionObj.width - adjustment) + 'px';
			me.body = document.getElementById("modaldialog_bd");
			
		}
		
		this.ddResize.onDrag = function(e) {
			var newPos = [pega.util.Event.getPageX(e), pega.util.Event.getPageY(e)];
			var offsetX = newPos[0] - this.startPos[0];
			var offsetY = newPos[1] - this.startPos[1];
			var newWidth = Math.max(this.startWidth + offsetX, 10);
			var newHeight = Math.max(this.startHeight + offsetY, 10);

			//BUG-55153  1-12-2011 KODUC setting content min height and min width to the modal dialog 
			this.actualWidth = newWidth;
			this.actualHeight = newHeight;
			if(newWidth<=300){
				newWidth = this.actualWidth = 300;
			}
			if(newHeight<=200){
				newHeight  = this.actualHeight = 200;
			}
			//End of BUG-55153
	
			me.cfg.setProperty("width", newWidth + "px");
			me.cfg.setProperty("height", newHeight + "px");
			
			var headerHeight = 0;
			var buttonsHeight = 0;
			var sectionTable = pega.util.Dom.getElementsById("EXPAND-OUTERFRAME", document.getElementById("modaldialog_bd"), "TABLE");
			if(sectionTable != null){
				sectionTable = sectionTable[0];				
				var buttonsTable = sectionTable.nextSibling;
				if(buttonsTable != null){
					while(buttonsTable.nodeType !=1){
						buttonsTable = buttonsTable.nextSibling;
						if(buttonsTable == null) break;
					}
					if(buttonsTable != null) {
						buttonsHeight = buttonsTable.offsetHeight;
					}
				}
			}
			if(document.getElementById("modaldialog_hd") != null ){
				headerHeight = document.getElementById("modaldialog_hd").offsetHeight;
			}
			var borderElements = pega.util.Dom.getElementsById("mCurve",document.getElementById("modaldialog"));
			var borderElementsHt = 0;
			if(borderElements) {
				var borderEleLen = borderElements.length;
				for(var i = 0; i<borderEleLen; i++) {
					borderElementsHt += borderElements[i].clientHeight;
					if(pega.util.Dom.getStyle(borderElements[i],"display") == 'none') {
						borderElementsHt = 0;
						break;
					}
				}
			}
			var modalDialogBody = document.getElementById("modaldialog_bd");
			modalDialogBody.style.overflowX = "hidden";
			var modalDialogContent = $("#modaldialog_con", document.getElementById("modaldialog")).get(0);
			if(modalDialogContent) {
				while(modalDialogContent.parentNode.nodeName != "DIV"){
				modalDialogContent = modalDialogContent.parentNode;
				}
				modalDialogContent = modalDialogContent.parentNode;
			}
			else {
				modalDialogContent = modalDialogBody;
			}			
			modalDialogContent.style.width = newWidth + 'px';
			
			if( newHeight <= (headerHeight + buttonsHeight) ){
				modalDialogContent.style.height = (headerHeight + buttonsHeight + 15) + 'px';
			}else if((newHeight - (headerHeight + buttonsHeight + borderElementsHt + 40)) > 0 ){
				modalDialogContent.style.height = (newHeight - (headerHeight + buttonsHeight + borderElementsHt + 40)) + 'px';
			}
			var innerHeight = me.innerElement.offsetHeight;
			var innerWidth = me.innerElement.offsetWidth;
			if (innerWidth < 20) {
				me.innerElement.style.width = "20px";
			}
			me.fireEvent("resizeEvent", {ev: "resizeEvent", target: me});
		}

	}, this, true);

	if (userConfig) {
		this.cfg.applyConfig(userConfig, true);
	}
	this.initEvent.fire(pega.widget.ResizePanel);
};

// BEGIN BUILT-IN PROPERTY EVENT HANDLERS //

/**
* The default event handler fired when the "close" property is changed. The method controls the appending or hiding of the close icon at the top right of the Panel.
* @method configClose
* @param {String} type	The CustomEvent type (usually the property name)
* @param {Object[]}	args	The CustomEvent arguments. For configuration handlers, args[0] will equal the newly applied value for the property.
* @param {Object} obj	The scope object. For configuration handlers, this will usually equal the owner.
*/
pega.widget.ResizePanel.prototype.configClose = function(type, args, obj) {
	var val = args[0];
	var doHide = function(e, obj) {
		obj.hide();
	};
	if (val) {
		if (! this.close) {
			this.close = document.createElement("span");
			pega.util.Dom.addClass(this.close, "container-close");
			this.close.innerHTML = "&#160;";
			this.innerElement.appendChild(this.close);
			pega.util.Event.addListener(this.close, "click", doHide, this);
		} else {
			this.close.style.display = "block";
		}
	} else {
		if (this.close) {
			this.close.style.display = "none";
		}
	}
};
//static-content-hash-trigger-GCC
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.1
*/
/**
 * Provides methods to parse JSON strings and convert objects to JSON strings.
 *
 * @module json
 * @class JSON
 * @namespace pega.lang
 * @static
 */
(function () {

var l = pega.lang,
    isFunction = l.isFunction,
    isObject   = l.isObject,
    isArray    = l.isArray,
    _toStr     = Object.prototype.toString,
                 // 'this' is the global object.  window in browser env.  Keep
                 // the code env agnostic.  Caja requies window, unfortunately.
    Native     = (pega.env.ua.caja ? window : this).JSON,

/* Variables used by parse */

    /**
     * Replace certain Unicode characters that JavaScript may handle incorrectly
     * during eval--either by deleting them or treating them as line
     * endings--with escape sequences.
     * IMPORTANT NOTE: This regex will be used to modify the input if a match is
     * found.
     *
     * @property _UNICODE_EXCEPTIONS
     * @type {RegExp}
     * @private
     */
    _UNICODE_EXCEPTIONS = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,

    /**
     * First step in the safety evaluation.  Regex used to replace all escape
     * sequences (i.e. "\\", etc) with '@' characters (a non-JSON character).
     *
     * @property _ESCAPES
     * @type {RegExp}
     * @static
     * @private
     */
    _ESCAPES = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,

    /**
     * Second step in the safety evaluation.  Regex used to replace all simple
     * values with ']' characters.
     *
     * @property _VALUES
     * @type {RegExp}
     * @static
     * @private
     */
    _VALUES  = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,

    /**
     * Third step in the safety evaluation.  Regex used to remove all open
     * square brackets following a colon, comma, or at the beginning of the
     * string.
     *
     * @property _BRACKETS
     * @type {RegExp}
     * @static
     * @private
     */
    _BRACKETS = /(?:^|:|,)(?:\s*\[)+/g,

    /**
     * Final step in the safety evaluation.  Regex used to test the string left
     * after all previous replacements for invalid characters.
     *
     * @property _UNSAFE
     * @type {RegExp}
     * @static
     * @private
     */
    _UNSAFE  = /^[\],:{}\s]*$/,


/* Variables used by stringify */

    /**
     * Regex used to replace special characters in strings for JSON
     * stringification.
     *
     * @property _SPECIAL_CHARS
     * @type {RegExp}
     * @static
     * @private
     */
    _SPECIAL_CHARS = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,

    /**
     * Character substitution map for common escapes and special characters.
     *
     * @property _CHARS
     * @type {Object}
     * @static
     * @private
     */
    _CHARS = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    
    UNDEFINED = 'undefined',
    OBJECT    = 'object',
    NULL      = 'null',
    STRING    = 'string',
    NUMBER    = 'number',
    BOOLEAN   = 'boolean',
    DATE      = 'date',
    _allowable = {
        'undefined'        : UNDEFINED,
        'string'           : STRING,
        '[object String]'  : STRING,
        'number'           : NUMBER,
        '[object Number]'  : NUMBER,
        'boolean'          : BOOLEAN,
        '[object Boolean]' : BOOLEAN,
        '[object Date]'    : DATE,
        '[object RegExp]'  : OBJECT
    },
    EMPTY     = '',
    OPEN_O    = '{',
    CLOSE_O   = '}',
    OPEN_A    = '[',
    CLOSE_A   = ']',
    COMMA     = ',',
    COMMA_CR  = ",\n",
    CR        = "\n",
    COLON     = ':',
    COLON_SP  = ': ',
    QUOTE     = '"';

// Only accept JSON objects that report a [[Class]] of JSON
Native = _toStr.call(Native) === '[object JSON]' && Native;

// Escapes a special character to a safe Unicode representation
function _char(c) {
    if (!_CHARS[c]) {
        _CHARS[c] =  '\\u'+('0000'+(+(c.charCodeAt(0))).toString(16)).slice(-4);
    }
    return _CHARS[c];
}


/* functions used by parse */

/**
 * Traverses nested objects, applying a filter or reviver function to
 * each value.  The value returned from the function will replace the
 * original value in the key:value pair.  If the value returned is
 * undefined, the key will be omitted from the returned object.
 *
 * @method _revive
 * @param data {MIXED} Any JavaScript data
 * @param reviver {Function} filter or mutation function
 * @return {MIXED} The results of the filtered/mutated data structure
 * @private
 */
function _revive(data, reviver) {
    var walk = function (o,key) {
        var k,v,value = o[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (l.hasOwnProperty(value,k)) {
                    v = walk(value, k);
                    if (v === undefined) {
                        delete value[k];
                    } else {
                        value[k] = v;
                    }
                }
            }
        }
        return reviver.call(o,key,value);
    };

    return typeof reviver === 'function' ? walk({'':data},'') : data;
}

/**
 * Replace certain Unicode characters that may be handled incorrectly by
 * some browser implementations.
 *
 * @method _prepare
 * @param s {String} parse input
 * @return {String} sanitized JSON string ready to be validated/parsed
 * @private
 */
function _prepare(s) {
    return s.replace(_UNICODE_EXCEPTIONS, _char);
}

function _isSafe(str) {
    return l.isString(str) &&
            _UNSAFE.test(str.replace(_ESCAPES,'@').
                             replace(_VALUES,']').
                             replace(_BRACKETS,''));
}

function _parse(s,reviver) {
    // sanitize
    s = _prepare(s);

    // Ensure valid JSON
    if (_isSafe(s)) {
        // Eval the text into a JavaScript data structure, apply the
        // reviver function if provided, and return
        return _revive( eval('(' + s + ')'), reviver );
    }

    // The text is not valid JSON
    throw new SyntaxError('JSON.parse');
}



/* functions used by stringify */

// Utility function used to determine how to serialize a variable.
function _type(o) {
    var t = typeof o;
    return  _allowable[t] ||              // number, string, boolean, undefined
            _allowable[_toStr.call(o)] || // Number, String, Boolean, Date
            (t === OBJECT ?
                (o ? OBJECT : NULL) :     // object, array, null, misc natives
                UNDEFINED);               // function, unknown
}

// Enclose escaped strings in quotes
function _string(s) {
    return QUOTE + s.replace(_SPECIAL_CHARS, _char) + QUOTE;
}

// Adds the provided space to the beginning of every line in the input string
function _indent(s,space) {
    return s.replace(/^/gm, space);
}

// JavaScript implementation of stringify (see API declaration of stringify)
function _stringify(o,w,space) {
    if (o === undefined) {
        return undefined;
    }

    var replacer = isFunction(w) ? w : null,
        format   = _toStr.call(space).match(/String|Number/) || [],
        _date    = pega.lang.JSON.dateToString,
        stack    = [],
        tmp,i,len;

    if (replacer || !isArray(w)) {
        w = undefined;
    }

    // Ensure whitelist keys are unique (bug 2110391)
    if (w) {
        tmp = {};
        for (i = 0, len = w.length; i < len; ++i) {
            tmp[w[i]] = true;
        }
        w = tmp;
    }

    // Per the spec, strings are truncated to 10 characters and numbers
    // are converted to that number of spaces (max 10)
    space = format[0] === 'Number' ?
                new Array(Math.min(Math.max(0,space),10)+1).join(" ") :
                (space || EMPTY).slice(0,10);

    function _serialize(h,key) {
        var value = h[key],
            t     = _type(value),
            a     = [],
            colon = space ? COLON_SP : COLON,
            arr, i, keys, k, v;

        // Per the ECMA 5 spec, toJSON is applied before the replacer is
        // called.  Also per the spec, Date.prototype.toJSON has been added, so
        // Date instances should be serialized prior to exposure to the
        // replacer.  I disagree with this decision, but the spec is the spec.
        if (isObject(value) && isFunction(value.toJSON)) {
            value = value.toJSON(key);
        } else if (t === DATE) {
            value = _date(value);
        }

        if (isFunction(replacer)) {
            value = replacer.call(h,key,value);
        }

        if (value !== h[key]) {
            t = _type(value);
        }

        switch (t) {
            case DATE    : // intentional fallthrough.  Pre-replacer Dates are
                           // serialized in the toJSON stage.  Dates here would
                           // have been produced by the replacer.
            case OBJECT  : break;
            case STRING  : return _string(value);
            case NUMBER  : return isFinite(value) ? value+EMPTY : NULL;
            case BOOLEAN : return value+EMPTY;
            case NULL    : return NULL;
            default      : return undefined;
        }

        // Check for cyclical references in nested objects
        for (i = stack.length - 1; i >= 0; --i) {
            if (stack[i] === value) {
                throw new Error("JSON.stringify. Cyclical reference");
            }
        }

        arr = isArray(value);

        // Add the object to the processing stack
        stack.push(value);

        if (arr) { // Array
            for (i = value.length - 1; i >= 0; --i) {
                a[i] = _serialize(value, i) || NULL;
            }
        } else {   // Object
            // If whitelist provided, take only those keys
            keys = w || value;
            i = 0;

            for (k in keys) {
                if (keys.hasOwnProperty(k)) {
                    v = _serialize(value, k);
                    if (v) {
                        a[i++] = _string(k) + colon + v;
                    }
                }
            }
        }

        // remove the array from the stack
        stack.pop();

        if (space && a.length) {
            return arr ?
                OPEN_A + CR + _indent(a.join(COMMA_CR), space) + CR + CLOSE_A :
                OPEN_O + CR + _indent(a.join(COMMA_CR), space) + CR + CLOSE_O;
        } else {
            return arr ?
                OPEN_A + a.join(COMMA) + CLOSE_A :
                OPEN_O + a.join(COMMA) + CLOSE_O;
        }
    }

    // process the input
    return _serialize({'':o},'');
}


/* Public API */
pega.lang.JSON = {
    /**
     * Leverage native JSON parse if the browser has a native implementation.
     * In general, this is a good idea.  See the Known Issues section in the
     * JSON user guide for caveats.  The default value is true for browsers with
     * native JSON support.
     *
     * @property useNativeParse
     * @type Boolean
     * @default true
     * @static
     */
    useNativeParse : !!Native,

    /**
     * Leverage native JSON stringify if the browser has a native
     * implementation.  In general, this is a good idea.  See the Known Issues
     * section in the JSON user guide for caveats.  The default value is true
     * for browsers with native JSON support.
     *
     * @property useNativeStringify
     * @type Boolean
     * @default true
     * @static
     */
    useNativeStringify : !!Native,

    /**
     * Four step determination whether a string is safe to eval. In three steps,
     * escape sequences, safe values, and properly placed open square brackets
     * are replaced with placeholders or removed.  Then in the final step, the
     * result of all these replacements is checked for invalid characters.
     *
     * @method isSafe
     * @param str {String} JSON string to be tested
     * @return {boolean} is the string safe for eval?
     * @static
     */
    isSafe : function (s) {
        return _isSafe(_prepare(s));
    },

    /**
     * <p>Parse a JSON string, returning the native JavaScript
     * representation.</p>
     *
     * <p>When lang.JSON.useNativeParse is true, this will defer to the native
     * JSON.parse if the browser has a native implementation.  Otherwise, a
     * JavaScript implementation based on http://www.json.org/json2.js
     * is used.</p>
     *
     * @method parse
     * @param s {string} JSON string data
     * @param reviver {function} (optional) function(k,v) passed each key:value
     *          pair of object literals, allowing pruning or altering values
     * @return {MIXED} the native JavaScript representation of the JSON string
     * @throws SyntaxError
     * @static
     */
    parse : function (s,reviver) {
        return Native && pega.lang.JSON.useNativeParse ?
            Native.parse(s,reviver) : _parse(s,reviver);
    },

    /**
     * <p>Converts an arbitrary value to a JSON string representation.</p>
     *
     * <p>Objects with cyclical references will trigger an exception.</p>
     *
     * <p>If a whitelist is provided, only matching object keys will be
     * included.  Alternately, a replacer function may be passed as the
     * second parameter.  This function is executed on every value in the
     * input, and its return value will be used in place of the original value.
     * This is useful to serialize specialized objects or class instances.</p>
     *
     * <p>If a positive integer or non-empty string is passed as the third
     * parameter, the output will be formatted with carriage returns and
     * indentation for readability.  If a String is passed (such as "\t") it
     * will be used once for each indentation level.  If a number is passed,
     * that number of spaces will be used.</p>
     *
     * <p>When lang.JSON.useNativeStringify is true, this will defer to the
     * native JSON.stringify if the browser has a native implementation.
     * Otherwise, a JavaScript implementation is used.</p>
     *
     * @method stringify
     * @param o {MIXED} any arbitrary object to convert to JSON string
     * @param w {Array|Function} (optional) whitelist of acceptable object keys
     *                  to include OR a function(value,key) to alter values
     *                  before serialization
     * @param space {Number|String} (optional) indentation character(s) or
     *                  depthy of spaces to format the output 
     * @return {string} JSON string representation of the input
     * @throws Error
     * @static
     */
    stringify : function (o,w,space) {
        return Native && pega.lang.JSON.useNativeStringify ?
            Native.stringify(o,w,space) : _stringify(o,w,space);
    },

    /**
     * Serializes a Date instance as a UTC date string.  Used internally by
     * the JavaScript implementation of stringify.  If you need a different
     * Date serialization format, override this method.  If you change this,
     * you should also set useNativeStringify to false, since native JSON
     * implementations serialize Dates per the ECMAScript 5 spec.  You've been
     * warned.
     *
     * @method dateToString
     * @param d {Date} The Date to serialize
     * @return {String} stringified Date in UTC format YYYY-MM-DDTHH:mm:SSZ
     * @static
     */
    dateToString : function (d) {
        function _zeroPad(v) {
            return v < 10 ? '0' + v : v;
        }

        return d.getUTCFullYear()         + '-' +
            _zeroPad(d.getUTCMonth() + 1) + '-' +
            _zeroPad(d.getUTCDate())      + 'T' +
            _zeroPad(d.getUTCHours())     + COLON +
            _zeroPad(d.getUTCMinutes())   + COLON +
            _zeroPad(d.getUTCSeconds())   + 'Z';
    },

    /**
     * Reconstitute Date instances from the default JSON UTC serialization.
     * Reference this from a reviver function to rebuild Dates during the
     * parse operation.
     *
     * @method stringToDate
     * @param str {String} String serialization of a Date
     * @return {Date}
     */
    stringToDate : function (str) {
        var m = str.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d{3}))?Z$/);
        if (m) {
            var d = new Date();
            d.setUTCFullYear(m[1], m[2]-1, m[3]);
            d.setUTCHours(m[4], m[5], m[6], (m[7] || 0));
            return d;
        }
        return str;
    }
};

/**
 * <p>Four step determination whether a string is safe to eval. In three steps,
 * escape sequences, safe values, and properly placed open square brackets
 * are replaced with placeholders or removed.  Then in the final step, the
 * result of all these replacements is checked for invalid characters.</p>
 *
 * <p>This is an alias for isSafe.</p>
 *
 * @method isValid
 * @param str {String} JSON string to be tested
 * @return {boolean} is the string safe for eval?
 * @static
 * @deprecated use isSafe
 */
pega.lang.JSON.isValid = pega.lang.JSON.isSafe;

})();
pega.register("json", pega.lang.JSON, {version: "2.8.1", build: "19"});
//static-content-hash-trigger-GCC
(function (p) {
    var NULL = null; /*This should be used instead of null, since this helps the compaction, which cannot compact the null keyword.*/
    var _iframeShimMarkupTemplate = '<iframe  id="poi{0}" src="about:blank" class="pz-po-ci"></iframe>';
    var _loaderMarkupTemplate = '<div id="pol{0}" class="pega_ui_busyIndicator pz-po-l" ><div style="width:20px; height:20px"></div></div>';
    var _contentMarkupTemplate = '<div id="po{0}" class="pz-po-c"><ul class="pz-po-c-ul"><li><div id="arrow{0}" class="po-arrow-hide"><div class="border" id="arrow-border"></div></div><div id="poc{0}"></div></li><li id="pohr{0}" class="pz-po-c-hr"></li><li id="pob{0}" style="text-align:center;"></li></ul></div>';
    /* Changed the buttonsMarkupTemplate to support the new markup  US-113511*/
    var _buttonsMarkupTemplate = '<button type="button" class="pzhc pzbutton" onclick="pega.u.d.getPopOver({0}).close(\'{1}\');"><img class="pzbtn-i" src="webwb/zblankimage.gif"/>{2}</button>&nbsp;';
    //'<button onclick="pega.u.d.getPopOver({0}).close(\'{1}\');">{2}</button>';
    /* var _buttonsMarkupTemplate = '<button type="button" class="pzhc" onclick="pega.u.d.getPopOver({0}).close(\'{1}\');"><div class="pzbtn-rnd"><div class="pzbtn-lft" ><div class="pzbtn-rgt"><div class="pzbtn-mid"><img class="pzbtn-i" src="webwb/zblankimage.gif"/>{2}</div></div></div></div></button>&nbsp;'; */
    var _hostContainer = NULL;
    var _popOversContainer = document.createElement("div");
    _popOversContainer.style.zIndex = 100;
    /* BUG-73191: Before changing the Z-Index here look into pega_ui_menubar.js, increase the Z-Index of menubar also to the same proportion */

    _popOversContainer.id = "_popOversContainer";
    var _isInsideFormTag = false;
    var _isInScreenLayout = null;
    var navUserAgent = navigator.userAgent;
    var isMobile =  navUserAgent.match(/Android/i) || navUserAgent.match(/BlackBerry/i) || navUserAgent.match(/iPhone|iPad|iPod/i) || navUserAgent.match(/Opera Mini/i) || navUserAgent.match(/IEMobile/i);
    function setIsScreenLayout() {
        try {
            if (!pega.u.d.ServerProxy.isDestinationLocal()) {
                var screenLayout = $(".screen-layout");
                if (screenLayout && screenLayout.length >= 1 && ("absolute" == $(".screen-layout-region-main-middle").css("position") || "absolute" == $(".screen-layout-region-main-sidebar1").css("position"))) {
                    _isInScreenLayout = true;
                } else {
                    _isInScreenLayout = false;
                }
            } else {
                _isInScreenLayout = false;
            }
        } catch (e) { _isInScreenLayout = false; }
    }

  // BUG-576371
    p.u.d.closeOverlayHandler = function(layoutInfo) {
      try {
        var popoverElement, popover;
        var shouldPopoverBeClosed = false;
        // if layout info passed on 

        if(layoutInfo && layoutInfo.inactiveTab) {
          popoverElement = pega.u.d.getPopOver(layoutInfo.inactiveTab).getActivePopOverElement();
          popover = pega.u.d.getPopOver(layoutInfo.inactiveTab);
          shouldPopoverBeClosed = true;
      
          var level = popover.getLevel();
          if(level === 0) {
            // check if associated element belong to layout
            var element = popover.getAssociatedElement();
            shouldPopoverBeClosed = pega.util.Dom.isAncestor(layoutInfo.layoutBody, element);
          }
        } else {
          popoverElement = pega.u.d.getPopOver().getActivePopOverElement();
          popover = pega.u.d.getPopOver();
          shouldPopoverBeClosed = true;
        }

        if(shouldPopoverBeClosed && popoverElement && popoverElement.className.indexOf("overlayPO") !== -1) {
          popover.close();
        } 
      } catch(e) { 
    }
  };
  
    pega.ui.EventsEmitter.subscribe("onUnloadOverlayClose", p.u.d.closeOverlayHandler);
    
    if(!pega.ui.EventsEmitter.isListenerSubscribed("onHarnessUnload", p.u.d.closeOverlayHandler)) {
      pega.ui.EventsEmitter.subscribe("onHarnessUnload", p.u.d.closeOverlayHandler);
    }
  
    function AsyncExecute() {
        var _executeHandle = NULL;
        this.execute = function (methodScope, method, args, callbackScope, callback) {
            _executeHandle = setTimeout(function () { var result = method.apply(methodScope, args); _executeHandle = NULL; if (typeof callback == 'function') { callback.apply(callbackScope, result); } }, 0);
        };
        this.cleanUp = function () {
            if (_executeHandle != NULL) {
                clearTimeout(_executeHandle);
                _executeHandle = NULL;
            }
        };
    }

    function DomElementFetchStrategy(domElement, containerElement, onContentReadyScope, onContentReady) {
        var _element = domElement;
        var _containerElement = containerElement;
        var _onContentReady = onContentReady;
        var _onContentReadyScope = onContentReadyScope;

        this.initiateFetch = function () {
            var callbackInterceptor = function () {
                pega.u.d.loadHTMLEleCallback(_containerElement);
                if (typeof _onContentReady == 'function') {
                    _onContentReady.apply(_onContentReadyScope);
                }
                if(_onContentReadyScope.onloads && _onContentReadyScope.onloads.length > 0){
                    for(var i=0; i < _onContentReadyScope.onloads.length;i++)
                        invokeCallback(_onContentReadyScope.onloads[i], _onContentReadyScope.getContentContainerElement());
                }
            }
            if(_element && _element.firstChild && _element.firstChild.id == 'Pega_Cal_Cont'){
                _containerElement.innerHTML = _element.innerHTML;
                if (typeof _onContentReady == 'function') {
                    _onContentReady.apply(_onContentReadyScope);
                }
                if(_onContentReadyScope.onloads && _onContentReadyScope.onloads.length > 0){
                    for(var i=0; i < _onContentReadyScope.onloads.length;i++)
                        invokeCallback(_onContentReadyScope.onloads[i], _onContentReadyScope.getContentContainerElement());
                }
            }
            else {
                p.u.d.loadDOMObject(_containerElement, _element, callbackInterceptor);
            }
        };

        this.cleanUp = _void;
    }

    function MethodFetchStrategy(methodScope, method, args, onContentReadyScope, onContentReady) {
        var _asyncExecute = new AsyncExecute();
        var _onContentReady = onContentReady;
        var _scope = methodScope;
        var _onContentReadyScope = onContentReadyScope;

        this.initiateFetch = function () {
            _asyncExecute.execute(_scope, method, args, this, this.asyncExecuteCompleted);
        };

        this.asyncExecuteCompleted = function (fetchResult) {
            if (typeof _onContentReady == 'function') {
                _onContentReady.apply(_onContentReadyScope, fetchResult);
            }

            this.cleanUp();
        };

        this.cleanUp = function () {
            _asyncExecute.cleanUp();
        };
    }

    function SectionFetchStrategy(content, scope, onSuccess, onFailure) {
        var _responseHandle = NULL;
        var _content = content;
        var _scope = scope;
        var _onSuccess = onSuccess;
        var _onFailure = onFailure;

        this.initiateFetch = function () {
            _responseHandle = initiateSectionFetch(_content.name, _content.preActivity,
                                { success: _onSuccess, failure: _onFailure, scope: _scope });
        };

        this.cleanUp = function () {
            if (typeof _responseHandle !== 'object') {
                return;
            }
           if(!p.util.Connect.isCallInProgress(_responseHandle))
            p.util.Connect.abort(_responseHandle);
            _responseHandle = NULL;
        };
    }

    var _void = function () { };

    var _getPopOverLevelForElement = function (el) {
        var level = -1;
        var b = document.body;
        try {
          while (el != null && el != b && (typeof el.po !== 'object' || typeof el.po.getLevel !== 'function')) {
            el = el.parentNode || el.offsetParent;
            if (el == null) {
                /* Added to display popover IE6 standards mode */
                el = b;
                break;
                // throw "Exception in _getPopOverLevelForElement - Cannot determine the correct parent for the specified element.";
            }
          }
        } catch(e) { el = b; }
        if (el != null && typeof el.po === 'object' && typeof el.po.getLevel === 'function') {
            level = el.po.getLevel();
        }
        return level;
    };

    var _displayShim = function (popOver) {
        var level = popOver.getLevel();
        var iframeShim = document.getElementById("poi" + level);
        var poc = popOver.getActivePopOverElement();
        setElementSizeXY(iframeShim, getElementSizeXY(poc));
        setElementPositionXY(iframeShim, getElementPositionXY(poc));
        iframeShim.style.visibility = "visible";
    };

    var _hideShim = function (popOver) {
        var level = popOver.getLevel();
        var iframeShim = document.getElementById("poi" + level);
        iframeShim.style.visibility = "hidden";
    };

    var initIframeShim4IE = function () {
        var isIE6 = pega.util.Event.isIE && pega.util.Event.isIE == 6;
        if (!isIE6) {
            _iframeShimMarkupTemplate = "";
            _displayShim = _hideShim = _void;
        }
    };

    var _clickAwayProvider = new (function (e) {
        var _harnessContent = NULL;
        var _harnessMainregion = NULL;
        var _modalDialogScrollElement = NULL;
        var _pegaHarness = null;
        var _flexLayoutScrollElement = null;
        var clickHandler = function (e) {
            _onClickAway(e, "click");
        }, innerDocHandler = function (e) {
            _onClickAway(e, "iframe-clickaway");
        }, desktopClickHandler = function (e) {
            // if the overlay contains an iframe, the first test will fail and close the overlay when setting focus inside the iframe - add
            // additional test to test is the activeElement of the document is the same as the target event and if the iframe is either contained inside a modal dialog or a jquery dialog
            if(pega.util.Event.getTarget(e).ownerDocument !== document) {
              var parentFrame = pega.util.Event.getTarget(e).ownerDocument.defaultView.frameElement;
              if( (!parentFrame && $(".ui-dialog").length == 0) ||
                  ( $(parentFrame).parents("#modaldialog_con").length == 0 && $(parentFrame).parents(".ui-dialog").length == 0 ) ||
                   parentFrame.ownerDocument != document ) {
                _onClickAway(e, "iframe-clickaway");    
              }     
            }
        }, scrollHandler = function (e) {
            _onClickAway(e, "scroll");
        }, keyHandler = function (e) {
            if(e.keyCode === 27) {
                _onClickAway(e, "escape");
            }
            if(e.keyCode === 9 && document.activeElement && document.getElementById("_popOversContainer") && document.getElementById("_popOversContainer").hasChildNodes()){
                if(!(document.getElementById("_popOversContainer")).contains(document.activeElement)){
                _onClickAway(e, "escape");
                }
            }
        }, _onClickAway = NULL, _clickAwayAttached = false, _clickAwayTimer;
        this.registerScrollHandlers = function (targetElem) {
          var _parentNode = targetElem;
          while(_parentNode != null && _parentNode.nodeName  && _parentNode.nodeName.toLowerCase() != "main") {
            // BUG-605422 when overflow is scroll it is returned as auto scroll as a whole string
            if($(_parentNode).css("overflow") == "auto" || $(_parentNode).css("overflow") == "scroll" || $(_parentNode).css("overflow").indexOf("scroll") !== -1) {
               pega.util.Event.addListener(_parentNode, 'scroll', scrollHandler);
               _parentNode.setAttribute("data-popover-scroll", "yes");
            }
            if(_parentNode.nodeName.toLowerCase() == "body") break;
            _parentNode = _parentNode.parentNode;
          }          
        };
        this.unregisterScrollHandlers = function () {
          var _scrollElements = document.querySelectorAll("*[data-popover-scroll='yes']");
          var _removeAttribute = function(element){
            if(element.removeAttribute) {
              element.removeAttribute("data-popover-scroll"); 
            } 
          }
          if(_scrollElements && _scrollElements.length >= 1) {
            for(var idx = 0; idx < _scrollElements.length; idx++) {
              //BUG-500496 - don't remove listeners if popover is active and it's level is >=0(general popovers)
              if(!((pega.u.d.getPopOverLevel(_scrollElements[idx])>=0) && pega.u.d.getPopOver(_scrollElements[idx]).isActive())){
                pega.util.Event.removeListener(_scrollElements[idx], 'scroll', scrollHandler);
                _removeAttribute(_scrollElements[idx]);
              }
            }
          }
        };
        this.registerClickAway = function (onClickAway) {
            if (_clickAwayAttached) {
                return;
            }
            _onClickAway = onClickAway;
            _clickAwayTimer = setTimeout(function () {
                // Tap event is deprecated as part of this US-130296
                pega.util.Event.addListener(document.body, 'click', clickHandler);
                var innerFrames = document.body.getElementsByTagName('iframe');
                if(innerFrames && innerFrames.length > 0){
                    for (var idx = 0; idx < innerFrames.length; idx++) {
                        if(innerFrames[idx].className.indexOf('cke_')!=-1){
                            pega.util.Event.addListener(innerFrames[idx].contentWindow , 'click', innerDocHandler);
                        }
                      if(innerFrames[idx].name=="actionIFrame" && innerFrames[idx].title=="Take Action"){     //SE-44425 Customer having iframe..This code is to detect that iframe
                        pega.util.Event.addListener(innerFrames[idx].contentWindow , 'click', innerDocHandler);
                      }
                    }
                }
                try {
                    if(pega.desktop.support.getDesktopApplication() != null) {
                        pega.desktop.registerEventListener("DesktopMouseClick", desktopClickHandler);
                    }
                } catch(e) {
                }
                /** BUG-288815: Adding OR conditions for static-dc-tab and screen-layout-region */
                _harnessContent = document.getElementById('HARNESS_CONTENT') || ($("div.static-dc-tab")?$("div.static-dc-tab")[0]:null) || ($("main.screen-layout-region")?$("main.screen-layout-region")[0]:null);
              
                if (_harnessContent) {
                    p.util.Event.addListener(_harnessContent, 'scroll', scrollHandler);
                }
              
                /* BUG-308314: Popover container presents outside the main-screen-region, popover not re positioning along with main content scroll bar. Hence attaching scroll handler for main-screen-region */
                 _harnessMainregion = ($("main.screen-layout-region")?$("main.screen-layout-region")[0]:null);
                if (_harnessMainregion && _harnessMainregion != _harnessContent) {
                    var rootPopOver = p.u.d.getPopOver();
                    var _popoverContainerDiv = rootPopOver.getContentContainerElement();
                    if(!pega.util.Dom.isAncestor(_harnessMainregion, _popoverContainerDiv) || _harnessMainregion.tagName === 'MAIN') {
                        p.util.Event.addListener(_harnessMainregion, 'scroll', scrollHandler);
                    }
                }

                _pegaHarness = document.getElementById('PEGA_HARNESS');     
                if(_pegaHarness){       
                  p.util.Event.addListener(_pegaHarness, 'scroll', scrollHandler);      
                }
              var portalSection =  document.getElementById("INNERDIV-SubSectionpyPortalContentBB");
              if(portalSection){
                 p.util.Event.addListener(portalSection, 'scroll', scrollHandler);
              }
                _flexLayoutScrollElement = document.getElementsByClassName('workarea-view-scroll-wrapper');
                if (_flexLayoutScrollElement) {
                    p.util.Event.addListener(_flexLayoutScrollElement, 'scroll', scrollHandler);
                }
                p.util.Event.addListener(window, 'scroll', scrollHandler);
                if(pega.u.d.bModalDialogOpen && pega.u.d.modalDialog ){
                  var modalBody = pega.u.d.modalDialog.body;
                  try{
                    _modalDialogScrollElement = modalBody.getElementsByClassName("modal-scroll-panel")[0];  
                    if(_modalDialogScrollElement){
                        p.util.Event.addListener(_modalDialogScrollElement, 'scroll', scrollHandler);  
                    } 
                  }
                  catch(e){
                    
                   }               
                }
                p.util.Event.addListener(document, 'keyup', keyHandler);
            }, 0);
            _clickAwayAttached = true;
        };
        this.removeClickAway = function () {
            clearTimeout(_clickAwayTimer);
            if (!_clickAwayAttached) {
                return;
            }
            // Tap event is deprecated as part of this US-130296
                pega.util.Event.removeListener(document.body, 'click', clickHandler);
                try {
                    if(pega.desktop.support.getDesktopApplication() != null) {
                        pega.desktop.cancelEventListener("DesktopMouseClick", desktopClickHandler);
                    }
                } catch(e) {                
                }
            if (_harnessContent) {
                p.util.Event.removeListener(_harnessContent, 'scroll', scrollHandler);
            }
            if(_harnessMainregion){
                p.util.Event.removeListener(_harnessMainregion, 'scroll', scrollHandler);
            }
            if (_pegaHarness) {     
                p.util.Event.removeListener(_pegaHarness, 'scroll', scrollHandler);     
            }
           var portalSection =  document.getElementById("INNERDIV-SubSectionpyPortalContentBB");
              if(portalSection){
                 p.util.Event.removeListener(portalSection, 'scroll', scrollHandler);
              }
            if (_flexLayoutScrollElement) {
                p.util.Event.removeListener(_flexLayoutScrollElement, 'scroll', scrollHandler);
            }
            if(_modalDialogScrollElement){
                 p.util.Event.removeListener(_modalDialogScrollElement, 'scroll', scrollHandler);
            }
            p.util.Event.removeListener(window, 'scroll', scrollHandler);
            p.util.Event.removeListener(document, 'keyup', keyHandler);
            _clickAwayAttached = false;
        };
    })(p.util.Event);

    var ensurePopOverHost = function (level) {
        if (_isInScreenLayout == null || (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && !_isInScreenLayout &&
              (($(".screen-layout-region-main-middle") && "absolute" === $(".screen-layout-region-main-middle").css("position")) || 
                 ($(".screen-layout-region-main-sidebar1") && "absolute" === $(".screen-layout-region-main-sidebar1").css("position"))))) {
            setIsScreenLayout();
        }
        if(_hostContainer && !document.body.contains(_hostContainer)){
           _hostContainer = null;  
        }
        if (!_hostContainer || (level != null && typeof level === 'object' && _isInScreenLayout)) {
            var _isNoHostContainer = !_hostContainer;
            var _hostContainerOriginal = _hostContainer;
           if(typeof level === 'undefined' || (level != null && typeof level === 'object' && !level._prevSmartInfo))          
            _hostContainer = document.body;
          //BUG-197942 - added pega.offline check
            if(!pega.mobile.isHybrid && document.forms && document.forms.length && document.forms[0].name == "main" && document.forms[0].parentNode && document.forms[0].parentNode.id == "PEGA_HARNESS" && (typeof level === 'undefined' || (level != null && typeof level === 'object' && !level._prevSmartInfo))) {
                if (_isInScreenLayout) {
                    if (level != null && typeof level === 'object' && pega.util.Dom.isAncestor(document.forms[0].parentNode, level)) {
                        _isInsideFormTag = true;
                        _hostContainer = document.forms[0];
                    } else if (typeof level === 'undefined') {
                        var _popOversContainerObj = document.getElementById('_popOversContainer');
                        if (!_popOversContainerObj) {
                            _isInsideFormTag = true;
                            _hostContainer = document.forms[0];
                        }
                    }
                } else {
                    _isInsideFormTag = true;
                    _hostContainer = document.forms[0];
                }
            }
            if (_isNoHostContainer && _hostContainer) {
                _hostContainer.appendChild(_popOversContainer);
            } else if (level != null && typeof level === 'object' && _isInScreenLayout) {
                if (_hostContainerOriginal != _hostContainer) {
                    _hostContainer.appendChild(_popOversContainer);
                }
            }
            /*BUG-337874 : Reverting BUG-327930 cahnges */
          /*if (level != null && typeof level === 'object' && _isInScreenLayout && level._inSmartInfo && !level._prevSmartInfo){            
              if(document.forms[0] && pega.util.Dom.isAncestor(document.forms[0].parentNode, level)){
                _hostContainer = document.forms[0];
              } else {
                 _hostContainer = document.body;
              }
              _hostContainer.appendChild(_popOversContainer);
            } */         
        } else if (_isInsideFormTag) {
            var _popOversContainerObj = document.getElementById('_popOversContainer');
            if (!_popOversContainerObj) {
                _isInsideFormTag = false;
                _hostContainer = document.body;
                _hostContainer.appendChild(_popOversContainer);
            }
        }

    };

    var getPopOverContainer = function (level) {
        var poElement = document.getElementById("po" + level);
        if (!poElement) {
            poElement = document.createElement("div");
            poElement.innerHTML = (_iframeShimMarkupTemplate + _contentMarkupTemplate).replace(/\{0\}/g, level);
            var childNode = poElement.firstChild;
            var tagName = childNode.tagName;
            _popOversContainer.appendChild(childNode);
            if (tagName.toLowerCase() === 'div') {
                return childNode;
            }
            childNode = poElement.firstChild;
            _popOversContainer.appendChild(childNode);

            return childNode;
        }

        return poElement;
    };

    var getPopOverLoaderContainer = function (level) {
        var po = getPopOverContainer(level);
        var result = document.getElementById("pol" + level);
        if (!result) {
            result = document.createElement("div");
            result.innerHTML = _loaderMarkupTemplate.replace(/\{0\}/g, level);
            result = result.firstChild;
            _popOversContainer.appendChild(result);
        }

        return result;
    };

    var getPopOverLoaderImageElement = function (level) {
        return document.getElementById("poli" + level);
    };

    var getPopOverContentContainer = function (level) {
        return document.getElementById("poc" + level);
    };

    var initiateSectionFetch = function (sectionName, preActivity, callback) {
        var strUrlSF = SafeURL_createFromURL(pega.u.d.url);
        var _preActivity = (preActivity) ? preActivity.name : NULL;
        var postDataURL = new SafeURL();
        if (sectionName) {
            strUrlSF.put("pyActivity", "pzGetPopOverData");
            strUrlSF.put("SectionName", sectionName);
            if (preActivity) {
                strUrlSF.put("PreActivity", _preActivity);
                var pageName = preActivity.page;
                if (pageName) {
                    strUrlSF.put("PreActivityPage", pageName);
                }
                var paramsList = preActivity.params;
                if (paramsList) {
                    var paramsURL = new SafeURL();
                    for (var param in paramsList) {
                        paramsURL.put(param, paramsList[param]);
                    }
                    /* BUG-277285: Pass the PreActivityParams as postData */
                    //strUrlSF.put("PreActivityParams", paramsURL.toQueryString());
                    postDataURL.put("PreActivityParams", paramsURL.toQueryString());
                }
            }
        }

        return p.u.d.asyncRequest('POST', strUrlSF, callback, postDataURL);
    };

    var fixSectionTableWidth = function (sectionElement, styleWidth) {
        if (!sectionElement) {
            return;
        }
    
        var sectionLayouts = sectionElement.childNodes;
        var sectionLayoutsCount = sectionLayouts.length;
        for (var index = 0; index < sectionLayoutsCount; index++) {
            var sectionLayout = sectionLayouts[index];
            if(sectionLayout.tagName && sectionLayout.tagName.toLowerCase() ==="span" && sectionLayout.childNodes && sectionLayout.childNodes.length) {
                sectionLayout = sectionLayout.childNodes[0];
            }
            if (sectionLayout.tagName && sectionLayout.tagName.toLowerCase() === 'table' && sectionLayout.id === 'EXPAND-OUTERFRAME') {
                sectionLayout.style.width = styleWidth;
            }
        }
    };

    var positions = {
        "leftTop": 0,
        "centerTop": 1,
        "rightTop": 2,
        "leftMiddle": 3,
        "centerMiddle": 4,
        "rightMiddle": 5,
        "leftBottom": 6,
        "centerBottom": 7,
        "rightBottom": 8
    };

    var getPositionId = function (position) {
        return positions[position];
    };

    var positionElementRelativeTo = function (relativeElement, repositionedElement, position, isContent, level, aDivClasses, extraParams) {
        var csstext = '';
        repositionedElement.style.cssText = csstext + 'z-index:100;';
        
        var client = getCientDimensions();
        //added for frameless dynamic containers
        try {
          var harnessDiv = document.getElementById("PEGA_HARNESS");
          var rootAssocElem = relativeElement;
          if(level>0){
            var rootPopOver = p.u.d.getPopOver();
            rootAssocElem = rootPopOver.getAssociatedElement();
          }
          if(typeof(extraParams) === "object" && extraParams.useRelativeElement) {
            rootAssocElem = relativeElement;
          }
          var headerGapCompensation = 0;
          try{
            var gapPanelElem = $(".pz-gap-panel").get(0);
            if(gapPanelElem!=undefined){
              //  if(pega.util.Dom.isAncestor(gapPanelElem, rootAssocElem)){       BUG-306681
                    headerGapCompensation = $(gapPanelElem).css("top");
                    if(headerGapCompensation != "auto"){
                        headerGapCompensation = headerGapCompensation.replace(/px/ig,"").replace(/%/ig,"");
                    }else{
                        var headerPosition = $(gapPanelElem).position();
                        headerGapCompensation = headerPosition.top;
                    }
              //  }
            }
          }
          catch(e){
          }
          if (pega.util.Dom.isAncestor(harnessDiv, rootAssocElem)) {
            var dcLayoutDiv = harnessDiv.parentNode;
            while(dcLayoutDiv && dcLayoutDiv.tagName && dcLayoutDiv.tagName.toLowerCase() != "body") {
              if($(dcLayoutDiv).hasClass("screen-layout-region")) {
                var leftComposition = "";
                if(pega.u.d.isOrientationRTL()){
                  leftComposition = $(dcLayoutDiv).css("right");
                }
                else{
                  leftComposition = $(dcLayoutDiv).css("left");
                }
                if(leftComposition != "auto"){
                        leftComposition = leftComposition.replace(/px/ig,"").replace(/%/ig,"");
                }else{
                    /*BUG-235235: Safari in frameless portal returns auto since the position is static */
                    var dcPosition = $(dcLayoutDiv).position();
                    leftComposition = dcPosition.left;
                }
                var mainContainerElement = $(_popOversContainer).closest(dcLayoutDiv);
                var isPopoverInsideMainContainer = mainContainerElement && mainContainerElement.length > 0;
                if (!isNaN(leftComposition) && $(dcLayoutDiv).css('position') =='absolute' && !(((jQuery("html").hasClass("ff") || $(_popOversContainer).css("position")=="fixed") && !(jQuery("html").hasClass("ff") && $(_popOversContainer).css("position")==="static" && dcLayoutDiv.tagName && dcLayoutDiv.tagName.toLowerCase() === "main" && isPopoverInsideMainContainer)) && dcLayoutDiv.tagName && dcLayoutDiv.tagName.toLowerCase() == "main") && !(isMobile && jQuery("html").hasClass("safari") || jQuery("html").hasClass("iOS"))) {
                  if (client.right - leftComposition >= 0) {
                    var layoutWidth = $(dcLayoutDiv).css("width");
                    layoutWidth = layoutWidth.replace(/px/ig,"").replace(/%/ig,"");
                    
                    client.right -= leftComposition;
                    
                    if(layoutWidth < (client.right)){
                      client.right = layoutWidth;
                    }
                  }
                }
                break;

              } else {
                    dcLayoutDiv = dcLayoutDiv.parentNode;
              }
            }
          }
        } catch(e) { }
      
        var height = client.bottom - client.top,
        width = client.right - client.left;
        
        position.offsetAttach = position.offsetAttach || {};
        position.offsetAttach.x = position.offsetAttach.x || 0;
        position.offsetAttach.y = position.offsetAttach.y || 0;
        position.fieldAttach = position.fieldAttach || "rightBottom";
        position.popOverAttach = position.popOverAttach || "rightTop";
        position.mouseOrTouchPositionX = position.mouseOrTouchPositionX || null;
        position.size = position.size || {};
        position.size.min = position.size.min || {};
        position.size.min.x = position.size.min.x || 50;
        position.size.min.y = position.size.min.y || 50;
        position.size.max = position.size.max || {};
        position.size.max.x = position.size.max.x ? Math.min(position.size.max.x, width - 20) :(width - 20);
        position.size.max.y = position.size.max.y ? Math.min(position.size.max.y, height - 20) :(height - 20);

        var addActualY = false;
        if (relativeElement.getAttribute("data-setActualY") == "true") {
            addActualY = true;
        }
      
        var isMouseOrTouchPositionUpdated = false;
        var _mouseOrTouchPositionX = undefined;
        if(position.mouseOrTouchPositionX && !isNaN(position.mouseOrTouchPositionX)) {
          _mouseOrTouchPositionX = position.mouseOrTouchPositionX;
          isMouseOrTouchPositionUpdated = true;
        }

        var ePos = getElementPositionXY(relativeElement, _mouseOrTouchPositionX),
        offLeft = position.offsetAttach.x,
        offTop = position.offsetAttach.y,
        fieldPos = getPositionId(position.fieldAttach),
        poPos = getPositionId(position.popOverAttach),
        elem = {
            x: repositionedElement.scrollWidth,
            y: repositionedElement.scrollHeight
        };
        
        var noOverflow = extraParams && (extraParams.overflow === false);
        var hideVScroll = extraParams && (extraParams.hideVScroll === true);
        var cssObj = {};
        if(hideVScroll) {
            cssObj['overflow-y'] = 'hidden';
        }
        if (elem.x <= position.size.min.x) {
            elem.x = position.size.min.x;
            cssObj['width'] = position.size.min.x + 'px';
        } else if(elem.x > position.size.max.x) {
            elem.x = position.size.max.x;
            cssObj['width'] = position.size.max.x +'px';
            if(!noOverflow) {
            cssObj['overflow-x'] = 'auto';
            }
        }
        
        if (elem.y <= position.size.min.y) {
            elem.y = position.size.min.y;
            cssObj['height'] = position.size.min.y + 'px';
        } else if(elem.y > position.size.max.y) {
            elem.y =  position.size.max.y;
            cssObj['height'] = position.size.max.y + 'px';
            if(!hideVScroll) {
                if(!noOverflow){
                    cssObj['overflow-y'] = 'auto';
                }
            }
        }
        
        var actualX, flippedX, isFlippedInX = false, isFlippedInY = false;
        if(fieldPos % 3 == 0) {
            if( poPos %3 ==0 ) {
                actualX = ePos.x;
                flippedX = ePos.x + (isMouseOrTouchPositionUpdated?0:(relativeElement.offsetWidth?relativeElement.offsetWidth:0)) - elem.x;
            } else if( poPos % 3 == 2) {
                actualX = ePos.x - elem.x;
                flippedX = ePos.x + (relativeElement.offsetWidth?relativeElement.offsetWidth:0);
            } else {
                actualX = ePos.x - elem.x / 2;
                flippedX = ePos.x + relativeElement.offsetWidth - elem.x / 2;
            }       
        } else if(fieldPos % 3 == 2) {
            if( poPos %3 ==0 ) {
                actualX = ePos.x + relativeElement.offsetWidth;
                flippedX = ePos.x - elem.x;
            } else if( poPos % 3 == 2) {
                actualX = ePos.x + relativeElement.offsetWidth - elem.x;
                flippedX = ePos.x;          
            } else {
                actualX = ePos.x + relativeElement.offsetWidth - elem.x / 2;
                flippedX = ePos.x - elem.x / 2;
            }
        } else {
            if( poPos %3 ==0 ) {
                actualX = ePos.x + relativeElement.offsetWidth / 2;
                flippedX = ePos.x + relativeElement.offsetWidth / 2 - elem.x;
            } else if( poPos % 3 == 2) {
                actualX = ePos.x + relativeElement.offsetWidth / 2 - elem.x;
                flippedX = ePos.x + relativeElement.offsetWidth / 2;                
            } else {
                actualX = ePos.x + relativeElement.offsetWidth / 2 - elem.x / 2;
                flippedX = ePos.x + relativeElement.offsetWidth / 2 - elem.x / 2;               
            }
        }
        actualX  += offLeft;
        flippedX -= offLeft;
        
        var actualY, flippedY;
        if(parseInt(fieldPos / 3) == 0) {
            if( parseInt(poPos /3) ==0 ) {
                actualY = ePos.y;
                flippedY = ePos.y + relativeElement.offsetHeight - elem.y;
            } else if( parseInt(poPos / 3) == 2) {
                actualY = ePos.y - elem.y;
                flippedY = ePos.y + relativeElement.offsetHeight;
            } else {
                actualY = ePos.y - elem.y / 2;
                flippedY = ePos.y + relativeElement.offsetHeight - elem.y / 2;
            }       
        } else if(parseInt(fieldPos / 3) == 2) {
            if( parseInt(poPos / 3) ==0 ) {
                actualY = ePos.y + relativeElement.offsetHeight;
                flippedY = ePos.y - elem.y;
            } else if( parseInt(poPos / 3) == 2) {
                actualY = ePos.y + relativeElement.offsetHeight - elem.y;
                flippedY = ePos.y;          
            } else {
                actualY = ePos.y + relativeElement.offsetHeight - elem.y / 2;
                flippedY = ePos.y - elem.y / 2;
            }
        } else {
            if( parseInt(poPos /3) ==0 ) {
                actualY = ePos.y + relativeElement.offsetHeight / 2;
                flippedY = ePos.y + relativeElement.offsetHeight / 2 - elem.y;
            } else if( parseInt(poPos / 3) == 2) {
                actualY = ePos.y + relativeElement.offsetHeight / 2 - elem.y;
                flippedY = ePos.y + relativeElement.offsetHeight / 2;               
            } else {
                actualY = ePos.y + relativeElement.offsetHeight / 2 - elem.y / 2;
                flippedY = ePos.y + relativeElement.offsetHeight / 2 - elem.y / 2;              
            }
        }
        actualY  += offTop;
        flippedY -= offTop;

      var modalCompensation = 0;
        try {
            if (pega.util.Event.isIE && pega.u.d.inStandardsMode && pega.u.d.bModalDialogOpen &&
                pega.u.d.modalDialog && pega.util.Dom.isAncestor(pega.u.d.modalDialog.body, relativeElement)) {
                if (!isNaN(document.body.scrollTop) && document.body.scrollTop > 0) {
                    modalCompensation = document.body.scrollTop;
                }
            }
        } catch(e) {}
        var screenLayoutMainScroll = 0;
        var screenHorizontalMainScroll = 0;
        var runtimeToolsTopBarHeight = 0;
        try {
            if (_isInScreenLayout == null) {
                setIsScreenLayout();
            }
            if (_isInScreenLayout) {
                var harnessDiv = document.getElementById("PEGA_HARNESS");
                var ajaxContainerElement = $(relativeElement).closest("div[data-mdc-id]");
                if (harnessDiv && pega.util.Dom.isAncestor(harnessDiv, relativeElement) && "absolute" === $(".screen-layout-region-main-middle").css("position") && (ajaxContainerElement && ajaxContainerElement.length == 0)) {

                    var scrollTopVal = $(".screen-layout-region-main-middle").scrollTop();
                    var scrollLeftVal = $(".screen-layout-region-main-middle").scrollLeft();
                    if (scrollTopVal && !isNaN(scrollTopVal)) {
                        screenLayoutMainScroll = scrollTopVal;
                    }
                    if(scrollLeftVal && !isNaN(scrollLeftVal)){
                    screenHorizontalMainScroll = scrollLeftVal; 
                  }
                }
            }
            
        } catch(e) {}

      
        if(actualX >= client.left && actualX + elem.x < client.right) {
            csstext += 'left:' + (actualX  + screenHorizontalMainScroll) + 'px;';
        } else if(flippedX > client.left && flippedX + elem.x < client.right) {
            csstext += 'left:' + (flippedX + screenHorizontalMainScroll) + 'px;';
            isFlippedInX = true;
        } else {
            var actAvaiWidth = Math.min(client.right,actualX + elem.x) - Math.max(client.left,actualX);
            var flippedAvailWidth = Math.min(client.right,flippedX + elem.x) - Math.max(client.left,flippedX);          
            if(actAvaiWidth >= flippedAvailWidth) {
                cssObj['width'] = actAvaiWidth+'px';
                if(!noOverflow) {
                cssObj['overflow-x'] = 'auto';
                }
                if(actualX < client.left) {
                    csstext += 'left:'+client.left+'px;';
                } else {
                    csstext += 'left:'+actualX+'px;';
                }
            } else {
                cssObj['width'] = flippedAvailWidth+'px';
                if(!noOverflow) {
                cssObj['overflow-x'] = 'auto';
                }
                isFlippedInX = true;
                if(flippedX < client.left) {
                    /* BUG-500615 set scrolled to true in scroll event and in that case if client.left is 0 use flippedX for left*/
                  // BUG-552245 if associated element is outside viewport to the left use flippedX for left
                    var relativeElementRect = relativeElement.getBoundingClientRect();
                    if(relativeElementRect.left < 0 && p.u.d.scrolled && client.left == 0 && pega.u.d.findParentTable(relativeElement)){
                      csstext += 'left:'+flippedX+'px;';
                      p.u.d.scrolled = false;
                    }else{
                    csstext += 'left:'+client.left+'px;';
                    }
                } else {
                    csstext += 'left:'+flippedX+'px;';
                }
            }
        }
      var nestedPopoverComponsationActY=0 ,nestedPopoverComponsationFlipY=0, popoverInsideCenterPopover = 0;
        if(level > 0){
            var _popOverRelElem = p.u.d.getPopOver(relativeElement);
            if(_popOverRelElem){
              var parentDivRelElem =_popOverRelElem.getContentContainerElement().parentNode;
              if(parentDivRelElem){
                var centerPopoverDiv = parentDivRelElem.getElementsByClassName("centerOverlay");
                while(level > 0){
                  var previousId = "po"+(level-1);
                  var previousDiv;
                  for(var i=0;i<centerPopoverDiv.length;i++){
                    if(centerPopoverDiv[i].id ==previousId){
                      previousDiv = centerPopoverDiv[i];
                      break;
                    }
                  }
                  level = level - 1;
                }
                if(previousDiv){
                    var previousDivClassName = previousDiv.className;
                   if(previousDivClassName && (previousDivClassName.indexOf("centerOverlay") != -1 )){
                     popoverInsideCenterPopover =1;
                        nestedPopoverComponsationActY = actualY - (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
                        nestedPopoverComponsationFlipY = flippedY - (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
                    }
                }
            }
          }
        }
        var targetScrollTop = 0;
        /*
          BUG-527103
          Microsoft Edge - scrollTop is returning the scrollTop value where as other browsers are returning 0, so we should not consider it in Edge.
          Note: There are two variations of Edge, Microsoft Based Edge and Chromium Based Edge.
          This issue is only with Microsoft Edge.
          P.S 
          var isChromiumBasedEdge = navigator.userAgent.match(/Edg\//ig); 
        */
        var isMicrosoftEdge = navigator.userAgent.match(/Edge/ig);
        if(document && document.body && document.body.scrollTop && !isMicrosoftEdge) {
          targetScrollTop = document.body.scrollTop;
        }
        if(popoverInsideCenterPopover===1){
          screenLayoutMainScroll = 0; // BUG-527967
        }
        if(actualY > client.top && actualY + elem.y < client.bottom + ePos.scrolled) {
          if(popoverInsideCenterPopover==1){
            csstext += 'top:' + ((nestedPopoverComponsationActY- modalCompensation-headerGapCompensation)+screenLayoutMainScroll+runtimeToolsTopBarHeight  - targetScrollTop ) + 'px;';
          } else{
            csstext += 'top:' + ((actualY- modalCompensation-headerGapCompensation)+screenLayoutMainScroll+runtimeToolsTopBarHeight  - targetScrollTop ) + 'px;';
          }
            
        } else if(flippedY > client.top && flippedY + elem.y < client.bottom) {
          if(popoverInsideCenterPopover==1){
            csstext += 'top:' + ((nestedPopoverComponsationFlipY-modalCompensation-headerGapCompensation)+screenLayoutMainScroll+runtimeToolsTopBarHeight  - targetScrollTop ) + 'px;';
          } else {
            csstext += 'top:' + ((flippedY-modalCompensation-headerGapCompensation)+screenLayoutMainScroll+runtimeToolsTopBarHeight  - targetScrollTop ) + 'px;';
          }
            
            isFlippedInY = true;
        } else {
            var actAvaiHeight = Math.min(client.bottom,actualY + elem.y) - Math.max(client.top,actualY);
            var flippedAvailHeight = Math.min(client.bottom,flippedY + elem.y) - Math.max(client.top,flippedY);
            if(actAvaiHeight >= flippedAvailHeight) {
                cssObj['height'] = actAvaiHeight+'px';
                if(!hideVScroll) {
                    if(!noOverflow){
                        cssObj['overflow-y'] = 'auto';
                    }
                }
                if (addActualY && actualY < 0) {
                    csstext += 'top:'+ (actualY - modalCompensation-headerGapCompensation + screenLayoutMainScroll + runtimeToolsTopBarHeight - nestedPopoverComponsationActY) +'px;';
                } else if(actualY < client.top) {
                    if(popoverInsideCenterPopover==1)
                        client.top = client.top - (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
                    csstext += 'top:'+ (client.top - modalCompensation-headerGapCompensation + screenLayoutMainScroll + runtimeToolsTopBarHeight) + 'px;';
                } else {
                    csstext += 'top:'+ (actualY - modalCompensation-headerGapCompensation + screenLayoutMainScroll + runtimeToolsTopBarHeight) +'px;';
                }
            } else {
                cssObj['height'] = flippedAvailHeight+'px';
                if(!hideVScroll) {
                    if(!noOverflow){
                        cssObj['overflow-y'] = 'auto';
                    }
                }
                isFlippedInY = true;
                if(flippedY < client.top) {
                    if(popoverInsideCenterPopover==1)
                        client.top = client.top - (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
                    csstext += 'top:'+ (client.top - modalCompensation-headerGapCompensation + screenLayoutMainScroll + runtimeToolsTopBarHeight) +'px;';
                } else {
                  if($(repositionedElement).hasClass("smartInfoContainer") && flippedY >= client.bottom && flippedAvailHeight < 0 ) {
                    cssObj['height'] = "0px";
                  }
                    csstext += 'top:'+ (flippedY - modalCompensation-headerGapCompensation + screenLayoutMainScroll + runtimeToolsTopBarHeight) +'px;';
                }
            }
        }
        
        if(aDivClasses && aDivClasses.length > 0) {
            var arrElem = document.getElementById("arrow"+level);
            if(isFlippedInY && isFlippedInX) {
                arrElem.className = aDivClasses[3];
            } else if(isFlippedInY) {
                arrElem.className = aDivClasses[1];
            } else if(isFlippedInX) {
                arrElem.className = aDivClasses[2];
            } else {
                arrElem.className = aDivClasses[0];
            }
        }
      
        for(var prop in cssObj) {
            csstext += prop+':'+cssObj[prop]+';';
        }
        
        if (!isContent) {
            repositionedElement.firstChild.style.cssText = 'width:' + (elem.x - 8) + 'px; height:' + (elem.y - 8) + 'px; text-align:center; vertical-align:middle; overflow: hidden;z-index:100;';
        }

        if (extraParams && extraParams.setVisible === true) {
            csstext += "visibility: visible;";
        }
        repositionedElement.style.cssText = csstext + 'z-index:100;';
      
        /*  US-266708: START */
        if(isMouseOrTouchPositionUpdated) {
          try {
            var arrowPositionAdjustment = 0;
            var arrElem = document.getElementById("arrow"+level);
            if(typeof(arrElem.className) === "string") {
              if(arrElem.className.indexOf("arrow top") != -1 || arrElem.className.indexOf("arrow bottom") != -1) {
                arrowPositionAdjustment = (parseInt($(arrElem).css("left").replace(/px/ig,"")) + 15) * -1;
                if((parseInt($(repositionedElement).css("left").replace(/px/ig,"")) + arrowPositionAdjustment) < 0) {
                  arrowPositionAdjustment = (parseInt($(repositionedElement).css("left").replace(/px/ig,""))) * -1;
                }
              } else if(arrElem.className.indexOf("arrow right") != -1 || arrElem.className.indexOf("arrow left") != -1) {
                arrowPositionAdjustment = parseInt($(arrElem).css("right").replace(/px/ig,"")) + 15;
                if((parseInt($(repositionedElement).css("left").replace(/px/ig,"")) + arrowPositionAdjustment + elem.x) > client.right) {
                  arrowPositionAdjustment -= (parseInt($(repositionedElement).css("left").replace(/px/ig,"")) + arrowPositionAdjustment + elem.x) - client.right;
                }
              }
              if(!isNaN(arrowPositionAdjustment)) {
                $(repositionedElement).css("left", (parseInt($(repositionedElement).css("left").replace(/px/ig,"")) + arrowPositionAdjustment) + "px");
              }
            }
          } catch(e) { }
        }
        /*  US-266708: END */
      
        if(extraParams && extraParams.setMaxHeightAndWidth === true && !isMobile) {
          /* US-268638: START */
          try {
            var cssUpdated = false;
            var _csstext = repositionedElement.style.cssText;
            var _$repositionedElement = $(repositionedElement);
            var _maxHeight = _$repositionedElement.css("max-height");
            var _maxWidth = _$repositionedElement.css("max-width");
            if(typeof _maxHeight === "string" && (_maxHeight == "none" || _maxHeight == "")) {
              var _top = _$repositionedElement.css("top").replace(/px/ig,"");
              var _borderTopWidth = _$repositionedElement.css("border-top-width").replace(/px/ig,"");
              var nextMaxHeight = elem.y + _borderTopWidth * 2;
              var computedHeight = getComputedStyle(repositionedElement).getPropertyValue("height");
              /* BUG-508883 Made changes to avoid extra vertial scrollbar */
              var shouldAdd1Px = Math.abs(nextMaxHeight - parseInt(computedHeight)) <= 1;
              if (shouldAdd1Px) {
                nextMaxHeight += 1;
              }
              if(isFlippedInY) {
                if(!isNaN(elem.y)) {
                  _csstext += "max-height:" + (nextMaxHeight) + "px;overflow:auto;";
                  _csstext += "top:"+(_top - _borderTopWidth * 2)+"px;";
                  cssUpdated = true;
                }
              } else {
                if(!isNaN(_top) && !isNaN(client.bottom) && client.bottom - _top >= 1) {
                  _csstext += "max-height:" + (client.bottom - _top) + "px;overflow:auto;";
                  cssUpdated = true;
                }
              }
            }
            if(typeof _maxWidth === "string" && (_maxWidth == "none" || _maxWidth == "")) {
              var _left = _$repositionedElement.css("left").replace(/px/ig,"");
              if(!isNaN(_left) && !isNaN(client.right) && client.right - _left >= 1) {
                _csstext += "max-width:" + (client.right - _left) + "px;" + (cssUpdated?"":"overflow:auto;");
                cssUpdated = true;
              }
            }
            if(cssUpdated) {
              /* console.log("SHV: _maxHeight = " + _maxHeight + ",    _maxWidth = " + _maxWidth + ",    _csstext = " + _csstext); */
              repositionedElement.style.cssText = _csstext;
            }
          } catch(e) { }
          /* US-268638: END */
        }
    };

    // Gets the dom element hosting the specified property.
    var getDomElementForProperty = function (propertyName) {
        // TODO: Return the corresponding dom element reference.
        return NULL;
    };

    var setElementSizeXY = function (element, dimensions) {
        if (typeof dimensions.x === 'number') {
            p.util.Dom.setStyle(element, 'width', dimensions.x + 'px');
        }
        if (typeof dimensions.y === 'number') {
            p.util.Dom.setStyle(element, 'height', dimensions.y + 'px');
        }
    };

    var getElementSizeXY = function (element) {
        var region = p.util.Dom.getRegion(element);
        return {
            x: (region.right - region.left),
            y: (region.bottom - region.top)
        };
    };
  
    var setXYAxis = function(relativeElement,harnessDiv, xy) {
      var ajaxContainerElement = $(relativeElement).closest("div[data-mdc-id]");
      var addedScrollTop = 0;
      if((ajaxContainerElement && ajaxContainerElement.length === 0) && harnessDiv && harnessDiv.scrollWidth > document.body.scrollWidth && harnessDiv.scrollLeft > 0) {
        xy[0] = xy[0] + harnessDiv.scrollLeft;
      }
      if((ajaxContainerElement && ajaxContainerElement.length === 0) && harnessDiv && harnessDiv.scrollHeight > document.body.scrollHeight && harnessDiv.scrollTop > 0 && document.body.scrollTop === 0) {
        xy[1] = xy[1] + harnessDiv.scrollTop;
        addedScrollTop = harnessDiv.scrollTop;
      }
      return addedScrollTop;
    }

    var getElementPositionXY = function (element, mouseOrTouchPositionX) {
      var addedScrollTop = 0;
      var isIpad = navigator.userAgent.match(/iPad/i);  /* BUG-505781: we should remove top composition for IPAD */
        var xy = p.util.Dom.getXY(element);
        if(mouseOrTouchPositionX) {
          xy[0] = mouseOrTouchPositionX;
        }
        var considerMargins = true;
        var rootPopOver = p.u.d.getPopOver();
        var rootAssocElem = element;
        if(p.u.d.getPopOverLevel(element)>=0){
          rootAssocElem = rootPopOver.getAssociatedElement();
        }
        var harnessDiv = pega.u.d.findParent(rootAssocElem, "PEGA_HARNESS"); // BUG-581895
        try {
          if (pega.u.NavigateTopHandler) {
            /* BUG-175453: In frame less dynamic containers, we should remove top and left compositions */  
                if("static" === $(".screen-layout-region-main-middle").css("position")){ // BUG-675206
                      addedScrollTop = setXYAxis(rootAssocElem,harnessDiv, xy);
                }
                if(harnessDiv !== null) {
                    var dcLayoutDiv = harnessDiv.parentNode;
                    while(dcLayoutDiv && dcLayoutDiv.tagName && dcLayoutDiv.tagName.toLowerCase() != "body") {
                        if($(dcLayoutDiv).hasClass("screen-layout-region")) {
                            var leftComposition = "";
                            var topComposition = "";
                            if($(dcLayoutDiv).css('position') !='static'){
                               leftComposition = $(dcLayoutDiv).css("left");
                               topComposition = $(dcLayoutDiv).css("top");
                            }
                            if(leftComposition != "auto" &&  topComposition != "auto"){
                                leftComposition = leftComposition.replace(/px/ig,"").replace(/%/ig,"");
                                topComposition = topComposition.replace(/px/ig,"").replace(/%/ig,"");
                            }else{
                                /*BUG-235235: Safari in frameless portal returns auto since the position is static */
                                var position = $(dcLayoutDiv).position();
                                leftComposition = position.left;
                                topComposition = position.top
                            }
                            var popOversContainer = document.getElementById("_popOversContainer");
                            if (!isNaN(leftComposition) && !isNaN(topComposition) && ($(dcLayoutDiv).css('position') =='absolute' || (frameElement && $(dcLayoutDiv).css('position') =='static')) && !(((jQuery("html").hasClass("ff")|| $(_popOversContainer).css("position")=="fixed") && !(jQuery("html").hasClass("ff") && $(_popOversContainer).css("position")=="static")) && dcLayoutDiv.tagName && dcLayoutDiv.tagName.toLowerCase() == "main") && (dcLayoutDiv.tagName && dcLayoutDiv.tagName.toLowerCase() == "main" && dcLayoutDiv.contains(popOversContainer)) && !((isMobile && !isIpad) && (jQuery("html").hasClass("safari") || jQuery("html").hasClass("iOS")))) {
                                if (xy[0]-leftComposition >= 0) { xy[0] -= leftComposition; }
                                if (xy[1]-topComposition >= 0) { xy[1] -= topComposition; }
                                considerMargins = false; 
                            }
                          if(frameElement && $(dcLayoutDiv).css('position') =='static' && document.body.scrollTop){
                            xy[1] += $(dcLayoutDiv)[0].scrollTop;
                          }
                            break;
                        } else {
                            dcLayoutDiv = dcLayoutDiv.parentNode;
                        }
                    }
                }
          } else if((frameElement && ("static" === $(".screen-layout-region-main-middle", parent.document).css("position") || "absolute" === $(".screen-layout-region-main-middle", parent.document).css("position"))) || (!frameElement && $(".screen-layout-region-main-middle", parent.document).length===0)){
            // Check if this class is available in parent window
            addedScrollTop = setXYAxis(rootAssocElem,harnessDiv, xy);
          }
        } catch(e) { }
        if(considerMargins && document.getElementById("PEGA_HARNESS")){
            if(window.getComputedStyle){
                var bodyMarginLeft = window.getComputedStyle(document.body).marginLeft;
                if(bodyMarginLeft){
                    bodyMarginLeft = bodyMarginLeft.replace(/px/ig,"");
                    xy[0] -= bodyMarginLeft;
                }
            }
        }        
        return {
            x: xy[0],
            y: xy[1],
            scrolled: addedScrollTop
        };
    };

    var setElementPositionXY = function (element, position) {
        p.util.Dom.setXY(element, [position.x, position.y]);
    };

    var getCientDimensions = function () {
        return pega.util.Dom.getClientRegion();
    };

    var pointLiesInElement = function (point, element) {
        var elementSize = getElementSizeXY(element);
        var elementPos = getElementPositionXY(element);
        return (point.x >= elementPos.x && point.x <= (elementPos.x + elementSize.x)) &&
        (point.y >= elementPos.y && point.y <= (elementPos.y + elementSize.y));
    };

    var getEventXY = function (event) {
        var result = p.util.Event.getXY(event);
        return {
            x: result[0],
            y: result[1]
        };
    };

    var getSectionRootElement = function (element) {
        var childNodeCount = element.childNodes.length;
        for (var index = 0; index < childNodeCount; index++) {
            var childNode = element.childNodes[index];
            if (childNode.id === 'RULE_KEY') {
                return childNode;
            }
        }

        return null;
    };

    var invokeCallback = function (callback, args) {
        var callbackType = typeof callback;
        if (callbackType === 'undefined') {
            return;
        }

        if (callbackType === 'function') {
            return callback.apply(NULL, args);
        }

        // If the callback contains its own arguments, prepend them with the arguments specified in args.
        if (callbackType === 'object' && callbackType.length > 0) {
            var func = callback[0];
            var funcArgs = callback[1];
            if (typeof funcArgs === 'object' && typeof funcArgs.length === 'number') {
                if (typeof args === 'object' && args.length > 0) {
                    funcArgs.unshift.apply(funcArgs, args);
                }
            }
            else {
                funcArgs = args;
            }
            var scope = callback[2];
            return func.apply(scope, funcArgs);
        }
    };

    var _emptyDBP = { bind: _void };
    var _popoverAssociateElemStack = null;

    var popOver = function (level) {
        var _level = level;
        var _childPopOver = NULL;
        var _container = NULL;
        // States of the popover - "init", "ready", "loader", "active", "inactive". "init" & "ready" states are only applicable during initialization.
        var _state = 'init';
        var _options = {};
        var _buttons = {
            ok: true,
            cancel: true
        };
        var _bindings = {};
        var _dbp = _emptyDBP;
        var _position = {};
        var _content = {};
        var _callbacks = {};
        var _visual = { displayLoader: true, customShowLoader: null, customHideLoader: null, contentClass: '', arrowDivClasses: null };
        var _extraParams = {};
        var _attachedDomElement = NULL;
        var _loaderContainerElement = NULL;
        var _loaderBusyInd = NULL;
        //var _loaderTimeoutHandle = NULL;
        var _result = NULL;
        var _that = this;
        this.onloads = new Array();

        this.getLevel = function () {
            return _level;
        };

        this.getState = function () {
            return _state;
        };
        this.setState = function (state) {
            _state = state;
        };
        this.isActive = function () {
            return _state === 'active' || _state === 'loader';
        };
        //US-79038 : Disable clickaway configuration - Handling Nested Overlays - START
        var _IsDisabledClickaway=false;
        this.isDisabledClickaway = function () {
            return _IsDisabledClickaway;
        };
        var _IsCenterOverlay=false;
        this.isCenterOverlay = function () {
            return _IsCenterOverlay;
        };
        //US-79038 : Disable clickaway configuration - Handling Nested Overlays - END
        var bindingsEqual = function (bindings) {
            return bindings
                && bindings.associatedProperty === _bindings.associatedProperty
                && bindings.associatedElement === _bindings.associatedElement
                && bindings.selectionProperty === _bindings.selectionProperty;
        };
      
        // US-91158: Overlay accessibility -- start
        /*this.isOverlay = function() {
            return (_options && _options.visual && _options.visual.contentClass && /overlay/i.test(_options.visual.contentClass)); 
        };*/
      
        // Creating dummy buttons for looping inside the overlay on pressing 'tab'
        var createLoopingButtons = function(currentOverlayInstance) {
            var overlayContainerElement = currentOverlayInstance.getContentContainerElement();
            var liContainingOverlay = $(overlayContainerElement).find("li:eq(0)")[0];
          
            // focus the first element here
            function focusFirst() {
                $(':not(.circular-btn-placeholder):tabbable:first', liContainingOverlay).focus();
            }
          
            // focus the last element here
            function focusLast() {
                $(':not(.circular-btn-placeholder):tabbable:last', liContainingOverlay).focus();
            }
          
            // Focus loop Dummy Buttons
            
            var firstButton = document.createElement("button");
            // styling the dummy button to be invisible
           
            firstButton.className = "circular-btn-placeholder";
            firstButton.setAttribute("type","button");
            firstButton.setAttribute("role","presentation");
            firstButton.setAttribute("aria-hidden","true");
            $(liContainingOverlay).parent().prepend(firstButton);

            var lastButton = document.createElement("button");
            // styling the dummy button to be invisible
            
            lastButton.className = "circular-btn-placeholder";
            lastButton.setAttribute("type","button");
            lastButton.setAttribute("role","presentation");
            lastButton.setAttribute("aria-hidden","true");
            $(liContainingOverlay).parent().append(lastButton);                 
            
            firstButton.onfocus = focusLast;
            lastButton.onfocus = focusFirst;          
        };

        // US-91158: Overlay accessibility -- end

        var visualEqual = function (visual) {
            return visual
                && visual.contentClass === _visual.contentClass;
        };
        
        this.attachOnLoads = function (onloadFunction) {
            this.onloads.push(onloadFunction);
        };
      
      var registerDOMObserver = function(e){
        var targetNode = document.body;
        var config = { 
          attributes: true,
          childList: true,
          subtree: true,
          attributeFilter: ['style'],
          };
        var callback = function(mutationsList, observer) {
          for(var k=0;k<mutationsList.length;k++) {
            if(!$(e).is(":visible") && pega.u.d.getPopOver(e)){
              var popoOverElement = pega.u.d.getPopOver(e).getActivePopOverElement();
              if(popoOverElement && popoOverElement.className && (popoOverElement.className.indexOf("smarttip-container") !== -1 || popoOverElement.className.indexOf("smartInfoContainer") !== -1)){ /*BUG-526332 Disimiss only respective popover*/
                pega.u.d.getPopOver(e).close();
                observer.disconnect();
                break;
              }
            }
            if(!$(e).is(":visible")){
              observer.disconnect();
              break;
            }
          }
        };
        var observer = new MutationObserver(callback);
        observer.observe(targetNode, config);

      };

        
        this.open = function (options) {
            if (this.isActive()) {
                if (bindingsEqual(options.bindings) && visualEqual(options.visual)) {
        if(!options.extraParams || options.extraParams.refresh == false){
            return;
        }
                }
                else {
                    /* BUG-116528: added forceClose argument to close api */
                    this.close("clickaway", null, true);
                }
            }
            // 1. Initialize.
            init(this, options);
            // 2. Display Loader - Resize the loader markup according to the current field. Update it to display Title/Ok/Close etc and display it. 
            displayLoader(this);
            // 3. Bind click away handlers.
            //US-79038 Disable clickaway configuration
            var bAddClickAway = true;
            if(options.extraParams!=null && options.extraParams.bIsDisableClickaway!=null && options.extraParams.bIsDisableClickaway.toUpperCase()=="TRUE"){
                bAddClickAway = false;
                _IsDisabledClickaway=true;
            }
            if (bAddClickAway) {
                _IsDisabledClickaway=false;     
                ensureClickAwayAttached();
            }
            //US-79038 Disable clickaway configuration - changes end
            // 4. Fetch Content - Determine the content fetch strategy and initiate it.
            setContentFetchStrategy(this);
                
            /* BUG-345864: START */
            if(pega.ctxmgr && typeof(pega.ctxmgr.registerContextSwitching) === "function") {
              pega.ctxmgr.registerContextSwitching(_popOversContainer);
            }
            /* BUG-345864: END */
            _contentFetchStrategy.initiateFetch();
            if(_visual.isMobile && _visual.isMobileFullScreen === "true"){
               pega.u.d.localActionContainerOpened(true);
              
              
              $(".screen-layout-region-main-middle").css("overflow-y","visible");
                $(".screen-layout-region-main-middle").css("overflow-x","visible");
              $(".screen-layout-region-main-middle").css("overflow","visible");
            }
            // 5. Load and display Content - When the async method comes back, load it in the popover and reposition and display.
            // Note - This happens in the success callback of the content fetch method.
          
            // US-91158
            // 6. Calling dummy button creation function for a focus cycle loop
            createLoopingButtons(this);
            if(_clickAwayProvider && options.bindings && options.bindings.associatedElement) {
              ensureClickAwayAttached();
              _clickAwayProvider.registerScrollHandlers(options.bindings.associatedElement);
            }
            if(options.bindings && options.bindings.associatedElement) {
                if(_popoverAssociateElemStack == null) {
                    _popoverAssociateElemStack = new Array();
                }
                _popoverAssociateElemStack.push(options.bindings.associatedElement);
            }
          
            //TASK-595108 : 7. adding this to back navigation history
            if(pega.mobile.nativenav && this.getAssociatedElement() != null && !(this.getAssociatedElement().dataset.backNavId)){
                this.getAssociatedElement().dataset.backNavId = pega.mobile.nativenav.addToHistory(this.close, this);
            }
          if(_container && _container.className && (_container.className.indexOf("smarttip-container") !== -1 || _container.className.indexOf("smartInfoContainer") !== -1)){
            registerDOMObserver(options.bindings.associatedElement); /* BUG-518645 - To dismiss overlay once the associated element gets removed or hidden */
          }
        };

        this.getActivePopOverElement = function () {
            if (_state === 'active') {
                return _container;
            }
            if (_state === 'loader' && _visual.displayLoader) {
                return _loaderContainerElement;
            }

            return null;
        };

        this.getContentContainerElement = function () {
            return _container;
        };

        this.getAssociatedElement = function () {
            return _attachedDomElement;
        };

        this.getSectionElement = function () {
            return getSectionRootElement(getPopOverContentContainer(this.getLevel()));
        }

        var ensureClickAwayAttached = function () {

            _clickAwayProvider.registerClickAway(clickAwayHandler);
        };

        var bindDBP = function (popOver) {
            _dbp.bind.call(_dbp, popOver, _bindings);
        };

        var unbindDBP = function (popOver) {
            if (typeof _dbp.unbind === 'function') {
                _dbp.unbind.call(_dbp, popOver, _bindings);
            }
        };

        var _popOverCloseInitiated = false;

        var clickAwayHandler = function (e, reason) {
                switch (reason) {
                case "scroll":
                    if(_visual.isMobile && _visual.isMobileFullScreen === "true"){
                        return;
                    }
                    try {
                        var target = p.util.Event.getTarget(e);
                        if(target && target.nodeName =="#document"){
                            try { /* BUG-167348: repositioning pop over if associatedElement inside a modal dialog */
                                if (pega.u.d.bModalDialogOpen && _state === "active" && _container) {
                                    var _associatedElement = getAttachedDomElement();
                                    var mOverlay = document.getElementById("modalOverlay");
                                    if (mOverlay && pega.util.Dom.isAncestor(mOverlay, _associatedElement) && p.u.d.getPopOver(_associatedElement).isActive()) {
                                        p.u.d.scrolled = true;
                                        p.u.d.getPopOver(_associatedElement).reposit();
                                        if ($(_container).css("visibility") === "hidden") {
                                            $(_container).css("visibility","visible");
                                        }
                                    }
                                }
                            } catch(e) { }
                            return;
                        } else if (target && target.nodeName.toLowerCase() == "div" && target.id == "HARNESS_CONTENT") {
                            var fixedBBStylesBlock = document.getElementById("fixedBBStyles");
                            if(fixedBBStylesBlock && _container) {
                                var _associatedElement = getAttachedDomElement();
                                if (pega.util.Dom.isAncestor(target, _associatedElement) && p.u.d.getPopOver(_associatedElement).isActive()) {
                                    _associatedElement.setAttribute("data-setActualY", "true"); 
                                    p.u.d.scrolled = true;
                                    p.u.d.getPopOver(_associatedElement).reposit();
                                    _associatedElement.removeAttribute("data-setActualY");
                                    if ($(_container).css("visibility") === "hidden") {
                                        $(_container).css("visibility","visible");
                                    }
                                }
                            }
                        } 
                        /** BUG-288815: Adding OR conditions with  'screen-layout-region and static-dc-tab' */
                      // BUG-605422 adding target.getAttribute("class") as there are exceptions when target does not have class
                      else if(_container && target && ((target.nodeName.toLowerCase() == "div" && target.id == "PEGA_HARNESS") || (target.getAttribute("class") && (target.getAttribute("class").indexOf("modal-scroll-panel") != -1 || target.getAttribute("class").indexOf("workarea-view-scroll-wrapper") != -1 || target.getAttribute("class").indexOf("screen-layout-region") != -1 || target.getAttribute("class").indexOf("static-dc-tab") != -1 )))){
                          var _associatedElement = getAttachedDomElement();
                          if (pega.util.Dom.isAncestor(target, _associatedElement) && p.u.d.getPopOver(_associatedElement).isActive()) {
                            _associatedElement.setAttribute("data-setActualY", "true"); 
                            p.u.d.scrolled = true;
                            p.u.d.getPopOver(_associatedElement).reposit();
                            _associatedElement.removeAttribute("data-setActualY");
                            if ($(_container).css("visibility") === "hidden") {
                              $(_container).css("visibility","visible");
                            }
                          }
                        }
                      
                       else if(target && target.nodeName.toLowerCase() == "div" && target.id == "INNERDIV-SubSectionpyPortalContentBB"){
                          var _associatedElement = getAttachedDomElement();
                         
                          _associatedElement.setAttribute("data-setActualY", "true");
                         p.u.d.scrolled = true;
                         p.u.d.getPopOver(_associatedElement).reposit();
                         _associatedElement.removeAttribute("data-setActualY");
                         if ($(_container).css("visibility") === "hidden") {
                           $(_container).css("visibility","visible");
                         }                          
                        } else {
                          var _associatedElement = getAttachedDomElement();
                          var _activeAssociatedElement = getActiveAssociatedElement();
                          if (target && target.getAttribute("data-popover-scroll") == "yes") {
                            if(pega.util.Dom.isAncestor(target, _associatedElement)  && p.u.d.getPopOver(_associatedElement).isActive()) {
                              _associatedElement.setAttribute("data-setActualY", "true"); 
                              p.u.d.scrolled = true;
                              p.u.d.getPopOver(_associatedElement).reposit();
                              _associatedElement.removeAttribute("data-setActualY");
                              if ($(_container).css("visibility") === "hidden") {
                                $(_container).css("visibility","visible");
                              }
                            } else if (pega.util.Dom.isAncestor(target, _activeAssociatedElement)  && p.u.d.getPopOver(_activeAssociatedElement).isActive()) {
                              _activeAssociatedElement.setAttribute("data-setActualY", "true");
                              var _activePO = p.u.d.getPopOver(_activeAssociatedElement);
                              var _extraParams = {"useRelativeElement": true}; 
                              p.u.d.scrolled = true;
                              _activePO.reposit(_extraParams, _activeAssociatedElement);
                              _activeAssociatedElement.removeAttribute("data-setActualY");
                              var _activePOContainer = _activePO.getContentContainerElement();
                              if ($(_activePOContainer).css("visibility") === "hidden") {
                                $(_activePOContainer).css("visibility","visible");
                              }
                            }
                          }
                        }
                    }catch (ex) {
                        // If clickaway cannot determine the popover level, do not proceed.
                        return;
                    }   
                    break;
                case "click":
                    var clickedPopOverLevel = -1;
                    try {
                        var target = p.util.Event.getTarget(e);

                        if(!pega.util.Dom.inDocument(target)) {
                            return;
                        }
            var smartPromptDiv = document.getElementById("ISnsPopDiv");
                        var menuDiv = document.getElementById("menuFromOverlay");
                        if((smartPromptDiv && pega.util.Dom.isAncestor(smartPromptDiv, target)) || menuDiv) {
                            if(menuDiv) $(menuDiv).remove();
                            return;
                        }
                      var fullScreenDateRange = document.getElementsByClassName("daterangefullscreen");
                      if(isMobile && fullScreenDateRange && pega.util.Dom.isAncestor(fullScreenDateRange[0], target)){
                        return;
                      }
                        clickedPopOverLevel = _getPopOverLevelForElement(target);
                    }
                    catch (ex) {
                        // If clickaway cannot determine the popover level, do not proceed.
                        return;
                    }
                    var rootPopOver = p.u.d.getPopOver();
                    var clickedPopOver = (clickedPopOverLevel !== -1) ? p.u.d.getPopOver(clickedPopOverLevel) : NULL;
                    var popOverToClose = (clickedPopOver == NULL) ? rootPopOver : clickedPopOver.getChildPopOver(false);
                    if (popOverToClose != NULL && popOverToClose.getAssociatedElement() != target) {
                        //US-79038 : Disable clickaway configuartion - Handling Nested Overlays - START
                        var popOverToCloseArray= [];
                        popOverToCloseArray.push(popOverToClose);
                        while(popOverToClose.getChildPopOver(false)!=NULL && popOverToClose.getChildPopOver(false).isActive())
                        {
                            popOverToCloseArray.push(popOverToClose.getChildPopOver(false));
                            popOverToClose=popOverToClose.getChildPopOver(false);
                        }
                        while(popOverToCloseArray.length>0 && popOverToCloseArray[popOverToCloseArray.length-1].isDisabledClickaway()==false){
                            popOverToCloseArray.pop().close('clickaway',"","",target);
                        }
                        //US-79038 : Disable clickaway configuartion - Handling Nested Overlays - END
                    }
                    break;
                    case "iframe-clickaway":
                        var target = p.util.Event.getTarget(e);

                        if(!target) {
                            return;
                        }                     
                    var rootPopOver = p.u.d.getPopOver();
                    popOverToClose =  rootPopOver;
                    if (popOverToClose != NULL && popOverToClose.getAssociatedElement() != target) {
                        //US-79038 : Disable clickaway configuartion - Handling Nested Overlays - START
                        var popOverToCloseArray= [];
                        popOverToCloseArray.push(popOverToClose);
                        while(popOverToClose.getChildPopOver(false)!=NULL && popOverToClose.getChildPopOver(false).isActive())
                        {
                            popOverToCloseArray.push(popOverToClose.getChildPopOver(false));
                            popOverToClose=popOverToClose.getChildPopOver(false);
                        }
                        while(popOverToCloseArray.length>0 && popOverToCloseArray[popOverToCloseArray.length-1].isDisabledClickaway()==false){
                            popOverToCloseArray.pop().close('iframe-clickaway',"","",target);
                        }
                        //US-79038 : Disable clickaway configuartion - Handling Nested Overlays - END
                    }
                    break;
                default :
                    var rootPopOver = p.u.d.getPopOver();
                    if(reason === "escape") {
                      /* BUG-299141: Checking for keyboard tab event and the active element is of body,
                      then skipping close popover container */
                      try {
                        if(e.keyCode === 9 && pega.u.d.focusElement && pega.u.d.focusElement.firstElementChild &&
                           pega.u.d.focusElement.firstElementChild.className === "iconOpenRule" &&
                           document.activeElement && document.activeElement.tagName && document.activeElement.tagName.toLowerCase() === "body") {
                          return;
                        }
                      } catch(e) { }
                      
                      if(27 === e.keyCode && rootPopOver){
                        /* escape key */
                        var currPopOverLevel = -1;
                        try {
                          var target = p.util.Event.getTarget(e);
                          if (!pega.util.Dom.inDocument(target)) {
                            return;
                          }
                          currPopOverLevel = _getPopOverLevelForElement(target);
                        } catch (ex) {
                          // If clickaway cannot determine the popover level, do not proceed.
                          return;
                        }
                        var currentPopOver = (currPopOverLevel !== -1) ? p.u.d.getPopOver(currPopOverLevel) : NULL;
                        if (currentPopOver) {
                          currentPopOver.close("", "", "", target);
                        } else {
                          rootPopOver.close("","","",target);
                        }
                      }
                    }
                    
                    /* US-91158:Overlay accessibility */
                    if(e.keyCode === 9 && rootPopOver){
                      /* To avoid dismissing smarttip immediately on tab key - Start */
                      var popOverElement = rootPopOver.getActivePopOverElement();
                      var _target = p.util.Event.getTarget(e);
                      if(popOverElement && popOverElement.className && (popOverElement.className.indexOf("smarttip-container") !== -1) && _target === rootPopOver.getAssociatedElement()){
                        return;
                      }/* End */
                      if(!rootPopOver.isDisabledClickaway())
                        rootPopOver.close("","","",target); /* close() is called without arguments. This will set back the focus to the element that triggered the overlay */ 
                    }
                    /*rootPopOver.close('clickaway');*/
                    break;
            }
        };

        var onContentReady = function (fetchResult) {
            contentFetchComplete(this);
        };

        var contentFetchComplete = function (scope) {
            createButtons();
           /* 08/06/2011 GUJAS1 BUG-43380 - Positioning needs to be postponed till onContentReady callback
            is finished. This callback can modify the content thereby changing its dimensions.
            This would render previous position incorrect, as is apparent by the use-case in BUG-43380.
            Performing the repositioning after onContentReady is better since at that point, all the 
            content modification has been completed and the content is ready to be displayed.*/
            /*positionElementRelativeTo(_attachedDomElement, _container, _position, true);*/
            hideLoader();
            bindDBP(scope);
            _state = 'active';
            invokeCallback(_callbacks.onContentReady, [_container]);
            callPopOverListeners("onContentReady");
          
           /* 08/06/2011 GUJAS1 BUG-43380 - Positioning needs to be postponed till onContentReady callback
            is finished. This callback can modify the content thereby changing its dimensions.
            This would render previous position incorrect, as is apparent by the use-case in BUG-43380.
            Performing the repositioning after onContentReady is better since at that point, all the 
            content modification has been completed and the content is ready to be displayed.*/
    
            var secElem = _that.getSectionElement();
            /* BUG-76002 : START, Here to avoid taking full width applied style:inline for the outer section 
            if(secElem) {
                secElem.style.display = 'inline';
            }

            BUG-76002 : END */
         
            fixSectionTableWidth(secElem, "auto");
            // Skip positioning the overlay in case if it is center aligned
            if(scope._IsCenterOverlay && (scope._IsCenterOverlay==true || scope._IsCenterOverlay.toUpperCase()=="TRUE")){
                var csstext = '';
              csstext = csstext+"z-index:100;";
                
                var client = getCientDimensions();
                var height = client.bottom - client.top;
                var width = client.right - client.left;
                var containerScrollWidth = _container.scrollWidth;
                var containerScrollHeight = _container.scrollHeight;
              if(containerScrollHeight >= height){
                csstext = csstext+"overflow-y:auto;height:"+(height-20)+"px;";
              } else {
                csstext = csstext+"overflow-y:auto;max-height:100%;";
              }
              if(containerScrollWidth >= width){
                csstext = csstext+"overflow-x:auto;width:"+(width-20)+"px;";
              }
              /*if(pega.env.ua.gecko > 0){ //center overlay in ff
                var top = (height/2) - (_container.clientHeight/2);
                csstext += "top: "+ top + "px !important;"
              }*/
              _container.style.cssText=csstext;
            }
            else{
                positionElementRelativeTo(_attachedDomElement, _container, _position, true, _level, _visual.arrowDivClasses, _extraParams);
            }

            //fixSectionTableWidth(secElem, "100%");
            _displayShim(scope);
          //TASK-265559 bajaj 19-01-2015 begin
            
            if(pega.ctx && pega.ctx.pzHarnessID) {
                _container.setAttribute("data-harness-id", pega.ctx.pzHarnessID);
            }
            var $container = $(_container);
            var isOffline = pega.u.d.ServerProxy.isDestinationLocal();
            if(!_visual.isMobile){
                $container.css("visibility","visible");
               if(pega.u.d.modalDialog && pega.u.d.modalDialog._revealDismissAnimation){
                 var otherParamObj = {clearProps: "transform"};
                 pega.u.d.modalDialog._revealDismissAnimation(_container, _visual.animations, "reveal", undefined, otherParamObj);
               }     
            } else {
                if(pega.u.d.allowTransition()){
                    setTimeout(function(){
                        $container.css("visibility","visible");
                      if(pega.u.d.modalDialog && pega.u.d.modalDialog._revealDismissAnimation){
                        var otherParamObj = {clearProps: "transform"};
                        pega.u.d.modalDialog._revealDismissAnimation(_container, _visual.animations, "reveal", function(){
                            invokeCallback(_callbacks.onContentDisplayed, [_container]);
                        }, otherParamObj);
                      }
                    }, 0);
                } else {
                    $container.css("visibility","visible");
                }
            }
         
            /*RAIDV: BUG-201802
            Show transition - in OSCO and Online apps when coming from LA and in mobile phone ex -> Nexus 5 
            Set initial visibility to hidden - Only in OSCO apps when coming from LA and in NOT mobile phone ex -> iPad
            (Subscribers of popover like datetime, etc should not have visibility hidden nor should they have any transition)
            */
            
            /*if( pega.u.d.allowTransition()){
                      setTimeout(function(){
                          $container.addClass('anim anim-show');
                          pega.u.d.runTransitionTimeout(".anim.anim-show",this,function(){
                              invokeCallback(_callbacks.onContentDisplayed, [_container]); 
                          });
                      },0);
            }else if(isOffline && _visual.isLocalAction ){
              /*sings9: (BUG-197846) Hiding the Overlay till the data is loaded when it will be displayed in Offline on a non mobile device
              $container.css("visibility","hidden");
            } */
            
            // TASK-265553 @yellk
            if(_visual.isMobile && _visual.isMobileFullScreen === "true"){
                _that.setProperHeight();
                $(window).resize(function(event) { // tried registerResize/ orientatiinchange nothing worked
                  _that.setProperHeight();
                } );
            }else{
                invokeCallback(_callbacks.onContentDisplayed, [_container]);
            }
            
        }
        
        this.setProperHeight = function(){
            if(_visual.isMobile && _visual.isMobileFullScreen === "true"){
                function calcHeight(el){
                    var btHeight = 0;

                    if(el != null){
                        while(el.nodeType !=1){
                            el = el.nextSibling;
                            if(el == null) break;
                        }
                        if(el != null) {
                            btHeight = el.offsetHeight;
                        }
                    }
                    
                    return btHeight;
                }
                
            //  var dh = pega.u.d.getDocHeight(); // BUG-188006 bajaj for submit/cancel layout full screen mobile
                var dh = $(_container).height(); //BUG-219518 - use container height in place of doc height to handle landscape mode popovers
              //BUG-244703: Checking if footer is present for the section in Local Action
                var hasOverlayFooter = $($(_container).find('#poc0').find('.sectionDivStyle')[0]).children().last().hasClass('layout');
                var bh = hasOverlayFooter? calcHeight($($(_container).find('#poc0').find('.sectionDivStyle')[0]).children().last()[0]): 0;
                var sec = $(_container).find('#modaldialog_con').find('.sectionDivStyle')[0];
                $(sec).css('max-height',dh-bh-2);
                $(sec).css('overflow-y',"auto");// end task
            }
        }
        
        var onContentFetchSuccess = function (response) {
            if (_popOverCloseInitiated || _state != 'loader') {
                return;
            }
            var strResponse = response.responseText;
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = strResponse;
          //  fixSectionTableWidth(getSectionRootElement(tempDiv), "auto");
            var popOverDiv = getPopOverContentContainer(_level);
            var _this = this;
            var callbackInterceptor = function () {
                pega.u.d.loadHTMLEleCallback(popOverDiv);
                contentFetchComplete(_this);            
            }
            p.u.d.loadDOMObject(popOverDiv, tempDiv, callbackInterceptor);
        };

        var onContentFetchFailed = function () {
            displayFetchError();
        };

        var onDomElementFetched = function () {                 
            contentFetchComplete(this);
        };

        var displayFetchError = function () {
            // TODO:
        };

        var _contentFetchStrategy = NULL;

        var setContentFetchStrategy = function (scope) {
            var contentType = _content.type;
            switch (contentType) {
                case "section":
                    _contentFetchStrategy = new SectionFetchStrategy(_content, scope, onContentFetchSuccess, onContentFetchFailed);
                    break;
                case "method":
                    var contentFetchMethod = _content.contentMethod;
                    var contentFetchMethodType = typeof contentFetchMethod;
                    var contentMethodIsObject = contentFetchMethodType === 'object';
                    // If a fetch function is not specified either directly or as the first parameter of the callback array, throw an exception.
                    if (contentFetchMethodType !== 'function' && !contentMethodIsObject && typeof contentFetchMethod[0] !== 'function') {
                        throw ("Content Fetch Method is not specified.\nPopover requires this method if the value of content.type is specified as 'method'.");
                    }
                    var args = (contentMethodIsObject) ? contentFetchMethod[1] : NULL;
                    var contentMethodScope = (contentMethodIsObject) ? contentFetchMethod[2] : NULL;
                    var popOver = scope;
                    if (typeof args === 'object' && typeof args.length === 'number') {
                        // Add popOver to the beginning of the arguments array, so that the contentFetchMethod
                        // recieves the popOver instance as its first parameter.
                        args.unshift(popOver);
                    }
                    else {
                        args = [popOver];
                    }
                    _contentFetchStrategy = new MethodFetchStrategy(contentMethodScope, contentFetchMethod, args, scope, onContentReady);
                    break;
                case "domElement":
                    var element = _content.element;
                    if (typeof element !== 'object') {
                        throw ("Content dom element reference is not specified.\nPopover requires this reference if the value of content.type is specified as 'domElement'.");
                    }
                    _contentFetchStrategy = new DomElementFetchStrategy(_content.element, getPopOverContentContainer(_level), scope, onDomElementFetched);
                    break;
            }
        };

        // Gets the dom element reference of the field with which this popover is attached.
        var getAttachedDomElement = function () {
            if (_bindings.associatedElement) {
                return _bindings.associatedElement;
            }

            var result = NULL;
            if (_bindings.associatedProperty) {
                result = getDomElementForProperty(_bindings.associatedProperty);
            }

            return result;
        };

        var getActiveAssociatedElement = function() {
            if(_popoverAssociateElemStack != null && _popoverAssociateElemStack.length >= 1) {
                return _popoverAssociateElemStack[_popoverAssociateElemStack.length-1];
            } else {
                return null;
            }
        }

        var displayLoader = function (scope) {
            _state = 'loader';
            if (_visual.displayLoader === true) {
                if (typeof _visual.customShowLoader == 'function') {
                    _visual.customShowLoader();
                    return;
                }
                var loaderWidth = getElementSizeXY(_attachedDomElement).x;
                positionElementRelativeTo(_attachedDomElement, _loaderContainerElement, _position);
                _displayShim(scope);
                
                _loaderContainerElement.style.visibility = "visible";               
                
                /* BUG-259811: Triggering a reflow in iPad Safari */
                if(jQuery("html").hasClass("safari") && jQuery("html").hasClass("iOS")) {
                    var tempDisplay = "visible";
                    tempDisplay =  window.getComputedStyle ? window.getComputedStyle(document.body, "").visibility : document.body.style.visibility;
                    document.body.style.visibility = "hidden";
                    document.body.offsetHeight;
                    document.body.style.visibility=tempDisplay;
                }
                _loaderBusyInd=pega.u.d.setBusyIndicator(_loaderContainerElement,true,false);
            }
        };

        var hideLoader = function () {
            if (_visual.displayLoader === true) {
                if (typeof _visual.customHideLoader == 'function') {
                    _visual.customHideLoader();
                    return;
                }

                _loaderBusyInd.hide();
                _loaderContainerElement.style.cssText = 'visibility:hidden;';
                _loaderContainerElement.firstChild.style.cssText = '';
              
                /* BUG-259811: Triggering a reflow in iPad Safari */
                if(jQuery("html").hasClass("safari") && jQuery("html").hasClass("iOS")) {
                    var tempDisplay = "visible";
                    tempDisplay =  window.getComputedStyle ? window.getComputedStyle(document.body, "").visibility : document.body.style.visibility;
                    document.body.style.visibility = "hidden";
                    document.body.offsetHeight;
                    document.body.style.visibility=tempDisplay;
                }
            }
        };

        var createButtons = function () {
            var buttonsContainer = document.getElementById("pob" + _level);
            if (!buttonsContainer) {
                return;
            }

            var hrContainer = document.getElementById("pohr" + _level);

            var buttons = '';

            if (_buttons.ok) {
                var okButtonText = _buttons.okText ? _buttons.okText : 'OK';
                buttons += _buttonsMarkupTemplate.replace(/\{0\}/g, _level).replace(/\{1\}/g, 'OK').replace(/\{2\}/g, okButtonText);
            }

            if (_buttons.cancel) {
                var cancelButtonText = _buttons.cancelText ? _buttons.cancelText : 'Cancel';
                buttons += _buttonsMarkupTemplate.replace(/\{0\}/g, _level).replace(/\{1\}/, 'cancel').replace(/\{2\}/g, cancelButtonText);
            }

            hrContainer.style.display = buttonsContainer.style.display = "none";
            if (buttons.length > 0) {
                buttonsContainer.innerHTML = '<div>' + buttons + '</div>';
                hrContainer.style.display = buttonsContainer.style.display = "block";
            }
        };
        /* For run time backward compatibility of US-265506 */
        var _processAnimObj = function(visualsObj){
            var animationObj = {};
            if(visualsObj.animations){
                var animObj = visualsObj.animations;
                /* For backward compatibility US-265506 */    
                if (animObj && animObj.animIn && animObj.animOut) {
		                /* For backward compatibility - Checking for string null because in case of no animations set, animIn and animOut values are set as "anim-null" */
    		            if (animObj.animIn.indexOf("null") == -1 && animObj.animOut.indexOf("null") == -1) {
		                    var newAnimInEffect = pega.u.d.modalDialog._getEffect ? pega.u.d.modalDialog._getEffect(animObj.animIn) +
		                        "-open" : "none";
    		                var newAnimOutEffect = "";
		                    if (animObj.animOut === "anim-in-animation") {
		                        newAnimOutEffect = "reverse-" + newAnimInEffect;
    		                } else {
		                        newAnimOutEffect = pega.u.d.modalDialog._getEffect ? pega.u.d.modalDialog._getEffect(animObj
		                            .animOut) + "-close" : "none";
    		                }
		                    animationObj.mobile = {
		                        "reveal": {
		                            "effect": newAnimInEffect
    		                    },
		                        "dismiss": {
		                            "effect": newAnimOutEffect
    		                    }
		                    }
                        visualsObj.isMobileFullScreen = "true";
    		            }
        		    } else {
		                if (animObj && pega.u.d.modalDialog._processAnimObj) {
		                    animationObj = pega.u.d.modalDialog._processAnimObj(animObj);
		                }
        		    }
                visualsObj.animations = animationObj;
            }
            
        };
        var init = function (po, options) {
            _popOverCloseInitiated = false;
            _state = 'init';
            _options = options;
            _dbp = _emptyDBP;
        _extraParams = {};
           _bindings = {};
           _position = {};
           _content = {};
           _callbacks = {};
           _buttons = {ok: true, cancel: true};
           _visual = { displayLoader: true, customShowLoader: null, customHideLoader: null, contentClass: '', arrowDivClasses: null , isMobile: false};
        //arrowDivClasses should be array like [defaultClass, verticallyFlippedClass, horizontallyFlippedClass, bothFlippedClass]
           
            if (options) {
                if (options.bindings) {
                    _bindings = options.bindings;
                    if (typeof _bindings.bindingProvider === 'object' && typeof _bindings.bindingProvider.bind === 'function') {
                        _dbp = _bindings.bindingProvider;
                    }
                }
                if (options.position) {
                    _position = options.position;
                }
                if (options.content) {
                    _content = options.content;
                    // Assume type as section if not specified.
                    if (typeof _content.type == 'undefined') {
                        _content.type = 'section';
                    }
                }
                if (options.callbacks) {
                    _callbacks = options.callbacks;
                }
                if (options.buttons) {
                    _buttons = options.buttons;
                }
                if (options.visual) {
                    $.extend(true,_visual,options.visual);
                }
           if (options.extraParams) {
                    _extraParams = options.extraParams;
                }
            }
            _loaderContainerElement = getPopOverLoaderContainer(_level);
            _attachedDomElement = getAttachedDomElement();
            
           //Center Position Overlay
           if(_extraParams.bIsCenterOverlay!=null && _extraParams.bIsCenterOverlay.toUpperCase()=="TRUE"){
             _popOversContainer.className="fixedPopOverContainer";
             _popOversContainer.style.display='block';
             po._IsCenterOverlay=true;
           }

            // Ensure that _container is initialized and present in DOM
            if (!_container || !document.body.contains(_container)) {
                _container = getPopOverContainer(level);
                _container.po = po;
            }
            //TASK-265559 bajaj 19-01-2015 begin
            var bFlag = $('html').hasClass('phone');
            _visual.isMobile = bFlag;
            _processAnimObj(_visual);
            if (_visual.isMobile && _visual.isMobileFullScreen === "true") {
                if(!_container.classList.contains("local-action")){
                    _container.classList.add("local-action");    		
                }
            } else {		
                _container.classList.remove("local-action");		
            }
                  
          // end
            var cssClass = _visual.contentClass;
            
            if(_extraParams && _extraParams.modalStyle && _extraParams.modalStyle!="") cssClass += " " + _extraParams.modalStyle;
            if (cssClass.length > 0) {
                p.util.Dom.addClass(_container, cssClass);
                //Center Position Overlay
              if(_extraParams.bIsCenterOverlay!=null && _extraParams.bIsCenterOverlay.toUpperCase()=="TRUE"){
                  p.util.Dom.addClass(_container, "centerOverlay");
                  /*if(pega.env.ua.gecko > 0){  //center overlay in ff
                    p.util.Dom.addClass(_container, "table-display");
                  }*/
              }
            }

            if (_visual.arrowDivClasses && _visual.arrowDivClasses.length > 0) {
                document.getElementById("arrow"+_level).className = _visual.arrowDivClasses[0];
            }

            _bindings.popOverElement = _container;

            if (_attachedDomElement == NULL) {
                // If there is no dom element associated with the attached property, popover loader should be displayed with the document element.
                _attachedDomElement = document.body;
                _position.fieldAttach = _position.popOverAttach = "centerMiddle";
                _position.offsetAttach = {
                    x: 0,
                    y: 0
                };
            }

            _state = 'ready';
        };

        this.reposit = function (_extraParams, _activeAssociateElem) {
        positionElementRelativeTo(((typeof(_activeAssociateElem) != "undefined" && _activeAssociateElem != null)?_activeAssociateElem:_attachedDomElement), _container, _position, true, _level, _visual.arrowDivClasses, _extraParams);
        };


        this.close = function (closeReason, closeResult, forceClose, target) {
            // If the state is set to locked then fall out. Added for Live UI to allow overlays to be inspected/edited
            if (this.getState() == "locked" || $(this.getContentContainerElement()).hasClass('has-assertion-popover')) {
                $(this.getContentContainerElement()).removeClass('has-assertion-popover');
                return;
            }

            //TASK-595108 : Removing this from back navigation history
            if (pega.mobile.nativenav && this.getAssociatedElement() != null) {
                pega.mobile.nativenav.removeFromHistory(this.getAssociatedElement().dataset.backNavId);
                this.getAssociatedElement().dataset.backNavId = "";
            }
          
            _popOverCloseInitiated = true;

            if (!this.isActive()) {
                return;
            }

            if (typeof _callbacks.onBeforeClose !== 'undefined') {
                if (invokeCallback(_callbacks.onBeforeClose, [closeReason, closeResult, _bindings, target]) !== true) {
                    /*if (typeof forceClose !== 'undefined' && !forceClose) {
                        return;
                    }*/
                     /*BUG-128978*/
           if (!forceClose) {
            return;
           }
                }
            }

            _state = "closing";
            if (pega.c && pega.c.actionSequencer) {
                    pega.u.d.pauseAjaxSequencer();
                    //pega.c.actionSequencer.pause();
            }
            // Close any sub popovers, cancelling them.
            if (_childPopOver != NULL) {
                _childPopOver.close('cancel');
            }

            // Clean up content fetch.
            _contentFetchStrategy.cleanUp();

            // Hide the popover.
            hideLoader();
            // TASK-265559: bajaj 01/19/2015: Moved the visual cleanup chore to closeCleanup to
            // take care of animations during close.
            //_container.style.cssText = 'visibility:hidden; height:; width:;';

            _hideShim(this);

          // Set back the default value of isCenterOverlay
          if(this._IsCenterOverlay){
            this._IsCenterOverlay=false;
          }

            if (_visual.arrowDivClasses && _visual.arrowDivClasses.length > 0) {
                p.util.Dom.addClass(document.getElementById("arrow"+_level), 'po-arrow-hide');
            }

            // Update the popover result field with the closeResult value.
            this.setResult(closeResult);

            // Remove clickaway handlers.
            if (_level === 0) {
              _clickAwayProvider.removeClickAway();

              /* BUG-345864: START */
              if(pega.ctxmgr && typeof(pega.ctxmgr.unregisterContextSwitching) === "function") {
                pega.ctxmgr.unregisterContextSwitching(_popOversContainer);
              }
              /* BUG-345864: END */
            }

            if (typeof _dbp.onClose === 'function') {
                _dbp.onClose.call(_dbp, closeReason);
            }

            unbindDBP(this);

            // TASK-265559: bajaj 01/19/2015: Moved the visual cleanup chore to closeCleanup to
            // take care of animations during close.
            // // Call the OnClose callback with the specified closeResult.
            // invokeCallback(_callbacks.onClose, [closeReason, closeResult, _bindings]);
            
            // _state = 'inactive';

            // _popOverCloseInitiated = false;
            

            var that = this;
          function _dismissCallback(){
              _container.style.removeProperty("opacity");
              //SE-62599
              if(pega.util.Event.isIE) { 
                pega.ctxmgr.skipContextSwitching = true;
              }
              _container.style.removeProperty("visibility");
              _container.style.removeProperty("transform");
              _container.classList.remove("local-action");
              var cssClass = _visual.contentClass;
              if(cssClass == 'pz-po-c-rteoverlay') {
                  pega.ui.rte.resetModalFlag();
              }
              if(_extraParams && _extraParams.modalStyle && _extraParams.modalStyle!="") {
                  cssClass += " " + _extraParams.modalStyle;
              }
              if (cssClass.length > 0) {
                  p.util.Dom.removeClass(_container, cssClass);
                  p.util.Dom.removeClass(_container, "centerOverlay");
                  /*if(pega.env.ua.gecko > 0){   //center overlay in ff
                      p.util.Dom.removeClass(_container, "table-display");
                  }*/
                  if(_container.previousSibling ==NULL || typeof(_container.previousSibling)=='undefined'){
                        _popOversContainer.className="";
                    }
              }
              delete pega.ctxmgr.skipContextSwitching;
          }
          var hasAnimations = pega.u.d.modalDialog && pega.u.d.modalDialog._hasAnimations && pega.u.d.modalDialog._hasAnimations(_visual.animations, "dismiss");
          if(pega.u.d.modalDialog && pega.u.d.modalDialog._revealDismissAnimation){
              if(hasAnimations){
                  var otherParamObj = {clearProps: "transform"};
                  pega.u.d.modalDialog._revealDismissAnimation(_container, _visual.animations, "dismiss", function(){
                      _dismissCallback();
                      that.closeCleanup(closeReason, closeResult, _bindings, true);
                  }, otherParamObj);      
              } else {
                  _dismissCallback();
                  that.closeCleanup(closeReason, closeResult, _bindings);
              }
          }else{
              _dismissCallback();
            if (_visual.animations && pega.u.d.allowTransition() && $(_container).hasClass("anim-show")){
                var $container = $(_container);
                if(_visual.animations.animIn != _visual.animations.animOut){
                    $container.removeClass(_visual.animations.animIn).addClass(_visual.animations.animOut);
                } 
                var that = this;
                $container.width($container.width()).removeClass("anim-show");
                pega.u.d.runTransitionTimeout(".anim",that,function(){
                  $container.removeClass("anim").removeClass(_visual.animations.animOut);
                  $container.removeClass("local-action");
                  
                });
            }
            else{
                this.closeCleanup(closeReason, closeResult, _bindings);
            }
            
        }
            
            /* US-91158: Overlay accessibility */
            var overlayContainerElement = this.getContentContainerElement();
            var liContainingOverlay = $(overlayContainerElement).find("li:eq(0)")[0];   
          
            /* removing the tabindex attribute from overlay body in case there is no focussable element in an overlay */
            if(!($(':not(.circular-btn-placeholder):tabbable:first', liContainingOverlay).length)){
              var dialogBody = pega.util.Dom.getElementsByClassName('sectionDivStyle', 'div', liContainingOverlay);
              if((dialogBody.length > 0) && (dialogBody[0].getAttribute('tabindex')))
                dialogBody[0].removeAttribute('tabindex');
            }
          
            /* Removing the dummy buttons, used for focus cycling, when the overlay is closed */
            $(liContainingOverlay).parent().find("button.circular-btn-placeholder").remove();
            
            return closeResult;
        };

        this.closeCleanup = function(closeReason, closeResult, bindings, isTransitionDone){
            if(pega && pega.offline){/*BUG-199680 : in hybrid client if style.cssText is used screen is frozen, so changed to use individual properties*/
                _container.style.visibility = 'hidden';
                _container.style.height = '0px';
                _container.style.width = '0px';
            }else{
               _container.style.cssText = 'visibility:hidden; height:; width:;';
            }
          
            _container.removeAttribute("data-harness-id");

            if(_popoverAssociateElemStack != null) {
                var _asscociateElemRef = _popoverAssociateElemStack.pop();
                _asscociateElemRef = null;
                if(_popoverAssociateElemStack.length <= 0) {
                    _popoverAssociateElemStack = null;
                }
            }

            if(_visual.isMobile && _visual.isMobileFullScreen === "true"){
              $(".screen-layout-region-main-middle").css("overflow-y","auto");
              $(".screen-layout-region-main-middle").css("overflow-x","auto");
              $(".screen-layout-region-main-middle").css("overflow","auto");
            }
          
            // Call the OnClose callback with the specified closeResult.
            closeResult = isTransitionDone;
            invokeCallback(_callbacks.onClose, [ closeReason, closeResult, _bindings,_container]);
            callPopOverListeners("onClose");
          
            _state = 'inactive';

            _popOverCloseInitiated = false;
          if (pega.c && pega.c.actionSequencer)
                pega.u.d.resumeAjaxSequencer();

           /*BUG-244466:Removing name, validationtype, data-required attributes in popover*/
            $(_container).find("input").removeAttr("name").removeAttr("validationtype").removeAttr("data-required");
            $(_container).find("select").removeAttr("name").removeAttr("validationtype").removeAttr("data-required");
            $(_container).find("textarea").removeAttr("name").removeAttr("validationtype").removeAttr("data-required");
            $(_container).find("#RULE_KEY").removeAttr("node_name"); 
            $(_container).find("#CT").removeAttr("id");
            $(_container).find("[data-expr-id]").removeAttr("data-expr-id");
          
            if(_clickAwayProvider) {
              _clickAwayProvider.unregisterScrollHandlers();
            }
        };

        // Updates the popover result field with the specified value.
        this.setResult = function (result) {

            // If a DBP getResult is specified, invoke it to fetch the result.
            if (typeof result === 'undefined') {
                if (typeof _dbp.getResult === 'function') {
                    result = _dbp.getResult.call(_dbp);
                }
            }

            if (typeof result !== 'undefined') {
                _result = result;
                invokeCallback(_callbacks.onResultChange, [result, _bindings]);
            }
        };

        // This function creates a simplified popover within a popover scenario. The current implementation allows for only one popover instance per level.
        // The outermost level begins at 0. Every sub-popover gets an increased level.
        this.getChildPopOver = function (createIfNotExists) {
            if (typeof createIfNotExists == 'undefined') {
                createIfNotExists = true;
            }
            if (_childPopOver == NULL && createIfNotExists) {
                _childPopOver = new popOver(_level + 1);
            }

            return _childPopOver;
        };
        _state = 'ready';
    };
  
    // Add global listener for popover events
    // {
    //   onContentReady: function (),
    //   onClose: function ()
    // }
    var _popOverListeners = [];
    p.u.d.addPopOverListener = function (listener) {
       _popOverListeners.push(listener);
    };
    p.u.d.removePopOverListener = function (listener) {
       var index = _popOverListeners.indexOf(listener);
       if (index !== -1) {
           _popOverListeners.splice(index, 1);
       }
    };
    var callPopOverListeners = function (event) {
       for (var i = 0; i < _popOverListeners.length; i++) {
           var callback = _popOverListeners[i][event];
           if (typeof callback === 'function') {
             try {
               callback();
             } catch (error) {
               console.debug("Unable to call popover listener: " + error);
             }
           }
       }
    };
  
    var _popOver = new popOver(0);
    p.u.d.getPopOver = function (level) {
        ensurePopOverHost(level);
        initIframeShim4IE();
        var result = _popOver;
        if (typeof level === 'object' && level != NULL) {
            var associatedElementLevel = _getPopOverLevelForElement(level);
            level = associatedElementLevel + 1;
        }

        if (typeof level !== 'number') {
            return result;
        }

        while (level-- && result) {
            result = result.getChildPopOver();
        }

        return result;
    };

    p.u.d.getPopOverLevel = function (elem) {
     return _getPopOverLevelForElement(elem);
    };

    p.u.d.repositionAndShowPopover = function (e) {
      this.repositionPopover(e, {"setVisible": true});
    }
    
    p.u.d.repositionPopover = function (e, extraParams) {
     var target = pega.util.Event.getTarget(e),
     level = _getPopOverLevelForElement(target);
     if (level >= 0) {
        if (typeof extraParams == 'string') {
          extraParams = JSON.parse(extraParams);
        }
        this.getPopOver(level).reposit(extraParams);
     }
    };
  
    /* this api allows to display a section as an overlay by positioning it static and toggling the case visible */
    p.u.d.toggleFixedOverlay = function (sectionName, e) {
      if(e) {
        var elem = e.target;
        if(elem && elem.tagName==="I") elem=elem.parentElement;  // fix issue with IE where the i is the focus element 
        elem.classList.toggle('active');
      }
      /* Need to find the overlay container that's associated with the clicked icon, since microDC now allows us to have nested harnesses */
      var harnessElem = elem.closest('.harness-content-workarea-view');
      var headerElem = harnessElem.querySelector('.workarea-view-header');
      var fixedElem = harnessElem.querySelector('div[node_name="' + sectionName + '"]');
      if(!fixedElem) return;
      if(fixedElem.classList.contains('visible')) {
         fixedElem.classList.toggle('visible');
         fixedElem.style.width = '';
         setTimeout(function() { fixedElem.style.display = 'none' }, 400);
      } else {
         fixedElem.style.display = 'block';
         if(headerElem) {
           /* Need to calculate overlay position differently for IE11, since it ignores the CSS transform stacking context */
          fixedElem.style.top = (document.querySelector('.ie11') ? (headerElem.offsetHeight + harnessElem.offsetTop) : headerElem.offsetHeight) + 'px';
          if(headerElem.offsetWidth > 0 && headerElem.offsetWidth < fixedElem.offsetWidth) {
            fixedElem.style.width = headerElem.offsetWidth;
          }
         }
         fixedElem.classList.toggle('visible');
      }
    };
  
  /* This function is used by the Checkbox group template to set the other input in the same fieldset to false */
    p.u.d.toggleCheckGroup = function (e) {
      if(!e) return;
      var elem = e.target;
      var prop = elem.getAttribute("name");
      if(elem.checked === false) return;
      var fieldSet = elem.closest("fieldset");
      var parentNode = fieldSet?fieldSet:elem.closest("form"); // find the top parent fieldset
      if(!parentNode) return;
      var inputElems = parentNode.querySelectorAll("input[type='hidden']"); // locate all hidden input fields
      Array.prototype.forEach.call(inputElems, function(el, i){
        try {
        var tmpprop = el.getAttribute("name");
        if( tmpprop !== prop && pega.u.d.getProperty(tmpprop) === true) { // set the other input to false - only if the element that was clicked was set to checked
           pega.u.d.setProperty(tmpprop, false); 
        }
        var nextElem = el.nextElementSibling; // reset any error on this element that could have been added during validation
        if(nextElem && nextElem.classList.contains("ErrorShade")) {
          nextElem.classList.remove("ErrorShade");
          var errorDiv = document.getElementById( tmpprop + "Error");
          if(errorDiv) {
            errorDiv.parentNode.removeChild(errorDiv);
          }
          var tmppropName = pega.ui.property.toReference(tmpprop);
          tmppropName = "Error_" + tmppropName.substring(tmppropName.indexOf("."));
          tmpprop = "Error_" + tmpprop;
          errorDiv = document.querySelectorAll(".custom_errorlist_ul > li");
          Array.prototype.forEach.call(errorDiv, function(errorel, j){
            if(errorel.id === tmppropName || errorel.id === tmpprop) {
              var parEl = errorel.parentNode;
              parEl.removeChild(errorel);
              if(parEl.children.length === 0) {
               var mainElDiv = parEl.closest(".layout");
               if(mainElDiv) {
                   mainElDiv.parentNode.removeChild(mainElDiv);
                }
              }
            }
          });
        }
        }catch(ex) {}
      });
      
    };


})(pega);
//static-content-hash-trigger-GCC
(function () {

	if (!pega.ui) {
         		pega.u = p.namespace("pega.ui");
        	} 

	var _listeners = new Array();

	function _notify (stat) {
		for(var i=0; i < _listeners.length; i++) {
			_listeners[i]( {status:stat} );
		}
	}

    	function AJAXStatus() {

		this.register = function (cb) {
			for(var i=0; i<_listeners.length; i++){
				if(_listeners[i] == cb)
				return;
			}
			_listeners.push(cb);
		}

		this.cancel = function (cb) {
			for(var i=0; i<_listeners.length; i++){
				if(_listeners[i] == cb) {
					_listeners.splice(i,1);
				}
			}
		}

		this.start= function () {
			_notify("start");
		}

		this.complete= function() {
			_notify("complete");
		}

		this.isActive = function() {
			pega.u.d.isAjaxInProgress;
		},

		this.nullify = function() {
			for(var i=0; i < _listeners.length; i++) {
				_listeners[i] = null;				
			}

		}

    	}

    pega.u.d.AJAXStatus = new AJAXStatus();

})();
//static-content-hash-trigger-GCC
pega.namespace("pega.ui");
pega.ui.HarnessActions = new function() {
    var harCtxMgr = pega.ui.HarnessContextMgr;
    var performAction = function(safeUrl) {
        if (pega.u.d.ServerProxy.isHybridClient()) {
            // DCUtils will not be present in MicroDC based offline applications. So copied the logic. Not a good approach. 
            var parentWindow = pega.mobile.support.getPortalWindow();
            if (parentWindow && parentWindow.pega.ctx.isMDC) {
                safeUrl.put("pzPrimaryPageName", "pyWorkPage");
                safeUrl.put("action", "runFlow");
                safeUrl.put("api", "runFlow");
                var handler = {
                    online: pega.u.d.UIActionRouter.onlineHandler,
                    offline: pega.u.d.UIActionRouter.offlineHandler,
                    scope: that
                };
                pega.u.d.setBusyIndicator(document.body, true, true);
                pega.u.d.ServerProxy.doAction(safeUrl, null, handler, null);
                removeScreenLayoutMask(); //to hide the mask
            } else {
                safeUrl.put("pzPrimaryPageName", "pyWorkPage");
                safeUrl.put("action", "runFlow");
                safeUrl.put("api", "runFlow");
                pega.ui.DCUtil.runFlow(safeUrl);
            }
        } else if (pega.ctx.isMDC) {
            safeUrl.put("isURLReady", "true");
            pega.ui.MDCUtil.microDCRenderer(safeUrl, undefined, true);
        } else if (harCtxMgr.get("bIsDCSPA")) {
            safeUrl.put("isURLReady", "true");
            pega.u.d.UIActionRouter.singlePageRenderer(safeUrl);
        } else {
            //BUG-549645 : Document edit page is not loaded completely in PIMC
            if (pega.mobile && pega.mobile.isMultiWebViewOfflinePegaMobileClient && !(pega.offline)) {
                safeUrl.put("isRemoteCase", "true");
            }
            pega.u.d.convertToRunActivityAction(safeUrl);
            window.location = safeUrl.toURL();
        }
    };
    /*
      @public changeStage facilitate the changing of stages in a case
      @Handler
      @param $changeToNextStage$ whether to navigate to next stage or not
      @param $changeToStage$ identify the id of the stage to switch to if next is not true
      @return $auditNote$ note to use for audit trail
      */
    this.changeStage = function(changeToNextStage, changeToStage, auditNote, isTargetMDC) {
       pega.u.d.isHistoryReplaced=false;
        if (pega.desktop.infinity && pega.ctx.acName === "acsecondary") {
            pega.desktop.infinity.changeCaseStage(changeToNextStage, changeToStage, auditNote, isTargetMDC);
        } else {
            var workURL = new SafeURL("Work-.pxPerformChangeStage");
            if (changeToNextStage == null && changeToStage == null) return;
            var primaryPageName = harCtxMgr.get("primaryPageName");
            if (primaryPageName == null || primaryPageName == "") return;
            var harnessPurpose = pega.ctx.strHarnessPurpose;
            workURL.put("HarnessPurpose", harnessPurpose);
            workURL.put("pzPrimaryPageName", primaryPageName);
            if (changeToNextStage != null) workURL.put("ChangeToNextStage", changeToNextStage);
            if (changeToStage != null) workURL.put("ChangeToStage", changeToStage);
            if (auditNote != null) workURL.put("AuditNote", auditNote);
            if (isTargetMDC) {
                workURL.put("skipHistoryUpdation", "true");
            }
            performAction(workURL);
        }
    };
    /*
       @public handleMenuAction call the apis that are required to perform when the FA drop down is selected  or back button is clicked on the perform harness
       @Handler
       @param $String$actionType contains the action that is to be perfomed
       @param $String$prevTaskIndex contains the prevTaskIndex
       @return $void$
      */
    this.handleMenuAction = function(actionType, prevTaskIndex, event, taskIndex, actionName, insHandle, mdcTarget) {
       var menuActionArguments = arguments;
        var that=this;
        pega.util.Event.stopEvent(event);
       
        function handleMenuActionsCallback() {
          var actionURL = SafeURL_createFromURL(harCtxMgr.get('url'));
          actionURL.put("HarnessMode", harCtxMgr.get('strHarnessMode'));
          actionURL.put("FieldError", harCtxMgr.get('fieldErrorType'));
          actionURL.put("FormError", harCtxMgr.get('formErrorType'));
          actionURL.put("pyCustomError", harCtxMgr.get('pyCustomError'));
          actionURL.put("bExcludeLegacyJS", harCtxMgr.get('bExcludeLegacyJS'));
          switch (actionType) {
            case "ActionChange62":
                var bWarnBeforeChangingWindow = harCtxMgr.get('bWarnBeforeChangingWindow');
                if (typeof bWarnBeforeChangingWindow != undefined && bWarnBeforeChangingWindow == true && !
                    showDialogForWindowChange()) return;
                if ((actionName == null) || (taskIndex == null)) return;
                actionURL.put("NewTaskStatus", actionName);
                actionURL.put("PrevTaskIndex", prevTaskIndex);
                actionURL.put("TaskIndex", taskIndex);
                pega.u.d.processActionDefault(actionURL, event);
                break;
            case "DisplayAction":
              var harnessName = pega.ctx.strHarnessPurpose;
                if (mdcTarget && mdcTarget.startsWith("ac") && harnessName ==="Review") {
                    if (pega.desktop.infinity && pega.desktop.infinity.handleCaseAction) {
                        var arrayOfArguments = Array.prototype.slice.call(menuActionArguments);
                        pega.desktop.infinity.handleCaseAction(arrayOfArguments);
                    } else {
                        openAssignment(insHandle, "", "", {
                            "NewTaskStatus": actionName,
                            "TaskIndex": taskIndex
                        }, "false", false, {
                            "pyReloadAlways": "true",
                            "target": mdcTarget
                        });
                    }
                } else {
                    var displayURL1 = SafeURL_createFromURL(harCtxMgr.get('url'));
                    var displayURL = new SafeURL("Assign-.pyProcessAssignmentFromReview");
                    displayURL.put("pxReqURI", displayURL1.get("pxReqURI"));
                    if ((actionName == null) || (taskIndex == null) || (insHandle == null)) return;
                    displayURL.put("InsHandle", insHandle);
                    displayURL.put("NewTaskStatus", actionName);
                    displayURL.put("TaskIndex", taskIndex);
                    var url = displayURL.toURL();
                    performAction(displayURL);
                }
                break;
            case "DisplayActionNewTab":
                var displayURL = new SafeURL("Assign-.pyProcessAssignmentFromReview");
                if ((actionName == null) || (taskIndex == null) || (insHandle == null)) return;
                displayURL.put("InsHandle", insHandle);
                displayURL.put("NewTaskStatus", actionName);
                displayURL.put("TaskIndex", taskIndex);
                var url = displayURL.toURL();
                openWorkByURL(url, event);
                break;
        }
       }
       if (pega.u.d.isFormDirty(true, null, null, null,handleMenuActionsCallback )) {
            return;
        }else{
          handleMenuActionsCallback();
        }
    };
    /*
       @public getNextWork get the next most urgent work object and display it in this same frame
       @Handler
       @param $String$userIdentifier the identifier of the current operator
       @return $void$
      */
    this.getNextWorkSameFrame = function(userIdentifier) {
        var workURL = new SafeURL("@baseclass.doUIAction");
        if (userIdentifier == null) userIdentifier = "";
        workURL.put("action", "getNextWork");
        workURL.put("UserIdentifier", userIdentifier);
        if(pega.ctx && pega.ctx.portalName){
          workURL.put("portalName", pega.ctx.portalName);
        }
        performAction(workURL);
    };
    /*
       @public addWorkFromActionsMenu add child work object from the actions menu 
       @Handler
       @param $String$workClass the class of the new work object
       @param $String$flowName the flow used to start the new work object
       @return $void$
      */
    this.addWorkFromActionsMenu = function(workClass, flowName,mdcTarget) {
        if (workClass == null) return;
        if (flowName == null) return;
       if (mdcTarget && typeof mdcTarget === "string" && pega.desktop.infinity) {
            if (mdcTarget.startsWith("ac")) {
                pega.desktop.infinity.addCaseWorkFromActionMenu(flowName, workClass, mdcTarget);
            }
        } else {
        var primaryPageName = harCtxMgr.get("primaryPageName");
        if (primaryPageName == null || primaryPageName == "") return;
            var workURL = SafeURL_createFromURL(harCtxMgr.get('url'));
            workURL.put("pyActivity", "Work-.NewCovered");
            workURL.put("pzPrimaryPageName", primaryPageName);
            workURL.put("InsClass", workClass);
            workURL.put("FlowType", flowName);
            performAction(workURL);
    }
    };
    /*
       @public addCoveredWork add child work object from the parent case manually 
       @Handler
       @return $void$
      */
    //BUG-232157 : Add this JS function.
    this.addCoveredWork = function() {
        var workURL = new SafeURL("Work-.AddCovered");
        var primaryPageName = harCtxMgr.get("primaryPageName");
        if (primaryPageName == null || primaryPageName == "") return;
        workURL.put("pzPrimaryPageName", primaryPageName);
        performAction(workURL);
    };
    /*
	   @public addWorkFromActionsMenuInNewTab add child work object from the actions menu 
	   @Handler
	   @param $String$workClass the class of the new work object
	   @param $String$flowName the flow used to start the new work object
	   @param $String$workHandle the ins handleof the workobject
  
	   @return $void$
	  */
    this.addWorkFromActionsMenuInNewTab = function(workClass, flowName, workHandle, event) {
        var workURL = new SafeURL("pzNewCovered");
        if (workClass == null) return;
        if (flowName == null) return;
        var primaryPageName = harCtxMgr.get("primaryPageName");
        if (primaryPageName == null || primaryPageName == "") return;
        //workURL.put("pzPrimaryPageName", "myCasesWorkPage");
        workURL.put("InsClass", workClass);
        workURL.put("FlowType", flowName);
        //workURL.put("WorkPageName", "myCasesWorkPage");
        workURL.put("WorkHandle", workHandle);
        var url = workURL.toURL();
        openWorkByURL(url, event);
    };
    /*
       @public addFlowFromActionsMenu add new flow to a  work object from the actions menu 
       @Handler
       @param $String$flowType the name of the flow 
       @param $String$flowClass the class of the flow
       @return $void$
      */
    this.addFlowFromActionsMenu = function(flowType, flowClass, mdcTarget) {
      function addFlowFromActionsMenuCallback(){
      var harnessName = pega.ctx.strHarnessPurpose;
        if (mdcTarget && typeof mdcTarget === "string" && pega.desktop.infinity && harnessName==="Review") {
            if (mdcTarget.startsWith("ac")) {
                pega.desktop.infinity.addCaseFlowFromActionMenu(flowType, flowClass, mdcTarget);
            }
        } else {
            if (flowType == null) return;
            if (flowClass == null) return;
            var primaryPageName = harCtxMgr.get("primaryPageName");
            if (primaryPageName == null || primaryPageName == "") return;
            var workURL = new SafeURL_createFromEncryptedURL(harCtxMgr.get('url'));
            workURL.put("pyActivity", "Work-.StartNewFlow");
            var harnessPurpose = pega.ctx.strHarnessPurpose;
            //BUG-554993 : harness purpose is not set properly for pzHarnessShell for offline multi web-view
            if ((!harnessPurpose) && (pega.mobile && pega.mobile.isMultiWebViewOfflinePegaMobileClient) && (pega
                    .offline)) {
                harnessPurpose = "pyCaseWorker";
            }
            workURL.put("HarnessPurpose", harnessPurpose);
            workURL.put("pzPrimaryPageName", primaryPageName);
            workURL.put("flowType", flowType);
            workURL.put("flowClass", flowClass);
            workURL.put("pyManualSupportingFlow", "true");
            performAction(workURL);
        }
        }
       if (pega.u.d.isFormDirty(true, null, null, null,addFlowFromActionsMenuCallback)) {
            return;
        } else {
          addFlowFromActionsMenuCallback();
        }
    };
    /*
       @public addFlowFromActionsMenuInNewTab add new flow to a  work object from the actions menu 
       @Handler
       @param $String$flowType the name of the flow 
       @param $String$flowClass the class of the flow
       @return $void$
      */
    this.addFlowFromActionsMenuInNewTab = function(flowType, flowClass, workHandle, event) {
        var workURL = new SafeURL("Work-.pzStartNewFlowWrapper");
        if (flowType == null) return;
        if (flowClass == null) return;
        var primaryPageName = harCtxMgr.get("primaryPageName");
        if (primaryPageName == null || primaryPageName == "") return;
        //workURL.put("pzPrimaryPageName", "myCasesWorkPage");
        workURL.put("flowType", flowType);
        workURL.put("flowClass", flowClass);
        workURL.put("WorkHandle", workHandle);
        //workURL.put("WorkPageName", "myCasesWorkPage");
        workURL.put("pyManualSupportingFlow", "true");
        if (pega.u.d.ServerProxy.isHybridClient()) {
            workURL.put("action", "runFlow");
            workURL.put("api", "runFlow");
            pega.ui.DCUtil.runFlow(workURL);
        } else {
            var url = workURL.toURL();
            openWorkByURL(url, event);
        }
    };
    this.doAttachmentSingleClick = function(nRow, strClass, strInsName, strInsKey, strCategoryProp, strCategoryValue,
        pxLinkedRefTo, useInlineView, inputValues, pxLinkedClassTo) {
        pega.c.AttachUtil.checkTokenAndDownloadAttachment(pega.util.Event.getEvent(), strInsKey, pxLinkedRefTo,
            "Work-", "GetAttachmentReference", "DisplayAttachFile", useInlineView, inputValues,
            pxLinkedClassTo);
    };
    this.doAttachmentShare = function(strInsName, strInsKey, pxLinkedRefTo, strClass) {
        pega.c.AttachUtil.shareAttachment(pega.util.Event.getEvent(), strInsName, strInsKey, pxLinkedRefTo,
            strClass, "DisplayAttachFile");
    };
    this.exportDocumentToPdf = function(DocContentPage, insHandle) {
        var elemId = "ATTACHMENT-DATA";
        var dtWin = pega.desktop.support.getDesktopWindow();
        var topWindow = dtWin ? dtWin : window;
        var elem = topWindow.document.getElementById(elemId);
        if (null == elem) {
            elem = document.getElementById(elemId);
        }
        if (null == elem) {
            var tempFrame = document.createElement('iframe');
            tempFrame.id = elemId;
            tempFrame.style.display = 'none';
            document.body.appendChild(tempFrame);
            elem = tempFrame;
        }
        var url = new SafeURL("PegaSocial-Document" + "." + "pzConvertDocToPDF");
        url.put("DocContentPage", DocContentPage);
        url.put("insHandle", insHandle);
        pega.u.d.convertToRunActivityAction(url);
        url = url.toURL();
        elem.src = url;
    };
    this.replaceBrokenThumbnail = function(thumbnailImage) {
        thumbnailImage.src = "webwb/pyImageThumbnail.svg";
    };
    var launchMiniProfile = function(event, oSafeURL) {
        var miniProfilePostActionCallback = function() {
            /* launch user mini profile*/
            var options = {
                flowAction: "pyOperatorMiniProfile",
                displayMode: pega.api.ui.constants.OVERLAY,
                event: event,
                flowActionClass: "Embed-OperatorID-MiniProfile",
                closeOnClickAway: true,
                skinFormat: 'Standard no padding',
                contextPage: "D_pzOperatorMiniProfile"
            };
            pega.api.ui.actions.launchLocalAction(options);
        };
        pega.u.d.asyncRequest('GET', oSafeURL, {
            success: miniProfilePostActionCallback
        }, null);
        event.preventDefault();
        event.stopPropagation();
    };
    this.openUserMiniProfile = function(event, userId) {
        /* Build D_pzOperatorMiniProfile data page to launch mini profile local action*/
        var oSafeURL = new SafeURL("@baseclass.pzSetUserIdentifier");
        oSafeURL.put("UserIdentifier", userId);
        pega.u.d.convertToRunActivityAction(oSafeURL);
        launchMiniProfile(event, oSafeURL);
    };
    this.openUserMiniProfileWithURL = function(event, miniProfileURL) {
        var oSafeURL = SafeURL_createFromURL(miniProfileURL);
        launchMiniProfile(event, oSafeURL);
    };
    this.openUserMiniProfileOnEnter = function(event, miniProfileURL) {
        event.preventDefault();
        if (event.keyCode == 13) {
            pega.ui.HarnessActions.openUserMiniProfileWithURL(event, miniProfileURL);
        }
        event.stopPropagation();
    };
};
//static-content-hash-trigger-GCC
//<!-- HTML -->
//<script>

pega.ui.Invoke = function () {

}

pega.ui.Invoke.prototype = {
	runActivity: function(oArgs, postValues, reloadElement) { // ETCHASKETCH Run Activity API
		var sActivityName = oArgs[0];
		var sActivityParams = oArgs[1];
		var sUsingPage = oArgs[2];
		var event = oArgs[3];
		var whiteListID = oArgs[4];
		var contextPage = oArgs[5];
    var callBackObj = oArgs[6];
    var actURLStr = oArgs[7];
    var isSecuredURL = actURLStr?true:false;

    var strUrlSF = SafeURL_createFromURL(pega.ctx.url);
    var postData = new SafeURL();
    if(postValues === true) {
      reloadElement = reloadElement || document.body;
      pega.u.d.processOnBeforeSubmit(false,reloadElement);
      postData = pega.u.d.getQueryString(reloadElement, false, true);
    }

    if(isSecuredURL) {
      postData.put(actURLStr, "");
      contextPage = oArgs[8];
    } else if (sActivityName && sActivityName != '') {
      strUrlSF.put("pzActivity", sActivityName);
      strUrlSF.put("pyActivity", "pzRunActionWrapper");
      strUrlSF.put("pySubAction", "runAct");
    }
			var target = null;
			var grid = null;
			if (event) {
				target = pega.util.Event.getTarget(event);
				/*BUG-222393: In case of IE,if target.parentNode is null,search for element with name,"target.name" in the DOM and reassign it to target if it exists*/
              	if(typeof(target) != "undefined" && target != null && !target.parentNode && pega.util.Event.isIE){         
                  var targetsList = pega.ctx.dom.getElementsByName(target.name);
                  if(targetsList){
                    target = targetsList[0];
                  }                 
                }
				if (typeof Grids != "undefined" && Grids)
 				     grid = Grids.getActiveGrid(event);
			}
			
			// true if event is in a non-grid repeat layout
			var isInNonGridRepeat = false;
			if (target)
				isInNonGridRepeat = !grid && pega.u.d.isInRepeat(target);

			/*BUG-219267: Getting the correct page from the grid whenever action is invoked from a menu with load behavior 'while screen renders'.*/
            if (sUsingPage == "tempNavStepPg" && grid) {
				sUsingPage = grid.getEntryHandle();
            }

			if (isInNonGridRepeat) {
				//Check whether event came from a repeat non-grid layout
				var row = pega.u.d.getRepeatRow(target, true);
				if(row && row.getAttribute("hPref")) {
					var contextPage = pega.u.property.toReference(row.getAttribute("hPref"));
					strUrlSF.put("pzPrimaryPageName", contextPage);
				} else if(row && row.getAttribute("id")){
					var contextPage = pega.u.property.toReference(row.getAttribute("id"));
					strUrlSF.put("pzPrimaryPageName", contextPage);
				} else 
					strUrlSF.put("pzPrimaryPageName", sUsingPage);
					
				/* BUG-226084: START - setting proper context page in case using page not available */
				if(strUrlSF.get("pzPrimaryPageName") == false && contextPage && contextPage != "") {
					strUrlSF.put("pzPrimaryPageName", contextPage );
				}
				/* BUG-226084: END */
			} else if (sUsingPage != '') {
				strUrlSF.put("pzPrimaryPageName", sUsingPage);
			} else {
			    if(contextPage && contextPage!= ""){
				strUrlSF.put("pzPrimaryPageName", contextPage );
			    } else {
				if(event!=null && typeof(Grids)!="undefined" && Grids){
			     	if (grid != null) { //Check if source is in Sequoia
					    if(!grid.isLastEventFromRow){ //Check whether event was from row or action top/bottom
						strUrlSF.put("pzPrimaryPageName", grid.gridReferencePage);
				   	    } else{
			                 		var rtRow = grid.getRightRow();
						if (rtRow && pega.util.Dom.isAncestor(rtRow, target)) {
			                        		var rowPage = rtRow.getAttribute("hPref") ? rtRow.getAttribute("hPref") : rtRow.id;
			                        		var contextPage = pega.u.property.toReference(rowPage);
					      		strUrlSF.put("pzPrimaryPageName", contextPage );
			                 		} else {
							strUrlSF.put("pzPrimaryPageName", grid.gridReferencePage);
						}
				    	    }
				}
			    }
			  }
			}
            if(!(whiteListID==null || whiteListID=="")){
            	strUrlSF.put("pzActionID",whiteListID);	
            }
            //strUrlSF.put("pzActivityParams", escape(sActivityParams));
            var paramKeys = "";
            if(sActivityParams){
                var oParams = sActivityParams.split("&");
                for (var i = 0; i < oParams.length; i++) {
                    if (oParams[i] != '') {
                        var oParamNMPair = oParams[i].split("=");
                        postData.put(oParamNMPair[0], oParamNMPair[1]);
                        paramKeys += oParamNMPair[0] + "&";
                    }
                }
                paramKeys = paramKeys.substring(0, paramKeys.lastIndexOf("&"));
                if (paramKeys != "" || paramKeys != null) {
                    postData.put("pzActivityParams", paramKeys);
                }
          //postData.put("pzActivityParams", sActivityParams);
            }
            pega.u.d.setBusyIndicator();
          
          	// Create a callback which calls the callback functions which were passed in
            // but also hides the busy indicator when complete.
          	var callBackScope = (callBackObj && callBackObj.scope) || this;
            var callBack = {
                success : function(response) {
                    try {
                      if(callBackObj && typeof callBackObj.success =='function'){
                          callBackObj.success.call(callBackScope, response);
                      }
                  	} catch(e) {}
                    pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
                },
                failure : function(response) {
                    try {
                    	if(callBackObj && typeof callBackObj.failure =='function'){
                        	callBackObj.failure.call(callBackScope, response);
                    	}
                    } catch(e){}
                    pega.u.d.gBusyInd && pega.u.d.gBusyInd.hide();
                }   
            };
          	pega.u.d.asyncRequest('POST', strUrlSF, callBack, postData);
	},
	
	runDataTransform: function(oArgs) { // ETCHASKETCH Run Data Transform API
		var sDataTransformName = oArgs[0];
		var sDataTransformParams = oArgs[1];
		var sUsingPage = oArgs[2];
		var event = oArgs[3];
		var contextPage = oArgs[4];

        // Run data transform in offline
       
      if (sDataTransformName && sDataTransformName != ''){
        var strUrl = SafeURL_createFromURL(pega.ctx.url);
        strUrl.put("pzDataTransform", sDataTransformName);
        strUrl.put("pyActivity", "pzRunActionWrapper");
        strUrl.put("pySubAction", "runDT");

        var target = null;
        var grid = null;
        if (event) {
          target = pega.util.Event.getTarget(event);
          /*BUG-222393: In case of IE,if target.parentNode is null,search for element with name,"target.name" in the DOM and reassign it to target if it exists*/
          if(!target.parentNode && pega.util.Event.isIE){         
            var targetsList = pega.ctx.dom.getElementsByName(target.name);
            if(targetsList){
              target = targetsList[0];
            }                 
          }
          if (typeof Grids != "undefined" && Grids)
            grid = Grids.getActiveGrid(event);
        }

        // true iff event is in a non-grid repeat layout
        var isInNonGridRepeat = false;
        if (target)
          isInNonGridRepeat = !grid && pega.u.d.isInRepeat(target);

        /*BUG-219267: Getting the correct page from the grid whenever action is invoked from a menu with load behavior 'while screen renders'.*/
        if (sUsingPage == "tempNavStepPg" && grid) {
          sUsingPage = grid.getEntryHandle();
        }

        if (isInNonGridRepeat) {
          //Check whether event came from a repeat non-grid layout
          var row = pega.u.d.getRepeatRow(target, true);
          if(row && row.getAttribute("hPref")) {
            var contextPage = pega.u.property.toReference(row.getAttribute("hPref"));
            strUrl.put("pzPrimaryPageName", contextPage);
          } else {
            strUrl.put("pzPrimaryPageName", sUsingPage);
          }
          /* BUG-226092: START - setting proper context page in case using page not available */
          if(strUrl.get("pzPrimaryPageName") == false && contextPage && contextPage != "") {
            strUrl.put("pzPrimaryPageName", contextPage );
          }
          /* BUG-226092: END */
        } else if (sUsingPage != '') {
          strUrl.put("pzPrimaryPageName", sUsingPage);
        } else {
          if(event!=null && typeof(Grids)!="undefined" && Grids){
            if(contextPage && contextPage!= ""){
              strUrl.put("pzPrimaryPageName", contextPage );
            } else {
              if (grid != null) { //Check if source is in Sequoia
                if(!grid.isLastEventFromRow){ //Check whether event was from row or action top/bottom
                  strUrl.put("pzPrimaryPageName", grid.gridReferencePage);
                } else {	
                  var rtRow = grid.getRightRow();
                  if (rtRow && pega.util.Dom.isAncestor(rtRow, target)) {
                    var rowPage = rtRow.getAttribute("hPref") ? rtRow.getAttribute("hPref") : rtRow.id;
                    var contextPage = pega.u.property.toReference(rowPage);
                    strUrl.put("pzPrimaryPageName", contextPage );
                  } else {
                    strUrl.put("pzPrimaryPageName", grid.gridReferencePage);
                  }
                }
              }
            }
          }
        }

        //strUrl.put("pzDataTransformParams", escape(sDataTransformParams));
        var paramKeys = "";
        var postURL = new SafeURL();
        if(sDataTransformParams){
            var oParams = sDataTransformParams.split("&");
            for (var i = 0; i < oParams.length; i++) {
                if (oParams[i] != '') {
                    var oParamNMPair = oParams[i].split("=");
                    postURL.put(oParamNMPair[0], oParamNMPair[1]);
                    paramKeys += oParamNMPair[0] + "&";
                }
            }
            paramKeys = paramKeys.substring(0, paramKeys.lastIndexOf("&"));
            if (paramKeys != "" || paramKeys != null) {
                postURL.put("pzDataTransformParams", paramKeys);
            }
          //postURL.put("pzDataTransformParams", sDataTransformParams);
        }
        var oscoHandler = {
          scope: this,
          online : function(){
            pega.u.d.setBusyIndicator();
            var onSuccessOrFailure = function (response) {
              //Hide Busy indicator
              try {
                pega.u.d.gBusyInd.hide();
              } catch(e) {}
            };
            var callBack = {
              success : onSuccessOrFailure,
              failure : onSuccessOrFailure
            };
            pega.u.d.asyncRequest('POST', strUrl, callBack, postURL);
          },
          offline : function(args){
			var contextPage = args.get("pzPrimaryPageName"),
            className = pega.ui.ClientCache.find(contextPage).get("pxObjClass").getValue();
            pega.offline.runDataTransform(sDataTransformName, className, contextPage);
          }
        };
        pega.u.d.ServerProxy.doAction(strUrl, postURL, oscoHandler);
      }
	}
};

pega.u = pega.namespace("pega.ui");

pega.u.invoke =  new pega.ui.Invoke();
//static-content-hash-trigger-GCC
/* Performance Code Start */
TouchPerformance = {
    showLogs: false,
    state: {
        control: "",
        touchstart: "",
        touchend: "",
        clickhandlerstart: "",
        dblclickhandlerstart: "",
        touchend_touchstart: "",
        clickstart_touchend: ""
    },
    collection: [],
    now: function () {
        return (new Date()).getTime();
    },
    recordTouchStart: function (control) {
        this.state.control = control;
        this.state.touchstart = this.now();

        if (this.showLogs) {
            console.log("[P]Control:" + this.state.control);
            console.log("[P]Touch-Start:" + this.state.touchstart);
        }
    },
    recordTouchEnd: function () {
        this.state.touchend = this.now();
        this.state.touchend_touchstart = (this.state.touchend - this.state.touchstart);

        if (this.showLogs) {
            console.log("[P]Touch-End:" + this.state.touchend);
            console.log("[P]Touch-Start to Touch-End:" + this.state.touchend_touchstart);
        }
    },
    recordClickStart: function () {
        this.state.clickhandlerstart = this.now();
        this.state.clickstart_touchend = (this.state.clickhandlerstart - this.state.touchend);

        this.collection.push(this.state);

        if (this.showLogs) {
            console.log("[P]Click:" + this.state.clickhandlerstart);
            console.log("[P]Touch-End to Click:" + this.state.clickstart_touchend);
        }

        this.resetState();
    },
    resetState: function () {
        this.state = {
            control: "",
            touchstart: "",
            touchend: "",
            clickhandlerstart: "",
            dblclickhandlerstart: "",
            touchend_touchstart: "",
            clickstart_touchend: ""
        };
    },
    resetCollection: function () {
        this.collection = [];
    }
};
/* Performance Code End */

(function (p) {
    var $e = p.util.Event;
    var $b = document;

    if (p.cl.isTouchAble()) {

        var TAPHOLD_MINTIME = 500;
        var TAPHOLD_THRESHOLD = 5;
        var DOUBLETAP_MAXTIME = 300;
        var WAIT_FOR_DOUBLE_TAP = 300;
        var DOUBLETAP_THRESHOLD = 20;
        var TAP_THRESHOLD = 10;
        var previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
        var startX = 0;
        var startY = 0;
        var startTarget = null;
        var tap_timer = 0;
        var taphold_timer = 0;
        var didtapandhold = false;
        var gridObj = null;
        var templateGridObj = null;
        var disableTextSelect = true;
        /*Tap Event lifecycle - new, open(in touchstart), close (in touchend) and cancel (touchcancel and touchmove)*/
        var TOUCH_STATUS = "new";

        var iosDuplicateAlertFix = {
            lastEvent: null
        };

        var getDistance = function (touch1, x, y) {
            var x = x - touch1.pageX;
            var y = y - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
        };

        var sqr = function (x) { return x * x };
        var dist2 = function (v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) };
        var distToSegmentSquared = function (p, v, w) {
            var l2 = dist2(v, w);
            if (l2 == 0) return dist2(p, v);
            var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            if (t < 0) return dist2(p, v);
            if (t > 1) return dist2(p, w);
            return dist2(p, {
                x: v.x + t * (w.x - v.x),
                y: v.y + t * (w.y - v.y)
            });
        };
        var distToSegment = function (p, v, w) { return Math.sqrt(distToSegmentSquared(p, v, w)); };

        var executeEvent = function (event, eventType) {
            // For performance calculation
            TouchPerformance.recordTouchEnd();

            var target = $e.getTarget(event),
                currDist = 20,
                eventPoint = { x: event.changedTouches[0].pageX, y: event.changedTouches[0].pageY };

            if (eventType == 'tap' && (!target.getAttribute("data-click") || target.getAttribute("data-click") == "")) {
                // added onclick attributed children selector also to handle scenarios like grid-pagination links, which has onclick attribute
                var clickableChildren = $(target).find('[data-click*="[["], [onclick!=""]');
                clickableChildren.each(function (i, elem) {
                    if (elem.tagName && elem.tagName.toLowerCase() == "input" && elem.type && (elem.type.toLowerCase() == "checkbox" || elem.type.toLowerCase() == "radio")) return;
                    if ((elem.getAttribute('data-click') == '' || elem.getAttribute('data-click') == null) && (elem.getAttribute('onclick') == '' || elem.getAttribute('onclick') == null)) return;
                    var elemRect = elem.getBoundingClientRect(),
                        currentDistance = Math.min(distToSegment(eventPoint, { x: elemRect.left, y: elemRect.top }, { x: elemRect.left, y: elemRect.bottom }),
                            distToSegment(eventPoint, { x: elemRect.left, y: elemRect.top }, { x: elemRect.right, y: elemRect.top }),
                            distToSegment(eventPoint, { x: elemRect.left, y: elemRect.bottom }, { x: elemRect.right, y: elemRect.bottom }),
                            distToSegment(eventPoint, { x: elemRect.right, y: elemRect.top }, { x: elemRect.right, y: elemRect.bottom }));

                    if (currentDistance < currDist) {
                        currDist = currentDistance;
                        target = elem;
                    }
                });
            }

            // For text based inputs and button and link, we rely on native click but not on the synthetic click
            // 		- text based controls : TASK-425037 - to let the user able to click at a specific position of the text
            // 		- button & link : ':active' states are not happening to these elements if we rely on synthetic click
            // 		- select : BUG-269259 : in android select input elements do not show options for user triggered custom click events
            if (isTextBox(target) || isTextArea(target) || ((navigator.userAgent.indexOf('Android') > 0) && !isMenuItem(target) && (target.tagName == 'SELECT' || isButton(target) || isLink(target)))) {
                return;
            } else if ((navigator.userAgent.indexOf('Windows') > 0) && target.tagName == 'SELECT') { // BUG-271256
                return;
            }

            if (isCheckBox(target) || isRadio(target)) {
                if (target.tagName && target.tagName.toLowerCase() == "label" && target.getAttribute("for") != null && target.control) {
                    target = target.control;
                }

                // if checkbox or radiobutton is disabled, no need to trigger 'click'
                if (target.disabled) {
                    return;
                }
            }

            // Firing mouseover event to handle menu configured within a grid
            var moEvent = document.createEvent("MouseEvent");
            moEvent.initMouseEvent('mouseover', true, true, event.view, event.detail, event.changedTouches[0].screenX, event.changedTouches[0].screenY, event.changedTouches[0].clientX, event.changedTouches[0].clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);
            moEvent.isATriggeredEvent = true;
            target.dispatchEvent(moEvent);

            // BUG-539870 - Executing blur event after the mouseover event(earlier blur is firing before the mouseover event is fired). Corrected as per the event order
            if (document.activeElement && document.activeElement != target) {
                document.activeElement.blur();
            }
          
            var newEventType = '';
            switch (eventType) {
                case 'tap':
                    newEventType = 'click';
                    break;
                case 'doubletap':
                    newEventType = 'dblclick';
                    break;
                case 'taphold':
                    newEventType = 'contextmenu';
                    break;
            }

            /*
            if(target.tagName == 'SELECT' && newEventType == 'click' && (navigator.userAgent.indexOf('Android') > 0)){
          // Firing mousedown event, if target element is a dropdown and environment is android
          var mdEvent = document.createEvent("MouseEvent");
          mdEvent.initMouseEvent ('mousedown', true, true, event.view, event.detail, event.changedTouches[0].screenX, event.changedTouches[0].screenY, event.changedTouches[0].clientX, event.changedTouches[0].clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);
          target.dispatchEvent(mdEvent);
        }
        */

            // Firing click event
            var gestureEvent = document.createEvent("MouseEvent");
            gestureEvent.touches = event.touches;

            gestureEvent = document.createEvent("MouseEvent");
            gestureEvent.initMouseEvent(newEventType, true, true, event.view, event.detail, event.changedTouches[0].screenX, event.changedTouches[0].screenY, event.changedTouches[0].clientX, event.changedTouches[0].clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);

            gestureEvent.isSimulated = true;
            iosDuplicateAlertFix.lastEvent = gestureEvent;

            target.dispatchEvent(gestureEvent);

            // focus is needed by input based elements inorder to display the keyboard. Also as we are canceling the actual click, we need to set current target as current element
            $(target).focus();

            // * IMP * CANCELLING THE touchend EVENT BY SETTING THE event.returnValue to false
            event.preventDefault();
            event.stopPropagation();
        };

        var onTouchStart = function (event) {
            var isSingleTouch = false;
            didtapandhold = false;
            TOUCH_STATUS = "new";
            gridObj = templateGridObj = null;
            var gridDiv = null;
            var templateGridDiv = null;
            var checkControl = false;
            var target = $e.getTarget(event);
            var control = event.target.attributes['data-ctl'] ? event.target.attributes['data-ctl'].value : "";

            if (isCheckBox(event.target)) {
                control = "Checkbox";
            }

            if (isRadio(event.target)) {
                control = "Radio";
            }

            if (!control) {
                control = event.target.attributes['type'] ? event.target.attributes['type'].value : "";
            }

            // for performance calculation
            TouchPerformance.recordTouchStart(control);

            if (event.changedTouches && event.changedTouches.length === 1 && event.targetTouches && event.targetTouches.length === 1 && event.touches && event.touches.length === 1) {
                isSingleTouch = true;
            }

            if (isSingleTouch) {
                TOUCH_STATUS = "open";
                /* BUG-106572 */
                if (disableTextSelect) {
                    pega.util.Dom.addClass($b.body, "disableSelection");
                    disableTextSelect = false;
                }

                if (typeof (Grids) != 'undefined') {
                    gridObj = Grids.getActiveGrid(event);
                }

                if (gridObj) {
                    gridDiv = gridObj.gridDiv;
                } else if (typeof (pega.ui.tGrid) != 'undefined') {
                    templateGridObj = pega.ui.tGrid.getGridBySource(null, null, event);
                    if (templateGridObj) {
                        templateGridDiv = $('table[uniqueid=' + templateGridObj.uniqueId + ']').closest('#PEGA_GRID_SKIIN').parent();
                        gridDiv = templateGridDiv[0];
                    }
                }


                startX = event.touches[0].pageX;
                startY = event.touches[0].pageY;
                startTarget = target;

                if ((gridDiv && gridDiv.getAttribute("data-rightclick") != null) || target.getAttribute("data-rightclick") != null) {

                    taphold_timer = setTimeout(function () {
                        didtapandhold = true;
                        previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                        executeEvent(event, "taphold");
                    }, TAPHOLD_MINTIME);
                }

                if ((gridDiv && gridDiv.getAttribute("data-dblclick") != null) || target.getAttribute("data-dblclick") != null || isTextBox(target) || isMenuItem(target)) {
                    if (previousEvent.name == "tap") {
                        event.preventDefault();
                        if (gridDiv) {
                            var container, gridRow;
                            if (gridObj) {
                                if (pega.util.Dom.isAncestor(gridObj.leftBodyUL, target))
                                    container = gridObj.leftBodyUL;
                                else if (pega.util.Dom.isAncestor(gridObj.rightBodyTbl, target))
                                    container = gridObj.rightBodyTbl;
                                gridObj.setActiveRow(event, container);
                                gridRow = gridObj.getRightRow();
                            } else if (templateGridObj) {
                                var layoutInfo = pega.ui.DataRepeaterUtils.getClosestRepeatLayoutInfo(event, true);
                                if (layoutInfo && layoutInfo.rowNode)
                                    gridRow = layoutInfo.rowNode;
                            }
                            if (previousEvent.target != gridRow) {
                                previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };

                            }
                        } else {
                            if (previousEvent.target != target) {
                                previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                            }
                        }
                    }
                }

                if (previousEvent.name == "") {
                    previousEvent.startX = event.touches[0].pageX;
                    previousEvent.startY = event.touches[0].pageY;
                }
                gridObj = templateGridObj = null;

            }
            else {
                reset();
                return false;
            }
        };

        var onTouchMove = function (event) {
            var isSingleTouch = false;
            var target = $e.getTarget(event);

            /* BUG-111651 && BUG-111282 - DTSprint18 - singp1 Start*/

            var checkControl = isCheckBox(target);
            if (checkControl) {
                //SE-35209 : Cancelling the touch event when the target is check box during scroll
                TOUCH_STATUS = "cancel";
                return;
            }

            checkControl = isRadio(target);
            if (checkControl) {
                //SE-35209 : Cancelling the touch event when the target is radio button during scroll
                TOUCH_STATUS = "cancel";
                return;
            }

            /* BUG-111651 && BUG-111282 - DTSprint18 - singp1 End*/

            if (event.changedTouches.length == 1 && event.targetTouches.length == 1 && event.touches.length == 1) {
                isSingleTouch = true;

            }

            if (isSingleTouch && TOUCH_STATUS == "open" && startTarget == target) {

                var distanceMoved = getDistance(event.touches[0], startX, startY);

                if (distanceMoved > TAP_THRESHOLD) {
                    TOUCH_STATUS = "cancel";
                    previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };

                }

                if (distanceMoved > TAPHOLD_THRESHOLD) {
                    if (taphold_timer) {
                        clearTimeout(taphold_timer);
                        taphold_timer = 0;
                    }
                }


            } else {
                TOUCH_STATUS = "cancel";
                previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                startTarget = null;
            }


        };

        var onTouchEnd = function (event) {
            var isSingleTouch = false;
            var gridDiv = null;
            var templateGridDiv = null;
            var target = $e.getTarget(event);
            var isdoubletapConfigured = false;
            var istapConfigured = false;
            var preventDefault = true;
            gridObj = templateGridObj = null;

            var thisEventTimeStamp = (new Date()).getTime();
            var perfObj;


            if (event.changedTouches && event.changedTouches.length === 1 && event.targetTouches && event.targetTouches.length === 0 && event.touches && event.touches.length === 0) {
                isSingleTouch = true;
            }

            if (taphold_timer) {
                clearTimeout(taphold_timer);
                taphold_timer = 0;
            }
            if (didtapandhold) {
                TOUCH_STATUS = "close";
                previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                startTarget = null;
                didtapandhold = false;

                event.preventDefault();
                return false;
            }

            if (isSingleTouch && TOUCH_STATUS == "open" && startTarget == target) {

                if (typeof (Grids) != 'undefined') {
                    gridObj = Grids.getActiveGrid(event);
                }

                if (gridObj) {
                    gridDiv = gridObj.gridDiv;
                } else if (typeof (pega.ui.tGrid) != 'undefined') {
                    templateGridObj = pega.ui.tGrid.getGridBySource(null, null, event);
                    if (templateGridObj) {
                        templateGridDiv = $('table[uniqueid=' + templateGridObj.uniqueId + ']').closest('#PEGA_GRID_SKIIN').parent();
                        gridDiv = templateGridDiv[0];
                    }
                }


                if ((gridDiv && gridDiv.getAttribute("data-dblclick") != null) || target.getAttribute("data-dblclick") != null || isTextBox(target) || isMenuItem(target)) {
                    isdoubletapConfigured = true;
                    if (previousEvent.name == "") {
                        previousEvent.name = "tap";
                        previousEvent.timeStamp = thisEventTimeStamp;
                        if (gridDiv) {
                            if (target.getAttribute("data-click") != null) {
                                previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                            } else {
                                var container, gridRow;
                                if (gridObj) {
                                    if (pega.util.Dom.isAncestor(gridObj.leftBodyUL, target))
                                        container = gridObj.leftBodyUL;
                                    else if (pega.util.Dom.isAncestor(gridObj.rightBodyTbl, target))
                                        container = gridObj.rightBodyTbl;
                                    /* BUG-119578 - ML-DTSprint1 - singp1 Start*/
                                    gridObj.setActiveRow(event, container);
                                    /* BUG-119578 - ML-DTSprint1 - singp1 End*/
                                    gridRow = gridObj.getRightRow();
                                } else if (templateGridObj) {
                                    var layoutInfo = pega.ui.DataRepeaterUtils.getClosestRepeatLayoutInfo(event, true);
                                    if (layoutInfo && layoutInfo.rowNode)
                                        gridRow = layoutInfo.rowNode;
                                }
                                previousEvent.target = gridRow;
                            }
                        } else {
                            setTimeout(function () {
                                previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                            }, DOUBLETAP_MAXTIME);

                            previousEvent.target = startTarget;
                        }
                        TOUCH_STATUS = "close";
                        executeEvent(event, "tap");

                        // TASK-422587 if clicked on grid-action-top content instead of the actual grid-content, reset previousEvent..
                        var $actionTop = $(gridDiv).find('.gridActionTop');//, 
                        var $actionBottom = $(gridDiv).find('.gridActionBottom');
                        if (($actionTop[0] && $.contains($actionTop[0], event.target)) || ($actionBottom[0] && $.contains($actionBottom[0], event.target))) {
                            previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                        }
                    } else if (previousEvent.name == "tap" && (thisEventTimeStamp - previousEvent.timeStamp) < DOUBLETAP_MAXTIME && getDistance(event.changedTouches[0], previousEvent.startX, previousEvent.startY) < DOUBLETAP_THRESHOLD) {
                        previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                        TOUCH_STATUS = "close";
                        /*BUG-214416 : Tapping very quickly on links and textinputs should not lead to double taps*/
                        if (!isTextBox(target) && !isMenuItem(target))
                            executeEvent(event, "doubletap");
                    } else {
                        previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                        TOUCH_STATUS = "close";
                    }
                }

                if (!isdoubletapConfigured && ((gridDiv && gridDiv.getAttribute("data-click") != null) || target.getAttribute("data-click") != null) && (thisEventTimeStamp - previousEvent.timeStamp > DOUBLETAP_MAXTIME)) {
                    istapConfigured = true;
                    if (previousEvent.name == "") {
                        previousEvent.name = "tap";
                        previousEvent.timeStamp = thisEventTimeStamp;
                        previousEvent.target = startTarget;
                        TOUCH_STATUS = "close";
                        previousEvent.name = "";
                        // Not resetting timestamps to detect double click on same control and to prevent it
                        //previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                        executeEvent(event, "tap");
                    } else {
                        previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                        TOUCH_STATUS = "close";
                    }
                }
                else {
                    setTimeout(function () {
                        previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                    }, DOUBLETAP_MAXTIME);
                }

                // To prevent second click on same control if it less than threshold (Eg: double click on attach content opens attachment overlay 2 times in HC)
                if ((!isdoubletapConfigured && !istapConfigured) && (thisEventTimeStamp - previousEvent.timeStamp) < DOUBLETAP_MAXTIME) {
                    previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                    TOUCH_STATUS = "close";
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
                if (!isdoubletapConfigured && !istapConfigured) {
                    previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
                    TOUCH_STATUS = "close";
                    executeEvent(event, "tap");
                }

                startTarget = null;
                gridObj = null;
            } else {
                startTarget = null;
                TOUCH_STATUS = "cancel";
                previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
            }
            /*
          Now using "event.returnValue = false" statement in the executeEvent method to cancel the 'touchend' event
            // TASK-425037 : if target element is textinput or textarea, we need the actual click event so that the cursor position will be at the exact touch position 
            if (isTextBox(target) || isTextArea(target) || ((navigator.userAgent.indexOf('Android') > 0) && (isButton(target) || isLink(target)))){
                    preventDefault = false;
            }
      	
        if(preventDefault){
          // We need to prevent the default behaviour in order to cancel the default browser 300ms mouse events 
          event.preventDefault();
          return false;
        }*/
        };

        var isButton = function (target) {
            if ((target.tagName && target.tagName.toLowerCase() == "button") || ($(target).parents('button').length > 0)) {
                return true;
            }

            return false;
        }

        var isLink = function (target) {
            if ((target.tagName && target.tagName.toLowerCase() == "a") || ($(target).parents('a').length > 0)) {
                return true;
            }

            return false;
        }

        var isCheckBox = function (target) {
            if (target.tagName && target.tagName.toLowerCase() == "label" && target.getAttribute("for") != null && target.control) {
                target = target.control;
            }
            if (target.tagName && target.tagName.toLowerCase() == "input" && target.type && target.type.toLowerCase() == "checkbox") {
                return true;
            }
            return false;
        };

        var isMenuItem = function (target) {
            /*BUG-214416 - target can be span or anchor .so check with class */
            if (target.getAttribute("class") && target.getAttribute("class").match("^menu-item")) {
                return true;
            }
            return false;
        };

        var isTextBox = function (target) {
            var type = target.type && target.type.toLowerCase(); // BUG-267821 bajaj for number
            /*HFix-49881 : adding date, time, datetime-local*/
            if (target.tagName && target.tagName.toLowerCase() == "input" && target.type && (type == "text" || type == "number" || type == "email" || type == "phone" || type == "url" || type == "date" || type == "datetime-local" || type == "time" || type == "tel" || type == "password" )) {
                return true;
            }
            return false;
        };

        var isTextArea = function (target) {

            if (target.tagName && target.tagName.toLowerCase() == "textarea") {
                return true;
            }
            return false;
        };

        var isRadio = function (target) {

            if (target.tagName && target.tagName.toLowerCase() == "label" && target.getAttribute("for") != null && target.control) {
                target = target.control;
            }
            if (target.tagName && target.tagName.toLowerCase() == "input" && target.type && target.type.toLowerCase() == "radio") {
                return true;
            }
            return false;
        };

        var onTouchCancel = function (event) {
            if (taphold_timer) {
                clearTimeout(taphold_timer);
                taphold_timer = 0;
            }
            if (tap_timer) {
                clearTimeout(tap_timer);
                tap_timer = 0;
            }
            TOUCH_STATUS = "cancel";
            previousEvent = { "name": "", "timeStamp": 0, "startX": 0.0, "startY": 0.0, "target": "" };
            startTarget = null;

        };

        var onResize = function (event) {
            if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") {
                if (!pega.u.d.bModalDialogOpen) {
                    // Workaround for chrome bug => https://bugs.chromium.org/p/chromium/issues/detail?id=270018&can=4&colspec=ID%20Pri%20M%20Iteration%20ReleaseBlock%20Cr%20Status%20Owner%20Summary%20OS%20Modified
                    // BUG-364381: Move the input field to center of the visible area
                    document.activeElement.scrollIntoView({ block: "center" });
                }
            }
        };


        var reset = function () {

        };

        $e.addListener($b, "touchstart", onTouchStart);
        $e.addListener($b, "touchmove", onTouchMove);
        $e.addListener($b, "touchend", onTouchEnd);
        $e.addListener($b, "touchcancel", onTouchCancel);

        $e.addListener($b, "click", function (event) {
            if (iosDuplicateAlertFix.lastEvent !== null && event.isSimulated !== true && iosDuplicateAlertFix.lastEvent.target === event.target) {
                event.preventDefault();
                event.stopImmediatePropagation();

                return false;
            }
        });

        // Fix for BUG-289116, when keyboard is shown on Andriod - window is resized,
        // so we may react to this event and scroll to active input.
        if (/Android/.test(navigator.appVersion)) {
            $e.addListener(window, "resize", onResize);
        }
    }
})(pega);
//static-content-hash-trigger-GCC
/*
* Raises different types of swipe/ fling events based on user geatures on the device. 
*/

$(function() {
	if (!pega.cl.isTouchAble() || (typeof pega.cl.disableSwipeGestures != "undefined" && pega.cl.disableSwipeGestures === true)) {
		return;
	}

	/* SWIPE EVENT FUNCTIONALITY */
	(function(element, callback, progressCallback, cancelCallback) {
		var touchsurface = element,
			swipedir,
			startX,
			startY,
			threshold = 50, //required min distance traveled to be considered swipe
			restraint = 100, // maximum distance allowed at the same time in perpendicular direction
			flingAllowedTime = 120, // maximum time allowed to travel that distance
			swipeAllowedTime = 3000, // maximum time allowed to travel that distance
			elapsedTime,
			startTime,
			handleswipe = callback || function(swipedir) {},
			handleProgressCallback = progressCallback || function(progData) {},
			handleCancelCallback = cancelCallback || function() {},
			minDirectionActivationthreshold = 10,
			isSwipeInProgress = false,
			isTouchEnable = isTouchEnabledDevice(),
			isWindows = isWindowsDevice(),
			touchStart = /*isWindows?'MSGestureStart':*/'touchstart',
			touchMove = /*isWindows?'MSGestureChange':*/'touchmove',
			touchEnd = /*isWindows?'MSGestureEnd':*/'touchend',
      touchCancel = 'touchcancel';    

		var eventTarget = null;


		//US-248213 - patep2
		function isWindowsDevice() {
			//device is touchable true and useragent Windows
			return (isTouchEnable && navigator.userAgent.includes('Windows'));
		}

		//US-248213 - patep2
		function isTouchEnabledDevice() {
			var isTouchEnabled = false;
			if (window.PointerEvent && ('maxTouchPoints' in navigator)) {
				// if Pointer Events are supported, just check maxTouchPoints
				if (navigator.maxTouchPoints > 0) {
					isTouchEnabled = true;
				}
			} else {
				// no Pointer Events...
				if (window.matchMedia && window.matchMedia("(any-pointer:coarse)").matches) {
					// check for any-pointer:coarse which mostly means touchscreen
					isTouchEnabled = true;
				} else if (window.TouchEvent || ('ontouchstart' in window)) {
					// last resort - check for exposed touch events API / event handler
					isTouchEnabled = true;
				}
			}
			return isTouchEnabled;
		}

		var isHScrollable = function(elArr) {
			var returnVal = false;

			for (var i in elArr) {
				if (elArr[i].scrollWidth > elArr[i].clientWidth && window.getComputedStyle(elArr[i]).overflowX !== "hidden") {
					returnVal = !returnVal;
				}
			}

			return returnVal;
		};

		var isVScrollable = function(elArr) {
			var returnVal = false;

			for (var i in elArr) {
				if (elArr[i].scrollHeight > elArr[i].clientHeight && window.getComputedStyle(elArr[i]).overflowY === "hidden") {
					returnVal = !returnVal;
				}
			}

			return returnVal;
		};

		var isScrollable = function(el) {
			return isHScrollable(el) || isVScrollable(el);
		}

		var isValidSwipe = function(el, swipedir) {
			var elArray = $(el).parents().toArray();
			elArray.unshift(el);

			if (swipedir === "left" || swipedir === "right") {
				if (isHScrollable(elArray)) {
					return false;
				}
			} else if (swipedir === "up" || swipedir === "down") {
				if (isVScrollable(elArray)) {
					return false;
				}
			}

			return true;
		}

		var isGesturesBlocked = function(el) {
			if ($.trim($(el).attr('data-nogestures')) === 'true') {
				return true;
			}

			var elArray = $(el).parents('[data-nogestures=true]');
			if (elArray.length > 0) {
				return true;
			}

			return false;
		}

		touchsurface.addEventListener(touchStart, function(e) {
			var touchobj = e.changedTouches[0];
			swipedir = '';
			startX = touchobj.pageX;
			startY = touchobj.pageY;
			startTime = new Date().getTime(); // record time when finger first makes contact with surface

			eventTarget = touchobj.target;
		}, false);

		touchsurface.addEventListener(touchMove, function(e) {
			var touchobj = e.changedTouches[0];
			var distX = touchobj.pageX - startX; // get horizontal dist traveled by finger while in contact with surface
			var distY = touchobj.pageY - startY; // get vertical dist traveled by finger while in contact with surface
			var type = "";

			if (Math.abs(distY) >= minDirectionActivationthreshold && Math.abs(distX) <= restraint) {
				type = 'vertical';
			} else if (Math.abs(distX) >= minDirectionActivationthreshold && Math.abs(distY) <= restraint) {
				type = 'horizontal';
			} else {
				return;
			}

			isSwipeInProgress = true;

			handleProgressCallback({
				type: type,
				distanceX: distX,
				distanceY: distY
			}, e, eventTarget);
		}, false);

		//To perform action on swipe/fling/cancel 
    var touchEndAction = function(e) {
			// touch move did not happened, no need to process swipe calculations
			if (!isSwipeInProgress) {
				return;
			}

			// resetting to false and continue processing swipe calculations..
			isSwipeInProgress = false;
      var validSwipedir = false;
			var touchobj = e.changedTouches[0];
			var distX = touchobj.pageX - startX; // get horizontal dist traveled by finger while in contact with surface
			var distY = touchobj.pageY - startY; // get vertical dist traveled by finger while in contact with surface
			elapsedTime = new Date().getTime() - startTime; // get time elapsed

			var swipeType = '';
			if (elapsedTime > flingAllowedTime && elapsedTime <= swipeAllowedTime) { // first condition for swipe met
				swipeType = 'swipe';
				if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint) { // 2nd condition for horizontal swipe met
					swipedir = (distX < 0) ? 'left' : 'right' // if dist traveled is negative, it indicates left swipe
				}
				else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint) { // 2nd condition for vertical swipe met
					swipedir = (distY < 0) ? 'up' : 'down' // if dist traveled is negative, it indicates up swipe
				}
			} else if (elapsedTime <= flingAllowedTime) {
				swipeType = 'fling';
				if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint) { // 2nd condition for horizontal swipe met
					swipedir = (distX < 0) ? 'left' : 'right' // if dist traveled is negative, it indicates left swipe
				}
				else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint) { // 2nd condition for vertical swipe met
					swipedir = (distY < 0) ? 'up' : 'down' // if dist traveled is negative, it indicates up swipe
				}
			}
      //below logic can be generalized if there is need to enhance swipe feature to vertical
			//if(swipedir !=='' && eventTarget!= null && !isGesturesBlocked(eventTarget) && isValidSwipe(eventTarget, swipedir)){
      validSwipedir = (swipedir !== '' && swipedir!=='up' && swipedir!=='down');
			if (validSwipedir && eventTarget != null && !isGesturesBlocked(eventTarget)) {
				handleswipe(swipeType, swipedir, e, eventTarget);
			} else {
				handleCancelCallback(e, eventTarget);
			}

			eventTarget = null; // @yellk | setting to null, to avoid memory leak
		};
    
    touchsurface.addEventListener(touchCancel, touchEndAction, false);

		touchsurface.addEventListener(touchEnd, touchEndAction, false);
	})(document, function(swipeType, swipeDir, event, target) {
		//console.log("swipeType:"+swipeType+" direction:"+swipeDir);

		if (target) {
			var swipeEvent = document.createEvent("MouseEvent");
			swipeEvent.initMouseEvent(swipeType + "" + swipeDir, true, true, event.view, event.detail, event.changedTouches[0].screenX, event.changedTouches[0].screenY, event.changedTouches[0].clientX, event.changedTouches[0].clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);

			// TODO make this control level 
			// TODO somehow, this should process only one handler
			target.dispatchEvent(swipeEvent);
		}
	}, function(progressData, event, target) {
		// console.log("progress event:",progressData," : ",event);

		if (target) {
			var swipeProgressEvent = new CustomEvent('swipeinprogress', {
				bubbles: true,
				detail: progressData
			});
			target.dispatchEvent(swipeProgressEvent);
		}
	}, function(event, target) {
		// console.log("swipe cancel event:", event);

		if (target) {
			var swipeCancelEvent = new CustomEvent('swipecancel', {
				bubbles: true
			});
			target.dispatchEvent(swipeCancelEvent);
		}
	});
});
//static-content-hash-trigger-GCC
pega.namespace("pega.tools");

pega.tools.EvalDomUtils_globals = {
    loadedExternalFiles: "",
    objDocFragDOM: null,
    gInlineScripts: "",
    gInlineDOMId: "",
    scriptCntr: 0,
    objDocFragElemDOM: null,
    thisDomObj: null,
    bFoundHTMLTag: false,
    skipExecuteCallBack:false,
    initializeVariables: function() {
        this.gInlineScripts = "";
        this.gInlineDOMId = null;
        this.scriptCntr = 0;
		    this.objDocFragDOM = null;
        this.skipExecuteCallBack = false;
		    //this.objDocFragElemDOM = null;
    },
    cleanup: function() {
        /* Called in window context */
        pega.tools.EvalDomUtils_globals.objDocFragElemDOM = null;
    	pega.tools.EvalDomUtils_globals.objDocFragDOM = null;
    	pega.tools.EvalDomUtils_globals.orgDomObj = null;
    },
    scriptLoaded: function() {
        /*Counter is decremented after loading each file*/
        this.scriptCntr--;

        if (this.scriptCntr <= 0) {
            /*This means all the JS files are loaded. Process inline scripts*/
            if (this.thisDomObj != null && this.gInlineScripts.length > 0 && this.gInlineDOMId != "")
                this.thisDomObj.addFileToHeader(this.gInlineScripts, this.gInlineDOMId, null);
            /* clean up, cox memory leak*/
          	this.gInlineScripts = "";
          	this.gInlineDOMId = null;
            /*Call callbackFunction after executing inline scripts*/
            if (this.callbackFunction && !this.skipExecuteCallBack) {/*BUG-432709- The callBack should be executed only when theloading of external scripts is also done or if there are no external scripts*/
                this.skipExecuteCallBack = false;
                this.callbackFunction(this.orgDomObj);
                /*Update clientEndTime first and wait to see if scriptLoaded gets called again within the next 1 sec. If so update clientEndtime with that value and wait for 1 more second*/
                if (pega.c && pega.c.actionSequencer && !pega.u.d.gIsScriptsLoading && !pega.u.d.isAjaxInProgress()) {
                    pega.c.actionSequencer.resume();
                }
            }
            /* flag load complete to test tool and perf mon */
            if (pega.ui.statetracking) pega.ui.statetracking.setScriptLoadingDone();
        }
    },
    callbackFunction: null,
    orgDomObj: null
};

/*
@constructor- DOM Script Loader
@return $void$
*/

pega.tools.EvalDOMScripts = function() {}
pega.tools.EvalDOMScripts.prototype = {
    /*IE6 Flag */
    _IE6: false,

    /*Function call to load innerHTML to a DOM object
     * objDOMId : the target dom element to reload
     * sInnerHTML : the source HTML string to be consumed by objDOMId
     * overrideAction : overrides default action of setting sInerHTML as innerHTML of objDOMId;
     * a collection of key:value pairs setting atleast following keys -
     * 1. domElement : the descendant element of objDOMId on which current domAction has to be performed
     * 2. domAction : the dom action to be performed on the domElement other than the default action of setting innerHTML
     *              possible String values -
     *                            1. remove : removes domElement from the DOM; sInnerHTML still has to be atleast an empty String
     *                            2. replace : replaces domElement by the firstChild of the sInnerHTML
     *                            3. insert : inserts firstChild of the sInnerHTML before domElement
     *                            4. append : appends firstChild of the sInnerHTML as child of domElement
     */
    loadHTMLElement: function(objDOMId, sInnerHTML, callbackFunction, overrideAction) {
        var globalsRef = pega.tools.EvalDomUtils_globals;
        this.setIE6Flag();
        if (objDOMId == null || typeof(objDOMId) == "undefined" || sInnerHTML == null) return;
        if (typeof sInnerHTML != "object") {

            var sInnerHTML = sInnerHTML;
            //PMFBug-9332 changes: encoding the grave accent character.
            // BUG-132046: Added semi colon after &#96
            if (pega.util.Event.isIE) {
                sInnerHTML = sInnerHTML.replace(/`/g, "&#96;");
            }

            //PMFBug-9332 changes end.
            globalsRef.bFoundHTMLTag = false;
            globalsRef.callbackFunction = callbackFunction;
            globalsRef.orgDomObj = objDOMId;
            if (sInnerHTML.indexOf("<HTML") != -1 || sInnerHTML.indexOf("<html") != -1)
                globalsRef.bFoundHTMLTag = true;
            if (globalsRef.objDocFragDOM != null) {
                /*fine*/

            } else {
                globalsRef.objDocFragDOM = document.createDocumentFragment();

            }
            if (!globalsRef.objDocFragElemDOM) {
                globalsRef.objDocFragElemDOM = globalsRef.objDocFragDOM.appendChild(document.createElement("dummytag", ""));
            }
            try {
                if (overrideAction) {
                    var domAction = overrideAction.domAction;
                    var domElement = overrideAction.domElement;

                    if (domElement && domAction) {
                        /* extract the first child from incoming response in sInnerHTML and assign it to sInnerHTML back */
                        var srcElt = null;
                        var tempDiv = document.createElement("div");
                        /* check if sInnerHTML needs to be enclosed in <table> tag
                         * without this logic, objDocFragElemDOM.innerHTML does not retain <tr/> tags in FF.
                         * Such enclosing <table/> tags are required even for IE to get the row.
                         * Then retain only first row
                         */
                        if ((domAction != "append" && domElement.tagName == "TR") ||
                            (domAction == "append" && domElement.tagName == "TBODY")) {
                            /* response has tr object */
                            var innerHTMLStr = pega.tools.SUtils.trim(sInnerHTML);
                            if (innerHTMLStr.indexOf("<tr") == 0 || innerHTMLStr.indexOf("<TR") == 0) {
                                sInnerHTML = "<table>" + sInnerHTML + "</table>";
                            }
                            tempDiv.innerHTML = "&nbsp;" + sInnerHTML;
                            var srcTbl = pega.util.Dom.getFirstChild(tempDiv);
                            if (srcTbl && srcTbl.rows && srcTbl.rows.length > 0) {
                                /* retain only first row */
                                var srcRow = srcTbl.rows[0];
                                var trgTbl = document.createElement("table");
                                trgTbl.insertRow(0);
                                var trgRow = trgTbl.rows[0];
                                trgRow.parentNode.replaceChild(srcRow, trgRow);
                                tempDiv.innerHTML = "";
                                tempDiv.appendChild(trgTbl); /* tempDiv has a single row table as its only child  */
                            } else {
                                /* the case may be delete of tr thus no tr found in response text */
                                tempDiv.innerHTML = "";
                            }
                        } /*In case of LI. This is for the left part of the grid*/
                        else if ((domAction == "append" && domElement.tagName == "UL") || domElement.tagName == "LI") {
                            tempDiv.innerHTML = "&nbsp;" + sInnerHTML;
                            var srcLi = pega.util.Dom.getFirstChild(tempDiv);
                            if (!srcLi) {
                                /* the case may be delete of tr thus no tr found in response text */
                                tempDiv.innerHTML = "";
                            }
                        } else if (sInnerHTML) { /* response is not expected to have any tr object */
                            if (domElement.tagName.toUpperCase() === "TBODY") { /* if domAction is replace and domElement is tbody (for Progressive Load ) */
                                sInnerHTML = "<table>" + sInnerHTML + "</table>";
                            }
                            tempDiv.innerHTML = "&nbsp;" + sInnerHTML;
                            /*BUG-361326 -To Append Multiple row at a time*/
                            if(!overrideAction.bMultiple){
                            srcElt = pega.util.Dom.getFirstChild(tempDiv);
                            srcElt.parentNode.removeChild(srcElt); /* delink it from tempDiv before nullifying tempDiv's innerHTML */
                            tempDiv.innerHTML = "";
                            tempDiv.appendChild(srcElt);}
                        }
                        sInnerHTML = tempDiv.innerHTML; /* sinnerHTML now has first child from the response text */
                    }
                }
                globalsRef.objDocFragElemDOM.innerHTML = "&nbsp;" + sInnerHTML;
            } catch (err) {
                // BUG-258056: Replace is happening twice in FF; hack to supress error alert
                // BUG-258255: Uncommenting this as the issue is no more reproducible
                this.displayErrorMsg(err);
            }
        } else {
            globalsRef.bFoundHTMLTag = false;
            globalsRef.callbackFunction = callbackFunction;
            globalsRef.orgDomObj = objDOMId;

            if (globalsRef.objDocFragElemDOM)
                globalsRef.TempObjDocFragElemDOM = globalsRef.objDocFragElemDOM
            globalsRef.objDocFragElemDOM = sInnerHTML;


        }
        var strSelectUniqueID = "";
        if (typeof(objDOMId.getAttribute("uniqueID")) != "undefined" && objDOMId.getAttribute("uniqueID") != null)
            strSelectUniqueID = objDOMId.getAttribute("uniqueID");
        else {
            strSelectUniqueID = pega.util.Dom.generateId();
            objDOMId.setAttribute("uniqueID", strSelectUniqueID);
        }
        globalsRef.initializeVariables();
        globalsRef.thisDomObj = this;
        this.processInlineScripts(objDOMId, globalsRef.objDocFragElemDOM, strSelectUniqueID, overrideAction);
    },
    displayErrorMsg: function(err, htmlFound) {
        var txt = "There was an error when loading the content given.\n\n";
        if (pega.tools.EvalDomUtils_globals.bFoundHTMLTag) txt += "Found HTML Tag in the given content which is not valid.\n\n";
        txt += "IE Error description: " + err.description + "\n";
        alert(txt);
    },
    setIE6Flag: function() {
        if (pega.util.Event.isIE) {
            if (pega.util.Event.isIE == 6)
                this._IE6 = true;
            else
                this._IE6 = false;
        }
    },
    /*Function to evaluate innerJS/CSS scripts
     * objDOMIdToLoad : the target dom element to reload
     * objDOMId : the source dom element whose innerHTML has to be consumed by objDOMIdToLoad
     * objDOMIduniqueID : the uniqueId attribute of a section div as generated using pega.util.Dom.generateId()
     * overrideAction : overrides default action of setting objDOMId.innerHTML to objDOMIdToLoad.innerHTML;
     * set to boolean true if just want to process scripts in objDOMId without changing objDOMIdToLoad, or
     * set to a collection of key:value pairs setting atleast following keys -
     * 1. domElement : the descendant element of objDOMIdToLoad on which current domAction has to be performed
     * 2. domAction : the dom action to be performed on the domElement other than the default action of setting innerHTML
     *              possible String values -
     *                            1. remove : removes domElement from the DOM; objDOMId still has to be atleast an empty html element
     *                            2. replace : replaces domElement by the firstChild of the objDOMId
     *                            3. insert : inserts firstChild of the objDOMId before domElement
     *                            4. append : appends firstChild of the objDOMId as child of domElement
     */

    processInlineScripts: function(objDOMIdToLoad, objDOMId, objDOMIduniqueID, overrideAction) {
    
        var execScript = "";
        var xCnt;
        var bFoundScriptOrFile = false;
        var filesArray = new Array();
        pega.tools.EvalDomUtils_globals.scriptCntr = 0;
        var bRemoveScripts = false;
        if (pega.env.ua.gecko && overrideAction && (overrideAction.domAction == "append" || overrideAction.domAction == "replace" || overrideAction.domAction == "insert")) {
            bRemoveScripts = true;
        }
        var childsToBeRem = new Array();
        for (xCnt = 0; xCnt < 3; xCnt++) {
            var children = null;
            if (xCnt == 0)
                children = objDOMId.getElementsByTagName("LINK");
            else if (xCnt == 1)
                children = pega.util.Dom.getElementsById("loadscripts", objDOMId, "SPAN");
            else
                children = objDOMId.getElementsByTagName("SCRIPT");
            var child, childTagName;
            var index;
            var childrenLength = children ? children.length : 0;
            for (index = 0; index < childrenLength; ++index) {
                child = children[index];
                childTagName = child.tagName;
                if (childTagName && ("SCRIPT" == childTagName || "LINK" == childTagName || "SPAN" == childTagName)) {
                    var childsrc = "";
                    if ("SCRIPT" == childTagName)
                        childsrc = child.getAttribute("src");
                    else if ("LINK" == childTagName)
                        childsrc = child.getAttribute("href");
                    else if ("SPAN" == childTagName)
                        childsrc = child.getAttribute("scriptsrc");
                    if (childsrc != null && typeof(childsrc) != "undefined" && childsrc != "") {
						/*US-81389 : all script are loaded initially no need to process inline scripts*/
						if(pega.offline && "SCRIPT" == childTagName){
							continue;
						}
                        var isDuplicate = this.isDuplicateUrl(childsrc, filesArray);
                        /* To avoid duplicate script files to be added to filesArray. This can happen when a single html property (like listview) is present twice in the response.*/
                        if (isDuplicate) {
                            continue;
                        }
                        /* Code change ends*/
                        /*Increment script counter when it is a JS file. Used to execute inline scripts*/
                        if ("SCRIPT" == childTagName) {
                            /*Increment the counter*/
                            pega.tools.EvalDomUtils_globals.scriptCntr++;
                        }
                        if ("LINK" == childTagName && this.checkScriptsInTag(childsrc, "head", "css")) {
                            continue;
                        }
                        filesArray.push(new Array(child, null, objDOMIdToLoad));
                        bFoundScriptOrFile = true;
                    } else {
                        if ("LINK" != childTagName && "SPAN" != childTagName && (childTagName == "SCRIPT" && (child.getAttribute("EVENT") == null || child.getAttribute("EVENT") == ""))) {
                            var childInnerHTML = child.innerHTML;
                            /* support for harness */
                            if (childInnerHTML.indexOf("document.write") == -1) {
                                bFoundScriptOrFile = true;
                                execScript += childInnerHTML;
                                if (bRemoveScripts) {
                                    childsToBeRem.push(child);
                                }
                            }
                        }
                    }
                }
            }
        }
      
        /* BUG-429365: Removing external scripts from the response markup,
         * which will be anyways added to the head. 
         */
        for (var i = 0; i < filesArray.length; i++) {
          var extScript = filesArray[i][0];
          extScript.parentNode.removeChild(extScript);
        }
        if (bRemoveScripts) {
            for (var i = 0; i < childsToBeRem.length; i++) {
                var ch = childsToBeRem[i];
                ch.parentNode.removeChild(ch);
            }
        }
        var globalsRef = pega.tools.EvalDomUtils_globals;
        try {
            var str = "&nbsp;";
            //PMFBug-9332 changes : encoding the accent grave character.
            var strDom = "";
            var html = objDOMId.innerHTML;
            if ((html).match("^" + str) == str) {
                strDom = (html).substring(str.length);
            } else {
                strDom = html;
            }
            if (pega.util.Event.isIE) {
                strDom = strDom.replace(/`/g, "&#96;");
            }
            //PMFBug-9332 changes end.
            if (overrideAction) { /* default action has been overridden */
                var domElement = overrideAction.domElement;
                if (domElement) {
                    /* any action can be taken only for a descendant of a section;
                     * domElement is required; else only script in objDOMId will be processed
                     */
                    var domAction = overrideAction.domAction;
                    if (domAction) {
                        var parentElt = domElement.parentNode;
                        if (!parentElt) {
                            // BUG-145830
                            objDOMIdToLoad.className = objDOMIdToLoad.className;
                          	/* BUG-289422: setting pega.u.d.gIsScriptsLoading to false as it not allowing further events to process */
                          	pega.u.d.gIsScriptsLoading = false;
                            return; /* every domAction depends on valid parent node */
                        }
                        var srcElt = null;
                        var tempDiv = document.createElement("div");
                        tempDiv.innerHTML = "&nbsp;" + strDom;
                        srcElt = pega.util.Dom.getFirstChild(tempDiv);

                        /* check if strDom was enclosed in <table> tag by loadHTMLElement */
                        if ((domAction != "append" && domElement.tagName == "TR") ||
                            (domAction == "append" && domElement.tagName == "TBODY")) {
                            /* tr is the required child */
                            if (srcElt && srcElt.rows && srcElt.rows.length > 0) {
                                srcElt = srcElt.rows[0];
                            }
                        }

                        /* For Progressive Load */
                        if (domAction === "replace" && domElement.tagName.toUpperCase() == "TBODY") {
                            srcElt = pega.util.Dom.getFirstChild(srcElt);
                        }
                        globalsRef.orgDomObj = srcElt;
                      	/*BUG-273820: in firefox srcElt is null if response contains only script tag*/
						if(pega.env.ua.gecko && !srcElt){
                          srcElt = document.createElement("dummytag", "");
                        }
                        switch (domAction) {
                            case "remove":
                                globalsRef.orgDomObj = null;
                                parentElt.removeChild(domElement);
                                break;

                            case "replace":
                                if (overrideAction.bTreegrid && srcElt.tagName == "LI") {
                                    var Domapi = pega.util.Dom;
                                    /*For progressive load action the dummy rows will be empty Lis. So, replace Li with new markup*/
                                    if (overrideAction.partialTrigger && overrideAction.partialTrigger == "progressiveLoad") {
                                        parentElt.replaceChild(srcElt, domElement);
                                    } else {
                                        /*In case of tree grid, replace the rowUniqueID with new one for the LI*/
                                        domElement.setAttribute("rowUniqueID", srcElt.getAttribute("rowUniqueID"));
                                        /* replacing the rowContent UL.*/
                                        domElement.replaceChild(Domapi.getFirstChild(srcElt), Domapi.getFirstChild(domElement));
                                        domElement.className = srcElt.className;
                                    }
                                    Domapi = null;
                                } else {
                                    parentElt.replaceChild(srcElt, domElement);
                                }
                                break;

                            case "insert":
                                parentElt.insertBefore(srcElt, domElement);
                                break;

                            case "append":
                            /*BUG-361326 -To Append Multiple row at a time*/
                            if(!overrideAction.bMultiple){   
                                domElement.appendChild(srcElt);}
                            else {
                              var wrapperNode=document.createElement("div");
                              domElement.appendChild(wrapperNode);
                              
                              if(!(tempDiv.firstChild.tagName == "DIV")){
                                tempDiv.firstChild.remove();
                              }
                              domElement.lastChild.outerHTML=tempDiv.innerHTML;
                              globalsRef.orgDomObj = tempDiv.innerHTML;
                              tempDiv.innerHTML = "";
                              //$(domElement).append(tempDiv.innerHTML);
                            }
                                
                        }
                    } else {
                        /* overrideAction and domElement are defined but domAction key is not set;
                         * perform default action on domElement */
                        domElement.innerHTML = strDom;
                    }
                } /* if domElement */
                else { /* domElement is empty; means only script processing is needed; callbackFunction need to be passed objDOMId */
                    globalsRef.orgDomObj = objDOMId;
                }
            } else { /* default action of setting innerHTML of objDOMIdToLoad*/
              
                /* BUG-483486 : START : Remove all validations on the elements before replacing so as to prevent them from happening on stale DOM */
                $(objDOMIdToLoad).find("[validationType]").each(function(index, elem) {elem.removeAttribute('validationType')});
                /* BUG-483486 : END */
                /*BUG-533348*/
                $(objDOMIdToLoad).find("[data-change]").each(function(index, elem) {
                  var datactrl = elem.getAttribute('data-ctl');
                  if(datactrl && datactrl =='["AutoCompleteAG"]'){
                    elem.removeAttribute('data-change');
                  }
                });/*BUG-533348*/
                objDOMIdToLoad.innerHTML = strDom;
                if (globalsRef.TempObjDocFragElemDOM) {
                    globalsRef.objDocFragElemDOM = globalsRef.TempObjDocFragElemDOM;
                    globalsRef.TempObjDocFragElemDOM = null;
                }



            }
        } catch (err) {
            // BUG-258056: Replace is happening twice in FF; hack to supress error alert
            // BUG-258255: Uncommenting this as the issue is no more reproducible
            this.displayErrorMsg(err);
        }
        var scriptEl = null;
        var noOfFiles = filesArray.length;

        var cssFilesCnt = 0;
      
        if (execScript.length > 0) {
           globalsRef.skipExecuteCallBack = true;/*BUG-432709- The callBack should be executed only when theloading of external scripts is also done or if there are no external scripts*/

           // flag load complete to test tool and perf mon on loading start
           if (pega.ui && pega.ui.statetracking) pega.ui.statetracking.setScriptLoadingBusy();
         }
        for (var i = 0; i < noOfFiles; i++) {
            scriptEl = filesArray[i];
            if (scriptEl[0].tagName && scriptEl[0].tagName == "LINK") {
                cssFilesCnt++;
            }
         
            this.addFileToHeader(scriptEl[0], scriptEl[1], scriptEl[2]);
        }

        if (execScript.length > 0) {
            globalsRef.gInlineScripts = execScript;
            globalsRef.gInlineDOMId = objDOMIduniqueID;
            if (globalsRef.scriptCntr == 0) {
                globalsRef.skipExecuteCallBack = false;/*BUG-432709- The callBack should be executed only when theloading of external scripts is also done or if there are no external scripts*/

                globalsRef.scriptLoaded();
            }
        } else if (!bFoundScriptOrFile || cssFilesCnt == noOfFiles) {
            /*trigger the callback function when there are only CSS files in the new HTML OR no scripts at all. (BUG-47042)*/
            if (globalsRef.callbackFunction) {
                globalsRef.callbackFunction(globalsRef.orgDomObj);
                //BUG-45341: Call resume of actionsequencer after scriptloading is over.
                if (pega && pega.c && pega.c.actionSequencer && pega.u && pega.u.d && !pega.u.d.gIsScriptsLoading && !pega.u.d.isAjaxInProgress())
                    pega.c.actionSequencer.resume();

            }
        }
        // BUG-145830
        objDOMIdToLoad.className = objDOMIdToLoad.className;

    },
    /*Function to add sourced js scripts and custom functions in inline js scripts*/
    addFileToHeader: function(theFile, objUniqueID, objDiv) {
        var jsChk = (typeof(theFile) != "string") ? theFile.getAttribute("src") : "";
        if (jsChk == null || typeof(jsChk) == "undefined" || jsChk == "")
            jsChk = (typeof(theFile) != "string") ? theFile.getAttribute("scriptsrc") : "";
        var cssChk = (typeof(theFile) != "string") ? theFile.getAttribute("href") : "";
        if (jsChk != null && typeof(jsChk) != "undefined" && jsChk != "") {
            var bExists = false;
            if (objDiv != null) {
                bExists = this.checkScriptInDiv(objDiv, jsChk, "js");
            }
            if (pega.env.ua.ie != 6) {
                if (theFile.parentNode != null) {
                    theFile.parentNode.removeChild(theFile);
                }
            }
            this.loadExternalFile(jsChk, "js", bExists);
        } else if (cssChk != null && typeof(cssChk) != "undefined" && cssChk != "") {
            var bExists = false;
            if (objDiv != null) {
                bExists = this.checkScriptInDiv(objDiv, cssChk, "css");
            }
            if (pega.env.ua.ie != 6) {
                if (theFile.parentNode != null) {
                    theFile.parentNode.removeChild(theFile);
                }
            }
            this.loadExternalFile(cssChk, "css", bExists);
        } else {
            var scriptRef = this.chkInlineJSExists(objUniqueID);
            if (scriptRef != null && pega.env.ua.IE) {
                scriptRef.text = theFile;
            } else {
                if (scriptRef != null)
                    scriptRef.parentNode.removeChild(scriptRef);
                var head = document.getElementsByTagName("head")[0];
                var script = document.createElement('script');
                script.type = 'text/javascript';
                script.text = theFile;
                script.id = "inline_" + objUniqueID;
                head.appendChild(script);
            }
        }
    },
    checkScriptInDiv: function(objDiv, file, filetype) {
        var scripts;
        if (filetype == "js") {
            if (!(scripts = objDiv.scripts))
                scripts = objDiv.getElementsByTagName('script');
        } else if (filetype == "css") {
            if (!(scripts = objDiv.links))
                scripts = objDiv.getElementsByTagName('link');
        }
        if (scripts != null) {
            if (scripts.length != null) {
                for (var i = 0; i < scripts.length; i++) {
                    var srcscript = "";
                    if (filetype == "js")
                        srcscript = unescape(scripts[i].src); /*Bug-22647 FF escapes script src when accessed using getElementByTagName('script')*/
                    else if (filetype == "css")
                        srcscript = scripts[i].href;
                    if (srcscript != null && (srcscript == file || srcscript.indexOf(file) != -1)) {
                        return true;
                    }
                }
            } else if ((scripts.src != null && (unescape(scripts.src) == file || unescape(scripts.src).indexOf(file) != -1)) || (scripts.href != null && (scripts.href == file || scripts.href.indexOf(file) != -1))) {
                return true;
            }
        }

    },
    chkInlineJSExists: function(objUniqueID) {
        var scripts = null;
        if (!(scripts = document.scripts))
            scripts = document.getElementsByTagName('script');
        if (scripts != null) {
            if (scripts.length != null) {
                for (var i = 0; i < scripts.length; i++) {
                    if (scripts[i].id == ("inline_" + objUniqueID))
                        return scripts[i];
                }
            }
        } else if (scripts.id == ("inline_" + objUniqueID)) {
            return scripts;
        }
        return null;
    },
    /*
    @private- Function to load JS/CSS
    @param $Object$file - The file to load
    @return $void$
    */
    loadExternalFile: function(file, filetype, bAdd) {
      	// flag outstanding work to test tool and perf mon - removed BUG-406017
		    //if (pega && pega.ui && pega.ui.statetracking) pega.ui.statetracking.setScriptLoadingBusy(file);

      	if (!bAdd) {
            if ((file != null && file == "") || this.isFileAlreadyLoaded(file, filetype)) {
                /*Call scriptLoaded() only for JS files*/
                if (filetype == "js") {
                    pega.tools.EvalDomUtils_globals.scriptLoaded();
                }
				        //if (pega && pega.ui && pega.ui.statetracking) pega.ui.statetracking.setScriptLoadingDone();
                return true;
            }
        }

        var fileref = "";
        if (filetype == "js") {
            fileref = document.createElement('script');
            fileref.setAttribute("type", "text/javascript");
            fileref.setAttribute("src", file);
        } else if (filetype == "css") {
            fileref = document.createElement("link");
            fileref.setAttribute("rel", "stylesheet");
            fileref.setAttribute("type", "text/css");
            fileref.setAttribute("href", file);
        }
        if (fileref !== "") {
            /* OSCO Go To HC */

            if (pega && pega.offline && filetype === "js") {
                /*---------- Parse JS when offline ----------------*/
                //This hardcoded string should be replaced with a proper PRPC type
                launchbox.PRPC.ClientStore.getItems("js", file, function(data) {
                    if (data && data[0]) {
                        head.removeChild(fileref); // remove old script and append new one
                        var scriptFromCache = document.createElement("script");
                        scriptFromCache.innerText = data[0].content;
                        eval(data[0].content);
                        //head.appendChild(scriptFromCache);// appending should take care of evaling script
                        pega.tools.EvalDomUtils_globals.scriptLoaded();                      	
                    } else {					 
                        pega.tools.EvalDomUtils_globals.scriptLoaded();
                      	head.removeChild(fileref);
                    }
                }, function(code, message) {
                  	pega.tools.EvalDomUtils_globals.scriptLoaded();                 
					head.removeChild(fileref);
                });

                /*--------------------------*/



            } else {
                var actualContext = pega.ctx;
                /*IE fires onreadystatechange for JS files. Firefox fires onload for JS files. IE fires both onreadystatechange and onload for CSS files and firefox fires nothing for css files*/
                fileref.onreadystatechange = function() {
                    var originalContext = pega.ctx;
                    pega.ctxmgr.setContext(actualContext); //set to the actual harness context
                    /*IE fires either complete or loaded. Call scriptLoaded only for JS files. "src" will be present for only JS files*/
                    if ((this.readyState == 'complete' || this.readyState == 'loaded') && this.getAttribute("src") && this.getAttribute("src") != null && this.loaded != true) {
                        /*Decrement the counter as JS file loading is completed*/
                        this.loaded = true;
                        pega.tools.EvalDomUtils_globals.scriptLoaded();
                    }
                    pega.ctxmgr.resetContext(originalContext);
					          //if (pega && pega.ui && pega.ui.statetracking) pega.ui.statetracking.setScriptLoadingDone();
                };
                fileref.onload = function() {
                    var originalContext = pega.ctx;
                    pega.ctxmgr.setContext(actualContext); //set to the actual harness context
                    /*As IE fires this event for css check for "src"*/
                    if (this.getAttribute("src") && this.getAttribute("src") != null && this.loaded != true) {
                        /*Decrement the counter as JS file loading is completed*/
                        this.loaded = true;
                        pega.tools.EvalDomUtils_globals.skipExecuteCallBack = false;/*BUG-432709- The callBack should be executed only when theloading of external scripts is also done or if there are no external scripts*/
                        pega.tools.EvalDomUtils_globals.scriptLoaded();
                    }
                    pega.ctxmgr.resetContext(originalContext);
					          //if (pega && pega.ui && pega.ui.statetracking) pega.ui.statetracking.setScriptLoadingDone();
                };
            }

            var head = document.getElementsByTagName("head")[0];
            head.appendChild(fileref);
            pega.tools.EvalDomUtils_globals.loadedExternalFiles += file + " ";
        }

    },
    /*
    @private- Function to check if JS already exists
    @param $Object$file - The file to load
    @return $boolean$
    */
    isFileAlreadyLoaded: function(file, filetype) {
        var fileExists = false;
        if (pega.tools.EvalDomUtils_globals.loadedExternalFiles.indexOf(file) != -1) {
            fileExists = true;
        } else {

            if (this.checkScriptsInTag(file, "head", filetype) || this.checkScriptsInTag(file, "body", filetype)) return true;
            /*Check in the header first*/
        }
        return fileExists;
    },
    /*
    @private- Function to check if JS external scripts exists in the tag
    @param $String$tagName - The tag name in which the script search needs to be done
    @return $boolean$
    */
    checkScriptsInTag: function(file, tagName, filetype) {
        /*Check in the header first*/
        var scripts = "";
        var tagObj = document.getElementsByTagName(tagName);
        var tag = tagObj[0];
        if (filetype == "js") {
            if (!(scripts = tag.scripts))
                scripts = tag.getElementsByTagName('script');
        } else if (filetype == "css") {
            if (!(scripts = tag.links))
                scripts = tag.getElementsByTagName('link');
        }
        if (scripts != null) {
            if (scripts.length != null) {
                for (var i = 0; i < scripts.length; i++) {
                    var srcscript = "";
                    if (filetype == "js")
                        srcscript = unescape(scripts[i].src);
                    else if (filetype == "css")
                        srcscript = scripts[i].href;
                    if (srcscript != null && (srcscript == file || srcscript.indexOf(file) != -1)) {
                        return true;
                    }
                }
            } else if ((scripts.src != null && (unescape(scripts.src) == file || unescape(scripts.src).indexOf(file) != -1)) || (scripts.href != null && (scripts.href == file || scripts.href.indexOf(file) != -1))) {
                return true;
            }
        }
        return false;
    },

    isDuplicateUrl: function(childsrc, filesArray) {
        var arrLength = filesArray.length;
        var fileChild = null;
        var fileChildsrc = null;
        var fileChildTagName = null;
        for (var i = 0; i < arrLength; i++) {
            fileChild = filesArray[i][0];

            fileChildTagName = fileChild.tagName;
            if ("SCRIPT" == fileChildTagName)
                fileChildsrc = unescape(fileChild.getAttribute("src"));

            else if ("LINK" == fileChildTagName)
                fileChildsrc = fileChild.getAttribute("href");
            else if ("SPAN" == fileChildTagName)
                fileChildsrc = fileChild.getAttribute("scriptsrc");

            if (fileChildsrc == childsrc) {
                return true;
            }
          	fileChild = null;
        }
        return false;
    }

}

var DOMScriptLoader = function() {
    DOMScriptLoader.superclass.constructor.call(this);
}
pega.lang.extend(DOMScriptLoader, pega.tools.EvalDOMScripts);
//static-content-hash-trigger-GCC
/*
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.5.2
*/

/*
Changes:
1. TASK-14891: Commented out a code to fix the flickering issue in IE. This code is not present in yui 2.7
2. TASK-40549 : BUG-27518. I can't select this text in the name in order to copy and paste it. Removed the setting document onselectstart to false in the handleMouseDown API.
*/


/**
 * @description <p>Makes an element resizable</p>
 * @namespace pega.util
 * @requires pega, dom, dragdrop, element, event
 * @optional animation
 * @module resize
 * @beta
 */
(function() {
/*BUG-159902: Dev tip for the ENG-12590.*/
if(typeof(pega) == "undefined"){
     return;
}
var D = pega.util.Dom,
    Event = pega.util.Event,
    Lang = pega.lang;

    /**
     * @constructor
     * @class Resize
     * @extends pega.util.Element
     * @description <p>Makes an element resizable</p>
     * @param {String/HTMLElement} el The element to make resizable.
     * @param {Object} attrs Object liternal containing configuration parameters.
    */

    var Resize = function(el, config) {
        var oConfig = {
            element: el,
            attributes: config || {}
        };
        Resize.superclass.constructor.call(this, oConfig.element, oConfig.attributes);    
    };

    /**
    * @private
    * @static
    * @property _instances
    * @description Internal hash table for all resize instances
    * @type Object
    */ 
    Resize._instances = {};
    /**
    * @static
    * @method getResizeById 
    * @description Get's a resize object by the HTML id of the element associated with the Resize object.
    * @return {Object} The Resize Object
    */ 
    Resize.getResizeById = function(id) {
        if (Resize._instances[id]) {
            return Resize._instances[id];
        }
        return false;
    };

    pega.extend(Resize, pega.util.Element, {
        /**
        * @private
        * @property CSS_RESIZE
        * @description Base CSS class name
        * @type String
        */ 
        CSS_RESIZE: 'yui-resize',
        /**
        * @private
        * @property CSS_DRAG
        * @description Class name added when dragging is enabled
        * @type String
        */ 
        CSS_DRAG: 'yui-draggable',
        /**
        * @private
        * @property CSS_HOVER
        * @description Class name used for hover only handles
        * @type String
        */ 
        CSS_HOVER: 'yui-resize-hover',
        /**
        * @private
        * @property CSS_PROXY
        * @description Class name given to the proxy element
        * @type String
        */ 
        CSS_PROXY: 'yui-resize-proxy',
        /**
        * @private
        * @property CSS_WRAP
        * @description Class name given to the wrap element
        * @type String
        */ 
        CSS_WRAP: 'yui-resize-wrap',
        /**
        * @private
        * @property CSS_KNOB
        * @description Class name used to make the knob style handles
        * @type String
        */ 
        CSS_KNOB: 'yui-resize-knob',
        /**
        * @private
        * @property CSS_HIDDEN
        * @description Class name given to the wrap element to make all handles hidden
        * @type String
        */ 
        CSS_HIDDEN: 'yui-resize-hidden',
        /**
        * @private
        * @property CSS_HANDLE
        * @description Class name given to all handles, used as a base for single handle names as well.. Handle "t" will get this.CSS_HANDLE + '-t' as well as this.CSS_HANDLE
        * @type String
        */ 
        CSS_HANDLE: 'yui-resize-handle',
        /**
        * @private
        * @property CSS_STATUS
        * @description Class name given to the status element
        * @type String
        */ 
        CSS_STATUS: 'yui-resize-status',
        /**
        * @private
        * @property CSS_GHOST
        * @description Class name given to the wrap element when the ghost property is active
        * @type String
        */ 
        CSS_GHOST: 'yui-resize-ghost',
        /**
        * @private
        * @property CSS_RESIZING
        * @description Class name given to the wrap element when a resize action is taking place.
        * @type String
        */ 
        CSS_RESIZING: 'yui-resize-resizing',
        /**
        * @private
        * @property _resizeEvent
        * @description The mouse event used to resize with
        * @type Event
        */ 
        _resizeEvent: null,
        /**
        * @private
        * @property dd
        * @description The <a href="pega.util.DragDrop.html">pega.util.DragDrop</a> instance used if draggable is true
        * @type Object
        */ 
        dd: null,
        /** 
        * @private
        * @property browser
        * @description A copy of the pega.env.ua property
        * @type Object
        */
        browser: pega.env.ua,
        /** 
        * @private
        * @property _positioned
        * @description A flag to show if the element is absolutely positioned
        * @type Boolean
        */
        _positioned: null,
        /** 
        * @private
        * @property _dds
        * @description An Object containing references to all of the <a href="pega.util.DragDrop.html">pega.util.DragDrop</a> instances used for the resize handles
        * @type Object
        */
        _dds: null,
        /** 
        * @private
        * @property _wrap
        * @description The HTML reference of the element wrapper
        * @type HTMLElement
        */
        _wrap: null,
        /** 
        * @private
        * @property _proxy
        * @description The HTML reference of the element proxy
        * @type HTMLElement
        */
        _proxy: null,
        /** 
        * @private
        * @property _handles
        * @description An object containing references to all of the resize handles.
        * @type Object
        */
        _handles: null,
        /** 
        * @private
        * @property _currentHandle
        * @description The string identifier of the currently active handle. e.g. 'r', 'br', 'tl'
        * @type String
        */
        _currentHandle: null,
        /** 
        * @private
        * @property _currentDD
        * @description A link to the currently active DD object
        * @type Object
        */
        _currentDD: null,
        /** 
        * @private
        * @property _cache
        * @description An lookup table containing key information for the element being resized. e.g. height, width, x position, y position, etc..
        * @type Object
        */
        _cache: null,
        /** 
        * @private
        * @property _active
        * @description Flag to show if the resize is active. Used for events.
        * @type Boolean
        */
        _active: null,
        /** 
        * @private
        * @method _createProxy
        * @description Creates the proxy element if the proxy config is true
        */
        _createProxy: function() {
            if (this.get('proxy')) {
                this._proxy = document.createElement('div');
                this._proxy.className = this.CSS_PROXY;
                this._proxy.style.height = this.get('element').clientHeight + 'px';
                this._proxy.style.width = this.get('element').clientWidth + 'px';
                this._wrap.parentNode.appendChild(this._proxy);
            } else {
                this.set('animate', false);
            }
        },
        /** 
        * @private
        * @method _createWrap
        * @description Creates the wrap element if the wrap config is true. It will auto wrap the following element types: img, textarea, input, iframe, select
        */
        _createWrap: function() {
            this._positioned = false;
            //Force wrap for elements that can't have children 
            switch (this.get('element').tagName.toLowerCase()) {
                case 'img':
                case 'textarea':
                case 'input':
                case 'iframe':
                case 'select':
                    this.set('wrap', true);
                    break;
            }
            if (this.get('wrap')) {
                this._wrap = document.createElement('div');
                this._wrap.id = this.get('element').id + '_wrap';
                this._wrap.className = this.CSS_WRAP;
                D.setStyle(this._wrap, 'width', this.get('width'));
                D.setStyle(this._wrap, 'height', this.get('height'));
                D.setStyle(this._wrap, 'z-index', this.getStyle('z-index'));
                this.setStyle('z-index', 0);
                var pos = D.getStyle(this.get('element'), 'position');
                D.setStyle(this._wrap, 'position', ((pos == 'static') ? 'relative' : pos));
                D.setStyle(this._wrap, 'top', D.getStyle(this.get('element'), 'top'));
                D.setStyle(this._wrap, 'left', D.getStyle(this.get('element'), 'left'));
                if (D.getStyle(this.get('element'), 'position') == 'absolute') {
                    this._positioned = true;
                    D.setStyle(this.get('element'), 'position', 'relative');
                    D.setStyle(this.get('element'), 'top', '0');
                    D.setStyle(this.get('element'), 'left', '0');
                }
                var par = this.get('element').parentNode;
                par.replaceChild(this._wrap, this.get('element'));
                this._wrap.appendChild(this.get('element'));
            } else {
                this._wrap = this.get('element');
                if (D.getStyle(this._wrap, 'position') == 'absolute') {
                    this._positioned = true;
                }
            }
            if (this.get('draggable')) {
                this._setupDragDrop();
            }
            if (this.get('hover')) {
                D.addClass(this._wrap, this.CSS_HOVER);
            }
            if (this.get('knobHandles')) {
                D.addClass(this._wrap, this.CSS_KNOB);
            }
            if (this.get('hiddenHandles')) {
                D.addClass(this._wrap, this.CSS_HIDDEN);
            }
            D.addClass(this._wrap, this.CSS_RESIZE);
        },
        /** 
        * @private
        * @method _setupDragDrop
        * @description Setup the <a href="pega.util.DragDrop.html">pega.util.DragDrop</a> instance on the element
        */
        _setupDragDrop: function() {
            D.addClass(this._wrap, this.CSS_DRAG);
            this.dd = new pega.util.DD(this._wrap, this.get('id') + '-resize', { dragOnly: true });
            this.dd.on('dragEvent', function() {
                this.fireEvent('dragEvent', arguments);
            }, this, true);
        },
        /** 
        * @private
        * @method _createHandles
        * @description Creates the handles as specified in the config
        */
        _createHandles: function() {
            this._handles = {};
            this._dds = {};
            var h = this.get('handles');
            for (var i = 0; i < h.length; i++) {
                this._handles[h[i]] = document.createElement('div');
                this._handles[h[i]].id = D.generateId(this._handles[h[i]]);
                this._handles[h[i]].className = this.CSS_HANDLE + ' ' + this.CSS_HANDLE + '-' + h[i];
                var k = document.createElement('div');
                k.className = this.CSS_HANDLE + '-inner-' + h[i];
                this._handles[h[i]].appendChild(k);
                this._wrap.appendChild(this._handles[h[i]]);
                Event.on(this._handles[h[i]], 'mouseover', this._handleMouseOver, this, true);
                Event.on(this._handles[h[i]], 'mouseout', this._handleMouseOut, this, true);
                this._dds[h[i]] = new pega.util.DragDrop(this._handles[h[i]], this.get('id') + '-handle-' + h);
                this._dds[h[i]].setPadding(15, 15, 15, 15);
                this._dds[h[i]].on('startDragEvent', this._handleStartDrag, this._dds[h[i]], this);
                this._dds[h[i]].on('mouseDownEvent', this._handleMouseDown, this._dds[h[i]], this);
            }
            this._status = document.createElement('span');
            this._status.className = this.CSS_STATUS;
            document.body.insertBefore(this._status, document.body.firstChild);
        },
        /** 
        * @private
        * @method _ieSelectFix
        * @description The function we use as the onselectstart handler when we start a drag in Internet Explorer
        */
        _ieSelectFix: function() {
            return false;
        },
        /** 
        * @private
        * @property _ieSelectBack
        * @description We will hold a copy of the current "onselectstart" method on this property, and reset it after we are done using it.
        */
        _ieSelectBack: null,
        /** 
        * @private
        * @method _setAutoRatio
        * @param {Event} ev A mouse event.
        * @description This method checks to see if the "autoRatio" config is set. If it is, we will check to see if the "Shift Key" is pressed. If so, we will set the config ratio to true.
        */
        _setAutoRatio: function(ev) {
            if (this.get('autoRatio')) {
                if (ev && ev.shiftKey) {
                    //Shift Pressed
                    this.set('ratio', true);
                } else {
                    this.set('ratio', this._configs.ratio._initialConfig.value);
                }
            }
        },
        /** 
        * @private
        * @method _handleMouseDown
        * @param {Event} ev A mouse event.
        * @description This method preps the autoRatio on MouseDown.
        */
        _handleMouseDown: function(ev) {
            if (D.getStyle(this._wrap, 'position') == 'absolute') {
                this._positioned = true;
            }
            if (ev) {
                this._setAutoRatio(ev);
            }
            if (this.browser.ie) {
                this._ieSelectBack = document.body.onselectstart; 
            }
        },
        /** 
        * @private
        * @method _handleMouseOver
        * @param {Event} ev A mouse event.
        * @description Adds CSS class names to the handles
        */
        _handleMouseOver: function(ev) {
            //Internet Explorer needs this
            D.removeClass(this._wrap, this.CSS_RESIZE);
            if (this.get('hover')) {
                D.removeClass(this._wrap, this.CSS_HOVER);
            }
            var tar = Event.getTarget(ev);
            if (!D.hasClass(tar, this.CSS_HANDLE)) {
                tar = tar.parentNode;
            }
            if (D.hasClass(tar, this.CSS_HANDLE) && !this._active) {
                D.addClass(tar, this.CSS_HANDLE + '-active');
                for (var i in this._handles) {
                    if (Lang.hasOwnProperty(this._handles, i)) {
                        if (this._handles[i] == tar) {
                            D.addClass(tar, this.CSS_HANDLE + '-' + i + '-active');
                            break;
                        }
                    }
                }
            }

            //Internet Explorer needs this
            D.addClass(this._wrap, this.CSS_RESIZE);
        },
        /** 
        * @private
        * @method _handleMouseOut
        * @param {Event} ev A mouse event.
        * @description Removes CSS class names to the handles
        */
        _handleMouseOut: function(ev) {
            //Internet Explorer needs this
            D.removeClass(this._wrap, this.CSS_RESIZE);
            if (this.get('hover') && !this._active) {
                D.addClass(this._wrap, this.CSS_HOVER);
            }
            var tar = Event.getTarget(ev);
            if (!D.hasClass(tar, this.CSS_HANDLE)) {
                tar = tar.parentNode;
            }
            if (D.hasClass(tar, this.CSS_HANDLE) && !this._active) {
                D.removeClass(tar, this.CSS_HANDLE + '-active');
                for (var i in this._handles) {
                    if (Lang.hasOwnProperty(this._handles, i)) {
                        if (this._handles[i] == tar) {
                            D.removeClass(tar, this.CSS_HANDLE + '-' + i + '-active');
                            break;
                        }
                    }
                }
            }
            //Internet Explorer needs this
            D.addClass(this._wrap, this.CSS_RESIZE);
        },
        /** 
        * @private
        * @method _handleStartDrag
        * @param {Object} args The args passed from the CustomEvent.
        * @param {Object} dd The <a href="pega.util.DragDrop.html">pega.util.DragDrop</a> object we are working with.
        * @description Resizes the proxy, sets up the <a href="pega.util.DragDrop.html">pega.util.DragDrop</a> handlers, updates the status div and preps the cache
        */
        _handleStartDrag: function(args, dd) {
            var tar = dd.getDragEl();
            if (D.hasClass(tar, this.CSS_HANDLE)) {
                if (D.getStyle(this._wrap, 'position') == 'absolute') {
                    this._positioned = true;
                }
                this._active = true;
                this._currentDD = dd;
                if (this._proxy) {
                    this._proxy.style.visibility = 'visible';
                    this._proxy.style.zIndex = '1000';
                    this._proxy.style.height = this.get('element').clientHeight + 'px';
                    this._proxy.style.width = this.get('element').clientWidth + 'px';
                }

                for (var i in this._handles) {
                    if (Lang.hasOwnProperty(this._handles, i)) {
                        if (this._handles[i] == tar) {
                            this._currentHandle = i;
                            var handle = '_handle_for_' + i;
                            D.addClass(tar, this.CSS_HANDLE + '-' + i + '-active');
                            dd.on('dragEvent', this[handle], this, true);
                            dd.on('mouseUpEvent', this._handleMouseUp, this, true);
                            break;
                        }
                    }
                }


                D.addClass(tar, this.CSS_HANDLE + '-active');

                if (this.get('proxy')) {
                    var xy = D.getXY(this.get('element'));
                    D.setXY(this._proxy, xy);
                    if (this.get('ghost')) {
                        this.addClass(this.CSS_GHOST);
                    }
                }
                D.addClass(this._wrap, this.CSS_RESIZING);
                this._setCache();
                this._updateStatus(this._cache.height, this._cache.width, this._cache.top, this._cache.left);
                this.fireEvent('startResize', { type: 'startresize', target: this});
            }
        },
        /** 
        * @private
        * @method _setCache
        * @description Sets up the this._cache hash table.
        */
        _setCache: function() {
            this._cache.xy = D.getXY(this._wrap);
            D.setXY(this._wrap, this._cache.xy);
			//BUG-106205 Need to get height without padding. Replaced with jQuery
            this._cache.height = $(this._configs.element.value).height()	//this.get('clientHeight');
            this._cache.width = $(this._configs.element.value).width();		//this.get('clientWidth');
            this._cache.start.height = this._cache.height;
            this._cache.start.width = this._cache.width;
            this._cache.start.top = this._cache.xy[1];
            this._cache.start.left = this._cache.xy[0];
            this._cache.top = this._cache.xy[1];
            this._cache.left = this._cache.xy[0];
            this.set('height', this._cache.height, true);
            this.set('width', this._cache.width, true);
        },
        /** 
        * @private
        * @method _handleMouseUp
        * @param {Event} ev A mouse event.
        * @description Cleans up listeners, hides proxy element and removes class names.
        */
        _handleMouseUp: function(ev) {
            this._active = false;

            var handle = '_handle_for_' + this._currentHandle;
            this._currentDD.unsubscribe('dragEvent', this[handle], this, true);
            this._currentDD.unsubscribe('mouseUpEvent', this._handleMouseUp, this, true);

            if (this._proxy) {
                this._proxy.style.visibility = 'hidden';
                this._proxy.style.zIndex = '-1';
                if (this.get('setSize')) {
                    this.resize(ev, this._cache.height, this._cache.width, this._cache.top, this._cache.left, true);
                } else {
                    this.fireEvent('resize', { ev: 'resize', target: this, height: this._cache.height, width: this._cache.width, top: this._cache.top, left: this._cache.left });
                }

                if (this.get('ghost')) {
                    this.removeClass(this.CSS_GHOST);
                }
            }

            if (this.get('hover')) {
                D.addClass(this._wrap, this.CSS_HOVER);
            }
            if (this._status) {
                D.setStyle(this._status, 'display', 'none');
            }
            if (this.browser.ie) {
                document.body.onselectstart = this._ieSelectBack;
            }

            if (this.browser.ie) {
                D.removeClass(this._wrap, this.CSS_RESIZE);
            }

            for (var i in this._handles) {
                if (Lang.hasOwnProperty(this._handles, i)) {
                    D.removeClass(this._handles[i], this.CSS_HANDLE + '-active');
                }
            }
            if (this.get('hover') && !this._active) {
                D.addClass(this._wrap, this.CSS_HOVER);
            }
            D.removeClass(this._wrap, this.CSS_RESIZING);

            D.removeClass(this._handles[this._currentHandle], this.CSS_HANDLE + '-' + this._currentHandle + '-active');
            D.removeClass(this._handles[this._currentHandle], this.CSS_HANDLE + '-active');

            if (this.browser.ie) {
                D.addClass(this._wrap, this.CSS_RESIZE);
            }

            this._resizeEvent = null;
            this._currentHandle = null;
            
            if (!this.get('animate')) {
                this.set('height', this._cache.height, true);
                this.set('width', this._cache.width, true);
            }

            this.fireEvent('endResize', { ev: 'endResize', target: this, height: this._cache.height, width: this._cache.width, top: this._cache.top, left: this._cache.left });
        },
        /** 
        * @private
        * @method _setRatio
        * @param {Number} h The height offset.
        * @param {Number} w The with offset.
        * @param {Number} t The top offset.
        * @param {Number} l The left offset.
        * @description Using the Height, Width, Top & Left, it recalcuates them based on the original element size.
        * @return {Array} The new Height, Width, Top & Left settings
        */
        _setRatio: function(h, w, t, l) {
            var oh = h, ow = w;
            if (this.get('ratio')) {
                var orgH = this._cache.height,
                    orgW = this._cache.width,
                    nh = parseInt(this.get('height'), 10),
                    nw = parseInt(this.get('width'), 10),
                    maxH = this.get('maxHeight'),
                    minH = this.get('minHeight'),
                    maxW = this.get('maxWidth'),
                    minW = this.get('minWidth');

                switch (this._currentHandle) {
                    case 'l':
                        h = nh * (w / nw);
                        h = Math.min(Math.max(minH, h), maxH);                        
                        w = nw * (h / nh);
                        t = (this._cache.start.top - (-((nh - h) / 2)));
                        l = (this._cache.start.left - (-((nw - w))));
                        break;
                    case 'r':
                        h = nh * (w / nw);
                        h = Math.min(Math.max(minH, h), maxH);                        
                        w = nw * (h / nh);
                        t = (this._cache.start.top - (-((nh - h) / 2)));
                        break;
                    case 't':
                        w = nw * (h / nh);
                        h = nh * (w / nw);
                        l = (this._cache.start.left - (-((nw - w) / 2)));
                        t = (this._cache.start.top - (-((nh - h))));
                        break;
                    case 'b':
                        w = nw * (h / nh);
                        h = nh * (w / nw);
                        l = (this._cache.start.left - (-((nw - w) / 2)));
                        break;
                    case 'bl':
                        h = nh * (w / nw);
                        w = nw * (h / nh);
                        l = (this._cache.start.left - (-((nw - w))));
                        break;
                    case 'br':
                        h = nh * (w / nw);
                        w = nw * (h / nh);
                        break;
                    case 'tl':
                        h = nh * (w / nw);
                        w = nw * (h / nh);
                        l = (this._cache.start.left - (-((nw - w))));
                        t = (this._cache.start.top - (-((nh - h))));
                        break;
                    case 'tr':
                        h = nh * (w / nw);
                        w = nw * (h / nh);
                        l = (this._cache.start.left);
                        t = (this._cache.start.top - (-((nh - h))));
                        break;
                }
                oh = this._checkHeight(h);
                ow = this._checkWidth(w);
                if ((oh != h) || (ow != w)) {
                    t = 0;
                    l = 0;
                    if (oh != h) {
                        ow = this._cache.width;
                    }
                    if (ow != w) {
                        oh = this._cache.height;
                    }
                }
            }
            return [oh, ow, t, l];
        },
        /** 
        * @private
        * @method _updateStatus
        * @param {Number} h The new height setting.
        * @param {Number} w The new width setting.
        * @param {Number} t The new top setting.
        * @param {Number} l The new left setting.
        * @description Using the Height, Width, Top & Left, it updates the status element with the elements sizes.
        */
        _updateStatus: function(h, w, t, l) {
            if (this._resizeEvent && (!Lang.isString(this._resizeEvent))) {
                if (this.get('status')) {
                    D.setStyle(this._status, 'display', 'inline');
                }
                h = ((h === 0) ? this._cache.start.height : h);
                w = ((w === 0) ? this._cache.start.width : w);
                var h1 = parseInt(this.get('height'), 10),
                    w1 = parseInt(this.get('width'), 10);
                
                if (isNaN(h1)) {
                    h1 = parseInt(h, 10);
                }
                if (isNaN(w1)) {
                    w1 = parseInt(w, 10);
                }
                var diffH = (parseInt(h, 10) - h1);
                var diffW = (parseInt(w, 10) - w1);
                this._cache.offsetHeight = diffH;
                this._cache.offsetWidth = diffW;
                this._status.innerHTML = '<strong>' + parseInt(h, 10) + ' x ' + parseInt(w, 10) + '</strong><em>' + ((diffH > 0) ? '+' : '') + diffH + ' x ' + ((diffW > 0) ? '+' : '') + diffW + '</em>';
                D.setXY(this._status, [Event.getPageX(this._resizeEvent) + 12, Event.getPageY(this._resizeEvent) + 12]);
            }
        },
        /** 
        * @method reset
        * @description Resets the element to is start state.
        * @return {<a href="pega.util.Resize.html">pega.util.Resize</a>} The Resize instance
        */
        reset: function() {
            this.resize(null, this._cache.start.height, this._cache.start.width, this._cache.start.top, this._cache.start.left, true);
            return this;
        },
        /** 
        * @method resize
        * @param {Event} ev The mouse event.
        * @param {Number} h The new height setting.
        * @param {Number} w The new width setting.
        * @param {Number} t The new top setting.
        * @param {Number} l The new left setting.
        * @param {Boolean} force Resize the element (used for proxy resize).
        * @param {Boolean} silent Don't fire the beforeResize Event.
        * @description Resizes the element, wrapper or proxy based on the data from the handlers.
        * @return {<a href="pega.util.Resize.html">pega.util.Resize</a>} The Resize instance
        */
        resize: function(ev, h, w, t, l, force, silent) {
            this._resizeEvent = ev;
            var el = this._wrap, anim = this.get('animate'), set = true;
            if (this._proxy && !force) {
                el = this._proxy;
                anim = false;
            }
            this._setAutoRatio(ev);
            if (this._positioned) {
                if (this._proxy) {
                    t = this._cache.top - t;
                    l = this._cache.left - l;
                }
            }

            var ratio = this._setRatio(h, w, t, l);
            h = parseInt(ratio[0], 10);
            w = parseInt(ratio[1], 10);
            t = parseInt(ratio[2], 10);
            l = parseInt(ratio[3], 10);

            if (t == 0) {
                //No Offset, get from cache
                t = D.getY(el);
            }
            if (l == 0) {
                //No Offset, get from cache
                l = D.getX(el);
            }

            

            if (this._positioned) {
                if (this._proxy && force) {
                    if (!anim) {
                        el.style.top = this._proxy.style.top;
                        el.style.left = this._proxy.style.left;
                    } else {
                        t = this._proxy.style.top;
                        l = this._proxy.style.left;
                    }
                } else {
                    if (!this.get('ratio') && !this._proxy) {
                        t = this._cache.top + -(t);
                        l = this._cache.left + -(l);
                    }
                    if (t) {
                        if (this.get('minY')) {
                            if (t < this.get('minY')) {
                                t = this.get('minY');
                            }
                        }
                        if (this.get('maxY')) {
                            if (t > this.get('maxY')) {
                                t = this.get('maxY');
                            }
                        }
                    }
                    if (l) {
                        if (this.get('minX')) {
                            if (l < this.get('minX')) {
                                l = this.get('minX');
                            }
                        }
                        if (this.get('maxX')) {
                            if ((l + w) > this.get('maxX')) {
                                l = (this.get('maxX') - w);
                            }
                        }
                    }
                }
            }
            if (!silent) {
                var beforeReturn = this.fireEvent('beforeResize', { ev: 'beforeResize', target: this, height: h, width: w, top: t, left: l });
                if (beforeReturn === false) {
                    return false;
                }
            }

            this._updateStatus(h, w, t, l);

            if (this._positioned) {
                if (this._proxy && force) {
                    //Do nothing
                } else {
                    if (t) {
                        D.setY(el, t);
                        this._cache.top = t;
                    }
                    if (l) {
                        D.setX(el, l);
                        this._cache.left = l;
                    }
                }
            }
            if (h) {
                if (!anim) {
                    set = true;
                    if (this._proxy && force) {
                        if (!this.get('setSize')) {
                            set = false;
                        }
                    }
                    if (set) {
		      /* 
                        if (this.browser.ie > 6) {
                            if (h === this._cache.height) {
                                h = h + 1;
                            }
                        }
		      */
                        el.style.height = h + 'px';
                    }
                    if ((this._proxy && force) || !this._proxy) {
                        if (this._wrap != this.get('element')) {
                            this.get('element').style.height = h + 'px';
                        }
                    }
                }
                this._cache.height = h;
            }
            if (w) {
                this._cache.width = w;
                if (!anim) {
                    set = true;
                    if (this._proxy && force) {
                        if (!this.get('setSize')) {
                            set = false;
                        }
                    }
                    if (set) {
                        el.style.width = w + 'px';
                    }
                    if ((this._proxy && force) || !this._proxy) {
                        if (this._wrap != this.get('element')) {
                            this.get('element').style.width = w + 'px';
                        }
                    }
                }
            }
            if (anim) {
                if (pega.util.Anim) {
                    var _anim = new pega.util.Anim(el, {
                        height: {
                            to: this._cache.height
                        },
                        width: {
                            to: this._cache.width
                        }
                    }, this.get('animateDuration'), this.get('animateEasing'));
                    if (this._positioned) {
                        if (t) {
                            _anim.attributes.top = {
                                to: parseInt(t, 10)
                            };
                        }
                        if (l) {
                            _anim.attributes.left = {
                                to: parseInt(l, 10)
                            };
                        }
                    }

                    if (this._wrap != this.get('element')) {
                        _anim.onTween.subscribe(function() {
                            this.get('element').style.height = el.style.height;
                            this.get('element').style.width = el.style.width;
                        }, this, true);
                    }

                    _anim.onComplete.subscribe(function() {
                        this.set('height', h);
                        this.set('width', w);
                        this.fireEvent('resize', { ev: 'resize', target: this, height: h, width: w, top: t, left: l });
                    }, this, true);
                    _anim.animate();

                }
            } else {
                if (this._proxy && !force) {
                    this.fireEvent('proxyResize', { ev: 'proxyresize', target: this, height: h, width: w, top: t, left: l });
                } else {
                    this.fireEvent('resize', { ev: 'resize', target: this, height: h, width: w, top: t, left: l });
                }
            }
            return this;
        },
        /** 
        * @private
        * @method _handle_for_br
        * @param {Object} args The arguments from the CustomEvent.
        * @description Handles the sizes for the Bottom Right handle.
        */
        _handle_for_br: function(args) {
            var newW = this._setWidth(args.e);
            var newH = this._setHeight(args.e);
            this.resize(args.e, (newH + 1), newW, 0, 0);
        },
        /** 
        * @private
        * @method _handle_for_bl
        * @param {Object} args The arguments from the CustomEvent.
        * @description Handles the sizes for the Bottom Left handle.
        */
        _handle_for_bl: function(args) {
            var newW = this._setWidth(args.e, true);
            var newH = this._setHeight(args.e);
            var l = (newW - this._cache.width);
            this.resize(args.e, newH, newW, 0, l);
        },
        /** 
        * @private
        * @method _handle_for_tl
        * @param {Object} args The arguments from the CustomEvent.
        * @description Handles the sizes for the Top Left handle.
        */
        _handle_for_tl: function(args) {
            var newW = this._setWidth(args.e, true);
            var newH = this._setHeight(args.e, true);
            var t = (newH - this._cache.height);
            var l = (newW - this._cache.width);
            this.resize(args.e, newH, newW, t, l);
        },
        /** 
        * @private
        * @method _handle_for_tr
        * @param {Object} args The arguments from the CustomEvent.
        * @description Handles the sizes for the Top Right handle.
        */
        _handle_for_tr: function(args) {
            var newW = this._setWidth(args.e);
            var newH = this._setHeight(args.e, true);
            var t = (newH - this._cache.height);
            this.resize(args.e, newH, newW, t, 0);
        },
        /** 
        * @private
        * @method _handle_for_r
        * @param {Object} args The arguments from the CustomEvent.
        * @description Handles the sizes for the Right handle.
        */
        _handle_for_r: function(args) {
            this._dds.r.setYConstraint(0,0);
            var newW = this._setWidth(args.e);
            this.resize(args.e, 0, newW, 0, 0);
        },
        /** 
        * @private
        * @method _handle_for_l
        * @param {Object} args The arguments from the CustomEvent.
        * @description Handles the sizes for the Left handle.
        */
        _handle_for_l: function(args) {
            this._dds.l.setYConstraint(0,0);
            var newW = this._setWidth(args.e, true);
            var l = (newW - this._cache.width);
            this.resize(args.e, 0, newW, 0, l);
        },
        /** 
        * @private
        * @method _handle_for_b
        * @param {Object} args The arguments from the CustomEvent.
        * @description Handles the sizes for the Bottom handle.
        */
        _handle_for_b: function(args) {
            this._dds.b.setXConstraint(0,0);
            var newH = this._setHeight(args.e);
            this.resize(args.e, newH, 0, 0, 0);
        },
        /** 
        * @private
        * @method _handle_for_t
        * @param {Object} args The arguments from the CustomEvent.
        * @description Handles the sizes for the Top handle.
        */
        _handle_for_t: function(args) {
            this._dds.t.setXConstraint(0,0);
            var newH = this._setHeight(args.e, true);
            var t = (newH - this._cache.height);
            this.resize(args.e, newH, 0, t, 0);
        },
        /** 
        * @private
        * @method _setWidth
        * @param {Event} ev The mouse event.
        * @param {Boolean} flip Argument to determine the direction of the movement.
        * @description Calculates the width based on the mouse event.
        * @return {Number} The new value
        */
        _setWidth: function(ev, flip) {
            var xy = this._cache.xy[0],
                w = this._cache.width,
                x = Event.getPageX(ev),
                nw = (x - xy);

                if (flip) {
                    nw = (xy - x) + parseInt(this.get('width'), 10);
                }
                
                nw = this._snapTick(nw, this.get('yTicks'));
                nw = this._checkWidth(nw);
            return nw;
        },
        /** 
        * @private
        * @method _checkWidth
        * @param {Number} w The width to check.
        * @description Checks the value passed against the maxWidth and minWidth.
        * @return {Number} the new value
        */
        _checkWidth: function(w) {
            if (this.get('minWidth')) {
                if (w <= this.get('minWidth')) {
                    w = this.get('minWidth');
                }
            }
            if (this.get('maxWidth')) {
                if (w >= this.get('maxWidth')) {
                    w = this.get('maxWidth');
                }
            }
            return w;
        },
        /** 
        * @private
        * @method _checkHeight
        * @param {Number} h The height to check.
        * @description Checks the value passed against the maxHeight and minHeight.
        * @return {Number} The new value
        */
        _checkHeight: function(h) {
            if (this.get('minHeight')) {
                if (h <= this.get('minHeight')) {
                    h = this.get('minHeight');
                }
            }
            if (this.get('maxHeight')) {
                if (h >= this.get('maxHeight')) {
                    h = this.get('maxHeight');
                }
            }
            return h;
        },
        /** 
        * @private
        * @method _setHeight
        * @param {Event} ev The mouse event.
        * @param {Boolean} flip Argument to determine the direction of the movement.
        * @description Calculated the height based on the mouse event.
        * @return {Number} The new value
        */
        _setHeight: function(ev, flip) {
            var xy = this._cache.xy[1],
                h = this._cache.height,
                y = Event.getPageY(ev),
                nh = (y - xy);

                if (flip) {
                    nh = (xy - y) + parseInt(this.get('height'), 10);
                }
                nh = this._snapTick(nh, this.get('xTicks'));
                nh = this._checkHeight(nh);
                
            return nh;
        },
        /** 
        * @private
        * @method _snapTick
        * @param {Number} size The size to tick against.
        * @param {Number} pix The tick pixels.
        * @description Adjusts the number based on the ticks used.
        * @return {Number} the new snapped position
        */
        _snapTick: function(size, pix) {
            if (!size || !pix) {
                return size;
            }
            var _s = size;
            var _x = size % pix;
            if (_x > 0) {
                if (_x > (pix / 2)) {
                    _s = size + (pix - _x);
                } else {
                    _s = size - _x;
                }
            }
            return _s;
        },
        /** 
        * @private
        * @method init
        * @description The Resize class's initialization method
        */        
        init: function(p_oElement, p_oAttributes) {
            this._cache = {
                xy: [],
                height: 0,
                width: 0,
                top: 0,
                left: 0,
                offsetHeight: 0,
                offsetWidth: 0,
                start: {
                    height: 0,
                    width: 0,
                    top: 0,
                    left: 0
                }
            };

            Resize.superclass.init.call(this, p_oElement, p_oAttributes);

            this.set('setSize', this.get('setSize'));

            if (p_oAttributes.height) {
                this.set('height', parseInt(p_oAttributes.height, 10));
            }
            if (p_oAttributes.width) {
                this.set('width', parseInt(p_oAttributes.width, 10));
            }
            
            var id = p_oElement;
            if (!Lang.isString(id)) {
                id = D.generateId(id);
            }
            Resize._instances[id] = this;

            this._active = false;
            
            this._createWrap();
            this._createProxy();
            this._createHandles();

        },
        /**
        * @method getProxyEl
        * @description Get the HTML reference for the proxy, returns null if no proxy.
        * @return {HTMLElement} The proxy element
        */      
        getProxyEl: function() {
            return this._proxy;
        },
        /**
        * @method getWrapEl
        * @description Get the HTML reference for the wrap element, returns the current element if not wrapped.
        * @return {HTMLElement} The wrap element
        */      
        getWrapEl: function() {
            return this._wrap;
        },
        /**
        * @method getStatusEl
        * @description Get the HTML reference for the status element.
        * @return {HTMLElement} The status element
        */      
        getStatusEl: function() {
            return this._status;
        },
        /**
        * @method getActiveHandleEl
        * @description Get the HTML reference for the currently active resize handle.
        * @return {HTMLElement} The handle element that is active
        */      
        getActiveHandleEl: function() {
            return this._handles[this._currentHandle];
        },
        /**
        * @method isActive
        * @description Returns true or false if a resize operation is currently active on the element.
        * @return {Boolean}
        */      
        isActive: function() {
            return ((this._active) ? true : false);
        },
        /**
        * @private
        * @method initAttributes
        * @description Initializes all of the configuration attributes used to create a resizable element.
        * @param {Object} attr Object literal specifying a set of 
        * configuration attributes used to create the utility.
        */      
        initAttributes: function(attr) {
            Resize.superclass.initAttributes.call(this, attr);

            /**
            * @attribute setSize
            * @description Set the size of the resized element, if set to false the element will not be auto resized,
            * the resize event will contain the dimensions so the end user can resize it on their own.
            * This setting will only work with proxy set to true and animate set to false.
            * @type Boolean
            */
            this.setAttributeConfig('setSize', {
                value: ((attr.setSize === false) ? false : true),
                validator: pega.lang.isBoolean
            });

            /**
            * @attribute wrap
            * @description Should we wrap the element
            * @type Boolean
            */
            this.setAttributeConfig('wrap', {
                writeOnce: true,
                validator: pega.lang.isBoolean,
                value: attr.wrap || false
            });

            /**
            * @attribute handles
            * @description The handles to use (any combination of): 't', 'b', 'r', 'l', 'bl', 'br', 'tl', 'tr'. Defaults to: ['r', 'b', 'br'].
            * Can use a shortcut of All. Note: 8 way resizing should be done on an element that is absolutely positioned.
            * @type Array
            */
            this.setAttributeConfig('handles', {
                writeOnce: true,
                value: attr.handles || ['r', 'b', 'br'],
                validator: function(handles) {
                    if (Lang.isString(handles) && handles.toLowerCase() == 'all') {
                        handles = ['t', 'b', 'r', 'l', 'bl', 'br', 'tl', 'tr'];
                    }
                    if (!Lang.isArray(handles)) {
                        handles = handles.replace(/, /g, ',');
                        handles = handles.split(',');
                    }
                    this._configs.handles.value = handles;
                }
            });

            /**
            * @attribute width
            * @description The width of the element
            * @type Number
            */
            this.setAttributeConfig('width', {
                value: attr.width || parseInt(this.getStyle('width'), 10),
                validator: pega.lang.isNumber,
                method: function(width) {
                    width = parseInt(width, 10);
                    if (width > 0) {
                        if (this.get('setSize')) {
                            this.setStyle('width', width + 'px');
                        }
                        this._cache.width = width;
                        this._configs.width.value = width;
                    }
                }
            });

            /**
            * @attribute height
            * @description The height of the element
            * @type Number
            */
            this.setAttributeConfig('height', {
                value: attr.height || parseInt(this.getStyle('height'), 10),
                validator: pega.lang.isNumber,
                method: function(height) {
                    height = parseInt(height, 10);
                    if (height > 0) {
                        if (this.get('setSize')) {
                            this.setStyle('height', height + 'px');
                        }
                        this._cache.height = height;
                        this._configs.height.value = height;
                    }
                }
            });

            /**
            * @attribute minWidth
            * @description The minimum width of the element
            * @type Number
            */
            this.setAttributeConfig('minWidth', {
                value: attr.minWidth || 15,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute minHeight
            * @description The minimum height of the element
            * @type Number
            */
            this.setAttributeConfig('minHeight', {
                value: attr.minHeight || 15,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute maxWidth
            * @description The maximum width of the element
            * @type Number
            */
            this.setAttributeConfig('maxWidth', {
                value: attr.maxWidth || 10000,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute maxHeight
            * @description The maximum height of the element
            * @type Number
            */
            this.setAttributeConfig('maxHeight', {
                value: attr.maxHeight || 10000,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute minY
            * @description The minimum y coord of the element
            * @type Number
            */
            this.setAttributeConfig('minY', {
                value: attr.minY || false
            });

            /**
            * @attribute minX
            * @description The minimum x coord of the element
            * @type Number
            */
            this.setAttributeConfig('minX', {
                value: attr.minX || false
            });
            /**
            * @attribute maxY
            * @description The max y coord of the element
            * @type Number
            */
            this.setAttributeConfig('maxY', {
                value: attr.maxY || false
            });

            /**
            * @attribute maxX
            * @description The max x coord of the element
            * @type Number
            */
            this.setAttributeConfig('maxX', {
                value: attr.maxX || false
            });

            /**
            * @attribute animate
            * @description Should be use animation to resize the element (can only be used if we use proxy).
            * @type Boolean
            */
            this.setAttributeConfig('animate', {
                value: attr.animate || false,
                validator: function(value) {
                    var ret = true;
                    if (!pega.util.Anim) {
                        ret = false;
                    }
                    return ret;
                }               
            });

            /**
            * @attribute animateEasing
            * @description The Easing to apply to the animation.
            * @type Object
            */
            this.setAttributeConfig('animateEasing', {
                value: attr.animateEasing || function() {
                    var easing = false;
                    try {
                        easing = pega.util.Easing.easeOut;
                    } catch (e) {}
                    return easing;
                }()
            });

            /**
            * @attribute animateDuration
            * @description The Duration to apply to the animation.
            * @type Number
            */
            this.setAttributeConfig('animateDuration', {
                value: attr.animateDuration || 0.5
            });

            /**
            * @attribute proxy
            * @description Resize a proxy element instead of the real element.
            * @type Boolean
            */
            this.setAttributeConfig('proxy', {
                value: attr.proxy || false,
                validator: pega.lang.isBoolean
            });

            /**
            * @attribute ratio
            * @description Maintain the element's ratio when resizing.
            * @type Boolean
            */
            this.setAttributeConfig('ratio', {
                value: attr.ratio || false,
                validator: pega.lang.isBoolean
            });

            /**
            * @attribute ghost
            * @description Apply an opacity filter to the element being resized (only works with proxy).
            * @type Boolean
            */
            this.setAttributeConfig('ghost', {
                value: attr.ghost || false,
                validator: pega.lang.isBoolean
            });

            /**
            * @attribute draggable
            * @description A convienence method to make the element draggable
            * @type Boolean
            */
            this.setAttributeConfig('draggable', {
                value: attr.draggable || false,
                validator: pega.lang.isBoolean,
                method: function(dd) {
                    if (dd && this._wrap) {
                        this._setupDragDrop();
                    } else {
                        if (this.dd) {
                            D.removeClass(this._wrap, this.CSS_DRAG);
                            this.dd.unreg();
                        }
                    }
                }
            });

            /**
            * @attribute hover
            * @description Only show the handles when they are being moused over.
            * @type Boolean
            */
            this.setAttributeConfig('hover', {
                value: attr.hover || false,
                validator: pega.lang.isBoolean
            });

            /**
            * @attribute hiddenHandles
            * @description Don't show the handles, just use the cursor to the user.
            * @type Boolean
            */
            this.setAttributeConfig('hiddenHandles', {
                value: attr.hiddenHandles || false,
                validator: pega.lang.isBoolean
            });

            /**
            * @attribute knobHandles
            * @description Use the smaller handles, instead if the full size handles.
            * @type Boolean
            */
            this.setAttributeConfig('knobHandles', {
                value: attr.knobHandles || false,
                validator: pega.lang.isBoolean
            });

            /**
            * @attribute xTicks
            * @description The number of x ticks to span the resize to.
            * @type Number or False
            */
            this.setAttributeConfig('xTicks', {
                value: attr.xTicks || false
            });

            /**
            * @attribute yTicks
            * @description The number of y ticks to span the resize to.
            * @type Number or False
            */
            this.setAttributeConfig('yTicks', {
                value: attr.yTicks || false
            });

            /**
            * @attribute status
            * @description Show the status (new size) of the resize.
            * @type Boolean
            */
            this.setAttributeConfig('status', {
                value: attr.status || false,
                validator: pega.lang.isBoolean
            });

            /**
            * @attribute autoRatio
            * @description Using the shift key during a resize will toggle the ratio config.
            * @type Boolean
            */
            this.setAttributeConfig('autoRatio', {
                value: attr.autoRatio || false,
                validator: pega.lang.isBoolean
            });

        },
        /**
        * @method destroy
        * @description Destroys the resize object and all of it's elements & listeners.
        */        
        destroy: function() {
            var k =  this.get('id') + '-handle-' + this.get('handles');
            for (var h in this._handles) {
                if (Lang.hasOwnProperty(this._handles, h)) {
                    Event.purgeElement(this._handles[h]);
                     if(this._handles[h].parentNode){
                       this._handles[h].parentNode.removeChild(this._handles[h]);
                     }
                     else{
                       delete this._handles[h];
                     }
                    this._dds[h].removeFromGroup(k);
                }
            }
            if (this._proxy) {
                if(this._proxy.parentNode){
                  this._proxy.parentNode.removeChild(this._proxy);
                }
                else{
                  delete this._proxy;
                }
            }
            if (this._status) {
                if(this._status.parentNode){
                  this._status.parentNode.removeChild(this._status);
                }
                else{
                  delete this._status;
                }
            }
            if (this.dd) {
                this.dd.unreg();
                D.removeClass(this._wrap, this.CSS_DRAG);
            }
            if (this._wrap != this.get('element')) {
                this.setStyle('position', '');
                this.setStyle('top', '');
                this.setStyle('left', '');
                if(this._wrap.parentNode){
                  this._wrap.parentNode.replaceChild(this.get('element'), this._wrap);
                }
            }
            this.removeClass(this.CSS_RESIZE);

            delete pega.util.Resize._instances[this.get('id')];
            //Brutal Object Destroy
            for (var i in this) {
                if (Lang.hasOwnProperty(this, i)) {
                    this[i] = null;
                    delete this[i];
                }
            }
        },
        /**
        * @method toString
        * @description Returns a string representing the Resize Object.
        * @return {String}
        */        
        toString: function() {
            if (this.get) {
                return 'Resize (#' + this.get('id') + ')';
            }
            return 'Resize Utility';
        }
    });

    pega.util.Resize = Resize;
 
/**
* @event dragEvent
* @description Fires when the <a href="pega.util.DragDrop.html">pega.util.DragDrop</a> dragEvent is fired for the config option draggable.
* @type pega.util.CustomEvent
*/
/**
* @event startResize
* @description Fires when when a resize action is started.
* @type pega.util.CustomEvent
*/
/**
* @event endResize
* @description Fires when the mouseUp event from the Drag Instance fires.
* @type pega.util.CustomEvent
*/
/**
* @event resize
* @description Fires on every element resize (only fires once when used with proxy config setting).
* @type pega.util.CustomEvent
*/
/**
* @event beforeResize
* @description Fires before every element resize after the size calculations, returning false will stop the resize.
* @type pega.util.CustomEvent
*/
/**
* @event proxyResize
* @description Fires on every proxy resize (only fires when used with proxy config setting).
* @type pega.util.CustomEvent
*/

})();
/*BUG-159902: Dev tip for the ENG-12590.*/
if(typeof(pega) != "undefined"){
	pega.register("resize", pega.util.Resize, {version: "2.5.2", build: "1076"});
}
//static-content-hash-trigger-GCC
pega.u = pega.namespace("pega.ui");
pega.u.NonBlockingAjax = {}; 
(function(p) {
	var ajaxParams = {};
	var nonBlockingAJAXRetryCount = pega.u.d.longPollRetryCount || 0;
	var _PendingRequests = [];
	var ConnectionManager = (function() {
		var max_connections = 1;
		var available = 1;
		if(pega.env.ua.ie) {
			if(document.documentMode) {
				max_connections = 5;
			}
		} else if(pega.env.ua.gecko > 2) {
			max_connections = 5;
		} else if(pega.env.ua.webkit > 522) {
			max_connections = 3;
		} else if(pega.env.ua.opera <= 10.50) {
			max_connections = 3;
		} else if(pega.env.ua.opera > 10.50) {
			max_connections = 7;
		}
		available = max_connections;
		return {
			getConnToken : function() {
				if(available > 0) {
					available--;
					return true
				} else {
					return false;
				}
			},
			releaseConnToken : function() {
				available++;
				if(available > max_connections)
					available = max_connections
			},
			setMaxConnections : function(max){
		 		 if(max >= 1 && max <= max_connections){
		  			max_connections = max;
		 		 }
			}
		};
	})();
	var AsyncRequest = (function() {
		var _successHandler  = function(res) {
			pega.ui.statetracking.setAjaxPostBusy("NonBlockingAjax"); 
			nonBlockingAJAXRetryCount = pega.u.d.longPollRetryCount || 0;          
			ResponseProcessor.processResponseBundle(res);
			pega.ui.statetracking.setAjaxPostDone("NonBlockingAjax");
		};
		var _failureHandler = function(res) {
			  if(nonBlockingAJAXRetryCount > 0){
	                nonBlockingAJAXRetryCount--;
                	var localAjaxParams = ajaxParams;
                	setTimeout(function(){
                    /* BUG-423680: START - Initialising correct header content type */
                    pega.util.Connect.initHeader("Content-Type", "application/json;charset=UTF-8");
                    pega.util.Connect.setDefaultPostHeader(false);
                    /* BUG-423680: END */
                    pega.util.Connect.asyncRequest('POST', localAjaxParams['safeUrl'], localAjaxParams['callback'], localAjaxParams['requestString']);
                  }, pega.u.d.longPollRetryTimeout);
	          }else{
					pega.ui.statetracking.setAjaxPostBusy("NonBlockingAjax");
		   			ResponseProcessor.processFailure(res);
					pega.ui.statetracking.setAjaxPostDone("NonBlockingAjax");
              }
		};
		var _callback = {
			scope : this,
			success : _successHandler,
			failure : _failureHandler
		};
		return {
			send : function(requestString, isCancel, pxReqURI){
				var safeUrl = new SafeURL();
				safeUrl.put("pzIsNonBLocking", "true");
        if(pxReqURI) {
          safeUrl.put("pxReqURI", pxReqURI);
        }
				var callback = _callback;
				if(isCancel) {
				   callback = undefined;
				}
			    ajaxParams['safeUrl'] = safeUrl.toURL();
			    ajaxParams['callback'] = callback;
			    ajaxParams['requestString'] = requestString;
			    if(nonBlockingAJAXRetryCount <= 0){
			   		 nonBlockingAJAXRetryCount = pega.u.d.longPollRetryCount || 0;
			   	}
        /* BUG-423680: START - Initialising correct header content type */
        pega.util.Connect.initHeader("Content-Type", "application/json;charset=UTF-8");
        pega.util.Connect.setDefaultPostHeader(false);
        /* BUG-423680: END */
				pega.util.Connect.asyncRequest('POST', safeUrl.toURL(), callback , requestString);	
			}	
		};
		

	})();
	var ServiceQueue = (function() {

		/*Array that serves as the actual storage of service requests*/
		var _storage = new p.tools.Queue();
		var _counter = 1001;

		/*Autogenerates IDs to be stamped on service request when they are inserted into the service queue*/
		var _assignID = function() {
			/* reset counter */
			if (_counter == 99999) { _counter = 1001; }			
			return (new Date()).getTime() + ((_counter++) % 1000);
		};
		/*Informs request dispatcher about the availability of services in the queue awaiting processing*/
		var _notifyDispatcher = function() {
			RequestDispatcher.scheduleDispatch();
		};
		return {
			/* Performs the task of adding requests to the queue */
			add : function(requestArray, pendingRequests) {
				/*TODO:
				 1. Assign Request ID to each element
				 2. Add Request Array Elements to Queue
				 3. Call _notifyDispatcher
				 */
				for(var i = 0; i < requestArray.length; i++) {
					if(!requestArray[i].ID) {
                      if(requestArray[i].data.adp=="D_LongPoll"){/*EPIC-7677*/
                        requestArray[i].ID = requestArray[i].data.activity.subscriptionId;
                      }else{
						requestArray[i].ID = _assignID();
                      }
					}
					try {
					  if(pendingRequests){
						requestArray[i].pendingRequests = pendingRequests;
						pendingRequests.push(requestArray[i].ID);
					  }
					}
					catch(err){}
					_storage.enqueue(requestArray[i]);
				}
				_notifyDispatcher();
			},
			/*Returns the next request in the queue to be processed.
			 When all requests have been processed, returns null*/
			getNextRequest : function() {
				/*TODO:
				 1. Remove next entry from queue.
				 2. Update queue
				 3. Return queue entry
				 */
				if(_storage.isEmpty()) {
					return null;
				} else {
					return _storage.dequeue();
				}
			},
      isEmpty : function() {
        return _storage.isEmpty();
      }
		};
	})();

	var RequestDispatcher = (function() {
		
		var _requestPackage = null;

		/*Update the request bundle*/
		var _updateRequestPackage = function(request) {
			_requestPackage[_requestPackage.length] = request;
		};
		var _executeDataPreProcessor = function(request) {
			if(!request.DataPreProcessor)
				return;
			var preProcessor = request.DataPreProcessor.functions;
			for(var i = 0; i < preProcessor.length; i++) {
				var args = [];
				if(preProcessor[i].args) {
					for(var j = 0; j < preProcessor[i].args.length; j++)
					args.push(preProcessor[i].args[j]);
				}
				args.push(request.data);
				if(preProcessor[i].scope) {
					preProcessor[i].funcRef.apply(preProcessor[i].scope, args);
				} else {
					preProcessor[i].funcRef.apply(null, args);
				}
			}

		};
		/*Dipatch _requestBundle to server*/
		var _dispatch = function() {
			//_requestPackage = {"RequestPackage":_requestPackage}
      if(!_requestPackage) return;
      var _reqURI = null;
      for(var i=0;i<_requestPackage.length;i++){
        if(_requestPackage[i] && _requestPackage[i].data && _requestPackage[i].data.activity){
           _requestPackage[i].data.activity.UITemplatingStatus = "N";
        }
      
        if(_requestPackage[i] && _requestPackage[i].data && _requestPackage[i].data.pxReqURI) {
          if(_reqURI == null) {
            _reqURI = _requestPackage[i].data.pxReqURI;
          } else if (_reqURI != null && _requestPackage[i].data.pxReqURI != _reqURI) {
            /* if all adp request are seding to same thread, then pass pxReqURI */
            _reqURI = "";
          }
          delete _requestPackage[i].data.pxReqURI;
        }
        
        if(_requestPackage[i] && _requestPackage[i].data && typeof (_requestPackage[i].data.isAssociateRequestor) != "undefined") {
          delete _requestPackage[i].data.isAssociateRequestor;
        }
      }
      if(_reqURI === "") { _reqURI = null; }

			var requestString = JSON.stringify(_requestPackage);
			/* BUG-144337: don't send non blocking async request if requestString is null or empty */
			if (!(requestString === "" || requestString === "[]")) {
				AsyncRequest.send(requestString, false, _reqURI);
			} 
			_requestPackage = null;
		};
		/*Put the RequestDispatcher to sleep if connection is not available*/
		var _sleep = function() {
			setTimeout(RequestDispatcher.scheduleDispatch, 1000);
		};
		/*Deep Copy Request*/
		var _deepCopy = function(p, c) {
			var c = c || {};
			for(var i in p) {
				if(i === 'Callbacks' || i === 'DataPreProcessor')
					continue;
				if( typeof p[i] === 'object') {
					c[i] = (p[i].splice) ? [] : {};
					_deepCopy(p[i], c[i]);
				} else
					c[i] = p[i];
			}
			return c;
		};
		/* Deep Copy Request and Delete Callbacks array*/
		var _copyAndDelete = function(request) {
			var copiedObj = _deepCopy(request);
			delete copiedObj.DataPreProcessor;
			delete copiedObj.Callbacks;
			delete copiedObj.pendingRequests;
			delete copiedObj.responsePreProcessor;
			return copiedObj;
		};
		/*Process the service queue*/
		var _processServiceQueue = function() {
			/*TODO:
			 1. Process queue by calling ServiceQueue.getNextRequest()
			 2. Add entry in Callback table and remove from queue
			 3. Update request bundle
			 4. Dispatch after registering ResponseProcessor.processResponseBundle as callback for the AJAX
			 */
			var nextRequest = null;
			_requestPackage = [];
      var _associateRequestorQueue = [];
      var _reqURI = null;
      if(ServiceQueue.isEmpty()) {
        _requestPackage = null;
        ConnectionManager.releaseConnToken();
        return;
      }

			do {
				nextRequest = ServiceQueue.getNextRequest();
				if(nextRequest) {
          var _skipRequestProcess = false;
          if(nextRequest.data && nextRequest.data.pxReqURI) {
            if(_reqURI == null) {
              _reqURI = nextRequest.data.pxReqURI;
            } else if (_reqURI != null && nextRequest.data.pxReqURI != _reqURI) {
              _skipRequestProcess = true;
            }
          }
          if(_skipRequestProcess && nextRequest.data && nextRequest.data.isAssociateRequestor) {
            _associateRequestorQueue.push(nextRequest);
          } else {
            CallbackTable.add(nextRequest.ID, nextRequest);
            /* run pre-processor to update request JSON Data */
            _executeDataPreProcessor(nextRequest);
            _updateRequestPackage(_copyAndDelete(nextRequest));
          }
				}
			} while (nextRequest)
			if(_requestPackage.length > 0)
				_dispatch();
      if(_associateRequestorQueue.length > 0)
        ServiceQueue.add(_associateRequestorQueue);
      _associateRequestorQueue = null;
      _reqURI = null;
		};
		var _getConnectionToken = function() {
			return ConnectionManager.getConnToken();
		};
		return {
			/*If connection is available, call _processServiceQueue, else sleep */
			scheduleDispatch : function() {
				if(_requestPackage == null && _getConnectionToken()) {
					_processServiceQueue();
				} else {
					_sleep();
				}
			},
			sendCancelRequest : function(PendingRequests) {
				/*send cancel ajax */
				var reqArr = [];
				for(var i=0;i<PendingRequests.length;i++) {
					var req = CallbackTable.getRequest(PendingRequests[i]);
					if(req) {
						reqArr.push({"channel":req.channel.substring(0,req.channel.lastIndexOf("/"))+"/cancel", "ID":req.ID, "clientID":req.clientID, "connectionType":req.connectionType});
					}
				}
				if (reqArr.length > 0) {
					var requestString = JSON.stringify(reqArr);
					/* BUG-198002: don't send non blocking async request if requestString is null or empty */
					if (!(requestString === "" || requestString === "[]")) {
						AsyncRequest.send(requestString, true);
					}
				}
			}			
			
		};
	})();

	var getTopWindow = function() {
		var win = window;
		try {
			while(win.parent != win && win.parent.document && win.parent.pega.u.NonBlockingAjax) {
				win = win.parent;
			}
		} catch(e) {
		}
		return win;
	}

	var CallbackTable = (function() {
		/*Map indexed by request ID and holding requests
		 */
		var _callbackTable = new p.tools.Hashtable();

		return {
			/*Adds to requests being sent for processing to callback table*/
			add : function(requestID, request) {
              _callbackTable.put(requestID, request);/*Changes done for PegaCALL EPIC-7677*/
				/*if(!_callbackTable.containsKey(requestID)) {
					_callbackTable.put(requestID, request);
				}*/
			},
			/*Returns request mapped to request ID*/
			getRequest : function(requestID) {
				return _callbackTable.get(requestID);
			},
			/*Removes request from callback table and returns the same*/
			remove : function(requestID) {
				_callbackTable.remove(requestID);
			},
			getAllRequests : function() {
				return _callbackTable.values();
			},
			clear : function() {
				_callbackTable.clear();
			},
			isEmpty : function() {
				return _callbackTable.isEmpty();
			}
		};
	})();

	var ResponseProcessor = (function() {
		var _requeueArray;
		var _reconnectHandlers = {
			"retry" : function(request, response) {
				_requeueArray.push(request);
			},
			"process-partial" : function(request, response) {
				_executeCallbacks(request, response);
				_requeueArray.push(request);
			},
			"none" : function(request, response) {
				_executeCallbacks(request, response);
				_removeFromCallbackTable(request.ID);
				_removeFromPending(request);
			}

		};

		var _adviceHandlers = {
			"reconnect" : _reconnectHandlers
		};

		var _processResponse = function(responseObj) {
			var requestID = responseObj.ID;
			var request = _getFromCallbackTable(requestID);

			/*If Response is pending requeue the request*/
			if(_isResponsePending(responseObj)) {
				_adviceHandlers["reconnect"][responseObj.advice.reconnect](request, responseObj);
				return;
			}
			if(request.responsePreProcessor){
				request.responsePreProcessor.apply(null, [request, responseObj]);
			}
			/*Else remove from callback table and invoke callback */
			_removeFromCallbackTable(requestID);
			_executeCallbacks(request, responseObj);
			_removeFromPending(request);
			if(_PendingRequests && _PendingRequests.length == 0)
				pega.u.d.clearReloadedStatus();

		};
		var _removeFromPending = function(request) {
			try{
				for(var i = 0; i < request.pendingRequests.length; i++) {
					if(request.pendingRequests[i] == request.ID) {
						request.pendingRequests.splice(i, 1);
						break;
					}
				}
			}catch(err){}
		};
		/*returns true/false based on response status*/
		var _isResponsePending = function(response) {
			if(response && response.advice && response.advice.reconnect) {
				return true;
			}
			return false;
		};
		var _requeue = function() {
			if(_requeueArray.length > 0) {
				ServiceQueue.add(_requeueArray);
			}
		};
		var _getFromCallbackTable = function(requestID) {
			return CallbackTable.getRequest(requestID);
		};
		var _removeFromCallbackTable = function(requestID) {
			CallbackTable.remove(requestID);
		};
		var _executeCallbacks = function(request, responseObj) {
			if(!request.Callbacks)
				return;	
			var callbacks = request.Callbacks.functions;
			for(var i = 0; i < callbacks.length; i++) {
				var args = [];
				if(callbacks[i].args) {
					for(var j = 0; j < callbacks[i].args.length; j++)
					args.push(callbacks[i].args[j]);
				}
				args.push(responseObj.data);
				args.push(responseObj.successful);
				if(responseObj.successful == "false")
					args.push(responseObj.error);
				if(callbacks[i].scope) {
					callbacks[i].funcRef.apply(callbacks[i].scope, args);
				} else {
					callbacks[i].funcRef.apply(null, args);
				}
			}

		};
		return {
			/*Callback function for AJAX*/
			processResponseBundle : function(response) {				
				try {
					/*initialize requeue array*/
					_requeueArray = [];
	
					/*Call _processResponse for every response*/
					var responseArray = JSON.parse(response.responseText);
	
					for(var i = 0; i < responseArray.length; i++) {
						_processResponse(responseArray[i]);
					}
	
					/* add requeued requests to Service Queue */
					_requeue();
				} catch(e) {
				  }
				/* release the connection token to Connection Manager*/
				ConnectionManager.releaseConnToken();

			},
			processFailure : function(response) {
				ConnectionManager.releaseConnToken();
			},
			responsePreProcessor : function(request, responseObj){
				
				var currentCT = pega.ui.ChangeTrackerMap.getTrackerByThread(request.data.threadId);
					if(currentCT){
						currentCT.parseForChangeTrackerDiv(responseObj.data.response,false);							
						if(currentCT.changedPropertiesList.length > 0){
							if(typeof updateExpressionTargetsFromList === 'function')
								updateExpressionTargetsFromList(currentCT.changedPropertiesList);
							pega.u.d.evaluateClientConditions('TCL',null,true,true);					
						}
						else if(currentCT.addRemovePagesList.length >0){
							pega.u.d.evaluateClientConditions('TCL',null,false,true);
						}
					}
				
			}
		};
	})();
	
		/*placeholder for wrapper function */
	pega.u.NonBlockingAjax.addRequests = function(requestObjsArray,local,PendingRequestsArr,ResponseProcessorObject) {		
		var PendingRequests = PendingRequestsArr;
		var ResponseProcessorObj = ResponseProcessorObject;
		if(!local) {
			var oWnd = getTopWindow();
			if(!oWnd || oWnd == window) {
				PendingRequests = _PendingRequests;
				ResponseProcessorObj = ResponseProcessor.responsePreProcessor ;
			} else {				
				oWnd.pega.u.NonBlockingAjax.addRequests(requestObjsArray ,true,_PendingRequests,ResponseProcessor.responsePreProcessor );	
				return;			
			}
		}
		if (requestObjsArray && requestObjsArray.length >= 1) {
			/* code for building the RequestArray*/
			var requestArray = new Array();
			for (var reqIdx = 0; reqIdx < requestObjsArray.length; reqIdx++) {
				var requestObj = requestObjsArray[reqIdx];
				var nonBlockingAjaxRequestJSON = {};
				nonBlockingAjaxRequestJSON.ID = "";
				nonBlockingAjaxRequestJSON.clientID = "session";
				nonBlockingAjaxRequestJSON.channel = "/" + requestObj.serviceName + "/" + requestObj.mode;
				nonBlockingAjaxRequestJSON.data = requestObj.data;
				nonBlockingAjaxRequestJSON.DataPreProcessor = requestObj.DataPreProcessor;
				nonBlockingAjaxRequestJSON.Callbacks = requestObj.Callbacks;
				if(requestObj.serviceName == 'adp'){	
					nonBlockingAjaxRequestJSON.responsePreProcessor = ResponseProcessorObj;
				}
				nonBlockingAjaxRequestJSON.connectionType = "long-polling";
				requestArray.push(nonBlockingAjaxRequestJSON);
			}
		    ServiceQueue.add(requestArray, PendingRequests);
		}
	};
	pega.u.NonBlockingAjax.cleanPendingRequests = function(local,PendingRequests) {
		if(local) {
			if(CallbackTable.isEmpty()) {
				return;
			}
			if(PendingRequests.length > 0) {
				RequestDispatcher.sendCancelRequest(PendingRequests);
			}
			for(var i = 0; i < PendingRequests.length; i++){
				CallbackTable.remove(PendingRequests[i].ID);
			}
			return;
		}
		var oWnd = getTopWindow();
		if(!oWnd || oWnd == window) {
			var reqIds = [];
			var reqs = CallbackTable.getAllRequests();
			for(var i = 0; i < reqs.length; i++){
				reqIds.push(reqs[i].ID);
			}
			if(reqIds.length >0) {
				RequestDispatcher.sendCancelRequest(reqIds);
			}
			CallbackTable.clear();
		} else {
			oWnd.pega.u.NonBlockingAjax.cleanPendingRequests(true, _PendingRequests);
			_PendingRequests = [];
		}

	};
	pega.u.NonBlockingAjax.setMaxConnection = function(max) {
		var oWnd = getTopWindow();
		if(!oWnd || oWnd == window) {
			ConnectionManager.setMaxConnections(max);
		} else {
			oWnd.ConnectionManager.setMaxConnections(max);
		}
	};
})(pega);
//static-content-hash-trigger-GCC
//fgnass.github.com/spin.js#v1.2.8
!function(window, document, undefined) {

  /**
   * Copyright (c) 2011 Felix Gnass [fgnass at neteye dot de]
   * Licensed under the MIT license
   */

  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */
    , animations = {} /* Animation rules keyed by their name */
    , useCssAnimations

  /**
   * Utility function to create elements. If no tag name is given,
   * a DIV is created. Optionally properties can be passed.
   */
  function createEl(tag, prop) {
    var el = document.createElement(tag || 'div')
      , n

    for(n in prop) el[n] = prop[n]
    return el
  }

  /**
   * Appends children and returns the parent.
   */
  function ins(parent /* child1, child2, ...*/) {
    for (var i=1, n=arguments.length; i<n; i++)
      parent.appendChild(arguments[i])

    return parent
  }

  /**
   * Insert a new stylesheet to hold the @keyframe or VML rules.
   */
  var sheet = function() {
    var el = createEl('style', {type : 'text/css'})
    ins(document.getElementsByTagName('head')[0], el)
    return el.sheet || el.styleSheet
  }()

  /**
   * Creates an opacity keyframe animation rule and returns its name.
   * Since most mobile Webkits have timing issues with animation-delay,
   * we create separate rules for each line/segment.
   */
  function addAnimation(alpha, trail, i, lines) {
    var name = ['opacity', trail, ~~(alpha*100), i, lines].join('-')
      , start = 0.01 + i/lines*100
      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)
      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()
      , pre = prefix && '-'+prefix+'-' || ''

    if (!animations[name]) {
      sheet.insertRule(
        '@' + pre + 'keyframes ' + name + '{' +
        '0%{opacity:' + z + '}' +
        start + '%{opacity:' + alpha + '}' +
        (start+0.01) + '%{opacity:1}' +
        (start+trail) % 100 + '%{opacity:' + alpha + '}' +
        '100%{opacity:' + z + '}' +
        '}', sheet.cssRules.length)

      animations[name] = 1
    }
    return name
  }

  /**
   * Tries various vendor prefixes and returns the first supported property.
   **/
  function vendor(el, prop) {
    var s = el.style
      , pp
      , i

    if(s[prop] !== undefined) return prop
    prop = prop.charAt(0).toUpperCase() + prop.slice(1)
    for(i=0; i<prefixes.length; i++) {
      pp = prefixes[i]+prop
      if(s[pp] !== undefined) return pp
    }
  }

  /**
   * Sets multiple style properties at once.
   */
  function css(el, prop) {
    for (var n in prop)
      el.style[vendor(el, n)||n] = prop[n]

    return el
  }

  /**
   * Fills in default values.
   */
  function merge(obj) {
    for (var i=1; i < arguments.length; i++) {
      var def = arguments[i]
      for (var n in def)
        if (obj[n] === undefined) obj[n] = def[n]
    }
    return obj
  }

  /**
   * Returns the absolute page-offset of the given element.
   */
  function pos(el) {
    var o = { x:el.offsetLeft, y:el.offsetTop }
    while((el = el.offsetParent))
      o.x+=el.offsetLeft, o.y+=el.offsetTop

    return o
  }

  var defaults = {
    lines: 12,            // The number of lines to draw
    length: 7,            // The length of each line
    width: 5,             // The line thickness
    radius: 10,           // The radius of the inner circle
    rotate: 0,            // Rotation offset
    corners: 1,           // Roundness (0..1)
    color: '#000',        // #rgb or #rrggbb
    speed: 1,             // Rounds per second
    trail: 100,           // Afterglow percentage
    opacity: 1/4,         // Opacity of the lines
    fps: 20,              // Frames per second when using setTimeout()
    zIndex: 2e9,          // Use a high z-index by default
    className: 'spinner', // CSS class to assign to the element
    top: 'auto',          // center vertically
    left: 'auto',         // center horizontally
    position: 'relative'  // element position
  }

  /** The constructor */
  function Spinner(o) {
  /*BUG-176099 added check for IE8*/  
    if(pega.util.Event.isIE === 8 ){
      return { spin : function(){}, stop : function(){}, opacity  : function(){} };
    }
    if (!this.spin) return new Spinner(o)
    this.opts = merge(o || {}, Spinner.defaults, defaults)
  }

  Spinner.defaults = {}

  merge(Spinner.prototype, {
    spin: function(target) {
      this.stop()
      var self = this
        , o = self.opts
        , el = self.el = css(createEl(0, {className: o.className}), {position: o.position, width: 0, zIndex: o.zIndex})
        , mid = o.radius+o.length+o.width
        , ep // element position
        , tp // target position

      if (target) {
        target.insertBefore(el, target.firstChild||null)
        tp = pos(target)
        ep = pos(el)
        css(el, {
          left: (o.left == 'auto' ? tp.x-ep.x + (target.offsetWidth >> 1) : parseInt(o.left, 10) + mid) + 'px',
          top: (o.top == 'auto' ? tp.y-ep.y + (target.offsetHeight >> 1) : parseInt(o.top, 10) + mid)  + 'px'
        })
      }

      el.setAttribute('aria-role', 'progressbar')
      self.lines(el, self.opts)

      if (!useCssAnimations) {
        // No CSS animation support, use setTimeout() instead
        var i = 0
          , fps = o.fps
          , f = fps/o.speed
          , ostep = (1-o.opacity) / (f*o.trail / 100)
          , astep = f/o.lines

        ;(function anim() {
          i++;
          for (var s=o.lines; s; s--) {
            var alpha = Math.max(1-(i+s*astep)%f * ostep, o.opacity)
            self.opacity(el, o.lines-s, alpha, o)
          }
          self.timeout = self.el && setTimeout(anim, ~~(1000/fps))
        })()
      }
      return self
    },

    stop: function() {
      var el = this.el
      if (el) {
        clearTimeout(this.timeout)
        if (el.parentNode) el.parentNode.removeChild(el)
        this.el = undefined
      }
      return this
    },

    lines: function(el, o) {
      var i = 0
        , seg

      function fill(color, shadow) {
        return css(createEl(), {
          position: 'absolute',
          width: (o.length+o.width) + 'px',
          height: o.width + 'px',
          background: color,
          boxShadow: shadow,
          transformOrigin: 'left',
          transform: 'rotate(' + ~~(360/o.lines*i+o.rotate) + 'deg) translate(' + o.radius+'px' +',0)',
          borderRadius: (o.corners * o.width>>1) + 'px'
        })
      }

      for (; i < o.lines; i++) {
        seg = css(createEl(), {
          position: 'absolute',
          top: 1+~(o.width/2) + 'px',
          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
          opacity: o.opacity,
          animation: useCssAnimations && addAnimation(o.opacity, o.trail, i, o.lines) + ' ' + 1/o.speed + 's linear infinite'
        })

        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2+'px'}))

        ins(el, ins(seg, fill(o.color, '0 0 1px rgba(0,0,0,.1)')))
      }
      return el
    },

    opacity: function(el, i, val) {
      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val
    }

  })

  /////////////////////////////////////////////////////////////////////////
  // VML rendering for IE
  /////////////////////////////////////////////////////////////////////////

  /**
   * Check and init VML support
   */
  ;
/*BUG-176099 added check for IE8*/  
if(pega.util.Event.isIE !== 8 ){ 
  (function() {

    function vml(tag, attr) {
      return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr)
    }

    var s = css(createEl('group'), {behavior: 'url(#default#VML)'})

    if (!vendor(s, 'transform') && s.adj) {

      // VML support detected. Insert CSS rule ...
      sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')

      Spinner.prototype.lines = function(el, o) {
        var r = o.length+o.width
          , s = 2*r

        function grp() {
          return css(
            vml('group', {
              coordsize: s + ' ' + s,
              coordorigin: -r + ' ' + -r
            }),
            { width: s, height: s }
          )
        }

        var margin = -(o.width+o.length)*2 + 'px'
          , g = css(grp(), {position: 'absolute', top: margin, left: margin})
          , i

        function seg(i, dx, filter) {
          ins(g,
            ins(css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx}),
              ins(css(vml('roundrect', {arcsize: o.corners}), {
                  width: r,
                  height: o.width,
                  left: o.radius,
                  top: -o.width>>1,
                  filter: filter
                }),
                vml('fill', {color: o.color, opacity: o.opacity}),
                vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change
              )
            )
          )
        }

        if (o.shadow)
          for (i = 1; i <= o.lines; i++)
            seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')

        for (i = 1; i <= o.lines; i++) seg(i)
        return ins(el, g)
      }

      Spinner.prototype.opacity = function(el, i, val, o) {
        var c = el.firstChild
        o = o.shadow && o.lines || 0
        if (c && i+o < c.childNodes.length) {
          c = c.childNodes[i+o]; c = c && c.firstChild; c = c && c.firstChild
          if (c) c.opacity = val
        }
      }
    }
    else
      useCssAnimations = vendor(s, 'animation')
  })()
}

  window.Spinner = Spinner

}(window, document);
//static-content-hash-trigger-GCC
function screenLayoutResize() {
    // If the screen layout is being transitioned into place then return
    // this allows the tansitions to end before calling this function
    // this function will be called from pzDesignerStudioWindowLoad.js when transition finishes
    if ($(".screen-layout").hasClass("load-transition")) {
        return false;
    }
  
    //US-121795 sets click functions for toggle and screen layout mask
    // passes private API to appview
    registerScreenLayoutWithAppView();
  
    var origLeftWidth = $(".screen-layout-region-main-sidebar1").outerWidth();
    var origRightWidth = $(".screen-layout-region-main-sidebar2").outerWidth();
    var collisionOffset = 100;
    var isRTL = pega.u.d.isOrientationRTL();

    // Return true if the sidebar is fixed.
    // This only happens when the media query is active
    // sidebar: A jquery object, usually $( ".screen-layout-region-main-sidebar1" ) or $( ".screen-layout-region-main-sidebar2" ).
    function isSidebarFixed(sidebar) {
        // Check if sidebar is fixed
        return "absolute" == sidebar.css("position");
    }
    function removeVisibilityAside(className){
      $(className).css("display","block");
    }
    function resizeHeader(el) {
        var ey = el.outerHeight();
        
        if($(el).parents(".screen-layout").hasClass("flex")) {
            var footerHeight, separatorHeight, heightToBeSubtracted;
            var clientHeight = $(".screen-layout").height();
            footerHeight = $("footer.screen-layout-region-footer").outerHeight() || 0;
            separatorHeight = $(el).find("#sidebar-collapse-header").outerHeight() || 0;
            heightToBeSubtracted = ey + footerHeight;
        
            $('.screen-layout-region-main-middle, .screen-layout-region-main-sidebar1, .screen-layout-region-main-sidebar2, #sidebar-collapse-left, #sidebar-collapse-right').css({ 'height': (clientHeight - heightToBeSubtracted) + 'px' });
            $("#sidebar-collapse-header").css({ 'top': (ey - separatorHeight) + 'px' });
            $("#sidebar-collapse-left, #sidebar-collapse-right").css({ 'top': ey + 'px' });
            
            footerHeight ? $("footer.screen-layout-region-footer").css("z-index", 0) : 1;
        }   
        else {
            $(".screen-layout-region-main-middle").css({
                'top': ey
            });

            if (isSidebarFixed($(".screen-layout-region-main-sidebar1"))) {
                $(".screen-layout-region-main-sidebar2").css({
                    'top': ey
                });
                $(".screen-layout-region-main-sidebar1").css({
                    'top': ey
                });
            }
        }
    }

    function resizeFooter(el) {
        var ey = el.outerHeight();
      
        if($(el).parents(".screen-layout").hasClass("flex")) {
            var headerHeight, separatorHeight, heightToBeSubtracted;
            var clientHeight = $(".screen-layout").height();
            headerHeight = $("header.screen-layout-region-header").outerHeight() || 0;
            separatorHeight = $(el).find("#sidebar-collapse-footer").outerHeight() || 0;
            heightToBeSubtracted = ey + headerHeight;
        
            $('.screen-layout-region-main-middle, .screen-layout-region-main-sidebar1, .screen-layout-region-main-sidebar2, #sidebar-collapse-left, #sidebar-collapse-right').css({ 'height': (clientHeight - heightToBeSubtracted) + 'px' });
            $("#sidebar-collapse-footer").css({ 'bottom': (ey - separatorHeight) + 'px' });
            $("#sidebar-collapse-left, #sidebar-collapse-right").css({ 'bottom': ey + 'px' });
            $(el).css("z-index", 0);
        }   
        else {
            el.css({
                'bottom': '0',
                'top': ''
            });

            $(".screen-layout-region-main-middle").css({
                'bottom': ey
            });

            if (isSidebarFixed($(".screen-layout-region-main-sidebar1"))) {
                $(".screen-layout-region-main-sidebar2").css({
                    'bottom': ey
                });
                $(".screen-layout-region-main-sidebar1").css({
                    'bottom': ey
                });
            }
        }
    }


    function resizeLeft(el) {
        var ex = el.outerWidth();
      
        if($(el).parents(".screen-layout").hasClass("flex")) {
            var separatorWidth, rightWidth, widthToBeSubtracted, liveUISidebarWidth;
            liveUISidebarWidth = $('.runtime-control-panel.showing.runtime-control-panel-active').outerWidth() || 0;
            var clientWidth = $(".screen-layout").width();
            rightWidth = $(".screen-layout-region-main-sidebar2").outerWidth() || 0;
            separatorWidth = $(el).find("#sidebar-collapse-left").outerWidth() || 0;
            widthToBeSubtracted = ex + rightWidth + liveUISidebarWidth;
        
            $('.screen-layout-region-main-middle').css({ 'width': (clientWidth - widthToBeSubtracted) + 'px' });
            $("#sidebar-collapse-left").css({ 'left': (ex - separatorWidth) + 'px' });
       }
       else{
          var count = parseInt(ex) - parseInt(origLeftWidth);
          count += "px";

          if (!isSidebarFixed($(".screen-layout-region-main-sidebar1"))) {
              if (isRTL) {
                  $(".screen-layout-region-header").css({
                      'right': count
                  }, "fast");;
                  $(".screen-layout-region-footer").css({
                      'right': count
                  }, "fast");
                  $(".screen-layout-region-main-middle").css({
                      'right': count
                  }, "fast");
              } else {
                  $(".screen-layout-region-header").css({
                      'left': count
                  }, "fast");;
                  $(".screen-layout-region-footer").css({
                      'left': count
                  }, "fast");
                  $(".screen-layout-region-main-middle").css({
                      'left': count
                  }, "fast");
              }
          } else {
              if (isRTL) {
                  $(".screen-layout-region-main-middle").css({
                      'right': ex
                  }, "fast");
              } else {
                  $(".screen-layout-region-main-middle").css({
                      'left': ex
                  }, "fast");
              }
          }
       }
    }

    function resizeRight(el) {
        var ex = el.outerWidth();
      
        if($(el).parents(".screen-layout").hasClass("flex")) {
            var separatorWidth, leftWidth, widthToBeSubtracted, liveUISidebarWidth;
            liveUISidebarWidth = $('.runtime-control-panel.showing.runtime-control-panel-active').outerWidth() || 0;
            var clientWidth = $(".screen-layout").width();
            leftWidth = $(".screen-layout-region-main-sidebar1").outerWidth() || 0;
            separatorWidth = $(el).find("#sidebar-collapse-right").outerWidth() || 0;
            widthToBeSubtracted = ex + leftWidth + liveUISidebarWidth;

            $('.screen-layout-region-main-middle').css({ 'width': (clientWidth - widthToBeSubtracted) + 'px' });    
            $("#sidebar-collapse-right").css({ 'right': (ex - separatorWidth) + 'px' });
        }
        else{
            if (isRTL) {
              el.css({
                'left': '0',
                'right': ''
              });
            } else {
              el.css({
                'right': '0',
                'left': ''
              });
            }

            var count = parseInt(ex) - parseInt(origRightWidth);
            count += "px";

            if (!isSidebarFixed($(".screen-layout-region-main-sidebar2"))) {
                if (isRTL) {
                    $(".screen-layout-region-header").css({
                        'right': count
                    });
                    $(".screen-layout-region-footer").css({
                        'right': count
                    });
                    $(".screen-layout-region-main-middle").css({
                        'right': count
                    });
                } else {
                    $(".screen-layout-region-header").css({
                        'left': count
                    });
                    $(".screen-layout-region-footer").css({
                        'left': count
                    });
                    $(".screen-layout-region-main-middle").css({
                        'left': count
                    });
                }
            } else
            if (isRTL) {
                $(".screen-layout-region-main-middle").css({
                    'left': ex
                });
            } else {
                $(".screen-layout-region-main-middle").css({
                    'right': ex
                });
            }
        }
    }


    if ($(".screen-layout-region-header").hasClass("screen-layout-region-resize")) {
        $(".screen-layout-region-header").resizable({
            minHeight: parseInt($("#sidebar-collapse-header").outerHeight())
        }, {
            handles: {
                's': $('#sidebar-collapse-header')
            },
            resize: function(event, ui) {
                $('#sidebar-collapse-header').addClass('noclick');

                var el = $(this);
                var ey = el.outerHeight();

                /* Update Collapsed class */
                var collapseWrapper = $("#sidebar-collapse-header");
                if (collapseWrapper.hasClass("collapsed") && ey > parseInt($("#sidebar-collapse-header").outerHeight())) {
                    collapseWrapper.removeClass("collapsed");
                } else if (!collapseWrapper.hasClass("collapsed") && ey == parseInt($("#sidebar-collapse-header").outerHeight())) {
                    collapseWrapper.addClass("collapsed");
                }

                /* Check for collision */
                var footerHeight = parseInt($(".screen-layout-region-footer").outerHeight());
                if (!parseInt(footerHeight))
                    footerHeight = 0;
                if (parseInt(ey) + footerHeight > parseInt($(".screen-layout").outerHeight() - collisionOffset)) {
                    $(this).outerHeight(parseInt($(".screen-layout").outerHeight() - collisionOffset - footerHeight));
                    $(this).resizable('widget').trigger('mouseup');
                }
                resizeHeader(el);
            },
            start: function(event, ui) {
                if (document.all) {
                    $(".dynamicContainer").css('z-index', '-1');
                    $(".dynamicContainer > iframe").css('z-index', '-1');
                    $(".dc-main").css('z-index', '-1');
                    $(".dc-main > iframe").css('z-index', '-1');
                } else {
                    $(".dynamicContainer").css('pointer-events', 'none');
                    $(".dynamicContainer > iframe").css('pointer-events', 'none');
                    $(".dc-main").css('pointer-events', 'none');
                    $(".dc-main > iframe").css('pointer-events', 'none');
                }
            },
            stop: function(event, ui) {
                if (document.all) {
                    $(".dynamicContainer > iframe").css('z-index', '');
                    $(".dynamicContainer").css('z-index', '');
                    $(".dc-main > iframe").css('z-index', '');
                    $(".dc-main").css('z-index', '');
                } else {
                    $(".dynamicContainer > iframe").css('pointer-events', 'auto');
                    $(".dynamicContainer").css('pointer-events', 'auto');
                    $(".dc-main > iframe").css('pointer-events', 'auto');
                    $(".dc-main").css('pointer-events', 'auto');
                }
            }
        });


        $(".screen-layout-region-header").css({
            'overflow': 'hidden'
        });
        $("#sidebar-collapse-header").click(function() {
            var collapseWrapper = $("#sidebar-collapse-header");
            if ($(this).hasClass('noclick') && !collapseWrapper.hasClass("collapsed")) {
                $(this).removeClass('noclick');
            } else {
                var ey;
                if (collapseWrapper.hasClass("collapsed")) {
                    ey = origLeftWidth;
                    collapseWrapper.removeClass("collapsed");
                } else {
                    ey = parseInt($("#sidebar-collapse-header").outerHeight());
                    collapseWrapper.addClass("collapsed");
                }
                $(".screen-layout-region-header").animate({
                    'height': ey
                }, "fast");
             
               //onclick on seperator div 
               if($("#sidebar-collapse-header").parents(".screen-layout").hasClass("flex")) {
                   var footerheight, heightToBeSubtracted, separatorHeight;
                   var clientHeight = $(".screen-layout").height();
                   separatorHeight = $("#sidebar-collapse-header").outerHeight();
                   footerheight = $("footer.screen-layout-region-footer").outerHeight() || 0;
                   heightToBeSubtracted = ey + footerheight;
             
                   $('.screen-layout-region-main-middle, .screen-layout-region-main-sidebar1, .screen-layout-region-main-sidebar2, #sidebar-collapse-left, #sidebar-collapse-right').animate({ 'height': (clientHeight - heightToBeSubtracted) + 'px' }, { duration: 200, queue: false });
                   $("#sidebar-collapse-header").animate({ 'top': (ey - separatorHeight) + 'px' }, { duration: 200, queue: false });
                   $("#sidebar-collapse-left, #sidebar-collapse-right").animate({ 'top': ey + 'px' }, { duration: 200, queue: false });
               }
                else{   
                    $(".screen-layout-region-main-middle").animate({
                        'top': ey
                    }, "fast");
                    if (isSidebarFixed($(".screen-layout-region-main-sidebar1"))) {
                        $(".screen-layout-region-main-sidebar2").animate({
                            'top': ey
                        }, "fast");
                        $(".screen-layout-region-main-sidebar1").animate({
                            'top': ey
                        }, "fast");
                    }
                }
            }
        });
    }

    if ($(".screen-layout-region-main-sidebar1").hasClass("screen-layout-region-resize")) {
        $(".screen-layout-region-main-sidebar1").resizable({
            minWidth: parseInt($("#sidebar-collapse-left").outerWidth())
        }, {
            handles: {
                'e': $('#sidebar-collapse-left')
            },
            resize: function(event, ui) {
                $('#sidebar-collapse-left').addClass('noclick');
                if (origLeftWidth == 0) {
                    origLeftWidth = $(".screen-layout-region-main-sidebar1").outerWidth();
                }
                var el = $(this);
                var ex = el.outerWidth();

                /* Update Collapsed class */
                var collapseWrapper = $("#sidebar-collapse-left");
                if (collapseWrapper.hasClass("collapsed") && ex > parseInt($("#sidebar-collapse-left").outerWidth())) {
                    collapseWrapper.removeClass("collapsed");
                } else if (!collapseWrapper.hasClass("collapsed") && ex == parseInt($("#sidebar-collapse-left").outerWidth())) {
                    collapseWrapper.addClass("collapsed");
                }

                /* Check for collision */
                var sidebar2Width = parseInt($(".screen-layout-region-main-sidebar2").outerWidth());
                if (!parseInt(sidebar2Width))
                    sidebar2Width = 0;
                if (parseInt(ex) + sidebar2Width > parseInt($(".screen-layout").outerWidth() - collisionOffset)) {
                    $(this).outerWidth(parseInt($(".screen-layout").outerWidth() - collisionOffset - sidebar2Width));
                    $(this).resizable('widget').trigger('mouseup');
                }
                resizeLeft(el);
            },
            start: function(event, ui) {
                if (document.all) {
                    $(".dynamicContainer").css('z-index', '-1');
                    $(".dynamicContainer > iframe").css('z-index', '-1');
                    $(".dc-main").css('z-index', '-1');
                    $(".dc-main > iframe").css('z-index', '-1');
                } else {
                    $(".dynamicContainer").css('pointer-events', 'none');
                    $(".dynamicContainer > iframe").css('pointer-events', 'none');
                    $(".dc-main").css('pointer-events', 'none');
                    $(".dc-main > iframe").css('pointer-events', 'none');
                }
            },
            stop: function(event, ui) {
                if (document.all) {
                    $(".dynamicContainer > iframe").css('z-index', '');
                    $(".dynamicContainer").css('z-index', '');
                    $(".dc-main > iframe").css('z-index', '');
                    $(".dc-main").css('z-index', '');
                } else {
                    $(".dynamicContainer > iframe").css('pointer-events', 'auto');
                    $(".dynamicContainer").css('pointer-events', 'auto');
                    $(".dc-main > iframe").css('pointer-events', 'auto');
                    $(".dc-main").css('pointer-events', 'auto');
                }
            }
        });

        $("#sidebar-collapse-left").click(function(event) {
            var sidebar1 = $(".screen-layout-region-main-sidebar1");
            var collapseWrapper = $("#sidebar-collapse-left");
            if (origLeftWidth == 0) {
                origLeftWidth = sidebar1.outerWidth();
            }
            if ($(this).hasClass('noclick') && !collapseWrapper.hasClass("collapsed")) {
                $(this).removeClass('noclick');
                event.stopImmediatePropagation();
            } else {

                var ex;
                var count;
                var leftContentDiv = sidebar1.find(".screen-layout-region-content");
                if (collapseWrapper.hasClass("collapsed")) {
                    ex = origLeftWidth;
                    count = origLeftWidth;
                    collapseWrapper.removeClass("collapsed");
                    if (leftContentDiv) {
                      leftContentDiv.removeClass("hide");
                    }
                } else {
                    ex = parseInt($("#sidebar-collapse-left").outerWidth());
                    collapseWrapper.addClass("collapsed");
                    var currWidth = $(".screen-layout-region-main-sidebar1").outerWidth();
                    count = parseInt(currWidth) - parseInt(origLeftWidth);
                    count = parseInt(count) + parseInt(ex) - parseInt(currWidth);
                    if (leftContentDiv) {
                      leftContentDiv.addClass("hide");
                    }
                }
                /* BUG-492043 */
                if($(collapseWrapper).hasClass("collapsed")){
                  sidebar1.attr("data-expanded","false");  
                }else{
                  sidebar1.attr("data-expanded","true");
                }
                sidebar1.animate({
                    'width': ex
                }, "fast",function(){
                     if(sidebar1.attr("data-expanded") === "false")
                       removeVisibilityAside(".screen-layout-region-main-sidebar1");
                   });
                    
                 //onclick on seperator div flex
                if($("#sidebar-collapse-left").parents(".screen-layout").hasClass("flex")) {
                     var rightWidth, widthToBeSubtracted, separatorWidth, liveUISidebarWidth;
                     liveUISidebarWidth = $('.runtime-control-panel.showing.runtime-control-panel-active').outerWidth() || 0;
                     var clientWidth = $(".screen-layout").width();
                     separatorWidth = $("#sidebar-collapse-left").outerWidth();
                     rightWidth = $("aside.screen-layout-region-main-sidebar2").outerWidth() || 0;
                     widthToBeSubtracted = ex + rightWidth + liveUISidebarWidth;
                     $('.screen-layout-region-main-middle').animate({ 'width': (clientWidth - widthToBeSubtracted) + 'px'}, "fast");
                     $("#sidebar-collapse-left").animate({ 'left': (ex - separatorWidth) + 'px' },"fast");
                }
                else{
                    if (!isSidebarFixed(sidebar1)) {
                        $(".screen-layout-region-main-middle").animate({
                            'left': count
                        }, "fast");
                    } else {
                        // This has been added to counterfeit the special IE 'flexResize' handling done in pzpega_ui_doc_lifecycle module,
                        // to avoid UI flickering issues upon leftnav collapse. BUG-309193

                        if (window.navigator.userAgent.indexOf('Trident/') > 0) { //if IE

                          var activeDCIframe = $('.dc-main .dynamicContainer:visible > iframe')[0];

                          // get active(visible) DC iframe in the document
                          if (activeDCIframe) { 
                            $(activeDCIframe.contentDocument).find('.harnessContent #harness-container').css('width', '');
                          }

                        }

                        //BUG-223746 fix
                        if (isRTL) {
                            $(".screen-layout-region-main-middle").animate({
                                'right': ex
                            }, "fast");
                        } else {
                            $(".screen-layout-region-main-middle").animate({
                                'left': ex
                            }, "fast");
                        }
                    }
                  }
            }
        });
    }

    if ($(".screen-layout-region-main-sidebar2").hasClass("screen-layout-region-resize")) {
        $(".screen-layout-region-main-sidebar2").resizable({
            minWidth: parseInt($("#sidebar-collapse-right").outerWidth())
        }, {
            handles: {
                'w': $('#sidebar-collapse-right')
            },
            resize: function(event, ui) {
                $('#sidebar-collapse-right').addClass('noclick');
                if (origRightWidth == 0) {
                    origRightWidth = $(".screen-layout-region-main-sidebar2").outerWidth();
                }
                var el = $(this);
                var ex = el.outerWidth();

                /* Update Collapsed class */
                var collapseWrapper = $("#sidebar-collapse-right");
                if (collapseWrapper.hasClass("collapsed") && ex > parseInt($("#sidebar-collapse-right").outerWidth())) {
                    collapseWrapper.removeClass("collapsed");
                } else if (!collapseWrapper.hasClass("collapsed") && ex == parseInt($("#sidebar-collapse-right").outerWidth())) {
                    collapseWrapper.addClass("collapsed");
                }

                /* Check for collision */
                var sidebar1Width = parseInt($(".screen-layout-region-main-sidebar1").outerWidth());
                if (!parseInt(sidebar1Width))
                    sidebar1Width = 0;
                if (parseInt(ex) + sidebar1Width > parseInt($(".screen-layout").outerWidth() - collisionOffset)) {
                    $(this).outerWidth(parseInt($(".screen-layout").outerWidth() - collisionOffset - sidebar1Width));
                    $(this).resizable('widget').trigger('mouseup');
                }
                resizeRight(el);
            },
            start: function(event, ui) {
                if (document.all) {
                    $(".dynamicContainer").css('z-index', '-1');
                    $(".dynamicContainer > iframe").css('z-index', '-1');
                    $(".dc-main").css('z-index', '-1');
                    $(".dc-main > iframe").css('z-index', '-1');
                } else {
                    $(".dynamicContainer").css('pointer-events', 'none');
                    $(".dynamicContainer > iframe").css('pointer-events', 'none');
                    $(".dc-main").css('pointer-events', 'none');
                    $(".dc-main > iframe").css('pointer-events', 'none');
                }
            },
            stop: function(event, ui) {
                if (document.all) {
                    $(".dynamicContainer > iframe").css('z-index', '');
                    $(".dynamicContainer").css('z-index', '');
                    $(".dc-main > iframe").css('z-index', '');
                    $(".dc-main").css('z-index', '');
                } else {
                    $(".dynamicContainer > iframe").css('pointer-events', 'auto');
                    $(".dynamicContainer").css('pointer-events', 'auto');
                    $(".dc-main > iframe").css('pointer-events', 'auto');
                    $(".dc-main").css('pointer-events', 'auto');
                }
            }
        });


        $("#sidebar-collapse-right").click(function() {
            var sidebar2 = $(".screen-layout-region-main-sidebar2");
            var collapseWrapper = $("#sidebar-collapse-right");
            if (origRightWidth == 0) {
                origRightWidth = sidebar2.outerWidth();
            }
            if ($(this).hasClass('noclick') && !collapseWrapper.hasClass("collapsed")) {
                $(this).removeClass('noclick');
            } else {
                var ex;
                var iscollapsed = null;
                if (collapseWrapper.hasClass("collapsed")) {
                    ex = origRightWidth;
                    collapseWrapper.removeClass("collapsed");
                    iscollapsed = false;
                } else {
                    ex = parseInt($("#sidebar-collapse-right").outerWidth());
                    collapseWrapper.addClass("collapsed");
                    iscollapsed = true;
                }
                var currWidth = $(".screen-layout-region-main-sidebar2").outerWidth();
                var count = parseInt(currWidth) - parseInt(origRightWidth);
                count = parseInt(count) + parseInt(ex) - parseInt(currWidth);
                /* BUG-492043 */
                if(iscollapsed){
                 sidebar2.attr("data-expanded","false");  
                }else{
                 sidebar2.attr("data-expanded","true");
                }
                sidebar2.animate({
                    'width': ex
                }, "fast",function(){
                     if(sidebar2.attr("data-expanded") === "false" && iscollapsed)
                       removeVisibilityAside(".screen-layout-region-main-sidebar2");
                   });
              
                if($("#sidebar-collapse-right").parents(".screen-layout").hasClass("flex")) {
                   var leftWidth, widthToBeSubtracted, separatorWidth, liveUISidebarWidth;
                   liveUISidebarWidth = $('.runtime-control-panel.showing.runtime-control-panel-active').outerWidth() || 0;
                   var clientWidth = $(".screen-layout").width();
                   separatorWidth = $("#sidebar-collapse-right").outerWidth();
                   leftWidth = $("aside.screen-layout-region-main-sidebar1").outerWidth() || 0;
                   widthToBeSubtracted = ex + leftWidth + liveUISidebarWidth;
                  
                   $('.screen-layout-region-main-middle').animate({ 'width': (clientWidth - widthToBeSubtracted) + 'px'}, "fast");
                   $("#sidebar-collapse-right").animate({ 'right': (ex - separatorWidth) + 'px' },"fast");
                }
                else {
                  if (!isSidebarFixed(sidebar2)) {
                      $(".screen-layout-region-main-middle").animate({
                          'right': count
                      }, "fast");
                  } else {
                      if (isRTL) {
                          $(".screen-layout-region-main-middle").animate({
                              'left': ex
                          }, "fast");
                          ex = 0;
                      }

                      $(".screen-layout-region-main-middle").animate({
                          'right': ex
                      }, "fast");
                  }
               }    
            }
        });
    }
    
    if ($(".screen-layout-region-footer").hasClass("screen-layout-region-resize")) {
        $(".screen-layout-region-footer").resizable({
            minHeight: parseInt($("#sidebar-collapse-footer").outerHeight())
        }, {
            handles: {
                'n': $('#sidebar-collapse-footer')
            },
            resize: function(event, ui) {
                $('#sidebar-collapse-footer').addClass('noclick');

                var el = $(this);
                var ey = el.outerHeight();

                /* Update Collapsed class */
                var collapseWrapper = $("#sidebar-collapse-footer");
                if (collapseWrapper.hasClass("collapsed") && ey > parseInt($("#sidebar-collapse-footer").outerHeight())) {
                    collapseWrapper.removeClass("collapsed");
                } else if (!collapseWrapper.hasClass("collapsed") && ey == parseInt($("#sidebar-collapse-footer").outerHeight())) {
                    collapseWrapper.addClass("collapsed");
                }

                /* Check for collision */
                var headerHeight = parseInt($(".screen-layout-region-header").outerHeight());
                if (!parseInt(headerHeight))
                    headerHeight = 0;
                if (parseInt(ey) + headerHeight > parseInt($(".screen-layout").outerHeight() - collisionOffset)) {
                    $(this).outerHeight(parseInt($(".screen-layout").outerHeight() - collisionOffset - headerHeight));
                    $(this).resizable('widget').trigger('mouseup');
                }
                resizeFooter(el);
            },
            start: function(event, ui) {
                if (document.all) {
                    $(".dynamicContainer").css('z-index', '-1');
                    $(".dynamicContainer > iframe").css('z-index', '-1');
                    $(".dc-main").css('z-index', '-1');
                    $(".dc-main > iframe").css('z-index', '-1');
                } else {
                    $(".dynamicContainer").css('pointer-events', 'none');
                    $(".dynamicContainer > iframe").css('pointer-events', 'none');
                    $(".dc-main").css('pointer-events', 'none');
                    $(".dc-main > iframe").css('pointer-events', 'none');
                }
            },
            stop: function(event, ui) {
                if (document.all) {
                    $(".dynamicContainer > iframe").css('z-index', '');
                    $(".dynamicContainer").css('z-index', '');
                    $(".dc-main > iframe").css('z-index', '');
                    $(".dc-main").css('z-index', '');
                } else {
                    $(".dynamicContainer > iframe").css('pointer-events', 'auto');
                    $(".dynamicContainer").css('pointer-events', 'auto');
                    $(".dc-main > iframe").css('pointer-events', 'auto');
                    $(".dc-main").css('pointer-events', 'auto');
                }
            }
        });


        $("#sidebar-collapse-footer").click(function() {
            var collapseWrapper = $("#sidebar-collapse-footer");
            if ($(this).hasClass('noclick') && !collapseWrapper.hasClass("collapsed")) {
                $(this).removeClass('noclick');
            } else {
                var ey;
                if (collapseWrapper.hasClass("collapsed")) {
                    ey = origLeftWidth;
                    collapseWrapper.removeClass("collapsed");
                } else {
                    ey = parseInt($("#sidebar-collapse-footer").outerHeight());
                    collapseWrapper.addClass("collapsed");
                }
                $(".screen-layout-region-footer").animate({
                    'height': ey
                }, "fast");
                
                
               //onclick on seperator div flex 
               if($("#sidebar-collapse-footer").parents(".screen-layout").hasClass("flex")) {
                   var headerheight, heightToBeSubtracted, separatorHeight;
                   var clientHeight = $(".screen-layout").height();
                   separatorHeight = $("#sidebar-collapse-footer").outerHeight();
                   headerheight = $("header.screen-layout-region-header").outerHeight() || 0;
                   heightToBeSubtracted = ey + headerheight;
                 
                   $('.screen-layout-region-main-middle, .screen-layout-region-main-sidebar1, .screen-layout-region-main-sidebar2, #sidebar-collapse-left, #sidebar-collapse-right').animate({ 'height': (clientHeight - heightToBeSubtracted) + 'px' }, { duration: 200, queue: false });
                   $("#sidebar-collapse-footer").animate({ 'bottom': (ey - separatorHeight) + 'px' }, { duration: 200, queue: false });
                   $("#sidebar-collapse-left, #sidebar-collapse-right").animate({ 'bottom': ey + 'px' }, { duration: 200, queue: false });   
                }
                else{
                    $(".screen-layout-region-main-middle").animate({
                        'bottom': ey
                    }, "fast");
                    if (isSidebarFixed($(".screen-layout-region-main-sidebar1"))) {
                        $(".screen-layout-region-main-sidebar2").animate({
                            'bottom': ey
                        }, "fast");
                        $(".screen-layout-region-main-sidebar1").animate({
                            'bottom': ey
                        }, "fast");
                    }
                }
             }
        });
    }
    if($("#sidebar-region-one").attr('data-expanded') === 'false'&& !$('#sidebar-collapse-left').hasClass("collaapsed")){
        $('#sidebar-collapse-left').click();
      //toggleCollapseLeftPanel();
    }
    if($("#sidebar-region-two").attr('data-expanded') === 'false' && !$('#sidebar-collapse-right').hasClass("collaapsed")){
        $('#sidebar-collapse-right').click();
      //toggleCollapseRightPanel();
    }
    $(window).resize(function(e, data) {
        pega.ui.screenLayout.resizeScreenLayout();
    });
};

/**
 * @public Loops over all the panels in a screenlayout and clears the inline styles applied to them
 **/
function resetScreenLayoutInlineStyles() {
    // Get a handle on all children in the screen layout
    var panels = document.querySelectorAll(".screen-layout > *");

    // Loop over all the children and remove all inline styles
    for (var i = 0; i < panels.length; i++) {
        panels[i].style.removeProperty("top");
        panels[i].style.removeProperty("bottom");
        panels[i].style.removeProperty("left");
        panels[i].style.removeProperty("right");
        panels[i].style.removeProperty("width");
    }
}

/**
 * Function searches for a screen layout element and returns it. Figures out if the element should be found in
 * the desktopWindow or not.
 *
 * @param $String$ selector - The selector to search for
 * @return $Element$ jQuery element to return
 */
function _getScreenLayoutElement(selector) {
    // Get a handle on the desktopWindow
    var desktopWindow = pega.desktop.support.getDesktopWindow();
    var tempElement = null;

    if (window != desktopWindow && !window.opener) { // When not a desktopWindow and not a pop up                                
        tempElement = $(selector, desktopWindow.document);
    } else { // Everything else use self
        tempElement = $(selector);
    }

    // Return element
    return tempElement;
}

function toggleCollapseLeftPanel() {
    var collapseWrapper = _getScreenLayoutElement("#sidebar-collapse-left");

    // Trigger a click on the mask to minimize screen layout and clear mask
    collapseWrapper.trigger('click');
};

/*Right panel APIs*/
function toggleCollapseRightPanel() {
    var collapseWrapper = _getScreenLayoutElement("#sidebar-collapse-right");

    // Trigger a click on the mask to minimize screen layout and clear mask
    collapseWrapper.trigger('click');
};

function collapsePanel(panelLoc) {
    var panelID;
    if (panelLoc.toUpperCase() == "LEFT") {
        panelID = "#sidebar-collapse-left";
    } else if (panelLoc.toUpperCase() == "RIGHT") {
        panelID = "#sidebar-collapse-right";
    } else if (panelLoc.toUpperCase() == "HEADER") {
        panelID = "#sidebar-collapse-header";
    } else if (panelLoc.toUpperCase() == "FOOTER") {
        panelID = "#sidebar-collapse-footer";
    } else {
        panelID = panelLoc;
    }

    // Get a handle on the element
    var collapseWrapper = _getScreenLayoutElement(panelID);

    if (!collapseWrapper.hasClass("collapsed")) {
        collapseWrapper.trigger('click');
    }
};

function expandPanel(panelLoc) {
    var panelID;
    if (panelLoc.toUpperCase() == "LEFT") {
        panelID = "#sidebar-collapse-left";
    } else if (panelLoc.toUpperCase() == "RIGHT") {
        panelID = "#sidebar-collapse-right";
    } else if (panelLoc.toUpperCase() == "HEADER") {
        panelID = "#sidebar-collapse-header";
    } else if (panelLoc.toUpperCase() == "FOOTER") {
        panelID = "#sidebar-collapse-footer";
    } else {
        panelID = panelLoc;
    }

    // Get a handle on the element
    var collapseWrapper = _getScreenLayoutElement(panelID);

    if (collapseWrapper.hasClass("collapsed")) {
        collapseWrapper.trigger('click');
    }
};

//END COLLAPSIBLE


//US-121795 moved click registration into pzpega_ui_appview
function removeScreenLayoutMask() {
    pega.ui.appview.hideRegion(pega.ui.appview.REGION_LEFT);
    pega.ui.appview.hideRegion(pega.ui.appview.REGION_RIGHT);
};
function showScreenLayoutLeftSidebar() {
    pega.ui.appview.showRegion(pega.ui.appview.REGION_LEFT);
};
function showScreenLayoutRightSidebar() {
    pega.ui.appview.showRegion(pega.ui.appview.REGION_RIGHT);
}
function toggleLeftSidebar() {
    pega.ui.appview.showRegion(pega.ui.appview.REGION_LEFT);
};
function toggleRightSidebar() {
    pega.ui.appview.showRegion(pega.ui.appview.REGION_RIGHT);
};


//privately shares screen layout methods with pega.ui.appview
function registerScreenLayoutWithAppView() {
  
    //define any private variables here...
  
    //pass private API along here...
    pega.ui.appview.onScreenLayoutLoad({
        "showPanel": function(panel) { 
            //determine which panel will be shown and how to reveal it.
            if ($(".screen-layout").hasClass("screen-layout-icon_toolbar")) {
                //Animate slide up for icon bar
                $(".screen-layout").addClass("icon-bar-slideup");
            } else if (panel == pega.ui.appview.REGION_RIGHT) {
                //Animate in right sidebar
                //$('.ie .screen-layout-region-main-sidebar2').css({ 'width': origRightWidth + 'px!important' });
                var toggleTwoNav = document.getElementById("appview-nav-toggle-two");
                if(toggleTwoNav) {
                  toggleTwoNav.setAttribute("aria-expanded", true);
                }
                $(".screen-layout").addClass("screen-layout-expanded-s2");
                $(".screen-layout").addClass("screen-layout-expanded-s2-animate");
            } else {
                //Animate in left sidebar (most common)
                //$('.ie .screen-layout-region-main-sidebar1').css({ 'width': origLeftWidth + 'px!important' });
                var toggleOneNav = document.getElementById("appview-nav-toggle-one");
                if(toggleOneNav) {
                  toggleOneNav.setAttribute("aria-expanded", true);
                }               
                $(".screen-layout").addClass("screen-layout-expanded-s1");
                $(".screen-layout").addClass("screen-layout-expanded-s1-animate");
            }
        },
        "hidePanel": function(panel) {
            /* BUG-304541 and BUG-304683 added flex specific code left side-bar was showing twice */
            if($(".screen-layout").hasClass("flex")){
              $(".screen-layout").removeClass("screen-layout-expanded-s1-animate screen-layout-expanded-s2-animate screen-layout-expanded-s1-animate2d screen-layout-expanded-s2-animate2d icon-bar-slideup");
              
              var toggleOneNav = document.getElementById("appview-nav-toggle-one"),
                  toggleTwoNav = document.getElementById("appview-nav-toggle-two");
              
              if (toggleOneNav) {
                toggleOneNav.setAttribute("aria-expanded", false);
              }
              if (toggleTwoNav) {
                toggleTwoNav.setAttribute("aria-expanded", false);
              }
              
              setTimeout(function() {
                //start second stage of animation
                $(".screen-layout").removeClass("screen-layout-expanded-s1 screen-layout-expanded-s2");
            }, 200);
           }
          else{
            //remove all expand classes, begin animated hide
            $(".screen-layout").removeClass("screen-layout-expanded-s1-animate screen-layout-expanded-s2-animate screen-layout-expanded-s1-animate2d screen-layout-expanded-s2-animate2d icon-bar-slideup");

            setTimeout(function() {
                //start second stage of animation
                $(".screen-layout").addClass("screen-layout-expanded-s1-close screen-layout-expanded-s2-close");
                $(".screen-layout").removeClass("screen-layout-expanded-s1 screen-layout-expanded-s2");
            }, 200);
            setTimeout(function() {
                //end second stage of animation
                //Used to hide sidebar after animation has taken place so it doesn't show through body background
                $(".screen-layout").removeClass("screen-layout-expanded-s1-close");
                $(".screen-layout").removeClass("screen-layout-expanded-s2-close");
            }, 400);
          }
        }
    });
}

//HALLJ: BUG-244060, handle event registration for offline without registering duplicates for non-offline...
var that = this;

window.addEventListener("load", function() {

    //fix for scroll-bar visibility in IE
    var scrollHeight;
    var mainMiddleHeight = $(".screen-layout-region-main-middle").height();
    var dcHeaderHeight = $("div.dc-header").height();
    scrollHeight = mainMiddleHeight- dcHeaderHeight;
    $(".ie11 .flex #workarea .static-dc-tab,.ie11 .flex #workarea .tabContent .dynamicContainer,.edge .flex #workarea .static-dc-tab").css({ 'height': (scrollHeight) + 'px' });
  
    if (pega.u.d && pega.u.d.HCLoadManager && pega.offline) {
        
        //Wait until HC finishes loading before registering handlers
        pega.u.d.HCLoadManager.onViewRendered(function() {
            screenLayoutResize.call(that);
        });

    } else {

        //not offline, okay to load now
        screenLayoutResize.call(that);

    }
    //UI Reg portal left navigation issue in mobile view
    var screenLayout = document.querySelector(".screen-layout");
    var clientResizeWidth = screenLayout ? screenLayout.getBoundingClientRect().width : null;
    var leftSideBar = $(".screen-layout-region-main-sidebar1");
    if(leftSideBar && clientResizeWidth <= 550 && leftSideBar.css("position") === "static") {
      leftSideBar.css({
        'position': "absolute"
      });
    }

});

pega.namespace("pega.ui");

pega.ui.screenLayout = function() {
    var publicAPI = {};
    publicAPI.resizeScreenLayout = function(width, height) {
      //after resizing setting the main height and width
        if($("main.screen-layout-region-main-middle").parents(".screen-layout").hasClass("flex")) {
            /* BUG-285233 calculation of width and height in case of round-up for resize */
            var clientResizeWidth = width;
            var clientResizeHeight = height;
                    /* BUG-285233 calculation of width and height in case of round-up for resize */
            if (!clientResizeWidth) {
                clientResizeWidth = document.querySelector(".screen-layout").getBoundingClientRect().width      
            }
            if (!clientResizeHeight) {
              clientResizeHeight = document.querySelector(".screen-layout").getBoundingClientRect().height
            }
            var origResizeLeftWidth = $(".screen-layout-region-main-sidebar1").outerWidth() || 0;
            if($(".screen-layout-region-main-sidebar1").css("z-index") == -1) {
                origResizeLeftWidth = 1;
            }
            var origResizeRightWidth = $(".screen-layout-region-main-sidebar2").outerWidth() || 0;
            if($(".screen-layout-region-main-sidebar2").css("z-index") == -1) {
                origResizeRightWidth = 1;
            }
            var liveUISidebarWidth = $('.runtime-control-panel.showing.runtime-control-panel-active').outerWidth() || 0;
            var agileWorkbenchWidth = $('.pz-gap-panel.ui-resizable.showing.pz-gap-panel-active').outerWidth() || 0;
            var origResizeHeaderHeight = $("header.screen-layout-region-header").outerHeight() || 0;
            var origResizeFooterHeight = $("footer.screen-layout-region-footer").outerHeight() || 0;
            var heightToBeSubtracted = origResizeHeaderHeight + origResizeFooterHeight;
            var widthToBeSubtracted = origResizeLeftWidth + origResizeRightWidth + liveUISidebarWidth + agileWorkbenchWidth;
            /* In case of IE the Width calculation during Resize */
            if (pega.util.Event.isIE) 
                widthToBeSubtracted += 1;
            /*$('.screen-layout-region-main-middle,.screen-layout-region-main-sidebar1, .screen-layout-region-main-sidebar2, #sidebar-collapse-left, #sidebar-collapse-right').css({ 'height': (clientResizeHeight - heightToBeSubtracted) + 'px' });
            $('.screen-layout-region-main-middle').css({ 'width': (clientResizeWidth - widthToBeSubtracted) + 'px' });*/
          /* BUG-306759 commneted the inline style for window resize */
          var isHeaderResizable,isFooterResizable,isLeftSideBarResizable,isRightSideBarResizable;
          isHeaderResizable = $('.screen-layout-region-header').hasClass('screen-layout-region-resize ui-resizable');
          isFooterResizable = $('.screen-layout-region-footer').hasClass('screen-layout-region-resize ui-resizable');
          isLeftSideBarResizable = $('.screen-layout-region-main-sidebar1').hasClass('screen-layout-region-resize ui-resizable');
          isRightSideBarResizable = $('.screen-layout-region-main-sidebar2').hasClass('screen-layout-region-resize ui-resizable');
          if(isHeaderResizable || isFooterResizable || isLeftSideBarResizable || isRightSideBarResizable){
            $('.screen-layout-region-main-middle,.screen-layout-region-main-sidebar1, .screen-layout-region-main-sidebar2, #sidebar-collapse-left, #sidebar-collapse-right').css({ 'height': (clientResizeHeight - heightToBeSubtracted) + 'px' });
            $('.screen-layout-region-main-middle').css({ 'width': (clientResizeWidth - widthToBeSubtracted) + 'px' });
          }
        }
        var frame = $(".screen-layout");
        var header = $(".screen-layout-region-header");
        var footer = $(".screen-layout-region-footer");
        var headerHeight = header.outerHeight();
        var footerHeight = footer.outerHeight();
        var sidebar1 = $(".screen-layout-region-main-sidebar1");
        var sidebar2 = $(".screen-layout-region-main-sidebar2");
        var middle = $(".screen-layout-region-main-middle");

        /* if sidebar position is absolute, then media query has not run -- reset defaults */
        if (sidebar1.css("position") == "absolute") {
            $("#sidebar-collapse-left").show();
            var style = sidebar1.attr('style');
            if (style) {
                /* BUG-504355 : after resize need to keep display:block prop */
                if(sidebar1.attr("data-expanded") === "false" && style.indexOf("display: block;") != -1){
                  sidebar1.attr('style', style.replace(/width: 0px;/g, '').replace(/display: none;/g, '').replace(/position: absolute;/g, ''));
                }else{
                  sidebar1.attr('style', style.replace(/width: 0px;/g, '').replace(/display: block;/g, '').replace(/display: none;/g, '').replace(/position: absolute;/g, ''));
                }
                sidebar1.css({
                    'top': headerHeight,
                    'bottom': footerHeight
                });
            }
            var currWidth = sidebar1.outerWidth();
            if (pega.u.d.isOrientationRTL()) {
                middle.css({
                    'right': currWidth
                });
                middle.css({
                    'left': 0
                }); // BUG-223568 fix
            } else {
                middle.css({
                    'left': currWidth
                });
            }
            header.css({
                'margin-left': '0',
                'left': '0'
            });
            footer.css({
                'margin-left': '0',
                'left': '0'
            });
            var screenStyle = frame.attr('style');
            if (screenStyle) {
                if (pega.u.d.isOrientationRTL()) {
                    var regex = new RegExp('margin-right: ' + sidebar1.css('width') + ';', "g");
                    frame.attr('style', screenStyle.replace(regex, '').replace(/margin-right: [0-9]*px;/g, ''));
                } else {
                    var regex = new RegExp('margin-left: ' + sidebar1.css('width') + ';', "g");
                    frame.attr('style', screenStyle.replace(regex, '').replace(/margin-left: [0-9]*px;/g, ''));
                }

            }

        } else if (sidebar1.css("position") == "fixed") {
            if (!sidebar1.is(":visible"))
                middle.css({
                    'left': ''
                });
        }
        //UI Reg portal left navigation issue in mobile view
        if(clientResizeWidth <= 550 && sidebar1.css("position") === "static") {
          sidebar1.css({
            'position': "absolute"
          });
        }
        if (sidebar2.css("position") == "absolute") {

            $("#sidebar-collapse-right").show();
            var style = sidebar2.attr('style');
            if (style) {
                /* BUG-504355 : after resize need to keep display:block prop */
                if(sidebar2.attr("data-expanded") === "false" && style.indexOf("display: block;") != -1){
                  sidebar2.attr('style', style.replace(/width: 0px;/g, '').replace(/display: none;/g, '').replace(/position: absolute;/g, ''));
                }else{
                  sidebar2.attr('style', style.replace(/width: 0px;/g, '').replace(/display: block;/g, '').replace(/display: none;/g, '').replace(/position: absolute;/g, ''));
                }
                sidebar2.css({
                    'top': headerHeight,
                    'bottom': footerHeight
                });
            }
            var currWidth = sidebar2.outerWidth();
            if (pega.u.d.isOrientationRTL()) {
                middle.css({
                    'left': currWidth
                });
            } else {
                middle.css({
                    'right': currWidth
                });
            }
            header.css({
                'margin-right': '0',
                'right': '0'
            });
            footer.css({
                'margin-right': '0',
                'right': '0'
            });
            var screenStyle = frame.attr('style');
            if (screenStyle) {
                if (pega.u.d.isOrientationRTL()) {
                    var regex = new RegExp('margin-left: ' + sidebar2.css('width') + ';', "g");
                    frame.attr('style', screenStyle.replace(regex, '').replace(/margin-left: [0-9]*px;/g, ''));
                } else {
                    var regex = new RegExp('margin-right: ' + sidebar2.css('width') + ';', "g");
                    frame.attr('style', screenStyle.replace(regex, '').replace(/margin-right: [0-9]*px;/g, ''));
                }
            }

        } else if (sidebar2.css("position") == "fixed") {
            if (!sidebar2.is(":visible"))
                middle.css({
                    'right': ''
                });
        }
    }
  
    return publicAPI;
}();



//Adding code to file - pzpega_ui_workarea is not picking the code change, may be file not loaded
if(typeof(pega)!="undefined" &&  typeof(pega.u)!="undefined" && typeof(pega.u.d)!= "undefined" ){
  pega.u.d.attachOnload (harnessPortalResizable, true);
}else {
  window.attachEvent("onload", harnessPortalResizable); // attach onload event
}

function harnessPortalResizable(){
  //Right resizable
  var mainLeft = $(".workarea-main-left");
  var mainRight = $(".workarea-main-right");
  var mainLeftHandle = $(mainLeft.find('div[class*="workarea-main-left-handle"]'));
  var mainRightHandle = $(mainRight.find('div[class*="workarea-main-right-handle"]'));
  
  if(mainRight.length>0 && !mainRight.hasClass("ui-resizable") && mainRightHandle.length>0){
    //Collapsed the left panle on click css
    mainRightHandle.click(function(){
      if($(".workarea-main-right").hasClass("noClick")){
        $(".workarea-main-right").removeClass("noClick")
         return false;
       }
      $(this.parentElement).toggleClass("collapsed");
      /* BUG-492043 */
      if($(this.parentElement).hasClass("collapsed")){
        $(this.parentElement).attr('data-expanded','false');
      }else{
        $(this.parentElement).attr('data-expanded','true');
      }
      if($(this.parentElement).attr('data-expanded') === 'false'){
        $(this.parentElement).css("display","block");
      }
      $(window).resize();
    });
    mainRight.resizable({
      handles: {'w': mainRightHandle}, 
      resize : function (event, ui) {
        ui.position.left = ui.originalPosition.left;
        ui.size.width = ui.size.width - 3;
      },
      start: function( event, ui ) {
        $(".workarea-main-right").addClass("noClick");
        $(".workarea-main-right").removeClass("collapsed");
      },
      stop: function( event, ui ) {
        setTimeout(function(){
          $(".workarea-main-right").removeClass("noClick")
        }, 300);
      }
    });
  }
  
  //Left Resizable
  if(mainLeft.length>0 && !mainLeft.hasClass("ui-resizable") && mainLeftHandle.length>0){
    //Collapsed the left panle on click css
    //Uncomment if you need left panel to be expand/collapse
    /*$(".workarea-main-left-handle").click(function(){
      $(this.parentElement).toggleClass("collapsed");
    });*/
    mainLeftHandle.click(function(){
      if($(".workarea-main-left").hasClass("noClick")){
        $(".workarea-main-left").removeClass("noClick")
         return false;
       }
      $(this.parentElement).toggleClass("collapsed");
      /* BUG-492043 */
      if($(this.parentElement).hasClass("collapsed")){
        $(this.parentElement).attr('data-expanded','false');
      }else{
        $(this.parentElement).attr('data-expanded','true');
      }
      if($(this.parentElement).attr('data-expanded') === 'false'){
        $(this.parentElement).css("display","block");
      }
      $(window).resize();
    });
    mainLeft.resizable({
      handles: {'e': mainLeftHandle}, 
      resize:function(event, ui){
        ui.size.width = ui.size.width - 3;
      }  ,
      start: function( event, ui ) {
        $(".workarea-main-left").addClass("noClick");
        $(".workarea-main-left").removeClass("collapsed");
      },
      stop: function( event, ui ) {
        setTimeout(function(){
          $(".workarea-main-left").removeClass("noClick")
        }, 300);
      }
    }); 
  }
  if($(".workarea-main-left").attr('data-expanded') === 'false'&& !$('.workarea-main-left').hasClass("collapsed")){
        $('.workarea-main-left-handle').click();
      //toggleCollapseLeftPanel();
    }
    if($(".workarea-main-right").attr('data-expanded') === 'false' && !$('.workarea-main-right').hasClass("collapsed")){
        $('.workarea-main-right-handle').click();
      //toggleCollapseRightPanel();
    }
}
//static-content-hash-trigger-GCC
(function(p){
	var pue = p.util.Event,
		pud = p.u.d,
		desktop = pega.desktop,
		desktopSupport = desktop.support,
		ua = p.env.ua,
		desktopWindow = null,

		initialize = function(){
			if (!pud || ! desktop || ! desktopSupport){
				return;
			}
			desktopWindow = desktopSupport.getDesktopWindow();
			var currentWindow = window;
			/*
			if (window != desktopWindow){
				return;
			}*/

			if (ua.ie){
				// For IE, install the reload handler as the current window's "focusin" event handler.
				pue.addListener(currentWindow.document,"focusin", windowHandlerWrapper);
			}
			else if (ua.webkit){
				currentWindow.addEventListener("focus", windowHandlerWrapper, true);
			}else{
				// For Firefox, install the reload handler as the current window's document's "focusin" event handler.
				// Firefox doesn't trigger focus on the window object when the window is activated.
				// Thankfully, it does trigger the document's focus event.
				pue.addListener(currentWindow.document,"focusin", windowHandlerWrapper);
			}

		},

		windowHandlerWrapper = function(){
			try{
				desktopWindow.pega.desktop.windowReloadHandler();
			}catch(e){}
		},

		that = this;

		pud.attachOnload(function () { initialize.call(that); }, false);
})(pega);
//static-content-hash-trigger-GCC
/*********************************************************************************************************
* 
* pzpega_mobile_hybrid.js
* This file included the API's that are required for hybrid client.
*
* This file should be included after pzpega_mobile.js as pega.mobile namespace is declare in pzpega_mobile.js file.
*
**********************************************************************************************************/

(function(p) {
	p.m = p.mobile;
  
  /* ToDo: These declaration should be removed as these are already present in pzpega_mobile. This can be done only when jsUnits are fixed by adding pzpega_mobile as dependency in Describe_pzpega_mobile_hybrid rule */
  
	p.m.isNativeSDK = (navigator.userAgent.toLowerCase().indexOf('pegamobilesdk') !== -1);
	p.m.isHybridClient = (navigator.userAgent.toLowerCase().indexOf('ampwebcontrol') !== -1);
	p.m.isPegaElectronContainer = (navigator.userAgent.toLowerCase().indexOf('pegaelectroncontainer') !== -1);
	p.m.isPegaMobileClient = (navigator.userAgent.toLowerCase().indexOf('pegamobile') !== -1);
	p.m.isOfflineBrowser = pega.offline && pega.offline.browser ? true : false;
	p.m.isHybrid = (p.m.isNativeSDK || p.m.isHybridClient || p.m.isPegaElectronContainer || p.m.isOfflineBrowser || p.m.isPegaMobileClient);

	if (p.m.isPegaMobileClient && typeof pmcRuntimeFeatures === "undefined") {
		console.warn("pmcRuntimeFeatures is undefined in Pega Mobile Client. This shouldn't be the case.");
	} else if (p.m.isPegaMobileClient && pmcRuntimeFeatures !== "undefined") {
		p.m.isParentWebView = typeof pmcPortalConfiguration !== "undefined";
		p.m.isChildWebView = typeof pmcPortalConfiguration === "undefined";

		p.m.isSingleWebViewPegaMobileClient = !pmcRuntimeFeatures.pxUsesMultiWebView;
		p.m.isSingleWebViewOfflinePegaMobileClient = pmcRuntimeFeatures.pxUsesOffline === "true" && !pmcRuntimeFeatures.pxUsesMultiWebView;

		p.m.isMultiWebViewPegaMobileClient = pmcRuntimeFeatures.pxUsesMultiWebView === "true";
		p.m.isMultiWebViewOfflinePegaMobileClient = pmcRuntimeFeatures.pxUsesOffline === "true" && pmcRuntimeFeatures.pxUsesMultiWebView === "true";
	}

	// https://stackoverflow.com/questions/8348139/detect-ios-version-less-than-5-with-javascript
	function getIosVersion() {
		if (/iP(hone|od|ad)/.test(navigator.platform)) {
			var version = (navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);
			return version && parseInt(version[1], 10);
		}
	}

	if (pega && pega.u && pega.u.d) {
		pega.u.d.attachOnload(function() {
			var iOSVersion = getIosVersion();
			// BUG-513343 : If iOS version is greater than 12 add overflow:auto to the body tag.
			if (iOSVersion && iOSVersion > 12) {
				document.body.style.overflow = "auto";
			}
		}, false);
	}

	var main = p.desktop.support.getDesktopWindow();
	main = main ? main : window;

	var desktopWindow = main;

	// If in Live Composer Mode then the parentWindow should be forced to composer window
	if (main.pega.ui && main.pega.ui.composer) {
		main = main.pega.ui.composer.getCurrentComposerWindow();
	}

	p.m.getDesktopWindow = function() {
		return desktopWindow;
	};

	// -- Launchbox Wrapper - definition --
	var LaunchBox = function() {};

	LaunchBox.prototype = {
		logOut: function() {},
		//Make Launchbox Observable to support onlaunchboxloaded
		handlers: [],
		addEventListener: function(e, fn, scope) {
			this.handlers.push({
				type: e,
				fn: fn,
				scope: scope
			});
		},
		removeEventListener: function(e, fn, scope) {
			this.handlers = this.handlers.filter(
				function(handler) {
					if (handler.type !== e || handler.fn !== fn || handler.scope !== scope) {
						return handler;
					}
				}
			);
		},
		fireEvent: function(ev, args) {
			this.handlers.forEach(
				function(handler) {
					if (handler.type.toLowerCase() === ev.toLowerCase()) {
						handler.fn.apply(handler.scope || window, args);
					}
				}
			);
		}
	};
	// -- Launchbox Wrapper - end --

	var clientUsesAuthorizationCodeAuthentication = function() {
		return main.launchbox.Authentication
			&& main.launchbox.Authentication.AuthenticationType
			&& main.launchbox.Authentication.AuthenticationType.OAUTH2_AUTHORIZATION_CODE === main.launchbox.Authentication.authenticationType;
	};

	var invokeLogoutActivity = function(onLogOffSuccessful) {

		/** Logout is handled in new pyMobileBootstrap application */
		if (clientUsesAuthorizationCodeAuthentication() && main.launchbox.InterAppCommunicator) {
			main.launchbox.InterAppCommunicator.sendEvent({name: "Logoff"});
			onLogOffSuccessful();
			return;
		}

		if (!(main.launchbox.Authentication && main.launchbox.Authentication.Type.PEGA_AUTHENTICATOR)) {
			console.warn("The launchbox.Authentication.PEGA_AUTHENTICATOR API not available. Skipping logout on server side.");
			return;
		}

		var pegaAuthenticator = main.launchbox.Authentication.authenticator(main.launchbox.Authentication.Type.PEGA_AUTHENTICATOR);
		pegaAuthenticator.url = window.location.origin + window.pxReqURI;
		pegaAuthenticator.logOff().then(onLogOffSuccessful, function(error) {
			console.error("pegaAuthenticatior logOff failed" + JSON.stringify(error))
		});
	};

	var stopClientStoreIfNeeded = function(completionHandler) {
		if (!main.pega.offline || !(main.launchbox.PRPC && main.launchbox.PRPC.ClientStore)) {
			completionHandler();
			return;
		}
		var onStatusUpdateEvent = {
			onStatusUpdate: function(status) {
				if (!status.busy) {
					main.launchbox.PRPC.ClientStore.removeListener(onStatusUpdateEvent);
					completionHandler();
				} else {
					main.launchbox.PRPC.ClientStore.stop();
				}
			}
		};
		main.launchbox.PRPC.ClientStore.addListener(onStatusUpdateEvent);
	};

	var Hybrid = LaunchBox;

	if (p.m.isNativeSDK) {
		var NativeSDK = function() {};
		NativeSDK.prototype = new LaunchBox();
		NativeSDK.prototype.logOut = function() {
			invokeLogoutActivity(function() {
				window.close();
			});
		};
		Hybrid = NativeSDK;
	} else if (p.m.isHybridClient || p.m.isPegaElectronContainer || p.m.isOfflineBrowser || p.m.isPegaMobileClient) {
		var HybridClient = function() {};
		HybridClient.prototype = new LaunchBox();
		HybridClient.prototype.logOut = function(onLogOffSuccessful) {
			var closeAccount = function() {
				if (main.launchbox.AccountManager && main.launchbox.AccountManager.closeAccount) {
					// Reset global AccountManager listener.
					main.launchbox.AccountManager.accountManagerListener = {
						onOpen: function() {},
						onClose: function() {}
					};
					var callbacks = {
						'onSuccess': function() {},
						'onFailure': function(error) {
							console.log('Failed to close AccountManager account. ' + error);
						}
					};
					main.launchbox.AccountManager.closeAccount(callbacks);
				}
			};
			stopClientStoreIfNeeded(function() {
				invokeLogoutActivity(onLogOffSuccessful);
				if (window.launchbox && window.launchbox.appDynamics) {
					window.launchbox.appDynamics.stopTimer("Offline").then(
						window.launchbox.appDynamics.stopTimer("Online").then(closeAccount(), closeAccount()), closeAccount());
				} else {
					closeAccount();
				}
			});
		};
		Hybrid = HybridClient;
	}

	// final hybrid object, through which we can communicate with the native
	p.m.hybrid = new Hybrid();

	var launchboxReady = false;
	var callbacksWaitingForLaunchbox = [];

	p.m.hybrid.callWhenLaunchboxLoaded = function(callback, hasPriority) {
		if (launchboxReady) {
			callback();
		} else {
			if (hasPriority) {
				callbacksWaitingForLaunchbox.unshift(callback);
			} else {
				callbacksWaitingForLaunchbox.push(callback);
			}
		}
	};

	if (p.m.isHybrid) {
		main.onLaunchboxLoaded = function() {
			launchboxReady = true;
			callbacksWaitingForLaunchbox.forEach(
				function(callback) {
					try {
						callback();
					} catch (err) {
						console.log("Failed to call one of 'on launchbox loaded' callbacks.");
						console.error(err);
					}
				});
			callbacksWaitingForLaunchbox = [];
			main.pega.mobile.hybrid.fireEvent("launchboxloaded", arguments);
		};
	}

    /*
     *  TO BE REMOVED.
     */
	var readCookies = function(name) {
		var nameEQ = name + "=";
		var ca = document.cookie.split(';');
		var values = [];
		for (var i = 0; i < ca.length; i++) {
			var c = ca[i];
			while (c.charAt(0) === ' ')
				c = c.substring(1, c.length);
			if (c.indexOf(nameEQ) === 0)
				values.push(c.substring(nameEQ.length, c.length));
		}
		return values;
	};

    /*
     * TO BE REMOVED.
     * Currently used in pzPega_offline_datasync JS rule. But it can be replaced in future with a call to
     * launchbox.Authentication.Type.PEGA_AUTHENTICATOR object.
     */
	p.m.hybrid.isSessionCookieAvailable = function() {
		var pegaCookies = readCookies("Pega-RULES");
		for (var i = 0; i < pegaCookies.length; i++) {
			if (pegaCookies[i].length > 0 && pegaCookies[i] !== "none") {
				return true;
			}
		}
		return false;
	};

	p.m.hybrid.getLaunchBox = function() {
		/*Only HC , SDK , Electron , PIMC containers  have Launchbox support */
		/* For PIMC returns launchbox with PRPC.Clientstore in it*/
		if (p.m.isHybrid) {
			return top.launchbox;
		} else {
			return null;
		}
	};

	var javascriptErrorInApplication = false;

	// Show application after its view was rendered
	if (p.u.d.HCLoadManager && p.u.d.HCLoadManager.onViewRendered) {
		p.u.d.HCLoadManager.onViewRendered(function() {
			if (javascriptErrorInApplication) {
				return;
			}
			var triggerOnViewRendered = function() {
				main.launchbox.InterAppCommunicator.sendEvent({
					name: "OfflineViewRendered"
				});
				window.pega.offline.ExceptionHandler.disable();
			};
			if (window.launchbox.ApplicationManager) {
				if (window.launchbox.ApplicationManager.self.state === "started") {
					triggerOnViewRendered();
				} else {
					var appListener = {
						onListChanged: function() {},
						onApplicationChanged: function(changedApplication, progress, error) {
							if (changedApplication.id === window.launchbox.ApplicationManager.self.id &&
								changedApplication.state === "started") {
								triggerOnViewRendered();
								main.launchbox.ApplicationManager.removeApplicationManagerListener(appListener);
							}
						}
					};
					main.launchbox.ApplicationManager.addApplicationManagerListener(appListener);
				}
			}
		});
	}

	var interAppCommunicatorListener = {
		onEvent: function(data, senderId) {
			if (data.name === "JavascriptErrorInApplication") {
				// This flag is raised to make sure that app will not start.
				javascriptErrorInApplication = true;
			}
		}
	};

	if (p.u.d.HCLoadManager) {
		p.u.d.HCLoadManager.attachOfflineExceptionListener = function() {
			// Mobile Mashup do not have InterAppCommunicator.
			if (main.launchbox.InterAppCommunicator) {
				main.launchbox.InterAppCommunicator.addListener(interAppCommunicatorListener);
			}
		};
	}

	p.m.hybrid.callWhenLaunchboxLoaded(function() {
		if (p.u.d.HCLoadManager && p.u.d.HCLoadManager.attachOfflineExceptionListener) {
			p.u.d.HCLoadManager.attachOfflineExceptionListener();
		}
	});

})(pega);
//static-content-hash-trigger-GCC
(function (p) {
    p.m = p.namespace("pega.mobile");

    var isDebugging = true;//pega.mobile.debjs;

    /**
     * HistoryList
     */
    function HistoryList() {
        var list = {};
        var lastItemKey = null;

        this.list = list; // for debugging

        var keysCnt = 0;
        function getKey() {
            keysCnt++;
            return "key" + keysCnt;
        }

        this.push = function (val, isCheckPoint) {
            // get a new key
            var uid = getKey();

            // add it to the map with passed handler along with next and prev ref
            list[uid] = {
                data: val,
                prev: lastItemKey,
                next: null,
                isCheckPoint: isCheckPoint ? true : false
            }

            // update the prev items next value with the new item id
            if (lastItemKey != null) {
                list[lastItemKey].next = uid;
            }

            lastItemKey = uid;

            return uid;
        }

        this.getLastItem = function () {
            if (lastItemKey && list[lastItemKey]) {
                return list[lastItemKey].data;
            }

            return false;
        }

        this.pop = function (needFullData) {
            if (lastItemKey == null) {
                return false;
            }

            // back up the prev last item key
            var newLastItemKey = null;
            if (list[lastItemKey]) {
                newLastItemKey = list[lastItemKey].prev
            }

            // take a back of the while object
            var currentItem = list[lastItemKey];
            // var currentItemBkp = list[lastItemKey].data;

            // delete the last item
            delete list[lastItemKey];

            // update the last item value to the last but one's value
            lastItemKey = newLastItemKey;

            // update the new last items next value to null
            if (lastItemKey != null) {
                list[lastItemKey].next = null;
            }

            // return the item that we just removed
            if (needFullData) {
                return currentItem;
            } else {
                return currentItem.data;
            }
        }

        this.restore = function (key) {
            if (list[key] && list[key].isCheckPoint) {
                while (!this.isEmpty()) {
                    var item = this.pop(true);

                    if (item.isCheckPoint) {
                        return item;
                    }
                }
            }

            return false;
        }

        this.remove = function (uid) {
            if (!list[uid]) {
                return false;
            }

            // take backup of the references
            var nextBkp = list[uid].next;
            var prevBkp = list[uid].prev;

            // delete item
            delete list[uid];

            // udpate prev items next value
            if (prevBkp) {
                list[prevBkp].next = nextBkp;
            } else { // if prevBkp is null, that means the one that we just removed is the first item
                if (!nextBkp) { // if next value is also null then, we dont have any in the list
                    lastItemKey = null;	// there are no more items so we can set the lastItemKey to null
                }
            }

            // update next items prev value
            if (nextBkp) {
                list[nextBkp].prev = prevBkp;
            } else { // if next item is null, that means the one that we just removed is the last item. 
                lastItemKey = prevBkp;  // set currently removed items prev uid value to lastItemKey
            }

            return true;
        }

        this.isEmpty = function () {
            if (lastItemKey == null) {
                return true;
            }

            return false;
        }
    }

    var isActive = false;
    var isNavEnabled = false;

    var isBlocked = false;
    var history = new HistoryList();

    // inorder to identify the home page, we need to set some indication for home page history state, currently its value is null. 
    // However there are chances that other page states can also have null state... not sure.. hence below changes are needed..
    $(function () {
        // Pega Mobile Client - register for back event
        if (pega.mobile.sdk && pega.mobile.sdk.device && pega.mobile.sdk.device.goBack) {
            initState();
            pega.mobile.sdk.device.addEventListener("backbuttonpressed", processBack);
        }

        // Hybrid Container - register for back event
        if (pega.mobile && pega.mobile.hybrid) {
            pega.mobile.hybrid.callWhenLaunchboxLoaded(function () {
                if (window.launchbox && window.launchbox.BackAction) {
                    initState();
                    window.launchbox.BackAction.addListener({
                        "onBackButtonPressed": processBack
                    });
                }
            });
        }
    });

    // initialize state for mobile applications
    function initState() {
        // set active state
        isActive = true;

        // if application if offline enabled
        if (!pega.u.d.isAppOfflineEnabled()) {
            if (typeof (window.history.replaceState) == "function") {
                // get current HOME page history-state
                var state = window.history.state ? window.history.state : {};

                // update HOME page history-state with a flag.. say page=1
                state.page = 1;

                // replace current state with the updated state.
                window.history.replaceState(state, "Home");

                console.log("native_navigation:Home page marked!");
            }

            // set navigation enabled flag to true
            isNavEnabled = true;
        }
    }

    // handles the back button click
    function processBack() {
        // Micro DC case
        if (pega.ui.hasAjaxContainer && history.isEmpty()) {
            var state = pega.redux.Utils.getAjaxContainerState();
            if (state.docsHistory && state.docsHistory.length > 1) {
                var recordId = state.docsHistory[state.docsHistory.length - 2];
                var actionObj = {
                    recordId: recordId,
                    fromBackButtonClick: true
                };
                pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.SWITCH, actionObj));
                return;
            }
        }
        // if history not empty
        if (!history.isEmpty()) {
            // execute handler of the last item | *Note: its the handlers responsibility to execute removeFromHistory API 
            executeAndRemoveLastAction();
        } else { // if history is empty
            // check if in home page!
            if (((window.history.state && window.history.state.page != 1) || window.history.state == null) && isNavEnabled) { // --if not home page || some times sate will be null for intermediate pages
                // execute 'navigateBack'
                navigateBack();
            } else {// if empty 
                // execute 'exitApp'
                exitApp();
            }
        }
    }

    /**
     * execute the last action and remove it from the history
     */
    function executeAndRemoveLastAction() {
        // get the last item and remove it from the list
        var handler = history.getLastItem();//history.pop();

        try {
            handler();
        } catch (e) {
            console.error("Native nav back handler execution failed with exception", e);
        }
    }

    /*
     * adds an item to the history
     *
     * backHandler: callback funtion that will be executed when back button is clicked
     *
     * returns an unique id
     */
    function addToHistory(backHandler, scope) { // can pass coma-seperated arguments after the scope parameter - the same was as we pass parameters to the actual function
        if (isBlocked) {
            return -1;
        }

        // if this functionality is disabled for unsupported devices, we will just return -1
        var fn = validateAndGetHandler(backHandler, scope, arguments);

        if (fn) {
            // push to history and return the id
            return history.push(fn);//{fn:fn, scope: scope});
        }

        return -1;
    }

    /*
     * adds an item to the history and blocks further adding to the history
     *
     * backHandler: callback funtion that will be executed when back button is clicked
     *
     * returns an unique id
     */
    function addToHistoryAndBlock(backHandler, scope) { // can pass coma-seperated arguments after the scope parameter - the same was as we pass parameters to the actual function
        if (isBlocked) {
            return -1;
        }

        // if this functionality is disabled for unsupported devices, we will just return -1
        var fn = validateAndGetHandler(backHandler, scope, arguments);

        if (fn) {
            var id = history.push(fn);

            if (id && id !== -1) {
                isBlocked = id; // instead of boolean, maininging the id of the blocked element
            }
            // push to history and return the id
            return id;
        }

        return -1;
    }

    /*
     * adds an item to the history as a checkpoint
     *
     * backHandler: callback funtion that will be executed when back button is clicked
     *
     * returns an unique id
     */
    function addAsCheckPoint(backHandler, scope) { // can pass coma-seperated arguments after the scope parameter - the same way as we pass parameters to the actual function
        var fn = validateAndGetHandler(backHandler, scope, arguments);

        if (fn) {
            // push to history and return the id
            return history.push(fn, true);//{fn:fn, scope: scope});
        }

        return -1;
    }

    /*
     * pops all the items until it hits an item with isCheckpoint is true or if it reaches the last item
     * 
     * returns checkpoint item or false if it reaches the last item
     */
    function restoreCheckpoint(key) {
        if (key && key == -1) {
            return false;
        }

        return history.restore(key);
    }

    /*
     * removes an item from the history
     *
     * unique id : id that was returned when added to the history
     *
     * returns boolean status
     */
    function removeFromHistory(uniq_id) {
        // if this functionality is disabled for unsupported devices, we will just return -1
        if (!isActive) {
            return true;
        }

        if (isBlocked && isBlocked == uniq_id) {
            isBlocked = false;
        }

        // delete the item from the history array and
        // 	return the status
        return history.remove(uniq_id);
    }

    /**
          * triggers history back
          */
    function navigateBack() {
        // do default browser history back
        window.history.back();
    }

    /**
     * shows confirm dialog and takes the app to background
     *
     */
    function exitApp() {
        // show confirm dialog
        var exitMsg = pega.u.d.fieldValuesList.get("Are you sure you want to exit?") || "Are you sure you want to exit?";
        var sure = true;

        // showExitConfirmationOnAndroidApp is declared and set throught 'pzClientDynamicDataBottom' rule
        if (bottomVars.dynamic_context.showExitConfirmationOnAndroidApp) {
            sure = confirm(exitMsg);
        }

        // take the app to background
        if (sure) {
            if (pega.mobile.sdk && pega.mobile.sdk.device && pega.mobile.sdk.device.goBack) pega.mobile.sdk.device.goBack();
            if (top.launchbox) top.launchbox.BackAction.fireDefaultBackButtonAction();
        }
    }

    function validateAndGetHandler(backHandler, scope, argmnts) {
        // if this functionality is disabled for unsupported devices, we will just return -1
        if (!isActive) {
            return false;
        }

        // validate handler
        if (typeof backHandler !== 'function') {
            throw new Error("Invalid handler!");
        }

        var fn = backHandler;
        if (scope) {
            var aArgs = Array.prototype.slice.call(argmnts, 1); // bind method expects first param as scope, so we need the scope param in the 0th position

            fn = backHandler.bind.apply(backHandler, aArgs);// Using Function.prototype.bind with an array of arguments instead of coma seperated arguments
        }

        return fn;
    }

    p.m.nativenav = {
        addToHistory: addToHistory,
        addToHistoryAndBlock: addToHistoryAndBlock,
        removeFromHistory: removeFromHistory,
        addAsCheckPoint: addAsCheckPoint,
        restoreCheckpoint: restoreCheckpoint
    }

    if (isDebugging) {
        isActive = true;
        $(document).on('onBackButtonPressed', processBack);

        p.m.nativenav.items = history.list
        p.m.nativenav.triggerBack = processBack
    }
})(pega);
//static-content-hash-trigger-GCC
/*
@package
pzpega_openurl_in_modal.js
Wrapper to open a url inside a modal dialog - can be used for showModalDialog replacement

Implementation details:
   - if an overlay is already opened of if this is not a standard harness and only Jquery is loaded, then we will open a jquery Modal dialog
   - otherwise we open a standard PRPC modal or overlay (if a PRPC is already opened)
   - before calling processActionModal, we override pega.u.d.performFlowAction so that we can detect the close of the modal/flow 
     and avoid sending an unnecessary submit request to the server. The old showModalDialog was never submit anything into the clipboard on close
     and we need to implement the same approach - the function is restored when closing the modal
*/
/*
  Overwrite the showModalDialog if not present to return a warning message
*/
if (typeof showModalDialog == 'undefined') {
    window.showModalDialog = function(dialog, varArgIn, varOptions) {
        alert(
            "OpenUrlInDialog API and window.showModalDialog are no longer supported. Replace by an auto-generated local action"
        );
    }
}
if (!pega) var pega = {};
if (!pega.openUrlInModal) {
    /*  @constructor
    @protected - Constructor description goes here.
    @return $undefined$ - return description goes here.
    */
    pega.openUrlInModal = (function() {
        var showing, origPerformFlowAction, newEventObj, _url, _isOverlay, _width, _height,
            _cloneEventObj = function(eventObj, overrideObj) {
                if (!overrideObj) {
                    overrideObj = {};
                }

                function EventCloneFactory(overProps) {
                    for (var x in overProps) {
                        this[x] = overProps[x];
                    }
                }
                EventCloneFactory.prototype = eventObj;
                return new EventCloneFactory(overrideObj);
            },
            _modalListener = function(status) {
                if (status === "OPEN") {
                    pega.util.Dom.setStyle(pega.u.d.modalDialog.resizeHandle, "display", "none");
                } else if (status === "CLOSE") {
                    // nothing to do
                }
            },
            _hidePanel = function() {
                if (showing) {
                    pega.u.d.performFlowAction = origPerformFlowAction;
                    pega.u.d.unregisterModalListener(_modalListener);
                    showing = false;
                    if (pega.u.d.gBusyInd) pega.u.d.gBusyInd.hide();
                    newEventObj = undefined;
                }
            },
            _overrideShowModalFunctions = function(callbackFunction) {
                pega.u.d.performFlowAction = function(taskStatus, event, tempInterestPage, tempTaskStatus,
                    overlayNode, showOnlyMask, closeReason) {
                    _hidePanel();
                    if (!overlayNode) { // modal dialog closed
                        pega.u.d.modalDialog.hide();
                    } else {
                        var popOver = pega.u.d.getPopOver(pega.u.d.insertButton);
                        if (popOver != null) {
                            pega.u.d.overLaySubmit = false;
                            popOver.close();
                        }
                        pega.u.d.resetSubmitModalDlgParam();
                    }
                    if (callbackFunction) {
                        try {
                            callbackFunction(window.returnValue);
                        } catch (e) {
                            alert(
                                "pega.openUrlInModal.showModalDialog - error when calling callbackfunction: '" +
                                e.message + "'");
                        }
                    }
                };
            },
            /*  display a modal dialog or an overlay with PRPC components  */
            _showModalDialog = function(url, arDialogArguments, height, width, callbackFunction) {
                if (arDialogArguments) window.dialogArguments = arDialogArguments;
                if (typeof width == "string") width = width.replace("px", "");
                if (typeof height == "string") height = height.replace("px", "");
                // if the modal dialog is loaded - then we need to switch to an overlay
                var bIsModalOpened = pega.ui.Doc.prototype.isModalLoaded();
                origPerformFlowAction = pega.u.d.performFlowAction;
                showing = true;
                var tempPageName = "pyWorkPage"; // TODO: does the clipboard page matters ?
                var flowName = "pzDisplayModalDialog";
                _overrideShowModalFunctions(callbackFunction);
                pega.u.d.registerModalListener(_modalListener);
                var bIsDCinDL = false;
                var actionURL = new SafeURL();
                actionURL.put("readOnly", "true");
                actionURL.put("pzPrimaryPageName", tempPageName);
                actionURL.put("BaseReference", tempPageName);
                actionURL.put("modelessDialog", "true");
                actionURL.put("IgnoreSectionSubmit", true);
                actionURL.put("NewTaskStatus", flowName);
                actionURL.put("TaskIndex", "");
                actionURL.put("StreamType", "");
                actionURL.put("FieldError", "");
                actionURL.put("FormError", "");
                actionURL.put("pyCustomError", "");
                actionURL.put("bExcludeLegacyJS", "true");
                actionURL.put("modalStyle", "");
                actionURL.put("bIsDCinDL", bIsDCinDL);
                _url = typeof url == "string" ? url : url.toURL();
                actionURL.put("frameWidth", width + "px");
                actionURL.put("frameHeight", height + "px");
                _width = width;
                _height = height;
                actionURL.put("bIsModal", "true");
                actionURL.put("inStandardsMode", "true");
                if (bIsModalOpened) { // if a modal is opened then we should open an overlay
                    actionURL.put("ActionSection", "pyOverlayTemplate");
                    actionURL.put("bIsOverlay", "true");
                    actionURL.put("FlowActionTarget", "overlay");
                    _isOverlay = true;
                } else {
                    actionURL.put("ModalSection", "pyModalTemplate");
                    _isOverlay = false;
                }
                newEventObj = _cloneEventObj(document.event, {
                    target: document.body
                });
                pega.ui.Doc.prototype.processActionModal(actionURL, "", newEventObj, "", null, {isCenterOverlay: "true"});
            },
            /*  display a modal dialog  using jquery  */
            _showJqueryModalDialog = function(url, arDialogArguments, height, width, callbackFunction) {
                if (arDialogArguments) window.dialogArguments = arDialogArguments;
                var iFrameStart =
                    '<div><iframe name="pzDisplayModalDialog" id="pzDisplayModalDialog" frameborder="0" src="';
                var iFrameEnd = '" style="width:100%; height:100%"/></div>';
                var $frame = $(iFrameStart + (typeof url === "string" ? url : url.toURL()) + iFrameEnd);
                var $dialogWindow = $frame.dialog({
                    autoOpen: true,
                    modal: true,
                    width: width,
                    height: height + 50,
                    resizable: false,
                    autoResize: false,
                    position: ['middle', 20],
                    overlay: {
                        opacity: 0.8,
                        background: "black"
                    },
                    open: function() {
                        var pzDisplayModalDialogWindow = $(this).children()[0].contentWindow;
                        if (window.gsServerReqURI) pzDisplayModalDialogWindow.gsServerReqURI =
                            window.gsServerReqURI;
                        pzDisplayModalDialogWindow.dialogArguments = window.dialogArguments;
                        pzDisplayModalDialogWindow.returnValue = undefined;
                    },
                    close: function() {
                        _handleCloseJqueryModal(callbackFunction, undefined, $frame, $dialogWindow);
                    }
                }).width(width - 30).height(height).css("overflow", "hidden");
                $frame.children().on("load", function() {
                    var title = $(this).contents().find("title").html();
                    $dialogWindow.dialog('option', 'title', title);
                    // enable the closeModal function  
                    // set the return value in the window object and call the close container action
                    var pzDisplayModalDialogWindow = $(this)[0].contentWindow;
                    pzDisplayModalDialogWindow.closeModal = function() {
                        _handleCloseJqueryModal(callbackFunction, pzDisplayModalDialogWindow.returnValue,
                            $frame, $dialogWindow);
                    };
                });
            },
            _handleCloseJqueryModal = function(callbackFunction, retval, frame, dialogWindow) {
                window.returnValue = retval;
                dialogWindow.dialog('destroy');
                frame.remove();
                dialogWindow.remove();
                if (callbackFunction) {
                    try {
                        callbackFunction(window.returnValue);
                    } catch (e) {
                        alert("pega.openUrlInModal.showModalDialog - error when calling callbackfunction: '" + e
                            .message + "'");
                    }
                }
            },
            /*  display a modal dialog  using jquery  */
            _showMSModalDialog = function(url, arDialogArguments, height, width, callbackFunction) {
                if (typeof width === "string") width = width.replace("px", "");
                if (typeof height === "string") height = height.replace("px", "");
                var arOptions = "dialogHeight: " + height + "px; dialogWidth: " + width +
                    "px; status: no; help: no; scroll: yes; resizable: no;";
                var returnValue = window.showModalDialog((typeof url === "string" ? url : url.toURL()),
                    arDialogArguments, arOptions);
                window.returnValue = returnValue;
                if (callbackFunction) {
                    try {
                        callbackFunction(window.returnValue);
                    } catch (e) {
                        alert("pega.openUrlInModal.showModalDialog - error when calling callbackfunction: '" + e
                            .message + "'");
                    }
                }
            },
            // for IE8 or before - we switch back to the old showModalDialog to avoid memory leak issues
            _shouldFallbacktoMSModal = function() {
                if (pega.env && pega.env.ua && pega.env.ua.ie) {
                    if (pega.env.ua.ie <= 8) return true;
                    else return false;
                }
                //if MSIE is missing then the browser is a non-IE browser OR IE11+
                //should return false in all these cases
                var ieVersion = 0;
                var ua = window.navigator.userAgent;
                var msie = ua.indexOf("MSIE ");
                if (msie > 0) { /* If Internet Explorer, return version number */
                    ieVersion = parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)));
                    return (ieVersion <= 8);
                }
                return false;
            };
        return {
            /*
            @public- Opens a url in a modal dialog
            @param $String$oUrl – A string specifying the URL to open in the new dialog, or a SafeURL object.
            @param $Object$varDialogArguments – A String or an Array  that contains dialog arguments of the showModalDialog function.
            @param $Integer$iHeight – dialogHeight (in pixels).
            @param $Integer$iWidth – dialogWidth (in pixels).
            @param $Object$scallbackFunction – A callback function that will be called once the modal dialog is closed
            @return $void$ - .
            */
            showModalDialog: function(url, arDialogArguments, height, width, callbackFunction) {
                if (_shouldFallbacktoMSModal()) {
                    _showMSModalDialog(url, arDialogArguments, height, width, callbackFunction);
                    return;
                }
                var bIsOverlayOpened = false;
                var overlayElement = $("#_popOversContainer > #po0");
                if (overlayElement.length > 0 && overlayElement.css("visibility") !== "hidden")
                    bIsOverlayOpened = true;
                if (!(window.frameElement && window.frameElement.id === "pzDisplayModalDialog") && pega.ui &&
                    pega.ui.Doc && pega.ui.Doc.prototype && typeof pega.ui.Doc.prototype.processActionModal ==
                    "function" && !bIsOverlayOpened) {
                    _showModalDialog(url, arDialogArguments, height, width, callbackFunction);
                } else if (window.$) { // Test if jquery is loaded.
                    _showJqueryModalDialog(url, arDialogArguments, height, width, callbackFunction);
                } else {
                    alert(
                        "pega.openUrlInModal.showModalDialog is missing some javascript modules to work correctly"
                    );
                }
            },
            getCurrentUrl: function() {
                var elWrapper = document.getElementById("pzDisplayModalDialogWrapper");
                /*BUG-434036 : adding onload to dismiss modal in image picker. pzDisplayModalDialogLoaderOnLoad is in pzDisplayModalDialog HTML*/
                var elFrame = $("<iframe src='" + _url +
                    "' name='pzDisplayModalDialog' frameborder='0' style='width:" + _width + 
                    "px; height:" + _height + "px;' id='pzDisplayModalDialog' onload=\"pzDisplayModalDialogLoaderOnLoad(this,'pzDisplayModalDialog'," + _isOverlay +
                    " );\"></iframe>");
                elWrapper.appendChild(elFrame[0]);
                _url = "";
                _width = "";
                _height = "";
                elFrame.ready(function() {
                    var pzDisplayModalDialogWindow = window.frames["pzDisplayModalDialog"];
                    pzDisplayModalDialogWindow.gsServerReqURI = window.gsServerReqURI;
                    pzDisplayModalDialogWindow.dialogArguments = window.dialogArguments;
                    /* BUG-211056: passing change tracker map object - START */
                    pzDisplayModalDialogWindow.dialogChangeTrackerMap = pega.ui.ChangeTrackerMap;
                    /* BUG-211056: passing change tracker map object - END */
                    pzDisplayModalDialogWindow.returnValue = undefined;
                    if (_isOverlay) {
                        $(".overlayPO").attr("style", "left: " + $(".modal-overlay").offset().left +
                            "px; top: " + $(".modal-overlay").offset().top +
                            "px; z-index:    100; visibility: visible;"                        );
                        // override default window.close() function for target page
                        // set the return value in the window object and call the close container action
                        pzDisplayModalDialogWindow.closeModal = function() {
                            window.returnValue = pzDisplayModalDialogWindow.returnValue;
                            if (typeof pega.u.d.processOnFrameLoads != "undefined") {
                                pega.util.Event.removeListener(pzDisplayModalDialogWindow.frameElement,
                                    "load", pega.u.d.processOnFrameLoads);
                            }
                            pzDisplayModalDialogWindow.frameElement.src = 'javascript:false';
                            $(pzDisplayModalDialogWindow.frameElement).remove();
                            var popover = pega.u.d.getPopOver();
                            if (popover) popover.close();
                            pzDisplayModalDialogWindow.closeModal = undefined;
                            pzDisplayModalDialogWindow = null;
                        };
                    } else {
                        // override default window.close() function for target page
                        // set the return value in the window object and call the close container action
                        pzDisplayModalDialogWindow.closeModal = function() {
                            window.returnValue = pzDisplayModalDialogWindow.returnValue;
                            if (typeof pega.u.d.processOnFrameLoads != "undefined") {
                                pega.util.Event.removeListener(pzDisplayModalDialogWindow.frameElement,
                                    "load", pega.u.d.processOnFrameLoads);
                            }
                            pzDisplayModalDialogWindow.frameElement.src = 'javascript:false';
                            $(pzDisplayModalDialogWindow.frameElement).remove();
                            $("#container_close").click();
                            pzDisplayModalDialogWindow.closeModal = undefined;
                            pzDisplayModalDialogWindow = null;
                            pega.u.d.modalResizeObj.reset();
                            $(".yui-resize-status").remove();
                        };
                        // Get the title from the iframe and overwrite the modal window title
                        var modalTitle = pzDisplayModalDialogWindow.document.title;
                        if ($("#modaldialog_hd_title")[0]) $("#modaldialog_hd_title")[0].innerHTML =
                            modalTitle;
                    }
                    /* Updating change tracker object with parent change tracker object */
                    try {
                        if (pzDisplayModalDialogWindow.dialogChangeTrackerMap && pega.u.d.getThreadName() ===
                            pzDisplayModalDialogWindow.pega.u.d.getThreadName() &&
                            pzDisplayModalDialogWindow.pega && pzDisplayModalDialogWindow.pega.ui &&
                            pzDisplayModalDialogWindow.pega.ui.ChangeTrackerMap) {
                            var _trackerID = pzDisplayModalDialogWindow.pega.ui.ChangeTrackerMap.getTracker()
                                .id;
                            if (_trackerID == null || typeof(_trackerID) == "undefined") {
                                pzDisplayModalDialogWindow.pega.ui.ChangeTrackerMap =
                                    pzDisplayModalDialogWindow.dialogChangeTrackerMap;
                            }
                        }
                    } catch (e) {}
                });
            }
        }
    })(pega);
}
//static-content-hash-trigger-GCC
(function(pega) {
  if (!pega.control) {
    pega.c = pega.namespace("pega.control");
  } else {
    pega.c = pega.control;
  }
  if (!pega.c.AttachUtil) {
    /*-----------------------------------------
         * Utility methods for attachments
         *-----------------------------------------*/
    var isBlank = function(sval) {
      return (!sval || sval.trim() === "");
    };
    var hasValue = function(sval) {
      return !isBlank(sval);
    };
    var setUploadEncoding = function(oForm) {
      oForm.encoding = "multipart/form-data";
    };
    var setFormEncoding = function(oForm) {
      oForm.encoding = "application/x-www-form-urlencoded";
    };
    var browserSupportsFileList = function() {
      return (window.File && window.FileReader && window.FileList);
    };
    var getTopWindow = function() {
      var dtWin = pega.desktop.support.getDesktopWindow();
      return (dtWin ? dtWin : window);
    };
    var haveDocumentViewer = function() {
      var launchBox = pega.mobile.hybrid.getLaunchBox();
      return (launchBox && launchBox.DocumentViewer);
    };
    var isMobileBrowser = function() {
      return /Android|webOS|iPhone|iPad|iPod|IEMobile|BlackBerry/i.test(navigator.userAgent);
    };
    var isPIMC = navigator.userAgent.indexOf("PegaMobile") > -1;
    var getSourceElem = function(event) {
      var src;
      if (!event) {
        // If caller does not, or cannot, pass event, try one last time to get it from the call stack.
        event = this.getRunScriptEvent();
      }
      if (event) {
        src = event.srcElement ? event.srcElement : event.target;
      }
      return src;
    };
    /* Checks if user has an auth token for the storage location (or does not need one)*/
    var checkAppStorageOkToAttach = function(tokenCallback) {
      var strUrlSF = SafeURL_createFromURL(pega.u.d.url);
      strUrlSF.put("pyActivity", "pzAppStorageOkToAttachFile");
      var callBack = {
        success: function(response) {
          var authenticated = response.responseText;
          tokenCallback(authenticated);
        }
      };
      var response = pega.u.d.asyncRequest('GET', strUrlSF, callBack, null, null);
      return response;
    };
    var previewInPIMC = function(relativeUrl, event, isAbsUrl, switchToLocal) {
      var absUrl = isAbsUrl ? relativeUrl : window.location.protocol + "//" + window.location.host + relativeUrl;

      var cbFunctions = function(switchToLocal, success) {
        if (success) {
          return function() {
            console.debug('Attachment opened successfully' + switchToLocal);
            // console.log(this);
            if (switchToLocal) pega.u.d.ServerProxy.setDestination(pega.u.d.ServerProxy.DESTINATION
                                                                   .LOCAL);
          };
        } else {
          return function(error) {
            var errorMessage = 'Failed to open attachment "' + absUrl + '"';
            if (error) {
              errorMessage += '. Reason: ' + error.description;
            }
            console.error(errorMessage);
            if (switchToLocal) pega.u.d.ServerProxy.setDestination(pega.u.d.ServerProxy.DESTINATION
                                                                   .LOCAL);
          };
        }
      };
      // call Hybrid Client API
      // bajaa for TASK-475834 enhanced to support switching back

      pega.mobile.sdk.plugins.documents.preview(absUrl).then(function() {
        console.debug("Attachment downloaded and previewed with success");
        cbFunctions(switchToLocal, true)();
      }).catch(function() {
        cbFunctions(switchToLocal)();
      });

    };
    var showInDocViewer = function(relativeUrl, event, isAbsUrl, switchToLocal) {
      var absUrl = isAbsUrl ? relativeUrl : window.location.protocol + "//" + window.location.host +
          relativeUrl;
      // BUG-244487 : shows indicator on download progress
      var busyInd = new pega.ui.busyIndicator("", true, null);
      var srcElem = getSourceElem(event);
      if (srcElem) {
        busyInd.setTargetElement(srcElem);
      }
      busyInd.show();
      var cbFunctions = function(switchToLocal, success) {
        if (success) {
          return function() {
            console.debug('Attachment opened successfully' + switchToLocal);
            // console.log(this);
            busyInd.hide();
            if (switchToLocal) pega.u.d.ServerProxy.setDestination(pega.u.d.ServerProxy.DESTINATION
                                                                   .LOCAL);
          };
        } else {
          return function(error) {
            console.error('Failed to open attachment: ' + error.description);
            busyInd.hide();
            if (switchToLocal) pega.u.d.ServerProxy.setDestination(pega.u.d.ServerProxy.DESTINATION
                                                                   .LOCAL);
          };
        }
      };
      // call Hybrid Client API
      // bajaa for TASK-475834 enhanced to support switching back
      var cbDocViewer = {
        onSuccess: cbFunctions(switchToLocal, true),
        onProgress: function() {},
        onFailure: cbFunctions(switchToLocal)
      };
      pega.mobile.hybrid.getLaunchBox().DocumentViewer.open(absUrl, {}, cbDocViewer);
    };
    var displayAttachment = function(downloadUrl, downloadURLFromInlinePreview, event, useInlineView,
                                      attachmentMetadataObj) {
      var elemId = "ATTACHMENT-DATA";
      var useExternalViewer = "false";
      if (useInlineView && attachmentMetadataObj !== undefined && attachmentMetadataObj !== null) {
        var currentPreviewID = attachmentMetadataObj.uniqueID;
        var isHeaderRequired = attachmentMetadataObj.isHeaderRequired;
        var isDownloadRequired = attachmentMetadataObj.isDownloadRequired;
        var previewWrapperDiv = attachmentMetadataObj.targetDiv;
        var displayType = attachmentMetadataObj.displayType;
        var configuredHeight = attachmentMetadataObj.height;
        var configuredWidth = attachmentMetadataObj.width;
        var fallbackThumbnail = attachmentMetadataObj.fallbackThumbnail;
        var maintainAspectRatio = attachmentMetadataObj.maintainAspectRatio;
        if (attachmentMetadataObj.doNotUseEV !== "true" && pega.c.EVAUtil) {
          var evDetails = pega.c.EVAUtil.getExternalViewerDetails(attachmentMetadataObj);
          useExternalViewer = evDetails.useExternalViewer;
        } else {
          useExternalViewer = "false";
        }
        if (useExternalViewer === "false" && isOfficeAttachment(attachmentMetadataObj.fileType)) {
          useInlineView = false;
        }
      }
      var windowParams = "resizable=yes,scrollbars=yes,status=yes";
      var createTempFrame = function() {
        var tempFrame = document.createElement('iframe');
        tempFrame.id = elemId;
        tempFrame.style.display = 'none';
        document.body.appendChild(tempFrame);
        return tempFrame;
      };

      function createWrapperDiv(style) {
        var wrapperDiv = document.getElementById("ATTACHMENT-WRAPPER-DIV");
        if (wrapperDiv != null) {
          $("#ATTACHMENT-WRAPPER-DIV").remove();
        }
        wrapperDiv = document.createElement('div');
        wrapperDiv.id = "ATTACHMENT-WRAPPER-DIV";
        wrapperDiv.setAttribute('class', style);
        document.body.appendChild(wrapperDiv);
        return wrapperDiv;
      }

      function createHeader(targetDiv, style) {
        targetDiv.innerHTML = '<div id="ATTACHMENT-PREVIEW-HEADER" class="' + style + '"></div>';
        var headerDiv = document.getElementById("ATTACHMENT-PREVIEW-HEADER");
        headerDiv.innerHTML =
          '<div id="ATTACHMENT-PREVIEW-HEADER-INFO" class="attachment-inline-preview-header-info"></div>';
        headerDiv.innerHTML = headerDiv.innerHTML +
          '<div id="ATTACHMENT-PREVIEW-HEADER-DOWNLOAD-LINK" class="attachment-inline-preview-header-download-link"></div>';
        headerDiv.innerHTML = headerDiv.innerHTML +
          '<div id="ATTACHMENT-PREVIEW-HEADER-CLOSE-LINK" class="attachment-inline-preview-header-close-link"></div>';
        if (isHeaderRequired !== "false") {
          createHeaderInfoPart(document.getElementById("ATTACHMENT-PREVIEW-HEADER-INFO"));
        }
        if (isDownloadRequired !== "false") {
          createHeaderDownloadLinkPart(document.getElementById(
            "ATTACHMENT-PREVIEW-HEADER-DOWNLOAD-LINK"));
        }
        createHeaderCloseLinkPart(document.getElementById("ATTACHMENT-PREVIEW-HEADER-CLOSE-LINK"));
      }

      function createHeaderInfoPart(targetDiv) {
        var headerTitle = attachmentMetadataObj.fileName;
        var titleClass = "attachment-inline-preview-header-info-title";
        var titleHTML = '<div id="ATTACHMENT-PREVIEW-HEADER-INFO-TITLE" class="' + titleClass + '"><h1>' +
            headerTitle + '<span>.' + attachmentMetadataObj.fileType + '</span></h1></div>';
        targetDiv.innerHTML = targetDiv.innerHTML + titleHTML;
        var fileType = getFileTypeFromExtension(attachmentMetadataObj.fileType);
        var uploadedOn = attachmentMetadataObj.uploadedOn;
        var uploadedBy = attachmentMetadataObj.uploadedBy;
        var attachmentMetadata = fileType + " | " + uploadedOn + " " + uploadedBy;
        var metaClass = "attachment-inline-preview-header-info-meta";
        var metaHTML = '<div id="ATTACHMENT-PREVIEW-HEADER-INFO-META" class="' + metaClass + '">' +
            attachmentMetadata + '</div>';
        targetDiv.innerHTML = targetDiv.innerHTML + metaHTML;
      }

      function createHeaderDownloadLinkPart(targetDiv) {
        var downloadLinkClass = "attachment-inline-preview-header-links-download";
        var downloadLinkText = pega.u.d.fieldValuesList.get("pzDownload") + " " + attachmentMetadataObj.fileType
        .toUpperCase();
        var downloadLinkHTML = '<a id="inlineDownload" tabindex=0 role="link" title="' +
            downloadLinkText + '" class="' + downloadLinkClass +
            '"><i class="pi pi-download"></i> <span>' + downloadLinkText + '</span></a>';
        targetDiv.innerHTML = targetDiv.innerHTML + downloadLinkHTML;
        var action_downloadAttachment = function(e) {
          if (downloadURLFromInlinePreview == null) {
            alert(pega.u.d.fieldValuesList.get("pzAttachDownloadURLBroken"));
            return;
          }
          if (isMobileBrowser()) {
            if ($('html').hasClass("iOS")) {
              window.openUrlInWindow(downloadURLFromInlinePreview, "Attachment", windowParams);
            } else {
              downloadAttachmentUsingURL(downloadURLFromInlinePreview);
            }
          } else {
            downloadAttachmentUsingURL(downloadURLFromInlinePreview);
          }
        };
        $(document).on("click", "#inlineDownload", action_downloadAttachment);
        $(document).on("keypress", "#inlineDownload", function(event) {
          if (event.which === 13 || event.keyCode === 13) {
            action_downloadAttachment(event);
          }
        });
      }

      function createHeaderCloseLinkPart(targetDiv) {
        var closeLinkClass = "attachment-inline-preview-header-links-close";
        var closeTooltip = pega.u.d.fieldValuesList.get("pzClose");
        var closeLinkHTML = '<a id="inlineClose" tabindex=0 role="link" title="' + closeTooltip +
            '" class="' + closeLinkClass + '"><i class="pi pi-times"/></a>';
        targetDiv.innerHTML = targetDiv.innerHTML + closeLinkHTML;
        $(document).on('click', '#inlineClose', function() {
          $("#ATTACHMENT-WRAPPER-DIV").remove();
        });
        $(document).on('keypress', '#inlineClose', function(event) {
          if (event.which === 13 || event.keyCode === 13) {
            $("#ATTACHMENT-WRAPPER-DIV").remove();
          }
        });
      }

      function createContentDiv(targetDiv, style) {
        var contentDivId = "ATTACHMENT-PREVIEW-CONTENT" + currentPreviewID;
        targetDiv.innerHTML = targetDiv.innerHTML + '<div id="' + contentDivId + '" class="' + style +
          '"></div>';
        return document.getElementById('ATTACHMENT-PREVIEW-CONTENT' + currentPreviewID);
      }

      function renderMediaAttachment(url, fileType) {
        url = url + "&viewInline=true";
        if (isImageAttachment(fileType)) {
          var imageTag = document.createElement('img');
          imageTag.setAttribute('class',
                                'attachment-inline-preview-content-img attachment-inline-preview-content-img' +
                                currentPreviewID);
          imageTag.setAttribute('style', 'display:none;');
          imageTag.onerror = function() {
            handleBrokenMediaLink("image");
          }
          if (maintainAspectRatio !== "false") {
            imageTag.onload = function() {
              checkAndCorrectMediaDimension("image");
            };
          } else {
            stopPreviewLoadingThrobber();
            imageTag.setAttribute('style', 'display:block;');
            imageTag.setAttribute('width', configuredWidth);
            imageTag.setAttribute('height', configuredHeight);
          }
          imageTag.src = downloadUrl + "&viewInline=true";
          if (isMobileBrowser()) {
            $(document).on('click', '.attachment-inline-preview-content-img' + currentPreviewID,
                           function() {
              $('.attachment-inline-preview-content-img' + currentPreviewID).toggleClass(
                'zoom-in-inline-img');
            });
          }
          return imageTag;
        }
        if (isVideoAttachment(fileType)) {
          var videoTag = document.createElement('video');
          var extension = attachmentMetadataObj.fileType;
          if (extension === "ogv") extension = "ogg";
          if (extension === "m4v") extension = "mp4";
          if (displayType !== 'embed') {
            videoTag.setAttribute("autoplay", "");
          }
          videoTag.setAttribute("controls", "");
          videoTag.preload = "auto";
          videoTag.setAttribute('class',
                                'attachment-inline-preview-content-video attachment-inline-preview-content-video' +
                                currentPreviewID);
          if (isMobileBrowser()) {
            stopPreviewLoadingThrobber();
          } else {
            videoTag.setAttribute('style', 'display:none;');
          }
          if (maintainAspectRatio !== "false") {
            videoTag.onloadeddata = function() {
              checkAndCorrectMediaDimension("video");
            };
          } else {
            stopPreviewLoadingThrobber();
            videoTag.setAttribute('style', 'display:block;width:' + configuredWidth + 'px;height:' +
                                  configuredHeight + 'px;');
          }
          videoTag.onerror = function() {
            handleBrokenMediaLink("video");
          }
          var srcTag = document.createElement('source');
          srcTag.type = "video/" + extension;
          srcTag.onerror = function() {
            handleBrokenMediaLink("video");
          }
          srcTag.src = url;
          videoTag.appendChild(srcTag);
          return videoTag;
        }
      }

      function renderPDFAttachment(url, fileName, mediaWrapper) {
        if (useExternalViewer === "true") {
          url = pega.c.EVAUtil.modifyURLForExternalViewer(evDetails, attachmentMetadataObj, url);
        } else {
          url = url + "&viewInline=true";
        }
        var pdfTag = document.createElement('iframe');
        var browser = window.navigator.userAgent;
        if (!(browser.indexOf("Trident/") > 0 || browser.indexOf("Edge/") > 0)) {
          pdfTag.style.position = "absolute";
          pdfTag.style.left = "-9999px";
          pdfTag.onload = function() {
            pdfLoader(pdfTag, true);
          }
        } else {
          pdfLoader(pdfTag, false, mediaWrapper);
        }
        if (useExternalViewer === "false") {
          if (url !== undefined && url !== null && url !== "") {
            if (browser.indexOf("Trident/") > 0) {
              pdfTag.src = url + "&viewPDFInline=true";
            } else {
              var urlStr = url + "&viewPDFInline=true&fileName=" + fileName;
              var tempSafeURL = SafeURL_createFromURL(urlStr);
              pdfTag.src = tempSafeURL.toURL();
            }
          } else {
            pdfTag.src = "";
          }
        } else {
          pdfTag.src = url;
        }
        return pdfTag;
      }

      function pdfLoader(pdfTag, isNonIE, mediaWrapper) {
        var dimension = getContentPreviewDimension("pdf");
        var contentHeightLimit = dimension[0];
        var contentWidthLimit = dimension[1];
        stopPreviewLoadingThrobber();
        if (isNonIE) {
          pdfTag.height = contentHeightLimit;
          pdfTag.width = contentWidthLimit;
        } else {
          mediaWrapper.style.height = contentHeightLimit + "px";
          mediaWrapper.style.width = contentWidthLimit + "px";
          pdfTag.style.height = "100%";
          pdfTag.style.width = "100%";
        }
        setContentPreviewDimension(contentHeightLimit, contentWidthLimit);
        if (isNonIE) {
          pdfTag.style.position = "inherit";
          pdfTag.style.left = "0";
        }
        setPostPreviewActionFocus();
      }

      function checkAndCorrectMediaDimension(mediaType) {
        var mediaClass = (mediaType === "image") ? "attachment-inline-preview-content-img" +
            currentPreviewID : "attachment-inline-preview-content-video" + currentPreviewID;
        var mediaObj = document.getElementsByClassName(mediaClass)[0];
        if (isMobileBrowser() && mediaType !== "image") {
          mediaObj.style.display = "none";
        }
        var dimension = getContentPreviewDimension(mediaType);
        var contentHeightLimit = dimension[0];
        var contentWidthLimit = dimension[1];
        stopPreviewLoadingThrobber();
        var currentMediaHeight = 0;
        var currentMediaWidth = 0;
        if (mediaType === "image") {
          currentMediaHeight = mediaObj.naturalHeight;
          currentMediaWidth = mediaObj.naturalWidth;
        } else {
          currentMediaHeight = mediaObj.videoHeight;
          currentMediaWidth = mediaObj.videoWidth;
        }
        if (parseInt(contentWidthLimit) === 0) {
          mediaObj.setAttribute('style', 'display:block;width: 100%; height: 100%');
          setPostPreviewActionFocus();
          return;
        }
        if (parseInt(contentHeightLimit) === 0) {
          contentHeightLimit = Math.round((currentMediaHeight / currentMediaWidth) * contentWidthLimit);
        }
        while (currentMediaHeight > contentHeightLimit || currentMediaWidth > contentWidthLimit) {
          if (currentMediaHeight > contentHeightLimit) {
            setContentPreviewDimension(contentHeightLimit, ((contentHeightLimit / currentMediaHeight) *
                                                            currentMediaWidth));
          } else if (currentMediaWidth > contentWidthLimit) {
            setContentPreviewDimension(((contentWidthLimit / currentMediaWidth) * currentMediaHeight),
                                       contentWidthLimit);
          }
          currentMediaHeight = Math.round($("#ATTACHMENT-PREVIEW-CONTENT" + currentPreviewID +
                                            " > span").height());
          currentMediaWidth = Math.round($("#ATTACHMENT-PREVIEW-CONTENT" + currentPreviewID +
                                           " > span").width());
        }
        mediaObj.height = currentMediaHeight;
        mediaObj.width = currentMediaWidth;
        mediaObj.setAttribute('style', 'display:block;');
        setPostPreviewActionFocus();
      }

      function getContentPreviewDimension(attachType) {
        var contentHeightLimit = 0;
        var contentWidthLimit = 0;
        if (displayType !== 'embed') {
          contentHeightLimit = Math.round($("#ATTACHMENT-WRAPPER-DIV").height() - $(
            "#ATTACHMENT-PREVIEW-HEADER").height() - 35);
          contentWidthLimit = Math.round($("#ATTACHMENT-WRAPPER-DIV").width() - 28);
          if (isMobileBrowser()) {
            contentWidthLimit = contentWidthLimit + 28;
          }
        } else {
          contentHeightLimit = parseInt(configuredHeight);
          contentWidthLimit = parseInt(configuredWidth);
          if (contentWidthLimit === 0) {
            contentWidthLimit = Math.round(document.getElementById(previewWrapperDiv).offsetWidth);
          }
          if (contentHeightLimit === 0 && attachType === "pdf") {
            contentHeightLimit = Math.round(contentWidthLimit * (842 / 595));
          }
        }
        var dimension = [contentHeightLimit, contentWidthLimit];
        return dimension;
      }

      function setContentPreviewDimension(contentHeightLimit, contentWidthLimit) {
        $("#ATTACHMENT-PREVIEW-CONTENT" + currentPreviewID + " > span").width(contentWidthLimit);
        $("#ATTACHMENT-PREVIEW-CONTENT" + currentPreviewID + " > span").height(contentHeightLimit);
      }

      function setPostPreviewActionFocus() {
        if (displayType !== 'embed') {
          if (isDownloadRequired !== "false") {
            $("#inlineDownload").focus();
          } else {
            $("#inlineClose").focus();
          }
        }
      }

      function handleBrokenMediaLink(type) {
        stopPreviewLoadingThrobber();
        var errMsgWithStyle = "";
        /*var errMsg = (type === "video" ? pega.u.d.fieldValuesList.get("pzVideoLoadFail") : pega.u.d.fieldValuesList.get("pzImageLoadFail"));*/
        if (displayType !== 'embed') {
          var errMsg = pega.u.d.fieldValuesList.get("pzAttachmentNotFound");
          var errMsgStyle = 'color:#fff';
          errMsgWithStyle = "<b style='" + errMsgStyle + "'>" + errMsg + "</b>";
        } else {
          errMsgWithStyle = "<img src = '" + fallbackThumbnail + "' width='44' height='44'>"
        }
        document.getElementById("INLINE-PREVIEW-MEDIA-WRAPPER" + currentPreviewID).innerHTML =
          errMsgWithStyle;
      }

      function stopPreviewLoadingThrobber() {
        if (document.getElementById("IMG_SHOW_THROBBER_BEFORE_LOAD" + currentPreviewID)) {
          document.getElementById("IMG_SHOW_THROBBER_BEFORE_LOAD" + currentPreviewID).remove();
        }
      }

      function downloadAttachmentIniFrame(url, useInlineView) {
        if (attachmentMetadataObj != null && useExternalViewer === "false") {
          var isPreviewCandidate = isInlineViewCandiadate(attachmentMetadataObj.fileType);
          if (!isPreviewCandidate) {
            useInlineView = false;
          }
        }
        if (useInlineView && attachmentMetadataObj != null) {
          processInlinePreview(url);
        } else {
          downloadAttachmentUsingURL(url);
        }
      }

      function processInlinePreview(url) {
        var wrapperDiv = previewWrapperDiv;
        if (wrapperDiv === undefined || wrapperDiv === null || wrapperDiv === "") {
          wrapperDiv = createWrapperDiv('attachment-inline-preview-wrapper');
        } else {
          wrapperDiv = document.getElementById(wrapperDiv);
        }
        if (displayType !== 'embed') {
          createHeader(wrapperDiv, 'attachment-inline-preview-header');
        }
        var contentDiv = createContentDiv(wrapperDiv, 'attachment-inline-preview-content');
        if (displayType === 'embed') {
          contentDiv.classList.add('attachment-inline-preview-content-embed');
        }
        var mediaWrapper = document.createElement('span');
        var imageTag = document.createElement('img');
        imageTag.src = "webwb/pzLoadingBarAnimation.gif";
        imageTag.id = "IMG_SHOW_THROBBER_BEFORE_LOAD" + currentPreviewID;
        contentDiv.appendChild(imageTag);
        if (useExternalViewer !== "true" || isVideoAttachment(attachmentMetadataObj.fileType)) {
          mediaWrapper.id = "INLINE-PREVIEW-MEDIA-WRAPPER" + currentPreviewID;
          if (isMediaAttachment(attachmentMetadataObj.fileType)) {
            mediaWrapper.appendChild(renderMediaAttachment(url, attachmentMetadataObj.fileType));
            contentDiv.appendChild(mediaWrapper);
          } else if (attachmentMetadataObj.fileType.toLowerCase() === "pdf") {
            mediaWrapper.appendChild(renderPDFAttachment(url, attachmentMetadataObj.fileName,
                                                         mediaWrapper));
            contentDiv.appendChild(mediaWrapper);
          } else {
            downloadAttachmentUsingURL(url);
          }
        } else {
          mediaWrapper.appendChild(renderPDFAttachment(url, attachmentMetadataObj.fileName,
                                                       mediaWrapper));
          contentDiv.appendChild(mediaWrapper);
        }
      }

      function downloadAttachmentUsingURL(url) {
        var elem = getTopWindow().document.getElementById(elemId);
        if (elem === null) {
          elem = document.getElementById(elemId);
        }
        if (elem === null) {
          elem = createTempFrame();
        }
        elem.src = url;
      }
      try {
        if (haveDocumentViewer()) {
          showInDocViewer(downloadUrl, event);
        }
        else if (isPIMC) {
          previewInPIMC(downloadUrl, event);
        }
        else if (isMobileBrowser()) {
          // BUG-307062: Download attachments in the same window in mobile browsers for Android
          // iOS doesn't download in iFrame but creates image tag in iFrame. So download in new window.                    
          if (useInlineView) {
            downloadAttachmentIniFrame(downloadUrl, useInlineView);
          } else {
            if ($('html').hasClass("iOS")) {
              window.openUrlInWindow(downloadUrl, "Attachment", windowParams);
            } else {
              downloadAttachmentIniFrame(downloadUrl);
            }
          }
        } else if (document.addEventListener) // feature detection for IE9+ browsers
        {
          downloadAttachmentIniFrame(downloadUrl, useInlineView);
        } else {
          // Eng-10954/SR-103684/Bug-138864/Bug-140892 : kumad1 04/15/14
          window.open(downloadUrl, "Attachment", windowParams);
        }
      } catch (E) {
        console.error("Error displaying attachment: ", downloadUrl, E);
        var tempFrame = createTempFrame();
        tempFrame.src = downloadUrl;
      }
    };
    var isInlineViewCandiadate = function(attachmentType) {
      if (attachmentType === undefined) {
        return false;
      }
      return (isMediaAttachment(attachmentType)) || (attachmentType.toLowerCase() === "pdf");
    };
    var isMediaAttachment = function(attachmentType) {
      return (isImageAttachment(attachmentType) || isVideoAttachment(attachmentType) || isAudioAttachment(
        attachmentType));
    };
    var isImageAttachment = function(attachmentType) {
      attachmentType = attachmentType.toLowerCase();
      return (attachmentType === "png" || attachmentType === "jpg" || attachmentType === "jpeg" ||
              attachmentType === "bmp" || attachmentType === "gif" || ((attachmentType === "tif" ||
                                                                        attachmentType === "tiff") && isSafariOrEdgeOrIE()));
    };
    var isVideoAttachment = function(attachmentType) {
      attachmentType = attachmentType.toLowerCase();
      if (attachmentType === "mp4" || attachmentType === "m4v") {
        return true;
      } else {
        if (!isSafariOrEdgeOrIE()) {
          return (attachmentType === "webm" || attachmentType === "ogg" || attachmentType === "ogv");
        } else {
          return false;
        }
      }
    };
    var isAudioAttachment = function(attachmentType) {
      attachmentType = attachmentType.toLowerCase();
      return (attachmentType === "mp3" || attachmentType === "wav");
    };
    var isOfficeDocAttachment = function(attachmentType) {
      attachmentType = attachmentType.toLowerCase();
      return (attachmentType === "doc" || attachmentType === "docx");
    };
    var isOfficeExcelAttachment = function(attachmentType) {
      attachmentType = attachmentType.toLowerCase();
      return (attachmentType === "xls" || attachmentType === "xlsx");
    };
    var isOfficePPTAttachment = function(attachmentType) {
      attachmentType = attachmentType.toLowerCase();
      return (attachmentType === "ppt" || attachmentType === "pptx");
    };
    var isOfficeAttachment = function(attachmentType) {
      return (isOfficeDocAttachment(attachmentType) || isOfficeExcelAttachment(attachmentType) ||
              isOfficePPTAttachment(attachmentType));
    };
    var getFileTypeFromExtension = function(attachmentType) {
      attachmentType = attachmentType.toLowerCase();
      if (isImageAttachment(attachmentType) || attachmentType === "tif" || attachmentType === "tiff")
        return pega.u.d.fieldValuesList.get("pzImage");
      if (isVideoAttachment(attachmentType)) return pega.u.d.fieldValuesList.get("pzVideo");
      if (isAudioAttachment(attachmentType)) return pega.u.d.fieldValuesList.get("pzMusic");
      if (isOfficeDocAttachment(attachmentType)) return pega.u.d.fieldValuesList.get("pzOfcDoc");
      if (isOfficeExcelAttachment(attachmentType)) return pega.u.d.fieldValuesList.get("pzOfcExcel");
      if (isOfficePPTAttachment(attachmentType)) return pega.u.d.fieldValuesList.get("pzOfcPPT");
      if (attachmentType === "pdf") return pega.u.d.fieldValuesList.get("pzPDF");
      else {
        return attachmentType;
      }
    };
    var isSafariOrEdgeOrIE = function() {
      var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
      var browser = window.navigator.userAgent;
      if ((!isChrome && browser.indexOf("Firefox/") <= 0) && (browser.indexOf("Safari/") > 0 || browser.indexOf(
        "Trident/") > 0 || browser.indexOf("Edge/") > 0)) {
        return true;
      } else {
        return false;
      }
    };
    var setAttachmentMetadataUniqueID = function(attachmentMetadataObj) {
      if (attachmentMetadataObj !== undefined && attachmentMetadataObj !== null) {
        attachmentMetadataObj.uniqueID = new Date().getTime() + Math.floor(Math.random() * 20);
      }
    };
    var isSignatureAttachment = function(pxLinkedRefTo) {
      var attachments = pega.ui.ClientCache.find("D_pzOfflineAttachmentList");
      var attachmentIterator = (attachments && attachments.get("pxResults")) ? attachments.get("pxResults").iterator() : undefined;
      if (attachmentIterator) {
        while (attachmentIterator.hasNext()) {
          var attachment = attachmentIterator.next();
          if (pxLinkedRefTo === attachment.get("pxLinkedRefTo").getValue()) {
            return attachment.get("pyLabel").getValue() === "Signature-Attach";
          }
        }
      }
      return false;
    };
    var downloadAttachment = function(strInsKey, pxLinkedRefTo, refClass, downloadActivity, docViewerActivity,
                                       event, useInlineView, attachmentMetadataObj) {
      if ((haveDocumentViewer() || isPIMC) && hasValue(pxLinkedRefTo) && hasValue(docViewerActivity)) {
        var docViewerURL = new SafeURL(refClass + "." + docViewerActivity);
        docViewerURL.put("LinkedRefTo", pxLinkedRefTo.trim());
        pega.u.d.convertToRunActivityAction(docViewerURL);
        docViewerURL = docViewerURL.toURL(); // bajaa for TASK-475834
        var isAbsUrl, switchToLocal;
        if (pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal()) {
          if (pxLinkedRefTo.toUpperCase().indexOf("DATA-WORKATTACH-") < 0) {
            if (isPIMC && isSignatureAttachment(pxLinkedRefTo)) {
              pms.plugins.clientstore.getItemUrl('signature', pxLinkedRefTo.trim(), {decodeBase64: true, fileExtension: 'png'})
                .then(function(signatureUrl) {
                  previewInPIMC({ "id": signatureUrl }, event, true, switchToLocal);
                })
                .catch(function(error) {
                  console.error("Can't preview signature attachment " + pxLinkedRefTo + ". Reason: " + error);
                });
              return;
            } else {
              docViewerURL = pxLinkedRefTo.trim();
              isAbsUrl = true;
            }
          } else if(pxLinkedRefTo.toUpperCase().indexOf("TMP-DATA-WORKATTACH-") !== -1){ /*for PIMC offline preview old attachment mode*/
            pega.mobile.sdk.plugins.clientstore.getItem("DATA-WORKATTACH-FILE",pxLinkedRefTo.trim())
              .then(function(item){
              isAbsUrl = true;
              previewInPIMC({"id":item.url}, event, isAbsUrl,switchToLocal); /*BUG-495744*/
            }).catch(function(){
              console.log("error");
            });
            return;
          }else
            if (!pega.offline.NetworkStatus.isDataNetworkAvailable()) {
              setTimeout(function() {
                var CannotPerformWhenOffline = pega.u.d.fieldValuesList.get(
                  "CannotPerformWhenOffline");
                alert(CannotPerformWhenOffline);
                pega && pega.control && pega.control.Actions && pega.control.Actions.prototype
                  .hideSkeleton();
              }, 100);
              return;
            } else {
              pega.u.d.ServerProxy.setDestination(pega.u.d.ServerProxy.DESTINATION.REMOTE);
              switchToLocal = true;
            }
        }
        if(isPIMC){
          previewInPIMC(docViewerURL, event, isAbsUrl,switchToLocal);
        }else{
          showInDocViewer(docViewerURL, event, isAbsUrl, switchToLocal);
        }
      } else {
        var downloadURL = "";
        var downloadURLFromInlinePreview = ""
        var isMedia = false;
        var isPDF = false;
        var storage = "";
        if (useInlineView) {
          if (attachmentMetadataObj != null) {
            try {
              var attachmentType = attachmentMetadataObj.fileType;
              if (attachmentType != null && attachmentType.trim() !== "") {
                isMedia = isMediaAttachment(attachmentType.trim());
                isPDF = (attachmentType.trim().toLowerCase() === "pdf");
                storage = attachmentMetadataObj.storageType;
              }
            } catch (e) {}
          }
          if ((!isMedia && !isPDF) || storage === "External") {
            downloadURL = new SafeURL(refClass + "." + downloadActivity);
            downloadURL.put("linkInsHandle", strInsKey.trim());
          } else {
            downloadURL = new SafeURL(refClass + "." + docViewerActivity);
            downloadURL.put("LinkedRefTo", pxLinkedRefTo.trim());
          }
          downloadURLFromInlinePreview = new SafeURL(refClass + "." + downloadActivity);
          downloadURLFromInlinePreview.put("linkInsHandle", strInsKey.trim());
          pega.u.d.convertToRunActivityAction(downloadURLFromInlinePreview);
          pega.u.d.convertToRunActivityAction(downloadURL);
          downloadURLFromInlinePreview = downloadURLFromInlinePreview.toURL();
        } else {
          //BUG-608518 changes
          if (isMobileBrowser()) {
            if ($('html').hasClass("iOS")) {
              downloadURL = new SafeURL("@baseclass.pzProcessURLInWindow");
              downloadURL.put('pyPreActivity', refClass + "." + downloadActivity);
            }else{
              downloadURL = new SafeURL(refClass + "." + downloadActivity);
              pega.u.d.convertToRunActivityAction(downloadURL);
            }
          }else{
            downloadURL = new SafeURL(refClass + "." + downloadActivity);
            pega.u.d.convertToRunActivityAction(downloadURL);
          }
          downloadURL.put("linkInsHandle", strInsKey.trim());
        }
        displayAttachment(downloadURL.toURL(), downloadURLFromInlinePreview, event, useInlineView,
                          attachmentMetadataObj);
      }
    };
    var openAttachmentInOffline = function(itemType, pxLinkedRefTo) {
      if (itemType === "DATA-WORKATTACH-URL") {
        var CannotOpenUrlOnMobileApp = pega.u.d.fieldValuesList.get("CannotOpenUrlOnMobileApp");
        alert(CannotOpenUrlOnMobileApp);
      } else {
        var launchBox = pega.mobile.hybrid.getLaunchBox();
        launchBox.PRPC.ClientStore.getItem(itemType, pxLinkedRefTo).then(function(item) {
          var documentViewerCallbacks = {
            onSuccess: function() {
              console.debug("Attachment opened successfully");
            },
            onFailure: function(error) {
              console.error("Failed to open attachment: " + error.description);
            }
          };
          launchBox.DocumentViewer.open(item.url, documentViewerCallbacks);
        }, function() {
          console.error("Failed to fetch attachment URL from ClientStore.");
        });
      }
    };
    /* 	For File input element in IE, blur event is fired when the Browse button of the file input element is pressed.
        	This triggers validations even when the user is not done with chosing a file.
        	The validation alert imposes accessibility issue in chosing the file from file browser.
        	Hence delaying the validations till form submission.
        	 */
    /* 	@private
        	replaces the validationType attribute from the file input html element
        	with validationTypeBackup attribute so that the validation handlers are not
        	attached as listeners to the onblur and onchange events.
        	These events are employed to trigger client-side valiations.
        	IE triggers onblur at wrong times for file type input field.
        	 */
    var removeFileValidationTypes = function(ids) {
      var id = ids["thisId"];
      var obj = document.getElementById(id);
      if (obj != null) {
        var valType = obj.getAttribute("validationType");
        if (valType) {
          obj.setAttribute("validationTypeBackup", valType);
          obj.removeAttribute("validationType");
        }
      }
    }
    /*	@private
                restores the validationType attribute from validationTypeBackup attribute for
                the file input html element so that the validation handlers are invoked
                when the form is submitted.
                 */
    var restoreFileValidationTypes = function(ids) {
      var id = ids["thisId"];
      var obj = document.getElementById(id);
      if (obj != null) {
        var valTypeBackup = obj.getAttribute("validationTypeBackup");
        if (valTypeBackup) {
          obj.setAttribute("validationType", valTypeBackup);
          obj.removeAttribute("validationTypeBackup");
        }
      }
    }
    var onLoad = function(cbOnLoad) {
      // BUG-146964:added support for cross browser by using AddEventListener
      if (window.addEventListener) {
        window.addEventListener("load", cbOnLoad, false);
      } else if (window.attachEvent) {
        window.attachEvent("onload", cbOnLoad);
      }
    };
    pega.c.AttachUtil = {
      MULTIPART_FORM_DATA: "multipart/form-data",
      FORM_URL_ENCODED: "application/x-www-form-urlencoded",
      resetEncoding: function(oForm, form_mime_type) {
        if (oForm) {
          oForm.encoding = form_mime_type;
        }
      },
      resetEncodingFileUpload: function(oForm) {
        this.resetEncoding(oForm, this.MULTIPART_FORM_DATA);
      },
      resetEncodingForm: function(oForm) {
        this.resetEncoding(oForm, this.FORM_URL_ENCODED);
      },
      setEncoding: function(oForm, doEncodingNow, form_mime_type) {
        if (oForm) {
          if (doEncodingNow) {
            oForm.encoding = form_mime_type;
          } else {
            var cbSetUploadEncoding = function() {
              oForm.encoding = form_mime_type;
            };
            onLoad(cbSetUploadEncoding);
          }
        }
      },
      setEncodingFileUpload: function(oForm, doEncodingNow) {
        this.setEncoding(oForm, doEncodingNow, this.MULTIPART_FORM_DATA);
      },
      setEncodingForm: function(oForm, doEncodingNow) {
        this.setEncoding(oForm, doEncodingNow, this.FORM_URL_ENCODED);
      },
      isMaxFileSizeExceeded: function(maxSizeBytes, fileInput) {
        if (browserSupportsFileList() && fileInput != null) {
          var files = fileInput.files;
          for (var i = 0, filesCount = files.length; i < filesCount; ++i) {
            if (files[i].size > maxSizeBytes) {
              return true;
            }
          }
        }
        return false;
      },
      showMaxFileSizeViolation: function(event) {
        pega.u.d.reloadSection(null, "pyMaxFileSizeViolation", "", false, false, null, null, event);
      },
      getSelectedFileName: function(fileInput) {
        var selFileName = "",
            fileName;
        if (fileInput != null) {
          if (browserSupportsFileList()) {
            var files = fileInput.files;
            for (var i = 0, filesCount = files.length; files != null && i < filesCount; ++i) {
              fileName = files[i].name;
              if (isBlank(fileName)) {
                fileName = files[i].value;
              }
              if (hasValue(fileName)) {
                selFileName += fileName + ":";
              }
            }
          } else {
            fileName = fileInput.getAttribute("value");
            if (isBlank(fileName)) {
              fileName = fileInput.value;
            }
            if (hasValue(fileName)) {
              selFileName = fileName;
            }
          }
        }
        return selFileName;
      },
      deferValidationUntilSubmit: function(fileInputId) {
        var idObj = {
          thisId: fileInputId
        };
        removeFileValidationTypes(idObj);
        if (!isRegisteredOnBeforeSubmit(restoreFileValidationTypes)) {
          pega.u.d.registerOnBeforeSubmit(restoreFileValidationTypes, idObj);
        }
      },
      // pega.util.event.getEvent() does not recognize the event
      // in the call stack for "runScript" action from menu click events.
      getRunScriptEvent: function() {
        var ev = window.event;
        if (!ev) {
          var cllr = this.getRunScriptEvent.caller;
          while (cllr) {
            for (var ix = 0; ix < cllr.arguments.length; ++ix) {
              ev = cllr.arguments[ix];
              if (ev && (ev.srcElement || ev.target)) {
                return ev;
              }
            }
            cllr = cllr.caller;
          }
        }
        return undefined;
      },
      checkStorageAuthAndExecute: function(event, cbProcess, authorizationSectionName) {
        var cbOAuthFirst = function(authenticated) {
          if (authenticated === "true") {
            /* go straight to the file prompt, and avoid any more auth code */
            cbProcess();
            return;
          }
          // Save reference to original flow action callback, so we can restore when login flow is completed.
          var cbFlowActionOrig = pega.u.d.performFlowACallback;
          var cbAfterLogin = function(oResponse, containerNode, closeReason) {
            var cbOAuthAfterLogin = function(authenticated) {
              // If logged in, go ahead and upload attachment via callback
              if (authenticated === "true") {
                cbProcess();
              }
            };
            // Restore original callback
            pega.u.d.performFlowACallback = cbFlowActionOrig;
            // Call original callback (closes modal)
            cbFlowActionOrig(oResponse, containerNode, closeReason);
            // Check token again to make sure login successful
            checkAppStorageOkToAttach(cbOAuthAfterLogin)
          };
          if (isBlank(authorizationSectionName)) {
            authorizationSectionName = "pzCheckContentStorageTarget";
          }
          /* need to prompt for some authentication details before we can store the file */
          pega.u.d.performFlowACallback = cbAfterLogin;
          var srcElement = getSourceElem(event);
          pega.u.d.processAction(authorizationSectionName, "", "", "", "", "popup", "", "", "",
                                 srcElement);
        };
        /* need to check if storage is okay on-click because App setting or token status could have changed since form loaded*/
        if (pega.u.d.ServerProxy && pega.u.d.ServerProxy.isDestinationLocal()) {
          cbOAuthFirst("true");
        } else checkAppStorageOkToAttach(cbOAuthFirst);
      },
      checkWebStorageTokenAndExecute: function(event, cbProcess, authorizationSectionName) {
        this.checkStorageAuthAndExecute(event, cbProcess, authorizationSectionName);
      },
      checkTokenAndDownloadAttachment: function(event, strInsKey, pxLinkedRefTo, refClass,
                                                 downloadActivity, docViewerActivity, useInlineView, attachmentMetadataObj, pxLinkedClassTo) {
        var isPIMC = navigator.userAgent.indexOf("PegaMobile") > -1;
        if (pxLinkedRefTo === "" && pega.mobile && pega.mobile.isPegaElectronContainer) {
          // the case is for electron.. BUG-329099, needs proper handling BAJAA added new feildvalue for BUG-329679
          var CannotPerformWhenOffline = pega.u.d.fieldValuesList.get(
            "OfflineApplicationGettingSynchronized");
          alert(CannotPerformWhenOffline);
          if (pega && pega.control && pega.control.Actions) {
            pega.control.Actions.prototype.hideSkeleton();
          }
          return;
        }
        var cbProcess = function() {
          setAttachmentMetadataUniqueID(attachmentMetadataObj);
          downloadAttachment(strInsKey, pxLinkedRefTo, refClass, downloadActivity,
                             docViewerActivity, event, useInlineView, attachmentMetadataObj);
        };
        var isNewAttachMode = navigator.userAgent.indexOf("AmpWebControl") > -1 || navigator.userAgent
        .indexOf("PegaElectronContainer") > -1 || isPIMC;
        var that = this;
        var caseClassName = pega.ui.ClientCache.find("pyWorkPage.pxObjClass") != null ? pega.ui.ClientCache.find("pyWorkPage.pxObjClass").getValue() : null;
        if (haveDocumentViewer()) {
          if (caseClassName != null) {
            var pyOfflineAttachmentsEnabled = pega.offline.Utils.getOfflineSettingsForCase(caseClassName, "pyOfflineAttachmentsEnabled");  
            if ((pyOfflineAttachmentsEnabled !== "false") && isNewAttachMode) {
              console.info("Opening attachment in offline.");
              if (!pxLinkedClassTo) {
                pxLinkedClassTo = "DATA-WORKATTACH-FILE";
              }
              openAttachmentInOffline(pxLinkedClassTo.toUpperCase(), pxLinkedRefTo);
            } else {
              that.checkStorageAuthAndExecute(event, cbProcess);
            }


          } else {
            that.checkStorageAuthAndExecute(event, cbProcess);
          }


        } else if (isPIMC) {
          if (!pxLinkedClassTo) {
            pxLinkedClassTo = "DATA-WORKATTACH-FILE";
          }
          if (caseClassName != null) {
            that.previewPIMCAttachmentOffline(event, caseClassName, pxLinkedClassTo, pxLinkedRefTo, isNewAttachMode, cbProcess);
          } else {
            that.previewPIMCAttachmentOnline(event, pxLinkedRefTo, docViewerActivity, refClass, strInsKey, downloadActivity);
          }
        } else {
          that.checkStorageAuthAndExecute(event, cbProcess);
        }
      },
      checkTokenAndDisplayAttachment_pegaSocial_inline: function(event, attachmentMetadataObj, downloadURL,
                                                                  useInlineView, downloadURLFromInlinePreview) {
        if (useInlineView === "false" || useInlineView === false) {
          useInlineView = false;
        } else {
          useInlineView = true;
        }
        var cbProcess = function() {
          setAttachmentMetadataUniqueID(attachmentMetadataObj);
          displayAttachment(downloadURL, downloadURLFromInlinePreview, event, useInlineView,
                            attachmentMetadataObj);
        };
        this.checkStorageAuthAndExecute(event, cbProcess);
      },
      determineTypeOfAttachment: function(attachmentType) {
        if (isImageAttachment(attachmentType)) return "image";
        if (isVideoAttachment(attachmentType)) return "video";
        if (isAudioAttachment(attachmentType)) return "audio";
        if (isOfficeDocAttachment(attachmentType)) return "doc";
        if (isOfficeExcelAttachment(attachmentType)) return "excel";
        if (isOfficePPTAttachment(attachmentType)) return "ppt";
        if (attachmentType === "pdf") return "pdf";
        return "NA";
      },
      displayEmbeddedAttachment: function(attachmentMetadataObj, downloadURL, displayURL) {
        var cbProcess = function() {
          setAttachmentMetadataUniqueID(attachmentMetadataObj);
          displayAttachment(displayURL, downloadURL, null, true, attachmentMetadataObj);
        };
        var evt = $.Event('onload');
        evt.target = document.getElementById(attachmentMetadataObj.targetDiv);
        this.checkStorageAuthAndExecute(evt, cbProcess);
      },
      downloadEmbeddedAttachment: function(attachmentMetadataObj, downloadURL) {
        var cbProcess = function() {
          setAttachmentMetadataUniqueID(attachmentMetadataObj);
          displayAttachment(downloadURL, downloadURL, null, false, attachmentMetadataObj);
        };
        var evt = $.Event('onload');
        evt.target = document.getElementById(attachmentMetadataObj.targetDiv);
        this.checkStorageAuthAndExecute(evt, cbProcess);
      },

      previewPIMCAttachmentOnline: function(event, pxLinkedRefTo, docViewerActivity,refClass,strInsKey,downloadActivity) {
          if(pxLinkedRefTo.startsWith("DATA-WORKATTACH-URL")){
             var strUrlSF = SafeURL_createFromURL(pega.u.d.url);
             strUrlSF.put("pyActivity", "pzFetchURLDetails");
             strUrlSF.put("linkkey", pxLinkedRefTo); 
             var callBack = {
                success: function(response) {
                var link = response.responseText;
                link = (link.indexOf('://') === -1) ? 'http://' + link : link;
                pega.mobile.sdk.application.openUrl(link).then(function() {
					       	console.debug("Successfully opened the url");
					       	}).catch(function() {
					        console.error("Unable to open the url");
					        });
               }
            };
            pega.u.d.asyncRequest('GET', strUrlSF, callBack, null, null);
        } 
        else {
        var docViewerURL = new SafeURL(refClass + "." + downloadActivity);
				docViewerURL.put("linkInsHandle", strInsKey.trim());
        pega.u.d.convertToRunActivityAction(docViewerURL);
				docViewerURL = docViewerURL.toURL();
				var absoluteUrl = window.location.protocol + "//" + window.location.host + docViewerURL;
				var busyInd = new pega.ui.busyIndicator("", true, null);
				var srcElem = getSourceElem(event);
				if (srcElem) {
					busyInd.setTargetElement(srcElem);
				}
				busyInd.show();
        	pega.mobile.sdk.plugins.documents.preview(absoluteUrl).then(function() {
					console.debug("Attachment downloaded and previewed with success");
					busyInd.hide();
				}).catch(function() {
					console.error("Downloading and previewing attachment failed");
					busyInd.hide();
				});
        }
			
      },

      previewPIMCAttachmentOffline: function(event, caseClassName, pxLinkedClassTo, pxLinkedRefTo, isNewAttachMode, cbProcess) {
        var self = this;
        var pyOfflineAttachmentsEnabled = pega.offline.Utils.getOfflineSettingsForCase(caseClassName, "pyOfflineAttachmentsEnabled");
        
        //BUG-568002 : error message for URL attachment in offline.
        var linkedClassTo = pxLinkedClassTo ? pxLinkedClassTo.toUpperCase() : pxLinkedClassTo;
        if (linkedClassTo === "DATA-WORKATTACH-URL") {
          var CannotOpenUrlOnMobileApp = pega.u.d.fieldValuesList.get("CannotOpenUrlOnMobileApp");
          alert(CannotOpenUrlOnMobileApp);
        }
        if ((pyOfflineAttachmentsEnabled !== "false") && isNewAttachMode) {
          pms.plugins.clientstore.getItems([{type: pxLinkedClassTo.toUpperCase(), handle: pxLinkedRefTo}])
            .then(function(items) {
            if (items.length > 0 && items[0].url) {
              return items[0].url;
            } else {
              return pms.plugins.clientstore.getItemUrl("signature", pxLinkedRefTo, { decodeBase64: true, fileExtension: "jpg" });
            }
          })
            .then(function(documentId) {
            return pms.plugins.documents.preview({id: documentId})
          })
            .catch(function(error) {
            console.error("Cannot preview attachment (type='" + pxLinkedClassTo.toUpperCase() + "', handle='" + pxLinkedRefTo + "'). " + error);
          });
        } else {
          self.checkStorageAuthAndExecute(event, cbProcess);
        }
      },
      shareAttachment: function(event, strInsName, strInsKey, pxLinkedRefTo, strClass, docViewerActivity) {
        var docViewerURL = new SafeURL("Work-." + docViewerActivity);
        docViewerURL.put("LinkedRefTo", pxLinkedRefTo.trim());
        pega.u.d.convertToRunActivityAction(docViewerURL);
        docViewerURL = docViewerURL.toURL();
        var absoluteUrl = window.location.protocol + "//" + window.location.host + docViewerURL;
        var busyInd = new pega.ui.busyIndicator("", true, null);
        var srcElem = getSourceElem(event);
        if (srcElem) {
          busyInd.setTargetElement(srcElem);
        }
        busyInd.show();
        pega.mobile.sdk.plugins.documents.share(absoluteUrl).then(function() {
          console.debug("File shared with success");
          busyInd.hide();
        }).catch(function(error) {
          console.error("Sharing file failed.", error);
          busyInd.hide();
        });
      }
    }
  }
})(pega);
//static-content-hash-trigger-GCC
pega.ui.roboticAutomationApi = (function() {
  var _public = {};
  var _priv = {};

  /* Logging and debugging */
   _priv.log = function (msg) {
    if (pega.ui.debug) {
      console.log(msg);
    }
  };
  _public.invokeAutomation = function(action, automationMetadata,successCallback,errorCallback, bInvokeUsingConstellationService,responseId) {
    _priv.log("RDA API is invoked with automation metadata: "+JSON.stringify(automationMetadata));
    /* validate api inputs */
    var inputValidationMsg = _priv.validateInput(automationMetadata,bInvokeUsingConstellationService);

    
    if(!inputValidationMsg){
      if(bInvokeUsingConstellationService === true){
      pega.ui.roboticAutomationMessagingUtils.requestAutomationFromServer(action,automationMetadata,responseId);
    }
      else{
      // check runtime availability and subsequently invoke it
      _priv.checkAutomationRuntimeAvailability(automationMetadata,successCallback,errorCallback);
    }
    }  
    else{
      throw new Error(inputValidationMsg);
    }
    
    
  };

  _priv.validateInput = function(automationMetadata,bInvokeUsingConstellationService){

    var inputMissingFields = [];
    var invalidValues = [] ;
    var inputValidationMsg = null;

    if(!automationMetadata.automationName){
      inputMissingFields.push("automationName");
    }

    if(!automationMetadata.automationURL && !bInvokeUsingConstellationService){
      inputMissingFields.push("automationURL");
    }

    if(!automationMetadata.jwtString && !bInvokeUsingConstellationService){
      inputMissingFields.push("jwtString");
    }

    if(inputMissingFields.length > 0){
      inputValidationMsg = "Missing required fields: ["+inputMissingFields+"]";  
    }

    if(automationMetadata.timeout){

      if( isNaN(automationMetadata.timeout) || parseInt(automationMetadata.timeout) < 0){
        invalidValues["timeout"] = automationMetadata.timeout;
      }
    }

    if(Object.keys(invalidValues).length > 0){
      var invalidValuesString ;
      for(key in invalidValues){
        if(invalidValuesString){
          invalidValuesString = invalidValuesString + ","+key+":"+invalidValues[key]
        }else{
          invalidValuesString = key+":"+invalidValues[key]
        }
      }

      if(inputValidationMsg){
        inputValidationMsg = inputValidationMsg+" inavlid values: ["+invalidValuesString+"]";
      }
      else{
        inputValidationMsg = "inavlid values: ["+invalidValuesString+"]";
      }
    }

    return inputValidationMsg;
  };

  _priv.checkAutomationRuntimeAvailability = function(automationMetaData,successCallback,errorCallback) {

    _priv.log("checking RDA runtime availability ...");
    
    $.ajax({
      type: "GET",
      contentType: "application/json",
      url: automationMetaData.automationURL + "/IsAvailable",
      success: function(json) {
        _priv.log("Runtime is available!");
        // invoke RDA automation here.
        _priv.runAutomationInner(automationMetaData,successCallback,errorCallback);
      },
      error: function(response) {
        _priv.log("Runtime is NOT available!");
        response.isRuntimeAvailable = "false";
        errorCallback(response);
      },
      headers: {
        'Authorization': 'Bearer ' + automationMetaData.jwtString
      },
      timeout: 4000
    });
  }; 

  _priv.runAutomationInner = function(automationMetaData,successCallback,errorCallback) {
    _priv.log("Data sent to automation : " + JSON.stringify(automationMetaData.payload));
    
    $.ajax({
      type: "POST",
      contentType: "application/json",
      url: automationMetaData.automationURL + "/execute?activity=" + automationMetaData.automationName,
      dataType: "json",
      /* This data should be generate dynamically based on selected case type */
      data: automationMetaData.payload,
      success: function(response) {
        _priv.log("success: returned from rest service.... : " + JSON.stringify(response.ModifiedFields));
        successCallback(response);
      },
      error: function(response) {
        _priv.log("failed: returned from rest service.... : " + JSON.stringify(response));
        response.isRuntimeAvailable = "true";
        errorCallback(response);
      },
      headers: {
        'Authorization': 'Bearer ' + automationMetaData.jwtString
      },
      timeout: automationMetaData.timeout
    });
  };

  _public["testObject"] = _priv;
  return _public;

})();
//static-content-hash-trigger-NON
/*IE11 does not implement startsWith  . So overriding startsWith method */
if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}
pega.ui.roboticAutomation = (function() {
  
    var _public = {}
    var _priv = {}
    var automationMetaData;
    var callbackMethodName;
    var callbackParamsValue;
    var actionType;
    var containerElemName;
    var bInvokeUsingConstellationService  ;
    
    _priv.getRunMode = function(){ //method to identify the mode of execution. Can be : constellation or legacy
        console.log("fetching runtime availability");
        var postData = new SafeURL();
        var strUrlSF = SafeURL_createFromURL(pega.d.RDARuntimeSubscriptionStatusActivityEncrypted);
        var returnValue = "legacy";
        var callback = {
            success: function(response) {
              
              var responseData = JSON.parse(response.responseText);
              console.log("fetched runtime subscription successfully");
              if(responseData.pyStatusValue === "true"){
                returnValue = "constellation";
                console.log("runtime subscription for current user exists. Runmode : constellation");
              }
                else {
                returnValue = "legacy";
                if(responseData.pyStatusMessage === "Blank_DSS"){
                  console.log("messaging service host url is not configured. Runmode : legacy");
                }
                else{
                  console.log("runtime subscription for curent user does not exist. Runmode : legacy");
                }
              }
              },
            failure: function(o) {
               console.log("failed to fetch runtime subscription status. check pega logs for details. Attempting to run in legacy mode");
              returnValue = "legacy";
            }
     };
    const syncMode = {bAsync:false};
	  pega.u.d.asyncRequest('POST', strUrlSF, callback, postData,syncMode);
      return returnValue;

    }

    _public.runAutomation = function(action, containerElem, callbackMethod, callbackParams) {
        var relativeElem;
        if (action === "preLoad") {
            relativeElem = $(containerElem).closest('.pz-po-c')[0] || pega.u.d.findParent(containerElem, "modalWrapper") || pega.u.d.findParent(containerElem, "PEGA_HARNESS");
        } else if (action === "submitAssignment") {
            relativeElem = $("#PEGA_HARNESS");
        } else if (action === "submit") {
            relativeElem = containerElem;
        }
        if (relativeElem) {
            _public.showHideBusyIndicator(relativeElem);
        }
      var runMode = _priv.getRunMode();
      bInvokeUsingConstellationService  = false;
      var responseId = "";
      if(runMode === "constellation"){
        bInvokeUsingConstellationService = true;
        callbackMethodName = callbackMethod;
        callbackParamsValue = callbackParams;
        actionType = action;
        containerElemName = containerElem;
        const response ='';
        automationMetaData = _priv.returnAutomationMedataData(response, containerElem);
        responseId = pega.ui.roboticAutomationMessagingUtils.InvokeSubscribeToMsgService();        
        
      }else{     
        //firing ajax call to get the URL along with JWT token
        var postData = new SafeURL();
        //var strUrlSF = SafeURL_createFromURL(pega.u.d.url);
        //strUrlSF.put("pyActivity", "pzGetRDAURLWithToken");
        var strUrlSF = SafeURL_createFromURL(pega.d.RDAURLWithTokenActivityEncrypted);
        console.log("Calling the encrypted url for RDA token");
        var callback = {
            success: function(response) {
                if (response.responseText) {
                    automationMetaData = _priv.returnAutomationMedataData(response, containerElem);
                    _priv.processRunAutomation(action, containerElem, callbackMethod, callbackParams, automationMetaData,bInvokeUsingConstellationService,responseId);
                } else
                    console.log("Error in retrieving RDA URL with JWT token");
            },
            failure: function(o) {
                console.log("pzGetRDAURLWithToken activity failed");
            }
        };
        pega.u.d.asyncRequest('POST', strUrlSF, callback, postData);
       }
    }
    

    _priv.returnAutomationMedataData = function(response, containerElem) {
        var preAutomationDiv = $(containerElem).find("#preAutomationMeta")[0];
        var postAutomationDiv = $(containerElem).find("#postAutomationMeta")[0];

        var autoMeta,
            autoData,
            autoPrimaryPage,
            autoDataString,
            automationName,
            automationDiv,
            automationURL,
            automationBaseURL,
            urlWithJWT,
            timeoutVal;

        if (preAutomationDiv) {
            /* Fetch host details for preparing base URL and checking runtime - START*/
            var sectionMethodname = preAutomationDiv.getAttribute("data-section-methodname");
            autoMeta = JSON.parse(preAutomationDiv.getAttribute("data-automation-meta"));
            if (!sectionMethodname || !autoMeta) {
                return;
            }
            automationDiv = preAutomationDiv;
        } else if (postAutomationDiv) {
            automationDiv = postAutomationDiv;
            autoMeta = JSON.parse(postAutomationDiv.getAttribute("data-automation-meta"));
        }
        var jwtString;
        if(response){
            urlWithJWT = JSON.parse(response.responseText);
            //capturing the URL in automationBaseURL
            automationBaseURL = urlWithJWT.pyRDAUrl;
            if (automationBaseURL.startsWith("http://") || automationBaseURL.startsWith("https://")) {
            automationURL = automationBaseURL + "/api/v1/runtime";
        } else {
            automationURL = "https://" + automationBaseURL + "/api/v1/runtime";
        }
        console.log("URL provided is:" + automationURL);
        //capturing the JWT string in jwtString
        jwtString = urlWithJWT.pyJWTString;
        //getting timeout value
        timeoutVal =   urlWithJWT.pyTimeoutInMilliSeconds;
        //getting the localized text for ignore and continue 
        pega.ui.roboticAutomation.ignoreAndContinuteText = urlWithJWT.pyTempText;
        }
        /* END */      
        autoData = JSON.parse(_priv.jsonEscape(automationDiv.getAttribute("data-automation-propData")));
        autoPrimaryPage = automationDiv.getAttribute("data-automation-primaryPage");
        if (autoMeta.PRE) {
            automationName = autoMeta.PRE[0];
        } else if (autoMeta.POST) {
            automationName = autoMeta.POST[0];
        }
        return {
            autoData: autoData,
            automationName: automationName,
            automationURL: automationURL,
            sectionMethodname: sectionMethodname,
            automationDiv: automationDiv,
            autoPrimaryPage: autoPrimaryPage,
            jwtString: jwtString,
            timeout:timeoutVal
        };
    }

    _priv.processRunAutomation = function(action, containerElem, callbackMethod, callbackParams, automationMetaData,bInvokeUsingConstellationService,responseId) {
        if (action === "submit" || action === "submitAssignment") {
            if (!automationMetaData.jwtString && !bInvokeUsingConstellationService) {
                //refreshing the section to show errors in case jwt string is blank
                console.log("Blank JWT string.");
                _priv.processAutomationError(action, containerElem, callbackMethod, callbackParams, automationMetaData, "false");
                return;
            }
            _priv.invokeServerSideValidation(action, containerElem, callbackMethod, callbackParams, automationMetaData,bInvokeUsingConstellationService,responseId);
        } else if (action === "preLoad") {
            var sectionMethodname = automationMetaData.sectionMethodname;
            var preAutomationDiv = automationMetaData.automationDiv;
            if (!callbackParams) {
                callbackParams = new Array();
            }
            callbackParams = [sectionMethodname, preAutomationDiv];
            var hasMessages = containerElem ? $(containerElem).find('#preAutomationMeta')[0].getAttribute('data-automation-hasMessages') : false;
            if ("true" == hasMessages) {
                console.log("Primary page has errors. Automation is not invoked");
                callbackMethod.apply(this, callbackParams);
            } else {
                if (!automationMetaData.jwtString && !bInvokeUsingConstellationService) {
                    //refreshing the section to show errors in case jwt string is blank
                    console.log("Blank JWT string.");
                    _priv.processAutomationError(action, containerElem, callbackMethod, callbackParams, automationMetaData, "false");
                    return;
                }
                console.log("No errors. Proceeding to invoke Automation");
                callbackParamsValue = callbackParams;
                _priv.invokeRdaAutomation(action, containerElem, callbackMethod, callbackParams, automationMetaData, bInvokeUsingConstellationService,responseId);
            }
        }
    }
_public.processRunAutomation=function(responseId){
    _priv.processRunAutomation(actionType, containerElemName, callbackMethodName, callbackParamsValue, automationMetaData,bInvokeUsingConstellationService,responseId);
}
    _priv.processAutomationError = function(action, containerElem, callbackMethod, callbackParams, automationMetaData, executeAutomation, response) {
        var strUrl = new SafeURL();
        var sectionName;
        strUrl.put("ExecuteAutomation", executeAutomation);
        //handling scenarios to show the error on the page in case automation invocation failed
        if (action == "submit" || action == "submitAssignment") {
            strUrl.put("pzPrimaryPageName", $(containerElem).find('#postAutomationMeta')[0].getAttribute('data-automation-primarypage'));
            strUrl.put("Action", "submit");
            sectionName = $(containerElem).find('#postAutomationMeta')[0].getAttribute('data-section-name');
        } else if (action == "preLoad") {
            strUrl.put("pzPrimaryPageName", $(containerElem).find('#preAutomationMeta')[0].getAttribute('data-automation-primarypage'));
            strUrl.put("Action", "preLoad");
            sectionName = $(containerElem).find('#preAutomationMeta')[0].getAttribute('data-section-name');
        }
        if (automationMetaData.jwtString || bInvokeUsingConstellationService) {
            if (response) {
                if (response.statusText)
                    strUrl.put("StatusText", response.statusText);
                if (response.responseText)
                    strUrl.put("ResponseText", response.responseText);
                if (response.status)
                    strUrl.put("Status", response.status);
            }
        } else {
            strUrl.put("ResponseText", "Blank JWT");
        }
        var sectionNode = pega.u.d.getSectionByName(sectionName);
        var callback = {
            success: function(response) {
                callbackMethod.apply(this, callbackParams);
            }
        };
        //proceeding with case execution in pre automation via success callback
        if (action == "preLoad") {
            pega.u.d.reloadSection(sectionNode, "pxProcessAutomationFailure", strUrl.toQueryString(), false, true, '', true, null, null, '', callback.success);
        } else {
            //reloading the section to show errors
            pega.u.d.reloadSection(sectionNode, "pxProcessAutomationFailure", strUrl.toQueryString(), false, true, '', true, null, null, '', null);
            _public.showHideBusyIndicator(null, "hide");
            _priv.changeSubmitText(action, containerElem, callbackParams);

        }

    }

    _priv.invokeServerSideValidation = function(action, containerElem, callbackMethod, callbackParams, automationMetaData,bInvokeUsingConstellationService,responseId) {
        //Validate and proceed with rest of the flow upon successful validation. 
        var callback = {
            success: function(response) {
                _priv.fetchUpdatedRRValues(action, containerElem, callbackMethod, callbackParams, automationMetaData,bInvokeUsingConstellationService,responseId);
            }
        };
        var strUrl = new SafeURL();
        strUrl.put("pzPrimaryPageName", $(containerElem).find('#postAutomationMeta')[0].getAttribute('data-automation-primarypage'));
        strUrl.put("TaskStatus", $(containerElem).find('#postAutomationMeta')[0].getAttribute('data-flowaction-name'));
        if (action === "submitAssignment") {
            strUrl.put("isAssignment", true);
        }
        var sectionName = $(containerElem).find('#postAutomationMeta')[0].getAttribute('data-section-name');
        var sectionNode = pega.u.d.getSectionByName(sectionName);
        //Use reload section by passing the validate API to load the section upon any errors.
        pega.u.d.reloadSection(sectionNode, "pxPerformAutomationValidation", strUrl.toQueryString(), false, true, '', true, null, null, '', callback.success);
    };

  	//Added for SE-35311 by rathu
 	  _priv.jsonEscape =  function (str)  {
      	if(str)
        		return str.replace(/\n/g, "\\\\n").replace(/\r/g, "\\\\r").replace(/\t/g, "\\\\t");
        else
          return str;
	  };

    _priv.fetchUpdatedRRValues = function(action, containerElem, callbackMethod, callbackParams, automationMetaData,bInvokeUsingConstellationService,responseId) {
        var postData = new SafeURL();
        //var strUrlSF = SafeURL_createFromURL(pega.u.d.url);
        //strUrlSF.put("pyActivity", "pxFetchUpdatedRRFromClipboard");
        var strUrlSF = SafeURL_createFromURL(pega.d.FetchUpdatedRRFromClipboardActivityEncrypted);
        strUrlSF.put("pzPrimaryPageName", automationMetaData.autoPrimaryPage);
        strUrlSF.put("pzKeepPageMessages", "true");
        var callback = {
            success: function(response) {
                if (response.responseText == "hasMessages") { // in case of any property/page-set-messages
                    _public.showHideBusyIndicator(null, "hide");
                    _priv.enableButtons(action, containerElem);
                    console.log("Primary page has messages");
                } else {
                    var postAutomationDiv = $(containerElem).find('#postAutomationMeta')[0];
                    //getting the json string object  
                    var jsonStr = response.responseText;
                    postAutomationDiv.setAttribute("data-automation-propData", jsonStr);
                    automationMetaData.autoData = JSON.parse(_priv.jsonEscape(jsonStr)); //Modified by rathu for SE-35311
                    _priv.invokeRdaAutomation(action, containerElem, callbackMethod, callbackParams, automationMetaData,bInvokeUsingConstellationService,responseId);
                }
            },
            failure: function(o) {
                console.log("pxFetchUpdatedRRFromClipboard activity failed");
            }
        };
        pega.u.d.asyncRequest('POST', strUrlSF, callback, postData);
    };

  _priv.successCallbackInner = function(action, containerElem, callbackMethod, callbackParams, automationMetaData,response){
    _public.showHideBusyIndicator(null, "hide");
    _priv.updateClipboardWithAutomationValues(callbackMethod, callbackParams, automationMetaData, response);
  }
  
    _priv.invokeRdaAutomation = function(action, containerElem, callbackMethod, callbackParams, automationMetaData,bInvokeUsingConstellationService,responseId) {
      
      var autoData = pega.u.d.getPropValuesFromDOM(automationMetaData.autoData, automationMetaData.autoPrimaryPage);
      var autoDataString = JSON.stringify(autoData);
      automationMetaData.payload = autoDataString;
      //automationMetaData.timeout="60000";
      console.log("timeout value : "+automationMetaData.timeout);
      
      var successCallback = function(response) {
        _priv.successCallbackInner(action, containerElem, callbackMethod, callbackParams,automationMetaData,response);
      }
      
      var errorCallback = function(response) {
        _priv.processAutomationError(action, containerElem, callbackMethod, callbackParams,automationMetaData,response.isRuntimeAvailable, response);
      }
      pega.ui.roboticAutomationApi.invokeAutomation(action,automationMetaData, successCallback, errorCallback,bInvokeUsingConstellationService,responseId);
      
    };
  
   //Callback function once runtime publishes automation message
    _public.processExecutionCallBack = function(response){
        var automationStatus = response.Status
        if(automationStatus === "Completed"){
            _public.showHideBusyIndicator(null, "hide");
            _priv.updateClipboardWithAutomationValues(callbackMethodName, callbackParamsValue, automationMetaData, response);
        }else{
            _priv.processAutomationError(actionType, containerElemName, callbackMethodName, callbackParamsValue, automationMetaData,'true', response);
        }
      var postData = new SafeURL();
      var strUrlSF = SafeURL_createFromURL(pega.d.C11NPostExecutionCallBackActivityEncrypted);
      strUrlSF.put("action", actionType);
      strUrlSF.put("response", JSON.stringify(response));
      var callback = {
          success: function() {
              console.log("pyC11NPostExecutionCallBack activity executed.");
          },
          failure: function(o) {
              console.log("failed to execute pyC11NPostExecutionCallBack activity");
          }
      };
      pega.u.d.asyncRequest('POST', strUrlSF, callback, postData);
	  };

    //post the modified values into the clipboard by calling pzUpdateClipboardWithAutomationValues activity.
    _priv.updateClipboardWithAutomationValues = function(callbackMethod, callbackParams, automationMetaData, response) {
        var responseJson = JSON.stringify(response.ModifiedFields);
        var postData = new SafeURL();
        //var strUrlSF = SafeURL_createFromURL(pega.u.d.url);
        //strUrlSF.put("pyActivity", "pzUpdateClipboardWithAutomationValues");
        var strUrlSF = SafeURL_createFromURL(pega.d.UpdateClipboardWithAutomationValuesActivityEncrypted);
        strUrlSF.put("pzPrimaryPageName", automationMetaData.autoPrimaryPage);
        strUrlSF.put("clipboardPageName", automationMetaData.autoPrimaryPage);
        postData.put("jsonString", responseJson);
        var callback = {
            success: function(o) {
                callbackParams.push(response.ModifiedFields);
                callbackMethod.apply(this, callbackParams);
            },
            failure: function(o) {
                console.log("updateClipboardWithAutomationValues failed");
            }
        };
        pega.u.d.asyncRequest('POST', strUrlSF, callback, postData);


    }
    _priv.changeSubmitText = function(action, containerElem, callBackParameters) {
        var eventObj, sourceButton;
        if (action == 'submitAssignment')
            eventObj = callBackParameters[3];
        else if (action == 'submit')
            eventObj = callBackParameters[1];
        if (eventObj)
            sourceButton = eventObj.target || eventObj.srcElement;
        sourceButton.text = pega.ui.roboticAutomation.ignoreAndContinuteText;
        $(containerElem).find('#postAutomationMeta')[0].setAttribute("skipAutomation", "true");
        _priv.enableButtons(action, containerElem);
    }

    _public.skipAutomation = function(containerElem) {
        var postAutomationDiv = $(containerElem).find("#postAutomationMeta")[0];
        return postAutomationDiv.getAttribute("skipAutomation");
    }

    _priv.enableButtons = function(action, containerElem) {
        //This allows the workobject to be submitted again in case of failures.
        if (action === 'submitAssignment') { //for assignments
            pega.ctx.SubmitInProgress = false;
        } else { //for modal/overlays
            pega.u.d.enableAllButtons(containerElem);
        }
    }

    _public.isAutomationConfigured = function(action, containerElem) {
        if (action === "submit") {
            var postAutomationDiv;
            //code to diffrentiate b/n assignment's postAutomationMetaDiv with overlay's postAutomationMetaDiv
            //containerElem would be 'document' in case of submit on an Assignmemnt.
            if (containerElem == document) { // in case of submit on an Assignment 
                //code to see if an overlay had been launched. Yes, it's postAutomationMeta div could conflict with Assignment's postAutomationMeta div.              
                var overLaycontainer = document.getElementById('_popOversContainer');
                $(containerElem).find("#postAutomationMeta").each(function(i, elem) {
                    //If the found postAutomationMeta is not a child of overLayContainer,select it.
                    if (!pega.util.Dom.isAncestor(overLaycontainer, elem)) {
                        postAutomationDiv = elem;
                    }
                });
            } else { // in case of submit on a modal/overlay
                postAutomationDiv = $(containerElem).find("#postAutomationMeta")[0];
            }
            return postAutomationDiv;
        } else if (action === "preLoad") {
            var preAutomationDiv = $(containerElem).find("#preAutomationMeta")[0];
            return preAutomationDiv;
        }
    };
    _public.showHideBusyIndicator = function(relativeElem, action) {
        var mask = $('.overlay-mask');

        // Create the required mask

        if (mask && mask.length == 0) {
            var docBodyScrollTop = document.body.scrollTop;
            var docBodyScrollLeft = document.body.scrollLeft;
            if ((pega.env.ua.gecko || pega.util.Event.isIE) && document.documentElement) {
                docBodyScrollTop = document.documentElement.scrollTop;
                docBodyScrollLeft = document.documentElement.scrollLeft;
            }
            var docBodyClientHeight = document.body.clientHeight;
            var docBodyClientWidth = document.body.clientWidth;
            if (!$(relativeElem).hasClass("pz-po-c")) {
                $(relativeElem).css({
                    position: 'relative'
                });
            }
            mask = $('<div class="overlay-mask"></div>');
            mask.css({
                position: 'absolute',
                width: '100%',
                height: '100%',
                top: 0,
                left: 0,
                zIndex: 100
            }).appendTo($(relativeElem));

            var img = $("<ul class='throbber' role='progressbar' aria-valuetext='Loading content'  tabindex='0'>" +
                "<li></li>" +
                "<li></li>" +
                "<li></li>" +
                "<li></li>" +
                "<li></li>" +
                "<li></li>" +
                "<li></li>" +
                "<li></li>" +
                "<li></li>" +
                "</ul>");
            if (relativeElem && (relativeElem.id == "modalWrapper" || $(relativeElem).hasClass("pz-po-c"))) {
                img.css({
                    position: 'absolute',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)'
                });
            } else {
                img.css({
                    position: 'absolute',
                    top: (docBodyScrollTop + docBodyClientHeight / 2) + "px",
                    left: (docBodyScrollLeft + docBodyClientWidth / 2) + "px"
                });
            }
            img.appendTo(mask);

        }

        // Act based on params

        if (!action || action === 'show') {
            mask.show();
        } else if (action === 'hide') {
            mask.remove();
        }

    };
  
    _public["testObject"] = _priv;
    return _public;
})();
//static-content-hash-trigger-GCC
//static-content-hash-trigger-NON
pega.ui.roboticAutomationMessagingUtils = (function() {
    var _public = {};
    var _priv = {};
    var timeout;
    var timeoutInterval;
    var userId;
  
    _priv.log = function(msg) {
      //if (pega.ui.debug) {
        console.log(msg);
      //}
    };

    _priv.pegaLog = function(msg, logLevel, generateStackTrace, sentToTracer) {
        var postData = new SafeURL();
        var strUrlSF = SafeURL_createFromURL(pega.d.AddLogMessagesAndAlertsActivityEncrypted);
        strUrlSF.put("message", msg);
        strUrlSF.put("loggingLevel", logLevel);
        strUrlSF.put("generateStackTrace", generateStackTrace);
        strUrlSF.put("sendToTracer", sentToTracer);
      
        var callback = {
            success: function() {
                _priv.log("pzAddLogMessagesAndAlerts activity executed.");
            },
            failure: function(o) {
                _priv.log("failed to execute pzAddLogMessagesAndAlerts activity");
            }
        };
        pega.u.d.asyncRequest('POST', strUrlSF, callback, postData);
    }

    _public.requestAutomationFromServer = function(action, automationMetadata, responseId) {
        const responseFields = {
            action: action,
            responseId: responseId
        };
        var requiredResponseFields = JSON.stringify(responseFields);
        console.log(requiredResponseFields);
        _priv.sendAutomationRequest(automationMetadata, responseFields);

    };

    _public.InvokeSubscribeToMsgService = function() {
        var postData = new SafeURL();
        var strUrlSF = SafeURL_createFromURL(pega.d.C11NRDAMsgSvcSubscriptionInfoActivityEncrypted);
        console.log("running messaging activity");
        var responseId;
        var callback = {
            success: function(response) {
                _priv.log("pzGetC11NRDAMsgSvcSubscriptionInfo executed successfully");
                _priv.pegaLog("pzGetC11NRDAMsgSvcSubscriptionInfo executed successfully", "Info", false, false);
                _priv.log("response from pzGetC11NRDAMsgSvcSubscriptionInfo"+JSON.stringify(response));
                if (response.responseText) {
                    var urlWithJWT = JSON.parse(response.responseText);
                    var token = urlWithJWT.pyJWTString;
                    userId = urlWithJWT.pyUserIdentifier;
                    var sessionId = urlWithJWT.pxSessionID;
                    var filterMatcher = "AttendedRPA";
                    var url = urlWithJWT.pzMessagingServiceURL;
                    timeoutInterval = urlWithJWT.timeout;
                    pega.ui.roboticAutomation.ignoreAndContinuteText = urlWithJWT.pyTempText;
                    responseId = _public.subscribeToMessagingService(url, token, filterMatcher, userId, sessionId);
                } else {
                    _priv.log("Error in retrieving Msg Svc URL with JWT token");
                    _priv.pegaLog("Error in retrieving Msg Svc URL with JWT token", "Error", false, false);
                }
            },
            failure: function(o) {
                _priv.log("pzGetC11NRDAMsgSvcSubscriptionInfo activity failed");
                _priv.pegaLog("pzGetC11NRDAMsgSvcSubscriptionInfo activity failed", "Error", false, false);
            }
        };
        //pega.u.d.asyncRequest('POST', strUrlSF, callback, postData);
        const syncMode = {bAsync:false};
	      pega.u.d.asyncRequest('POST', strUrlSF, callback, postData,syncMode);
        return responseId;
    }

    _public.subscribeToMessagingService = function(serviceURL, token, filterMatcher, userId, sessionId) {    
        var connURL = "wss://" + serviceURL;
        const conn = {
            messagingService: connURL
        };
        _public.reloadConstellationControlSection();
        const currentDate = new Date();
        const timestamp = currentDate.getTime();
        var responseId = userId + "_" + sessionId + "_" + timestamp;
        const filter = {
            matcher: filterMatcher,
            criteria: {
                responseId: responseId
            }
        };
        var subscriptionID = "";
        console.log("before "+new Date().getTime());
        (async () => {
            console.log("waiting for PCore in window");
            var waitCount = 0;
            while (!window.hasOwnProperty("PCore")){ // define the condition as you like
                await new Promise(resolve => setTimeout(resolve, 1000));
                waitCount++;
                if(waitCount === 5)
                    break;
            }
            if(waitCount === 5){
                  const response = {
                        responseText : "Failed to load PCore"
                   };
                   _priv.log("Failed to load PCore");
                   pega.ui.roboticAutomation.processExecutionCallBack(response);
            }else{
               console.log("after "+new Date().getTime()); 
               console.log("PCore is defined");          
               PCore.getMessagingServiceManager().initConnection(conn);
               subscriptionID = PCore.getMessagingServiceManager().subscribe(filter, callbackforSubscribe, responseId);
               _priv.log("filter : " + JSON.stringify(filter));
               _priv.pegaLog("filter : " + JSON.stringify(filter), "Info", false, false);
               _priv.log("subscription ID " + subscriptionID);
               _priv.pegaLog("subscription ID " + subscriptionID, "Info", false, false);
               pega.ui.roboticAutomation.processRunAutomation(responseId); 
           }
        })();  
      return responseId;
    }
/*const syncWait = ms => {
    const end = Date.now() + ms
    while (Date.now() < end) continue
}*/
    const callbackforSubscribe = data => {
        _priv.log("callbackforSubscribe invoked " + JSON.stringify(data));
        clearTimeout(timeout);
        var response = data.message;
        var subscriptionID = data.message.RequiredResponseFields.responseId;
        pega.ui.roboticAutomation.processExecutionCallBack(response);
        _public.unsubscribeToMessaginSvc(subscriptionID);
    };

    _public.reloadConstellationControlSection = function() {
        $(document.body).find("#HARNESS_CONTENT").append('<div data-template="" node_name="pzConstellationControlLoad" node_type="MAIN_RULE" name="BASE_REF" id="RULE_KEY" class="sectionDivStyle  " style="visibility: hidden" base_ref="" data-node-id="pzConstellationControlLoad" version="1" objclass="Rule-HTML-Section" pyclassname="@baseclass" readonly="false" expandrl="" index="" uniqueid="SID1626676435037"></div>')
        pega.u.d.refreshSection("pzConstellationControlLoad");
    };

    //calling the publish activity
    _priv.sendAutomationRequest = function(automationMetaData, requiredResponseFields) {
        _priv.log("Data sent to automation : " + JSON.stringify(automationMetaData.payload));
        _priv.log("Required response fields sent in message : " + JSON.stringify(requiredResponseFields));
        var postData = new SafeURL();
        var strUrlSF = SafeURL_createFromURL(pega.d.C11NPublishRDAMessageActivityEncrypted);
        strUrlSF.put("runtimeOpID", userId);
        strUrlSF.put("automationName", automationMetaData.automationName);
        strUrlSF.put("automationData", automationMetaData.payload);
        strUrlSF.put("requiredResponseFields", JSON.stringify(requiredResponseFields));
        strUrlSF.put("isConstellationApp", "true");
      var responseIdForUnsubscribe = requiredResponseFields.responseId;
   
        var callback = {
            success: function() {
                _priv.log("pzC11NPublishRDAMessage activity executed.");
                timeout = setTimeout(function() {
                  
                 console.log("responseID for unsubscribe "+responseIdForUnsubscribe);
                    _public.unsubscribeToMessaginSvc(responseIdForUnsubscribe);
                    const response = {
                        statusText : "timeout"
                     };
                    pega.ui.roboticAutomation.processExecutionCallBack(response);
                }, timeoutInterval);
            },
            failure: function(o) {
                _priv.log("failed to execute pzC11NPublishRDAMessage activity");
                _public.unsubscribeToMessaginSvc(responseIdForUnsubscribe);
                    const response = {
                        statusText : "automationRequestFailed"
                     };
                    pega.ui.roboticAutomation.processExecutionCallBack(response);
            }
        };
        pega.u.d.asyncRequest('POST', strUrlSF, callback, postData);
    };

    _public.unsubscribeToMessaginSvc = function(subscriptionId) {
        PCore.getMessagingServiceManager().unsubscribe(subscriptionId);
        console.log("unsubscribed to msg svc for responseID : "+subscriptionId);
    };

    _public["testObject"] = _priv;
    return _public;
})();
//static-content-hash-trigger-GCC
/**!
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */

(function sortableModule(factory) {
	"use strict";

    if (typeof define === "function" && define.amd) {
        define("sortableModule", factory); 
    }	
	else if (typeof module != "undefined" && typeof module.exports != "undefined") {
		module.exports = factory();
	}
	else if (typeof Package !== "undefined") {
		//noinspection JSUnresolvedVariable
		Sortable = factory();  // export for Meteor.js
	}
	else {
		/* jshint sub:true */
		window["Sortable"] = factory();
	}
})(function sortableFactory() {
	"use strict";

	if (typeof window == "undefined" || !window.document) {
		return function sortableError() {
			throw new Error("Sortable.js requires a window with a document");
		};
	}

	var dragEl,
		parentEl,
		ghostEl,
		cloneEl,
		rootEl,
		nextEl,

		scrollEl,
		scrollParentEl,
		scrollCustomFn,

		lastEl,
		lastCSS,
		lastParentCSS,

		oldIndex,
		newIndex,

		activeGroup,
		putSortable,

		autoScroll = {},

		tapEvt,
		touchEvt,

		moved,

		/** @const */
		RSPACE = /\s+/g,

		expando = 'Sortable' + (new Date).getTime(),

		win = window,
		document = win.document,
		parseInt = win.parseInt,

		$ = win.jQuery || win.Zepto,
		Polymer = win.Polymer,
    captureMode = false,

		supportDraggable = !!('draggable' in document.createElement('div')),
		supportCssPointerEvents = (function (el) {
			// false when IE11
			if (!!navigator.userAgent.match(/Trident.*rv[ :]?11\./)) {
				return false;
			}
			el = document.createElement('x');
			el.style.cssText = 'pointer-events:auto';
			return el.style.pointerEvents === 'auto';
		})(),

		_silent = false,

		abs = Math.abs,
		min = Math.min,
		slice = [].slice,

		touchDragOverListeners = [],

		_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {
			// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
			if (rootEl && options.scroll) {
				var el,
					rect,
					sens = options.scrollSensitivity,
					speed = options.scrollSpeed,

					x = evt.clientX,
					y = evt.clientY,

					winWidth = window.innerWidth,
					winHeight = window.innerHeight,

					vx,
					vy,

					scrollOffsetX,
					scrollOffsetY
				;

				// Delect scrollEl
				if (scrollParentEl !== rootEl) {
					scrollEl = options.scroll;
					scrollParentEl = rootEl;
					scrollCustomFn = options.scrollFn;

					if (scrollEl === true) {
						scrollEl = rootEl;

						do {
							if ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||
								(scrollEl.offsetHeight < scrollEl.scrollHeight)
							) {
								break;
							}
							/* jshint boss:true */
						} while (scrollEl = scrollEl.parentNode);
					}
				}

				if (scrollEl) {
					el = scrollEl;
					rect = scrollEl.getBoundingClientRect();
					vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
					vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
				}


				if (!(vx || vy)) {
					vx = (winWidth - x <= sens) - (x <= sens);
					vy = (winHeight - y <= sens) - (y <= sens);

					/* jshint expr:true */
					(vx || vy) && (el = win);
				}


				if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
					autoScroll.el = el;
					autoScroll.vx = vx;
					autoScroll.vy = vy;

					clearInterval(autoScroll.pid);

					if (el) {
						autoScroll.pid = setInterval(function () {
							scrollOffsetY = vy ? vy * speed : 0;
							scrollOffsetX = vx ? vx * speed : 0;

							if ('function' === typeof(scrollCustomFn)) {
								return scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);
							}

							if (el === win) {
								win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
							} else {
								el.scrollTop += scrollOffsetY;
								el.scrollLeft += scrollOffsetX;
							}
						}, 24);
					}
				}
			}
		}, 30),

		_prepareGroup = function (options) {
			function toFn(value, pull) {
				if (value === void 0 || value === true) {
					value = group.name;
				}

				if (typeof value === 'function') {
					return value;
				} else {
					return function (to, from) {
						var fromGroup = from.options.group.name;

						return pull
							? value
							: value && (value.join
								? value.indexOf(fromGroup) > -1
								: (fromGroup == value)
							);
					};
				}
			}

			var group = {};
			var originalGroup = options.group;

			if (!originalGroup || typeof originalGroup != 'object') {
				originalGroup = {name: originalGroup};
			}

			group.name = originalGroup.name;
			group.checkPull = toFn(originalGroup.pull, true);
			group.checkPut = toFn(originalGroup.put);

			options.group = group;
		}
	;



	/**
	 * @class  Sortable
	 * @param  {HTMLElement}  el
	 * @param  {Object}       [options]
	 */
	function Sortable(el, options) {
		if (!(el && el.nodeType && el.nodeType === 1)) {
			throw 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);
		}

		this.el = el; // root element
		this.options = options = _extend({}, options);


		// Export instance
		el[expando] = this;


		// Default options
		var defaults = {
			group: Math.random(),
			sort: true,
			disabled: false,
			store: null,
			handle: null,
			scroll: true,
			scrollSensitivity: 30,
			scrollSpeed: 10,
			draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
			ghostClass: 'sortable-ghost',
			chosenClass: 'sortable-chosen',
			dragClass: 'sortable-drag',
			ignore: 'a, img',
			filter: null,
			animation: 0,
			setData: function (dataTransfer, dragEl) {
              	if ($('html').hasClass('ff')) {
                  dataTransfer.setData('text/html', dragEl.innerHTML);
                } else {
                  dataTransfer.setData('Text', dragEl.textContent);
                }
				
			},
			dropBubble: false,
			dragoverBubble: false,
			dataIdAttr: 'data-id',
			delay: 0,
			forceFallback: false,
			fallbackClass: 'sortable-fallback',
			fallbackOnBody: false,
			fallbackTolerance: 0,
			fallbackOffset: {x: 0, y: 0}
		};


		// Set default options
		for (var name in defaults) {
			!(name in options) && (options[name] = defaults[name]);
		}

		_prepareGroup(options);

		// Bind all private methods
		for (var fn in this) {
			if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
				this[fn] = this[fn].bind(this);
			}
		}

		// Setup drag mode
		this.nativeDraggable = options.forceFallback ? false : supportDraggable;

		// Bind events
		_on(el, 'mousedown', this._onTapStart);
		_on(el, 'touchstart', this._onTapStart);

		if (this.nativeDraggable) {
			_on(el, 'dragover', this);
			_on(el, 'dragenter', this);
	        /* commented this line to fix bug BUG-320265
            _on(el, 'drop', this);
            */
		}

		touchDragOverListeners.push(this._onDragOver);

		// Restore sorting
		options.store && this.sort(options.store.get(this));
	}


	Sortable.prototype = /** @lends Sortable.prototype */ {
		constructor: Sortable,

		_onTapStart: function (/** Event|TouchEvent */evt) {
			var _this = this,
				el = this.el,
				options = this.options,
				type = evt.type,
				touch = evt.touches && evt.touches[0],
				target = (touch || evt).target,
				originalTarget = target,
				filter = options.filter,
				startIndex;

			// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
			if (dragEl) {
				return;
			}

            // BUG-769200: If the event target is from Rich Text editor, return from here
            if (_closest(target, ".cke", el)) {
              return;
            }

			if (type === 'mousedown' && evt.button !== 0 || options.disabled) {
				return; // only left button or enabled
			}

			target = _closest(target, options.draggable, el);

			if (!target) {
				return;
			}

			if (options.handle && !_closest(originalTarget, options.handle, el)) {
				return;
			}

			// Get the index of the dragged element within its parent
			startIndex = _index(target, options.draggable);

			// Check filter
			if (typeof filter === 'function') {
				if (filter.call(this, evt, target, this)) {
					_dispatchEvent(_this, originalTarget, 'filter', target, el, startIndex);
					evt.preventDefault();
					return; // cancel dnd
				}
			}
			else if (filter) {
				filter = filter.split(',').some(function (criteria) {
					criteria = _closest(originalTarget, criteria.trim(), el);

					if (criteria) {
						_dispatchEvent(_this, criteria, 'filter', target, el, startIndex);
						return true;
					}
				});

				if (filter) {
					evt.preventDefault();
					return; // cancel dnd
				}
			}

			// Prepare `dragstart`
			this._prepareDragStart(evt, touch, target, startIndex);
		},

		_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
			var _this = this,
				el = _this.el,
				options = _this.options,
				ownerDocument = el.ownerDocument,
				dragStartFn;

			if (target && !dragEl && (target.parentNode === el)) {
				tapEvt = evt;

				rootEl = el;
				dragEl = target;
				parentEl = dragEl.parentNode;
				nextEl = dragEl.nextSibling;
				activeGroup = options.group;
				oldIndex = startIndex;

				this._lastX = (touch || evt).clientX;
				this._lastY = (touch || evt).clientY;

				dragEl.style['will-change'] = 'transform';

				dragStartFn = function () {
					// Delayed drag has been triggered
					// we can re-enable the events: touchmove/mousemove
					_this._disableDelayedDrag();

					// Make the element draggable
					dragEl.draggable = _this.nativeDraggable;

					// Chosen item
					_toggleClass(dragEl, options.chosenClass, true);
					_toggleClass(dragEl, options.ghostClass, false);

					// Bind the events: dragstart/dragend
					_this._triggerDragStart(touch);

					// Drag start event
					_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, oldIndex);
				};

				// Disable "draggable"
				options.ignore.split(',').forEach(function (criteria) {
					_find(dragEl, criteria.trim(), _disableDraggable);
				});

				_on(ownerDocument, 'mouseup', _this._onDrop);
				_on(ownerDocument, 'touchend', _this._onDrop);
				_on(ownerDocument, 'touchcancel', _this._onDrop);

				if (options.delay) {
					// If the user moves the pointer or let go the click or touch
					// before the delay has been reached:
					// disable the delayed drag
					_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchend', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
					_on(ownerDocument, 'mousemove', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchmove', _this._disableDelayedDrag);

					_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
				} else {
					dragStartFn();
				}
			}
		},

		_disableDelayedDrag: function () {
			var ownerDocument = this.el.ownerDocument;

			clearTimeout(this._dragStartTimer);
			_off(ownerDocument, 'mouseup', this._disableDelayedDrag);
			_off(ownerDocument, 'touchend', this._disableDelayedDrag);
			_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
			_off(ownerDocument, 'mousemove', this._disableDelayedDrag);
			_off(ownerDocument, 'touchmove', this._disableDelayedDrag);
		},

		_triggerDragStart: function (/** Touch */touch) {
			if (touch) {
				// Touch device support
				tapEvt = {
					target: dragEl,
					clientX: touch.clientX,
					clientY: touch.clientY
				};

				this._onDragStart(tapEvt, 'touch');
			}
			else if (!this.nativeDraggable) {
				this._onDragStart(tapEvt, true);
			}
			else {
				_on(dragEl, 'dragend', this);
				_on(rootEl, 'dragstart', this._onDragStart);
			}

			try {
				if (document.selection) {					
					// Timeout neccessary for IE9					
					setTimeout(function () {
						document.selection.empty();
					});					
				} else {
					window.getSelection().removeAllRanges();
				}
			} catch (err) {
			}
		},

		_dragStarted: function () {
			if (rootEl && dragEl) {
				var options = this.options;

				// Apply effect
				_toggleClass(dragEl, options.ghostClass, true);
				_toggleClass(dragEl, options.dragClass, false);

				Sortable.active = this;

				// Drag start event
				_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, oldIndex);
			}
		},

		_emulateDragOver: function () {
			if (touchEvt) {
				if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
					return;
				}

				this._lastX = touchEvt.clientX;
				this._lastY = touchEvt.clientY;

				if (!supportCssPointerEvents) {
					_css(ghostEl, 'display', 'none');
				}

				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),
					parent = target,
					i = touchDragOverListeners.length;

				if (parent) {
					do {
						if (parent[expando]) {
							while (i--) {
								touchDragOverListeners[i]({
									clientX: touchEvt.clientX,
									clientY: touchEvt.clientY,
									target: target,
									rootEl: parent
								});
							}

							break;
						}

						target = parent; // store last element
					}
					/* jshint boss:true */
					while (parent = parent.parentNode);
				}

				if (!supportCssPointerEvents) {
					_css(ghostEl, 'display', '');
				}
			}
		},


		_onTouchMove: function (/**TouchEvent*/evt) {
			if (tapEvt) {
				var	options = this.options,
					fallbackTolerance = options.fallbackTolerance,
					fallbackOffset = options.fallbackOffset,
					touch = evt.touches ? evt.touches[0] : evt,
					dx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x,
					dy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y,
					translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';

				// only set the status to dragging, when we are actually dragging
				if (!Sortable.active) {
					if (fallbackTolerance &&
						min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
					) {
						return;
					}

					this._dragStarted();
				}

				// as well as creating the ghost element on the document body
				this._appendGhost();

				moved = true;
				touchEvt = touch;

				_css(ghostEl, 'webkitTransform', translate3d);
				_css(ghostEl, 'mozTransform', translate3d);
				_css(ghostEl, 'msTransform', translate3d);
				_css(ghostEl, 'transform', translate3d);

				evt.preventDefault();
			}
		},

		_appendGhost: function () {
			if (!ghostEl) {
				var rect = dragEl.getBoundingClientRect(),
					css = _css(dragEl),
					options = this.options,
					ghostRect;

				ghostEl = dragEl.cloneNode(true);

				_toggleClass(ghostEl, options.ghostClass, false);
				_toggleClass(ghostEl, options.fallbackClass, true);
				_toggleClass(ghostEl, options.dragClass, true);

				_css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
				_css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
				_css(ghostEl, 'width', rect.width);
				_css(ghostEl, 'height', rect.height);
				_css(ghostEl, 'opacity', '0.8');
				_css(ghostEl, 'position', 'fixed');
				_css(ghostEl, 'zIndex', '100000');
				_css(ghostEl, 'pointerEvents', 'none');

				options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);

				// Fixing dimensions.
				ghostRect = ghostEl.getBoundingClientRect();
				_css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
				_css(ghostEl, 'height', rect.height * 2 - ghostRect.height);
			}
		},

		_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {
			var dataTransfer = evt.dataTransfer,
				options = this.options;

			this._offUpEvents();

			if (activeGroup.checkPull(this, this, dragEl, evt) == 'clone') {
				cloneEl = _clone(dragEl);
				_css(cloneEl, 'display', 'none');
				rootEl.insertBefore(cloneEl, dragEl);
				_dispatchEvent(this, rootEl, 'clone', dragEl);
			}

			_toggleClass(dragEl, options.dragClass, true);

			if (useFallback) {
				if (useFallback === 'touch') {
					// Bind touch events
					_on(document, 'touchmove', this._onTouchMove);
					_on(document, 'touchend', this._onDrop);
					_on(document, 'touchcancel', this._onDrop);
				} else {
					// Old brwoser
					_on(document, 'mousemove', this._onTouchMove);
					_on(document, 'mouseup', this._onDrop);
				}

				this._loopId = setInterval(this._emulateDragOver, 50);
			}
			else {
				if (dataTransfer) {
					dataTransfer.effectAllowed = 'move';
					options.setData && options.setData.call(this, dataTransfer, dragEl);
				}

				_on(document, 'drop', this);
				setTimeout(this._dragStarted, 0);
			}
		},

		_onDragOver: function (/**Event*/evt) {
			var el = this.el,
				target,
				dragRect,
				revert,
				options = this.options,
				group = options.group,
				activeSortable = Sortable.active,
				isOwner = (activeGroup === group),
				canSort = options.sort;

			if (evt.preventDefault !== void 0) {
				evt.preventDefault();
				!options.dragoverBubble && evt.stopPropagation();
			}

			moved = true;

			if (activeGroup && !options.disabled &&
				(isOwner
					? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
					: (
						putSortable === this ||
						activeGroup.checkPull(this, activeSortable, dragEl, evt) && group.checkPut(this, activeSortable, dragEl, evt)
					)
				) &&
				(evt.rootEl === void 0 || evt.rootEl === this.el) // touch fallback
			) {
				// Smart auto-scrolling
				_autoScroll(evt, options, this.el);

				if (_silent) {
					return;
				}

				target = _closest(evt.target, options.draggable, el);
				dragRect = dragEl.getBoundingClientRect();
				putSortable = this;

				if (revert) {
					_cloneHide(true);
					parentEl = rootEl; // actualization

					if (cloneEl || nextEl) {
						rootEl.insertBefore(dragEl, cloneEl || nextEl);
					}
					else if (!canSort) {
						rootEl.appendChild(dragEl);
					}

					return;
				}


				if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
					(el === evt.target) && (target = _ghostIsLast(el, evt))
				) {
					if (target) {
						if (target.animated) {
							return;
						}

						targetRect = target.getBoundingClientRect();
					}

					_cloneHide(isOwner);

					if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {
						if (!dragEl.contains(el)) {
							el.appendChild(dragEl);
							parentEl = el; // actualization
						}

						this._animate(dragRect, dragEl);
						target && this._animate(targetRect, target);
					}
				}
				else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {
					if (lastEl !== target) {
						lastEl = target;
						lastCSS = _css(target);
						lastParentCSS = _css(target.parentNode);
					}


					var targetRect = target.getBoundingClientRect(),
						width = targetRect.right - targetRect.left,
						height = targetRect.bottom - targetRect.top,
						floating = /left|right|inline/.test(lastCSS.cssFloat + lastCSS.display)
							|| (lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0),
						isWide = (target.offsetWidth > dragEl.offsetWidth),
						isLong = (target.offsetHeight > dragEl.offsetHeight),
						halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,
						nextSibling = target.nextElementSibling,
						moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt),
						after
					;

					if (moveVector !== false) {
						_silent = true;
						setTimeout(_unsilent, 30);

						_cloneHide(isOwner);

						if (moveVector === 1 || moveVector === -1) {
							after = (moveVector === 1);
						}
						else if (floating) {
							var elTop = dragEl.offsetTop,
								tgTop = target.offsetTop;

							if (elTop === tgTop) {
								after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;
							}
							else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {
								after = (evt.clientY - targetRect.top) / height > 0.5;
							} else {
								after = tgTop > elTop;
							}
						} else {
                          	if(!el.contains(dragEl)) { // if container does not contain the preview element
                              	after = halfway && isLong; // fix for BUG-271201
                            } else {
                              	after = (nextSibling !== dragEl) && !isLong || halfway && isLong;
                            }
						}

						if (!dragEl.contains(el)) {
							if (after && !nextSibling) {
								el.appendChild(dragEl);
							} else {
                if (target.parentNode) {
								  target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
                }
							}
						}

						parentEl = dragEl.parentNode; // actualization

						this._animate(dragRect, dragEl);
						this._animate(targetRect, target);
					}
				}
			}
		},

		_animate: function (prevRect, target) {
			var ms = this.options.animation;

			if (ms) {
				var currentRect = target.getBoundingClientRect();

				_css(target, 'transition', 'none');
				_css(target, 'transform', 'translate3d('
					+ (prevRect.left - currentRect.left) + 'px,'
					+ (prevRect.top - currentRect.top) + 'px,0)'
				);

				target.offsetWidth; // repaint

				_css(target, 'transition', 'all ' + ms + 'ms');
				_css(target, 'transform', 'translate3d(0,0,0)');

				clearTimeout(target.animated);
				target.animated = setTimeout(function () {
					_css(target, 'transition', '');
					_css(target, 'transform', '');
					target.animated = false;
				}, ms);
			}
		},

		_offUpEvents: function () {
			var ownerDocument = this.el.ownerDocument;

			_off(document, 'touchmove', this._onTouchMove);
			_off(ownerDocument, 'mouseup', this._onDrop);
			_off(ownerDocument, 'touchend', this._onDrop);
			_off(ownerDocument, 'touchcancel', this._onDrop);
		},

		_onDrop: function (/**Event*/evt) {
			var el = this.el,
				options = this.options;

			clearInterval(this._loopId);
			clearInterval(autoScroll.pid);
			clearTimeout(this._dragStartTimer);

			// Unbind events
			_off(document, 'mousemove', this._onTouchMove);

			if (this.nativeDraggable) {
				_off(document, 'drop', this);
				_off(el, 'dragstart', this._onDragStart);
			}

			this._offUpEvents();

			if (evt) {
				if (moved) {
					evt.preventDefault();
					!options.dropBubble && evt.stopPropagation();
				}

				ghostEl && ghostEl.parentNode.removeChild(ghostEl);

				if (dragEl) {
					if (this.nativeDraggable) {
						_off(dragEl, 'dragend', this);
					}

					_disableDraggable(dragEl);
					dragEl.style['will-change'] = '';

					// Remove class's
					_toggleClass(dragEl, this.options.ghostClass, false);
					_toggleClass(dragEl, this.options.chosenClass, false);

					if (rootEl !== parentEl) {
						newIndex = _index(dragEl, options.draggable);

						if (newIndex >= 0) {

							// Add event
							_dispatchEvent(null, parentEl, 'add', dragEl, rootEl, oldIndex, newIndex);

							// Remove event
							_dispatchEvent(this, rootEl, 'remove', dragEl, rootEl, oldIndex, newIndex);

							// drag from one list and drop into another
							_dispatchEvent(null, parentEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
							_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
						}
					}
					else {
						// Remove clone
						cloneEl && cloneEl.parentNode.removeChild(cloneEl);

						if (dragEl.nextSibling !== nextEl) {
							// Get the index of the dragged element within its parent
							newIndex = _index(dragEl, options.draggable);

							if (newIndex >= 0) {
								// drag & drop within the same list
								_dispatchEvent(this, rootEl, 'update', dragEl, rootEl, oldIndex, newIndex);
								_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
							}
						}
					}

					if (Sortable.active) {
						/* jshint eqnull:true */
						if (newIndex == null || newIndex === -1) {
							newIndex = oldIndex;
						}

						_dispatchEvent(this, rootEl, 'end', dragEl, rootEl, oldIndex, newIndex);

						// Save sorting
						this.save();
					}
				}

			}

			this._nulling();
		},

		_nulling: function() {
			rootEl =
			dragEl =
			parentEl =
			ghostEl =
			nextEl =
			cloneEl =

			scrollEl =
			scrollParentEl =

			tapEvt =
			touchEvt =

			moved =
			newIndex =

			lastEl =
			lastCSS =

			putSortable =
			activeGroup =
			Sortable.active = null;
		},

		handleEvent: function (/**Event*/evt) {
			var type = evt.type;

			if (type === 'dragover' || type === 'dragenter') {
				if (dragEl) {
					this._onDragOver(evt);
					_globalDragOver(evt);
				}
			}
			else if (type === 'drop' || type === 'dragend') {
				this._onDrop(evt);
			}
		},


		/**
		 * Serializes the item into an array of string.
		 * @returns {String[]}
		 */
		toArray: function () {
			var order = [],
				el,
				children = this.el.children,
				i = 0,
				n = children.length,
				options = this.options;

			for (; i < n; i++) {
				el = children[i];
				if (_closest(el, options.draggable, this.el)) {
					order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
				}
			}

			return order;
		},


		/**
		 * Sorts the elements according to the array.
		 * @param  {String[]}  order  order of the items
		 */
		sort: function (order) {
			var items = {}, rootEl = this.el;

			this.toArray().forEach(function (id, i) {
				var el = rootEl.children[i];

				if (_closest(el, this.options.draggable, rootEl)) {
					items[id] = el;
				}
			}, this);

			order.forEach(function (id) {
				if (items[id]) {
					rootEl.removeChild(items[id]);
					rootEl.appendChild(items[id]);
				}
			});
		},


		/**
		 * Save the current sorting
		 */
		save: function () {
			var store = this.options.store;
			store && store.set(this);
		},


		/**
		 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
		 * @param   {HTMLElement}  el
		 * @param   {String}       [selector]  default: `options.draggable`
		 * @returns {HTMLElement|null}
		 */
		closest: function (el, selector) {
			return _closest(el, selector || this.options.draggable, this.el);
		},


		/**
		 * Set/get option
		 * @param   {string} name
		 * @param   {*}      [value]
		 * @returns {*}
		 */
		option: function (name, value) {
			var options = this.options;

			if (value === void 0) {
				return options[name];
			} else {
				options[name] = value;

				if (name === 'group') {
					_prepareGroup(options);
				}
			}
		},


		/**
		 * Destroy
		 */
		destroy: function () {
			var el = this.el;

			el[expando] = null;

			_off(el, 'mousedown', this._onTapStart);
			_off(el, 'touchstart', this._onTapStart);

			if (this.nativeDraggable) {
				_off(el, 'dragover', this);
				_off(el, 'dragenter', this);
			}

			// Remove draggable attributes
			Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
				el.removeAttribute('draggable');
			});

			touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);

			this._onDrop();

			this.el = el = null;
		}
	};


	function _cloneHide(state) {
		if (cloneEl && (cloneEl.state !== state)) {
			_css(cloneEl, 'display', state ? 'none' : '');
			!state && cloneEl.state && rootEl.insertBefore(cloneEl, dragEl);
			cloneEl.state = state;
		}
	}


	function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {
		if (el) {
			ctx = ctx || document;

			do {
				if ((selector === '>*' && el.parentNode === ctx) || _matches(el, selector)) {
					return el;
				}
			}
			while (el !== ctx && (el = el.parentNode));
		}

		return null;
	}


	function _globalDragOver(/**Event*/evt) {
		if (evt.dataTransfer) {
			evt.dataTransfer.dropEffect = 'move';
		}
		evt.preventDefault();
	}


	function _on(el, event, fn) {
		el.addEventListener(event, fn, captureMode);
	}


	function _off(el, event, fn) {
		el.removeEventListener(event, fn, captureMode);
	}


	function _toggleClass(el, name, state) {
		if (el) {
			if (el.classList) {
				el.classList[state ? 'add' : 'remove'](name);
			}
			else {
				var className = (' ' + el.className + ' ').replace(RSPACE, ' ').replace(' ' + name + ' ', ' ');
				el.className = (className + (state ? ' ' + name : '')).replace(RSPACE, ' ');
			}
		}
	}


	function _css(el, prop, val) {
		var style = el && el.style;

		if (style) {
			if (val === void 0) {
				if (document.defaultView && document.defaultView.getComputedStyle) {
					val = document.defaultView.getComputedStyle(el, '');
				}
				else if (el.currentStyle) {
					val = el.currentStyle;
				}

				return prop === void 0 ? val : val[prop];
			}
			else {
				if (!(prop in style)) {
					prop = '-webkit-' + prop;
				}

				style[prop] = val + (typeof val === 'string' ? '' : 'px');
			}
		}
	}


	function _find(ctx, tagName, iterator) {
		if (ctx) {
			var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

			if (iterator) {
				for (; i < n; i++) {
					iterator(list[i], i);
				}
			}

			return list;
		}

		return [];
	}



	function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {
		sortable = (sortable || rootEl[expando]);

		var evt = document.createEvent('Event'),
			options = sortable.options,
			onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);

		evt.initEvent(name, true, true);

		evt.to = rootEl;
		evt.from = fromEl || rootEl;
		evt.item = targetEl || rootEl;
		evt.clone = cloneEl;

		evt.oldIndex = startIndex;
		evt.newIndex = newIndex;

		rootEl.dispatchEvent(evt);

		if (options[onName]) {
			options[onName].call(sortable, evt);
		}
	}


	function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt) {
		var evt,
			sortable = fromEl[expando],
			onMoveFn = sortable.options.onMove,
			retVal;

		evt = document.createEvent('Event');
		evt.initEvent('move', true, true);

		evt.to = toEl;
		evt.from = fromEl;
		evt.dragged = dragEl;
		evt.draggedRect = dragRect;
		evt.related = targetEl || toEl;
		evt.relatedRect = targetRect || toEl.getBoundingClientRect();

		fromEl.dispatchEvent(evt);

		if (onMoveFn) {
			retVal = onMoveFn.call(sortable, evt, originalEvt);
		}

		return retVal;
	}


	function _disableDraggable(el) {
		el.draggable = false;
	}


	function _unsilent() {
		_silent = false;
	}


	/** @returns {HTMLElement|false} */
	function _ghostIsLast(el, evt) {
		var lastEl = el.lastElementChild,
			rect = lastEl.getBoundingClientRect();

		// 5 — min delta
		// abs — нельзя добавлять, а то глюки при наведении сверху
		return (
			(evt.clientY - (rect.top + rect.height) > 5) ||
			(evt.clientX - (rect.right + rect.width) > 5)
		) && lastEl;
	}


	/**
	 * Generate id
	 * @param   {HTMLElement} el
	 * @returns {String}
	 * @private
	 */
	function _generateId(el) {
		var str = el.tagName + el.className + el.src + el.href + el.textContent,
			i = str.length,
			sum = 0;

		while (i--) {
			sum += str.charCodeAt(i);
		}

		return sum.toString(36);
	}

	/**
	 * Returns the index of an element within its parent for a selected set of
	 * elements
	 * @param  {HTMLElement} el
	 * @param  {selector} selector
	 * @return {number}
	 */
	function _index(el, selector) {
		var index = 0;

		if (!el || !el.parentNode) {
			return -1;
		}

		while (el && (el = el.previousElementSibling)) {
			if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && (selector === '>*' || _matches(el, selector))) {
				index++;
			}
		}

		return index;
	}

	function _matches(/**HTMLElement*/el, /**String*/selector) {
		if (el) {
			selector = selector.split('.');

			var tag = selector.shift().toUpperCase(),
				re = new RegExp('\\s(' + selector.join('|') + ')(?=\\s)', 'g');

			return (
				(tag === '' || el.nodeName.toUpperCase() == tag) &&
				(!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length)
			);
		}

		return false;
	}

	function _throttle(callback, ms) {
		var args, _this;

		return function () {
			if (args === void 0) {
				args = arguments;
				_this = this;

				setTimeout(function () {
					if (args.length === 1) {
						callback.call(_this, args[0]);
					} else {
						callback.apply(_this, args);
					}

					args = void 0;
				}, ms);
			}
		};
	}

	function _extend(dst, src) {
		if (dst && src) {
			for (var key in src) {
				if (src.hasOwnProperty(key)) {
					dst[key] = src[key];
				}
			}
		}

		return dst;
	}

	function _clone(el) {
		return $
			? $(el).clone(true)[0]
			: (Polymer && Polymer.dom
				? Polymer.dom(el).cloneNode(true)
				: el.cloneNode(true)
			);
	}

  _on(document, 'touchmove', function (evt) {
		if (Sortable.active) {
			evt.preventDefault();
		}
	});

	try {
		window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
			get: function () {
				captureMode = {
					capture: false,
					passive: false
				};
			}
		}));
	} catch (err) {}

	// Export utils
	Sortable.utils = {
		on: _on,
		off: _off,
		css: _css,
		find: _find,
		is: function (el, selector) {
			return !!_closest(el, selector, el);
		},
		extend: _extend,
		throttle: _throttle,
		closest: _closest,
		toggleClass: _toggleClass,
		clone: _clone,
		index: _index
	};


	/**
	 * Create sortable instance
	 * @param {HTMLElement}  el
	 * @param {Object}      [options]
	 */
	Sortable.create = function (el, options) {
		return new Sortable(el, options);
	};


	// Export
	Sortable.version = '1.4.2';
	return Sortable;
});
//static-content-hash-trigger-GCC
pega.namespace("pega.ui");

/**
 * The purpose of this class is to be used to make children of a HTML element 
 * draggable. As part of the constructor the children of the HTML element
 * will become draggable. Please overriden the given extension points for 
 * each instance of this class.
 * @param $HTML Element$ htmlElement - The parent element to make the children draggable 
 * @param $String$ droupName - The name of the droup to this sortable list belongs to
 * @param {$Object$} options - Additional options 
 * 
 *                   options.sortItems - Enable/disable sorting items within a list
 *                                  Default value is true
 *                   options.animation - The time length of the animation to play on drag
 *                   options.disabled - Option to disable the sortable.
 *                   options.cellMask - Boolean flag for when to add a mast to draggable elements to prevent interaction
 *                   options.customUIClass - A custom class to add to the parent of the draggable elements
 *					 options.delay -  Time in milliseconds to define when the sorting should start
 *					 options.previewOnDrag - If true shows the draggable element at the dragged position instead of a place holder highligh color. 		
 *												Default value is true
 *					 options.dropPosition - Set value to "vertical" if the top and bottom place holder styling is require otherwise set the value to 	
 *												"horizontal" to show the left and right place holder styles. Default value is set to "horizontal". This 
 *												option will be enabled only when previewOnDrag is set to false.
 *					 options.dropPositionLeftClass - class name for the style to be applied on the Left Place Holder
 *					 options.dropPositionRightClass - class name for the style to be applied on the Right Place Holder
 *					 options.dropPositionTopClass - class name for the style to be applied on the Top Place Holder
 *					 options.dropPositionBottomClass - class name for the style to be applied on the Bottom Place Holder
 *					 options.dragHandle - An element containing this class will function as a handle for dragging purposes
 *					 options.ghostClass - class to style the element which is being dragged at the original position
 *					 options.chosenClass - class to style the element which is being dragged at the original position and dragged along with the mouse
 *												pointer
 *					 options.dragClass - class to style the element which is being dragged along with the mouse pointer
 *                   options.putItems - whether elements can be added from other lists into this list - true|false 
 *                                      Default value is true
 *                   options.pullItems - ability to move elements from the list - true|false|'clone'
 *                                       Default value is true
 * 					 options.virtualDrop - ability to prevent the elements adding in DOM when it is dropped - true|false.This 
 *										 option will be enabled only when previewOnDrag is set to false.
 *                                       Default value is true
 *					 options.forceFallback - Forces Sortable to avoid using HTML5 draggable elements, even if the browser supports them. Defaults to
 *											 "false"
 *					 options.filter - list of selector that correspond to children element to not include for dragging and dropping
 */
pega.ui.Sortable = function(htmlElement, groupName, options) {
    /////////////////////////////////////////////////////////////////////////////////
    //                              PRIVATE VARIABLES                              //
    /////////////////////////////////////////////////////////////////////////////////
    var _this = this;
    var _htmlElement = htmlElement;
    if (!_htmlElement) {
        return false;
    }

    if (htmlElement["sortable"]) {
        return htmlElement["sortable"];
    }
	$(htmlElement).attr("sortable","");
    var _previousContainer = htmlElement;
    var _finished, _dragedOverElement, _draggedPosition, _appliedDragClass, _targetElement, _draggedElement, _sourceElement;
  //  var _draggedOutside = false;
    var _leftDropClassName = options.dropPositionLeftClass ? options.dropPositionLeftClass : "drop-position-left";
    var _rightDropClassName = options.dropPositionRightClass ? options.dropPositionRightClass : "drop-position-right";
    var _topDropClassName = options.dropPositionTopClass ? options.dropPositionTopClass : "drop-position-top";
    var _bottomDropClassName = options.dropPositionBottomClass ? options.dropPositionBottomClass : "drop-position-bottom";
    options.dropPosition = options.dropPosition ? options.dropPosition : "horizontal";
    options.previewOnDrag = (typeof options.previewOnDrag !== "undefined") ? options.previewOnDrag : true; //true or false
  	options.virtualDrop =(typeof options.virtualDrop !== "undefined")?options.virtualDrop : true;
    options.sortItems = (options.sortItems !== void 0) ? options.sortItems : true
    if (options === null) options = {};
    if (typeof options.animation == "undefined") options.animation = 250;
    if (options.dragHandle === null) options.dragHandle = "";


    // Add a cell mask if one was specified
    if (options.cellMask) {
      	// Loop over children of the sortable layout, add the cell mask 
        // class to the cell and then add a mask element to the cell
        for (var x = 0; x < htmlElement.children.length; x++) {
          var child = htmlElement.children[x];
          // Just to be safe make sure the cell has not been modified already
          if (!$(child).hasClass("cell-mask")) {
            $(child).append("<div class='mask-element'></div>");
            $(child).addClass("cell-mask");
          }
        }
    }
    // Add a custom class when specified
    if (options.customUIClass) {
        $(htmlElement).addClass(options.customUIClass);
    }

    /**
     * Called to remove the stylings which get applied when previewOnDrag is false
     */
    var _removeCardDragStylings = function() {
        if (_dragedOverElement) {
            $(_dragedOverElement).removeClass(_appliedDragClass);
        }
     
        return true;
    };
    /////////////////////////////////////////////////////////////////////////////////
    //                               PRIVATE FUNCTIONS                             //
    /////////////////////////////////////////////////////////////////////////////////
    /**
     * Called to return a data object with data abstracted out of the Sortable event object
     * @param  $Sortable Event$ e - The event object from sortable
     * @return A trimmed down object with needed data
     */
    function _createDataObject(e) {

        return {
            draggedElement: e.item,
            oldIndex: e.oldIndex,
            newIndex: e.newIndex,
            sourceLocation: e.from,
            targetLocation: e.to,
            previousLocation: _previousContainer
        };
    }

    var _prepareGroup = function(groupName, options) {
        function toFn(value, groupName, pull) {
            if (value === void 0 || value === true) {
                value = groupName;
            }

            if (typeof value === 'function') {
                return value;
            } else {
                return function(to, from) {
                    var fromGroup = from.group.name;
                    return pull ?
                        value :
                        value && (value.join ?
                            value.indexOf(fromGroup) > -1 :
                            (fromGroup === value)
                        );
                };
            }
        }
        var group = {};
        group.name = groupName;
        group.checkPull = toFn(options.pullItems, groupName, true);
        group.checkPut = toFn(options.putItems, groupName);

        _this.group = group;
        return;
    };


    /**
     * @private on drag method. Fires when the element is being dragged.This callback is enabled only when previewOnDrag is set to false.
     * @param  $Sortable Event$ e - The event object from sortable
     * @param  $drag Event$ e - The event object from drag listener
     */
    function _onDrag(e) {

        var dataObj = _createDataObject(e);
        var offset = $(_targetElement).offset();
        var outerWidth = $(_targetElement).outerWidth();
        var outerHeight = $(_targetElement).outerHeight();
        var offsetX = e.pageX - offset.left;
        var offsetY = e.pageY - offset.top;
        if (offsetX <= 0 || offsetY < 0 || offsetX > (offset.left + outerWidth) | offsetY > outerHeight) {
          //  _draggedOutside = true;
            _removeCardDragStylings();
        }/* else {
          //  _draggedOutside = false;
        }*/
        dataObj.draggedElement = _draggedElement;
        dataObj.targetLocation = _targetElement;
        dataObj.sourceLocation = _sourceElement;
        return _this.onDrag(dataObj, e);
    }
    /**
     * @privat drop method.Fires when the dragged element is dropped.This callback is enabled only when previewOnDrag is set to false.
     * @param  $Sortable Event$ e - The event object from sortable
     */

    function _onDrop(e) {
        var isItemAdded = false,
            dataObj = _createDataObject(e),
            addItem = false;
        var currentRect = _draggedElement.getBoundingClientRect();
      //  var prevRect = _dragedOverElement.getBoundingClientRect();
        var offsetLeft = currentRect.left;
        var offsetTop = currentRect.top;
        var parent = _targetElement;
        var target = $(e.target).closest("[sortable]");
      	var sameSrcAndDrgElement=false;
      	if(target)
      	target=target[0];
        var index = Array.prototype.indexOf.call(target.children, _dragedOverElement);
        var dragItemindex = Array.prototype.indexOf.call(parent.children, _draggedElement);
        var dragSortable = _targetElement.sortable;
        var dropSortable = target.sortable;
      if(dropSortable.group){
          if (target !== parent){
             if (!dropSortable.group.checkPut(dropSortable, dragSortable)) {
          _removeCardDragStylings();
            return;
        }
       }
      }
        if(dragSortable.group){
          var pullItem = dragSortable.group.checkPull(dropSortable, dragSortable);
        if (pullItem === 'clone') {
            _draggedElement = _draggedElement.cloneNode(true);
        } else if (!pullItem) {
            if (target !== parent){
               _removeCardDragStylings();
              return
            }
        }
        }
        if (_draggedPosition === "right" || _draggedPosition === "bottom") {
            if (target !== parent) {
                addItem = true;
                _targetElement = target;
                _sourceElement = parent;
              sameSrcAndDrgElement=false;
            } else {
                if (dragItemindex !== (index + 1) && options.sortItems) {
                    addItem = true;
                   sameSrcAndDrgElement=true;
                }
            }
            if (addItem) {
              if(options.virtualDrop){
                target.insertBefore(_draggedElement, target.children[index + 1]);
              }
                if (dragItemindex > (index + 1)) {
                    index = index + 1;
                }
                dataObj.newIndex = index;
                isItemAdded = true;
            }
        } else if (_draggedPosition === "left" || _draggedPosition === "top") {
            if (target !== parent) {
                addItem = true;
                _targetElement = target;
                _sourceElement = parent;
              sameSrcAndDrgElement=false;
            } else {
                if (dragItemindex !== (index !== 0 ? index - 1 : index) && options.sortItems) {
                    addItem = true;
                    sameSrcAndDrgElement = true;
                }
            }
            if (addItem) {
               if(options.virtualDrop){
                target.insertBefore(_draggedElement, target.children[index]);
               }
                if (dragItemindex < index) {
                    index = (index !== 0 ? index - 1 : index);
                }
                dataObj.newIndex = index;
                isItemAdded = true;
            }
        }
        _removeCardDragStylings();
        if (isItemAdded) {
            _sortable._animate({
                left: offsetLeft,
                top: offsetTop
            }, _draggedElement);
            dataObj.draggedElement = _draggedElement;
            dataObj.oldIndex = dragItemindex;
            dataObj.targetLocation = _targetElement;
            dataObj.sourceLocation = _sourceElement;
            dropSortable.htmlElement = _targetElement;
            dragSortable.htmlElement = _sourceElement;

           if($(_draggedElement).length!==0){
              if($(_draggedElement).hasClass(options.ghostClass)){
                $(_draggedElement).removeClass(options.ghostClass)
              }

              if($(_draggedElement).hasClass(options.chosenClass)){
                $(_draggedElement).removeClass(options.chosenClass);
              }
             
     		 }
          if(sameSrcAndDrgElement){
            return _this.onDrop(dataObj);
          }else{
            return dropSortable.onDrop(dataObj);
          }
            
        }
    }

    /**
     * @private internal drag start method. Adds a mouse up and mouse move to handle end when not moving cursor
     * @param  $Sortable Event$ e - The event object from sortable
     */
    function _onStart(e) {

        var dataObj = _createDataObject(e);
        _targetElement = dataObj.targetLocation;
        _sourceElement = dataObj.sourceLocation;
        _draggedElement = e.item;


        if (!options.previewOnDrag || options.pullItems) {
            e.item.addEventListener("drag", _onDrag);
            _draggedElement.ownerDocument.addEventListener("drop", _onDrop, true);
            _draggedElement.ownerDocument.addEventListener("touchend", _onDrop, true);
            _draggedElement.ownerDocument.addEventListener("touchcancel", _onDrop, true);
        }
        _finished = false;
        htmlElement.ownerDocument.defaultView.addEventListener("mouseup", _handleMouseUp);
        return _this.onStart(dataObj);
    }

    /**
     * @private internal move method that is fired when moving an element in a list
     * @param  $Sortable Event$ e - The event object from sortable
     */
    function _onMove(e, originalEvent) {

        var dataObj = _createDataObject(e);
        dataObj.draggedElement = _draggedElement;
        dataObj.relatedElement = e.related;
      
        if (!options.previewOnDrag) {
          //  var offsetTop = e.related.offsetTop;
            var clientWidth = e.related.offsetWidth;
            var clientHeight = e.related.offsetHeight;
            var relatedElementOffset = $(e.related).offset();
            var dragleftMaxValue = (clientWidth / 2) + relatedElementOffset.left;
            var topBorderHeight = (clientHeight / 2) + relatedElementOffset.top;

            _removeCardDragStylings();
            if (options.dropPosition === "vertical") {
                if (originalEvent.clientY < topBorderHeight) {
                    _dragedOverElement = e.related;
                    _appliedDragClass = _topDropClassName;
                    _draggedPosition = "top";
                } else {
                    _dragedOverElement = e.related;
                    _appliedDragClass = _bottomDropClassName
                    _dragedOverElement.style.boxShadow = "";
                    _draggedPosition = "bottom";
                }
            } else if (options.dropPosition === "horizontal") {

                if (originalEvent.clientX <= dragleftMaxValue) {
                    _dragedOverElement = e.related;
                    _appliedDragClass = _leftDropClassName;
                    _draggedPosition = "left";
                } else {
                    _dragedOverElement = e.related;
                    _appliedDragClass = _rightDropClassName;
                    _draggedPosition = "right";
                }
            }
            $(_dragedOverElement).addClass(_appliedDragClass);
            _this.onMove(dataObj, originalEvent);
            return false;
        } else {
            return _this.onMove(dataObj);
        }
    }


    /**
     * @private internal drag end method that is fired when moving is finished
     */
    function _onEnd(e) {
        if (e && !_targetElement.sortable.options.previewOnDrag) {
            _targetElement.ownerDocument.removeEventListener("drop", _onDrop, true);
            _targetElement.ownerDocument.removeEventListener("touchend", _onDrop, true);
            _targetElement.ownerDocument.removeEventListener("touchcancel", _onDrop, true);
            e.item.removeEventListener("drag", _onDrag);
          
        }
      if(e&&e.from){
          var sourceElement=$(e.from).find(e.clone);
               if($(sourceElement).length!==0){
                  if($(sourceElement).hasClass(options.ghostClass)){
                    $(sourceElement).removeClass(options.ghostClass)
                  }
                  if($(sourceElement).hasClass(options.chosenClass)){
                    $(sourceElement).removeClass(options.chosenClass);
                  }
                }
      }
    
        if (_finished === false) {
            _finished = true;
            return _this.onEnd();
        }
    }

    /**
     * @private internal update method that is fired when moving an element in a list
     * @param  $Sortable Event$ e - The event object from sortable
     */
    function _onUpdate(e) {
       _previousContainer = e.from;
       var dataObj = _createDataObject(e);
       if (options.previewOnDrag) {
            return _this.onDrop(dataObj);
       }
    }

    /**
     * @private internal add method that is fired when adding an element to a list
     * @param  $Sortable Event$ e - The event object from sortable
     */
    function _onAdd(e) {
       _previousContainer = e.from;
       var dataObj = _createDataObject(e);
       if (options.previewOnDrag) {
            return _this.onDrop(dataObj);
       }
    }

    /**
     * @private internal remove method that is fired when an element is removed from a list
     * @param  $Sortable Event$ e - The event object from sortable
     */
    function _onRemove(e) {
        var dataObj = _createDataObject(e);
        return _this.onRemove(dataObj, e);
    }

    /**
     * @private internal clone method that is fired when a clone of the element is created for dragging
     * @param  $Sortable Event$ e - The event object from sortable
     */
    function _onClone(e) {
        var dataObj = _createDataObject(e);
        return _this.onClone(dataObj);
    }

    /**
     * @private internal sort method that is fired when the list is updated (add/delete/update)
     * @param  $Sortable Event$ e - The event object from sortable
     */
    function _onSort(e) {
        var dataObj = _createDataObject(e);
        return _this.onSort(dataObj);
    }
   /**
     * @private internal drag start method.When an element is started dragging this function will get invoked.
     * @param  $Sortable Event$ e - The event object from sortable
     */
  function _onDragStart(e){
     var dataObj = _createDataObject(e);
        return _this.onDragStart(dataObj);
  }
    /**
     * attach options to the sortable Obj
     */
    _this.options = options;

    /**
     * @private to track the element has previewOnDrag feature enabled.
     */
    _this.el = htmlElement;

    /**
     * @private to track the element has previewOnDrag feature enabled.
     */
    if (groupName) {
        _prepareGroup(groupName, options);
    }
    /**
     * @private internal mouse up hander that is used to detect when you are mousing up and a move 
     * has not occured. Also adds a mousemove to detect when the user starts dragging an element
     */
    function _handleMouseUp() {
        htmlElement.ownerDocument.defaultView.removeEventListener("mouseup", _handleMouseUp);
        return _onEnd();
    }

    /////////////////////////////////////////////////////////////////////////////////
    //                                PUBLIC FUNCTIONS                             //
    /////////////////////////////////////////////////////////////////////////////////
    /**
     * Called to destroy this instance of the sortable class
     */
    _this.destroy = function() {
        _sortable.destroy();
        if (options.cellMask) {          
          	// Loop over the children of the sortable layouts and clean up the mask element and class
          	for (var x = 0; x < htmlElement.children.length; x++) {
              var child = htmlElement.children[x];
              var mask = child.querySelector(".mask-element");
              
              $(mask).remove();
              $(child).removeClass("cell-mask");
            }
        }

        if (options.customUIClass) {
            $(htmlElement).removeClass(options.customUIClass);
        }
        if (htmlElement["sortable"]) {
            htmlElement["sortable"] = null;
        }
    };

    /**
     * Called to disable this instance of the sortable class
     */
    _this.disable = function() {
        _sortable.option("disabled", true);
    };

    /**
     * Called to enable this instance of the sortable class
     */
    _this.enable = function() {
        _sortable.option("disabled", false);
    };

    /**
     * Get the element associated with this sortable instance
     */
    _this.getElement = function() {
        return _htmlElement;
    };
  
    /**
     * Revert the dropped element back to original position
     */
    _this.revertDrop = function(dataObj) {
        if (dataObj != null && dataObj.draggedElement != null ) {
          dataObj.previousLocation.insertBefore(dataObj.draggedElement, dataObj.previousLocation.children[dataObj.oldIndex])
        }
    };


    /////////////////////////////////////////////////////////////////////////////////
    //                                 EVENT EXTENSIONS                           //
    /////////////////////////////////////////////////////////////////////////////////
    /**
     * EXTENSION - on drag element choosen to be overridden on a per instance basis
     */
    _this.onStart = function(dataObj) {};
   /**
     * EXTENSION - on drag start extension to be overridden on a per instance basis
     */
    _this.onDragStart = function(dataObj) {};

    /**
     * EXTENSION - on move extension to be overridden on a per instance basis
     *
     * @param $DataObject$ dataObj - data provided by the action about the moving item
     */
    _this.onMove = function(dataObj) {};

    /**
     * EXTENSION - on drop extension to be overridden on a per instance basis
     *
     * @param $DataObject$ dataObj - data provided by the action about the moving item
     */
    _this.onDrop = function(dataObj) {};

    /**
     * EXTENSION - on drag extension to be overridden on a per instance basis
     *
     * @param $DataObject$ dataObj - data provided by the action about the drag item
     * @param $Event$ evt - data provided by the drag listener
     */
    _this.onDrag = function(dataObj, evt) {};

    /**
     * EXTENSION - on clone extension to be overridden on a per instance basis
     *
     * @param $DataObject$ dataObj - data provided by the action about the clone item
     */
    _this.onClone = function(dataObj) {};

    /**
     * EXTENSION - on sort extension to be overridden on a per instance basis
     *
     * @param $DataObject$ dataObj - data provided by the action about the sort item
     */
    _this.onSort = function(dataObj) {};

    /**
     * EXTENSION - on remove extension to be overridden on a per instance basis
     *
     * @param $DataObject$ dataObj - data provided by the action about the removed item
     */
    _this.onRemove = function(dataObj) {};

    /**
     * EXTENSION - on drag end extension to be overridden on a per instance basis
     */
    _this.onEnd = function() {};

    /**
     * Adding the function to this scope for unit testing
     */
    _this._onDrag = _onDrag;
    _this._onDrop = _onDrop;

    /////////////////////////////////////////////////////////////////////////////////
    //                              CONSTUCTOR START                               //
    /////////////////////////////////////////////////////////////////////////////////
    var _sortable = Sortable.create(htmlElement, {
        group: {
            'name': groupName,
            'put': (options.putItems !== void 0) ? options.putItems : true,
            'pull': (options.pullItems !== void 0) ? options.pullItems : true
        },
        sort: options.sortItems,
        delay: options.delay ? options.delay : 0,
        animation: options.animation,
        disabled:(options.disabled==="true"||options.disabled===true )? true : false,
        handle: options.dragHandle,
        filter : options.filter,
        dragClass: options.dragClass ? options.dragClass : "dragging",
        onChoose: function(e) {
            return _onStart(e);
        },
        onMove: function(e, originalEvent) {
            return _onMove(e, originalEvent);
        },
        onUpdate: function(e) {
            return _onUpdate(e);
        },
        onStart:function(e){
          return _onDragStart(e);
        },
        onAdd: function(e) {
            return _onAdd(e);
        },
        onEnd: function(e) {
            return _onEnd(e);
        },
        onSort: function(e) {
            return _onSort(e);
        },
        onRemove: function(e) {
            return _onRemove(e);
        },
        onClone: function(e) {
            return _onClone(e);
        },
        ghostClass: options.ghostClass ? options.ghostClass : "dropping",
        chosenClass: options.chosenClass ? options.chosenClass : "dragging",
      	forceFallback: options.forceFallback
    });
    htmlElement["sortable"] = _this;
  return _this;
};
//static-content-hash-trigger-GCC
/*
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.5.2
*/
/*
Bug-1087: Made following changes:
1)In initAttributes added a if(size in pixels<0) for this.setAttributeConfig('height' {...and this.setAttributeConfig('width', {
Task-8423: Collapsable/Expandable button has to be enabled in accessbility mode. Following changes are made
1)In _createClip function the anchor tag is added inside the collapsable div
2)In this.setAttributeConfig('collapse', {, the method is modified to get the anchor tag inside the div. In both the casses the class collapse is added to the anchor tag.

reddn@in.pega.com
1)Removed couple of 'set' api calls in the 'resize' api of LayoutUnit. This has been done to improve performance while resizing the panel.

REDDN :-
Task-21143:- Removed 'resize' api call from the 'render' API to improve Layout intialization performance. 

KUMAR4 :-
BUG-37961 - commented 'this.set('scroll', this._lastScroll);' in expand(). 'scroll' is already set in resize(), which is called just before the commented line of code.
*/
/**
 * @description <p>Provides a fixed layout containing, top, bottom, left, right and center layout units. It can be applied to either the body or an element.</p>
 * @namespace pega.widget
 * @requires pega, dom, element, event
 * @module layout
 * @beta
 */
(function() {
    var Dom = pega.util.Dom,
        Event = pega.util.Event,
        Lang = pega.lang;

    /**
     * @constructor
     * @class Layout
     * @extends pega.util.Element
     * @description <p>Provides a fixed layout containing, top, bottom, left, right and center layout units. It can be applied to either the body or an element.</p>
     * @param {String/HTMLElement} el The element to make contain a layout.
     * @param {Object} attrs Object liternal containing configuration parameters.
    */

    var Layout = function(el, config) {
        if (Lang.isObject(el) && !el.tagName) {
            config = el;
            el = null;
        }
        if (Lang.isString(el)) {
            if (Dom.get(el)) {
                el = Dom.get(el);
            }
        }
        if (!el) {
            el = document.body;
        }

        var oConfig = {
            element: el,
            attributes: config || {}
        };

        Layout.superclass.constructor.call(this, oConfig.element, oConfig.attributes);    
    };

    /**
    * @private
    * @static
    * @property _instances
    * @description Internal hash table for all layout instances
    * @type Object
    */ 
    Layout._instances = {};
    /**
    * @static
    * @method getLayoutById 
    * @description Get's a layout object by the HTML id of the element associated with the Layout object.
    * @return {Object} The Layout Object
    */ 
    Layout.getLayoutById = function(id) {
        if (Layout._instances[id]) {
            return Layout._instances[id];
        }
        return false;
    };

    pega.extend(Layout, pega.util.Element, {
        /**
        * @property browser
        * @description A modified version of the pega.env.ua object
        * @type Object
        */
        browser: function() {
            var b = pega.env.ua;
            b.standardsMode = false;
            b.secure = false;
            return b;
        }(),
        /**
        * @private
        * @property _rendered
        * @description Set to true when the layout is rendered
        * @type Boolean
        */
        _rendered: null,
        /**
        * @private
        * @property _zIndex
        * @description The zIndex to set all LayoutUnits to
        * @type Number
        */
        _zIndex: null,
        /**
        * @private
        * @property _sizes
        * @description A collection of the current sizes of all usable LayoutUnits to be used for calculations
        * @type Object
        */
        _sizes: null,
        /**
        * @private
        * @method _setBodySize
        * @param {Boolean} set If set to false, it will NOT set the size, just perform the calculations (used for collapsing units)
        * @description Used to set the body size of the layout, sets the height and width of the parent container
        */
        _setBodySize: function(set) {
            var h = 0, w = 0;
            set = ((set === false) ? false : true);

            if (this._isBody) {
                h = Dom.getClientHeight();
                w = Dom.getClientWidth();
            } else {
                h = parseInt(this.getStyle('height'), 10);
                w = parseInt(this.getStyle('width'), 10);
                if (isNaN(w)) {
                    w = this.get('element').clientWidth;
                }
                if (isNaN(h)) {
                    h = this.get('element').clientHeight;
                }
            }
            if (this.get('minWidth')) {
                if (w < this.get('minWidth')) {
                    w = this.get('minWidth');
                }
            }
            if (this.get('minHeight')) {
                if (h < this.get('minHeight')) {
                    h = this.get('minHeight');
                }
            }
            if (set) {
                Dom.setStyle(this._doc, 'height', h + 'px');
                Dom.setStyle(this._doc, 'width', w + 'px');
            }
            this._sizes.doc = { h: h, w: w };
            this._setSides(set);
        },
        /**
        * @private
        * @method _setSides
        * @param {Boolean} set If set to false, it will NOT set the size, just perform the calculations (used for collapsing units)
        * @description Used to set the size and position of the left, right, top and bottom units
        */
        _setSides: function(set) {
            var h1 = ((this._top) ? this._top.get('height') : 0),
                h2 = ((this._bottom) ? this._bottom.get('height') : 0),
                h = this._sizes.doc.h,
                w = this._sizes.doc.w;
            set = ((set === false) ? false : true);

            this._sizes.top = {
                h: h1, w: ((this._top) ? w : 0),
                t: 0
            };
            this._sizes.bottom = {
                h: h2, w: ((this._bottom) ? w : 0)
            };
            
            var newH = (h - (h1 + h2));

            this._sizes.left = {
                h: newH, w: ((this._left) ? this._left.get('width') : 0)
            };
            this._sizes.right = {
                h: newH, w: ((this._right) ? this._right.get('width') : 0),
                l: ((this._right) ? (w - this._right.get('width')) : 0),
                t: ((this._top) ? this._sizes.top.h : 0)
            };
            
            if (this._right && set) {
                this._right.set('top', this._sizes.right.t);
                if (!this._right._collapsing) { 
                    this._right.set('left', this._sizes.right.l);
                }
                this._right.set('height', this._sizes.right.h, true);
            }
            if (this._left) {
                this._sizes.left.l = 0;
                if (this._top) {
                    this._sizes.left.t = this._sizes.top.h;
                } else {
                    this._sizes.left.t = 0;
                }
                if (set) {
                    this._left.set('top', this._sizes.left.t);
                    this._left.set('height', this._sizes.left.h, true);
                    this._left.set('left', 0);
                }
            }
            if (this._bottom) {
                this._sizes.bottom.t = this._sizes.top.h + this._sizes.left.h;
                if (set) {
                    this._bottom.set('top', this._sizes.bottom.t);
                    this._bottom.set('width', this._sizes.bottom.w, true);
                }
            }
            if (this._top) {
                if (set) {
                    this._top.set('width', this._sizes.top.w, true);
                }
            }
            this._setCenter(set);
        },
        /**
        * @private
        * @method _setCenter
        * @param {Boolean} set If set to false, it will NOT set the size, just perform the calculations (used for collapsing units)
        * @description Used to set the size and position of the center unit
        */
        _setCenter: function(set) {
            set = ((set === false) ? false : true);
            var h = this._sizes.left.h;
            var w = (this._sizes.doc.w - (this._sizes.left.w + this._sizes.right.w));
            if (set) {
                this._center.set('height', h, true);
                this._center.set('width', w, true);
                this._center.set('top', this._sizes.top.h);
                this._center.set('left', this._sizes.left.w);
            }
            this._sizes.center = { h: h, w: w, t: this._sizes.top.h, l: this._sizes.left.w };
        },
        /**
        * @method getSizes
        * @description Get a reference to the internal Layout Unit sizes object used to build the layout wireframe
        * @return {Object} An object of the layout unit sizes
        */
        getSizes: function() {
            return this._sizes;
        },
        /**
        * @method getUnitById
        * @param {String} id The HTML element id of the unit
        * @description Get the LayoutUnit by it's HTML id
        * @return {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} The LayoutUnit instance
        */
        getUnitById: function(id) {
            return pega.widget.LayoutUnit.getLayoutUnitById(id);
        },
        /**
        * @method getUnitByPosition
        * @param {String} pos The position of the unit in this layout
        * @description Get the LayoutUnit by it's position in this layout
        * @return {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} The LayoutUnit instance
        */
        getUnitByPosition: function(pos) {
            if (pos) {
                pos = pos.toLowerCase();
                if (this['_' + pos]) {
                    return this['_' + pos];
                }
            }
            return false;
        },
        /**
        * @method removeUnit
        * @param {Object} unit The LayoutUnit that you want to remove
        * @description Remove the unit from this layout and resize the layout.
        */
        removeUnit: function(unit) {
            this['_' + unit.get('position')] = null;
            this.resize();
        },
        /**
        * @method addUnit
        * @param {Object} cfg The config for the LayoutUnit that you want to add
        * @description Add a unit to this layout and if the layout is rendered, resize the layout. 
        * @return {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} The LayoutUnit instance
        */
        addUnit: function(cfg) {
            if (!cfg.position) {
                return false;
            }
            if (this['_' + cfg.position]) {
                return false;
            }
            var element = null,
                el = null;

            if (cfg.id) {
                if (Dom.get(cfg.id)) {
                    element = Dom.get(cfg.id);
                    delete cfg.id;

                }
            }
            if (cfg.element) {
                element = cfg.element;
            }
            if(!this.bNewGen) {
				if (!el) {
					el = document.createElement('div');
					var id = Dom.generateId();
					el.id = id;
				}

				if (!element) {
					element = document.createElement('div');
				}
				Dom.addClass(element, 'yui-layout-wrap');
				if (this.browser.ie && !this.browser.standardsMode) {
					el.style.zoom = 1;
					element.style.zoom = 1;
				}

				if (el.firstChild) {
					el.insertBefore(element, el.firstChild);
				} else {
					el.appendChild(element);
				}
				this._doc.appendChild(el);
            }
            var h = false, w = false;

            if (cfg.height) {
                h = parseInt(cfg.height, 10);
            }
            if (cfg.width) {
                w = parseInt(cfg.width, 10);
            }
            var unitConfig = {};
            pega.lang.augmentObject(unitConfig, cfg); // break obj ref

            unitConfig.parent = this;
            
            unitConfig.height = h;
            unitConfig.width = w;
			
			var unit;
			if(this.bNewGen) {
				unitConfig.wrap = Dom.get(cfg.body).parentNode.parentNode;
				unit = new pega.widget.LayoutUnit(Dom.get(cfg.body).parentNode.parentNode.parentNode, unitConfig);
			} else {
				unitConfig.wrap = element;
				unit = new pega.widget.LayoutUnit(el, unitConfig);
			}
            

            unit.on('heightChange', this.resize, this, true);
            unit.on('widthChange', this.resize, this, true);
            unit.on('gutterChange', this.resize, this, true);
            this['_' + cfg.position] = unit;

            if (this._rendered) {
                this.resize();
            }

            return unit;
        },
        /**
        * @private
        * @method _createUnits
        * @description Private method to create units from the config that was passed in.
        */
        _createUnits: function() {
            var units = this.get('units');
            for (var i in units) {
                if (Lang.hasOwnProperty(units, i)) {
                    this.addUnit(units[i]);
                }
            }
        },
        /**
        * @method resize
        * @param {Boolean} set If set to false, it will NOT set the size, just perform the calculations (used for collapsing units)
        * @description Starts the chain of resize routines that will resize all the units.
        * @return {<a href="pega.widget.Layout.html">pega.widget.Layout</a>} The Layout instance
        */
        resize: function(set) {
            set = ((set === false) ? false : true);
            if (set) {
                var retVal = this.fireEvent('beforeResize');
                if (retVal === false) {
                    set = false;
                }
                if (this.browser.ie) {
                    if (this._isBody) {
                        Dom.removeClass(document.documentElement, 'yui-layout');
                        Dom.addClass(document.documentElement, 'yui-layout');
                    } else {
                        this.removeClass('yui-layout');
                        this.addClass('yui-layout');
                    }
                }
            }
            this._setBodySize(set);
            if (set) {
                this.fireEvent('resize', { target: this, sizes: this._sizes });
            }
            return this;
        },
        /**
        * @private
        * @method _setupBodyElements
        * @description Sets up the main doc element when using the body as the main element.
        */
        _setupBodyElements: function() {
            this._doc = Dom.get('layout-doc');
            if (!this._doc) {
                this._doc = document.createElement('div');
                this._doc.id = 'layout-doc';
                if (document.body.firstChild) {
                    document.body.insertBefore(this._doc, document.body.firstChild);
                } else {
                    document.body.appendChild(this._doc);
                }
            }
            this._createUnits();
            this._setBodySize();
            Event.on(window, 'resize', this.resize, this, true);
			if(!this.bNewGen) {
				Dom.addClass(this._doc, 'yui-layout-doc');
			}
		},
        /**
        * @private
        * @method _setupElements
        * @description Sets up the main doc element when not using the body as the main element.
        */
        _setupElements: function() {
						if(!this.bNewGen) {
							this._doc = this.getElementsByClassName('doc')[0];
						} else {
							this._doc = this.getElementsByClassName('yui-layout-doc')[0];
						}
            if (!this._doc) {
                this._doc = document.createElement('div');
                this.get('element').appendChild(this._doc);
            }
            this._createUnits();
            this._setBodySize();
            Event.on(window, 'resize', this.resize, this, true);
						if(!this.bNewGen) {
							Dom.addClass(this._doc, 'yui-layout-doc');
						}
        },
        /**
        * @private
        * @property _isBody
        * @description Flag to determine if we are using the body as the root element.
        * @type Boolean
        */
        _isBody: null,
        /**
        * @private
        * @property _doc
        * @description Reference to the root element
        * @type HTMLElement
        */
        _doc: null,
        /**
        * @private
        * @property _left
        * @description Reference to the left LayoutUnit Object
        * @type {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} A LayoutUnit instance
        */
        _left: null,
        /**
        * @private
        * @property _right
        * @description Reference to the right LayoutUnit Object
        * @type {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} A LayoutUnit instance
        */
        _right: null,
        /**
        * @private
        * @property _top
        * @description Reference to the top LayoutUnit Object
        * @type {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} A LayoutUnit instance
        */
        _top: null,
        /**
        * @private
        * @property _bottom
        * @description Reference to the bottom LayoutUnit Object
        * @type {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} A LayoutUnit instance
        */
        _bottom: null,
        /**
        * @private
        * @property _center
        * @description Reference to the center LayoutUnit Object
        * @type {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} A LayoutUnit instance
        */
        _center: null,
        /**
        * @private
        * @method init
        * @description The Layout class' initialization method
        */        
        init: function(p_oElement, p_oAttributes) {
            this._zIndex = 0;
            Layout.superclass.init.call(this, p_oElement, p_oAttributes);
            
            if (this.get('parent')) {
                this._zIndex = this.get('parent')._zIndex + 10;
            }

            this._sizes = {};

            var id = p_oElement;
            if (!Lang.isString(id)) {
                id = Dom.generateId(id);
            }
			if(Dom.get("layout-doc").getAttribute("data-newgen") === "true") {
				this.bNewGen = true;
			} else {
				this.bNewGen = false;
			}
            Layout._instances[id] = this;
        },
        /**
        * @method render
        * @description This method starts the render process, applying classnames and creating elements
        * @return {<a href="pega.widget.Layout.html">pega.widget.Layout</a>} The Layout instance
        */        
        render: function() {
            this._stamp();
            var el = this.get('element');
            if (el && el.tagName && (el.tagName.toLowerCase() == 'body')) {
                this._isBody = true;
                if(!this.bNewGen) {
					Dom.addClass(document.body, 'yui-layout');
					if (Dom.hasClass(document.body, 'yui-skin-sam')) {
						//Move the class up so we can have a css chain
						Dom.addClass(document.documentElement, 'yui-skin-sam');
						Dom.removeClass(document.body, 'yui-skin-sam');
					}
                }
                this._setupBodyElements();
            } else {
                this._isBody = false;
                this.addClass('yui-layout');
                this._setupElements();
            }
	   /* REDDN :- Task-21143:- Removed 'resize' api call to improve Layout intialization performance. */
            /*this.resize();*/
            this._rendered = true;
            this.fireEvent('render');

            return this;
        },
        /**
        * @private
        * @method _stamp
        * @description Stamps the root node with a secure classname for ease of use. Also sets the this.browser.standardsMode variable.
        */        
        _stamp: function() {
            if (document.compatMode == 'CSS1Compat') {
                this.browser.standardsMode = true;
            }
            if (window.location.href.toLowerCase().indexOf("https") === 0) {
                Dom.addClass(document.documentElement, 'secure');
                this.browser.secure = true;
            }
        },
        /**
        * @private
        * @method initAttributes
        * @description Processes the config
        */        
        initAttributes: function(attr) {
            Layout.superclass.initAttributes.call(this, attr);
            /**
            * @attribute units
            * @description An array of config definitions for the LayoutUnits to add to this layout
            * @type Array
            */
            this.setAttributeConfig('units', {
                writeOnce: true,
                validator: pega.lang.isArray,
                value: attr.units || []
            });

            /**
            * @attribute minHeight
            * @description The minimum height in pixels
            * @type Number
            */
            this.setAttributeConfig('minHeight', {
                value: attr.minHeight || false,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute minWidth
            * @description The minimum width in pixels
            * @type Number
            */
            this.setAttributeConfig('minWidth', {
                value: attr.minWidth || false,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute height
            * @description The height in pixels
            * @type Number
            */
            this.setAttributeConfig('height', {
                value: attr.height || false,
                validator: pega.lang.isNumber,
                method: function(h) {
                    this.setStyle('height', h + 'px');
                }
            });

            /**
            * @attribute width
            * @description The width in pixels
            * @type Number
            */
            this.setAttributeConfig('width', {
                value: attr.width || false,
                validator: pega.lang.isNumber,
                method: function(w) {
                    this.setStyle('width', w + 'px');
                }
            });

            /**
            * @attribute parent
            * @description If this layout is to be used as a child of another Layout instance, this config will bind the resize events together.
            * @type Object pega.widget.Layout
            */
            this.setAttributeConfig('parent', {
                writeOnce: true,
                value: attr.parent || false,
                method: function(p) {
                    if (p) {
                        p.on('resize', this.resize, this, true);
                    }
                }
            });
        },
        /**
        * @method toString
        * @description Returns a string representing the Layout.
        * @return {String}
        */        
        toString: function() {
            if (this.get) {
                return 'Layout #' + this.get('id');
            }
            return 'Layout';
        }
    });
    /**
    * @event resize
    * @description Fired when this.resize is called
    * @type pega.util.CustomEvent
    */
    /**
    * @event startResize
    * @description Fired when the Resize Utility for a Unit fires it's startResize Event.
    * @type pega.util.CustomEvent
    */
    /**
    * @event beforeResize
    * @description Firef at the beginning of the resize method. If you return false, the resize is cancelled.
    * @type pega.util.CustomEvent
    */
    /**
    * @event render
    * @description Fired after the render method completes.
    * @type pega.util.CustomEvent
    */

    pega.widget.Layout = Layout;
})();
/**
 * @description <p>Provides a fixed position unit containing a header, body and footer for use with a pega.widget.Layout instance.</p>
 * @namespace pega.widget
 * @requires pega, dom, element, event, layout
 * @optional animation, dragdrop, selector
 * @beta
 */
(function() {
    var Dom = pega.util.Dom,
        Sel = pega.util.Selector,
        Event = pega.util.Event,
        Lang = pega.lang;

    /**
     * @constructor
     * @class LayoutUnit
     * @extends pega.util.Element
     * @description <p>Provides a fixed position unit containing a header, body and footer for use with a pega.widget.Layout instance.</p>
     * @param {String/HTMLElement} el The element to make a unit.
     * @param {Object} attrs Object liternal containing configuration parameters.
    */

    var LayoutUnit = function(el, config) {
        
        var oConfig = {
            element: el,
            attributes: config || {}
        };

        LayoutUnit.superclass.constructor.call(this, oConfig.element, oConfig.attributes);    
    };

    /**
    * @private
    * @static
    * @property _instances
    * @description Internal hash table for all layout unit instances
    * @type Object
    */ 
    LayoutUnit._instances = {};
    /**
    * @static
    * @method getLayoutUnitById 
    * @description Get's a layout unit object by the HTML id of the element associated with the Layout Unit object.
    * @return {Object} The Layout Object
    */ 
    LayoutUnit.getLayoutUnitById = function(id) {
        if (LayoutUnit._instances[id]) {
            return LayoutUnit._instances[id];
        }
        return false;
    };

    pega.extend(LayoutUnit, pega.util.Element, {
        /**
        * @property STR_CLOSE
        * @description String used for close button title
        * @type {String}
        */
        STR_CLOSE: 'Click to close this pane.',
        /**
        * @property STR_COLLAPSE
        * @description String used for collapse button title
        * @type {String}
        */
        STR_COLLAPSE: 'Click to collapse this pane.',
        /**
        * @property STR_EXPAND
        * @description String used for expand button title
        * @type {String}
        */
        STR_EXPAND: 'Click to expand this pane.',
        /**
        * @property browser
        * @description A modified version of the pega.env.ua object
        * @type Object
        */
        browser: null,
        /**
        * @private
        * @property _sizes
        * @description A collection of the current sizes of the contents of this Layout Unit
        * @type Object
        */
        _sizes: null,
        /**
        * @private
        * @property _anim
        * @description A reference to the Animation instance used by this LayouUnit
        * @type pega.util.Anim
        */
        _anim: null,
        /**
        * @private
        * @property _resize
        * @description A reference to the Resize instance used by this LayoutUnit
        * @type pega.util.Resize
        */
        _resize: null,
        /**
        * @private
        * @property _clip
        * @description A reference to the clip element used when collapsing the unit
        * @type HTMLElement
        */
        _clip: null,
        /**
        * @private
        * @property _gutter
        * @description A simple hash table used to store the gutter to apply to the Unit
        * @type Object
        */
        _gutter: null,
        /**
        * @property header
        * @description A reference to the HTML element used for the Header
        * @type HTMLELement
        */
        header: null,
        /**
        * @property body
        * @description A reference to the HTML element used for the body
        * @type HTMLElement
        */
        body: null,
        /**
        * @property footer
        * @description A reference to the HTML element used for the footer
        * @type HTMLElement
        */
        footer: null,
        /**
        * @private
        * @property _collapsed
        * @description Flag to determine if the unit is collapsed or not.
        * @type Boolean
        */
        _collapsed: null,
        /**
        * @private
        * @property _collapsing
        * @description A flag set while the unit is being collapsed, used so we don't fire events while animating the size
        * @type Boolean
        */
        _collapsing: null,
        /**
        * @private
        * @property _lastWidth
        * @description A holder for the last known width of the unit
        * @type Number
        */
        _lastWidth: null,
        /**
        * @private
        * @property _lastHeight
        * @description A holder for the last known height of the unit
        * @type Number
        */
        _lastHeight: null,
        /**
        * @private
        * @property _lastTop
        * @description A holder for the last known top of the unit
        * @type Number
        */
        _lastTop: null,
        /**
        * @private
        * @property _lastLeft
        * @description A holder for the last known left of the unit
        * @type Number
        */
        _lastLeft: null,
        /**
        * @private
        * @property _lastScroll
        * @description A holder for the last known scroll state of the unit
        * @type Boolean
        */
        _lastScroll: null,
        /**
        * @private
        * @property _lastCenetrScroll
        * @description A holder for the last known scroll state of the center unit
        * @type Boolean
        */
        _lastCenterScroll: null,
        /**
        * @private
        * @property _lastScrollTop
        * @description A holder for the last known scrollTop state of the unit
        * @type Number
        */
        _lastScrollTop: null,
        /**
        * @method resize
        * @description Resize either the unit or it's clipped state, also updating the box inside
        * @param {Boolean} force This will force full calculations even when the unit is collapsed
        * @return {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} The LayoutUnit instance
        */
        resize: function(force) {
            var retVal = this.fireEvent('beforeResize');
            if (retVal === false) {
                return this;
            }
            if (!this._collapsing || (force === true)) {
                var scroll = this.get('scroll');

	       /** Commenting this call -- Equivalent statements are written below  **/
	       /* this.set('scroll', false); */
		/** NEW code starts here **/
		this.body.firstChild.setAttribute("scroll", false);
	         this.addClass('yui-layout-scroll');
                  this.removeClass('yui-layout-noscroll');
		/** NEW code ends here **/

                var hd = this._getBoxSize(this.header),
                    ft = this._getBoxSize(this.footer),
                    box = [this.get('height'), this.get('width')];


                var nh = (box[0] - hd[0] - ft[0]) - (this._gutter.top + this._gutter.bottom),
                    nw = box[1] - (this._gutter.left + this._gutter.right);

                var wrapH = (nh + (hd[0] + ft[0])),
                    wrapW = nw;

                if (this._collapsed && !this._collapsing) {
                    this._setHeight(this._clip, wrapH);
                    this._setWidth(this._clip, wrapW);
                    Dom.setStyle(this._clip, 'top', this.get('top') + this._gutter.top + 'px');
                    Dom.setStyle(this._clip, 'left', this.get('left') + this._gutter.left + 'px');
                } else if (!this._collapsed || (this._collapsed && this._collapsing)) {
                    wrapH = this._setHeight(this.get('wrap'), wrapH);
                    wrapW = this._setWidth(this.get('wrap'), wrapW);
                    this._sizes.wrap.h = wrapH;
                    this._sizes.wrap.w = wrapW;

                    Dom.setStyle(this.get('wrap'), 'top', this._gutter.top + 'px');
                    Dom.setStyle(this.get('wrap'), 'left', this._gutter.left + 'px');

                    this._sizes.header.w = this._setWidth(this.header, wrapW);
                    this._sizes.header.h = hd[0];

                    this._sizes.footer.w = this._setWidth(this.footer, wrapW);
                    this._sizes.footer.h = ft[0];

                    Dom.setStyle(this.footer, 'bottom', '0px');

                    this._sizes.body.h = this._setHeight(this.body, (wrapH - (hd[0] + ft[0])));
                    this._sizes.body.w =this._setWidth(this.body, wrapW);
                    Dom.setStyle(this.body, 'top', hd[0] + 'px');

		  /** Commenting this call -- Equivalent statements are written below  **/
                    /*this.set('scroll', scroll);*/
		  /** NEW code starts here **/
		  this.body.firstChild.setAttribute("scroll", scroll);
		  this.addClass('yui-layout-scroll');
		  /** NEW code ends here **/
		  this.fireEvent('resize');
                }
            }
            return this;
        },
        /**
        * @private
        * @method _setWidth
        * @description Sets the width of the element based on the border size of the element.
        * @param {HTMLElement} el The HTMLElement to have it's width set
        * @param {Number} w The width that you want it the element set to
        * @return {Number} The new width, fixed for borders and IE QuirksMode
        */
        _setWidth: function(el, w) {
            if (el) {
                Dom.setStyle(el, 'width', w + 'px');
            }
            return w;
        },
        /**
        * @private
        * @method _setHeight
        * @description Sets the height of the element based on the border size of the element.
        * @param {HTMLElement} el The HTMLElement to have it's height set
        * @param {Number} h The height that you want it the element set to
        * @return {Number} The new height, fixed for borders and IE QuirksMode
        */
        _setHeight: function(el, h) {
            if (el) {
                var b = this._getBorderSizes(el);
                h = (h - (b[0] + b[2]));
                h = this._fixQuirks(el, h, 'h');
                Dom.setStyle(el, 'height', h + 'px');
            }
            return h;
        },
        /**
        * @private
        * @method _fixQuirks
        * @description Fixes the box calculations for IE in QuirksMode
        * @param {HTMLElement} el The HTMLElement to set the dimension on
        * @param {Number} dim The number of the dimension to fix
        * @param {String} side The dimension (h or w) to fix. Defaults to h
        * @return {Number} The fixed dimension
        */
        _fixQuirks: function(el, dim, side) {
            var i1 = 0, i2 = 2;
            if (side == 'w') {
                i1 = 1;
                i2 = 3;
            }
            if (this.browser.ie && !this.browser.standardsMode) {
                //Internet Explorer - Quirks Mode
                var b = this._getBorderSizes(el),
                    bp = this._getBorderSizes(el.parentNode);
                if ((b[i1] === 0) && (b[i2] === 0)) { //No Borders, check parent
                    if ((bp[i1] !== 0) && (bp[i2] !== 0)) { //Parent has Borders
                        dim = (dim - (bp[i1] + bp[i2]));
                    }
                } else {
                    if ((bp[i1] === 0) && (bp[i2] === 0)) {
                        dim = (dim + (b[i1] + b[i2]));
                    }
                }
            }
            return dim;
        },
        /**
        * @private
        * @method _getBoxSize
        * @description Get's the elements clientHeight and clientWidth plus the size of the borders
        * @param {HTMLElement} el The HTMLElement to get the size of
        * @return {Array} An array of height and width
        */
        _getBoxSize: function(el) {
            var size = [0, 0];
            if (el) {
                if (this.browser.ie && !this.browser.standardsMode) {
                    el.style.zoom = 1;
                }
                var b = this._getBorderSizes(el);
                size[0] = el.clientHeight + (b[0] + b[2]);
                size[1] = el.clientWidth + (b[1] + b[3]);
            }
            return size;
        },
        /**
        * @private
        * @method _getBorderSizes
        * @description Get the CSS border size of the element passed.
        * @param {HTMLElement} el The element to get the border size of
        * @return {Array} An array of the top, right, bottom, left borders.
        */
        _getBorderSizes: function(el) {
            var s = [];
            el = el || this.get('element');
						if(!this.bNewGen) {
							if (this.browser.ie && !this.browser.standardsMode) {
									el.style.zoom = 1;
							}
						}
            s[0] = parseInt(Dom.getStyle(el, 'borderTopWidth'), 10);
            s[1] = parseInt(Dom.getStyle(el, 'borderRightWidth'), 10);
            s[2] = parseInt(Dom.getStyle(el, 'borderBottomWidth'), 10);
            s[3] = parseInt(Dom.getStyle(el, 'borderLeftWidth'), 10);
            
            //IE will return NaN on these if they are set to auto, we'll set them to 0
            for (var i = 0; i < s.length; i++) {
                if (isNaN(s[i])) {
                    s[i] = 0;
                }
            }
            return s;
        },
        /**
        * @private
        * @method _createClip
        * @description Create the clip element used when the Unit is collapsed
        */
        _createClip: function() {
            if (!this._clip) {
                this._clip = document.createElement('div');
                this._clip.className = 'yui-layout-clip yui-layout-clip-' + this.get('position');
		this.STR_EXPAND = pega.u.d.fieldValuesList.get("STR_EXPAND");
                this._clip.innerHTML = '<div class="collapse_div"><button type="button" class="collapse" title="'+this.STR_EXPAND+'"></button></div>';
                var c = this._clip.firstChild;                
	       Event.on(c, 'click', this.expand, this, true);
                this.get('element').parentNode.appendChild(this._clip);
            }
        },
        /**
        * @private
        * @method _toggleClip
        * @description Toggle th current state of the Clip element and set it's height, width and position
        */
        _toggleClip: function() {
            if (!this._collapsed) {
                //show
                var hd = this._getBoxSize(this.header),
                    ft = this._getBoxSize(this.footer),
                    box = [this.get('height'), this.get('width')];


                var nh = (box[0] - hd[0] - ft[0]) - (this._gutter.top + this._gutter.bottom),
                    nw = box[1] - (this._gutter.left + this._gutter.right),
                    wrapH = (nh + (hd[0] + ft[0]));

                switch (this.get('position')) {
                    case 'top':
                    case 'bottom':
                        this._setWidth(this._clip, nw);
                        this._setHeight(this._clip, this.get('collapseSize'));
                        Dom.setStyle(this._clip, 'left', (this._lastLeft + this._gutter.left) + 'px');
                        if (this.get('position') == 'bottom') {
                            Dom.setStyle(this._clip, 'top', ((this._lastTop + this._lastHeight) - (this.get('collapseSize') - this._gutter.top)) + 'px');
                        } else {
                            Dom.setStyle(this._clip, 'top', this.get('top') + this._gutter.top + 'px');
                        }
                        break;
                    case 'left':
                    case 'right':
                        this._setWidth(this._clip, this.get('collapseSize'));
                        this._setHeight(this._clip, wrapH);
                        Dom.setStyle(this._clip, 'top', (this.get('top') + this._gutter.top) + 'px');
                        if (this.get('position') == 'right') {
                            Dom.setStyle(this._clip, 'left', (((this._lastLeft + this._lastWidth) - this.get('collapseSize')) - this._gutter.left) + 'px');
                        } else {
                            Dom.setStyle(this._clip, 'left', (this.get('left') + this._gutter.left) + 'px');
                        }
                        break;
                }

                Dom.setStyle(this._clip, 'display', 'block');
                this.setStyle('display', 'none');
            } else {
                //Hide
                Dom.setStyle(this._clip, 'display', 'none');
            }
        },
        /**
        * @method getSizes
        * @description Get a reference to the internal sizes object for this unit
        * @return {Object} An object of the sizes used for calculations
        */
        getSizes: function() {
            return this._sizes;
        },
        /**
        * @method toggle
        * @description Toggles the Unit, replacing it with a clipped version.
        * @return {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} The LayoutUnit instance
        */
        toggle: function() {
            if (this._collapsed) {
                this.expand();
            } else {
                this.collapse();
            }
            return this;
        },
        /**
        * @method expand
        * @description Expand the Unit if it is collapsed.
        * @return {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} The LayoutUnit instance
        */
        expand: function() {
            if (!this._collapsed) {
                return this;
            }
            var retVal = this.fireEvent('beforeExpand');
            if (retVal === false) {
                return this;
            }

            this._collapsing = true;
            this.setStyle('zIndex', this.get('parent')._zIndex + 1);

            if (this._anim) {
                this.setStyle('display', 'none');
                //Animation Fails Here
                var attr = {}, s;

                switch (this.get('position')) {
                    case 'left':
                    case 'right':
                        this.set('width', this._lastWidth, true);
                        this.setStyle('width', this._lastWidth + 'px');
                        this.get('parent').resize(false);
                        s = this.get('parent').getSizes()[this.get('position')];
                        this.set('height', s.h, true);
                        var left = s.l;
                        attr = {
                            left: {
                                to: left
                            }
                        };
                        if (this.get('position') == 'left') {
                            attr.left.from = (left - s.w);
                            this.setStyle('left', (left - s.w) + 'px');
                        }
                        break;
                    case 'top':
                    case 'bottom':
                        this.set('height', this._lastHeight, true);
                        this.setStyle('height', this._lastHeight + 'px');
                        this.get('parent').resize(false);
                        s = this.get('parent').getSizes()[this.get('position')];
                        this.set('width', s.w, true);
                        var top = s.t;
                        attr = {
                            top: {
                                to: top
                            }
                        };
                        if (this.get('position') == 'top') {
                            this.setStyle('top',  (top - s.h) + 'px');
                            attr.top.from = (top - s.h);
                        }
                        break;
                }

                this._anim.attributes = attr;
                var exStart = function() {
                    this.setStyle('display', 'block');
                    this.resize(true);
                    this._anim.onStart.unsubscribe(exStart, this, true);
                };
                var expand = function() {
                    this._collapsing = false;
                    this.setStyle('zIndex', this.get('parent')._zIndex);
                    this.set('width', this._lastWidth);
                    this.set('height', this._lastHeight);
                    this._collapsed = false;
                    this.resize();

					//kumar4-commenting the following code to solve BUG-37961. 'scroll' is already set in resize() that's called above.
                    //this.set('scroll', this._lastScroll);
                    if (this._lastScrollTop > 0) {
                        this.body.scrollTop = this._lastScrollTop;
                    }
                    this._anim.onComplete.unsubscribe(expand, this, true);
                    this.fireEvent('expand');
                };
                this._anim.onStart.subscribe(exStart, this, true);
                this._anim.onComplete.subscribe(expand, this, true);
                this._anim.animate();
                this._toggleClip();
            } else {
                this._collapsing = false;
                this._toggleClip();
                this.setStyle('zIndex', this.get('parent')._zIndex);
                this.setStyle('display', 'block');
                this.set('width', this._lastWidth);
                this.set('height', this._lastHeight);
                this._collapsed = false;
                this.resize();

				//kumar4-commenting the following code to solve BUG-37961. 'scroll' is already set in resize() that's called above.
                //this.set('scroll', this._lastScroll);
                if (this._lastScrollTop > 0) {
                    this.body.scrollTop = this._lastScrollTop;
                }
                this.fireEvent('expand');
            }
            return this;
        },
        /**
        * @method collapse
        * @description Collapse the Unit if it is not collapsed.
        * @return {<a href="pega.widget.LayoutUnit.html">pega.widget.LayoutUnit</a>} The LayoutUnit instance
        */
        collapse: function() {
            if (this._collapsed) {
                return this;
            }
            var retValue = this.fireEvent('beforeCollapse');
            if (retValue === false) {
                return this;
            }
            if (!this._clip) {
                this._createClip();
            }
            this._collapsing = true;
            var w = this.get('width'),
                h = this.get('height'),
                attr = {};
            this._lastWidth = w;
            this._lastHeight = h;
            this._lastScroll = this.get('scroll');
            this._lastScrollTop = this.body.scrollTop;            
            this.set('scroll', false, true);
            this._lastLeft = parseInt(this.get('element').style.left, 10);
            this._lastTop = parseInt(this.get('element').style.top, 10);
            if (isNaN(this._lastTop)) {
                this._lastTop = 0;
                this.set('top', 0);
            }
            if (isNaN(this._lastLeft)) {
                this._lastLeft = 0;
                this.set('left', 0);
            }
            this.setStyle('zIndex', this.get('parent')._zIndex + 1);
            var pos = this.get('position');

            switch (pos) {
                case 'top':
                case 'bottom':
                    this.set('height', (this.get('collapseSize') + (this._gutter.top + this._gutter.bottom)));
                    attr = {
                        top: {
                            to: (this.get('top') - h)
                        }
                    };
                    if (pos == 'bottom') {
                        attr.top.to = (this.get('top') + h);
                    }
                    break;
                case 'left':
                case 'right':
                    this.set('width', (this.get('collapseSize') + (this._gutter.left + this._gutter.right)));
                    attr = {
                        left: {
                            to: -(this._lastWidth)
                        }
                    };
                    if (pos == 'right') {
                        attr.left = {
                            to: (this.get('left') + w)
                        };
                    }
                    break;
            }
            if (this._anim) {
                this._anim.attributes = attr;
                var collapse = function() {
                    this._collapsing = false;
                    this._toggleClip();
                    this.setStyle('zIndex', this.get('parent')._zIndex);
                    this._collapsed = true;
                    this.get('parent').resize();
                    this._anim.onComplete.unsubscribe(collapse, this, true);
                    this.fireEvent('collapse');
                };
                this._anim.onComplete.subscribe(collapse, this, true);
                this._anim.animate();
            } else {
                this._collapsing = false;
                this.setStyle('display', 'none');
                this._toggleClip();
                this.setStyle('zIndex', this.get('parent')._zIndex);
                this.get('parent').resize();
                this._collapsed = true;
                this.fireEvent('collapse');
            }
            return this;
        },
        /**
        * @method close
        * @description Close the unit, removing it from the parent Layout.
        * @return {<a href="pega.widget.Layout.html">pega.widget.Layout</a>} The parent Layout instance
        */
        close: function() {
            this.setStyle('display', 'none');
            this.get('parent').removeUnit(this);
            this.fireEvent('close');
            if (this._clip) {
                this._clip.parentNode.removeChild(this._clip);
                this._clip = null;
            }
            return this.get('parent');
        },
        /**
        * @private
        * @method init
        * @description The initalization method inherited from Element.
        */
        init: function(p_oElement, p_oAttributes) {
            this._gutter = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            this._sizes = {
                wrap: {
                    h: 0,
                    w: 0
                },
                header: {
                    h: 0,
                    w: 0
                },
                body: {
                    h: 0,
                    w: 0
                },
                footer: {
                    h: 0,
                    w: 0
                }
            };
            
            LayoutUnit.superclass.init.call(this, p_oElement, p_oAttributes);

            this.browser = this.get('parent').browser;
            
            var id = p_oElement;
            if (!Lang.isString(id)) {
                id = Dom.generateId(id);
            }
            LayoutUnit._instances[id] = this;
			
			if(Dom.get("layout-doc").getAttribute("data-newgen") === "true") {
				this.bNewGen = true;
			} else {
				this.bNewGen = false;
			}
            if(!this.bNewGen) {
			 this.setStyle('position', 'absolute');

             this.addClass('yui-layout-unit');
             this.addClass('yui-layout-unit-' + this.get('position'));
			}
			
            var header = this.getElementsByClassName('yui-layout-hd', 'div')[0];
            if (header) {
                this.header = header;
            }
            var body = this.getElementsByClassName('yui-layout-bd', 'div')[0];
            if (body) {
                this.body = body;
            }
            var footer = this.getElementsByClassName('yui-layout-ft', 'div')[0];
            if (footer) {
                this.footer = footer;
            }

            this.on('contentChange', this.resize, this, true);
            this._lastScrollTop = 0;

            this.set('animate', this.get('animate'));
        },
        /**
        * @private
        * @method initAttributes
        * @description Processes the config
        */        
        initAttributes: function(attr) {
            LayoutUnit.superclass.initAttributes.call(this, attr);

            /**
            * @private
            * @attribute wrap
            * @description A reference to the wrap element
            * @type HTMLElement
            */
            this.setAttributeConfig('wrap', {
                value: attr.wrap || null,
                method: function(w) {
                    if (w) {
                        var id = Dom.generateId(w);
                        LayoutUnit._instances[id] = this;
                    }
                }
            });
            /**
            * @attribute grids
            * @description Set this option to true if you want the LayoutUnit to fix the first layer of YUI CSS Grids (margins)
            * @type Boolean
            */
            this.setAttributeConfig('grids', {
                value: attr.grids || false
            });
            /**
            * @private
            * @attribute top
            * @description The current top positioning of the Unit
            * @type Number
            */
            this.setAttributeConfig('top', {
                value: attr.top || 0,
                validator: Lang.isNumber,
                method: function(t) {
                    if (!this._collapsing) {
                        this.setStyle('top', t + 'px');
                    }
                }
            });
            /**
            * @private
            * @attribute left
            * @description The current left position of the Unit
            * @type Number
            */
            this.setAttributeConfig('left', {
                value: attr.left || 0,
                validator: Lang.isNumber,
                method: function(l) {
                    if (!this._collapsing) {
                        this.setStyle('left', l + 'px');
                    }
                }
            });

            /**
            * @attribute minWidth
            * @description The minWidth parameter passed to the Resize Utility
            * @type Number
            */
            this.setAttributeConfig('minWidth', {
                value: attr.minWidth || false,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute maxWidth
            * @description The maxWidth parameter passed to the Resize Utility
            * @type Number
            */
            this.setAttributeConfig('maxWidth', {
                value: attr.maxWidth || false,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute minHeight
            * @description The minHeight parameter passed to the Resize Utility
            * @type Number
            */
            this.setAttributeConfig('minHeight', {
                value: attr.minHeight || false,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute maxHeight
            * @description The maxHeight parameter passed to the Resize Utility
            * @type Number
            */
            this.setAttributeConfig('maxHeight', {
                value: attr.maxHeight || false,
                validator: pega.lang.isNumber
            });

            /**
            * @attribute height
            * @description The height of the Unit
            * @type Number
            */
            this.setAttributeConfig('height', {
                value: attr.height,
                validator: Lang.isNumber,
                method: function(h) {
                    if (!this._collapsing) {
		      if(h<0) h=0;
                        this.setStyle('height', h + 'px');
                    }
                }
            });

            /**
            * @attribute width
            * @description The width of the Unit
            * @type Number
            */
            this.setAttributeConfig('width', {
                value: attr.width,
                validator: Lang.isNumber,
                method: function(w) {
                    if (!this._collapsing) {
		      if(w<0) w=0;	
                        this.setStyle('width', w + 'px');
                    }
                }
            });
            /**
            * @attribute position
            * @description The position (top, right, bottom, left or center) of the Unit in the Layout
            * @type {String}
            */
            this.setAttributeConfig('position', {
                value: attr.position
            });
            /**
            * @attribute gutter
            * @description The gutter that we should apply to the parent Layout around this Unit. Supports standard CSS markup: (2 4 0 5) or (2) or (2 5)
            * @type String
            */
            this.setAttributeConfig('gutter', {
                value: attr.gutter || 0,
                validator: pega.lang.isString,
                method: function(gutter) {
                    var p = gutter.split(' ');
                    if (p.length) {
                        this._gutter.top = parseInt(p[0], 10);
                        if (p[1]) {
                            this._gutter.right = parseInt(p[1], 10);
                        } else {
                            this._gutter.right = this._gutter.top;
                        }
                        if (p[2]) {
                            this._gutter.bottom = parseInt(p[2], 10);
                        } else {
                            this._gutter.bottom = this._gutter.top;
                        }
                        if (p[3]) {
                            this._gutter.left = parseInt(p[3], 10);
                        } else if (p[1]) {
                            this._gutter.left = this._gutter.right;
                        } else {
                            this._gutter.left = this._gutter.top;
                        }
                    }
                }
            });
            /**
            * @attribute parent
            * @description The parent Layout that we are assigned to
            * @type {Object} pega.widget.Layout
            */
            this.setAttributeConfig('parent', {
                writeOnce: true,
                value: attr.parent || false,
                method: function(p) {
                    if (p) {
                        p.on('resize', this.resize, this, true);
                    }

                }
            });
            /**
            * @attribute collapseSize
            * @description The pixel size of the Clip that we will collapse to
            * @type Number
            */
            this.setAttributeConfig('collapseSize', {
                value: attr.collapseSize || 25,
                validator: pega.lang.isNumber
            });
            /**
            * @attribute duration
            * @description The duration to give the Animation Utility when animating the opening and closing of Units
            */
            this.setAttributeConfig('duration', {
                value: attr.duration || 0.5
            });
            /**
            * @attribute easing
            * @description The Animation Easing to apply to the Animation instance for this unit.
            */
            this.setAttributeConfig('easing', {
                value: attr.easing || ((pega.util && pega.util.Easing) ? pega.util.Easing.BounceIn : 'false')
            });
            /**
            * @attribute animate
            * @description Use animation to collapse/expand the unit
            * @type Boolean
            */
            this.setAttributeConfig('animate', {
                value: ((attr.animate === false) ? false : true),
                validator: function() {
                    var anim = false;
                    if (pega.util.Anim) {
                        anim = true;
                    }
                    return anim;
                },
                method: function(anim) {
                    if (anim) {
                        this._anim = new pega.util.Anim(this.get('element'), {}, this.get('duration'), this.get('easing'));
                    } else {
                        this._anim = false;
                    }
                }
            });
            /**
            * @attribute header
            * @description The text to use as the Header of the Unit
            */
            this.setAttributeConfig('header', {
                value: attr.header || false,
                method: function(txt) {
                    if (txt === false) {
                        //Remove the footer
                        if (this.header) {
                            Dom.addClass(this.body, 'yui-layout-bd-nohd');
                            this.header.parentNode.removeChild(this.header);
                            this.header = null;
                        }
                    } else {
                        if (!this.header) {
                            var header = this.getElementsByClassName('yui-layout-hd', 'div')[0];
                            if (!header) {
                                header = this._createHeader();
                            }
                            this.header = header;
                        }
						var h = this.header.getElementsByTagName('h2')[0];
                        if (!h) {
                            h = document.createElement('h2');
                            this.header.appendChild(h);
                        }
                        h.innerHTML = txt;
                        if (this.body) {
                            Dom.removeClass(this.body, 'yui-layout-bd-nohd');
                        }
                    }
                    this.fireEvent('contentChange', { target: 'header' });
                }
            });
            /**
            * @attribute proxy
            * @description Use the proxy config setting for the Resize Utility
            * @type Boolean
            */
            this.setAttributeConfig('proxy', {
                writeOnce: true,
                value: ((attr.proxy === false) ? false : true)
            });
            /**
            * @attribute body
            * @description The content for the body. If we find an element in the page with an id that matches the passed option we will move that element into the body of this unit.
            */
            this.setAttributeConfig('body', {
                value: attr.body || false,
                method: function(content) {
                    if (!this.body) {
                        var body = this.getElementsByClassName('yui-layout-bd', 'div')[0];
                        if (body) {
                            this.body = body;
                        } else {
                            body = document.createElement('div');
                            body.className = 'yui-layout-bd';
                            this.body = body;
                            this.get('wrap').appendChild(body);
                        }
                    }
					var bNewGen = false;
					if(Dom.get("layout-doc").getAttribute("data-newgen") === "true") {
						bNewGen = true;
					}
					if(!bNewGen) {
						if (!this.header) {
							Dom.addClass(this.body, 'yui-layout-bd-nohd');
						}
						Dom.addClass(this.body, 'yui-layout-bd-noft');
					}
					
					var el = null;
                    if (Lang.isString(content)) {
                        el = Dom.get(content);
                    } else if (content && content.tagName) {
                        el = content;
                    }
                    if (el) {
                        var id = Dom.generateId(el);
                        LayoutUnit._instances[id] = this;
						if(!bNewGen) {
							this.body.appendChild(el);
						}
                    } else {
                        this.body.innerHTML = content;
                    }

                    this._cleanGrids();

                    this.fireEvent('contentChange', { target: 'body' });
                }
            });

            /**
            * @attribute footer
            * @description The content for the footer. If we find an element in the page with an id that matches the passed option we will move that element into the footer of this unit.
            */
            this.setAttributeConfig('footer', {
                value: attr.footer || false,
                method: function(content) {
                    if (content === false) {
                        //Remove the footer
                        if (this.footer) {
                            Dom.addClass(this.body, 'yui-layout-bd-noft');
                            this.footer.parentNode.removeChild(this.footer);
                            this.footer = null;
                        }
                    } else {
                        if (!this.footer) {
                            var ft = this.getElementsByClassName('yui-layout-ft', 'div')[0];
                            if (!ft) {
                                ft = document.createElement('div');
                                ft.className = 'yui-layout-ft';
                                this.footer = ft;
                                this.get('wrap').appendChild(ft);
                            } else {
                                this.footer = ft;
                            }
                        }
                        var el = null;
                        if (Lang.isString(content)) {
                            el = Dom.get(content);
                        } else if (content && content.tagName) {
                            el = content;
                        }
                        if (el) {
                            this.footer.appendChild(el);
                        } else {
                            this.footer.innerHTML = content;
                        }
                        Dom.removeClass(this.body, 'yui-layout-bd-noft');
                    }
                    this.fireEvent('contentChange', { target: 'footer' });
                }
            });
            /**
            * @attribute close
            * @description Adds a close icon to the unit
            */
            this.setAttributeConfig('close', {
                value: attr.close || false,
                method: function(close) {
                    //Position Center doesn't get this
                    if (this.get('position') == 'center') {
                        return false;
                    }
                    if (!this.header) {
                        this._createHeader();
                    }
                    var c = Dom.getElementsByClassName('close', 'div', this.header)[0];
                    if (close) {
                        if (!c) {
                            c = document.createElement('div');
                            c.className = 'close';
                            this.header.appendChild(c);
                            Event.on(c, 'click', this.close, this, true);
                        }
                        c.title = this.STR_CLOSE;
                    } else if (c) {
                        Event.purgeElement(c);
                        c.parentNode.removeChild(c);
                    }
                    this._configs.close.value = close;
                    this.set('collapse', this.get('collapse')); //Reset so we get the right classnames
                }
            });

            /**
            * @attribute collapse
            * @description Adds a collapse icon to the unit
            */
            this.setAttributeConfig('collapse', {
                value: attr.collapse || false,
                method: function(collapse) {
                    //Position Center doesn't get this
                    if (this.get('position') == 'center') {
                        return false;
                    }
                    if (!this.header) {
                        this._createHeader();
                    }
                    var c = Dom.getElementsByClassName('collapse_div','div',this.header)[0];
					var btnElem = Dom.getElementsByClassName('collapse','button',this.header)[0];
    	           if (collapse) {			
                        if (!c) {
								c = document.createElement('div');
								this.header.appendChild(c);	
							}
						if(!btnElem){
								btnElem = document.createElement('button');	
							this.STR_COLLAPSE = pega.u.d.fieldValuesList.get("STR_COLLAPSE");								
								btnElem.setAttribute("title",this.STR_COLLAPSE);
								btnElem.setAttribute("type", "button");
								c.appendChild(btnElem);
								Event.on(btnElem, 'click', this.collapse, this, true);
							}
						c.className = 'collapse_div' + ((this.get('close')) ? ' collapse-close' : '');
						btnElem.className = 'collapse' + ((this.get('close')) ? ' collapse-close' : '');			
				   } else if (c) {
		                        Event.purgeElement(c);
		                        c.parentNode.removeChild(c);
				  }
                }
            });
            /**
            * @attribute scroll
            * @description Adds a class to the unit to allow for overflow: auto, default is overflow: hidden
            */

            this.setAttributeConfig('scroll', {
                value: attr.scroll || false,
                method: function(scroll) {
					if ((scroll === false) && !this._collapsed) { //Removing scroll bar
                        if (this.body) {
                            if (this.body.scrollTop > 0) {
                                this._lastScrollTop = this.body.scrollTop;
                            }
                        }
                    }
                    var bNewGen = false;
					if(Dom.get("layout-doc").getAttribute("data-newgen") === "true") {
						bNewGen = true;
					}
                    if (scroll) {
                        if(!bNewGen) {
							this.addClass('yui-layout-scroll');
						}
                        if (this._lastScrollTop > 0) {
                            if (this.body) {
                                this.body.scrollTop = this._lastScrollTop;
                            }
                        }
                    } else {
                        if(!bNewGen) {
							this.removeClass('yui-layout-scroll');
						}
                    }
                }
            });
            /**
            * @attribute hover
            * @description Config option to pass to the Resize Utility
            */
            this.setAttributeConfig('hover', {
                writeOnce: true,
                value: attr.hover || false,
                validator: pega.lang.isBoolean
            });
            /**
            * @attribute resize
            * @description Should a Resize instance be added to this unit
            */

            this.setAttributeConfig('resize', {
                value: attr.resize || false,
                validator: function(r) {
                    if (pega.util && pega.util.Resize) {
                        return true;
                    }
                    return false;
                },
                method: function(resize) {
                    if (resize && !this._resize) {
                        //Position Center doesn't get this
                        if (this.get('position') == 'center') {
                            return false;
                        }
                        var handle = false; //To catch center
                        switch (this.get('position')) {
                            case 'top':
                                handle = 'b';
                                break;
                            case 'bottom':
                                handle = 't';
                                break;
                            case 'right':
                                handle = 'l';
                                break;
                            case 'left':
                                handle = 'r';
                                break;
                        }

                        this.setStyle('position', 'absolute'); //Make sure Resize get's a position
                        
                        if (handle) {
                            this._resize = new pega.util.Resize(this.get('element'), {
                                proxy: this.get('proxy'),
                                hover: this.get('hover'),
                                status: false,
                                autoRatio: false,
                                handles: [handle],
                                minWidth: this.get('minWidth'),
                                maxWidth: this.get('maxWidth'),
                                minHeight: this.get('minHeight'),
                                maxHeight: this.get('maxHeight'),
                                height: this.get('height'),
                                width: this.get('width'),
                                setSize: false
                            });
                            
                            this._resize._handles[handle].innerHTML = '<div class="yui-layout-resize-knob"></div>';

                            if (this.get('proxy')) {
                                var proxy = this._resize.getProxyEl();
                                proxy.innerHTML = '<div class="yui-layout-handle-' + handle + '"></div>';
                            }
                            this._resize.on('startResize', function(ev) {
                                this._lastScroll = this.get('scroll');
                                this.set('scroll', false);
                                if (this.get('parent')) {
                                    this.get('parent').fireEvent('startResize');
                                    var c = this.get('parent').getUnitByPosition('center');
                                    this._lastCenterScroll = c.get('scroll');
                                    c.set('scroll', false);
                                }
                                this.fireEvent('startResize');
                            }, this, true);
                            this._resize.on('resize', function(ev) {
                                this.set('height', ev.height);
                                this.set('width', ev.width);

				 //BUG-38209 - Following lines of code are being commented as 'scroll' is always 'false' and thus this code is redundant and causes errors
				 /*Bug-22443 Skipping setting scroll back to last scroll only for top panel.*/	
			     /*if(!(this.get('position') == 'top'))	
	                                this.set('scroll', this._lastScroll);*/
                                if (this.get('parent')) {
                                    var c = this.get('parent').getUnitByPosition('center');
                                    c.set('scroll', this._lastCenterScroll);
                                }
                            }, this, true);
                        }
                    } else {
                        if (this._resize) {
                            this._resize.destroy();
                        }
                    }
                }
            });
        },
        /**
        * @private
        * @method _cleanGrids
        * @description This method attempts to clean up the first level of the YUI CSS Grids, pega.util.Selector is required for this operation.
        */
        _cleanGrids: function() {
            if (this.get('grids')) {
                var b = Sel.query('div.yui-b', this.body, true);
                if (b) {
                    Dom.removeClass(b, 'yui-b');
                }
                Event.onAvailable('yui-main', function() {
                    Dom.setStyle(Sel.query('#yui-main'), 'margin-left', '0');
                    Dom.setStyle(Sel.query('#yui-main'), 'margin-right', '0');
                });
            }
        },
        /**
        * @private
        * @method _createHeader
        * @description Creates the HTMLElement for the header
        * @return {HTMLElement} The new HTMLElement
        */
        _createHeader: function() {
            var header = document.createElement('div');
            header.className = 'yui-layout-hd';
	   if (!(this._configs.header && this._configs.header.value))
	       header.style.borderWidth='0px';
            if (this.get('firstChild')) {
                this.get('wrap').insertBefore(header, this.get('wrap').firstChild);
            } else {
                this.get('wrap').appendChild(header);
            }
            this.header = header;
            return header;
        },
        /**
        * @method destroy
        * @description Removes this unit from the parent and cleans up after itself.
        * @return {<a href="pega.widget.Layout.html">pega.widget.Layout</a>} The parent Layout instance
        */
        destroy: function() {
            if (this._resize) {
                this._resize.destroy();
            }
            var par = this.get('parent');

            this.setStyle('display', 'none');
            par.removeUnit(this);
            if (this._clip) {
                this._clip.parentNode.removeChild(this._clip);
                this._clip = null;
            }

            Event.purgeElement(this.get('element'));
            this.get('parentNode').removeChild(this.get('element'));

            delete pega.widget.LayoutUnit._instances[this.get('id')];
            //Brutal Object Destroy
            for (var i in this) {
                if (Lang.hasOwnProperty(this, i)) {
                    this[i] = null;
                    delete this[i];
                }
            }
        
            return par;
        },
        /**
        * @method toString
        * @description Returns a string representing the LayoutUnit.
        * @return {String}
        */        
        toString: function() {
            if (this.get) {
                return 'LayoutUnit #' + this.get('id') + ' (' + this.get('position') + ')';
            }
            return 'LayoutUnit';
        }
    /**
    * @event resize
    * @description Fired when this.resize is called
    * @type pega.util.CustomEvent
    */
    /**
    * @event startResize
    * @description Fired when the Resize Utility fires it's startResize Event.
    * @type pega.util.CustomEvent
    */
    /**
    * @event beforeResize
    * @description Firef at the beginning of the resize method. If you return false, the resize is cancelled.
    * @type pega.util.CustomEvent
    */
    /**
    * @event contentChange
    * @description Fired when the content in the header, body or footer is changed via the API
    * @type pega.util.CustomEvent
    */
    /**
    * @event close
    * @description Fired when the unit is closed
    * @type pega.util.CustomEvent
    */
    /**
    * @event beforeCollapse
    * @description Fired before the unit is collapsed. If you return false, the collapse is cancelled.
    * @type pega.util.CustomEvent
    */
    /**
    * @event collapse
    * @description Fired when the unit is collapsed
    * @type pega.util.CustomEvent
    */
    /**
    * @event expand
    * @description Fired when the unit is exanded
    * @type pega.util.CustomEvent
    */
    /**
    * @event beforeExpand
    * @description Fired before the unit is exanded. If you return false, the collapse is cancelled.
    * @type pega.util.CustomEvent
    */
    });

    pega.widget.LayoutUnit = LayoutUnit;
})();
pega.register("layout", pega.widget.Layout, {version: "2.5.2", build: "1076"});
//static-content-hash-trigger-GCC
pega.namespace("pega.ui");

/*@protected
Function to initialize layouts.
@param $e$ event object
@param $root$ the document
@return $void$
*/
function initLayout(e, root){
	var layout = pega.util.Dom.getElementsById('layout-doc',root,'div');
	if(layout){
		var layoutObj = new pega.ui.Layout(layout[0],root);
		return layoutObj;
	}
}

/*@protected
Class which constructs the layout manager.
@param $topLayout$ The parent div layout-doc for which layout has to be constructed with different layout units.
@return $void$
*/
pega.ui.Layout = function(topLayout,root) {
	this.shim = null;
	this.accorObj = null;
	this.accorIndex = null;
	this.topLayout = topLayout;	
	var unitProps = this.getLUs();
	this.unitConfig = unitProps.units;
	this.collapsedUnits = unitProps.collapsedLUs;
	var bFullBody =  this.setPortalWidth(root);
	if(bFullBody)
		this.layoutObj = new pega.widget.Layout({units:this.unitConfig});
	else
		this.layoutObj = new pega.widget.Layout('PEGA_PORTAL',{units:this.unitConfig});
	
	//this.layoutObj.on('render',this.customizeLayout,this,true);
	this.layoutObj.on('startResize', this.activateShim, this, true);
	this.layoutObj.on('resize',this.deactivateShim, this, true);
	this.layoutObj.on('resize',pega.u.d.resizeHarnessCallback, pega.u.d, true);
	this.layoutObj.render();
	if(pega.u.d.isAccessible){
		this.addARIARoles(this.layoutObj);
	}
}	

/*@protected
Class which adds aria attribute role to layout units.
@param $layoutObj$ The layout object.
@return $void$
*/
pega.ui.Layout.prototype.addARIARoles = function(layoutObj){
	var positions =["PEGA_LU_T","PEGA_LU_L","PEGA_LU_C","PEGA_LU_R","PEGA_LU_B"];
	var len = positions.length;
	var role = "";
	for(var i=0; i<len; i++){
		var strUnitId = positions[i];
		switch(strUnitId){
		case "PEGA_LU_T":
			role = "banner";
			break;
		case "PEGA_LU_L":
			role = "navigation";
			break;
		case "PEGA_LU_C":
			role = "main";
			break;
		case "PEGA_LU_R":
			role = "contentinfo";
			break;
		case "PEGA_LU_B":
			role = "complementary";
			break;
		}
		var unitById = layoutObj.getUnitById(strUnitId);
		if(unitById != false){
			var oDivBody = unitById.body;
			var oDivHeader = unitById.header;
			if(oDivBody != null){
				if(oDivHeader != null)oDivBody = oDivBody.parentNode;
				oDivBody.setAttribute("role", role);
			}
		}
	}	
}

/*@protected
Handle default collapse of a layout unit. 
@param $ev$ Event object.
@param $args$  The object array with collapsed layoutunits and layout object.
@return $void$
*/
pega.ui.Layout.prototype.customizeLayout = function(){
if(document.getElementById("layout-doc").style.display == "none") {
	document.getElementById("layout-doc").style.display = "block";
}
this.layoutObj.panel = [];	
var panelPositions = ["TOP", "RIGHT", "LEFT","BOTTOM"];
	var len = panelPositions.length;
	for(var i=0; i<len; i++){
		var panel = this.layoutObj.getUnitByPosition(panelPositions[i]);
		if(panel)
			this.configExpandCollapse(panel,i);
	}			
	
	var topPanel = this.layoutObj.getUnitByPosition('TOP');
	var rightPanel = this.layoutObj.getUnitByPosition('RIGHT');
	var leftPanel = this.layoutObj.getUnitByPosition('LEFT');
	if(topPanel)
		topPanel.setStyle('zIndex', 2);		
	if(leftPanel)
		leftPanel.setStyle('zIndex', 1);
	if(rightPanel)
		rightPanel.setStyle('zIndex', 1);	
	if(this.collapsedUnits != null){		
		var len = this.collapsedUnits.length;         
		for(var i=0;i<len;i++){
			var position = this.collapsedUnits.LU[i]; 		
			this.layoutObj.getUnitByPosition(position).set('animate',false);
			this.layoutObj.getUnitByPosition(position).collapse();
			setTimeout(function() {
				this.layoutObj.resize();
				this.layoutObj.getUnitByPosition(position).set('animate', true);
         		       	}, 1000);	
		}
	}
}


pega.ui.Layout.prototype.configExpandCollapse = function(panel,pos){	
	var layoutObj = this;
	var className = "", collapsedClass = "",expandedClass = "";
	var handle;
	var panelPosition = panel.get('position'); 
	switch(panelPosition){
		case 'top':				
			className = "expandIcon-h";
			collapsedClass = "yui-layout-clip-top";
			expandedClass = "yui-layout-unit-top";	
			if(panel._resize)
				handle = panel._resize._handles.b;
			break;
	         case 'bottom':
			className = "expandIcon-h";
			collapsedClass = "yui-layout-clip-bottom";
			expandedClass = "yui-layout-unit-bottom";
			if(panel._resize)
				handle = panel._resize._handles.t;
			break;
		case 'left':			
			className = "expandIcon-v";
			collapsedClass = "yui-layout-clip-left";
			expandedClass = "yui-layout-unit-left";
			if(panel._resize)
				handle = panel._resize._handles.r;
			break;	
         		case 'right':
			className = "expandIcon-v";
			collapsedClass = "yui-layout-clip-right";
			expandedClass = "yui-layout-unit-right";
			if(panel._resize)
				handle = panel._resize._handles.l;
			break;	
	}
	var isCollapse = panel.get('collapse');
	var isResize = panel.get('resize');		
	var strHeader = panel.get('header');
	var strPosition = panel.get('position');
	this.layoutObj.panel[pos] = panel;	
	if(isCollapse && strHeader == ""){	
		var expandcollapseTitle = pega.u.d.fieldValuesList.get("EXPAND_COLLAPSE_MESSAGE");
		var panelDocument = this.layoutObj.getElementsByClassName(expandedClass,'div')[0];	
		pega.util.Dom.setStyle(panelDocument.firstChild.firstChild,'height','0px');
		if(isResize){	
			var resizeKnob = handle.firstChild;
			pega.util.Dom.setStyle(resizeKnob,'position','static');
			if(panelPosition == 'left' || panelPosition == 'right'){
				pega.util.Dom.setStyle(resizeKnob,'top','auto');
			}else{
				pega.util.Dom.setStyle(resizeKnob,'float','left');
				pega.util.Dom.setStyle(resizeKnob,'left','auto');
			}
			var c = '<button type="button" class=\"'+ className+ '\" title=\"'+expandcollapseTitle+'\" onclick=\"pega.u.d.portal.layoutObj.panel['+pos+'].collapse();\"></button>' + handle.innerHTML + '<button type="button" class="'+ className+  '\" title=\"'+expandcollapseTitle+'\" onclick=\"pega.u.d.portal.layoutObj.panel['+pos+'].collapse();\"></button>';
			var collapseDiv = document.createElement('div');
			collapseDiv.className = "collapse-div";
			collapseDiv.innerHTML = c;
			handle.removeChild(resizeKnob);			
	                  	handle.appendChild(collapseDiv);
																
		}else{		
			var handle =  document.createElement('div');
			handle.className = "collapse_div_New";
				
			var c = '<button type="button" class="'+ className+ '"  title=\"'+expandcollapseTitle+'\" onclick=\"pega.u.d.portal.layoutObj.panel['+pos+'].collapse();\"></button>';
			handle.innerHTML = c;
			panelDocument.appendChild(handle);
		}	
		panel.set("collapseSize",8);
		var collapseButton = document.getElementById('collapse_button_icon');
		if(collapseButton)
			collapseButton.style.display = 'none'; 
		panel.on('collapse',handleCollapse,collapsedClass,this);			
	}


}


function handleCollapse(ev,collapsedClass){
	
	var x = pega.util.Dom.getElementsByClassName(collapsedClass)[0];
	if(collapsedClass=="yui-layout-clip-right" || collapsedClass=="yui-layout-clip-left"){
		x.firstChild.firstChild.className = 'collapseIcon-v';
	}else{
		x.firstChild.firstChild.className = 'collapseIcon-h';
	}
	x.firstChild.className = "collapse_div_New";
}

/*@protected 
Get all layout units at the same level.
@return $Object$ layout units
*/
pega.ui.Layout.prototype.getLUs = function(){
	var layout = this.topLayout;
	var LU = new Object();
	var units = new Array();
	var collapsedUnits = new Array();
	var cnt1=0, cnt2=0;
	var positions =["PEGA_LU_T","PEGA_LU_L","PEGA_LU_C","PEGA_LU_R","PEGA_LU_B"];
	var len = positions.length;
	for(var i=0; i<len; i++){
		var unitByPos = pega.util.Dom.getElementsById(positions[i],layout,'div');
		if(unitByPos != null){
			units[cnt1] = this.getLUAttr(unitByPos[0]);
		if(this.isCollapsed(units[cnt1]))
			collapsedUnits[cnt2++] = units[cnt1].position;		
		cnt1++;
		}
	}
	
	LU.units = units;
	if(collapsedUnits.length>0)
		LU.collapsedLUs = collapsedUnits;
	return LU;
}

/*@protected 
Get attributes for each layout unit.
@return $Object$ Object array of layoutunit attributes.
*/
pega.ui.Layout.prototype.getLUAttr = function(lu){
	var luAttr= new Array();
	luAttr["animate"] = false;
	var resize = false;
	luAttr["resize"] = resize;
	if(!pega.u.d.isAccessible){
		resize = lu.getAttribute("resize");
		if(resize!=null)
			luAttr["tempResize"] = resize;	
	}
	var collapse = lu.getAttribute("collapse");
	if(collapse!=null)
		luAttr["collapse"] = collapse;
	var collapsed = lu.getAttribute("collapsed");
	if(collapsed!=null)
		luAttr["collapsed"] = collapsed;
	var scroll = lu.getAttribute("scroll");
	if(scroll!=null ) {
		var bScroll = (scroll === 'true');
		luAttr["scroll"] = bScroll;		
	}
	var body = lu.getAttribute("id");
	luAttr["body"] = body;	
	var position = lu.getAttribute("position");
	luAttr["position"] = position;
	
	var width = lu.getAttribute("width");
		luAttr["width"] = parseInt(width);
	var height = lu.getAttribute("height");
	luAttr["height"] =parseInt(height);

	var header = lu.getAttribute("header");
	if(header != null)
		luAttr["header"] = header;	
	if(position=="top")
		luAttr["tempGutter"] = pega.u.d.topGutter;	
	else if(position=="left") {
		if(luAttr["tempResize"])
			luAttr["tempGutter"] = pega.u.d.leftGutter;
		else
			luAttr["tempGutter"] = "0px 0px 0px 0px";
	}
	else if(position=="right")
		luAttr["tempGutter"] = pega.u.d.rightGutter;
	else if(position=="bottom")
		luAttr["tempGutter"] = pega.u.d.bottomGutter;
	return luAttr;	

}

/*@protected 
Checks if a layoutunit was configured for by default collapse.
@return $boolean$ returns true if the layoutunit has a nested layout.
*/
pega.ui.Layout.prototype.isCollapsed = function(unitAttr){
	if(unitAttr["collapsed"]=="true")
		return true;
	return false;
}


pega.ui.Layout.prototype.hasIFrame = function(divID){
	var centerDiv = pega.util.Dom.getElementsById(divID);
	var iframes= centerDiv[0].getElementsByTagName("iframe");
	if(iframes.length>0)
		return true;
	return false;
}

/*@protected 
Change the width of main panel from % to px.
@return $boolean$ returns true if the width is 100%, returns false if width is other then 100% or specified in px.
*/
pega.ui.Layout.prototype.setPortalWidth = function(root){
	var portal = pega.util.Dom.getElementsById('PEGA_PORTAL',root,'div');
	if(portal==null) return true;
	var widthVal = portal[0].style.width;
	var heightVal = portal[0].style.height;
	if(widthVal=="100%"){
		return true;
	}
	var w1 = widthVal.indexOf("%");
	if(w1 != -1){
		var numVal = widthVal.substr(0,w1);
		var windowWidth = document.body.clientWidth;
		widthVal = (windowWidth * numVal )/100 + 'px';		
	}	
	var h1 = heightVal.indexOf("%");
	if(h1 != -1){
		var numVal = heightVal.substr(0,h1);
		var windowHeight = document.body.clientHeight;
		heightVal = (windowHeight * numVal )/100 + 'px';		
	}
	portal[0].style.width = widthVal;
	portal[0].style.height = heightVal;
	return false;
}

/*@private
Returns the layout unit name if the container is in one of the layout units.
@param $container$ A container/div element
@return Returns null if container doesnot belong to any of the layout units. Otherwise returns layout unit name.
*/
pega.ui.Layout.prototype.getLUName = function(container){
	var reqDiv = container.parentNode;
	var accorId = 'PEGA_ACCORDION[\\w]+'; 
	var accorRegExp = new RegExp(accorId, 'gi');	
	while(reqDiv && reqDiv.id!='layout-doc'){
		var reqId = reqDiv.id;
		if(reqId=='PEGA_LU_L'||reqId=='PEGA_LU_R'||reqId=='PEGA_LU_T'||reqId=='PEGA_LU_B'||reqId=='PEGA_LU_C'){
			return reqId;
		}
		if(reqId && reqId.match(accorRegExp)){
			return false;
		}
		reqDiv = reqDiv.parentNode;	
	}
	return false;

}

/*@public
Get the layout unit object which has the container.
@param $container$ A container/div element
@return $obj$ the layout unit which hosts the container.
*/
pega.ui.Layout.prototype.getLayoutUnit = function(container){
	var layoutUnitID = this.getLUName(container);
	if(layoutUnitID){
		return pega.util.Dom.getElementsById(layoutUnitID)[0];
	}
}

pega.ui.Layout.prototype.doBeforeOpen = function(sourceString) {
	var api = sourceString.get("api");
	if(api == "openAssignment" || api == "createNewWork" || api == "getNextWorkItem" || api == "getNextWork" || api == "openWorkItem" || api == "openWorkByHandle" || api == "display" ) {
		var accorObj = pega.u.d.portal.accorObj;
		var accorIndex = pega.u.d.portal.accorIndex;
		if(accorObj != null && accorIndex != null) {
			accorObj.set('activeIndex', accorIndex);
		}
	}
}

/* Setting width of all layouts to their maximum scroll width/height to avoid unneccessary scroll bars.*/
pega.ui.Layout.prototype.stretchLayoutsToContent = function() {
	var computedLeftScrollWidth =  0;
	var computedRightScrollWidth  = 0;
	var adjustmentWidth = 20;
	var adjustmentHeight = 25;
	var computedBottomScrollHeight = 0;
	var computedTopScrollHeight = 0;
	var bottomDivScrollHeight = 0;
	var isLeftPanel = this.layoutObj.getUnitByPosition('left');
	var isRightPanel = this.layoutObj.getUnitByPosition('right');
	var isBottomPanel = this.layoutObj.getUnitByPosition('bottom');
    	var isTopPanel = this.layoutObj.getUnitByPosition('top');
	
	if( !pega.util.Event.isIE ) {
		var accordsLeft = pega.util.Dom.getElementsById("PEGA_ACCORDION", document.getElementById("PEGA_LU_L"), "DIV");
		var accordsRight = pega.util.Dom.getElementsById("PEGA_ACCORDION", document.getElementById("PEGA_LU_R"), "DIV");
		if( accordsLeft !=null || accordsRight !=null){
			adjustmentWidth = 120;
		}
	}
	if( isLeftPanel ){
		computedLeftScrollWidth  = document.getElementById("PEGA_LU_L").parentNode.scrollWidth;
	}
	if( isRightPanel ){
		computedRightScrollWidth =  document.getElementById("PEGA_LU_R").parentNode.scrollWidth;
	}
	if( isBottomPanel ){
		computedBottomScrollHeight = document.getElementById("PEGA_LU_B").parentNode.scrollHeight;
		bottomDivScrollHeight = document.getElementById("PEGA_LU_B").scrollHeight;
	}
	if( isTopPanel ){
		computedTopScrollHeight  = document.getElementById("PEGA_LU_T").parentNode.scrollHeight;
	}
	
	if( pega.util.Event.isIE || pega.env.ua.webkit > 0 ) {
		computedBottomScrollHeight = computedBottomScrollHeight + adjustmentHeight;
	}
	else if( pega.env.ua.gecko > 0 ) {
		computedBottomScrollHeight = computedBottomScrollHeight + bottomDivScrollHeight;
	}

	if( isLeftPanel && isLeftPanel._configs.width.value == 150 ) {
		this.layoutObj.getUnitByPosition('left').set('width', computedLeftScrollWidth + adjustmentWidth);
	}
	if( isRightPanel && isRightPanel._configs.width.value == 150 ){
		this.layoutObj.getUnitByPosition('right').set('width', computedRightScrollWidth + adjustmentWidth);
	}
	if( isBottomPanel && isBottomPanel._configs.height.value == 50 ){
		this.layoutObj.getUnitByPosition('bottom').set('height', computedBottomScrollHeight);
	}
	/*if( isTopPanel && isTopPanel._configs.height.value == 50 ) {
		this.layoutObj.getUnitByPosition('top').set('height', computedTopScrollHeight + adjustmentHeight);
	}*/ // BUG-82384 : Commented out the case where it adds an extra 25px for the case where the height is 50px.
}

pega.ui.Layout.prototype.createShim = function(){
	 var s = document.createElement('div');
            s.id = 'yui-ddm-shim';
            if (document.body.firstChild) {
                document.body.insertBefore(s, document.body.firstChild);
            } else {
                document.body.appendChild(s);
            }
            s.style.display = 'none';
            s.style.backgroundColor = 'red';
            s.style.position = 'absolute';
            s.style.zIndex = '99999';
            pega.util.Dom.setStyle(s, 'opacity', '0');
            this.shim = s;
  
  			if (pega.ui.DDM) {
            	pega.util.Event.on(s, "mouseup",   pega.util.DDM.handleMouseUp, pega.util.DDM, true);
            	pega.util.Event.on(s, "mousemove", pega.util.DDM.handleMouseMove, pega.util.DDM, true);
            }
  
            pega.util.Event.on(window, 'scroll', this.sizeShim, this, true);
}

pega.ui.Layout.prototype.sizeShim = function(){
	 var s = this.shim;
          s.style.height = pega.util.Dom.getDocumentHeight() + 'px';
          s.style.width = pega.util.Dom.getDocumentWidth() + 'px';
          s.style.top = '0';
          s.style.left = '0';
}

pega.ui.Layout.prototype.activateShim = function(){
	if(this.shim == null){
		this.createShim();
		this.sizeShim();
	}
         this.shim.style.display = 'block';
}

pega.ui.Layout.prototype.deactivateShim = function(){
	if (this.shim != null) {
		this.shim.style.display = 'none';
	}
};
//static-content-hash-trigger-GCC
/*
	This code is in support for pega.ui.commandpalette(pzpega_ui_command_palette.js) 
    it is loaded in every frame so that init can be called in the desktopWindow.
    This allows the command palette to register its own hot keys and load content
    when needed.
*/
if(pega && pega.desktop && pega.desktop.support) {
  if(pega.desktop.support.getDesktopWindow() && pega.desktop.support.getDesktopWindow().pega.ui.commandpalette) {
      pega.desktop.support.getDesktopWindow().pega.ui.commandpalette.init(window);
  };
};
//static-content-hash-trigger-GCC
/* ----------------------------------------------------------------------------
 *  (c) 2016 Pega Systems.
 * ----------------------------------------------------------------------------
 */

(function() {
  pega.mobile.hybrid.callWhenLaunchboxLoaded(function () {
	 if (window.launchbox && window.launchbox.appDynamics) {
        var config = {
          appKey: pega.ui.HarnessContextMap.getCurrentHarnessContext().getProperty('AppDynamicsAppKey')
        }
		window.launchbox.appDynamics.configure(config);
     var networkStatusListener = function() {
				if(!window.navigator.onLine) {
                    window.launchbox.appDynamics.stopTimer("Online");
					window.launchbox.appDynamics.startTimer("Offline");
                }
                else {
                  window.launchbox.appDynamics.stopTimer("Offline");
                  window.launchbox.appDynamics.startTimer("Online");
                }
			};
     
		  window.addEventListener('online', networkStatusListener);
      window.addEventListener('offline', networkStatusListener);
	 }
  });
  
})();
//static-content-hash-trigger-GCC
if (typeof(pega) != "undefined") {
    (function(p) {
        if (!p.api) {
            p.api = p.namespace("pega.api");
            p.api.ui = {
              constants: {
                SECTION : 1,
                HARNESS: 2,
                GRID: 3,
                RDL: 4,
                REPLACE_CURRENT: 1,
                OVERLAY: 2,
                MODAL_DIALOG: 3,
                REFRESH_CURRENT_ITEM: 1,
                REFRESH_ALL_ITEMS: 2,
                POP_UP_WINDOW: 2,
                NEW_DOCUMENT: 3 
              } 
            };
        }
      	var ERROR_INVALID_ARGUMENT_OBJECT = "Invalid JS Object passed";
      	var _log = function(msg){
          console.log(msg);
        }
      	
        p.api.ui.actions = {

            /*  var params = {section: sectionName, 
                              event: eventObject,
                              dataTransform: dataTransformJSObject, 
                              activity: activityJSObject,
                              submitOnRefresh: booleanVal }

             *  refreshSection(params);
             */

            refreshSection: function(params) {
                if (params && params instanceof Object) {

                    var section = params.section;
                    var transformObject = params.dataTransform;
                    var activityObject = params.activity;
                    var submitOnRefresh;
                  	if(typeof params.submitOnRefresh == 'undefined') {
                      submitOnRefresh = "0";
                    }
                 	  else {
                      submitOnRefresh = params.submitOnRefresh == true ? "0":"1";
                  	}
                  	var event = params.event;
                  	var target = event ? pega.util.Event.getTarget(event) : "";
                    var dataTransformStr = "";
                    var activityName = "";
                    var activityParamsStr = "";
                    var refreshTarget = section ? "otherSection" : "thisSection";

                    // DataTransform Syntax - TestTrasform,param1=abc&param2=5"  or TestTrasform,param1=#~EmpPage.Id~#&param2=123
                    if (transformObject && transformObject instanceof Object) {
                        var dtName = transformObject.name;
                        var dtParams = transformObject.parameters;
                        if (dtName) {
                            dataTransformStr = dtName;
                            var paramsStr = p.api.ui.util.getParametersString(dtParams, target);
                            if (paramsStr)
                                dataTransformStr += "," + paramsStr;
                        }
                    }

                    // Activity Params syntax - "&CurrentWorkIndex=#~EmpPage.Id~#&AllowInput=true&"
                    if (activityObject && activityObject instanceof Object) {
                        activityName = activityObject.name;
                        activityParamsStr = p.api.ui.util.getParametersString(activityObject.parameters, target);
                    }

                    pega.control.UIElement.Actions.refresh(refreshTarget, section, activityName, activityParamsStr, "", dataTransformStr, event, submitOnRefresh);
                }
              	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.refresh API");
                }
            },
          
          	/*  var params = {event: eventObject,
                              dataTransform: dataTransformJSObject, 
                              activity: activityJSObject,
                              submitOnRefresh: booleanVal }

             *  refreshHarness(params);
             */
          	refreshHarness: function(params) {
                if (params && params instanceof Object) {

                    var transformObject = params.dataTransform;
                    var activityObject = params.activity;
                    var submitOnRefresh = (typeof params.submitOnRefresh == 'undefined') ? true : params.submitOnRefresh;
                 	var event = params.event;
                  	var target = event ? pega.util.Event.getTarget(event) : "";

                    var dataTransformStr = "";
                    var activityName = "";
                    var activityParamsStr = "";
                    var refreshTarget = "currentharness";

                    // DataTransform Syntax - TestTrasform,param1=abc&param2=5"  or TestTrasform,param1=#~EmpPage.Id~#&param2=123
                    if (transformObject && transformObject instanceof Object) {
                        var dtName = transformObject.name;
                        var dtParams = transformObject.parameters;
                        if (dtName) {
                            dataTransformStr = dtName;
                            var paramsStr = p.api.ui.util.getParametersString(dtParams, target);
                            if (paramsStr)
                                dataTransformStr += "," + paramsStr;
                        }
                    }

                    // Activity Params syntax - "&CurrentWorkIndex=#~EmpPage.Id~#&AllowInput=true&"
                    if (activityObject && activityObject instanceof Object) {
                        activityName = activityObject.name;
                        activityParamsStr = p.api.ui.util.getParametersString(activityObject.parameters, target);
                    }

                    pega.control.UIElement.Actions.refresh(refreshTarget, "", activityName, activityParamsStr, "", dataTransformStr, event, !submitOnRefresh);
                }
              	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.refresh API");
                }
            },

            postValue: function(eventObject, updateDOM) {
                if (eventObject) {
                  	updateDOM = (typeof updateDOM == 'undefined') ? false : updateDOM;
                    pega.control.UIElement.Actions.postValue(eventObject, updateDOM);
                }
              	else{
                  _log("Invalid event object passed to pega.api.ui.actions.postValue API");
                } 
            },
          
          	/*
             *    pega.api.ui.actions.setValue(target, source, isProperty, event);
             */
            setValue: function(target, source, isProperty, event) {
              	if(target) {
                      var eventTarget = event ? pega.util.Event.getTarget(event) : "";
                      var contextPage = eventTarget ? p.api.ui.util.getBaseRef(eventTarget) : "";	
                      var targetPage = target.substr(0, target.indexOf("."));
                      var targetProperty = target.substr(target.indexOf(".")); 
                  	  if (isProperty && source) {
                        var srcPage = source.substr(0, source.indexOf("."));
                        var srcProperty = source.substr(source.indexOf("."));
                        var clientValue = pega.u.d.getProperty(srcProperty, srcPage || contextPage);
                        pega.u.d.setProperty(targetProperty, clientValue, targetPage || contextPage);
                      }
                      else
                        pega.u.d.setProperty(targetProperty, (typeof source != 'undefined') ? source : "", targetPage || contextPage);
               }
                   
            },
          
            /*
             * var params = {event: eventObj, list: [
                {target: 'targetProp1', source: "SourceProp1/value", isProperty: true/false},
               {target: 'targetProp2', source: "SourceProp2/value", isProperty: true/false},

                …,
                {target: 'targetPropN', source: "SourcePropN/value", isProperty: true/false}]};         
                pega.api.ui.actions.setValues(params);
             */
            setValues: function(params) {
              	if (params && params instanceof Object) {
                  var propsArray = params.list;
                  
                  if (propsArray && propsArray.length) {
                      var event = params.event;
                      var eventTarget = event ? pega.util.Event.getTarget(event) : "";
                      var contextPage = eventTarget ? p.api.ui.util.getBaseRef(eventTarget) : "";	
                    
                      for (var i = 0; i < propsArray.length; i++) {
                          var item = propsArray[i];
                          var target = item.target;
                          var source = item.source;
                          var isProperty = item.isProperty;
                          if (target) {
                              var targetPage = target.substr(0, target.indexOf("."));
                              var targetProperty = target.substr(target.indexOf("."));
                              if (isProperty && source) {
                                  var srcPage = source.substr(0, source.indexOf("."));
                                  var srcProperty = source.substr(source.indexOf("."));
                                  var clientValue = pega.u.d.getProperty(srcProperty, srcPage || contextPage);
                                  pega.u.d.setProperty(targetProperty, clientValue, targetPage || contextPage);
                              }
                      		  else
                                  pega.u.d.setProperty(targetProperty, (typeof source != 'undefined') ? source : "", targetPage || contextPage);
                          }
                      }
                  }
                }  
            },

            /*
            * var params = {name: “dataTransformName ", 
                            parameters: {param1:value1, param2: value2},
                            contextPage: "page1.page2 ",
                            event: eventObject};
              pega.api.ui.actions.runDataTransform(params);
            */
            runDataTransform: function(params) {
                if (params && params instanceof Object) {
                    var name = params.name;
                  	var event = params.event;
                  	var target = event ? pega.util.Event.getTarget(event) : "";
                    var paramsStr = p.api.ui.util.getParametersString(params.parameters, target);
                    var usingPage = params.contextPage || "";
                    name && pega.u.invoke.runDataTransform([name, paramsStr, usingPage, event]);
                }
              	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.runDataTransform API");
                }
            },

            runActivity: function(params) {
                if (params && params instanceof Object) {
                    var name = params.name;
                  	var event = params.event;
                  	var target = event ? pega.util.Event.getTarget(event) : "";
                    var paramsStr = p.api.ui.util.getParametersString(params.parameters, target);
                    var usingPage = params.contextPage || "";
                    var bReturnsResponse = params.returnsResponse;
                    var callbackObj;
                    if(bReturnsResponse === true && params.callbackObj){
                      paramsStr = paramsStr.length>0 ? paramsStr+"&": paramsStr;
                      paramsStr = paramsStr+"pyReturnsResponse="+bReturnsResponse;
                      callbackObj = params.callbackObj;
                    }
                    
                    name && pega.u.invoke.runActivity([name, paramsStr, usingPage, event, null, null, callbackObj]);
                }
              	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.runActivity API");
                }
            },

            /*
             * var params1 = {name: "DataPageName", 
                              parameters: [{name: "param1", value: "Page1.prop1", isProperty: true},  {name: "param2", value: 123, isProperty: false}], 
                              callback: callBackFunc,
                              event: eventObj}
             * pega.api.ui.actions.getDataPage(params1);
             */
            getDataPage: function(params) {
                if (params && params instanceof Object) {
                    var name = params.name;

                    if (name) {
                        var callback = params.callback;
                        var paramList = params.parameters;
                      	var event = params.event;
                      	var target = event ? pega.util.Event.getTarget(event) : "";

                        var paramsStr = "";
                        if (paramList && paramList.length) {
                            var paramObj = {};
                            for (var i = 0; i < paramList.length; i++) {
                                var item = paramList[i];
                                var paramName = item.name;
                                paramObj[paramName] = p.api.ui.util.getParameterValue(item, target);
                            }
                            paramsStr = JSON.stringify(paramObj);
                        }

                        var safeURL = SafeURL_createFromURL(pega.u.d.url);
                        safeURL.put("pyActivity", "pzGetDataPageJSON");
                        safeURL.put("pyDataPageName", name);

                        var postData;
                        if (paramsStr) {
                            postData = new SafeURL();
                            postData.put("DPParams", paramsStr);
                        }

                        var successCallback = function(cb) {
                            return function(res) {
                                cb && cb(JSON.parse(res.responseText));
                            }
                        }(callback);

                        var failureCallback = function(res) {
                            console.log("Error getting the datapage JSON " + res);
                        }

                        var asyncConfigOptions = {
                          isFromDatapage: true
                        }
                        p.u.d.asyncRequest("POST", safeURL, {
                            success: successCallback,
                            failure: failureCallback
                        }, postData, asyncConfigOptions);
                    }
                }
              	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.getDataPage API");
                }
            },
          
          	list: {

            /*var params = {
                            target: "grid / RDL",
                            position: 'rowPosition'
                            event: eventObject,
                            detailFlowAction: 'flowActionName',
                            template: "templateName",
                            dataPage: "datapageName",
                            dataPageResultsClass: "datapageResultsClassName"  
           };
          pega.api.ui.actions.list.addListItem(params);
           *
           *
           */
            addListItem: function(params) {
                if (params && params instanceof Object) {
                    var target = params.target || pega.api.ui.constants.GRID;
                    var position = params.position;
                    var event = params.event;
                  
                    var options = "";

                    if (!position)
                        position = (target == pega.api.ui.constants.RDL) ? 'first' : 'after';

                    var dataPage = params.dataPage || "";
                    if (dataPage) {
                        //dataPage += ".pxResults";
                        options = {
                            dataSource: dataPage
                        };
                    }

                    var action = (position == "after") ? "INSERTAFTER" : (position == "before") ? "INSERTBEFORE" : (position == "first") ? "INSERTFIRST" : "INSERTLAST";

                    if (target == pega.api.ui.constants.RDL) {
                        var resultsClass = params.dataPageResultsClass || "";
                        var flowAction = params.detailFlowAction || "";
                        var template = params.template || "pyNextGenGridModalTemplate";
                        pega.control.UIElement.Actions.addToRepeatSource(event, dataPage, action, flowAction, template, resultsClass);
                    } else {
                        pega.control.UIElement.Actions.doGridAction(event, action, "", options);
                    }
                }
              	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.list.addListItem API");
                }
            },

            //pega.api.ui.actions.deleteListItem(eventObject)
            deleteListItem: function(eventObject) {
                if (eventObject) {
                    window.removeFromRepeatSource && removeFromRepeatSource(eventObject);
                }
            },

            //pega.api.ui.actions.editListItem(eventObject)
            editListItem: function(eventObject) {
                if (eventObject) {
                    window.editRepeatItem && editRepeatItem(eventObject);
                }
            },
             
            /*  var params = {
                                    flowAction: “flowActionName ",
                                    event: eventObject,
                                    onLaunch : "Refresh Current Item/ Refresh All Items" ,
                                    disableWorkProcessing: true/false       
                                    template: "templateName"
      		  };
 
      		  pega.api.ui.actions.openLocalAction(params);
           *
           *
           */
            openLocalAction: function(params) {
                if (params && params instanceof Object) {
                    var flowAction = params.flowAction;
                    var afterAction = params.onLaunch || pega.api.ui.constants.REFRESH_CURRENT_ITEM;
                    var event = params.event;
                    if (flowAction) {
                        var refreshLayout = (afterAction == pega.api.ui.constants.REFRESH_CURRENT_ITEM) ? "false" : "true";
                        var templateGrid = isTemplateGrid(event);
                        if(templateGrid){
                          var options = {
                            noThreadProcess: "true",
                            templateName: params.template || "pyNextGenGridModalTemplate"
                          };
                          pega.control.UIElement.Actions.doListAction(event, "FLOWACTION", flowAction, options, null, refreshLayout);
                        }
                        else{
                          var disableWorkProcessing = (typeof params.disableWorkProcessing == 'undefined') ? false : params.disableWorkProcessing;
                          var options = {
                            noThreadProcess: disableWorkProcessing.toString(),
                            templateName: params.template || "pzGridModalTemplate"
                          };
                        }
                        pega.control.UIElement.Actions.doGridAction(event, "FLOWACTION", flowAction, options, null, refreshLayout);
                    }
                }
             	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.launchListLocalAction API");
                }
            }
              
            },

            /*
           *  var params = {
                                    flowAction: “flowActionName ",
                                    displayMode: "Replace Current / Overlay / Modal Dialog",
                                    event: eventObject,
                                    class: "className" ,
                                    contextPage: "pageName",
                                    format: "skinFormat",
                                    template: "pzModalTemplate",
                                    fullScreenDisplayOnMobile: true/false,
                                    revealEffect: "animName",
                                    closingEffect: "animName",
                                    closeOnClickAway: true/ false,
                                    centerOverlay: true/false
          };
 
            pega.api.ui.actions.launchLocalAction(params);
           *
           */
            launchLocalAction: function(params) {
                if (params && params instanceof Object) {

                    var flowActionName = params.flowAction;
                    var displayTarget = params.displayMode || pega.api.ui.constants.REPLACE_CURRENT;
                    var event = params.event;
                    var className = params.flowActionClass;
                  	

                    if (flowActionName && displayTarget && event && className) {

                        var format = params.skinFormat || "";
                        var template = params.template || "pzModalTemplate";
                        var fullScreenDisplay = (typeof params.isMobileFullScreen == 'undefined') ? true : params.isMobileFullScreen;
                        var inAnim = "anim-null";
                        var outAnim = "anim-null";
                      	var usingPage = params.contextPage;

                        if (fullScreenDisplay) {
                            inAnim = p.api.ui.util.inAnimMap[params.revealEffectName || "From bottom"];
                            outAnim = p.api.ui.util.outAnimMap[params.closingEffectName || "Reverse the reveal effect"];
                        }

                        var closeOnClickAway = (typeof params.closeOnClickAway == 'undefined') ? true : params.closeOnClickAway;
                        var centerOverlay = (typeof params.centerOverlay == 'undefined') ? false : params.centerOverlay;
                        var target = (displayTarget == pega.api.ui.constants.REPLACE_CURRENT) ? "false" : (displayTarget == pega.api.ui.constants.MODAL_DIALOG) ? "true" : "overlay";

                        if (format) {
                            if (displayTarget == pega.api.ui.constants.MODAL_DIALOG) { //"Fixed Sized" >> ""fixed_sized_modal""
                                format = format.trim().replace(/ /g, '_').toLowerCase() + "_modal";
                            } else if (displayTarget == pega.api.ui.constants.OVERLAY) { //"Fixed Sized" >> "pz-po-c-fixed_sized"
                                format = "pz-po-c-" + format.trim().replace(/ /g, '_').toLowerCase();
                            }
                        }

                        pega.control.UIElement.Actions.processAction(flowActionName, target, event, usingPage, "Rule-HTML-Section", format, template, inAnim, outAnim, className, className, !closeOnClickAway, centerOverlay);

                    }
                }
             	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.launchLocalAction API");
                }
              	
            },

            
            /*  var params = {
                            target: “Page1.prop1 ",
                            rowIndex: {value: "Page1.prop1", isProperty: true },
                            event: eventObj
            };
            pega.api.ui.actions.setFocus(params);
           *
           */
            setFocus: function(params) {
                if (params && params instanceof Object) {
                    var target = params.target;
                 	var rowIndexObj = params.rowIndex;

                    if (target || (event && rowIndexObj)) {
                        
                        var event = params.event;
                        var eventTarget = event ? pega.util.Event.getTarget(event) : "";
                      	
                        if (rowIndexObj && rowIndexObj instanceof Object) {
                            var value = p.api.ui.util.getParameterValue(rowIndexObj, eventTarget);
                            var options = {
                                dataSource: target,
                                focusIndex: value
                            };
                            pega.control.UIElement.Actions.doGridAction(event, "SETFOCUS", null, options);
                        } else {
                          	var contextPage = eventTarget ? p.api.ui.util.getBaseRef(eventTarget) : "";
                            var targetPage = target.substr(0, target.indexOf("."));
                            var targetProperty = target.substr(target.indexOf("."));
                            pega.control.UIElement.Actions.setItemFocus(targetProperty, targetPage || contextPage);
                        }

                    }
                }
            	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.setFocus API");
                }
            },

            /*  var params = {
                          activity: activityJSObject,
                          dataTransform: dataTransformJSObject,
                          usePrimaryPage: true/false,
                          url: "urlString",
                          windowProperties: {
                              name: {value: "Page1.Prop1", isProperty: true/false},
                              replaceHistory:  true/false,
                              height: pixels,
                              width:  pixels,
                              top: pixels,
                              left: pixels,
                              resizable:  true/false,
                              scrollbars: true/false,
                              locationbar: true/false,
                              menubar: true/false,
                              statusbar: true/false,
                              toolbar: true/false
                }

                };
 
            pega.api.ui.actions.openURLInWindow(params);
           *
           *
           */
            openURLInWindow: function(params) {
              	if (params && params instanceof Object) {
                    var externalURL = params.url;
                    var event = params.event;
                    var target = event ? pega.util.Event.getTarget(event) : "";
                    var wProperties = params.windowProperties;

                    var wName = "";
                    var wOptionsStr = "";
                    var replaceHistory = false;
                    var isAlternateUrl = externalURL ? "true" : "false";

                    if (wProperties && wProperties instanceof Object) {
                        var nameObj = wProperties.name;
                        if (nameObj) {
                          wName = p.api.ui.util.getParameterValue(nameObj, target);
                        }

                        replaceHistory = (typeof wProperties.replaceHistory == 'undefined') ? false : wProperties.replaceHistory;

                        var resizable = "resizable=" + (wProperties.resizable ? 1 : 0) + ",";
                        var scrollbars = "scrollbars=" + (wProperties.scrollbars ? 1 : 0) + ",";
                        var location = "location=" + (wProperties.locationbar ? 1 : 0) + ",";
                        var menubar = "menubar=" + (wProperties.menubar ? 1 : 0) + ",";
                        var status = "status=" + (wProperties.statusbar ? 1 : 0) + ",";
                        var toolbar = "toolbar=" + (wProperties.toolbar ? 1 : 0) + ",";
                        var height = (typeof wProperties.height == 'undefined') ? "" : "height=" + wProperties.height + ",";
                        var width = (typeof wProperties.width == 'undefined') ? "" : "width=" + wProperties.width + ",";
                        var top = (typeof wProperties.top == 'undefined') ? "" : "top=" + wProperties.top + ",";
                        var left = (typeof wProperties.left == 'undefined') ? "" : "left=" + wProperties.left;

                        wOptionsStr = resizable + scrollbars + location + menubar + status + toolbar + height + width + top + left;
                    }

                    if (externalURL) {
                        pega.control.UIElement.Actions.openUrlInWindow(externalURL, wName, wOptionsStr, replaceHistory.toString(), event, isAlternateUrl);
                    } else {
                        // Expected url >> /prweb/Ri-cE-kbyIJmD1qozVTAKaYXOyZehsa7*/!STANDARD?pyActivity=ShowTestHarness&pzPrimaryPageName=pyWorkPage.Features(5)
                        // Expected url in case of data transform >> /prweb/stGjv1jMWqVSivMGRkJat1WCu_rXWHpbIUDDzfmD7tU%5B*/!OpenPortal?pyActivity=@baseclass.pzTransformAndRun&pyDataTransform=TestTrasform&pyDataTransformParams=["DP1":"123","DP2": "test"]&pyPreActivity=TestActivity&Param1=&Param2=&pzPrimaryPageName=pyDisplayHarness

                        var activityObject = params.activity;
                        var transformObject = params.dataTransform;
                        var usePrimaryPage = (typeof params.usePrimaryPage == 'undefined') ? false : params.usePrimaryPage;

                        var urlStr = "";

                        if (activityObject && activityObject instanceof Object) {

                            var activityName = activityObject.name;
                            if (activityName) {
                                var activityParamsStr = p.api.ui.util.getParametersString(activityObject.parameters, target);
                                var contextPage = "pzPrimaryPageName=" + (usePrimaryPage ? SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName') : p.api.ui.util.getBaseRef(target));

                                if (transformObject && transformObject instanceof Object) {
                                    var dtName = transformObject.name;
                                    var dtParams = transformObject.parameters;
                                    var paramStr = "";

                                    urlStr = "pyActivity=@baseclass.pzTransformAndRun&pyDataTransform=" + dtName;

                                    if (dtParams && dtParams.length) {
                                        var paramStr = "&pyDataTransformParams=";
                                        paramStr += p.api.ui.util.getDataTransformParamsStr(dtParams, target);
                                    }

                                    urlStr += paramStr + "&pyPreActivity=" + activityName + "&" + activityParamsStr + contextPage;
                                } else {
                                    urlStr = "pyActivity=" + activityName + "&" + activityParamsStr + contextPage;
                                }

                                urlStr = window.location.pathname + "?" + urlStr;
                                pega.control.UIElement.Actions.openUrlInWindow(urlStr, wName, wOptionsStr, replaceHistory.toString(), event, isAlternateUrl);
                            }
                        }
                    }
                }
              	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.openURLInWindow API");
                }
            },
          	/**
            * pega.api.ui.actions.getSection("sectionname", "pagename", callBackFunc);
            */
          	getSection: function(sectionName, contextPage, callback) {
              var safeURL = SafeURL_createFromURL(pega.u.d.url);
              safeURL.put("pyActivity", "@baseclass.pzGetSectionForPage");
              safeURL.put("sectionName", sectionName);
              safeURL.put("pzPrimaryPageName", contextPage);
                            
              p.u.d.asyncRequest("GET", safeURL, {
                success: function(res) { callback(res.responseText);},
                failure: function(res) {
                  console.log("Error getting section markup " + res);
                }
              });
            },
          	/**
            * pega.api.ui.actions.getSection("sectionname", "pagelistname", callBackFunc);
            */
          	getSections: function(sectionName, contextList, callback) {
              var safeURL = SafeURL_createFromURL(pega.u.d.url);
              safeURL.put("pyActivity", "Code-Pega-List.pzGetSectionsForPageInList");
              safeURL.put("sectionName", sectionName);
              safeURL.put("pzPrimaryPageName", contextList);
                            
              p.u.d.asyncRequest("GET", safeURL, {
                success: function(res) { callback(res.responseText);},
                failure: function(res) {
                  console.log("Error getting section markup " + res);
                }
              });
            },

            /*
           * var params = {
                                      harness: "hanressName",
                                      harnessClass: "className" ,  
                                      displayTarget: "Replace Current / Pop-Up Window /New Document",
                                      tabName: {value: "Page1.Prop1", isProperty: true/false}, 
                                      contextPage: "Page1",
                                      windowName: "wName",
                                      windowWidth: No of pixels,     
                                      windowHeight: No of pixels,   
                                      readOnly: true/false,
                                      submitCurrent: true/false,
                                      key:  "pzInsKey",
                                      activity: activityJSObject,
                                      dataTransform: dataTransformJSObject,
                      displayHarnessFromServer: true/false,
                                      event: eventObj
            };
 
      pega.api.ui.actions.launchHarness(params);
           *
           */
            launchHarness: function(params) {
              	if (params && params instanceof Object) {
                    var harness = params.harness;
                    var className = params.harnessClass;

                    if (harness && className) {
                        var displayTarget = params.displayMode || pega.api.ui.constants.REPLACE_CURRENT;
                        var activityObject = params.activity;
                        var transformObject = params.dataTransform;
                        var event = params.event;
                        var contextPage = params.contextPage;
                        var isReadOnly = (typeof params.readOnly == 'undefined') ? true : params.readOnly;
                        var submitCurrent = (typeof params.doSubmit == 'undefined') ? true : params.doSubmit;
                        var displayHarnessFromServer = (typeof params.displayHarnessFromServer == 'undefined') ? false : params.displayHarnessFromServer;
                        var wName = params.windowName;
                        var wWidth = params.windowWidth;
                        var wHeight = params.windowHeight;
                        var tabNameObj = params.tabName;
                        var insKey = params.key;

                        var target = "";
                        var eventTarget = event ? pega.util.Event.getTarget(event) : "";
                        var activityName = "";
                        var activityParamsStr = "";
                        var dataTransformStr = "";
                        var tabName = "";
                        var wOptions = "";
                      	isReadOnly = isReadOnly ? "Yes" : "No";
                      	submitCurrent = submitCurrent ? "Yes" : "No";
                      	

                        target = (displayTarget == pega.api.ui.constants.POP_UP_WINDOW) ? "popup" : (displayTarget == pega.api.ui.constants.REPLACE_CURRENT) ? "current" : "newDocument";

                        if (tabNameObj && tabNameObj instanceof Object) {
                          tabName = p.api.ui.util.getParameterValue(tabNameObj, eventTarget);
                        }
                      
                      	if (insKey && insKey instanceof Object) {
                          insKey = p.api.ui.util.getParameterValue(insKey, eventTarget);
                        }

                        if (target == "popup") {
                            wOptions = "scrollbars=yes,resizable=1," + ((typeof wWidth == 'undefined') ? "" : "width=" + wWidth + ",") + ((typeof wHeight == 'undefined') ? "" : "height=" + wHeight + ",");
                        }

                        if (activityObject && activityObject instanceof Object) {
                            activityName = activityObject.name;
                            var paramList = activityObject.parameters;
                            if (paramList && paramList.length) { //"AP1:123,AP2:test"
                                for (var i = 0; i < paramList.length; i++) {
                                    var item = paramList[i];
                                    var paramName = item.name;
                                    var value = p.api.ui.util.getParameterValue(item, eventTarget);
                                    if (i > 0)
                                        activityParamsStr += ",";
                                    activityParamsStr += paramName + ":" + value;
                                }
                            }
                        }

                        if (transformObject && transformObject instanceof Object) { //pyDataTransform=TestTrasform&pyDataTransformParams=["param1":"value1", "parama2":"value2"] 
                            var dtName = transformObject.name;
                            var dtParams = transformObject.parameters;
                            if (dtName) {
                                var paramStr = p.api.ui.util.getDataTransformParamsStr(dtParams, eventTarget);
                                dataTransformStr = "pyDataTransform=" + dtName + (paramStr ? "&pyDataTransformParams=" + encodeURIComponent(paramStr) : "");
                            }
                        }

                        var primaryPage = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName');
                      	var arg7 = (target == "newDocument") ? tabName : (target == "popup") ? isReadOnly : submitCurrent;
                        var arg8 = (target == "popup") ? wOptions : (target == "newDocument") ? insKey : tabName;
                      	var arg9 = (target == "popup") ? wName || "" : isReadOnly;
                      	
                      	pega.control.UIElement.Actions.showHarnessWrapper(
	target, className, harness, activityName, activityParamsStr, primaryPage, arg7, arg8, arg9, dataTransformStr, event, contextPage, "", "", "", "", displayHarnessFromServer);
                    }
                }
             	else{
                  _log(ERROR_INVALID_ARGUMENT_OBJECT + " to pega.api.ui.actions.launchHarness API");
                }
            }
        }

        p.api.ui.util = {
            // var paramsList = [{name: "param1", value: "Page1.prop1", isProperty: true},  {name: "param2", value: 123, isProperty: false}]; >> param1=value1&param2=value2&
            getParametersString: function(paramsList, target) {
                var paramsStr = "";
                if (paramsList && paramsList.length) {
                    for (var i = 0; i < paramsList.length; i++) {
                        var item = paramsList[i];
                        var paramName = item.name;
                        var value = item.value;
                        var isProp = (typeof item.isProperty == 'undefined') ? false : item.isProperty;
                        if (isProp) {
                            value = this.getPropertyValue(target, value);
                        }
                        paramsStr += paramName + "=" + value + "&";
                    }
                }
                return paramsStr;
            },

            // var paramsList = [{name: "param1", value: "Page1.prop1", isProperty: true},  {name: "param2", value: 123, isProperty: false}]; >> ["param1": "value1", "param2":"value2"] 
            getDataTransformParamsStr: function(paramsList, target) {
                var paramsStr = "";
                if (paramsList && paramsList.length) {
                    paramsStr = "[";
                    for (var i = 0; i < paramsList.length; i++) {
                        var item = paramsList[i];
                        var paramName = item.name;
                        var value = item.value;
                        var isProp = (typeof item.isProperty == 'undefined') ? false : item.isProperty;
                        if (isProp)
                            value = this.getPropertyValue(target, value);
                        if (i > 0)
                            paramsStr += ",";
                        paramsStr += '"' + paramName + '":"' + value + '"';
                    }
                    paramsStr += "]";
                }
                return paramsStr;
            },

            getPropertyFullReferance: function(target, prop) {
                if(target && prop.charAt(0) == "."){
                  var rowEntryHandle = pega.u.property.toReference(pega.u.d.getRowAndEntryHandle(target).rowEntryHandle);
                  if (rowEntryHandle) {
                      prop = rowEntryHandle + prop;
                  } else {
                      prop = this.getBaseRef(target) + prop;
                  }
                }
                return prop;
            },

            getBaseRef: function(target) {
                var sectionBaseRef = pega.u.d.getBaseRef(target);
                if (!sectionBaseRef) {
                    sectionBaseRef = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName');
                } else if (sectionBaseRef.charAt(0) == ".") {
                    sectionBaseRef = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName') + sectionBaseRef;
                }
                return sectionBaseRef;
            },

            getPropertyValue: function(target, prop) {
                prop = this.getPropertyFullReferance(target, prop);
                prop = "#~" + prop + "~#";
                return pega.c.eventParser.replaceTokensWrapper(prop, "", "", true);
            },

            getParameterValue: function(paramObj, target){
                var value = paramObj.value;
                var isProp = (typeof paramObj.isProperty == 'undefined') ? false : paramObj.isProperty;
                if (isProp)
                    return this.getPropertyValue(target, value);
                else
                    return value;
            },

            inAnimMap: {
                "From bottom": "anim-bottom",
                "Fade in": "anim-fade",
                "Grow": "anim-grow",
                "From left": "anim-left",
                "From right": "anim-right",
                "Shrink": "anim-shrink",
                "From top": "anim-top",
                "Vertical flip": "anim-vert-flip"
            },

            outAnimMap: {
                "Reverse the reveal effect": "anim-in-animation",
                "To top": "anim-top",
                "To bottom": "anim-bottom",
                "To left": "anim-left",
                "To right": "anim-right",
                "Shrink": "anim-grow",
                "Grow": "anim-shrink",
                "Vertical flip": "anim-vert-flip",
                "Fade out": "anim-fade"
            }
        }
    })(pega);
}
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.compare");
pega.ui.compare = function() {
    /*
      parameters 
      1. argument[0] =event 
      2. argument[1]=language 
          values are js/plain/java
      3. argument[2]= fetch  -- values are  'string'/'inskey'  
      4. argumetn[3] =currentString
      5. argument[4]= compareString 
      6. arguemnts[5]= propertyName 
           if argument[3] is inskey tell the function which property to be compared after fetching rule xml using inskeys provided as currentString /compareString 
      7. arguments[6] =currentLabel
      8. arguments[7]= compareWithLabel
      9. arguments[8]=ruleClass
          values are pxObjClass of rule 
      10. arguments[9]= doneCallback
      11. arguments[10] =cancelCallback
      12. arguments[11.....XX]=extra details to be passed as parameters of callbacks 
      */
    var _compareDiffParams = [];
    var _diffViewEditor;
    var _diffViewCEObject;
    var _callbackParams;
    var _oResponseObj;
    var _select;
    var prevDiffElement;
    var nextDiffElement;
    var modalCloseBtn;
  	var toolTipForReverAllChunk = "Revert all chunks";
    var paramKeys = ["event", "language", "fetch", "currentString", "compareString", "propertyName",
            "currentLabel", "compareWithLabel", "doneCallback", "cancelCallback", "ruleClass"];
    var _resizeEventHandler = function() {
        if (document.getElementById("ce-diff-view")) {
            document.getElementById("ce-diff-view").style.height = "";
        }
        _setModalHeight();
    };
    var _showEventHandler = function() {
        pega.u.d.modalDialog.setHeader("Compare text");
        _processActionCallback(_oResponseObj)
    };

    function _successCallback(oResponseObj) {
        _oResponseObj = oResponseObj;
        pega.u.d.modalDialog.subscribe("show", _showEventHandler);
        pega.u.d.processAction("pzLaunchCompareDiffDialog", '', "Rule-HTML-Section", '', '', true,
            _compareDiffParams.event, "pzCompareTextModalTemplate", '', '', false, "Standard");
    }

    function _failureCallback() {
        if (pega.u.d.gBusyInd) {
            pega.u.d.gBusyInd.hide()
        }
        alert("Diff tool: Ajax call to launch diff in popup failed!");
    }

    function _getComputedStyleValue(elem, property) {
        return window.getComputedStyle(elem, null).getPropertyValue(property);
    }

    function _setModalHeight() {
        var ht_mdpanel = document.querySelector("div[data-node-id='pzCompareTextModalTemplate'] .modal-scroll-panel");
        if (ht_mdpanel) {
            var diffpanel_ht = document.querySelector(
                "div[data-node-id='pzCompareTextModalTemplate']>#EXPAND-OUTERFRAME").clientHeight;
            var diffpanel_hd = parseInt(_getComputedStyleValue(document.querySelector(".diff-view-panel .item-1"),
                "height"));
            var headers_ht = parseInt(_getComputedStyleValue(document.querySelector(".diff-content .headersDiv"),
                "height"));
            document.getElementById("ce-diff-view").style.height = diffpanel_ht - diffpanel_hd - 60 - headers_ht +
                "px";
        }
    }

    function _populateSelectBox() {
        var diffObj = _diffViewCEObject.rightChunks();
        _select = document.querySelectorAll(".diff-view-panel select")[0];
        _select.innerHTML = "";
        var text, option;
        for (var i = 0; i < diffObj.length; i++) {
            val = diffObj[i].editTo;
            text = i + 1 + ". Difference from line no." + diffObj[i].editFrom + " to line no." + diffObj[i].editTo;
            option = document.createElement("option");
            option.text = text;
            option.editFrom = diffObj[i].editFrom;
            option.editTo = diffObj[i].editTo;
            _select.add(option);
        }
    }
    
    function _onChangeForSelectBox(event, from){
        var editFrom;
        if(from){
            editFrom = from;
        } else {   
          editFrom = _select[_select.selectedIndex].editFrom;
        }
          
        _jumpToLine(editFrom);
        _diffViewEditor.setCursor({line: editFrom});
        _hideShowPrevDiffBtns();
    }
    function _addEventsToSelectBox(){
        /*
        _registerEventOnElement(_select, "focus", function(){
            this.selectedIndex = -1;
        }); */
        _registerEventOnElement(_select, "change", _onChangeForSelectBox);
        
    }

    function _updateDiffCount(diffObj) {
        var diffObj = _diffViewCEObject.rightChunks();
        document.querySelectorAll(".diff-view-panel .diff-count")[0].innerHTML = diffObj.length;
    }

    function _revertAllChanges() {
        var originalChanges = _diffViewCEObject.right.orig.getValue();
        _diffViewEditor.setValue(originalChanges);
        _diffViewEditor.refresh();
    }

    function _appendHeadersToDiffView() {
        var diffViewObj = document.getElementById("ce-diff-view");
        var headersDivElement = document.querySelectorAll(".headersDiv")[0];
        if (headersDivElement) {
          	var parentNode = headersDivElement.parentNode;
			parentNode.removeChild(headersDivElement);
        }
        var headersDiv = document.createElement("div");
        headersDiv.className = "headersDiv";
        var leftHeaderDiv = document.createElement("div");
        leftHeaderDiv.innerHTML = "<b>Current file : </b>" + _compareDiffParams.currentLabel;
        leftHeaderDiv.className = "header leftDiv";
        var rightHeaderDiv = document.createElement("div");
        rightHeaderDiv.innerHTML = "<b>Compare with : </b>" + _compareDiffParams.compareWithLabel;
        rightHeaderDiv.className = "header rightDiv";
        var middleHeaderDiv = document.createElement("div");
        middleHeaderDiv.className = "header middleDiv";
      	middleHeaderDiv.title = toolTipForReverAllChunk;
        _registerEventOnElement(middleHeaderDiv, "click", _revertAllChanges);
        headersDiv.appendChild(leftHeaderDiv);
        headersDiv.appendChild(middleHeaderDiv);
        headersDiv.appendChild(rightHeaderDiv);
        var diffViewPanel = document.querySelectorAll("#ce-diff-view")[0];
        diffViewPanel.parentNode.insertBefore(headersDiv, diffViewPanel.parentNode.firstChild);
    }

    function _registerEventOnElement(element, eventName, handler) {
        if (element) element.addEventListener(eventName, handler);
    }

    function _jumpToLine(i) {
        var t = _diffViewEditor.charCoords({
            line: i,
            ch: 0
        }, "local").top;
        var middleHeight = _diffViewEditor.getScrollerElement().offsetHeight / 2;
        _diffViewEditor.scrollTo(null, t - middleHeight - 5);
    }

    function _hideShowPrevDiffBtns() {
        var cursor = _getCurrentCursorPosition();
        var chunks = _diffViewEditor.state.diffViews[0].chunks;
        var flag = false;
        for (var i = 0; i < chunks.length; i++) {
            if (cursor <= chunks[i].editTo) {
                flag = true;
                /* If there is only one difference, enable both previous and next buttons */
                if(chunks.length == 1){
                    prevDiffElement.classList.remove("disabled");
                    nextDiffElement.classList.remove("disabled");
                    break;
                }
                /* If last difference, disable next button */
                if (i == chunks.length - 1) {
                    nextDiffElement.classList.add("disabled");
                    prevDiffElement.classList.remove("disabled");
                } else if (i == 0) {
                    /*If first difference, disable previous button */
                    prevDiffElement.classList.add("disabled");
                    nextDiffElement.classList.remove("disabled");
                } else {
                    /* Enable both previous and next buttons for middle elements */
                    prevDiffElement.classList.remove("disabled");
                    nextDiffElement.classList.remove("disabled");
                }
                break;
            }
        }
        if (!flag) {
            nextArrow.classList.add("disabled");
        }
    }

    function diffHandler(e, command, isPrevious) {
        if (e && e.currentTarget && e.currentTarget.classList.contains("disabled")) {
            e.preventDefault();
        } else {
            _diffViewEditor.execCommand(command);
            _hideShowPrevDiffBtns();
            var cursorPos = _getCurrentCursorPosition();
            _jumpToLine(cursorPos);
            if(isPrevious && _select.selectedIndex > 0) {
            _select.selectedIndex--;
            } else if(_select.selectedIndex < _select.length-1){
                /*If not previous, then it is next */
                _select.selectedIndex++;
            }
        }
    }

    function _getMode(language) {
        switch (language) {
            case "js":
            case "javascript":
                mode = "javascript";
                break;
            case "css":
                mode = "css";
                break;
            case "java":
            case "text/x-java":
                mode = "text/x-java";
                break;
            case "html":
                mode = "text/html";
                break;
            case "jsp":
            case "application/x-jsp":
                mode = "application/x-jsp";
                break;
            case "text":
            case "text/plain":
                mode = "text/x-diff";
            default:
                mode = "application/x-jsp";
        }
        return mode;
    }

    function _hideShowDiffPanelElements() {
      	var diffCount = _diffViewCEObject.rightChunks().length;
        if (diffCount == 0) {
            _select.style.display = "none";
            prevDiffElement.style.display = "none";
            nextDiffElement.style.display = "none";
        } else {
            _select.style.display = "block";
            prevDiffElement.style.display = "block";
            nextDiffElement.style.display = "block";
        }
    }

    function _createDiffViewEleIfNotExists(elementId) {
        var diffViewElem = document.getElementById("ce-diff-view");
        if (diffViewElem == null) {
            diffViewElem = document.createElement("div");
            diffViewElem.setAttribute("id", "ce-diff-view");
            document.querySelectorAll(".diff-view-panel .diff-content")[0].appendChild(diffViewElem);
        } else {
            diffViewElem.style.height = "";
            diffViewElem.innerHTML = "";
        }
        return diffViewElem;
    }

    function _processArguments() {
        var argsLength = arguments.length >= paramKeys.length ? arguments.length : paramKeys.length;
        for (var ai = 0; ai < argsLength; ai++) {
            _compareDiffParams[paramKeys[ai]] = arguments[ai];
        }
        if (argsLength > paramKeys.length) {
            argsLength = arguments.length;
            var ind = 0;
            _callbackParams = [];
            for (var aj = paramKeys.length; aj < argsLength; aj++) {
                _callbackParams[ind] = arguments[aj];
                ind++;
            }
        }
    }
  
    function _setSelectboxItem(from){
        for(var i=0; i<_select.length; i++){
          if(_select[i].editFrom === from){
            _select.selectedIndex = i;
            break;
          }
        }
    }
    function _getCurrentCursorPosition(){
        return _diffViewEditor.getCursor().line;
    }
    function _updateDiffHandler() {
        var oldSelectLength = _select.length;
        var _oldSelectIndex = _select.selectedIndex;
        _updateDiffCount();
        _populateSelectBox();
        _hideShowDiffPanelElements();
        if(_select.length === 0){
            return;
        } else if(oldSelectLength < _select.length){
            /* If a change is inserted, point to current diff */
            _onChangeForSelectBox(null, _getCurrentCursorPosition());
            _setSelectboxItem(_getCurrentCursorPosition());
        } else if(_oldSelectIndex === oldSelectLength - 1){
            /* Last diff is selected and hence move to first diff */
            _onChangeForSelectBox();
        } else {
            diffHandler(null, "goNextDiff", false);
            _setSelectboxItem(_getCurrentCursorPosition());
        }
        _hideShowPrevDiffBtns();
    }

    function _addScrollLockEvent() {
        var lock = document.querySelectorAll("div[class='CodeMirror-merge-scrolllock']")[0];
        lock.onclick = function() {
                if (this.innerHTML === "\u21db\u21da") {
                    this.classList.add("lock");
                    this.classList.remove("unlock");
                } else {
                    this.classList.add("unlock");
                    this.classList.remove("lock");
                }
            }
            /* adds classes when loading for the first time*/
        lock.classList.add("lock");
        lock.classList.remove("unlock");
    }

    function _processActionCallback(oResponseObj) {
      	prevDiffElement = document.querySelectorAll(".diff-view-panel .prev-diff")[0];
        nextDiffElement = document.querySelectorAll(".diff-view-panel .next-diff")[0];
        modalCloseBtn = document.querySelectorAll("div[data-node-id='pzCompareTextModalTemplate'] .container-close")[0];
        var diffViewElem = _createDiffViewEleIfNotExists();
        if (_compareDiffParams["fetch"] === "inskey") {
            oResponseObj = JSON.parse(oResponseObj.responseText);
        }
        var language = (_compareDiffParams.language || "java").toLowerCase();
        _diffViewCEObject = CodeMirror.MergeView(diffViewElem, {
            value: oResponseObj.currentValue,
            orig: oResponseObj.compareWithValue,
            lineNumbers: true,
            mode: _getMode(language),
            highlightDifferences: true,
            connect: null,
            collapseIdentical: false
        });
        _diffViewEditor = _diffViewCEObject.editor();
        _updateDiffCount();
        _populateSelectBox();
        _addEventsToSelectBox();
        _hideShowDiffPanelElements();
        _appendHeadersToDiffView();
        _addScrollLockEvent();
        
        _registerEventOnElement(prevDiffElement, "click", function(e) {
            diffHandler(e, "goPrevDiff", true);
        });
        _registerEventOnElement(nextDiffElement, "click", function(e) {
            diffHandler(e, "goNextDiff", false);
        });
        _diffViewEditor.on("updateDiff", _updateDiffHandler);
        /* Hide prevDiffElement when opens for the first time */
        prevDiffElement.classList.add("disabled");
        if (pega.u.d.gBusyInd) {
            pega.u.d.gBusyInd.hide()
        }
        _setModalHeight();
        _registerEventOnElement(window, "resize", _resizeEventHandler);
        _registerEventOnElement(modalCloseBtn, "click", _cancelCompareDiff);
        setTimeout(function() {
            _diffViewCEObject.editor().refresh();
            _diffViewCEObject.rightOriginal().refresh();
        }, 0);
        _onChangeForSelectBox();
    }

    function _showCompareDiff() {
        _processArguments.apply(this, arguments);
        if (pega.u.d.gBusyInd) {
            pega.u.d.gBusyInd.show()
        }
        if (_compareDiffParams.fetch === "inskey") {
            var oSafeUrl = new SafeURL("@baseclass.pzFetchCompareSources");
            oSafeUrl.put("currentInskey", _compareDiffParams.currentString);
            oSafeUrl.put("compareWithInskey", _compareDiffParams.compareString);
            oSafeUrl.put("propertyName", _compareDiffParams.propertyName);
            var callback = {
                success: _successCallback,
                failure: _failureCallback
            }
            pega.u.d.asyncRequest('POST', oSafeUrl, callback);
        } else if (_compareDiffParams.fetch === "string") {
            _successCallback({
                "currentValue": _compareDiffParams.currentString,
                "compareWithValue": _compareDiffParams.compareString
            });
        }
    }

    function _doneCompareDiff() {
        if (document.querySelectorAll("div[data-node-id='pzCompareTextModalTemplate'] .container-close").length) {
            document.querySelectorAll("div[data-node-id='pzCompareTextModalTemplate'] .container-close")[0].removeEventListener(
                "click", _cancelCompareDiff);
        }
        pega.u.d.hideModalWindow();
        var updatedContent = _diffViewEditor.getValue();
        if (_compareDiffParams.doneCallback !== "undefined" && _compareDiffParams.doneCallback !== "") {
            var doneCallback = eval(_compareDiffParams.doneCallback);
            if (typeof doneCallback === "function") {
                var returnObj = {
                    "updatedCurrentString": updatedContent,
                    "fetch": _compareDiffParams["fetch"],
                    "propertyName": _compareDiffParams["propertyName"],
                    "ruleClass": _compareDiffParams["ruleClass"]
                };
                if (_callbackParams) {
                    returnObj["params"] = _callbackParams;
                }
                doneCallback(returnObj);
            }
        }
        _diffCleanUp();
    }

    function _cancelCompareDiff() {
        if (document.querySelectorAll("div[data-node-id='pzCompareTextModalTemplate'] .container-close").length) {
            document.querySelectorAll("div[data-node-id='pzCompareTextModalTemplate'] .container-close")[0].removeEventListener(
                "click", _cancelCompareDiff);
        }
        pega.u.d.hideModalWindow();
        if (_compareDiffParams.cancelCallback !== "undefined" && _compareDiffParams.cancelCallback !== "") {
            var cancelCallback = eval(_compareDiffParams.cancelCallback);
            if (typeof cancelCallback === "function") {
                var returnObj = {
                    "propertyName": _compareDiffParams["propertyName"],
                    "ruleClass": _compareDiffParams["ruleClass"]
                };
                if (_callbackParams) {
                    returnObj["params"] = _callbackParams;
                }
                cancelCallback(returnObj);
            }
        }
        _diffCleanUp();
    }

    function _getDiffViewObj() {
        return _diffViewCEObject;
    }

    function _diffCleanUp() {
        pega.u.d.modalDialog.unsubscribe("show", _showEventHandler);
        window.removeEventListener("resize", _resizeEventHandler);
        _diffViewEditor.off("updateDiff", _updateDiffHandler);
        _oResponseObj = null;
        _diffViewEditor = null;
        _diffViewCEObject = null;
    }
  
    return {
        /*
          parameters 
          1. argument[0] =event 
          2. argument[1]=language 
                values are js/plain/java
          3. argument[2]= fetch  -- values are  'string'/'inskey'  
          4. argumetn[3] =currentString
          5. argument[4]= compareString 
          6. arguemnts[5]= propertyName 
               if argument[3] is inskey tell the function which property to be compared after fetching rule xml using inskeys provided as currentString /compareString 
          7. arguments[6] =currentLabel
          8. arguments[7]= compareWithLabel
          9. arguments[8]= doneCallback
          10. arguments[9] =cancelCallback
          11. arguments[10]=ruleClass
                values are pxObjClass of rule 
          12. arguments[11.....XX]=extra details to be passed as parameters of callbacks 
          */
        showDiff: _showCompareDiff,
        /*called on click of cancel */
        cancelDiff: _cancelCompareDiff,
        /*called on click of done*/
        doneDiff: _doneCompareDiff,
        getDiffViewObj: _getDiffViewObj
    }
}();
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.components");

/** 
 * This Inspector creates hooks that allow the user to "inspect" DOM elements on the page and attach events to fire when inspecting elements of interest
 * @param $Object$ configuration - the configuration of the inspector object for use and behavior
 *                 configuration.elementFoundCallback - required param to be used as a hook to fire a function when found, passes the function the element that has been found
 *                 configuration.eventMonitored - the type of event that will be used to trigger the inspecting, will be mouseover by default
 *                 configuration.selectorList - array of selectors that will be used to determine what the inspector is looking for, will be "*" by default
 *                 configuration.ignoreList - array of selector that will be used to skip any inspecting if the element is contained in any of the selectors
 *                 configuration.isValidElement - a function that is called when finding an element to allow for continued searching
 */
pega.ui.components.Inspector = function(configuration) {
    if(!configuration || !configuration.elementFoundCallback) {
        throw new Error("elementFoundCallback is a required parameter");
    }

    var _config = {};
    _config.elementFoundCallback = configuration.elementFoundCallback;
    _config.eventMonitored = configuration.eventMonitored || "mouseover";
    _config.selectorList = configuration.selectorList || ["*"];
    _config.ignoreList = configuration.ignoreList || [];
    _config.isValidElement = configuration.isValidElement || function(element) { return true; };
    
    var _enabled = false;

	/** 
     * @private finds if the element is contained within the selector provided
     * @param $HTMLElement$ element - element of interest
     * @param $HTMLElement$ selector - selector to use to find if element is contained within this selector
     *
     * @return $HTMLElement$ element that was found from the selector, null if nothing found
     */
    function _closest(element, selector) {
        var elem = $(element).closest(selector);

        if (elem.length < 1) {
            return null;
        }

        return elem[0];
    }

  	/** 
     * @private event attached to the eventMonitored config option that will act as a wrapper for the elementFoundCallback config option
     * @param $Event$ e - event object
     */
    function _handleEvent(e) {
        // Don't inspect inside elements in the ignore list
        var ignoreSelectors = _config.ignoreList.join(',');
        if (_closest(e.target, ignoreSelectors)) {
            return;
        }

      	// TODO: This may want to be a function in the future...
      	var returnObj = {};
      	returnObj.eventObj = e;
        
        // Find the closest element that matches the selector(s) if you can or fall out with a null element within the elementFoundCallback
        var selectorList = _config.selectorList.join(',');
        var closestElem = _closest(e.target, selectorList);

        // Call extension to see if the element is ok and if it needs to keep looking
        while(closestElem && !_config.isValidElement(closestElem)) {
            closestElem = _closest(closestElem.parentNode, selectorList);
        }

        if (!closestElem) {
      		returnObj.foundElement = null;
            _config.elementFoundCallback(returnObj);
            return false;
        } else {
          	returnObj.foundElement = closestElem; 
       		_config.elementFoundCallback(returnObj);
        }
    }

  	/**
     * @private used for clean up purposes, removes any events being attached by this class
     * @param $Event$ e - event object
     */
    function _handleUnload(e) {
        this.removeEventListener(_config.eventMonitored, _handleEvent, true);
        this.removeEventListener('unload', _handleUnload, true);
    }

    /** 
     * @private used to add event listeners in all frames
     */
    function _addEventListeners() {
        var frames = pega.util.Dom.getFrames(window);
        for (var i = 0; i < frames.length; i++) {
            frames[i].addEventListener(_config.eventMonitored, _handleEvent, true);
            frames[i].addEventListener('unload', _handleUnload, true);
        }
    }

    /** 
     * @private used to remove event listeners in all frames
     */
    function _removeEventListeners() {
        var frames = pega.util.Dom.getFrames(window);
        for (var i = 0; i < frames.length; i++) {
            frames[i].removeEventListener(_config.eventMonitored, _handleEvent, true);
          	frames[i].removeEventListener('unload', _handleUnload, true);
        }
    }

	/** 
     * @public disables the class and removes all event listeners applied by this class, acts as a turn off and clean up function
     */
    this.disable = function() {
        _enabled = false;
        _removeEventListeners();
      
        pega.ui.composer.cancelEventListener("Inspector.WindowLoad", _addEventListeners);
	      window.removeEventListener('unload', this.disable, true);
    }
  	
    /**
     * @public enables the class and adds all event listeners applied by this class
     */
    this.enable = function() {
        //if the inspector is already enabled, then prevent it from reregistering events
        if(!_enabled){
            _enabled = true;
            _addEventListeners();

            pega.ui.composer.registerEventListener("Inspector.WindowLoad", _addEventListeners);
            window.addEventListener('unload', this.disable, true);
        }
    }
    
    /** 
     * @public gives that status of the class if it is on or off
     *
     * @return $Boolean$ returns the current status
     */
    this.isEnabled = function() {
        return _enabled;
    }
};

if(pega.ui && pega.ui.composer && pega.ui.composer.sendEvent) {
    pega.ui.composer.sendEvent("Inspector.WindowLoad", window);
}
 //static-content-hash-trigger-YUI
pega.namespace("pega.ui");

// This is the pega.ui.panel Constants
pega.ui.panelConstants = (function () {
    /* -- PUBLIC GLOBALS -- */
    var publicAPI = {};
  
    // Enum for supported panel docks
    publicAPI.DOCK_LOCATION = Object.freeze({
        RIGHT: "RIGHT",
        LEFT: "LEFT", 
        TOP: "TOP"
    });
  
    publicAPI.DOCK_CLASS = Object.freeze({
        RIGHT: "right-panel-dock",
        LEFT: "left-panel-dock",
        TOP: "top-panel-dock"
    });
  
    publicAPI.HARNESS_SELECTOR = "body > [data-portalharnessinsname]";
  
    // Enum for all class names being used
    publicAPI.ClassNames = Object.freeze({
        BASE_DOCK: "panel-dock",
        MANAGER_TRANSITION: "panel-manager-transitions",
        DOCK_TRANSITION: "panel-dock-transitions",
        DOCK_SHOW: "panel-dock-show",
        PANEL_MANAGER: "panel-manager",
        BASE_PANEL: "panel-component",
        SHOW_PANEL: "show-panel-component",
        CHILD_PANEL: "panel-component-child"
    });
  
    // Enum for event names used by manager and panels
    publicAPI.EventMessages = Object.freeze({
        DOCK_SHOW: "PanelDock.show",
        DOCK_HIDE: "PanelDock.hide",
        DOCK_RESIZE: "PanelDock.resize",
        BASE_DOCK_STATE_CHANGED : "PanelDock.baseStateChanged",
        INHERITED_DOCK_STATE_CHANGED : "PanelDock.inheritedStateChanged",
        PANEL_SHOW: "PanelComponent.show",
        PANEL_HIDE: "PanelComponent.hide",
        PANEL_DESTROY: "PanelComponent.destroy",
        CLOSE_ICON_CLICK: "PanelComponent.closeIconClick"
    });
  
    // Return the constants
    return publicAPI;
}());
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.components.panels");

/** 
 * This is a basic panel object. It can be used standalone but is very powerful when registered via pega.ui.panelManager.register(myPanel, location).
 * 
 * @param panelId - A unique ID for your panel. This will also be added as an ID to your panel element in the DOM.
 * @param options - A set of options used for the panels component
  *       options.preShow - A function that will be called (if the panel is hidden) before any other show logic
 *        options.preHide - A function that will be called (if the panel is showing) before any other hide logic
 *        options.showCallback - A call back function that is called when the panel is shown
 *        options.hideCallback - A call back function that is called when the panel is hidden
 *        options.pushesContent - When true visually pushes content in, otherwise overlays the content  - 
 */
pega.ui.components.panels.Base = function(panelId, options) {
    var _this = this;
    var _options = options || {};
    /////////////////////////////////////////////////////////////////////////////////
    //                                   CONSTANTS                                 //
    /////////////////////////////////////////////////////////////////////////////////
    var States = Object.freeze({
        HIDDEN: "HIDDEN",
        SHOWING: "SHOWING"
    });
    
    /////////////////////////////////////////////////////////////////////////////////
    //                                 CONSTRUCTOR                                 //
    /////////////////////////////////////////////////////////////////////////////////
    var _panelId = panelId;

    var _panelElement = document.createElement('div'); // The outermost DOM element for the panel
    _panelElement.id = _panelId;
    _panelElement.className = pega.ui.panelConstants.ClassNames.BASE_PANEL;
    document.body.appendChild(_panelElement); // Add panel element to body by default

    var _childPanels = {}; // The child panels of this panel - an associative array keyed by panel ID
    var _state = States.HIDDEN; // The state of the panel

    /////////////////////////////////////////////////////////////////////////////////
    //                               PRIVATE FUNCTIONS                             //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @private Invokes the extendable showCallback function and cleans up the event listener
     */
    function _showCallback(e) {
        /* 
         * BUG-386706: Verify that the panel element is the same as the target element
         * (we do not want child elements of the panel firing transitionend events to cause the
         * showCallback() function to trigger).
         */
        if(_this.getElement() === e.target) {
            if(_options.showCallback) {
                _options.showCallback();                
            }          
            _this.getElement().removeEventListener("transitionend", _showCallback);
        }
                    
    }
  
    /**
     * @private Invokes the extendable hideCallback function and cleans up the event listener
     */
    function _hideCallback(e) {
        /* 
         * BUG-386706: Verify that the panel element is the same as the target element
         * (we do not want child elements of the panel firing transitionend events to cause the
         * hideCallback() function to trigger).
         */
        if(_this.getElement() === e.target) {
            if(_options.hideCallback) {
                _options.hideCallback();                
            }          
            _this.getElement().removeEventListener("transitionend", _hideCallback);
        }        
    }

    /////////////////////////////////////////////////////////////////////////////////
    //                                  PUBLIC API                                 //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @public Getter for panel element.
     * 
     * @return The outermost DOM element for the panel.
     */
    this.getElement = function() {
        return _panelElement;
    }

    /**
     * @public Getter for the ID.
     * 
     * @return The ID of the panel.
     */
    this.getId = function() {
        return _panelId;
    }

    /**
     * @public Getter for whether the panel is showing.
     * 
     * @return True if the panel is showing.
     */
    this.isShowing = function() {
        return (_state === States.SHOWING);
    }
      
    /**
     * @public Shows the panel.
     */
    this.show = function() {
        // Only show if hiding
        if(!_this.isShowing()) {
            // Before the panel shows, call the extendable preShow      
            if(_options.preShow){
                _options.preShow();
            } 
          
            // Add class that shows panel
            _panelElement.classList.add(pega.ui.panelConstants.ClassNames.SHOW_PANEL);
            // Update the panel state
            _state = States.SHOWING;
            var parentPanel = _panelElement.parentNode;
            if(parentPanel) {
                pega.ctxmgr.registerContextSwitching(parentPanel);
            }
            
            // Notify of the panel show
            pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.PANEL_SHOW, {id : _panelId});
          
            // When the panel is done loading, call the extendable showCallback
            _this.getElement().addEventListener("transitionend", _showCallback);
        }
    }
    
    /**
     * @public Hides the panel.
     */
    this.hide = function() {
        // Only hide if showing
        if(_this.isShowing()) {
            // Hide child panels
            for(var childId in _childPanels) {
                _childPanels[childId].hide();
            }          
          
            // Before the panel hides, call the extendable preHide      
            if(_options.preHide){
                _options.preHide();
            }          
          
            // Remove the class that shows the panel
            _panelElement.classList.remove(pega.ui.panelConstants.ClassNames.SHOW_PANEL);
            // Update the panel state
            _state = States.HIDDEN;
            // Notify of the panel hide
            pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.PANEL_HIDE, {id : _panelId});
          
            // When the panel is done hiding, call the extendable hideCallback      
            _this.getElement().addEventListener("transitionend", _hideCallback);
        }
    }

    /**
     * @public Adds a panel as a child to this panel.
     * 
     * @param childPanel - A panel object that will be added to this panel as a child.
     * @return true if child was added successfully, false if otherwise
     */
    this.addChild = function(childPanel) {
        var childPanelId = childPanel.getId();
        if(_childPanels[childPanelId]) {
            return false; // We already have a child panel with this ID
        }

        var childPanelElement = childPanel.getElement();
        // Apply the child class to the child panel
        childPanelElement.classList.add(pega.ui.panelConstants.ClassNames.CHILD_PANEL);
        // Add child panel inside this panel's DOM element
        _panelElement.appendChild(childPanelElement);
        // Add the child to the list of children this panel contains
        _childPanels[childPanelId] = childPanel;

        return true;
    }

    /**
     * @public Removes a child panel from this panel.
     * 
     * @param childPanel - The child panel to remove from this panel.
     * @return true if the child panel was removed successfully, false if otherwise
     */
    this.removeChild = function(childPanel) {
        var childPanelId = childPanel.getId();
        if(!_childPanels[childPanelId]) {
            return false; // we do not have a child panel with this ID
        }

        var childPanelElement = _childPanels[childPanelId].getElement();
        // Remove the child class from the child panel
        childPanelElement.classList.remove(pega.ui.panelConstants.ClassNames.CHILD_PANEL);
        // Move panel element to document body
        document.body.appendChild(childPanelElement);
        // Nullify the object from the list of children
        _childPanels[childPanelId] = null;
        // Remove the key from the list
        delete _childPanels[childPanelId];

        return true;
    }

    /**
     * @public Sets the inner content of the panel.
     * 
     * @param htmlElement - An element to insert into the panel for its content.
     */
    this.setContent = function(htmlElement) {
        _panelElement.appendChild(htmlElement);
    }
    
    /**
     * @public returns true if the panel should push content (default) or false
     *
     * @return If the panel does not push content (overlays content)
     */
    this.doesPushContent = function() {
        // If no options.pushesContent, then default to true, else return the actual value 
        return _options.pushesContent == null || _options.pushesContent;
    }

    /**
     * @public Destroys this panel and cleans it up from the DOM.
     */
    this.destroy = function() {
        // Make sure the element is in the DOM
        if(_panelElement.parentNode) {
            _panelElement.parentNode.removeChild(_panelElement);
        }

        // Destroy child panels
        for(var childId in _childPanels) {
            _childPanels[childId].destroy();
        }

        // Send message announcing panel is destroyed
        pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.PANEL_DESTROY, {id : _panelId});

        // Remove transitionend event listeners to be safe
        window.removeEventListener("transitionend", _showCallback);
        window.removeEventListener("transitionend", _hideCallback);
    }
};
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.components.panels");

/**
 * This is an enhanced panel object. It allows a section to be loaded into the panel as outlined by https://mesh.pega.com/docs/DOC-107367.
 * 
 * @param panelId - A unique ID for your panel. This will also be added as an ID to your panel element in the DOM.
 */
pega.ui.components.panels.ClassLoader = function(panelId, options) {
    pega.ui.components.panels.Base.call(this, panelId, options); // inherit

    /////////////////////////////////////////////////////////////////////////////////
    //                                   CONSTANTS                                 //
    /////////////////////////////////////////////////////////////////////////////////


    /////////////////////////////////////////////////////////////////////////////////
    //                                 CONSTRUCTOR                                 //
    /////////////////////////////////////////////////////////////////////////////////
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.CLOSE_ICON_CLICK, _closeIconClick, null, this);
    var _this = this;
    var _baseDestroy = this.destroy;
    var _baseShow = this.show;
    var _baseHide = this.hide;
    var _sectionElement = null;

    /////////////////////////////////////////////////////////////////////////////////
    //                               PRIVATE FUNCTIONS                             //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @private Builds parameters for the preActivity of a reload section.
     * 
     * @param panelClass - The Pega class of the UI Panel
     * @param params - Additional array of parameters to be sent to server (ex. { "paramName": "paramValue" })
     */
    function _buildPreActivityParams(panelClass, params) {
        // Build up URL for preActivity
        var reloadUrl = new SafeURL();
        reloadUrl.put("panelClass", panelClass);

        // Add all additional parameters to the request
        for(var key in params) {
            // protect against possible null pointer exception if anything was passed as undefined as part of params
            if (params[key] !== undefined) {
                reloadUrl.put(key, params[key]);
            }           
        }

        return reloadUrl;
    }

    /**
     * @private Used to close the panel containing the event's target 
     * 
     * @param e - The event that fired this function
     */
    function _closeIconClick(e) {
        var nearestPanel = $(e.target).closest(".panel-component")[0];
        if(nearestPanel && nearestPanel.id == this.getId()) {
            this.hide();
        }
    }  

    /**
     * @private Removes the width by setting the style to null, and removes the event.
     */
    function _removeWidth() {
        if(_sectionElement) {
            _sectionElement.style.width = null;
            _this.getElement().removeEventListener("transitionend", _removeWidth);
        }
    }

    /**
     * @private Used to set the width of the panels child and registered for cleanup event 
     */
    function _setWidthAndRegisterForRemoveCallback() {
        // TODO if we want to support resize, then we need to rethink this hardcoded amount
        if(_sectionElement) {
            _sectionElement.style.width = "360px";
            _this.getElement().addEventListener("transitionend", _removeWidth);
          
          if ($(".screen-layout").hasClass("flex")) {
            var isHeaderResizable = $(".screen-layout-region-header").hasClass("screen-layout-region-resize ui-resizable");
            var isFooterResizable = $(".screen-layout-region-footer").hasClass("screen-layout-region-resize ui-resizable");
            var isLeftSideBarResizable = $(".screen-layout-region-main-sidebar1").hasClass("screen-layout-region-resize ui-resizable");
            var isRightSideBarResizable = $(".screen-layout-region-main-sidebar2").hasClass("screen-layout-region-resize ui-resizable");
            if (
              isHeaderResizable ||
              isFooterResizable ||
              isLeftSideBarResizable ||
              isRightSideBarResizable
            ) {
              var rightWidth, widthToBeSubtracted, leftWidth;
              var clientWidth = $(window).width();
              leftWidth = $(".screen-layout-region-main-sidebar1").outerWidth() || 0;
              rightWidth = $(".screen-layout-region-main-sidebar2").outerWidth() || 0;

              widthToBeSubtracted = leftWidth + rightWidth + 360;

              $(".screen-layout-region-main-middle").css({
                width: clientWidth - widthToBeSubtracted + "px",
              });
            }
          }
        }
    }

    /////////////////////////////////////////////////////////////////////////////////
    //                                  PUBLIC API                                 //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @public Shows the panel and sets the width accordingly while animating
     */
     this.show = function() {
         _setWidthAndRegisterForRemoveCallback();
         _baseShow();
     }

    /**
     * @public Hides the panel and sets the width accordingly while animating
     */
     this.hide = function() {
         _setWidthAndRegisterForRemoveCallback();
         _baseHide();
     }

    /**
     * @public Handles calling the panel Load Activity to load the content based on the given class
     *
     * @param panelClass - The class of the panel to show (ex. Pega-UI-Panel-LayoutEditor)
     * @param callback - A callback function to be run after the reload occurs
     * @param params - Additional array of parameters to be sent to server (ex. { "paramName": "paramValue" })
     */
    this.loadByClass = function(panelClass, callback, params) {
        if(_sectionElement != null) { // pzPanel section already in DOM
            var sectionNode = pega.u.d.getSectionByName("pzPanel", "", _sectionElement);
            var preActivityUrl = _buildPreActivityParams(panelClass, params);
            // Refresh pzPanel section
            pega.u.d.reloadSection(sectionNode, "pzLoadPanel", preActivityUrl.toQueryString(), false, false, -1, false, null, null, null, callback);
        } else { // pzPanel section not in DOM yet
            // The new section element needs to be the first child because if the parent panel contains children panels with content, it may find that section instead
            _sectionElement = document.createElement("div");
            this.getElement().insertBefore(_sectionElement, this.getElement().firstChild);

            var preActivityUrl = _buildPreActivityParams(panelClass, params);
            preActivityUrl.put("panelName", this.getId()); // add panel name param because we are creating the parameterized data page for the first time here
            // load the pzPanel section into the dom
            pega.u.d.loadSectionIntoDom("pzPega_UI_Panel", "@baseclass", _sectionElement, callback, "", "pzLoadPegaUIPanel", preActivityUrl.toQueryString());
        }
    }

    /**
     * @public Handles calling the panel load activity to load the content based on the given section name and page context.
     * 
     * @param streamName - The name of the section to load
     * @param pageContext - The name of the page to load the section against
     * @param callback - A callback function to be run after the reload occurs
     * @param params - Additional array of parameters to be sent to server (ex. { "paramName": "paramValue" })
     */
    this.loadByDynamic = function(streamName, pageContext, callback, params) {
        params = params || {}; // this argument is optional
        params.streamName = streamName;
        params.pageContext = pageContext;

        this.loadByClass("Pega-UI-PanelContent-Dynamic", callback, params);
    }
    
    /**
     * @public Handles loading a section into a panel
     *
     * @param $Object$ configurations - A list of configurations for loading the section into a panel
     *    $String$ (Required)    sectionName -  Name of the section to load in a panel
     *    $String$ (Required)    sectionClass - Class of the section to load in a panel
     *    $Function$ (Optional)  callback - Javascript function to run on success of loading the sections in the panel (given an empty function if not specified)
     *    $String$ (Optional)    pageContext - Page context of where to invoke the activities in / load the section in (given "" if not specified)
     *    $String$ (Optional)    preActivityName - Name of an activity to run prior to loading the section (given "" if not specified)
     *    $SafeURL$ (Optional)   preActivityParams - Parameters that are send to the activity (given an empty SafeURL if not specified)
     *    $Boolean$ (Optional)   disableHeader - Boolean controlling whether or not we have a header section
     *    $String$ (Optional)    headerSectionName - Name of the header section to load in a panel (given "pzPanelHeader" if not specified)
     *    $String$ (Optional)    headerSectionClass - Class of the header section to load in a panel (given "@baseclass" if not specified) 
     */
    this.loadSectionInPanel = function(configurations) {
        if(!configurations.sectionName || typeof configurations.sectionName !== "string") {
            throw new Error("Section name is not specified and / or is not a string!");
	      }
      
        if(!configurations.sectionClass || typeof configurations.sectionClass !== "string") {
            throw new Error("Section class is not specified and / or is not a string!");
	      }
      
        if(!configurations.callback || typeof configurations.callback !== "function") {
            configurations.callback = function() {};
        }
      
        if(!configurations.pageContext || typeof configurations.pageContext !== "string") {
            configurations.pageContext = "";
	      }
      
        if(!configurations.preActivityName || typeof configurations.preActivityName !== "string") {
            configurations.preActivityName = "";
	      }
      
        if(!configurations.preActivityParams || !configurations.preActivityParams instanceof SafeURL) {
            configurations.preActivityParams = new SafeURL(); 
        }
      
        // Remove content from panels to be replaced
        var panelElement = this.getElement();
        while(panelElement.firstChild) {
            // Cleanup the elements in the section we want to remove
            var uniqueId = panelElement.firstChild.getAttribute("uniqueid");
            pega.u.d.removeFromMemory(uniqueId);
            panelElement.removeChild(panelElement.firstChild);
        }
      
        // If we have not disabled the header, load header content
        if(!configurations.disableHeader) {
            if((!configurations.headerSectionName || typeof configurations.headerSectionName !== "string") ||
               (!configurations.headerSectionClass || typeof configurations.headerSectionClass !== "string")) {
                configurations.headerSectionName = "pzPanelHeader"; 
                configurations.headerSectionClass = "@baseclass"; 
            }
          
            // Insert new div into panel element before the content
            var headerContent = panelElement.appendChild(document.createElement("div"));

            // Load the header content into the DOM
            pega.u.d.loadSectionIntoDom(configurations.headerSectionName, configurations.headerSectionClass, headerContent, function(){}, configurations.pageContext, "", "");
        }

        // Insert new div into the panel element to hold the content
        var sectionContent = panelElement.appendChild(document.createElement('div'));

        // Load the section content into the DOM
        var sectionContainerContent = pega.u.d.loadSectionIntoDom(configurations.sectionName, configurations.sectionClass, sectionContent, configurations.callback, configurations.pageContext, configurations.preActivityName, configurations.preActivityParams.toQueryString());
        sectionContainerContent.classList.add("panel-content");
    }
    
    /**
     * @public Destroys this panel and cleans it up from the DOM, then removes event listeners
     */
    this.destroy = function() {
        _sectionElement = null;
        // Call pzpega_ui_components_panels_base destroy first
        _baseDestroy();
        // Clean up event listener from the dom
        pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.CLOSE_ICON_CLICK, _closeIconClick);
    }    
};
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.components.panelDocks");

/** 
 * This is a base panel dock to be inherited.  The pega.ui.manager is responsible for using the
 * correct dock based on the dock location passed in when registering a panel.
 * 
 * @param locationID - A unique ID for your panelDock.
 * @param panelDockClass - CSS class to specify styling
 * @param options - Options object with the following fields:
 *                   startingWidth - Width that the panel is when first displayed 
 *                   startingHeight - Height that the panel is when first displayed
 *                   enableResize - When true, the panel is resizable
 */
pega.ui.components.panelDocks.Base = function(locationID, panelDockClass, options) {

    /////////////////////////////////////////////////////////////////////////////////
    //                                 CONSTRUCTOR                                 //
    /////////////////////////////////////////////////////////////////////////////////
    var _this = this;
    var _panels = {};
    // Option related Vars
    var _options = options || {};
    var _width = _options.startingWidth || 360;
    var _height = _options.startingHeight || 46;
    var _enableResize = _options.enableResize || false;

    // Dock element which exists in the DOM
    var _dockElement = document.createElement('div');
    _dockElement.id = locationID;
    _dockElement.classList.add(panelDockClass);
    _dockElement.classList.add(pega.ui.panelConstants.ClassNames.BASE_DOCK);
    _dockElement.classList.add(pega.ui.panelConstants.ClassNames.DOCK_TRANSITION);
    document.body.appendChild(_dockElement);

    // Based on the option passed in, handle resizable logic
    if (_enableResize) {
        var handle = $("<div class='panel-dock-resize-handle ui-resizable-handle ui-resizable-w'></div>");
        $(_dockElement).prepend(handle);

        // TODO: Investigate a non-jquery approach?
        $(_dockElement).resizable({
            handles : {"w": ".panel-dock-resize-handle"},
            resize: function(event, ui){
                _this.resize(ui.size);
            },
            start: function(event, ui) {              
                // Temporarily disable mouse events on iframes for smooth dragging
                var iframeList = document.getElementsByTagName("iframe");
                for(var i = 0; i < iframeList.length; i++) {
                    iframeList[i].style.pointerEvents = "none";
                }

                pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.BASE_DOCK_STATE_CHANGED, false);
                // Remove the transition class as the transition animation kicks in while dragging
                _dockElement.classList.remove(pega.ui.panelConstants.ClassNames.DOCK_TRANSITION);
            },
            stop: function(event, ui) {
                // Re-enable mouse events on iframes
                var iframeList = document.getElementsByTagName("iframe");
                for(var i = 0; i < iframeList.length; i++) {
                    iframeList[i].style.pointerEvents = "auto";
                }

                pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.BASE_DOCK_STATE_CHANGED, true);
                // Add transition back as its removed in start
                _dockElement.classList.add(pega.ui.panelConstants.ClassNames.DOCK_TRANSITION);
            }
        });
    }

    /////////////////////////////////////////////////////////////////////////////////
    //                               PRIVATE FUNCTIONS                             //
    /////////////////////////////////////////////////////////////////////////////////


    /////////////////////////////////////////////////////////////////////////////////
    //                                  PUBLIC API                                 //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @public addPanel - add the passed in panel to this dock
     *
     * @param panel - The panel to add
     * @return - true is successfully added, otherwise false
     */
    this.addPanel = function(panel) {
        if(_panels[panel.getId()]) {
            return false;
        }

        _panels[panel.getId()] = panel;
        _dockElement.appendChild(panel.getElement());
        return true;
    }

    /**
     * @public destroyPanelHandler - handles how the dock should respond to a panel being destroyed
     *
     * @param eventArg - The panel which was destroyed
     * @return - true is successfully handled, otherwise false
     */
    this.destroyPanelHandler = function (eventArg) {
       var panelId = eventArg.id;
      
        // Return if panel doesn't exist in this dock
        if(!_panels[panelId]) {
            return false;
        }
      
        // Remove the panels content from the DOM
        delete _panels[panelId];
        return true;
    }

    /**
     * @public showHandler - handles how the dock should respond to a panel showing
     *
     * @param eventArg - argument object passed the event which has an Id property on it.
     * @return - true is successfully handled, otherwise false
     */
    this.showHandler = function(eventArg) {
        var panelId = eventArg.id;
        // Return if panel doesn't exist in this dock
        if(!_panels[panelId]) {
            return false;
        }

        // Hide all the other panels
        for(var key in _panels) {
            if(panelId !== key) {
                _panels[key].hide();
            }
        }

        pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.BASE_DOCK_STATE_CHANGED, true);

        _dockElement.classList.add(pega.ui.panelConstants.ClassNames.DOCK_SHOW);
        return true;
    }

    /**
     * @public hideHandler - handles how the dock should respond to a panel hiding
     *
     * @param eventArg - argument object passed the event which has an Id property on it.
     * @return - true is successfully handled, otherwise false
     */
    this.hideHandler = function(eventArg) {
        var panelId = eventArg.id;

        if(!_panels[panelId]) {
            return false;
        }

        // If there is a panel that is showing, then dont hide the dock
        for(var key in _panels) {
            if(_panels[key].isShowing()) {
                return false;
            }
        }

        var cleanUpAfterHideTransition = function() {
             pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.BASE_DOCK_STATE_CHANGED, false);

            _dockElement.removeEventListener("transitionend", cleanUpAfterHideTransition);
        };
        _dockElement.addEventListener("transitionend", cleanUpAfterHideTransition);
        _dockElement.classList.remove(pega.ui.panelConstants.ClassNames.DOCK_SHOW);

        return true;
    }   
    
    /**
     * @public isShowing - determines if any panel is showing in this dock
     *
     * @return - true if the panel is showing, false if otherwise
     */
    this.isShowing = function() {
        // loop over all the panels, return true is any is showing
        for(var key in _panels) {
            if(_panels[key].isShowing()) {
              return true
            }
        }
        return false;
    }
    
    /**
     * @public isPanelInDock - determines if the passed in panel is in this dock
     *
     * @return - true if the panel is in this dock, false otherwise
     */
    this.isPanelInDock = function(panelId) {
        return panelId in _panels;
    }
    
    /**
     * @public getDockElement - gets the dock element
     *
     * @return - the dock element
     */
    this.getDockElement = function() {
        return _dockElement;
    }
    
    /**
     * @public doesPanelPushContent - determines if the passed in panel pushes content or overlays content
     *
     * @return - true if the panel pushes content, false if it overlays the content
     */
    this.doesPanelPushContent = function(panelId){
      if(panelId in _panels) {
          return _panels[panelId].doesPushContent();
      } else {
          // The panel belongs to a different dock, return true by default
          return true;
      }
    }

    /**
     * @public hide - hides all of the dock's panels
     */
    this.hide = function() {
        // Hide all the panels
        for(var key in _panels) {
            _panels[key].hide();
        }
    }

    /**
     * @public resize - resizes the private width and height based on the passed in argument
     *
     * @param size - size object has a width and height propertry
     */
    this.resize = function(size) {
        _width = size.width;
        _height = size.height;
    }

    /**
     * @public getWidth - gets the width of the dock
     *
     * @return - the width of the docks
     */
    this.getWidth = function() {
        return _width;
    }

    /**
     * @public getHeight - gets the height of the dock
     *
     * @return - gets the height of the dock
     */
    this.getHeight = function() {
        return _height;
    }

    /**
     * @public destroy - cleans up the dock
     */
    this.destroy = function() {
        // Clean up the DOM
        _dockElement.parentNode.removeChild(_dockElement);
        pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.BASE_DOCK_STATE_CHANGED, false);

        // Clean up events
        pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_DESTROY, this.destroyPanelHandler);
        pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_SHOW, this.showHandler);
        pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_HIDE, this.hideHandler);
    }

    // These event registrations are purposely at the bottom as this file as the eventhandler functions have not been declared yet
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_DESTROY, this.destroyPanelHandler);
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_SHOW, this.showHandler);
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_HIDE, this.hideHandler);
};
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.components.panelDocks");

/** 
 * This is a specific panel dock to be displayed on the right side of the screen.  The pega.ui.manager
 * is responsible for using the correct dock based on the dock location passed in when registering a panel.
 * 
 * @param locationID - A unique ID for your panelDock.
 * @param panelDockClass - css class to specify styling
 * @param options - options object which is passed directly to the panelDock Base's constructor
 */
pega.ui.components.panelDocks.Right = function(locationID, panelDockClass, options) {

    /////////////////////////////////////////////////////////////////////////////////
    //                                 CONSTRUCTOR                                 //
    /////////////////////////////////////////////////////////////////////////////////
    pega.ui.components.panelDocks.Base.call(this, locationID, panelDockClass, options); // Inherit

    // Cancel event handlers from the base
    pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_SHOW, this.showHandler);
    pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_HIDE, this.hideHandler);
    pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_DESTROY, this.destroyPanelHandler);

    // Cache off these methods from the base class before they are overrideen
    var _baseShowHandler = this.showHandler; 
    var _baseHideHandler = this.hideHandler;
    var _baseResize = this.resize;
    var _baseDestroyPanelHandler = this.destroyPanelHandler;
    var _baseDestroy = this.destroy;

    // Cache off this, so that inside of eventhandler the original object can be referenced
    var _this = this;

    /////////////////////////////////////////////////////////////////////////////////
    //                               PRIVATE FUNCTIONS                             //
    /////////////////////////////////////////////////////////////////////////////////
  
    /**
     * @private Resets harness to default state without docks
     */
    function _resetHarness() {
        var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);      
        // If the dock is successfully hidden, then we want to set the body's right to be 0
        harness.style.right = "0px";
    }  
  
    /////////////////////////////////////////////////////////////////////////////////
    //                                  PUBLIC API                                 //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @public showHandler - handles how the dock should respond to a panel showing
     *
     * @param eventArg - argument object passed the event which has an Id property on it.
     */
    this.showHandler = function(eventArg) {
        // Call the base panel's showHandler function, which if successful handles right panel specific code
        if(_this.isPanelInDock(eventArg.id)){
            _baseShowHandler(eventArg);
            _this.getDockElement().style.width = _this.getWidth() + "px";

            if(_this.doesPanelPushContent(eventArg.id)){
                // Update the body to be shift based on the width of the right panel
                var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);  
                harness.style.right = _this.getWidth() + "px";
            } else {
                 // If the panel overlays, then the width should be 0
                 _resetHarness();
            }
            pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.HARNESS_RESIZE);
        } 
    }

    /**
     * @public hideHandler - handles how the dock should respond to a panel hiding
     *
     * @param eventArg - argument object passed the event which has an Id property on it.
     */
    this.hideHandler = function(eventArg) {
        // If the panel belongs to this dock
        if(_this.isPanelInDock(eventArg.id)) {
            // Call the base panel's hideHandler function
            _baseHideHandler(eventArg);
            // If the dock is still showing (another panel has shown), then dont adjust the dock
            if(!_this.isShowing()) {
                // Always adjust the dock
                 _this.getDockElement().style.width = "0px";
                // Adjust the harness if the panel has pushed content
                if(_this.doesPanelPushContent(eventArg.id)) {
                  _resetHarness();
                } 
            }       
        }
    }
    
    /**
     * @public destroyPanelHandler - handles how the dock should respond to a panel being destroyed
     *
     * @param eventArg - The panel which was destroyed
     * @return - true is successfully handled, otherwise false
     */
    this.destroyPanelHandler = function (eventArg) {
      _baseDestroyPanelHandler(eventArg);
      if(!_this.isShowing()) {
        _resetHarness();
        _this.getDockElement().style.width = "0px"; 
      }
    }

    /**
     * @public destroy - cleans up the dock
     */
    this.destroy = function(){
        _resetHarness();
        _baseDestroy();
    }

    /**
     * @public resize - handles how the dock should respond to a panel resizing
     *
     * @param eventArg - argument object passed the event which has a width and height property on it.
     */
    this.resize = function(size) {
        // Call the base panel's resize function
        _baseResize(size);

        var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);      
      
        // Set the body's right to be based on the panels width (since it has resized)
        harness.style.right = _this.getWidth() + "px";
    }

    // Register for the show and hide events 
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_SHOW, this.showHandler);
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_HIDE, this.hideHandler);
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_DESTROY, this.destroyPanelHandler);
};
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.components.panelDocks");

/** 
 * This is a specific panel dock to be displayed on the left side of the screen.  The pega.ui.manager
 * is responsible for using the correct dock based on the dock location passed in when registering a panel.
 * 
 * @param locationID - A unique ID for your panelDock.
 * @param panelDockClass - css class to specify styling
 * @param options - options object which is passed directly to the panelDock Base's constructor
 */
pega.ui.components.panelDocks.Left = function(locationID, panelDockClass, options) {

    /////////////////////////////////////////////////////////////////////////////////
    //                                 CONSTRUCTOR                                 //
    /////////////////////////////////////////////////////////////////////////////////
    pega.ui.components.panelDocks.Base.call(this, locationID, panelDockClass, options); // Inherit
  
    // Cancel event handlers from the base
    pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_SHOW, this.showHandler);
    pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_HIDE, this.hideHandler);
    pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_DESTROY, this.destroyPanelHandler);

    // Cache off these methods from the base class before they are overrideen
    var _baseShowHandler = this.showHandler; 
    var _baseHideHandler = this.hideHandler;
    var _baseResize = this.resize;
    var _baseDestroyPanelHandler = this.destroyPanelHandler;
    var _baseDestroy = this.destroy;
  
    // Cache off this, so that inside of eventhandler the original object can be referenced
    var _this = this;

    /////////////////////////////////////////////////////////////////////////////////
    //                               PRIVATE FUNCTIONS                             //
    /////////////////////////////////////////////////////////////////////////////////
  
    /**
     * @private Resets harness to default state without docks
     */
    function _resetHarness() {
        var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);      
        // If the dock is successfully hidden, then we want to set the body's left to be 0
        harness.style.left = "0px";
    }
     
    /////////////////////////////////////////////////////////////////////////////////
    //                                  PUBLIC API                                 //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @public showHandler - handles how the dock should respond to a panel showing
     *
     * @param eventArg - argument object passed the event which has an Id property on it.
     */
    this.showHandler = function(eventArg) {
        // Call the base panel's showHandler function, which if successful handles left panel specific code
        if(_this.isPanelInDock(eventArg.id)){
            _baseShowHandler(eventArg);
            _this.getDockElement().style.width = _this.getWidth() + "px";

            if(_this.doesPanelPushContent(eventArg.id)){
                // Update the body to be shift based on the width of the left panel
                var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);  
                harness.style.left = _this.getWidth() + "px";
            } else {
                // If the panel overlays, then the width should be 0
                _resetHarness();
            }
            pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.INHERITED_DOCK_STATE_CHANGED);
        } 
    }

    /**
     * @public hideHandler - handles how the dock should respond to a panel hiding
     *
     * @param eventArg - argument object passed the event which has an Id property on it.
     */
    this.hideHandler = function(eventArg) {
        // If the panel belongs to this dock
        if(_this.isPanelInDock(eventArg.id)) {
            // Call the base panel's hideHandler function
            _baseHideHandler(eventArg);
            // If the dock is still showing (another panel has shown), then dont adjust the dock
            if(!_this.isShowing()) {
                // Always adjust the dock
                 _this.getDockElement().style.width = "0px";
                // Adjust the harness if the panel has pushed content
                if(_this.doesPanelPushContent(eventArg.id)) {
                  _resetHarness();
                } 
            }       
        }
    }
    
    /**
     * @public destroyPanelHandler - handles how the dock should respond to a panel being destroyed
     *
     * @param eventArg - The panel which was destroyed
     * @return - true is successfully handled, otherwise false
     */
    this.destroyPanelHandler = function (eventArg) {
      _baseDestroyPanelHandler(eventArg);
      if(!_this.isShowing()) {
        _resetHarness();
        _this.getDockElement().style.width = "0px"; 
      }
    }
    
    /**
     * @public destroy - cleans up the dock
     */
    this.destroy = function(eventArg){
        _resetHarness();
        _baseDestroy(eventArg);
    }

    /**
     * @public resize - handles how the dock should respond to a panel resizing
     *
     * @param eventArg - argument object passed the event which has a width and height property on it.
     */
    this.resize = function(size) {
        // Call the base panel's resize function
        _baseResize(size);

        var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);      
      
        // Set the body's left to be based on the panels width (since it has resized)
        harness.style.left = _this.getWidth() + "px";
    }

    // Register for the show and hide events 
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_SHOW, this.showHandler);
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_HIDE, this.hideHandler);
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_DESTROY, this.destroyPanelHandler);
};
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.components.panelDocks");

/** 
 * This is a specific panel dock to be displayed on the top side of the screen.  The pega.ui.manager
 * is responsible for using the correct dock based on the dock location passed in when registering a panel.
 * 
 * @param locationID - A unique ID for your panelDock.
 * @param panelDockClass - css class to specify styling
 * @param options - options object which is passed directly to the panelDock Base's constructor
 */
pega.ui.components.panelDocks.Top = function(locationID, panelDockClass, options) {

    /////////////////////////////////////////////////////////////////////////////////
    //                                 CONSTRUCTOR                                 //
    /////////////////////////////////////////////////////////////////////////////////
    pega.ui.components.panelDocks.Base.call(this, locationID, panelDockClass, options); // inherit

    // Cancel event handlers from the base
    pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_SHOW, this.showHandler);
    pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_HIDE, this.hideHandler);
    pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.PANEL_DESTROY, this.destroyPanelHandler);

    // Cache off these methods from the base class before they are overrideen
    var _baseShowHandler = this.showHandler; 
    var _baseHideHandler = this.hideHandler;
    var _baseResize = this.resize;
    var _baseDestroyPanelHandler = this.destroyPanelHandler;
    var _baseDestroy = this.destroy;

    // Cache off this, so that inside of eventhandler the original object can be referenced
    var _this = this;
  
    /////////////////////////////////////////////////////////////////////////////////
    //                               PRIVATE FUNCTIONS                             //
    /////////////////////////////////////////////////////////////////////////////////
  
    /**
     * @private Resets harness to default state without docks
     */
    function _resetHarness() {
        var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);      
        // If the dock is successfully hidden, then we want to set the body's top to be 0
        harness.style.top = "0px";
    }
  
    /////////////////////////////////////////////////////////////////////////////////
    //                                  PUBLIC API                                 //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @public showHandler - handles how the dock should respond to a panel showing
     *
     * @param eventArg - argument object passed the event which has an Id property on it.
     */
    this.showHandler = function(eventArg) {
        if(_this.isPanelInDock(eventArg.id)) {
            // Call the base panel's showHandler function, which if successful handles top panel specific code
            _baseShowHandler(eventArg);
                      
            _this.getDockElement().style.width = "100%";
            _this.getDockElement().style.height = _this.getHeight() + "px";                            
                     
            if(_this.doesPanelPushContent(eventArg.id)) {
                // Update the body to be shift based on the height of the top panel
                var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);  
                harness.style.top = _this.getHeight() + "px";
            } else {
                // If the panel overlays, then the width should be 0
                _resetHarness();
            }          
          
            // Send event to trigger resize in panel manager
            pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.INHERITED_DOCK_STATE_CHANGED);            
        }
    }   
    
    /**
     * @public hideHandler - handles how the dock should respond to a panel hiding
     *
     * @param eventArg - argument object passed the event which has an Id property on it.
     * @return - NA
     */
    this.hideHandler = function(eventArg) {    
        // If the panel belongs to this dock
        if(_this.isPanelInDock(eventArg.id)) {
            // Call the base panel's hideHandler function
            _baseHideHandler(eventArg);
            // If the dock is still showing (another panel has shown), then dont adjust the dock
            if(!_this.isShowing()) {
                // Always adjust the dock
                 _this.getDockElement().style.height = "0";
                // Adjust the harness if the panel has pushed content
                if(_this.doesPanelPushContent(eventArg.id)) {
                  _resetHarness();
                  pega.desktop.sendEvent(pega.ui.panelConstants.EventMessages.INHERITED_DOCK_STATE_CHANGED); 
                } 
            }       
        }
    }
    
    /**
     * @public destroyPanelHandler - handles how the dock should respond to a panel being destroyed
     *
     * @param eventArg - The panel which was destroyed
     * @return - true is successfully handled, otherwise false
     */
    this.destroyPanelHandler = function (eventArg) {
      _baseDestroyPanelHandler(eventArg);
      if(!_this.isShowing()) {
        _resetHarness();
        _this.getDockElement().style.height = "0px"; 
      }
    }
    
    /**
     * @public destroy - cleans up the dock
     */
    this.destroy = function() {
        _resetHarness();
        _baseDestroy();
    }

    /**
     * @public resize - handles how the dock should respond to a panel resizing
     *
     * @param eventArg - argument object passed the event which has a width and height property on it.
     */
    this.resize = function(size) {
        // Call the base panel's resize function
        _baseResize(size);

        var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);      
      
        // Set the body's top to be based on the panels width (since it has resized)
        harness.style.top = _this.getHeight() + "px";
    }

    // Register for the show and hide events 
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_SHOW, this.showHandler);
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_HIDE, this.hideHandler);
    pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.PANEL_DESTROY, this.destroyPanelHandler);
};
//static-content-hash-trigger-GCC
var $pNamespace = pega.namespace;
$pNamespace("pega.ui");

// This is the pega.ui.Panel Manager
pega.ui.panelManager = (function () {
    /* -- PUBLIC GLOBALS -- */
    var publicAPI = {};
    var _listOfDocks = {}; // List of all dock objects
    var _isInitialized = false;

    /////////////////////////////////////////////////////////////////////////////////
    //                              PRIVATE FUNCTIONS                              //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @private Initializes the Panel Manager and sets event listeners.
     */
    function _initialize() {
        // Register events for handling anything harness related
        pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.INHERITED_DOCK_STATE_CHANGED, _resizeHarness);
        pega.desktop.registerEventListener(pega.ui.panelConstants.EventMessages.BASE_DOCK_STATE_CHANGED, _toggleHarnessTransitions);

        var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);
        harness.classList.add(pega.ui.panelConstants.ClassNames.PANEL_MANAGER);

        for(var key in pega.ui.panelConstants.DOCK_LOCATION) {
            var locationID = pega.ui.panelConstants.DOCK_LOCATION[key];
            var panelDockClass = pega.ui.panelConstants.DOCK_CLASS[key];    
            _listOfDocks[locationID] = pega.ui.PanelDockFactory.createPanelDock(locationID, panelDockClass, null);
        }

        window.addEventListener("unload", _destroy);
        _isInitialized = true;
    }
  
    /**
     * @private Sets the passed in dock's top based on the top panels style
     */
    function _adjustTopStyle(dock){
        var topElement = document.querySelector(".top-panel-dock");
        var computedStyles = window.getComputedStyle(topElement);
      
        var topPanelHeight = computedStyles.height;
        var topPanelTop = computedStyles.top;

        var topHeightInt = topPanelHeight === "" ? 0 :  parseInt(topPanelHeight.substring(0,topPanelHeight.indexOf("px")));
        var topTopInt = topPanelTop === "" ? 0 :  parseInt(topPanelTop.substring(0,topPanelTop.indexOf("px")));

        var newPanelTopInt =  topHeightInt + topTopInt;
        var newPanelTop =  newPanelTopInt === 0 ? "" : newPanelTopInt + "px";

        dock.getDockElement().style.top  = newPanelTop;
    }
  
    /**
     * @private Resizes the harness based on all open docks
     */
    function _resizeHarness() {
      // Adjust the top of the left and right dock to accomodate the top panel if its up
      _adjustTopStyle(_listOfDocks["LEFT"]);
      _adjustTopStyle(_listOfDocks["RIGHT"]);
      
      //handle scenario where top panel has not yet finished animating
      setTimeout(function(){
        _adjustTopStyle(_listOfDocks["LEFT"]);
        _adjustTopStyle(_listOfDocks["RIGHT"]);
      }, 250);
    }
  
    /**
     * @private Add/remove necessary transition classes from the harness
     *
     * @param addTransitions - Whether to add the transition class or not
     */
    function _toggleHarnessTransitions(addTransitions) {
        var harness = document.querySelector(pega.ui.panelConstants.HARNESS_SELECTOR);

        if(addTransitions) {
            harness.classList.add(pega.ui.panelConstants.ClassNames.MANAGER_TRANSITION);
        } else {
            harness.classList.remove(pega.ui.panelConstants.ClassNames.MANAGER_TRANSITION);
        }
    }

    /**
     * @private Destroy all dock objects and cancel all event listeners
     */
    function _destroy() {
        for(var key in pega.ui.panelConstants.DOCK_LOCATION) {
            var locationID = pega.ui.panelConstants.DOCK_LOCATION[key];
            _listOfDocks[locationID].destroy();
        }

        pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.INHERITED_DOCK_STATE_CHANGED, _resizeHarness);
        pega.desktop.cancelEventListener(pega.ui.panelConstants.EventMessages.BASE_DOCK_STATE_CHANGED, _toggleHarnessTransitions);
    }

    /////////////////////////////////////////////////////////////////////////////////
    //                              PUBLIC FUNCTIONS                               //
    /////////////////////////////////////////////////////////////////////////////////
    /**
     * @public Register a panel with the layout manager so that it can keep track of panels and react to panel behavior.
     *
     * @param $Object$ panel - The panel object that will be registered (i.e., pega.ui.components.panels.Base)
     * @param $String$ location - location that panel will be located in, can use public.DOCK_LOCATION enum to identify
     */
    publicAPI.registerPanel = function(panel, location) {
        if (!_isInitialized) {
          _initialize();
        }
        _listOfDocks[location].addPanel(panel);
    }

    /**
     * @public Hides all of the panels in all docks.
     */
    publicAPI.hideAllPanels = function() {
        for(var key in pega.ui.panelConstants.DOCK_LOCATION) {
            var locationID =  pega.ui.panelConstants.DOCK_LOCATION[key];
            if(_listOfDocks[locationID] != null) {
                _listOfDocks[locationID].hide();
            }
        }
    }

    // Return the manager
    return publicAPI;
}());

pega.ui.PanelDockFactory = (function(){
    /* -- PUBLIC GLOBALS -- */
    var publicAPI = {};

    publicAPI.createPanelDock = function(locationID, panelDockClass, options){
        switch(locationID){
            case pega.ui.panelConstants.DOCK_LOCATION.RIGHT :
                return new pega.ui.components.panelDocks.Right(locationID, panelDockClass, options);  // RIGHT, right-panel-dock
            case pega.ui.panelConstants.DOCK_LOCATION.LEFT :
                return new pega.ui.components.panelDocks.Left(locationID, panelDockClass, options) // LEFT, left-panel-dock
            case pega.ui.panelConstants.DOCK_LOCATION.TOP :
                return new pega.ui.components.panelDocks.Top(locationID, panelDockClass, options) // TOP, top-panel-dock
            default :
                throw "Panel Dock type " + dockType + " is not supported";
        }
    };

    // Return the panel dock factory
    return publicAPI;
}());
//static-content-hash-trigger-YUI
/**
 * This Component is used to create a highlight around an element that is provided
 * @param $object$ options - json object that is a list of options to enable for this component
 *                 options.id - the id to put onto the highlight element itself
 *                 options.container - a container to put the highlight element into, or a list of space
                                      separated string classes to uniquely identify the container element
 *                 options.class - custom class to put on the highlight element itself for custom styling
 *                 options.hasMask - add a mask around the element being highlighted to grey out the 
 *                                   rest of the the UI
 *                 options.useOffsetSize - used to override the calculations for the size of the highlight
 *                                         component.
 */
pega.ui.components.Highlight = function(options) {
    var _options = options || {};
    var _this = this;

    /////////////////////////////////////////////////////////////////////////////////
    //                                   CONSTANTS                                 //
    /////////////////////////////////////////////////////////////////////////////////
    var ClassNames = {
        DECORATION : "highlight-decoration",
        MASK : "highlight-mask",
        CENTERED : "highlight-centered",
        HIGHLIGHT : "highlight-base",
        INFOBAR : "highlight-infobar"
    };

    /////////////////////////////////////////////////////////////////////////////////
    //                                 CONSTRUCTOR                                 //
    /////////////////////////////////////////////////////////////////////////////////
    //currently highlighted element
    var _currentElement;
    var _infoBarElement;
    //highlight container
    var _highlightElement = document.createElement("div");
    _highlightElement.classList.add(ClassNames.HIGHLIGHT);
    //start highlight in hidden state
    _highlightElement.style.display = "none";

    if(typeof(_options.container) == "string"){
        //if the container if a string, it contains classes (space separated) that uniquely
        //identifiy the element.  This converts the string of classes to a selector
        // split the list of class on spaces
        var  arrayOfStringClasses = _options.container.split(" ")
        // add a . to each class
        var arrayofStringSelectors = arrayOfStringClasses.map(function(el){return "."+ el;})
        // concatenate the strings together
        var selector = arrayofStringSelectors.join("");

        //fetch the container element based on the selector
        _options.container = document.querySelector(selector)
    }
  
    //build the element into a container if specified
    if (_options.container) {
        _options.container.appendChild(_highlightElement);
    } else {
        document.body.appendChild(_highlightElement)
    }

    //apply id option given by user
    if (_options.id) {
        _highlightElement.id = _options.id;
    }  
    
    //apply class option given by user
    if (_options["class"]) {
        _highlightElement.className += " " + _options["class"];
    }

    //highlight element to position
    var _decorationElement = document.createElement("div");
    //apply base css class
    _decorationElement.classList.add(ClassNames.DECORATION);
    //append highlight to doc
    _highlightElement.appendChild(_decorationElement);

    if (_options.hasMask) {
        var _maskElement = document.createElement("div");
        _maskElement.classList.add(ClassNames.MASK)
        _highlightElement.appendChild(_maskElement);
    }

    /////////////////////////////////////////////////////////////////////////////////
    //                                  PRIVATE API                                //
    /////////////////////////////////////////////////////////////////////////////////
    /**
     * @private handler for scroll and resize events to reposition the highlight
     */
    var _resizeTimeoutID;
    function _handleReposition() {
        clearTimeout(_resizeTimeoutID);
        //Set new resize timeout
        _resizeTimeoutID = setTimeout(function(){
            _this.show(_currentElement);
        }, 25);
    }

    function _handleTransitionEnd (e){
        if (e.propertyName == "width" || e.propertyName == "height") {
            _handleReposition();
        }
    }

    /**
     * @private turn on event listeners to reposition the highlight on scroll and resize
     */
    function _turnListenersOn() {
        if (!_this.isShowing()) {
            var frames = pega.util.Dom.getFrames(window);
            for (var i = 0; i < frames.length; i++) {
            //the frame contains a harness that has the pega namespace
            if (frames[i].pega) {
                    frames[i].addEventListener("scroll", _handleReposition, true);
                    frames[i].addEventListener("resize", _handleReposition, true);
                    frames[i].addEventListener("transitionend", _handleTransitionEnd, true);
                    frames[i].pega.u.d.attachOnload(_handleReposition, true);
                }
            }
        }
    }

    /**
     * @private turn off events for scroll and resize
     * @param htmlElement - element to place highlight around
     */
    function _turnListenersOff() {
        clearTimeout(_resizeTimeoutID);
      
        var frames = pega.util.Dom.getFrames(window);
        for (var i = 0; i < frames.length; i++) {
            if (frames[i].pega) {
                frames[i].removeEventListener("scroll", _handleReposition, true);
                frames[i].removeEventListener("resize", _handleReposition, true);
                frames[i].removeEventListener("transitionend", _handleTransitionEnd, true);
                frames[i].pega.u.d.detachOnload(_handleReposition);
            }
        }
    }

    /**
     * @private get the offset top and left of the element
     * @param htmlElement - element to find location of
     */
    function _calcLeftAndTop(htmlElement) {
        var isInModal = $(htmlElement).closest("#modalWrapper").length > 0;
        var currentWindow = htmlElement.ownerDocument.defaultView;
      
        // Get location of element in context of current window
        // Now account for scrolling of top-window (when you're not in an iframe)
        var elementOffset = htmlElement.getBoundingClientRect();
        var loc = {};
        loc.left = elementOffset.left + $(currentWindow).scrollLeft(); 
        loc.top = elementOffset.top + $(currentWindow).scrollTop();
            
        // Loop over each parent window until coming back to current window
        while (currentWindow) {
            if (currentWindow == window || !currentWindow.parent) {
                break;
            } else {
                //Get location of window in context of parent window
                var windowOffset = currentWindow.frameElement.getBoundingClientRect();
                loc.left += windowOffset.left;
                loc.top += windowOffset.top;
              
                // Factor in scroll location when you are in iframes as it unintentially throws the distance off further than from the perspective of the top-window
                if (htmlElement.ownerDocument.defaultView == currentWindow && !isInModal) {
                    // Only factor in scroll for non desktopWindow frame since in the desktopWindow it is covered by offset
                    loc.top -= $(currentWindow).scrollTop();
                    loc.left -= $(currentWindow).scrollLeft();
                }
              
                currentWindow = currentWindow.parent;
            }
        }
        return loc;
    }

    /**
     * @private move element to current location.
     * @param locObj - object contain:
                    .width - width the new location
                    .height - height of the new location
                    .top - top location of the new location
                    .left - left location of the new location
     */
    function _setPositionElement(htmlElement, locObj) {
        htmlElement.style.width = locObj.width + "px";
        htmlElement.style.height = locObj.height + "px";
        htmlElement.style.left = locObj.left + "px";
        htmlElement.style.top = locObj.top + "px";
      
        //if an infobar element exists, and the highlight is within 21px of the top,
        //then force the infobar to be inside of the highlight
        if(_infoBarElement) {
            // BUG-419940, set _infoBarElement.style.top first to "" so it picks up on normal styling by default
            _infoBarElement.style.top = "";
            if(locObj.top <= 21){
                _infoBarElement.style.top = "0px";
            }
        }

    }

    /////////////////////////////////////////////////////////////////////////////////
    //                                  PUBLIC API                                 //
    /////////////////////////////////////////////////////////////////////////////////

    /**
     * @public Show highlight around the element provided.
     * @param htmlElement - element to place highlight around
     */
    _this.show = function(htmlElement) {
        
        // BUG-424590 don't attempt to show highlight elements which no longer exist 
        if(!_highlightElement) {return false;}
      
        //set current element being highlighted for tracking purposes
        _currentElement = htmlElement;
        var loc = {};
        //if there is no element, center the highlight in the middle of the screen
        //else position it on the element
        if (!htmlElement) {
            _highlightElement.classList.add(ClassNames.CENTERED);
        } else {
            loc = _calcLeftAndTop(htmlElement);
            
            loc.width = htmlElement.scrollWidth;
            loc.height = htmlElement.scrollHeight;
          
            // BUG-431793 Use offsetWidth instead of scrollWidth if specified. offsetWidth is the
            // outer width (ie. the space occupied by the element, including padding and borders).
            // scrollWidth is the total width including stuff that is only visible if you scroll
            if(_options.useOffsetSize === true) {
              loc.width = htmlElement.offsetWidth;
              loc.height = htmlElement.offsetHeight;
            }
        }

        /*Apply windows when showing the highlight to reposition*/
        _turnListenersOn();

        //Position highlight element and mask
        _setPositionElement(_highlightElement, loc);
      
        //Display the highlight element
        var hasSize = loc.width !== 0 && loc.height !== 0;
        _highlightElement.style.display = hasSize ? "block" : "none";
    }

    /**
     * @public Hide highlight
     */
    _this.hide = function() {
        //hide the highlight element
        _highlightElement.style.display = "none";

        /* Remove window event tracking highlight if not being displayed for performance */
        _turnListenersOff();
    }

    /**
     * @public is the highlight being displayed
     */
    _this.isShowing = function() {
        // BUG-424590 this was throwing a console error when attmepting to get _highlightElement.style
        // when _highlightElement no longer existed
        if(_highlightElement) {
          return (_highlightElement.style.display == "block");  
        } else {
          return false;
        }        
    }

    /**
     * @public Destroy the object and nullify all properties
     */
    _this.destroy = function() {
        _turnListenersOff();
      
        //remove the element from the dom
        if (_highlightElement && _highlightElement.parentElement) {
            _highlightElement.parentElement.removeChild(_highlightElement)
        }

        //nullify properties
        _highlightElement = null;
        _infoBarElement = null;
        _decorationElement = null;
        _options = null;
    }
    
    /**
     * @public called to return the highlight element
     * @return the highlight element
     */
    _this.getElement = function() {
        return _highlightElement;
    }    

    /**
     * @public Set the content for an infobar appearing on the highlight
     *         created the infobar if one does not already exist in the DOM
     * @param content - content for the infobar, can be an element or a string
     */
    _this.setInfoBarContent = function(content) {
        if (!_infoBarElement) {
            _infoBarElement = document.createElement("div");
            _infoBarElement.classList.add(ClassNames.INFOBAR);
            _highlightElement.appendChild(_infoBarElement);                   
        }

        if (content.outerHTML) {
            _infoBarElement.innerHTML = "";
            _infoBarElement.appendChild(content);
        }
        else {
            _infoBarElement.innerHTML = content;
        }
    }  
};
//static-content-hash-trigger-GCC
pega.ui.roboticAutomationAction = pega.ui.roboticAutomationAction || (function() {

  var _public = {}
  var _priv = {}

  /* client action function to be registered with MessagingManager for client action based processing */
  _priv.clientAction = function(data,actionCallback){
    var request  = _priv.prepareRequest(data);
    successHandler = function(rdaResponse){
      _priv.successHandlerInner(rdaResponse,actionCallback);
    }
    errorHandler = function(rdaResponse){
      _priv.errorHandlerInner(rdaResponse,actionCallback);
    } 

    pega.ui.roboticAutomationApi.invokeAutomation("datapage",request,successHandler,errorHandler,"false","");
  };

  _priv.prepareRequest = function(data){
    var invocationRequest = {};

    if(data && data.response){
      var request = data.response;

      if(request.pxRDAAutomationId){
        invocationRequest.automationName = request.pxRDAAutomationId;
      }
      if(request.pxTimeout){
        invocationRequest.timeout = request.pxTimeout * 1000;
      }
      if(request.pxAutomationMetadata){
        if(request.pxAutomationMetadata.pyRDAURL){
          var automationBaseURL = request.pxAutomationMetadata.pyRDAURL;
          if (automationBaseURL.startsWith("http://") || automationBaseURL.startsWith("https://")) {
            invocationRequest.automationURL = automationBaseURL + "/api/v1/runtime";
          } else {
            invocationRequest.automationURL = "https://" + automationBaseURL + "/api/v1/runtime";
          }
        }
        if(request.pxAutomationMetadata.pyJWTString){
          invocationRequest.jwtString = request.pxAutomationMetadata.pyJWTString;
        }
      }
      if(request.pyRequestParameters){
        
        var originalPayload = request.pyRequestParameters;
        delete originalPayload.pxObjClass;
        invocationRequest.payload = JSON.stringify(originalPayload);
      }
    }
    return invocationRequest;
  };

  _public.registerClientAction = function() {
    // ensure MessagingManager framework is available
    if(pega.ui.MessagingManager){
      pega.ui.MessagingManager.registerClientAction("executeRDA", _priv.clientAction);  
    }
  }
  
  _public.unregisterClientAction = function() {
    // ensure MessagingManager framework is available
    if(pega.ui.MessagingManager){
      pega.ui.MessagingManager.unregisterClientAction("executeRDA");  
    }
  }

  _priv.successHandlerInner = function(response,callback){
    callback(response.ModifiedFields,null);
  };

  _priv.errorHandlerInner = function(response,callback){
    callback(null,response);
  };

  pega.u.d.attachOnload(function() {
    _public.registerClientAction();
  }, true);

  
  pega.u.d.attachOnUnload(function() {
    _public.unregisterClientAction();
  }, false);
  
  _public["testObject"] = _priv;
  return _public;
})();
//static-content-hash-trigger-GCC
pega.namespace("pega.ui.components");

/** 
 * This Tree class creates a JavaScript tree within the element given. It allows for custom node values and events
 * 
 * @param $Object$ element - The element where the tree will be displayed
 *                 configuration - the configuration of the inspector object for use and behavior
 *                 configuration.readyCallback - Callback for when the tree ready event is fired
 *                 configuration.selectCallback - Callback for when a node is selected
 *                 configuration.hoverCallback - Callback for when a node is hovered
 *                 configuration.dehoverCallback - Callback for when a a node is dehovered
 */
pega.ui.components.Tree = function(element, configuration) {
    var _self = this;

    // State enum that only handles enabled/disabled currently
    var STATE = {
        ENABLED: "enabled",
        DISABLED: "disabled"
    }
    
    // An element must be supplied for the tree to be placed into
    if (!element) {
        throw new Error("Element is a required parameter");
    }
  
    // If no configuration is given just default it to empty so people can not supply it
    if (!configuration) {
        configuration = {};
    }
  
    // Store off configuration data in private object for scoping

    var _config = {};
    var _element = element;
    _element.classList.add("tree-component");
    _config.readyCallback = configuration.readyCallback || function(){};
    _config.selectCallback = configuration.selectCallback || function(){};
    _config.hoverCallback = configuration.hoverCallback || function(){};
    _config.dehoverCallback = configuration.dehoverCallback || function(){};
    _config.wholeRowHighlight = configuration.wholeRowHighlight || false;
  
    if (configuration.icons == null) configuration.icons = true;
    _config.icons = configuration.icons;

    var _preventInternalEvent = false; // Flag to prevent the internal tree event handler from being fired we APIs are called
    var _jsTreeReference = null; // Internal reference to the jsTree object
    var _hoveredId = ""; // Previously hovered node ID
    var _state = STATE.ENABLED; // State of if the tree is enabled or not

    /**
     * @private Called to bind all internal event handlers for jsTree
     */
    function _bindEvents() {
        //Loaded event that fires after tree is loaded
        $(_element).on("ready.jstree", function(e, data) {
            // If the tree refreshes and is disabled then make sure to disable on ready
            if (_state == STATE.DISABLED) {
                _self.disable();
            }

            _config.readyCallback();
        });

        //On hover of tree node
        $(_element).on("hover_node.jstree", function(e, data) {
            if (_preventInternalEvent || _state == STATE.DISABLED) return false;

            var nodeId;
            if (data.node.original && data.node.original.lookup) {
                nodeId = data.node.original.lookup;
            } else {
                nodeId = data.node.id;
            }
            
            _config.hoverCallback(nodeId);
        });

        //on dehover of tree node
        $(_element).on("dehover_node.jstree", function(e, data) {
            if (_preventInternalEvent || _state == STATE.DISABLED) return false;

            _config.dehoverCallback();
        });

        //on select of tree node
        $(_element).on("select_node.jstree", function(e, data) {
            if (_state == STATE.DISABLED) return false;
          
            var nodeId;

            if (data.node.original && data.node.original.lookup) {
                nodeId = data.node.original.lookup;
            } else {
                nodeId = data.node.id;
            }

            var $tree = $(_element);
            var node = _element.querySelector("#" + nodeId);

            var nodeOffset = $(node).offset();

            var nodeWidth = $(node.querySelector("a.jstree-anchor.jstree-clicked")).outerWidth();
            nodeWidth += $(node.querySelector("i.jstree-icon.jstree-ocl")).outerWidth();
            nodeWidth += 18; // some extra padding from li

            // BUG-190071: set position of the tree to be relative to get accurate scroll top values
            var oldPosition = $tree.css("position");
            $tree.css({ "position": "relative" });

            var treeScrollTop = $tree.scrollTop();
            var nodeOffsetTop = node.offsetTop;

            //BUG-195863: subtracting 40 pixels to account for the scrollbar covering the bottom of the tree panel div
            var bScrollVert = (nodeOffsetTop < treeScrollTop || nodeOffsetTop > (treeScrollTop + $tree.height() - 40));

            // BUG-190071: reset the position of the tree since the scroll top has been calculated
            $tree.css({ "position": oldPosition });

            var iPanelOffset = $(window).width() - $tree.width();
            var nodeLeft = nodeOffset.left - iPanelOffset;
            var nodeRight = nodeLeft + nodeWidth;
            var bScrollHoriz = (nodeLeft < 0 || nodeRight > $tree.width());

            var scrollTopAmount = nodeOffsetTop - ($tree.height() / 3);

            // Try to scroll so that the node is indented one-third the width of the tree.
            // BUG-170224: added maximum comparison with 0 to prevent negative numbers needed for if-statement below.
            var scrollLeftAmount = Math.max(0, $tree.scrollLeft() + nodeLeft - $tree.width() / 3);

            var newRight = nodeRight + $tree.scrollLeft() - scrollLeftAmount;

            // BUG-170224: added if to make the tree scroll enough to show icons when possible.
            // Check if the node overlaps on the right-hand side.
            if (newRight > $tree.width()) {
                // If it does, then scrollLeftAmount needs to be bigger.
                scrollLeftAmount = scrollLeftAmount + (newRight - $tree.width());

                var newLeft = nodeLeft + $tree.scrollLeft() - scrollLeftAmount;

                // Check if the node overlaps on the left-hand side.
                if (newLeft < 0) {
                    // If it does, then scroll only to the lefthand side of the node.
                    scrollLeftAmount = $tree.scrollLeft() + nodeLeft;
                }
            }

            //Only scroll to an item that is not in view
            if (bScrollVert && bScrollHoriz) {
                $tree.animate({
                    scrollTop: (scrollTopAmount),
                    scrollLeft: (scrollLeftAmount)
                }, 1000);
            } else if (bScrollVert) {
                $tree.animate({
                    scrollTop: (scrollTopAmount)
                }, 1000);
            } else if (bScrollHoriz) {
                $tree.animate({
                    scrollLeft: (scrollLeftAmount + 30)
                }, 1000);
            }

            if (_preventInternalEvent) return false;

          	_config.selectCallback(nodeId);
        });
    }

    /**
     * @public This function is called with data to be loaded into the tree
     * 
     * @param {JSON} data - Tree node data 
     * TODO: We should find a better way to interface the Data object. 
     * Might be worth either a public createNode API or some other object.
     */ 
    this.populate = function(data) {
        // Destroy then rebuild the tree object
        this.destroy();
        $(_element).jstree({
            'core': {
                'multiple': false,
                'data': data,
                'themes': {
                    'icons': _config.icons
                }             
            },
           'plugins' : [_config.wholeRowHighlight ? 'wholerow' : ""]
        });

        // Hold onto the jsTree reference and bind the events
        _jsTreeReference = $.jstree.reference(_element);
        _bindEvents();
    }
    
    /**
     * @public Called to destroy the jsTree object
     */
    this.destroy = function() {
        $(_element).jstree("destroy");
    }

    /**
     * @public Called to select a node by id
     * 
     * @param {String} id - The id of the node to select
     * @param {Boolean} skipCallback - This parameter allows for skipping the event callback
     * that are supplied in the constructor as options, defaults to false so callbacks are fired
     */
    this.selectNode = function(id, skipCallback) {
        _preventInternalEvent = skipCallback;
        _jsTreeReference.deselect_all();
        _jsTreeReference.select_node(id)
        _preventInternalEvent = false;
    }

    /**
     * @public Called to hover a node by id and also handle dehovering the previously 
     * hovered node if there was one
     * 
     * @param {String} id - The id of the node to hover
     * @param {Boolean} skipCallback - This parameter allows for skipping the event callback
     * that are supplied in the constructor as options, defaults to false so callbacks are fired
     */
    this.hoverNode = function(id, skipCallback) {
        _preventInternalEvent = skipCallback;
        // If the node was not higlighted in the tree then we need to implicitly dehover the last node
        var isVisibleInTree = !(_jsTreeReference.hover_node(id) === false);
        if (isVisibleInTree && _hoveredId != "" && _hoveredId != id) {
            this.dehoverNode(_hoveredId, skipCallback);
        }
        _hoveredId = id;
        _preventInternalEvent = false;
    }

    /**
     * @public Called to dehover a node by id
     * 
     * @param {String} id - The id of the node to dehover
     * @param {Boolean} skipCallback - This parameter allows for skipping the event callback
     * that are supplied in the constructor as options, defaults to false so callbacks are fired
     */
    this.dehoverNode = function(id, skipCallback) {
        _preventInternalEvent = skipCallback;
        _jsTreeReference.dehover_node(id);
        _preventInternalEvent = false;
        _hoveredId = "";
    }

    /**
     * @public Called to dehover all currently hovered nodes (Currently only one) 
     * 
     * @param {Boolean} skipCallback - This parameter allows for skipping the event callback
     * that are supplied in the constructor as options, defaults to false so callbacks are fired
     */
    this.dehoverAll = function(skipCallback) {
        this.dehoverNode(_hoveredId, skipCallback);
    }
    
    /**
     * @public Called to get the element where the tree is loaded
     */
    this.getElement = function() {
        return _element;
    }

    /**
     * @public Called to enable the ui tree 
     */
    this.enable = function() {
        _element.classList.remove("tree-component-readonly"); 
        _state = STATE.ENABLED;
    }

    /**
     * @public Called to disable the ui tree
     * 
     * TODO: Might be worth adding logic to actually disable each node in tree
     */
    this.disable = function() {
        _element.classList.add("tree-component-readonly");  
        _state = STATE.DISABLED;
    }
}
//static-content-hash-trigger-YUI
var domUtils = {
	firstBaseRefElement: null,

	/**
	* @getOuterHeight
	* Returns the outerHeight (including margin) of HTML Element
	* @param el HTML Element
	* @param type Type of the height which should be considered. Defaults to offsetHeight.
	**/
	getOuterHeight: function(el, type) {
		var height = el.offsetHeight;
		if (type == "scroll") {
			height = el.scrollHeight;
		}

		var style = getComputedStyle(el);
https://lu-85-hyd.eng.pega.com/prweb/app/MySample_/FFCSmrL1S7ekVFPr6Iu7VI70NiBUZstW*/!TABTHREAD3?pzTransactionId=&pzFromFrame=&pzPrimaryPageName=RH_1&pyActivity=%40baseclass.doUIAction#
		height += parseInt(style.marginTop) + parseInt(style.marginBottom);
		return height;
	},

	isDisplayNone: function() {
		return $(this).css('display') != 'none';
	},

	getSectionByName: function(sectionName, usingPage, container) {
		if (typeof (usingPage) == "undefined") {
			var usingPage = "";
		}
		var ruleKeyArray = pega.util.Dom.getElementsById("RULE_KEY", container, "div");
		if (ruleKeyArray) {
			var arrLength = ruleKeyArray.length;
			var foundIndex = -1;
			for (var index = 0; index < arrLength; index++) {
				if (ruleKeyArray[index].getAttribute("node_type") == "MAIN_RULE") {
					if (ruleKeyArray[index].parentNode && (ruleKeyArray[index].parentNode.id == "RULE_KEY")) {
						if (ruleKeyArray[index].parentNode.getAttribute("node_name") == sectionName) {
							if (this.getRelativeBaseRef(ruleKeyArray[index]) == usingPage) {
								foundIndex = index;
								break;
							}
						}
					}
					if (ruleKeyArray[index].getAttribute("node_name") == sectionName) {
						if (this.getRelativeBaseRef(ruleKeyArray[index]) == usingPage) {
							foundIndex = index;
							break;
						}
						if (foundIndex == -1) {
							foundIndex = index;
						}
					}
				}
			}
			if (foundIndex > -1) {
				return ruleKeyArray[foundIndex];
			}
		}
		return null;
	},

	getSectionsByName: function(sectionsName, container) {
		var sectionArr = [];
		var ruleKeyArray = pega.util.Dom.getElementsById("RULE_KEY", container, "div");
		if (ruleKeyArray) {
			var arrLength = ruleKeyArray.length;
			for (var index = 0; index < arrLength; index++) {
				if (ruleKeyArray[index].getAttribute("node_type") == "MAIN_RULE") {
					if (ruleKeyArray[index].getAttribute("node_name") == sectionsName) {
						sectionArr.push(ruleKeyArray[index]);
					}
				}
			}
		}
		if (sectionArr.length > 0) {
			return sectionArr;
		} else {
			return null;
		}
	},

	/*
	@protected Find Parent Named
	This function will find the parent element by climbing up the DOM and search for the given name parentName
	@param $Object$srcElement - Source Element
	@param $String$parentName - name of the parent element to be returned
	@return $Object$
	 */
	findParentNamed: function(srcElement, parentName) {
		var parent = srcElement.parentNode;
		/* Skip when you go all the way till document or reach HARNESS_CONTENT */
		while (parent && !parent.getElementById && parent.id != "HARNESS_CONTENT" && parent.id != "PEGA_HARNESS" && !parent.getAttribute("data-mdc-recordid")) {
			if (parent.getAttribute("NAME") == parentName)
				return parent;
			parent = parent.parentNode;
		}
		return null;
	},

	/*
@protected Find Parent with attribute
This function will find the parent element by climbing up the DOM and search for the given name parentName
@param $Object$srcElement - Source Element
@param $String$attrName - name of the attribute to be checked
@return $Object$
 */
	findParentWithAtrribute: function(srcElement, attrName) {
		var parent = srcElement.parentNode;
		while (parent && !parent.getElementById) {
			if (parent.getAttribute(attrName))
				return parent;
			parent = parent.parentNode;
		}
		return null;
	},

	getRelativeBaseRef: function(element) {
		if (!element) {
			element = event.srcElement;
		}
		var baseRef = (element.BASE_REF) ? element.BASE_REF : "";
		if (baseRef == "") {
			var brElement = this.findParentNamed(element, "BASE_REF");
			baseRef = (brElement) ? brElement.getAttribute("BASE_REF") : "";
		}
		return (brElement && (baseRef == "")) ? this.getRelativeBaseRef(brElement) : baseRef;
	},

	getPanelDiv: function() {
		var gadgetDiv = window.frameElement.parentNode;
		var panelDiv = gadgetDiv.parentNode;
		while (panelDiv && panelDiv != window.parent.document.body) {
			var id = panelDiv.id;
			if (id == "PEGA_LU_C" || id == "PEGA_LU_B" || id == "PEGA_LU_L" || id == "PEGA_LU_T" || id == "PEGA_LU_R") {
				return panelDiv;

			}
			panelDiv = panelDiv.parentNode;
		}
	},

	getRowAndEntryHandle: function(elementInCell) {
		var rowEntryHandle = null;
		var row = null;
		if (elementInCell) {
			var temp_gridObj;
			if (typeof (Grids) != "undefined")
				temp_gridObj = Grids.getElementsGrid(elementInCell);
			if (temp_gridObj) {
				/* elementInCell is inside a Grid */
				var target = elementInCell;
				var container;
				if (pega.util.Dom.isAncestor(temp_gridObj.leftBodyUL, target))
					container = temp_gridObj.leftBodyUL;
				else if (pega.util.Dom.isAncestor(temp_gridObj.rightBodyTbl, target))
					container = temp_gridObj.rightBodyTbl;
				if (container) {
					var cell = temp_gridObj.findCell(null, container, elementInCell);
					/*HFix-38627 : incase of expand pane tree grid, there are 2 tr elements for every row*/
					var index;
					/*BUG-355184: Reverted the changes made for BUG-335528 */
					if (cell) {
						index = temp_gridObj.getRowIndex(cell);
					}
					if (index != -1) {
						rowEntryHandle = temp_gridObj.getEntryHandle(index);
						row = temp_gridObj.getRightRow(index);
					}
				}
			}
			/* elementInCell may or may not be inside a Grid. Check for Repeating Layouts now. */
			var repeatRow = pega.u.d.getRepeatRow(elementInCell, true);
			if (row && repeatRow) {
				if (pega.util.Dom.isAncestor(row, repeatRow)) {
					row = repeatRow;
				}
			} else if (repeatRow) {
				row = repeatRow;
			}
			if (row) {
				rowEntryHandle = (row.getAttribute("hPref") || row.id);
			}
		}
		return {
			"row": row,
			"rowEntryHandle": rowEntryHandle
		};
	},

	getEnclosingSection: function(object) {
		while ((object.id != "RULE_KEY")) {

			object = object.parentNode;
			if (object.getElementById) {
				/* If reload element is not found set the reloadFail to true to set form submit*/
				return null;
			} else if ((object.id == "RULE_KEY") && ((object.getAttribute("node_type") == "MAIN_RULE") || (object.getAttribute("node_type") != "SECTION")))
				break;

		}
		if (object.getAttribute("node_type") == "SECTION")
			return this.getIncludedSection(object);
		else
			return object;

	},

	getIncludedSection: function(object) {
		var ruleKeyArray = pega.util.Dom.getElementsById("RULE_KEY", object, "div");
		if (ruleKeyArray) {
			var length = ruleKeyArray.length;
			for (var index = 0; index < length; index++) {
				if (ruleKeyArray[index].getAttribute("node_type") == "MAIN_RULE")
					return ruleKeyArray[index];
			}

		} else
			return null;

	},

	/*
	@protected Get Base Reference
	This function is used to get the base reference in order to reload the streams
	@param $Object$element
	@return $Object$
	 */

	getBaseRef: function(element, event, gridObj) {
		var baseRef = "";
		if (!element)
			element = pega.util.Event.getTarget(event);
		/*After base ref div and section main div, the main div will contain the base reference information*/
		if (element.id == "RULE_KEY" && element.getAttribute("node_type") == "MAIN_RULE" && element.getAttribute("BASE_REF"))
			baseRefElement = element;
		else {
			var gridElem = null;
			if (gridObj) {
				gridElem = gridObj.gridDiv;
			}
			var baseRefElement = this.findParentNamed(element, "BASE_REF");
			if (gridElem && pega.util.Dom.isAncestor(baseRefElement, gridElem)) {
				if (element.getAttribute("sec_baseref")) element.setAttribute("sec_baseref", "");
				return "";
			}
		}

		var firstBaseRefElement = baseRefElement;
		//BUG-340645
		if (baseRefElement == null && pega.util.Event.isIE && element.tagName) {
			var queryElement = document.querySelectorAll(element.tagName.toLowerCase() + "[name='" + element.getAttribute('name') + "']");
			if (queryElement.length == 1) {
				element = queryElement[0];
				baseRefElement = this.findParentNamed(element, "BASE_REF");
			}
		}
		/*Added to check the BaseRef element in the palce where it is called */
		if (firstBaseRefElement && firstBaseRefElement.getAttribute("FULL_BASE_REF")) {
			var fullbaseRef = firstBaseRefElement.getAttribute("FULL_BASE_REF"),
				baseRefAttr = firstBaseRefElement.getAttribute("BASE_REF");

			// if baseRefAttr is empty string, return fullBaseRef
			if (baseRefAttr && baseRefAttr.length != 0 && fullbaseRef.indexOf(baseRefAttr, fullbaseRef.length - baseRefAttr.length) !== -1) {
				firstBaseRefElement = null;
				return fullbaseRef;
			}
		}
		while (baseRefElement != null) {
			baseRef = baseRefElement.getAttribute("BASE_REF") + baseRef;
			if (baseRefElement.getAttribute("BASE_REF") != "" && baseRefElement.getAttribute("BASE_REF").indexOf(".") != 0) { // if this is a top level page do not look for more
				break;
			} else {
				baseRefElement = this.findParentNamed(baseRefElement, "BASE_REF");
			}
		}
		if (baseRef.indexOf(".") == 0) {
			baseRef = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName') + baseRef;
		}
		// BUG-134243 bug fix
		if (firstBaseRefElement && firstBaseRefElement != null) {
			var curBaseRef = firstBaseRefElement.getAttribute("FULL_BASE_REF");
			if (curBaseRef !== baseRef)
				firstBaseRefElement.setAttribute("FULL_BASE_REF", baseRef);
			//    this.firstBaseRefElement.setAttribute("FULL_BASE_REF", baseRef);
		}
		firstBaseRefElement = null;
		return baseRef;
	},

	/* This function is used to get the full template path in order to reload the streams */
	getTemplatePath: function(reloadElement) {
		var tempPath = "";
		var attrName = "data-rel-path";
		if (!reloadElement) return "";

		/* In case of Post Value, we will get reload element as control object,
			initiating reloadElement with the corresponding cell object */
		var relativePath = reloadElement.getAttribute(attrName);
		if (relativePath == null || typeof (relativePath) == "undefined") {
			reloadElement = this.findParentWithAtrribute(reloadElement, attrName);
		}

		if (reloadElement != null) {
			var reloadElementObj = reloadElement;
			if (reloadElementObj && reloadElementObj.getAttribute("FULL_TEMPLATE_PATH")) {
				var tempPath = reloadElementObj.getAttribute("FULL_TEMPLATE_PATH");
			} else {
				while (reloadElementObj != null) {
					relativePath = reloadElementObj.getAttribute(attrName);
					if (relativePath != null && typeof (relativePath) != "undefined") {
						tempPath = relativePath + tempPath;
					} else {
						tempPath = "";
						break;
					}
					reloadElementObj = this.findParentWithAtrribute(reloadElementObj, attrName);
				}

				if (tempPath != "") {
					reloadElement.setAttribute("FULL_TEMPLATE_PATH", tempPath);
				}
			}
		}
		return tempPath;
	},

	/*
	@protected This is a Helper fuction for expandIt()
	This function returns the parent table of the given element
	@param $Object$childElement - the source element to find the parent table
	@return $Object$
	 */

	findParentTable: function(childElement) {
		return this.findParentWithTagName(childElement, "TABLE");
	},

	findParentAnchor: function(childElement) {
		return this.findParentWithTagName(childElement, "A");
	},

	/*
	@protected This function returns the parent div of the given element
	@param $Object$childElement - the source element to find the parent div
	@return $Object$
	 */

	findParentDiv: function(childElement) {
		return this.findParentWithTagName(childElement, "DIV");
	},

	findParentWithTagName: function(childElement, tagName) {
		var theParent = childElement.parentNode;
		while (theParent != null) {
			if (theParent.tagName == tagName)
				return (theParent);
			else
				theParent = theParent.parentNode;
		}

		return (theParent);
	},
	/*
	Calculates the BaseRef of a ctDiv and stores the same on the div after first calculation
	returns - 'nosection' if the ctDiv is empty, without section. Else, returns the Base Reference (which can be empty if the element is on the primary page) - Autobots
	 */
	calcAndAttachSectionBaseRef: function(ctDiv, rcw) {
		var sectionBaseRef = '';
		/* rcw flag is using to find the section outside(at parent level) ctDiv dom */
		var includedSection = null;
		if (rcw) {
			includedSection = pega.u.d.getSectionDiv(ctDiv);
		} else {
			includedSection = pega.u.d.getIncludedSection(ctDiv);
		}
		if (!includedSection)
			return {
				'sectionBaseRef': 'nosection'
			};
		//BEGIN: Calculate BaseRef of the section under condition evaluation.

		//Check if baseRef was already calculated and attached to CT DIV
		var ctDiv_baseRef = ctDiv.getAttribute("sec_baseRef");
		var isInGrid = false;
		if (!ctDiv_baseRef) {
			var gridObj = null;
			if (typeof (Grids) != 'undefined') {
				gridObj = Grids.getElementsGrid(ctDiv);
			}
			if (gridObj && pega.u.d.getBaseRef(ctDiv, null, gridObj) == "") {
				isInGrid = true;
			} else {
				sectionBaseRef = pega.u.d.getBaseRef(includedSection);
			}

			/* For auto reload cell bahavior, there is no active row in grids. Henace fetching row context */
			if (rcw) {
				if (sectionBaseRef == "") { //Element might be a repeat layout
					var rowEntryHandle = pega.u.d.getRowAndEntryHandle(ctDiv).rowEntryHandle;
					if (rowEntryHandle != null && typeof (rowEntryHandle) != 'undefined') {
						sectionBaseRef = pega.u.property.toReference(rowEntryHandle);
					}
				}
				if (!sectionBaseRef) {
					sectionBaseRef = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName');
				} else if (sectionBaseRef.charAt(0) == ".") {
					sectionBaseRef = SafeURL_createFromURL(pega.u.d.url).get('pzPrimaryPageName') + sectionBaseRef;
				}
			}

			//Attach baseRef to the section ct div
			if (!sectionBaseRef)
				ctDiv.setAttribute("sec_baseRef", "PEGA_NA");
			else
				ctDiv.setAttribute("sec_baseRef", sectionBaseRef);
			if (isInGrid)
				ctDiv.setAttribute("sec_baseRef", "");

		} else {
			if (ctDiv_baseRef == "PEGA_NA")
				sectionBaseRef = "";
			else
				sectionBaseRef = ctDiv_baseRef;
		}
		/*BUG-63803 autobots the baseRef4ConditionEval used for condition evaluation*/
		var sectionRelativeBaseRef = includedSection.getAttribute("BASE_REF");
		var baseRef4ConditionEval = sectionBaseRef
		/* BUG-119457 added condition !rcw as cascading doesn't configure with usingPage.property */
		if (sectionRelativeBaseRef && !rcw) {
			var myreg = new RegExp(sectionRelativeBaseRef + "$");
			baseRef4ConditionEval = sectionBaseRef.replace(myreg, "");
		}
		return {
			'includedSec': includedSection,
			'sectionBaseRef': sectionBaseRef,
			'baseRef4ConditionEval': baseRef4ConditionEval
		};
	},

	/*
	@protected This function returns the source index for FireFox
	@param $String$element - Element to get the source index
	 */

	getSourceIndex: function(element, reloadElement) {
		if (reloadElement == null) {
			reloadElement = document;
		}
		var allElements = reloadElement.getElementsByTagName('*');
		for (var i = 0; i < allElements.length; i++) {
			if (allElements[i] == element) {
				return i;
			}
		}
	},

	/*
	@Private - This function finds the parent Td of the element
	@param $Object$  childElement
	@return $object$
	 */

	findParentTD: function(childElement) {
		var theParent = childElement.parentNode;
		while (!theParent.getElementById) {
			if (theParent.tagName == "TD")
				return (theParent);
			else
				theParent = theParent.parentNode;
		}
		return null;
	},

	/*
	@Private - When we submit the form without entering the mandatory fields it shows the errors from error table
	@return $void$
	 */

	showErrors: function() {
		var tableElements = null;
		var errorMarkers = new Array();
		var errorTables = new Array();
		// find all error markers (id="PegaRULESErrorFlag"), and array them
		errorMarkers = pega.util.Dom.getElementsById("PegaRULESErrorFlag", document);
		var errorMarkersLength = 0;
		if (errorMarkers) {
			errorMarkersLength = errorMarkers.length;
			var shadeErrorRef = pega.u.d.shadeError;
			var expandItRef = pega.u.d.expandIt;
		}
		for (var i = 0; i < errorMarkersLength; i++) {
			var objCurrent = errorMarkers[i].parentNode;
			if (pega.u.d.fieldErrorType == "ERRORTEXT")
				shadeErrorRef(objCurrent);

			// show the parent element if it is hidden
			while (!objCurrent.getElementById) {
				if (objCurrent.style.display == "none") {
					//checking if the expand div is available which is collapsed as we need to expandit only when collapsed
					var expandDiv = pega.util.Dom.getElementsById("EXPAND-INNERDIV", objCurrent);
					if (expandDiv != null) {
						// if more than one, select the first one
						if (expandDiv.length != null)
							expandDiv = expandDiv[0];
						if (pega.util.Dom.getStyle(expandDiv, "display") == "none") {
							if (typeof expandItRef === "function") {
								expandItRef(objCurrent);
							}
						}
					}

				}
				// Get the parent of current element and make it the new current element
				objCurrent = objCurrent.parentNode;
			}
		}
		//When accessible, skip this function
		if (typeof (h_displayErrorTable) == "function") {
			return;
		}

		if (pega.u.d.formErrorType != "NONE") {
			// If there *are* errorMarkers on the page, do not show the error boxes.
			// If there are *no* errorMarkers, show the boxes only if they have content.
			if (pega.u.d.alwaysShowFormLevelErrors != "true" && errorMarkersLength > 0) {
				pega.u.d.hideErrorBox();
			} else {
				// If the elements in the error tables have content
				// (innerHTML != ""), make the error tables visible.
				try {
					var errMsgAll = pega.ctx.dom.getElementById("ERRORMESSAGES_ALL");
					if (errMsgAll != null)
						pega.u.d.displayFormErrors(errMsgAll.innerHTML);
				} catch (e) {}

			}
			if (typeof markTabErrors === 'function') {
				pega.u.d.markTabErrors();
			}
		}
	},

	hideErrorBox: function() {
		var errorTables = pega.util.Dom.getElementsById("ERRORTABLE", document);
		var errorTablesLength = 0;
		if (errorTables)
			errorTablesLength = errorTables.length;
		// make sure error tables are not visible
		if (errorTablesLength > 0) {
			for (var t = 0; t < errorTablesLength; t++) {
				pega.util.Dom.setStyle(errorTables[t], "display", "none");
			}
		}
		if (pega.u.d.formErrorType == "FLOAT") {
			var errorTableSpacers = pega.util.Dom.getElementsById("ErrorTableSpacer", document),
				errorTableSpacersLength = 0;
			if (errorTableSpacers)
				errorTableSpacersLength = errorTableSpacers.length;
			if (errorTableSpacersLength > 0) {
				for (var t = 0; t < errorTableSpacersLength; t++) {
					pega.util.Dom.setStyle(errorTableSpacers[t], "display", "none");
				}
			}

		}
	},

	/*
	@protected This function is used to display the full error text and  to shade the fields
	@return $void$
	 */
	shadeError: function(objCurrent) {
		var relInput = null;
		var relInputId = objCurrent.id.substring(0, objCurrent.id.lastIndexOf("Error"));
		var addClassRef = pega.u.d.addClass;
		var getElementsByNameRef = pega.util.Dom.getElementsByName;
		while (!objCurrent.getElementById) {
			objCurrent = objCurrent.parentNode;
			relInput = getElementsByNameRef(relInputId, objCurrent);
			if (relInput) {
				var relInputLength = relInput.length;
				for (var errInp = 0; errInp < relInputLength; errInp++) {
					if (relInput[errInp].type != "hidden") {
						// porting of hfix-6852 - special case for the textarea control
						var firstChildElem = pega.util.Dom.getFirstChild(relInput[errInp].parentNode);
						var parentElemNode = relInput[errInp].parentNode.nodeName.toLowerCase();
						if ((parentElemNode == "span" || parentElemNode == "td") &&
							(firstChildElem.className.indexOf("textAreaStyle") > -1 || firstChildElem.className.indexOf("TextAreaEC") > -1)) {
							/* case to handle the old textarea expanded control */
							if (parentElemNode != "td") {
								addClassRef(relInput[errInp].parentNode, "errorShade");
							} else {
								addClassRef(pega.util.Dom.getAncestorByTagName(relInput[errInp], "TABLE"), "errorShade");
							}
						} else {
							addClassRef(relInput[errInp], "errorShade");
						}
					}
				}
				break;
			}
		}
	},

	addClass: function(el, classname) {
		pega.util.Dom.addClass(el, classname);
	},

	removeClass: function(el, classname) {
		pega.util.Dom.removeClass(el, classname);
	},


	/*
	@public Do button Action
	@param $String$name
	@param $String$action - Action Name to be performed
	@return $void$
	 */
	doButtonAction: function(name, action) {
		for (var count = 0; count < document.getElementsByTagName("Button").length; count++) {
			if (document.getElementsByTagName("Button")[count].className == "iconClose") {
				if (action == "hide")
					document.getElementsByTagName("Button")[count].style.display = "none";
				else if (action == "show")
					document.getElementsByTagName("Button")[count].style.display = "block";
			}
		}
	},

	/*
	@Handler
	@protected This function swap CSS class names for an icon/button when it fires mouseover event.
	Requires that 'buttonClass' attribute has a valid value, and that classes have been named [name] and [name_on] for mouseout and mouseover, respectively.
	@return $void$
	 */
	doButtonMouseOver: function(event) {
		event = (event == undefined) ? window.event : event;
		var el = pega.util.Event.getTarget(event);
		try {
			el.className = el.className += "_on";
		} catch (exception) {}
	},

	/*
	@Handler
	@protected This function swap CSS class names for an icon/button when it fires mouseout event.
	@return $void$
	 */
	doButtonMouseOut: function(event) {
		event = (event == undefined) ? window.event : event;
		var el = pega.util.Event.getTarget(event);
		try {
			el.className = el.buttonClass;
		} catch (exception) {}
	},

	/*
	@protected Find Parent Named
	This function will find the parent element by climbing up the DOM and search for the 	given name parentName
	@param $Object$srcElement - Source Element
	@param $String$parentName - name of the parent element to be returned
	@return $Object$
	 */

	findParent: function(srcElement, parentid) {
		var parent = srcElement.parentNode;
		while (parent != null) {
			if (parent.id == parentid)
				return parent;
			parent = parent.parentNode;
		}
		return null;
	},

	/*
	@Private - Moves the styles from parent frame document to current document(workobject)
	@return $void$
	 */

	moveStyles: function() {
		try {
			var theDoc = parent.frames.document;
			var linkList = theDoc.getElementsByTagName("LINK");
			var headList = document.getElementsByTagName("HEAD");
			var theHead = headList.item(0);
			for (var el = 0; el < linkList.length; el++) {
				var strRef = linkList.item(el).href;
				var currentLinkList = document.getElementsByTagName("LINK");
				var currentCount = currentLinkList.length;
				var bFound = false;
				for (var curEl = 0; curEl < currentCount; curEl++) {
					if (currentLinkList.item(curEl).href == strRef) {
						bFound = true;
					}
				}

				// only move if doesn't exist
				if (!bFound) {
					// document.createStyleSheet doesn't work here

					// create a link element and add the style sheet
					var styleSheet = document.createElement("LINK");
					styleSheet.rel = "Stylesheet";
					styleSheet.type = "text/css";
					styleSheet.href = strRef;
					theHead.appendChild(styleSheet);
				}
			}
		} catch (e) {}
	},

	/*
	Searches for input and gives the id for input in the modaldialog
	@return $Object$
	 */

	getFirstInputElement: function(elementID, container) {
		if (container == undefined && (elementID == undefined || elementID == 'pyActionArea')) {
			var firstForm = document.forms[0];
			var allElements = [];
			if (!firstForm) {
				/*BUG-412118: considering all actionable elements from the harness if there are no forms*/
				var iframeBody = document.getElementsByTagName("BODY")[0];
				if (iframeBody.hasAttribute("data-harness-id")) {
					var harness = iframeBody.getElementsByClassName("screen-layout")[0];
					if (harness) {
						var mainDiv = harness.getElementsByTagName("main")[0];
						if (mainDiv)
							allElements = mainDiv.getElementsByTagName("*");
					}
				}
			}
			else {
				allElements = firstForm.getElementsByTagName("*");
			}
			/*BUG-174420(HFIX PORT): HFIX-10176: Changed to getElementsByTagName from firstForm.elements as elements attribute does not include Anchor tags*/

			var totalCount = allElements.length;
			for (var i = 0; i < totalCount; i++) {
				var firstEle = allElements[i];
				/*BUG-196529: Added condition to return the first div element (with tabindex attribute 0) when accessibility is enabled*/
				if ((firstEle != null && firstEle.type != "hidden" && firstEle.style && firstEle.style.display != "none" && firstEle.offsetHeight > 0 && firstEle.disabled != true && (firstEle.readOnly != true || firstEle.hasAttribute("data-editable"))) && (firstEle.nodeName == "INPUT" || firstEle.nodeName == "SELECT" || firstEle.nodeName == "TEXTAREA" || (firstEle.nodeName == "A" && firstEle.getAttribute("data-focusable") !== "false" ) || (pega.u && pega.u.d && pega.u.d.isAccessible && firstEle.nodeName == "DIV" && firstEle.getAttribute("tabindex") == "0")))
					if (firstEle.id != 'ActionOptions')
						return firstEle;
			}
		} else {
			elementID = (elementID == undefined) ? 'PEGA_HARNESS' : elementID;
			container = (container == undefined) ? document : container;
			var elemArray = pega.util.Dom.getElementsById(elementID, container);
			var obj = null;
			if (elemArray) {
				var elem = elemArray[0];
				if (elem) {
					obj = this.parseChildNodes(elem);
				}
			}
			if (obj == null)
				return;
			return obj;
		}

	},

	/*
	Searches for input, select and radio in modaldialog
	@return $object$
	 */

	parseChildNodes: function(obj) {
		if (obj.hasChildNodes()) {
			var collection = obj.getElementsByTagName('*');
			for (var i = 0; i < collection.length; i++) {
				var obj = collection[i];

				if (obj != null && (obj.nodeName == "INPUT" || obj.nodeName == "SELECT" || obj.nodeName == "TEXTAREA") && (obj.type != "hidden" && obj.style.display != "none"))
					return obj;
			}
		} else {
			//no children, check if nodeName is input
			if (obj.nodeName == "INPUT") {
				if (obj.type != null && obj.type == "radio" && obj.checked)
					return obj;
				else if (obj.type != null && obj.type != "radio")
					return obj;
			}
		}
	},

	getScrollObj: function(obj) {
		var obj = obj.parentNode;
		var currWindow = window;
		var top = 0;
		while (obj) {
			/*if the current object has scrollbar*/
			var overflow = '';
			overflow = window.getComputedStyle ? (window.getComputedStyle(obj, null)["overflow"] || obj.style.overflow)
				: (obj.currentStyle ? obj.currentStyle["overflow"] : obj.style.overflow || 0);

			if (obj.offsetHeight < obj.scrollHeight && overflow != 'hidden' && overflow != 'visible')
				return [obj, currWindow, top];

			obj = obj.parentNode;
			overflow = window.getComputedStyle ? (window.getComputedStyle(obj, null)["overflow"] || obj.style.overflow)
				: (obj.currentStyle ? obj.currentStyle["overflow"] : obj.style.overflow || 0);

			if (obj == currWindow.document.body) {
				try {
					if (currWindow.frameElement) {
						overflow = window.getComputedStyle ? (window.getComputedStyle(currWindow.frameElement, null)["overflow"] || currWindow.frameElement.style.overflow)
							: (currWindow.frameElement.currentStyle ? currWindow.frameElement.currentStyle["overflow"] : currWindow.frameElement.style.overflow || 0);
					}
					if (obj.offsetHeight < obj.scrollHeight && overflow != 'hidden' && overflow != 'visible') {
						/*if this frame has the scrollbar*/
						return [obj, currWindow, top];
					} else if (!currWindow.frameElement) {
						/*if this is the outermost window/frame then return;*/
						return null;
					} else {
						obj = currWindow.frameElement;
						top += getAbsoluteTop(obj);
						currWindow = currWindow.parent;
					}
				} catch (e) {
					return [currWindow.document.body, currWindow, top];
				}
			}
		}
	},

	/* @api
	Get all the input element from the harness input/select/textarea
	@return $Object$
	 */
	getInputElements: function() {
		var inputElements = new Array();
		var inputTypes = new Array("input", "select", "textarea");
		for (var i = 0; i < inputTypes.length; i++) {
			var inputElementArray = document.getElementsByTagName(inputTypes[i]);
			for (var j = 0; j < inputElementArray.length; j++) {
				if (inputElementArray[j].type != 'hidden') {
					inputElements.push(inputElementArray[j]);
				}
			}
		}
		return inputElements;
	},

	/* @api
	Get all the button/url elements from the harness
	@return $Object$
	 */

	getOtherElements: function() {
		var inputElements = new Array();
		var elementTypes = new Array("button", "a");
		for (var i = 0; i < elementTypes.length; i++) {
			var inputElementArray = document.getElementsByTagName(elementTypes[i]);
			for (var j = 0; j < inputElementArray.length; j++) {
				inputElements.push(inputElementArray[j]);
			}
		}
		return inputElements;
	},

	/* @api
	Get all the harness elements (inputs/buttons/urls/complex elements)
	@return $Object$
	 */

	getHarnessElements: function(bInput, bOther, bComplex, sectionIds) {
		var allHarnessElements = new Array();
		if (bInput)
			allHarnessElements = allHarnessElements.concat(this.getInputElements());
		if (bOther)
			allHarnessElements = allHarnessElements.concat(this.getOtherElements());
		if (bComplex) {
			if (sectionIds && sectionIds.length) {
				var harnessElement = this.harnessElements.filter(function(harElement) {
					return sectionIds.indexOf(harElement.sectionID) != -1;
				});
				allHarnessElements = allHarnessElements.concat(harnessElement);
			}
			else {
				allHarnessElements = allHarnessElements.concat(this.harnessElements);
			}
		}
		return allHarnessElements;
	},

	/* @Handler
	Gets the tag  object and returns the firstChild which is not empty.
	@param - tag object.
	@return firstChild Object.
	 */
	getFirstChildObj: function(tagObject) {
		var firstChildDiv = tagObject.firstChild;
		//if(!pega.util.Event.isIE){
		while (firstChildDiv != null) {
			if (firstChildDiv.nodeType == 3 || (firstChildDiv.tagName.toLowerCase() == "input" && firstChildDiv.type == "hidden")) {
				firstChildDiv = firstChildDiv.nextSibling;
			} else {
				break;
			}
		}
		//}
		return firstChildDiv;
	},
  
  
  formatNumberAsPerLocale : function(val){
    if(!val)
       return val;
    if(val == "")
       return val;
    var localeDecmicalSep = window.decimal_separator;
    var locale = pega.u.d.Locale.replace("_", "-");
    if(localeDecmicalSep!=="."){
      var decimalPos = val.indexOf(".");
      var numTobeForamatted="";
      var generalDecSep = ".";
      if(decimalPos >=0 ){
        var numericPart = val.substring(0, decimalPos);
        var decimalPart = val.substring(decimalPos+1);
        numericPart = numericPart.replace(/\D/g, "");
        decimalPart = decimalPart.replace(/\D/g, "");
        numTobeForamatted = numericPart+localeDecmicalSep+decimalPart;
      } else {
        numTobeForamatted = val.replace(/\D/g, "");
      }
      //return new Intl.NumberFormat(locale).format(numTobeForamatted);
      return numTobeForamatted;
    }
    return val;
  },
  
  formatNumberWithSeparators : function(value) {
  if(!value)
       return value;
    if(value == "")
       return value;
     var localeDecimalSeparator = window.decimal_separator;
     var localeNumericSep = window.numeric_separator;
     var localeDecimalIndex = value.indexOf(localeDecimalSeparator);
     var formattedValue = "";
     var isnegative = false;
     if (value.indexOf("-") >= 0) {
        isnegative = true;
      }
     if (localeDecimalIndex != -1) {
       var integerPart = value.slice(0, localeDecimalIndex);
       var decimalPart = value.slice(localeDecimalIndex + 1);
       integerPart = integerPart.replace(/\D/g, "");
       integerPart = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, localeNumericSep);
       decimalPart = decimalPart.replace(/\D/g, "");
       formattedValue = integerPart + localeDecimalSeparator + decimalPart;
     } else {
       value = value.replace(/\D/g, "");
       formattedValue = value.replace(/\B(?=(\d{3})+(?!\d))/g, localeNumericSep);
     }
    if(isnegative){
      formattedValue = "-"+formattedValue;
    }
    return formattedValue;
  },
  
  formatNumberWithOutSeparators : function(value) {
  if(!value)
       return value;
    if(value == "")
       return value;
     var localeDecimalSeparator = window.decimal_separator;
     var localeDecimalIndex = value.indexOf(localeDecimalSeparator);
     var formattedValue = "";
     var isnegative = false;
     if (value.indexOf("-") >= 0) {
        isnegative = true;
      }
     if (localeDecimalIndex != -1) {
       var integerPart = value.slice(0, localeDecimalIndex);
       var decimalPart = value.slice(localeDecimalIndex + 1);
       integerPart = integerPart.replace(/\D/g, "");
       decimalPart = decimalPart.replace(/\D/g, "");
       formattedValue = integerPart + localeDecimalSeparator + decimalPart;
     } else {
       value = value.replace(/\D/g, "");
       formattedValue = value;
     }
    if(isnegative){
      formattedValue = "-"+formattedValue;
    }
    return formattedValue;
  },
  
	/* @api
	Set the property value
	@param $String$propertyName - Property name
	@param $String$newValue - Property value
	@return $void$
	 */

	setProperty: function(propertyName, newValue, pageName, customTimezone) {
		var propertyEntryHandle = null;
		if (pageName) {
			propertyEntryHandle = pega.u.property.toHandle(propertyName, pageName);
		} else {
			propertyEntryHandle = pega.u.property.toHandle(propertyName);
		}
		var elements = pega.ctx.dom.getElementsByName(propertyEntryHandle);
		try {
			if (!elements && navigator.userAgent.toLowerCase().indexOf("outlook") != -1) {
				elements = document.getElementsByName(propertyEntryHandle);
			}
		} catch (e) {}
    
    var isduplAcNumProp = false;
    if(elements.length > 1){
      for(var ind = 0; ind < elements.length; ind++ ){
        if(elements[ind].getAttribute("data-ac-numeric-prop") && elements[ind].getAttribute("data-ac-numeric-prop") === "true" ){
          isduplAcNumProp = true;
          break;
        }
      }
    }
    if(isduplAcNumProp){
      for(var ind = 0; ind < elements.length; ind++ ){
        if(!elements[ind].getAttribute("data-ac-numeric-prop")){
          elements[ind].setAttribute("data-ac-numeric-prop", true);
        }
      }
    }
		var radioButtonElement;
		if (elements) {
			for (var i = 0; i < elements.length; i++) {
				if (elements[i].type == "complex") {
					if (elements[i].element.setProperty)
						elements[i].element.setProperty(propertyName, newValue);
					else
						elements[i].value = newValue;
					if (!pega.util.Event.isSafari) {
						pega.util.Event.fireEvent(elements[i], "onmousedown");
					} else {
						//specific to safari if you do not prevent default dropdowns open and will stop execution of code until a user clicks outside the dropdown
						var Event = document.createEvent("MouseEvents");
						Event.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
						Event.preventDefault();
						elements[i].dispatchEvent(Event);
					}
					pega.u.d.fromSetValue = true;
					if (pega.env.ua.ie) {
						pega.util.Event.fireEvent(elements[i], "onfocusin");
					} else {
						pega.util.Event.fireEvent(elements[i], "onfocus");
					}
					pega.control.actionSequencer.fireTopPriorityEvent(elements[i], "change");
					pega.util.Event.fireEvent(elements[i], "onblur");
					if (pega.env.ua.ie) {
						pega.util.Event.fireEvent(elements[i], "onfocusout");
					}
					pega.u.d.fromSetValue = false;
				} else {
					var eleType = elements[i].type;

					/*BUG-281094:if element is hidden input of checkbox ignoring the element*/
					if ($(elements[i]).siblings(".checkbox") && $(elements[i]).siblings("input[type='checkbox']").get(0) && $(elements[i]).siblings("input[type='checkbox']").get(0).getAttribute("name") == elements[i].getAttribute("name")) {
						continue;
					}
					if (eleType == "checkbox") {
						var oldValue = elements[i].checked;

						if ((oldValue && (newValue == false || newValue == 'false')) ||
							(!oldValue && (newValue == true || newValue == 'true'))) {
							pega.control.actionSequencer.fireTopPriorityEvent(elements[i], "click");
						}
						//pega.util.Event.fireEvent(elements[i], "onclick");

					} else if (eleType == "textarea" && elements[i].id.startsWith("PEGACKEDITOR")) {
						var ed = CKEDITOR.instances[elements[i].id];
						ed.setData(newValue);
						pega.control.actionSequencer.fireTopPriorityEvent(elements[i], "change");
					} else {
						if (eleType == "radio") {
							if (newValue == elements[i].value) {
								elements[i].checked = true;
								radioButtonElement = elements[i];
							} else {
								elements[i].checked = false;
							}
						} else {
							var bReadonlyFormatting = elements[i].getAttribute && elements[i].getAttribute('data-formatting') && document.activeElement != elements[i];
							if (bReadonlyFormatting) {
								if (elements[i].getAttribute('data-format-method') || elements[i].getAttribute("data-template") == "") {
									elements[i].setAttribute('data-formatting', 'yes');
									elements[i].setAttribute("data-display-value", elements[i].value);
								}
								else {
									elements[i].setAttribute('data-value', newValue);
								}
							}
							if (customTimezone) { // set value bug fix : on date time control 
								newValue = pega.u.d.CalendarUtil.convertDateTimeBtwnTimezones(newValue, customTimezone, elements[i].getAttribute("data-custom-timezone") || pega.u.d.TimeZone);
							}
              if(elements[i].getAttribute("data-ac-numeric-prop") === "true" ){
                pega.control.PlaceHolder.setValue(elements[i], this.formatNumberAsPerLocale(newValue));
              } else {
                pega.control.PlaceHolder.setValue(elements[i], newValue);
              }
							
							if (customTimezone && elements[i].type == "hidden") { // Because we use data-value in buildDate() to pick the user selected value.
								elements[i].setAttribute("data-value", newValue);
							}

							if (!pega.util.Event.isSafari) {
								pega.util.Event.fireEvent(elements[i], "onmousedown");
							} else {
								//specific to safari if you do not prevent default dropdowns open and will stop execution of code until a user clicks outside the dropdown
								var Event = document.createEvent("MouseEvents");
								Event.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
								Event.preventDefault();
								elements[i].dispatchEvent(Event);
							}
						}
						pega.u.d.fromSetValue = true;
						if (!radioButtonElement || (radioButtonElement && elements[i].checked)) {
							if (document.activeElement != elements[i]) {
								if (bReadonlyFormatting) {
									pega.util.Event.fireEvent(elements[i], "onfocus");
								} else if (pega.env.ua.ie) {
									pega.util.Event.fireEvent(elements[i], "onfocusin");
								}
							}
							if (eleType !== "radio" || radioButtonElement) {
								pega.control.actionSequencer.fireTopPriorityEvent(elements[i], "change");
							}
							if (document.activeElement != elements[i]) {
								if (bReadonlyFormatting) {
									pega.util.Event.fireEvent(elements[i], "onblur");
								} else if (pega.env.ua.ie) {
									pega.util.Event.fireEvent(elements[i], "onfocusout");
								}
							}
							pega.u.d.fromSetValue = false;
						}
					}
				}
			}
			/*if (radioButtonElement) {
				pega.control.actionSequencer.fireTopPriorityEvent(radioButtonElement, "click");
			} */
		}
	},

	/* @api
	Get the property value
	@param $String$propertyName - Property name
	@return $String$
	 */

	getProperty: function(propertyName, pageName) {
		var propertyEntryHandle = null;
		if (pageName) {
			propertyEntryHandle = pega.u.property.toHandle(propertyName, pageName);
		} else {
			propertyEntryHandle = pega.u.property.toHandle(propertyName);
		}
		/*BUG-436440 : updated pega.util.Dom.getElementsByName to pega.ctx.dom.getElementsByName as existing one was failing in MDC case*/
		var elements = pega.ctx.dom.getElementsByName(propertyEntryHandle);
		if (elements) {
			for (var i = 0; i < elements.length; i++) {
				if (elements[i].type == "complex") {
					if (elements[i].element.getProperty)
						elements[i].element.getProperty(propertyName);
					else
						return elements[i].value;
				} else {
					if (elements[i].type && elements[i].type.toUpperCase() == "TEXTAREA" && elements[i].id && elements[i].id.indexOf("PEGAEDITOR") != -1) {
						var complexElements = pega.u.d.getHarnessElements(false, false, true);
						var len = complexElements.length;
						for (var k = 0; k < len; k++) {
							var complexObject = complexElements[k];
							var ele = complexObject.element;
							if (ele && typeof ele.isRichTextEditor != undefined && ele.isRichTextEditor == true && ele.myEditor != undefined) {
								if (ele.myEditor.get('element').name == propertyEntryHandle) {
									return ele.myEditor.getEditorHTML();
								}
							}
						}
					}
					if (elements[i].name && elements[i].name == propertyEntryHandle && elements[i].type && elements[i].type.toUpperCase() == "TEXTAREA" && elements[i].id && elements[i].id.indexOf("PEGACKEDITOR") != -1) {
						if (CKEDITOR && CKEDITOR.instances[elements[i].id] && CKEDITOR.instances[elements[i].id].getData) {
							return CKEDITOR.instances[elements[i].id].getData();
						}
					}
					for (var j = 0; j < elements.length; j++) {
						var eleType = elements[j].type;
						if (eleType == "checkbox") {
							if (elements[j].checked)
								return true;
							else
								return false;
						} else if (eleType == "radio") {
							if (elements[j].checked)
								return elements[j].value;
						}
					}
					if (elements[i].type === "radio") {
						return "";
					}
					return pega.control.PlaceHolder.getValue(elements[i]);
				}
			}
		}
	},

	getDOMElementValue: function(DOMElement) {
		var elementValue = "";
		if (DOMElement.type == "checkbox") {
			elementValue = DOMElement.checked;
		} else if (DOMElement.type == "radio") {
			var inputElt = document.getElementsByName(DOMElement.name);
			/* BUG-508963 if document is referring to outer html document instead of inner iframe document, issues occur.
			   So, in that case getting the elements By Name from DOMElement.ownerDocument */
			if (inputElt && inputElt.length === 0) {
				inputElt = DOMElement.ownerDocument.getElementsByName(DOMElement.name);
			}
			for (var i = 0; i < inputElt.length; i++) {
				if (inputElt[i].checked) {
					elementValue = inputElt[i].value;
					break;
				}
			}
		}
		/*Fliped the order of value extraction for Dynamic Select - BUG-76105*/
		else if (DOMElement.tagName.toLowerCase() == "select") {
			if (DOMElement.length > 0 && DOMElement.selectedIndex != -1) {
				var elemSelected = DOMElement.options[DOMElement.selectedIndex];
				var elemValue = pega.util.Dom.getInnerText(elemSelected);
				var selValueObj = DOMElement.options[DOMElement.selectedIndex].getAttributeNode("value");
				if (selValueObj != null && selValueObj.specified)
					elemValue = elemSelected.value;
				elementValue = elemValue;
			}
			if (!elementValue && DOMElement.getAttribute("DSSource")) {

				if (!(DOMElement.selectedIndex == 0 && DOMElement.options.length > 1))
					/* BUG-76635 */
					elementValue = DOMElement.getAttribute("DSDefault");
			}
		} else {
			elementValue = pega.control.PlaceHolder.getValue(DOMElement);
		}
		return elementValue;
	},
	/*
	@api getContainerSectionElement fetch Section UniqueId from given element id which can be used for refresh section
	@param $elementId id of the element for which u want to get section id
	 */
	getContainerSectionElement: function(elementId) {
		if (elementId == null || elementId == undefined) {
			return null;
		} else {
			var elementDiv = document.getElementById(elementId);
			return pega.u.d.getSectionId(pega.u.d.getSectionDiv(elementDiv));
		}
	},

	/*
	 * returns true if current harness has panel set instead of containers;
	 * panels are implemented using YUI layout component;
	 */

	isPanelSetHarness: function() {
		return (this.harnessType && this.harnessType == "layout");
	},
	getSectionIds: function(reloadElement) {
		if (!reloadElement)
			return new Array();
		if (reloadElement.length > 0)
			reloadElement = reloadElement[0];
		var mainNodes = pega.util.Dom.getElementsByAttribute("node_type", "MAIN_RULE", "DIV", reloadElement);
		var len = mainNodes.length;
		var sectionIds = new Array();
		sectionIds.push(reloadElement.getAttribute("uniqueID"));
		for (var i = 0; i < len; i++) {
			var node = mainNodes[i];
			var uniqueId = mainNodes[i].getAttribute("uniqueID");
			if (node && node.id == "RULE_KEY" && uniqueId && uniqueId != "") {
				sectionIds.push(uniqueId);

			}
		}
		return sectionIds;

	},

	/*
	@protected Create a new window with a new DIV
	Since a Harness cannot be properly printed due to its scrollable DIV, it's content has to be put into another window to be printed.
	This function opens a new window containing the contents of the HARNESS_CONTENT div, enables it to be printed.
	@param $String$ strDiv - The ID of the enclosed DIV tag of the harness to be printed (HARNESS_CONTENT)
	@return $void$
	 */
	doPrintDiv: function(strDiv) {
		var strDivContent = null;
		var linksList = null;
		var scriptsList = null;
		var hiddenInputList = "";

		var tempScriptTagsArray = new Array();
		var tempLinkArray = new Array();
		var hiddenInputArray = new Array();

		var scriptString;
		var scriptTagsString;
		var linkString;
		var hiddenInputString;

		var startIndex;
		var stopIndex;
		var functionIndex;

		if (strDiv == null) {
			return;
		} else {
			try {

				strDivContent = document.getElementById(strDiv).innerHTML;
				linksList = document.getElementsByTagName("LINK");
				scriptsList = document.getElementsByTagName("SCRIPT");
				hiddenInputList = document.getElementsByTagName("INPUT");
			} catch (e) {
				var valueHash = new Array();
				valueHash["$(strDiv)"] = strDiv;
				alert(getLocalString("pyMessageLabel", "Function doPrintDiv($(strDiv)) Error Element $(strDiv) does not exist.", valueHash));
				return;
			}
		}

		var win = window.open('', 'thePrintWindow', 'toolbar=no,scrollbars=yes');
		var d = win.document;

		var finalHtml = '';
		d.write('<html><head>');

		for (i = 0; i < hiddenInputList.length; i++) {
			if ((hiddenInputList[i].type == "hidden") && (hiddenInputList[i].id != "EXPAND-INDICATOR")) {
				hiddenInputArray.push(hiddenInputList[i].outerHTML);
				hiddenInputString = hiddenInputArray.join(' ');
			}
		}

		d.write(hiddenInputString);

		for (var i = 0; i < linksList.length; i++) {
			tempLinkArray.push("<link href='" + linksList[i].href + "' rel='stylesheet' type='text/css'>");
			linkString = tempLinkArray.join(' ');

		}

		var len = scriptsList.length;
		for (var j = 0; j < len; j++) {
			if (scriptsList[j].src != "") {
				var head = d.getElementsByTagName("head")[0];
				var script = d.createElement('script');
				script.type = 'text/javascript';
				script.src = scriptsList[j].src;
				head.appendChild(script);
			} else {
				var head = d.getElementsByTagName("head")[0];
				var script = d.createElement('script');
				script.type = 'text/javascript';
				script.text = scriptsList[j].innerHTML;
				head.appendChild(script);
			}
		}
		d.write("<SCRIPT>var gClosePrintWindow=true; var printView=true;<\/SCRIPT>");
		d.write(linkString);
		d.write('</head>');
		finalHtml += '<body class="forPrinting" onafterprint="window.opener" onload="">';
		finalHtml += '<div style="position:absolute; width:100%; height:100%">';
		finalHtml += strDivContent;
		finalHtml += '</div>';
		finalHtml += '<div style="position:absolute; width:100%; height:100%; z-index:1000">';
		finalHtml += '</div>';
		finalHtml += '<script>';
		finalHtml += 'var arrBodyElements = document.getElementsByTagName("body");';
		finalHtml += 'if ( typeof(arrBodyElements ) != "undefined") arrBodyElements[0].onload="";';
		finalHtml += '<\/script>';
		finalHtml += "<SCRIPT src='harness_print.js' type='text/javascript'><\/script>";
		finalHtml += '</body>';
		finalHtml += '</html>';
		d.write(finalHtml);
		d.close();
	},

	/* @Handler
	Gets the BUTTON tag reference and fires ONCLICK event on that object.
	@param - this object.
	 */

	fireButtonClick: function(tableRef) {
		var allButtonsRef = tableRef.getElementsByTagName("BUTTON");
		if (allButtonsRef[0].onclick != null)
			pega.util.Event.fireEvent(allButtonsRef[0], "click");
	},

	getCoordinates: function(element) {

		var tempEl = element;
		var leftValue = 0;
		var topValue = 0;
		var modalHeaderCorrection = 0;
		while (tempEl && typeof tempEl.offsetParent != "unknown") {
			if (pega.u.d && pega.u.d.modalDialog && pega.u.d.modalDialog.body) {
				if (tempEl.id == pega.u.d.modalDialog.body.id) {
					break;
				}
				modalHeaderCorrection = tempEl.offsetTop;
			}

			var panelId = "";
			if (tempEl.offsetParent && tempEl.offsetParent.offsetParent) {
				panelId = tempEl.offsetParent.offsetParent.id;
			}
			if (panelId == "PEGA_LU_L" || panelId == "PEGA_LU_R" || panelId == "PEGA_LU_C" || panelId == "PEGA_LU_T" || panelId == "PEGA_LU_B") {
				break;
			}
			leftValue += tempEl.offsetLeft;
			topValue += tempEl.offsetTop;
			tempEl = tempEl.offsetParent;
		}
		/*Top coordinate calculated thus far has included header height too but spellchecker div is positioned according to content and not body(header+body)*/
		if (!pega.u.d.inStandardsMode) {
			topValue -= modalHeaderCorrection;
		}
		return [leftValue, topValue];
	},

	/* @public @Handler
	getReadOnlyValue() called from the Defer Load api's while setting the readonly values
	@return $String$
	 */
	getReadOnlyValue: function(event, elem) {
		var harCtxMgr = pega.ui.HarnessContextMgr;

		if ((event == undefined || !event) && (elem == undefined && !elem)) {
			event = pega.util.Event.getEvent(event);
		}

		var testElem = elem;
		while (testElem && testElem.getAttribute) {
			if (testElem.getAttribute("readonly") == 'true') {
				return "-1";
			} else if (testElem.getAttribute("readonly") == 'false') {
				return "0";
			}
			testElem = testElem.parentNode;
		}
		if (harCtxMgr.get('strHarnessMode') == "ACTION" || (document.getElementById("HarnessMode") && document.getElementById("HarnessMode").value == "ACTION")) {
			/*If in perform harness */
			var actionSec = pega.util.Dom.getElementsById("pyActionArea");
			var actionIFrame = window.frames.actionIFrame;
			/*will be non null for iframe based outer perform harness*/
			var bFlowAction = harCtxMgr.get('bActionIframe');
			/*will be true for flowactions*/
			var bIframePerfHarness = false;
			if ((actionIFrame && actionIFrame != null) || bFlowAction)
				bIframePerfHarness = true;
			if (actionSec || !bIframePerfHarness) {
				/*if the new ActionArea section is used or if it is non iframe based perfrom harness( for e.g when using flowActionSimple)*/
				if ((elem == undefined || !elem) && event) {
					elem = pega.util.Event.getTarget(event);
				}
				while (elem) {
					if (elem.id == "pyActionArea" || elem.id == "pyFlowActionHTML") {
						return "0";
					}
					elem = elem.parentNode;
				}
				return "-1";
			} else {
				/* if old action area section is used */
				return harCtxMgr.get('bReadOnly');
			}
		} else {
			/*If not in perfom harness */
			return harCtxMgr.get('bReadOnly');
		}
	},

	getGroupElementValue: function(elementArray) {
		var value = pega.u.d.getDOMElementValue(elementArray[0]); //this is default setting for non-checkbox and non-radio values
		if (elementArray.length > 1) {
			if (elementArray[1].type == "checkbox") { //identify if its a checkbox property
				value = pega.u.d.getDOMElementValue(elementArray[1]);
			}
		}
		return value;
	},

	getCaretPosition: function(elem) {
		try {
			if (elem != undefined && /^(text|textarea|number|password|email|tel|url)$/.test(elem.type)) {
				if ('selectionStart' in elem) {
					return elem.selectionStart || document.getElementsByName(elem.name)[0].selectionStart;
				} else if (document.selection) {
					var r = document.selection.createRange();
					if (r == null) {
						return 0;
					}
					if (elem.createTextRange != undefined) {
						var re,
							rc;
						try {
							re = elem.createTextRange();
						} catch (e) {
							elem = document.getElementsByName(elem.name)[0];
							re = elem.createTextRange();
						}
						rc = re.duplicate();
						re.moveToBookmark(r.getBookmark());
						rc.setEndPoint('EndToStart', re);
						return rc.text.length;
					}
				}
			}
		} catch (e) {}
		return 0;
	},

	setCaretPosition: function(elem, pos) {
		try {
			if (elem != undefined && /^(text|textarea|number|password|email|tel|url)$/.test(elem.type)) {
				if (elem.setSelectionRange) {
					elem.setSelectionRange(pos, pos);
				} else if (elem.createTextRange) {
					var range = elem.createTextRange();
					range.collapse(true);
					range.moveEnd('character', pos);
					range.moveStart('character', pos);
					range.select();
				}
			}
		} catch (e) {}
	},

	getTrackedPagePointer: function(node, pageName) {
		var metadataPage = node.getAttribute(pageName);
		var trackedPropertiesList = pega.ui.ChangeTrackerMap.getTracker().trackedPropertiesList;
		return trackedPropertiesList[metadataPage];
	},

	/* Serves as a polyfill for Object.keys */
	getObjectKeys: function(object) {
		if (!object || typeof object != "object")
			return;
		if (Object.keys) {
			return Object.keys(object);
		} else {
			var keys = [];
			for (var k in object) {
				if (object.hasOwnProperty(k)) {
					keys.push(k);
				}
			}
			return keys;
		}
	},

	registerSinglePageNav: function(elementWithAnchors, container) {
		var $container = container ? jQuery(container) : jQuery(document);

		jQuery(elementWithAnchors).find("a[href^='#']").filter(function() {
			return this.href.match(/#[a-zA-Z]/);
		}).click(function() {
			var $target = $container.find("a[id='" + this.hash.substring(1) + "']").first();
			/* BUG-248057: Fix for Firefox - hidden anchors have height overlapping with the previous element */
			$target = $target.next();

			var scrollObj = pega.u.d.getScrollObj($target.get(0));

			if (scrollObj) {
				var $scrollObj = jQuery(scrollObj[0]);
			} else {
				var $scrollObj = jQuery("body");
			}

			var toScroll = $scrollObj.scrollTop() + $target.offset().top - $scrollObj.offset().top;
			/* BUG-355813: Extending the fix done for BUG-249588 for chrome */
			if ($scrollObj.prop("tagName").toUpperCase() === "BODY" && (pega.util.Dom.hasClass(document.documentElement, "ff") || pega.util.Dom.hasClass(document.documentElement, "chrome") || pega.util.Dom.hasClass(document.documentElement, "ie"))) {
				/* BUG-249588: In Firefox and IE, body doesn't scroll, html scrolls */
				jQuery(document.documentElement).animate({scrollTop: toScroll}, 250);
			} else {
				$scrollObj.animate({scrollTop: toScroll}, 250);
			}
			return false;
		});
	},

	setRequestAnimationFrame: function(method) {
		if (window.requestAnimationFrame) {
			window.requestAnimationFrame(method);
		} else {
			setTimeout(method, 0);
		}
	},

    /*
     @protected This function checks the given element is inside a repeat layout
     return the status to the handleClientEvent() function
     @param $Object$element - The element to be checked whether inside the repeat or not
     @return $boolean$
    */

	isInRepeat: function(element) {

		var parent = element.parentNode;
		while (parent != null) {
			if (parent.getAttribute && (parent.getAttribute("PL_PROP") != null || parent.getAttribute("PG_PROP") != null)) {
				return true;
			}
			else {
				parent = parent.parentNode;
			}
		}
		return false;
	},

    /*
     @protected This function Returns the parent element associated with this element in a repeat layout
     @param $Object$element - The element inside repeat
     @param $boolean$stopAtSection- If the search should be limited to the section in which the element is present
     @return $Object$ html element 
    */
	getRepeatObject: function(element, stopAtSection) {

		var parentEle = element.parentNode;
		if (stopAtSection && ((element.getAttribute && element.getAttribute("node_type") == "MAIN_RULE") || (parentEle && parentEle.getAttribute && parentEle.getAttribute("node_type") == "MAIN_RULE"))) {
			return null;
		}
		while (parentEle && parentEle != document.body) {
			if (parentEle.getAttribute && (parentEle.getAttribute("PL_PROP") != null || parentEle.getAttribute("PG_PROP") != null)) {
				return parentEle;
			}
			else {
				parentEle = parentEle.parentNode;
				if (parentEle != null & stopAtSection && parentEle.getAttribute && parentEle.getAttribute("node_type") == "MAIN_RULE") {
					break;
				}
			}
		}
		return null;
	},

	getDocumentElement: function() {
		var doc = document;
		if (pega && pega.ui && pega.ui.HarnessContextMgr && pega.ui.HarnessContextMgr.get("isMDC")) {
			var mdcName = pega.ui.HarnessContextMgr.get("mdcName");
			var recordId = pega.ui.HarnessContextMgr.get("recordId");
			var mdcContent;
			if (recordId) {
				mdcContent = document.querySelector("div[data-mdc-id='" + mdcName + "'] div[data-mdc-recordid='" + recordId + "']");
			} else {
				mdcContent = document.querySelector("div[data-mdc-id='" + mdcName + "']");
			}
			if (mdcContent) {
				doc = mdcContent;
			}
		}
		return doc;
	},

	getFormElement: function() {
		var docForm = document.forms[0];
		if (pega && pega.ui && pega.ui.HarnessContextMgr && pega.ui.HarnessContextMgr.get("isMDC")) {
			var mdcName = pega.ui.HarnessContextMgr.get("mdcName");
			var recordId = pega.ui.HarnessContextMgr.get("recordId");
			var mdcForm;
			if (recordId) {
				mdcForm = document.querySelector("div[data-mdc-id='" + mdcName + "'] div[data-mdc-recordid='" + recordId + "'] fieldset.mdc-fieldset");
			} else {
				mdcForm = document.querySelector("div[data-mdc-id='" + mdcName + "'] fieldset.mdc-fieldset");
			}
			if (mdcForm) {
				docForm = mdcForm;
			}
		}
		return docForm;
	},

	scrollIntoViewIfOutOfView: function(el) {
		var topOfPage = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
		var heightOfPage = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
		var elY = 0;
		var elH = 0;
		if (document.layers) {
			elY = el.y;
			elH = el.height;
		} else {
			for (var p = el; p && p.tagName != 'BODY'; p = p.offsetParent) {
				elY += p.offsetTop;
			}
			elH = el.offsetHeight;
		}
		if ((topOfPage + heightOfPage) < (elY + elH)) {
			el.scrollIntoView(true);
		} else if (elY < topOfPage) {
			el.scrollIntoView(false);
		}
	},


	getMDCFieldSets: function() {
		return document.querySelectorAll("fieldset.mdc-fieldset");
	},

	getAllMDCContainers: function() {
		var mainTag = document.getElementsByTagName("main");
		var acDivList = [];
		if (mainTag && mainTag.length == 1) {
			// DC SPA scenario.
			acDivList = mainTag[0].querySelectorAll("div[data-mdc-id]");
		} else {
			acDivList = document.querySelectorAll("div[data-mdc-id]");
		}
		return acDivList;
	},

	getMicroDCDocs: function(mdcName) {
		var microDCDocs = [];
		var mdcDiv = document.querySelector("div[data-mdc-id='" + mdcName + "']");
		if (mdcDiv) {
			microDCDocs = mdcDiv.children;
		}
		return microDCDocs;
	},

	closeOnlyMDCDocs: function(event, forceClose, closeSynchronously, ignoreDirty, paramACName) {
		if (!pega.ui.hasAjaxContainer) {
			return;
		}
		var isAnyMdcDocDirty = false;
		  
    function closeOnlyMDCDocsCallback(){
			var oSafeURL = SafeURL_createFromURL(pega.u.d.url);
			if (forceClose) {
				oSafeURL.put("forceClose", forceClose);
			}
			if (closeSynchronously) {
				oSafeURL.put("closeSynchronously", closeSynchronously);
			}
			var mdcName = paramACName || pega.ctx.mdcName;
			if (event && null != event) {
				var target = pega.util.Event.getTarget(event);
				/* Open section MDC code */
				if (target) {
					var mdcTarget = target.closest("div[data-mdc-recordid]");
					if (mdcTarget && mdcTarget.getAttribute("action") === "openSection") {
						mdcName = mdcTarget.closest("div[data-mdc-id]").getAttribute("data-mdc-id");
					}
				}
			}
			if (mdcName) {
				oSafeURL.put("mdcTarget", mdcName);
			}
			// During outer document close we need to close documents in all Ajax Containers.
			oSafeURL.put("isOuterDocClose", (mdcName ? false : true));
			pega.redux.store.dispatch(pega.redux.actions(pega.redux.actionTypes.CLOSEALL, oSafeURL));
		
		return isAnyMdcDocDirty;
    }
    if (!ignoreDirty && pega.u.d.isFormDirty(true, null, null, true, closeOnlyMDCDocsCallback)) {
			isAnyMdcDocDirty = pega.u.d.isFormDirty(true, null, null, true, closeOnlyMDCDocsCallback);
		}else{
      closeOnlyMDCDocsCallback();
    }
	},

	getOuterDocumentContext: function() {
		var harnessContextmap = pega.ctxmgr.getHarnessContextMap();
		for (var key in harnessContextmap) {
			if (harnessContextmap.hasOwnProperty(key)) {
				var currentHarnessctx = harnessContextmap[key];
				if (!currentHarnessctx.isMDC && !currentHarnessctx.isStatic) {
					return currentHarnessctx;
				}
			}
		}
		return null;
	},

	getScrollParent: function(node) {
		if (!node)
			return null;

		if (node.scrollHeight > node.clientHeight) {
			return node;
		} else {
			return this.getScrollParent(node.parentNode);
		}
	},
	filterRichText: function(strVal) {
		return strVal;
	},
	extendObj: function(out) {
		/* recursive deep copy
		   usage: jQuery.extend(true, {}, sectionStore); --> pega.u.d.extendObj({}, sectionStore);
		*/
		out = out || {};

		for (var i = 1; i < arguments.length; i++) {
			var obj = arguments[i];

			if (!obj)
				continue;

			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					if (typeof obj[key] === 'object') {
						if (Array.isArray(obj[key]) && !out[key]) {
							out[key] = this.extendObj([], obj[key]);
						}
						else {
							out[key] = this.extendObj(out[key], obj[key]);
						}
					} else {
						out[key] = obj[key];
					}
				}
			}
		}

		return out;
	},
	deepExtendObj: function(out) {
        /* recursive deep copy
           usage: jQuery.extend(true, {}, sectionStore); --> pega.u.d.deepExtendObj({}, sectionStore);
           deepExtendObj API does not work in case object is HTML element. 
        */
		out = out || {};

		for (var i = 1; i < arguments.length; i++) {
			var obj = arguments[i];

			if (!obj)
				continue;

			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					// BUG-554390 : Fixed merging arrays properly 
					if (obj[key] && typeof obj[key] === 'object' && (obj[key].constructor === Object || obj[key].constructor === Array)) {  /*in case HTML element do not call deepExtendObj again as hasOwnProperty() fails */
						out[key] = this.deepExtendObj(out[key], obj[key]);
					} else {
						out[key] = obj[key];
					}
				}
			}
		}
		return out;
	}
};

pega.lang.augmentObject(pega.ui.Doc.prototype, domUtils);
//static-content-hash-trigger-GCC
/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.2.2/LICENSE */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).DOMPurify=t()}(this,(function(){"use strict";var e=Object.hasOwnProperty,t=Object.setPrototypeOf,n=Object.isFrozen,r=Object.getPrototypeOf,o=Object.getOwnPropertyDescriptor,i=Object.freeze,a=Object.seal,l=Object.create,c="undefined"!=typeof Reflect&&Reflect,s=c.apply,u=c.construct;s||(s=function(e,t,n){return e.apply(t,n)}),i||(i=function(e){return e}),a||(a=function(e){return e}),u||(u=function(e,t){return new(Function.prototype.bind.apply(e,[null].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(t))))});var f,m=x(Array.prototype.forEach),d=x(Array.prototype.pop),p=x(Array.prototype.push),g=x(String.prototype.toLowerCase),h=x(String.prototype.match),y=x(String.prototype.replace),v=x(String.prototype.indexOf),b=x(String.prototype.trim),A=x(RegExp.prototype.test),T=(f=TypeError,function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return u(f,t)});function x(e){return function(t){for(var n=arguments.length,r=Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];return s(e,t,r)}}function w(e,r){t&&t(e,null);for(var o=r.length;o--;){var i=r[o];if("string"==typeof i){var a=g(i);a!==i&&(n(r)||(r[o]=a),i=a)}e[i]=!0}return e}function S(t){var n=l(null),r=void 0;for(r in t)s(e,t,[r])&&(n[r]=t[r]);return n}function k(e,t){for(;null!==e;){var n=o(e,t);if(n){if(n.get)return x(n.get);if("function"==typeof n.value)return x(n.value)}e=r(e)}return function(e){return console.warn("fallback value for",e),null}}var D=i(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),E=i(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),R=i(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),_=i(["animate","color-profile","cursor","discard","fedropshadow","feimage","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),N=i(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),O=i(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),M=i(["#text"]),L=i(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]),F=i(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),I=i(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),C=i(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),z=a(/\{\{[\s\S]*|[\s\S]*\}\}/gm),U=a(/<%[\s\S]*|[\s\S]*%>/gm),H=a(/^data-[\-\w.\u00B7-\uFFFF]/),j=a(/^aria-[\-\w]+$/),P=a(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),B=a(/^(?:\w+script|data):/i),W=a(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),G="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function q(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}var K=function(){return"undefined"==typeof window?null:window},V=function(e,t){if("object"!==(void 0===e?"undefined":G(e))||"function"!=typeof e.createPolicy)return null;var n=null,r="data-tt-policy-suffix";t.currentScript&&t.currentScript.hasAttribute(r)&&(n=t.currentScript.getAttribute(r));var o="dompurify"+(n?"#"+n:"");try{return e.createPolicy(o,{createHTML:function(e){return e}})}catch(e){return console.warn("TrustedTypes policy "+o+" could not be created."),null}};return function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:K(),n=function(t){return e(t)};if(n.version="2.2.9",n.removed=[],!t||!t.document||9!==t.document.nodeType)return n.isSupported=!1,n;var r=t.document,o=t.document,a=t.DocumentFragment,l=t.HTMLTemplateElement,c=t.Node,s=t.Element,u=t.NodeFilter,f=t.NamedNodeMap,x=void 0===f?t.NamedNodeMap||t.MozNamedAttrMap:f,Y=t.Text,X=t.Comment,$=t.DOMParser,Z=t.trustedTypes,J=s.prototype,Q=k(J,"cloneNode"),ee=k(J,"nextSibling"),te=k(J,"childNodes"),ne=k(J,"parentNode");if("function"==typeof l){var re=o.createElement("template");re.content&&re.content.ownerDocument&&(o=re.content.ownerDocument)}var oe=V(Z,r),ie=oe&&Ce?oe.createHTML(""):"",ae=o,le=ae.implementation,ce=ae.createNodeIterator,se=ae.createDocumentFragment,ue=r.importNode,fe={};try{fe=S(o).documentMode?o.documentMode:{}}catch(e){}var me={};n.isSupported="function"==typeof ne&&le&&void 0!==le.createHTMLDocument&&9!==fe;var de=z,pe=U,ge=H,he=j,ye=B,ve=W,be=P,Ae=null,Te=w({},[].concat(q(D),q(E),q(R),q(N),q(M))),xe=null,we=w({},[].concat(q(L),q(F),q(I),q(C))),Se=null,ke=null,De=!0,Ee=!0,Re=!1,_e=!1,Ne=!1,Oe=!1,Me=!1,Le=!1,Fe=!1,Ie=!0,Ce=!1,ze=!0,Ue=!0,He=!1,je={},Pe=w({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),Be=null,We=w({},["audio","video","img","source","image","track"]),Ge=null,qe=w({},["alt","class","for","id","label","name","pattern","placeholder","summary","title","value","style","xmlns"]),Ke="http://www.w3.org/1998/Math/MathML",Ve="http://www.w3.org/2000/svg",Ye="http://www.w3.org/1999/xhtml",Xe=Ye,$e=!1,Ze=null,Je=o.createElement("form"),Qe=function(e){Ze&&Ze===e||(e&&"object"===(void 0===e?"undefined":G(e))||(e={}),e=S(e),Ae="ALLOWED_TAGS"in e?w({},e.ALLOWED_TAGS):Te,xe="ALLOWED_ATTR"in e?w({},e.ALLOWED_ATTR):we,Ge="ADD_URI_SAFE_ATTR"in e?w(S(qe),e.ADD_URI_SAFE_ATTR):qe,Be="ADD_DATA_URI_TAGS"in e?w(S(We),e.ADD_DATA_URI_TAGS):We,Se="FORBID_TAGS"in e?w({},e.FORBID_TAGS):{},ke="FORBID_ATTR"in e?w({},e.FORBID_ATTR):{},je="USE_PROFILES"in e&&e.USE_PROFILES,De=!1!==e.ALLOW_ARIA_ATTR,Ee=!1!==e.ALLOW_DATA_ATTR,Re=e.ALLOW_UNKNOWN_PROTOCOLS||!1,_e=e.SAFE_FOR_TEMPLATES||!1,Ne=e.WHOLE_DOCUMENT||!1,Le=e.RETURN_DOM||!1,Fe=e.RETURN_DOM_FRAGMENT||!1,Ie=!1!==e.RETURN_DOM_IMPORT,Ce=e.RETURN_TRUSTED_TYPE||!1,Me=e.FORCE_BODY||!1,ze=!1!==e.SANITIZE_DOM,Ue=!1!==e.KEEP_CONTENT,He=e.IN_PLACE||!1,be=e.ALLOWED_URI_REGEXP||be,Xe=e.NAMESPACE||Ye,_e&&(Ee=!1),Fe&&(Le=!0),je&&(Ae=w({},[].concat(q(M))),xe=[],!0===je.html&&(w(Ae,D),w(xe,L)),!0===je.svg&&(w(Ae,E),w(xe,F),w(xe,C)),!0===je.svgFilters&&(w(Ae,R),w(xe,F),w(xe,C)),!0===je.mathMl&&(w(Ae,N),w(xe,I),w(xe,C))),e.ADD_TAGS&&(Ae===Te&&(Ae=S(Ae)),w(Ae,e.ADD_TAGS)),e.ADD_ATTR&&(xe===we&&(xe=S(xe)),w(xe,e.ADD_ATTR)),e.ADD_URI_SAFE_ATTR&&w(Ge,e.ADD_URI_SAFE_ATTR),Ue&&(Ae["#text"]=!0),Ne&&w(Ae,["html","head","body"]),Ae.table&&(w(Ae,["tbody"]),delete Se.tbody),i&&i(e),Ze=e)},et=w({},["mi","mo","mn","ms","mtext"]),tt=w({},["foreignobject","desc","title","annotation-xml"]),nt=w({},E);w(nt,R),w(nt,_);var rt=w({},N);w(rt,O);var ot=function(e){var t=ne(e);t&&t.tagName||(t={namespaceURI:Ye,tagName:"template"});var n=g(e.tagName),r=g(t.tagName);if(e.namespaceURI===Ve)return t.namespaceURI===Ye?"svg"===n:t.namespaceURI===Ke?"svg"===n&&("annotation-xml"===r||et[r]):Boolean(nt[n]);if(e.namespaceURI===Ke)return t.namespaceURI===Ye?"math"===n:t.namespaceURI===Ve?"math"===n&&tt[r]:Boolean(rt[n]);if(e.namespaceURI===Ye){if(t.namespaceURI===Ve&&!tt[r])return!1;if(t.namespaceURI===Ke&&!et[r])return!1;var o=w({},["title","style","font","a","script"]);return!rt[n]&&(o[n]||!nt[n])}return!1},it=function(e){p(n.removed,{element:e});try{e.parentNode.removeChild(e)}catch(t){try{e.outerHTML=ie}catch(t){e.remove()}}},at=function(e,t){try{p(n.removed,{attribute:t.getAttributeNode(e),from:t})}catch(e){p(n.removed,{attribute:null,from:t})}if(t.removeAttribute(e),"is"===e&&!xe[e])if(Le||Fe)try{it(t)}catch(e){}else try{t.setAttribute(e,"")}catch(e){}},lt=function(e){var t=void 0,n=void 0;if(Me)e="<remove></remove>"+e;else{var r=h(e,/^[\r\n\t ]+/);n=r&&r[0]}var i=oe?oe.createHTML(e):e;if(Xe===Ye)try{t=(new $).parseFromString(i,"text/html")}catch(e){}if(!t||!t.documentElement){t=le.createDocument(Xe,"template",null);try{t.documentElement.innerHTML=$e?"":i}catch(e){}}var a=t.body||t.documentElement;return e&&n&&a.insertBefore(o.createTextNode(n),a.childNodes[0]||null),Ne?t.documentElement:a},ct=function(e){return ce.call(e.ownerDocument||e,e,u.SHOW_ELEMENT|u.SHOW_COMMENT|u.SHOW_TEXT,null,!1)},st=function(e){return!(e instanceof Y||e instanceof X)&&!("string"==typeof e.nodeName&&"string"==typeof e.textContent&&"function"==typeof e.removeChild&&e.attributes instanceof x&&"function"==typeof e.removeAttribute&&"function"==typeof e.setAttribute&&"string"==typeof e.namespaceURI&&"function"==typeof e.insertBefore)},ut=function(e){return"object"===(void 0===c?"undefined":G(c))?e instanceof c:e&&"object"===(void 0===e?"undefined":G(e))&&"number"==typeof e.nodeType&&"string"==typeof e.nodeName},ft=function(e,t,r){me[e]&&m(me[e],(function(e){e.call(n,t,r,Ze)}))},mt=function(e){var t=void 0;if(ft("beforeSanitizeElements",e,null),st(e))return it(e),!0;if(h(e.nodeName,/[\u0080-\uFFFF]/))return it(e),!0;var r=g(e.nodeName);if(ft("uponSanitizeElement",e,{tagName:r,allowedTags:Ae}),!ut(e.firstElementChild)&&(!ut(e.content)||!ut(e.content.firstElementChild))&&A(/<[/\w]/g,e.innerHTML)&&A(/<[/\w]/g,e.textContent))return it(e),!0;if(!Ae[r]||Se[r]){if(Ue&&!Pe[r]){var o=ne(e)||e.parentNode,i=te(e)||e.childNodes;if(i&&o)for(var a=i.length-1;a>=0;--a)o.insertBefore(Q(i[a],!0),ee(e))}return it(e),!0}return e instanceof s&&!ot(e)?(it(e),!0):"noscript"!==r&&"noembed"!==r||!A(/<\/no(script|embed)/i,e.innerHTML)?(_e&&3===e.nodeType&&(t=e.textContent,t=y(t,de," "),t=y(t,pe," "),e.textContent!==t&&(p(n.removed,{element:e.cloneNode()}),e.textContent=t)),ft("afterSanitizeElements",e,null),!1):(it(e),!0)},dt=function(e,t,n){if(ze&&("id"===t||"name"===t)&&(n in o||n in Je))return!1;if(Ee&&A(ge,t));else if(De&&A(he,t));else{if(!xe[t]||ke[t])return!1;if(Ge[t]);else if(A(be,y(n,ve,"")));else if("src"!==t&&"xlink:href"!==t&&"href"!==t||"script"===e||0!==v(n,"data:")||!Be[e]){if(Re&&!A(ye,y(n,ve,"")));else if(n)return!1}else;}return!0},pt=function(e){var t=void 0,r=void 0,o=void 0,i=void 0;ft("beforeSanitizeAttributes",e,null);var a=e.attributes;if(a){var l={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:xe};for(i=a.length;i--;){var c=t=a[i],s=c.name,u=c.namespaceURI;if(r=b(t.value),o=g(s),l.attrName=o,l.attrValue=r,l.keepAttr=!0,l.forceKeepAttr=void 0,ft("uponSanitizeAttribute",e,l),r=l.attrValue,!l.forceKeepAttr&&(at(s,e),l.keepAttr))if(A(/\/>/i,r))at(s,e);else{_e&&(r=y(r,de," "),r=y(r,pe," "));var f=e.nodeName.toLowerCase();if(dt(f,o,r))try{u?e.setAttributeNS(u,s,r):e.setAttribute(s,r),d(n.removed)}catch(e){}}}ft("afterSanitizeAttributes",e,null)}},gt=function e(t){var n=void 0,r=ct(t);for(ft("beforeSanitizeShadowDOM",t,null);n=r.nextNode();)ft("uponSanitizeShadowNode",n,null),mt(n)||(n.content instanceof a&&e(n.content),pt(n));ft("afterSanitizeShadowDOM",t,null)};return n.sanitize=function(e,o){var i=void 0,l=void 0,s=void 0,u=void 0,f=void 0;if(($e=!e)&&(e="\x3c!--\x3e"),"string"!=typeof e&&!ut(e)){if("function"!=typeof e.toString)throw T("toString is not a function");if("string"!=typeof(e=e.toString()))throw T("dirty is not a string, aborting")}if(!n.isSupported){if("object"===G(t.toStaticHTML)||"function"==typeof t.toStaticHTML){if("string"==typeof e)return t.toStaticHTML(e);if(ut(e))return t.toStaticHTML(e.outerHTML)}return e}if(Oe||Qe(o),n.removed=[],"string"==typeof e&&(He=!1),He);else if(e instanceof c)1===(l=(i=lt("\x3c!----\x3e")).ownerDocument.importNode(e,!0)).nodeType&&"BODY"===l.nodeName||"HTML"===l.nodeName?i=l:i.appendChild(l);else{if(!Le&&!_e&&!Ne&&-1===e.indexOf("<"))return oe&&Ce?oe.createHTML(e):e;if(!(i=lt(e)))return Le?null:ie}i&&Me&&it(i.firstChild);for(var m=ct(He?e:i);s=m.nextNode();)3===s.nodeType&&s===u||mt(s)||(s.content instanceof a&&gt(s.content),pt(s),u=s);if(u=null,He)return e;if(Le){if(Fe)for(f=se.call(i.ownerDocument);i.firstChild;)f.appendChild(i.firstChild);else f=i;return Ie&&(f=ue.call(r,f,!0)),f}var d=Ne?i.outerHTML:i.innerHTML;return _e&&(d=y(d,de," "),d=y(d,pe," ")),oe&&Ce?oe.createHTML(d):d},n.setConfig=function(e){Qe(e),Oe=!0},n.clearConfig=function(){Ze=null,Oe=!1},n.isValidAttribute=function(e,t,n){Ze||Qe({});var r=g(e),o=g(t);return dt(r,o,n)},n.addHook=function(e,t){"function"==typeof t&&(me[e]=me[e]||[],p(me[e],t))},n.removeHook=function(e){me[e]&&d(me[e])},n.removeHooks=function(e){me[e]&&(me[e]=[])},n.removeAllHooks=function(){me={}},n}()}));
//# sourceMappingURL=purify.min.js.map
//static-content-hash-trigger-GCC