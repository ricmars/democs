/*@package
pega_cpm_dialogmanager.js
Manager for floating div dialogs
*/



/* Added for globalisation of units */

if (!pega)
  	var pega = {};
if (!pega.cpm)
  	pega.cpm = {};
if(!pega.cpm.UNITS)
           pega.cpm.UNITS = "px";

/* End */

// function for cpm tab manager
pega.cpm.dialogManager = function() {

	this._sDialogId = "";

	this._bPinned = false;
	this._nPinnedLeft = 0;
	this._nPinnedTop = 0;

	this._nCurrentLeft = 0;
	this._nCurrentTop = 0;

	this._nPinnedLeft = 0;
	this._nPinnedTop = 0;

	this._nWidth = 0;
	this._nHeight = 0;

	this._sOverflow = "visible";

	this._sSectionName = "";
	this._sSectionClass = "";

	this._sButtonPinnedId = "";
	this._sButtonCollapseId = "";

	this._bCollapsed = false;
	this._sCollapsibleDivId = "";

	
	this._sDialogStyleName = "";

	this._oDialog = null;

	this._oDocument = null;

	this._startX;
	this._startY;
	this._bMove = false;

	this._startMouseX;
	this._startMouseY;

	this._startDivX;
	this._startDivY;


	this._DIALOG_BODY_NAME = "dialogBody";
	this._DIALOG_BODY_STYLE = "dialogBodyStyle";

	this._overDiv;


	this._arClickEvent = new Array();
	this._arCloseEvent = new Array();
	this._arBeforeCloseEvent = new Array();
	this._arMoveEvent = new Array();
	this._arHideEvent = new Array();
	this._arShowEvent = new Array();
	this._arPinnedEvent = new Array();
	this._arUnpinnedEvent = new Array();

}


pega.cpm.dialogManager.prototype =
{

	nullify: function() {
		this._oDialog = null;
		this._oDocument = null;
	},

	

	/*
	@public- Create the Dialog
	@param $String$oDoc - "document" where you exist, can also pass in an element, but js will have to process and find document
	@param $String$sParams - JSON string of params.  Possible params include: nTop, nLeft, nWidth, nHeight, bPinned, sSectionName, sSectionClass, nPinnedTop, nPinnedLeft, sCollapsibleDivId, sOverflow
	@return $void$
	*/
	createDialog: function(oDoc, sParams) {
		// params of the format...
		// {"nTop" : "", "nLeft" : "", "nWidth" : "", "nHeight" : "", "bPinned" : "", "sSectionName" : "" }
		// nTop, nLeft, nWidth, nHeight, bPinned, sSectionName, sSectionClass, 
		// nPinnedTop, nPinnedLeft, sCollapsibleDivId
		


		if (this._oDialog == null) {
			oParams = deserialize(sParams);
			this._initialize(oDoc, oParams);
			this._buildDialog(oDoc);
		}
		else {
			this.showDialog();
		}
	},


	/*
	@public- Show the dialog, if the dialog was "hidden"
	@param  $boolean$bReloadBody - if true, body will be reloaded from server, false, just what is currently there
	@return $void$
	*/
	showDialog: function(bReloadBody) {
		if (this._oDialog != null) {
			this._oDialog.style.display = "";

			if (bReloadBody) {
				this._loadDialogBody();
			}

			this._fireEvent("show");
			
		}

		
	},


	/*
	@public- Hide the dialog.  This does not remove the dialog, just hides it.
	@return $void$
	*/
	hideDialog: function() {
		if (this._oDialog != null) {
			this._oDialog.style.display = "none";

			this._fireEvent("hide");
		}

		
	},


	/*
	@public- Closes the dialog (what the close button will call.)
	@param  $boolean$bHide - true, dialog is hidden, false, dialog is removed.
	@return $void$
	*/
	closeDialog : function(bHide) {

		this._fireEvent("beforeClose");

		if (bHide) {
			this.hideDialog();
		}
		else {
			this.removeDialog();
		}


		
	},

	/*
	@public- Removed the dialog from the html DOM
	@return $void$
	*/
	removeDialog: function() {
		if (this._oDialog != null) {
			this._oDialog.parentNode.removeChild(this._oDialog);

			this._oDialog = null;

			this._fireEvent("close");

		}

		this.nullify();

	},

	/*
	@public- Called from a collapse/expand button.  This will expand/collapse the dialog.  In order for this work the following MUST be present: a value for sCollapsibleDivId must have been passed in via createDialog.  The given oButton, must have a className of which the names must have "Collapsed" and "Expanded" in them.
	@param  $object$oButton - pointer to the expand/collapse button
	@return $void$
	*/
	collapseDialogFromButton: function(oButton) {

		if (oButton != null) {
			var sButtonClass = oButton.className;
			this._sButtonCollapseId = oButton.getAttribute("id");
		
			if (sButtonClass.indexOf("Collapsed") >=0) {
				this.collapseDialog(false);
			}
			else {
				this.collapseDialog(true);
			}
			
		}

	},

	/*
	@public- This will expand/collapse the dialog.  In order for this work the following MUST be present: a value for sCollapsibleDivId must have been passed in via createDialog.  The given oButton, must have a className of which the names must have "Collapsed" and "Expanded" in them.
	@param  $boolean$bCollapsed - true - collapse the dialog, false - expand the dialog
	@return $void$
	*/
	collapseDialog: function(bCollapsed) {
		this._bCollapsed = bCollapsed;
		var oDiv;
																		if (this._sCollapsibleDivId != "") {
			var oDivList = pega.util.Dom.getElementsById(this._sCollapsibleDivId, this._oDialog);
			if ((oDivList != null) && (oDivList.length > 0)) {
				oDiv = oDivList[0];
			}
		}

		if (this._sButtonCollapseId != "") {
			var oButtonList = pega.util.Dom.getElementsById(this._sButtonCollapseId, this._oDialog);
			if ((oButtonList != null) && (oButtonList.length > 0)) {
				var oButton = oDivButton[0];
				var sButtonClass = oButton.className;
				var sButtonButtonClass = oButton.getAttribute("buttonClass");
				if (bCollapsed) {
					if (sButtonClass.indexOf("Collapsed") < 0) {
						oButton.className = sButtonClass.replace(/Expanded/gi, "Collapsed");
						
						oButton.setAttribute("buttonClass", sButtonButtonClass.replace(/Expanded/gi, "Collapsed"));
					}
					
					if (oDiv != null) {
						oDiv.style.display = "none";

					}
					
				}
				else {
					if (sButtonClass.indexOf("Collapsed") >= 0) {
						oButton.className = sButtonClass.replace(/Collapsed/gi, "Expanded");
						
						oButton.setAttribute("buttonClass", sButtonButtonClass.replace(/Collapsed/gi, "Expanded"));
					}

					if (oDiv != null) {
						oDiv.style.display = "";
					}
				}
			}
		}


	},

	/*
	@public- Called from a pinned button.  This will pin/unpin the dialog.  In order for this work the following MUST be present: the given oButton, must have a className of which the names must have "Pin" and "Pinned" in them.
	@param  $object$oButton - pointer to the pin button
	@return $void$
	*/
	pinDialogFromButton: function(oButton) {

		if (oButton != null) {
			var sButtonClass = oButton.className;
			this._sButtonPinnedId = oButton.getAttribute("id");
		
			if (sButtonClass.indexOf("Pinned") >=0) {
				this.pinDialog(false);
			}
			else {
				this.pinDialog(true);
			}
			
		}
		
		
	},


	


	/*
	@public- This will pin/unpin the dialog.  In order for this work the following MUST be present: the given oButton, must have a className of which the names must have "Pin" and "Pinned" in them.
	@param  $boolean$bPinned - true - dialog is pinned, false - dialog can be moved
	@return $void$
	*/
	pinDialog: function(bPinned) {


		if (this._sButtonPinnedId != "") {
			var oButtonList = pega.util.Dom.getElementsById(this._sButtonPinnedId, this._oDialog);
			if ((oButtonList != null) && (oButtonList.length > 0)) {
				var oButton = oButtonList[0];
				var sButtonClass = oButton.className;
				var sButtonButtonClass = oButton.getAttribute("buttonClass");
				if (bPinned) {
					if (sButtonClass.indexOf("Pinned") < 0) {
						oButton.className = sButtonClass.replace(/Pin/gi, "Pinned");
			
						oButton.setAttribute("buttonClass", sButtonButtonClass.replace(/Pin/gi, "Pinned"));
					}
				}
				else {
					if (sButtonClass.indexOf("Pinned") >= 0) {
						oButton.className = sButtonClass.replace(/Pinned/gi, "Pin");

						oButton.setAttribute("buttonClass", sButtonButtonClass.replace(/Pinned/gi, "Pin"));
					}

				}
			}
		}

		if (bPinned) {
			this._oDialog.style.top = this._nPinnedTop;
			this._oDialog.style.left = this._nPinnedLeft;

			var oMove = new Object;
			oMove.top = parseInt(this._oDialog.style.top); 
			oMove.left = parseInt(this._oDialog.style.left);
			this._fireEvent("move", oMove);

			this._fireEvent("pinned");
		}
		else {
			this._fireEvent("unpinned");

		}

		this._oDialog.className = this._buildBodyStyle(bPinned);

	
		this._bPinned = bPinned;


		

			

	},


	/*
	@public- Function begins the move sequnence.  This function MUST be called from section/div that is a header or contains the buttons (close, pin, collapse).  This function MUST be called on the "onmousedown" event.
	@return $void$
	*/
	startMovingDialog: function(event) {

		event = (event == undefined)?window.event : event;

		if (!this._bPinned) {

			this._startMouseX = event.screenX;
			this._startMouseY = event.screenY;

			this._startDivX = parseInt(this._oDialog.style.left);
			this._startDivY = parseInt(this._oDialog.style.top);

			// create the overlay div, so mouse events will come through, otherwise, when on the top
			// of an iframe, may loose the mouse events. This overlay will sit on top of all, but under
			// the floating div.  Will be removed when the mouse events are detached.
			this._createOverlayingDiv();

			pega.util.Event.addListener(this._oDocument, 'mousemove', this._moveDialog, null, this);
			pega.util.Event.addListener(this._oDocument, 'mouseup', this._finishMovingDialog, null, this);
		}

	},



	/*
	@public- Add a listener for the events from the dialog
	@param  $String$sEvent - events to register for: click, show, hide, move, close, beforeClose
	@param  $Object$oCallback - pointer to callback function
	@param.optional $Object$oData - pointer to an object that contains data to be passed to callback fucntion
	@param.optional $Object$scope - if present will be scope of callback function (usually pass in "this")
	@return $void$
	*/
	addListener: function(sEvent, oCallback, oData, scope) {

		var oEvent = new pega.cpm.dialogManager.eventData(oCallback, oData, scope);
		
		this.removeListener(sEvent, oCallback);
		this._getEventQueue(sEvent).push(oEvent);

	},

	/*
	@public- Removes all registered events that have this callback function
	@param  $String$sEvent - events that are registered for: click, show, hide, move, close, beforeClose
	@param  $Object$oCallback - pointer to callback function
	@return $void$
	*/
	removeListener: function(sEvent, oCallback) {

		this._removeEvent(this._getEventQueue(sEvent), oCallback);

	},

	/*
	@private- Given an event type, return the event queue
	@param  $String$sEvent - events to register for: click, show, hide, move, close, beforeClose
	@return $Array$ - event queue
	*/
	_getEventQueue: function(sEvent) {

		switch (sEvent) {
			case "click" :
				return(this._arClickEvent);
				break;
			case "close" :
				return(this._arCloseEvent);
				break;
			case "beforeClose" :
				return(this._arBeforeCloseEvent);
				break;
			case "move" :
				return(this._arMoveEvent);
				break;
			case "hide" :
				return(this._arHideEvent);
				break;
			case "show" :
				return(this._arShowEvent);
				break;
			case "pinned" :
				return(this._arPinnedEvent);
				break;
			case "unpinned" :
				return(this._arUnpinnedEvent);
				break;
		}

	},

	/*
	@private - Handles eternal events, which that callback has the parametes in reverse.
	@param  $Object$oEvent - event data that belongs to the external event (usually "event")
	@param  $Object$oEventData - data that was passed to the callback to passed through
	@return $void$
	*/
	_handleExternalEvent: function(oEvent, oEventData) {

		this._fireEvent(oEventData, oEvent);
	},


	/*
	@private - Fires the local event
	@param  $String$sEvent - events to register for: click, show, hide, move, close, beforeClose
	@param  $Object$oEventData - data that was passed to the callback to passed through
	@return $void$
	*/
	_fireEvent: function(sEvent, oEventData) {

		this._fireLocalEvent(this._getEventQueue(sEvent), oEventData);


		
	},


	/*
	@private - Fires the local event
	@param  $Object$oArray - event queue to process the events
	@param  $Object$oEventData - data that was passed to the callback to passed through
	@return $void$
	*/	
	_fireLocalEvent: function(oArray, oEventData) {
		for (var el=0; el < oArray.length; el++) {
			var oEvent = oArray[el];

			try {
				if (oEvent.scope != null) {
					oEvent.eventFunction.call(oEvent.scope,oEventData, oEvent.oData);
				}
				else {
					oEvent.eventFunction.call(oEvent.scope,oEventData, oEvent.oData);
				}
			}
			catch(e) {
			}
		}

	},

	/*
	@private - Removed events from the queue that have the given callback function.
	@param  $Object$oArray - event queue to process the events
	@param  $Object$oCallback - callback function that when found in the queue, will be removed
	@return $void$
	*/
	_removeEvent: function(oArray, oCallback) {
		for (i=0; i < oArray.length; i++){
	         		if (oArray[i].eventFunction == oCallback) {
				oArray[i]= null;
				// remove from array
				oArray.splice(i, 1);
			}
		}

	},



	/*
	@private- Initializes the dialog with default or given data
	@param $object$oDoc -  "document" where you exist, can also pass in an element, but js will have to process and find document.
	@param $object$oParams - deserialized version of the JSON string
	@return $void$
	*/
	_initialize: function(oDoc, oParams) {

		if ((oParams.nTop != null) && (oParams.nLeft != null)) {
			
			this._setLocation(parseInt(oParams.nLeft), parseInt(oParams.nTop));

			if (oParams.bPinned != null) {
				this._bPinned = this._parseBoolean(oParams.bPinned);
			}

			this._setPinnedLocation(parseInt(oParams.nLeft), parseInt(oParams.nTop));
		}

		if ((oParams.nPinnedTop != null) && (oParams.nPinnedLeft != null)) {
			this._setPinnedLocation(parseInt(oParams.nPinnedLeft), parseInt(oParams.nPinnedTop));		
		}

		if ((oParams.nWidth != null) && (oParams.nHeight != null)) {
			this._setSize(parseInt(oParams.nWidth), parseInt(oParams.nHeight));
		}

		if (oParams.sSectionName != null) {
			this._sSectionName = oParams.sSectionName;
		}

		if (oParams.sSectionClass != null) {
			this._sSectionClass = oParams.sSectionClass;
		}

		if (oParams.sButtonPinnedId != null) {
			this._sButtonPinnedId = oParams.sButtonPinnedId;
		}

		if (oParams.sDialogStyleName != null) {
			this._sDialogStyleName = oParams.sDialogStyleName;
		}

		if (oParams.sDialogBodyId != null) {
			this._sDialogBodyId = oParams.sDialogBodyId;
		}

		if (oParams.sOverflow != null) {
			this._sOverflow = oParams.sOverflow;
		}

		

		
	},

	/*
	@private- Creates an overlaying DIV on top of the portal, so the mouse events from the main body will show through.
	@return $void$
	*/
	_createOverlayingDiv: function() {

		this._overDiv = this._oDocument.createElement("DIV");
		this._overDiv = this._oDocument.body.appendChild(this._overDiv);
		this._overDiv.style.width = "100%";
		this._overDiv.style.height = "100%";
		this._overDiv.style.backgroundColor = "transparent";
		this._overDiv.style.zIndex = "3";
		this._overDiv.style.position= "absolute";
		this._overDiv.style.top = 0;
		this._overDiv.style.left = 0;

	},


	/*
	@private- Remove the overlaying DIV.
	@return $void$
	*/
	_removeOverlayingDiv: function() {
		this._overDiv.parentNode.removeChild(this._overDiv);
	},

	/*
	@private- Builds the body style
	@param $boolean$bPinned - true, have "pinned" in the style, so can brand
	@return $string$ - returns the body style
	*/
	_buildBodyStyle: function (bPinned) {
		var sBodyStyle = this._DIALOG_BODY_STYLE;
		if (this._sDialogStyleName != "") {
			sBodyStyle += " " + this._sDialogStyleName;
		}

		if (bPinned) {
			sBodyStyle += " " + this._DIALOG_BODY_STYLE + "Pinned";
			if (this._sDialogStyleName != "") {
				sBodyStyle += " " + this._sDialogStyleName + "Pinned"
			}

		}

		return(sBodyStyle);
	},

	/*
	@private- Builds the dialog
	@param $object$oDoc -  "document" where you exist, can also pass in an element, but js will have to process and find document.
	@return $void$
	*/
	_buildDialog: function(oDoc) {
		var oBody = this._findBody(oDoc);
		
		if (oBody != null) {
			this._oDocument = oBody.parentNode.parentNode;
			this._oDialog = this._oDocument.createElement("DIV");

			this._oDialog = oBody.appendChild(this._oDialog);

			this._oDialog.setAttribute("id", this._sDialogId);
			

			this._oDialog.className = this._buildBodyStyle(this._bPinned);

			this._oDialog.style.position = "absolute";
			this._oDialog.style.zIndex = 5;
			

			this._oDialog.style.overflow = this._sOverflow;

			this._setLocation(this._nCurrentLeft, this._nCurrentTop);
			this._setSize(this._nWidth, this._nHeight);
			



			oDialogBody = this._oDocument.createElement("DIV");
			this._oDialog.appendChild(oDialogBody);

			oDialogBody.setAttribute("id", this._DIALOG_BODY_NAME);
			this._loadDialogBody();

		
			pega.util.Event.addListener(this._oDialog, 'click', this._handleExternalEvent, "click", this);
			

			

		}

	},

	/*
	@private- Calls the server to get the section data
	@return $void$
	*/
	_loadDialogBody: function() {

		var oSafeUrl = new SafeURL("Rule-HTML-Section.CPMGetSectionHTMLFromServerWithPost");
		oSafeUrl.put("pyPegaSectionClassName", this._sSectionClass);
		oSafeUrl.put("pyPegaSectionStreamName", this._sSectionName);
		var _this = this;
		pega.u.d.asyncRequest("POST",
			SafeURL_createFromURL(oSafeUrl.toURL()),
			{
				success:function(oResponse){
					_this._updateDialogBodyData(oResponse)
				},
				failure: function(){
					alert("Request from server failed.");
				},
				scope:this
			},
			"");

	},


	/*
	@private- Callback from the server, retrieves the section data from the server and puts in the correspoding DIV
	@param $object$oResponse - response data from the server as an object, generally use oResponse.responseText
	@return $void$
	*/
	_updateDialogBodyData: function(oResponse) {
		var oDivList = pega.util.Dom.getElementsById(this._DIALOG_BODY_NAME, this._oDialog, "DIV");
		if ((oDivList != null) && (oDivList.length > 0)) {
			var oDivBody = oDivList[0];

			var oDOMLoader = new pega.tools.EvalDOMScripts();
			var _this = this;
			oDOMLoader.loadHTMLElement(oDivBody, oResponse.responseText, function() {_this._afterLoad();});
		
		}
	},


	/*
	@private- Callback from the loadHTMLElement, function will update the "pinned" icon once it has been loaded
	@return $void$
	*/
	_afterLoad: function() {

		if (this._bPinned) {
			this.pinDialog(this._bPinned);
		}
	},

	/*
	@private- Utility to get the "BODY" of the given document or element
	@param $object$oDoc -  "document" where you exist, can also pass in an element, but js will have to process and find document.
	@return $object$ = returns the BODY as an DOM object
	*/
	_findBody: function(oDoc) {
		var oBody = oDoc.body;
		if (oBody == null) {
			oEl = oDoc.parentNode;
			while (oEl != null) {
				if (oEl.tagName == "BODY") {
					oBody = oEl;
					break;
				}
				
				oEl = oEl.parentNode;
			}
		}

		return (oBody);
	},




	/*
	@private- Sets the location of the dialog, both in the stored varibles and the dialog if exists.
	@param $integer$nLeft -  left corner of the dialog
	@param $integer$nTop - top corner of the dialog
	@return $void$
	*/
	_setLocation: function(nLeft, nTop) {
		this._nCurrentLeft = nLeft;
		this._nCurrentTop = nTop;

		if (this._oDialog != null) {
			this._oDialog.style.top = nTop;
			this._oDialog.style.left = nLeft;
		}
		
	},

	/*
	@private- Sets the size of the dialog, both in the stored variables and the dialog if exists.
	@param $integer$nWidth - width of the dialog
	@param $integer$nHeight - height of the dialog
	@return $void$
	*/
	_setSize: function (nWidth, nHeight) {
		this._nWidth = nWidth;
		this._nHeight = nHeight;

		if (this._oDialog != null) {
			this._oDialog.style.width = nWidth+pega.cpm.UNITS;
			this._oDialog.style.height = nHeight+pega.cpm.UNITS;
		}

	},


	/*
	@private- Sets the location of the where the dialog will be pinned
	@param $integer$nLeft - left corner of the dialog
	@param $integer$nTop - top corner of the dialog
	@return $void$
	*/
	_setPinnedLocation: function(nLeft, nTop) {
		this._nPinnedLeft = nLeft;
		this._nPinnedTop = nTop;

	},




	/*
	@private- Function handles moving the dialog.  This function is attached to the mousemove event in intialization
	@return $void$
	*/
	_moveDialog: function(event) {

		event = (event == undefined)?window.event : event;


		var x = event.screenX;
		var y = event.screenY;

		window.status = "x: " + x;

		var diffX = x - this._startMouseX;
		var diffY = y - this._startMouseY;

		//this._oDialog.style.top = this._startDivY + diffY;
		//this._oDialog.style.left = this._startDivX + diffX;

		this._setLocation(this._startDivX + diffX, this._startDivY + diffY);

	},


	/*
	@private- Function handles the end of the move, then cleans up and detaches events.  This function is attachd to the mouseup event in initialization.
	@return $void$
	*/
	_finishMovingDialog: function() {

		pega.util.Event.removeListener(this._oDocument, 'mousemove', this._moveDialog);
		pega.util.Event.removeListener(this._oDocument, 'mouseup', this._finishMovingDialog);

		this._removeOverlayingDiv();

		var oMove = new Object;
		oMove.top = parseInt(this._oDialog.style.top); 
		oMove.left = parseInt(this._oDialog.style.left);
		this._fireEvent("move", oMove);
	},


	/*
	@private- Utility function for converting text, integer to a boolean
	@param $String$sBool - string value of the boolean ("true", "false", "-1", "0")
	@return $boolean$ -returns the boolean equivalent
	*/
	_parseBoolean : function (sBool) {
		if ((sBool == true) || (sBool == "true") || (sBool == "-1") || (sBool == -1)) {
			return(true);
		}
		else {
			return(false);
		}
	},



	_lastFunction: function() {

		

	}

}


pega.cpm.dialogManager.eventData = function(oFunction, oData, scope) 
{
	this.eventFunction= oFunction;
	this.data= oData;
	this.scope = scope;
}
//static-content-hash-trigger-YUI
/*@package
pega_cpm_callchatdialog.js
Inherting from an intantiated dialogManager and overriding/adding functionality
*/



// inheriting from dialogManager and overriding/adding functionality
pega.cpm.callChatDialog = function(){




}

try {
pega.cpm.callChatDialog.prototype = new pega.cpm.dialogManager();
}
catch (e) {

}


// new and overriding functionality

//pega.cpm.callChatDialog.prototype._functionName = function(x,y) {
//}


/* Added for globalisation of units */
if (!pega) var pega = {};
if (!pega.cpm) pega.cpm = {};
if (!pega.cpm.UNITS) pega.cpm.UNITS = "px";
/* End */
/********Passing the parameters for log out- Creating global variables done for auto log out related enhancement***************/
var isConfirmationRequired_logout;
var logoutMsg_logout;
var confirmMsg_logout;
var confirmlogout_userchoice;
/********Passing the parameters for log out- End of Creating global variables ***************/
var sUniqueCount = 0;
var oCPMCallDialog = new pega.cpm.callChatDialog();
var oCPMChatDialog = new pega.cpm.callChatDialog();
/************* Registering the event for PhoneAgentLogoutStateEvent ************/
registerEventListener('PhoneAgentStateEvent', function(event) {
    if (event == null || event === undefined) return;
    var responseData = JSON.parse(event);
    //Commented below line as part of bug,BUG-680974 8.6.2-UCC11.5-Error page is coming while doing auto logout. Snapshot event will be received after logout hence sending separate logout event is not needed. Changed by Ram Reddy, Boddireddy
    //if (responseData.pyEventName === "Logout") sendEvent('PhoneAgentLogoutStateEvent', event);
});
// Handling PhoneSnapshotEvent, as there is no Logout event observed of nonACD
registerEventListener('PhoneSnapshotEvent', function(event) {
    if (event == null || event === undefined) return;
    var responseData = JSON.parse(event);
    if (responseData.pyEventName === "Snapshot" && responseData.pyDeviceState === "CLOSED") sendEvent('PhoneAgentLogoutStateEvent', event);
});
/*************End of Registering the event for PhoneAgentLogoutStateEvent ************/
pega.cpm.menuActions = {
        sOpts: "directories=no,menubar=no,status=no,titlebar=no,toolbar=no,height=380" + pega.cpm.UNITS,
        phoneInteraction: function(sInteractionType, sURLParams) {
            this.generalInteraction("customer", sInteractionType, sURLParams);
        },
        chatInteraction: function(sInteractionType, sURLParams) {
            this.generalInteraction("chat", sInteractionType, sURLParams);
        },
        inboundCorrespondence: function(sInteractionType, sURLParams) {
            var sUniqueId = "inboundcorr" + pega.cpm.tabbedInterface.getUniqueCount();
            var sMyURLParams = (typeof(sURLParams) == 'string' ? sURLParams : "");
            var applicationSettings = CPMGetDynamicReference();
            pega.cpm.tabbedInterface.createNewTab("inboundcorr", applicationSettings.InteractionClassGroup +
                ".CPMInvokeInteractionStartActivity&InsClass=" + sInteractionType +
                "&FolderType=pyDefault&HarnessPurpose=New" + sMyURLParams, sUniqueId);
            pega.cpm.tabbedInterface.selectTab(sUniqueId);
        },
        customercase: function() {
            var applicationSettings = CPMGetDynamicReference();
            openWorkByURL('<pega:reference name="pxRequestor.pxReqURI" mode="normal" />?pyActivity=' +
                applicationSettings.InteractionClassGroup + '.CPMCustomerCase');
        },
        /*
         sURLParams: additional URLParams should be formatted like: '&Param1=X&Param2=Y'
        */
        generalInteraction: function(sInteractionName, sInteractionClass, sURLParams) {
            var sUniqueId = sInteractionName + pega.cpm.tabbedInterface.getUniqueCount();
            var sMyURLParams = (typeof(sURLParams) == 'string' ? sURLParams : "");
            var applicationSettings = CPMGetDynamicReference();
            pega.cpm.tabbedInterface.createNewTab(sInteractionName, applicationSettings.InteractionClassGroup +
                ".CPMInvokeInteractionStartActivity" + "&WorkPageClass=" + sInteractionClass + sMyURLParams,
                sUniqueId);
            pega.cpm.tabbedInterface.selectTab(sUniqueId);
        },
        opportunity: function() {
            alert("Opportunity");
        },
        complaint: function() {
            alert("Complaint");
        },
        demoScreenPop: function(sModel) {
            if ($("#toasterpop").length) {
                var oSafeURL = new SafeURL("CPMIPStartDemoScreenPop");
                oSafeURL.put("DemoPopDT", sModel);
                pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true, true));
            } else {
                var oSafeURL = new SafeURL("CPMStartDemoScreenPop");
                oSafeURL.put("DemoPopDT", sModel);
                var windowObject = window.open(oSafeURL.toURL(), '', 'width=310' + pega.cpm.UNITS + ',height=290' +
                    pega.cpm.UNITS +
                    ',location:no;menubar:no;scrollbars:no;resizable:no;status:no;toolbar:no;scroll:no;help:no;'
                );
                windowObject.addEventListener('load', function() {
                    windowObject.document.body.style.overflow = "hidden"; //*** Added this css property to remove horizontal scroll bar for chrome.***
                }, false);
            }
        },
        referenceMaterials: function() {
            window.open(pxReqURI + "?pyStream=CAProductReference", "ReferenceMaterial", this.sOpts);
        },
        locationFinder: function() {
            var oSafeURL = new SafeURL("PegaCA-Interface-Account.CALocationTypes");
            window.open(oSafeURL.toURL(), "LocationFinder", this.sOpts + ",width=1000" + pega.cpm.UNITS);
        },
        chat: function() {
            var oParams = new Object;
            oParams.nTop = "10" + pega.cpm.UNITS;
            oParams.nLeft = "80" + pega.cpm.UNITS;
            oParams.nWidth = "80" + pega.cpm.UNITS;
            oParams.nHeight = "35" + pega.cpm.UNITS;
            oParams.sDialogStyleName = "ChatDialogStyle";
            oParams.sOverflow = "hidden";
            oParams.sSectionClass = "CPM-Portal";
            oParams.sSectionName = "PegaChatContainer";
            oParams.bPinned = true;
            oParams.sButtonPinnedId = "dialogPinButton";
            oParams.dialogName = "chat";
            oCPMChatDialog.createDialog(document, serialize(oParams));
            oCPMChatDialog.showDialog(false, serialize(oParams));
        },
        call: function() {
            var oParams = new Object;
            oParams.nTop = "10" + pega.cpm.UNITS;
            oParams.nLeft = "160" + pega.cpm.UNITS;
            oParams.nWidth = "480" + pega.cpm.UNITS;
            oParams.nHeight = "35" + pega.cpm.UNITS;
            oParams.sDialogStyleName = "CallDialogStyle";
            oParams.sOverflow = "hidden";
            oParams.sSectionClass = "ChannelServices-Device-Phone-UI";
            oParams.sSectionName = "PegaCallContainer";
            oParams.bPinned = true;
            oParams.sButtonPinnedId = "dialogPinButton";
            oParams.dialogName = "call";
            oCPMCallDialog.createDialog(document, serialize(oParams));
            oCPMCallDialog.showDialog(false, serialize(oParams));
        },
        menu: function() {
            alert("Menu Item");
        },
        _getUniqueCount: function() {
            sUniqueCount += 1;
            return (sUniqueCount);
        },
        cpmLogOff: function(isConfirmationRequired, logoutMsg, confirmMsg, confirmlogout_userchoice,event,isAppStudioUser) {
             //BUG-583957 start
    if(isAppStudioUser)
      { 
      closeDocuments();
        return;
      }
    //BUG-583957 end
            var confirmLogout = confirmlogout_userchoice;
           if ( true.toString() !== confirmlogout_userchoice.toString()) {
                confirmLogout = true;
                if ((isConfirmationRequired === true) || (isConfirmationRequired.toLowerCase() === "true")) {
                    confirmLogout = confirm(logoutMsg + "\n" + "\n" + confirmMsg);
                }
            }
              //BUG-583957 start
    if(confirmLogout)
      {   
         closeDocuments();
       }
        //BUG-583957 end
            //Exit from script if confirm action is false
            if (!confirmLogout) return false;
            // Clear the sessionStorage to make sure there is no bleed if the actual browser is not closed.
            sessionStorage.clear();
          localStorage.removeItem("pega_chat_messages_map");
            _chatLogout();
          var CurrDateTime = new Date();
           CurrDateTime = CurrDateTime.getTime();
          var framecount;
            closePortalWindowWrapper();

            function endActiveChats() {
                var oSafeURL = new SafeURL("@baseclass.czUpdateConversationOnAgentAction");
                oSafeURL.put("ConversationID", "Agent-LoggedOff");
                oSafeURL.put("AgentAction", "Resolved");
                oSafeURL.put("ReasonForQueueing", "Agent-LoggedOff");
                oSafeURL.put("CurrentAgentID", "");
                pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
                pega.u.d.asyncRequest("POST", SafeURL_createFromURL(oSafeURL.toURL()), null, null);
            }
 //BUG-583957 start
    function closeDocuments()
    {
        var iframes = $(window.document).find("iframe");
      framecount=iframes.length;
         for(var i = 0; i < iframes.length; i++){
           try{
           iframes[i].contentWindow.clearDirtyFlag();
           }
           catch(e){
             console.log(e);
           }
         }
        iframes = null;
         pega.desktop.closeAllDocuments(event);
    }
    //BUG-583957 end
            function _chatLogout() {
                //Continue with CPMLogoff
              localStorage.removeItem("pega_chat_messages_map");
                errorOccured = true;
                if ((typeof oPegaChatEventHandler !== 'undefined') && oPegaChatEventHandler.setChatLogout) {
                    oPegaChatEventHandler.setChatLogout(function(err, data) {
                        if (!err && data.success) {} else {
                            alert(err);
                        }
                    });
                } else {}
            }
function closePortalWindowWrapper()
          {
            
                        var LastExecTime = new Date();
                        LastExecTime = LastExecTime.getTime();
                        var datetimeDiff = LastExecTime - CurrDateTime;
            var iframes = $(window.document).find("iframe");
              var openframes=iframes.length;
            var iframecount = 1;
              if(document.getElementById('EmbeddedCCP')!==null && document.getElementById('EmbeddedCCP')!==undefined)
              {
                var iframecount = document.getElementById('EmbeddedCCP').getElementsByTagName('iframe').length + 1;
              }
             iframes = null;
            if(openframes>iframecount && !(datetimeDiff > 2000 && framecount==openframes)){
           setTimeout(function(){
             var iframes = $(window.document).find("iframe");
               framecount=iframes.length;
             iframes=null;
               closePortalWindowWrapper();  
              }, 1000);
          }
          else
            closePortalWindow();
          }
            function closePortalWindow() {
                var oSafeURL = SafeURL_createFromURL('pyActivity=@baseclass.pzProcessURLInWindow');
                oSafeURL.put("pyPreActivity", "CPM-Portal.CPMLogOff");
                var sName = "_self";
                pega.desktop.support.openUrlInWindow(oSafeURL, sName);
            }
        },
        clearErrorTimeOut: function(event) {
            //Added below line to cancel event listener as part of bug,BUG-680974 8.6.2-UCC11.5-Error page is coming while doing auto logout. Only one event has to be handled, even if multiple events are received. If multiple events are received handling them throws a connection error or forbidden errors. Changed by Ram Reddy, Boddireddy
            cancelEventListener('PhoneAgentLogoutStateEvent', pega.cpm.menuActions.clearErrorTimeOut);
            clearTimeout(pega.cti.API.TimeoutVal);
            pega.cpm.menuActions.portalLogOff(isConfirmationRequired_logout, logoutMsg_logout, confirmMsg_logout,
                confirmlogout_userchoice,event);
        },
        ctiLogoutAndCpmLogout: function(isConfirmationRequired, logoutMsg, confirmMsg, agentID, agentStatus, event ,options) {
            //Added options as part of bug,BUG-680974 8.6.2-UCC11.5-Error page is coming while doing auto logout. Changed by Ram Reddy, Boddireddy
            pega.cti.API.TimeoutVal = null;
            // declaring the values of the global variables
            isConfirmationRequired_logout = isConfirmationRequired;
            logoutMsg_logout = logoutMsg;
            confirmMsg_logout = confirmMsg;
            var confirmLogout_cti = true;
            if ((isConfirmationRequired == true) || (isConfirmationRequired.toLowerCase() == "true")) {
                confirmLogout_cti = confirm(logoutMsg + "\n" + "\n" + confirmMsg);
                confirmlogout_userchoice = confirmLogout_cti;
            }
            if (confirmlogout_userchoice) {
                if (pega.cti != null && pega.cti.API != null && (agentStatus != undefined && agentStatus !== "" && agentStatus !== "Logout")) {
                    //Commented below line as part of bug, 8.6.2-UCC11.5-Error page is coming while doing auto logout. The options value is received from CTIPhone page. Changed by Ram Reddy, Boddireddy 
                    //var options = new Object();
                    registerEventListener('PhoneAgentLogoutStateEvent', pega.cpm.menuActions.clearErrorTimeOut, null, null);
                    //----------------calling the CTI log out API --------------------------------//
                    //Added below empty string instead of undefined and jsonParseOptions as part of bug, 8.6.2-UCC11.5-Error page is coming while doing auto logout. The options value is received from CTIPhone page. Changed by Ram Reddy, Boddireddy 
                    pega.cti.API.logout(agentID, "", jsonParseOptions(options), options, function() {
                        pega.cti.API.TimeoutVal = setTimeout(function() {
                           //  So commenting the below line, did not understand the need of open modal when Logout is success
                           // pega.cpm.menuActions.OpenModalonFailureForCTILogout(event);
                            cancelEventListener('PhoneAgentLogoutStateEvent', pega.cpm.menuActions.clearErrorTimeOut);
                        }, 5000);
                    }, function(response) {
                        cancelEventListener('PhoneAgentLogoutStateEvent', pega.cpm.menuActions.clearErrorTimeOut);
                        if (response !== "" && response.hasOwnProperty("errMessage") && response.errMessage !== "") {
                            pega.cpm.menuActions.OpenModalonFailureForCTILogout(event);
                        }
                    });
                }
            }
        },
        portalLogOff: function(isConfirmationRequired, logoutMsg, confirmMsg, confirmlogout_userchoice,event) {
            //executed for success call back of CTIlogout
            pega.cpm.menuActions.cpmLogOff(isConfirmationRequired, logoutMsg, confirmMsg, confirmlogout_userchoice,event);
        },
        OpenModalonFailureForCTILogout: function(event) {
            //executed for failure callback of CTI logout
            var options1 = {
                flowAction: "DisplayLogOutErrorDuringCTILogout",
                displayMode: pega.api.ui.constants.MODAL_DIALOG,
                event: event,
                flowActionClass: "CPM-Portal",
            };
            pega.api.ui.actions.launchLocalAction(options1);
        },
        CTILogoutWithReasonCodes: function(isConfirmationRequired, logoutMsg, confirmMsg, agentID, agentStatus, event,
            ReasonCodes) {
            var confirmLogout_cti = true;
            if( ((isConfirmationRequired === true) || (isConfirmationRequired.toLowerCase() === "true")) && ReasonCodes!== "" && ReasonCodes!== "Select") {
                confirmLogout_cti = confirm(logoutMsg + "\n" + "\n" + confirmMsg);
                confirmlogout_userchoice = confirmLogout_cti;
            }
            if (confirmlogout_userchoice) {
                if ((agentID !== undefined && agentID !== "") && pega.cti != null && pega.cti.API != null && (
                        agentStatus !== undefined && agentStatus !== "" && agentStatus !== "Logout")) {
                    var options = new Object();
                    pega.cti.API.logout(agentID, ReasonCodes, options, function() {
                        pega.cpm.menuActions.portalLogOff(isConfirmationRequired, logoutMsg, confirmMsg,
                            confirmlogout_userchoice,event);
                    }, function(response) {
                        if (response !== "" && response.hasOwnProperty("errMessage") && response.errMessage !==
                            "") {
                            pega.cpm.menuActions.OpenModalonFailureForCTILogout(event);
                        }
                    });
                }
            }
        },
        pegaCallEmulator: function() {
            var sUniqueId = "pegaCall" + pega.cpm.tabbedInterface.getUniqueCount();
            pega.cpm.tabbedInterface.createNewTab("pegaCall", "CPM-Portal.DisplayCallChatEmulator", sUniqueId);
            pega.cpm.tabbedInterface.selectTab(sUniqueId);
        },
        pegaCallChatEvents: function() {
            var sUniqueId = "pegaCall" + pega.cpm.tabbedInterface.getUniqueCount();
            pega.cpm.tabbedInterface.createNewTab("pegaCall", "CPM-Portal.DisplayCallChatEvents", sUniqueId);
            pega.cpm.tabbedInterface.selectTab(sUniqueId);
        },
        pegaPayloadEvents: function() {
            var sUniqueId = "pegaCall" + pega.cpm.tabbedInterface.getUniqueCount();
            pega.cpm.tabbedInterface.createNewTab("pegaCall", "CPM-Portal.DisplayPayloadEvents", sUniqueId);
            pega.cpm.tabbedInterface.selectTab(sUniqueId);
        },
        // this display will show an example of how to reload an interaction tab with a different activity
        pegaRedloadInteraction: function() {
            var sUniqueId = "pegaReload" + pega.cpm.tabbedInterface.getUniqueCount();
            var applicationSettings = CPMGetDynamicReference();
            pega.cpm.tabbedInterface.createNewTab("customer", "@baseclass.DisplayStream&StreamClass=" +
                applicationSettings.SiteSpecificClassGroup + "&StreamName=pegaReloadInteraction", sUniqueId);
            pega.cpm.tabbedInterface.selectTab(sUniqueId);
        },
        // this display will show an example of how to reload a work tab with a different activity
        pegaRedloadWork: function() {
            var sUniqueId = "pegaReload" + pega.cpm.tabbedInterface.getUniqueCount();
            var applicationSettings = CPMGetDynamicReference();
            pega.cpm.tabbedInterface.createWorkTab(sUniqueId, "@baseclass.DisplayStream&StreamClass=" +
                applicationSettings.SiteSpecificClassGroup + "&StreamName=pegaReloadWork");
            pega.cpm.tabbedInterface.selectTab(sUniqueId);
        },
        operatorPreferences: function() {
            oSafeUrl = new SafeURL("@baseclass.CALaunchUserPreferencesThread");
            window.open(oSafeUrl.toURL(), "UserPreferences", "width=600" + pega.cpm.UNITS + ",height=650" + pega.cpm
                .UNITS);
            oSafeUrl.nullify();
        },
        clipboard: function() {
            // Clipboard functionality changed to CPM's UserMenu Nav File, which replicates PRPC's Designer Studio Clipboard feature
            //var oSafeURL= new SafeURL();
            //oSafeURL.put("pyStream","WebWBClipboard");
            //var popupWindowFeatures= "menubar=no,location=no,status=no,titlebar=no,toolbar=no,scrollbars=yes,resizable=yes,height=450"+pega.cpm.UNITS+",width=600"+pega.cpm.UNITS;
            //openUrlInWindow(oSafeURL,"WebWBClipboard",PopupWindowFeatures);       
        },
        testTabNav: function() {
            var sUniqueId = "pegaCall" + pega.cpm.tabbedInterface.getUniqueCount();
            var applicationSettings = CPMGetDynamicReference();
            pega.cpm.tabbedInterface.createNewTab("pegaCall", applicationSettings.SiteSpecificClassGroup +
                ".testShowCPMTabHarness", sUniqueId);
            pega.cpm.tabbedInterface.selectTab(sUniqueId);
        },
        /* KEEP THIS AS THE LAST FUNCTION */
        _lastFunction: function() {}
    }
    //Dynamic Class Reference by getting the JSON object of Declare_CAApplicationSettings Data page
function CPMGetDynamicReference() {
    var recentUrl = new SafeURL("@baseclass.CPMGetDynamicReferenceActivity");
    pega.u.d.asyncRequest('GET', SafeURL_createFromURL(recentUrl.toURL()), {
        success: function(respObject) {
            var applicationSettings = JSON.parse(respObject.responseText);
            return applicationSettings;
        },
        failure: function() {
            console.log("failed");
        },
        scope: this
    }, null);
}
//returns the xmlhttpobject dpending upon different browsers
function returnXMLHttpObj() {
    var request = null;
    if (window.XMLHttpRequest) {
        //For Non IE Browser
        request = new XMLHttpRequest();
    } else if (window.ActiveXObject) {
        //For IE Browser
        try {
            request = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (e1) {
            try {
                request = new ActiveXObject("MSXML2.XMLHTTP");
            } catch (e2) {
                try {
                    request = new ActiveXObject("MSXML3.XMLHTTP");
                } catch (e3) {
                    alert("Create Ajax Failed!" + e3)
                }
            }
        }
    }
    return request;
}

//static-content-hash-trigger-GCC
/* chat functionality */

function setChatAvailable() {
	
	var oEvent = new Object();
	oEvent.EventName="Ready";
	oEvent.AgentID="";
	oEvent.WorkMode="";
	oEvent.ReasonCode="";
	oEvent.Media="Chat";
	
	var sEvent = serialize(oEvent);
	sendEvent("ChannelAgentStateEvent", sEvent);
	oEvent = null;
}

function setChatNotAvailable() {

	var oEvent = new Object();
	oEvent.EventName="NotReady";
	oEvent.AgentID="";
	oEvent.WorkMode="";
	oEvent.ReasonCode="";
	oEvent.Media="Chat";
	
	var sEvent = serialize(oEvent);
	sendEvent("ChannelAgentStateEvent", sEvent);
	oEvent = null;
}

function setChatLogout() {
	
	var oEvent = new Object();
	oEvent.EventName="Logout";
	oEvent.AgentID="";
	oEvent.WorkMode="";
	oEvent.ReasonCode="";
	oEvent.Media="Chat";
	
	var sEvent = serialize(oEvent);
	sendEvent("ChannelAgentStateEvent", sEvent);
	oEvent = null;
}


function setChatLogin() {

	var oEvent = new Object();
	oEvent.EventName="Login";
	oEvent.AgentID="";
	oEvent.WorkMode="";
	oEvent.ReasonCode="";
	oEvent.Media="Chat";
	
	var sEvent = serialize(oEvent);
	sendEvent("ChannelAgentStateEvent", sEvent);
	oEvent = null;
}



/* call functionality */

function setCallAvailable() {
	
	var oEvent = new Object();
	oEvent.EventName="Ready";
	oEvent.AgentID="";
	oEvent.WorkMode="";
	oEvent.ReasonCode="";
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);
	sendEvent("ChannelAgentStateEvent", sEvent);
	oEvent = null;
}


function setCallAfterCall() {

	var oEvent = new Object();
	oEvent.EventName="AfterCall";
	oEvent.AgentID="";
	oEvent.WorkMode="";
	oEvent.ReasonCode="";
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);

	sendEvent("ChannelAgentStateEvent", sEvent);

	oEvent = null;


}

function setCallUnavailable() {

	
	var sValue = "";
	if(document.getElementById("testUnavailableValues") != null )
	{
		sValue = document.getElementById("testUnavailableValues").value; 
	}
	var oEvent = new Object();
	oEvent.EventName="NotReady";
	oEvent.AgentID="";
	oEvent.WorkMode="";
	oEvent.ReasonCode=sValue;
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);

	sendEvent("ChannelAgentStateEvent", sEvent);

	oEvent = null;
}

function setCallLogout() {

	var oEvent = new Object();
	oEvent.EventName="Logout";
	oEvent.AgentID="";
	oEvent.WorkMode="";
	oEvent.ReasonCode="";
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);
	sendEvent("ChannelAgentStateEvent", sEvent);
	oEvent = null;
}


function setCallLogin() {

	var oEvent = new Object();
	oEvent.EventName="Login";
	oEvent.AgentID="";
	oEvent.WorkMode="";
	oEvent.ReasonCode="";
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);
	sendEvent("ChannelAgentStateEvent", sEvent);
	oEvent = null;
}







function setCallRinging() {
	var sId = document.getElementById("testCallId").value;
	var sOtherDN = document.getElementById("testOtherDN").value;
	var sOtherDNName = document.getElementById("testOtherDNName").value;


	var oEvent = new Object();
	oEvent.EventName="Alerting";
	oEvent.CallId= sId;
	oEvent.OtherDN= sOtherDN;
	oEvent.OtherDNName= sOtherDNName;
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);

	sendEvent("ChannelCallStateEvent", sEvent);

	oEvent = null;

}

function setCallHold() {
	var sId = document.getElementById("testCallId").value;
	var sOtherDN = document.getElementById("testOtherDN").value;
	var sOtherDNName = document.getElementById("testOtherDNName").value;


	var oEvent = new Object();
	oEvent.EventName="Held";
	oEvent.CallId= sId;
	oEvent.OtherDN= sOtherDN;
	oEvent.OtherDNName= sOtherDNName;
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);

	sendEvent("ChannelCallStateEvent", sEvent);

	oEvent = null;

}

function setCallConnected() {
	var sId = document.getElementById("testCallId").value;
	var sOtherDN = document.getElementById("testOtherDN").value;
	var sOtherDNName = document.getElementById("testOtherDNName").value;


	var oEvent = new Object();
	oEvent.EventName="Connected";
	oEvent.CallId= sId;
	oEvent.OtherDN= sOtherDN;
	oEvent.OtherDNName= sOtherDNName;
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);

	sendEvent("ChannelCallStateEvent", sEvent);

	oEvent = null;

}

function setCallEstablished() {
	var sId = document.getElementById("testCallId").value;
	var sOtherDN = document.getElementById("testOtherDN").value;
	var sOtherDNName = document.getElementById("testOtherDNName").value;


	var oEvent = new Object();
	oEvent.EventName="Established";
	oEvent.CallId= sId;
	oEvent.OtherDN= sOtherDN;
	oEvent.OtherDNName= sOtherDNName;
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);

	sendEvent("ChannelCallStateEvent", sEvent);

	oEvent = null;
}

function setCallDisconnected() {
	var sId = document.getElementById("testCallId").value;
	var sOtherDN = document.getElementById("testOtherDN").value;
	var sOtherDNName = document.getElementById("testOtherDNName").value;


	var oEvent = new Object();
	oEvent.EventName="Disconnected";
	oEvent.CallId= sId;
	oEvent.OtherDN= sOtherDN;
	oEvent.OtherDNName= sOtherDNName;
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);

	sendEvent("ChannelCallStateEvent", sEvent);

	oEvent = null;

}

function setCallAbandoned() {
	var sId = document.getElementById("testCallId").value;
	var sOtherDN = document.getElementById("testOtherDN").value;
	var sOtherDNName = document.getElementById("testOtherDNName").value;


	var oEvent = new Object();
	oEvent.EventName="Abandoned";
	oEvent.CallId= sId;
	oEvent.OtherDN= sOtherDN;
	oEvent.OtherDNName= sOtherDNName;
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);

	sendEvent("ChannelCallStateEvent", sEvent);

	oEvent = null;

}


function setCallDiverted() {
	var sId = document.getElementById("testCallId").value;
	var sOtherDN = document.getElementById("testOtherDN").value;
	var sOtherDNName = document.getElementById("testOtherDNName").value;


	var oEvent = new Object();
	oEvent.EventName="Diverted";
	oEvent.CallId= sId;
	oEvent.OtherDN= sOtherDN;
	oEvent.OtherDNName= sOtherDNName;
	oEvent.Media="Phone";

	var sEvent = serialize(oEvent);

	sendEvent("ChannelCallStateEvent", sEvent);

	oEvent = null;

}

function changeStatus( media , eventTypeClass ){

	var oE1 = document.getElementById(media);
	if(oE1 != null){
		var oE2 = pega.util.Dom.getElementsById('ItemMiddle',oE1,"SPAN")[0];
		if(oE2 != null){
			oE2.innerHTML = '<span class="'+eventTypeClass+'"></span>';
		}
	}
}
if (typeof(cti) == "undefined") {
    cti = {};
}
if (typeof(cti.util) == "undefined") {
    cti.util = {};
}
cti.util.bind = function(fn, obj) {
    return function() {
        fn.call(obj, [].slice.call(arguments, 2));
    }
}
cti.util.Timer = function(lStartTime, sTimerContainerDivName, bStartTimer, refreshRate, oThresholds, oActionHandler) {
    // Setting the active time to display only for active timer
    cti.ActiveTimer = this;
    this._lStartTime = lStartTime;
    if ((this._lStartTime == -1) || (isNaN(this._lStartTime))) {
        this._lStartTime = new Date().getTime();
    }
    this._lEndTime = -1;
    this._sTimerContainerDivName = sTimerContainerDivName;
    this._oTimerContainerDiv = pega.util.Dom.get(sTimerContainerDivName);
    this._oThresholds = oThresholds;
    if (typeof oActionHandler != "undefined") this._oActionHandler = oActionHandler;
    else this._oActionHandler = new DefaultTimerActionHandler();
    this._oActionHandler.setTimerContainerDiv(this._oTimerContainerDiv);
    this._oActionHandler.setThresholds(this._oThresholds);
    this._oActionHandler.setId(sTimerContainerDivName);
    this._oActionHandler.setRefreshRate(refreshRate);
    this._timer = null;
    if (bStartTimer) this._timer = setInterval(cti.util.bind(this.handleTimer, this), refreshRate);
}
cti.util.Timer.prototype.init = function() {
    if (typeof(this._timer) == "undefined") this._timer = setInterval(cti.util.bind(this.handleTimer, this),
        refreshRate);
    else {
        this._timer = setInterval(cti.util.bind(this.handleTimer, this), refreshRate);
    }
}
cti.util.Timer.prototype.setEndTime = function(lEndTime) {
    this._lEndTime = lEndTime;
}
cti.util.Timer.prototype.cancelTimer = function() {
    clearInterval(this._timer);
}
cti.util.Timer.getTimeComponents = function(lMilliseconds) {
    var seconds = Math.floor(lMilliseconds / 1000);
    var d = Math.floor(seconds / 86400);
    var h = Math.floor((seconds - (d * 86400)) / (3600));
    var m = Math.floor((seconds - (d * 86400) - (h * 3600)) / 60);
    var s = seconds - (d * 86400) - (h * 3600) - (m * 60);
    var oTime = new Object();
    oTime.days = d;
    oTime.hours = h;
    oTime.minutes = m;
    oTime.seconds = s;
    oTime.totalTime = seconds;
    return (oTime);
}
cti.util.pad0 = function(lSeconds) {
    if (isNaN(lSeconds)) {
        lSeconds = 0;
    }
    return (lSeconds < 10 ? (lSeconds <= 0 ? "00" : "0" + lSeconds) : "" + lSeconds);
}
cti.util.Timer.prototype.handleTimer = function() {
  /** BUG-344824 - START **/
  if(window.parent != null && window.frameElement && window.frameElement.parentElement && window.frameElement.parentElement.style && window.frameElement.parentElement.style.display === 'none'){
    return;
  }
  /** BUG-344824 - END **/
  var oTimeComponents = null;
  var lCurrTime = this._lEndTime;
  if (lCurrTime == -1) lCurrTime = new Date().getTime();
  if (typeof serverClientTimeDifference != "undefined" && serverClientTimeDifference) oTimeComponents = cti.util.Timer
    .getTimeComponents(lCurrTime - this._lStartTime + (serverClientTimeDifference));
  else oTimeComponents = cti.util.Timer.getTimeComponents(lCurrTime - this._lStartTime);
  this._oActionHandler.handleTimer(oTimeComponents);
  if (this._lEndTime != -1) this.cancelTimer();
}
    /*
      Assumes Timer format as so:
      oTimerContainerDiv:<div> 
                            <elem id=timerIcon/>
                            <elem id=elapseTime/>
                            <elem id=goalTime/>
                          <div>
    */
DefaultTimerActionHandler = function() {
    this._oTimerContainerDiv = null;
    this._sTimerId;
    this._sIconElem = "timerIcon";
    this._sElapsed = "elapsedTime";
    this._sGoalTime = "goalTime";
    this._iconClassGoal = 'iconCTITimerGoal';
    this._iconClassDeadline = 'iconCTITimerDeadline';
    this._iconClassLate = 'iconCTITimerLate';
    this._elapsedClassGoal = 'elapsedCTITimerGoal';
    this._elapsedClassDeadline = 'elapsedCTITimerDeadline';
    this._elapsedClassLate = 'elapsedCTITimerLate';
    this._goalClass = "timerGoal";
}
DefaultTimerActionHandler.prototype.setTimerContainerDiv = function(oTimerContainerDiv) {
    this._oTimerContainerDiv = oTimerContainerDiv;
}
DefaultTimerActionHandler.prototype.setThresholds = function(oThresholds) {
    this._oThresholds = oThresholds;
}
DefaultTimerActionHandler.prototype.setId = function(sId) {
    this._sTimerId = sId;
}
DefaultTimerActionHandler.prototype.setRefreshRate = function(refreshRate) {
        this._refreshRate = refreshRate;
    }
    /*
      oTimeComponents: {days: d, hours: h,minutes:m,seconds:s, totalSeconds:seconds};
    */
DefaultTimerActionHandler.prototype.handleTimer = function(oTimeComponents) {
    if (cti && cti.ActiveTimer && cti.ActiveTimer._oActionHandler == this) {
        if (oTimeComponents.totalTime <= this._oThresholds.goal) {
            this.setGoalDisplay(oTimeComponents);
            this.setAngleTimeCircle(oTimeComponents.totalTime, this._oThresholds.goal);
        } else if (oTimeComponents.totalTime < this._oThresholds.deadline) {
            this.setDeadlineDisplay(oTimeComponents);
            this.setAngleTimeCircle(oTimeComponents.totalTime - this._oThresholds.goal, this._oThresholds.deadline -
                this._oThresholds.goal);
        } else {
            this.setLateDisplay(oTimeComponents);
            this.setAngleTimeCircle(oTimeComponents.totalTime, this._oThresholds.deadline);
        }
    }
}
DefaultTimerActionHandler.prototype.setGoalDisplay = function(oTimeComponents) {
    var sId = this._oTimerContainerDiv.id;
    var oDiv = document.getElementById(this._sTimerId);
    if (oDiv != null) {
        var oTimerIcon = pega.util.Dom.getElementsById(this._sIconElem, oDiv)[0];
        var oElapsedContainer = pega.util.Dom.getElementsById(this._sElapsed, oDiv)[0];
        var oGoalContainer = pega.util.Dom.getElementsById(this._sGoalTime, oDiv)[0];
        oTimerIcon.className = this._iconClassGoal;
        if (oTimeComponents.days != 0) {
            var sTime = oTimeComponents.days+"d " + cti.util.pad0(oTimeComponents.hours) + ":" + cti.util.pad0(oTimeComponents.minutes) + ":" +
                cti.util.pad0(oTimeComponents.seconds);
        } else if (oTimeComponents.hours != 0) {
            var sTime = cti.util.pad0(oTimeComponents.hours) + ":" + cti.util.pad0(oTimeComponents.minutes) + ":" +
                cti.util.pad0(oTimeComponents.seconds);
        } else {
            var sTime = cti.util.pad0(oTimeComponents.minutes) + ":" + cti.util.pad0(oTimeComponents.seconds);
        }
        pega.util.Dom.setInnerText(oElapsedContainer, sTime);
        oElapsedContainer.className = this._elapsedClassGoal;
        oElapsedContainer.style.display = "inline-block";
    }
  $(".cs_timer_control").removeClass("cs_timer_on_goal cs_timer_on_deadline cs_timer_deadline_exceed").addClass("cs_timer_on_goal");
//Adding change to not show tooltip when sla timer is hidden for BUG-559150
  if(typeof document.getElementById("showTimer") !== "undefined" && document.getElementById("showTimer") !== null){
      var title =   document.getElementById("showTimer").value;
      if(title.includes("showTimer"))
         $(".cs_timer_control").attr('title',$(oElapsedContainer).text()+"/"+$(oGoalContainer).text());
  }
      var csTimerTotal = document.getElementById('cs-timer-total');
      if(csTimerTotal != null) {
        csTimerTotal.setAttribute("stroke", "#6DDDC2");
     
  }
}
DefaultTimerActionHandler.prototype.setDeadlineDisplay = function(oTimeComponents) {
    var sId = this._oTimerContainerDiv.id;
    var oDiv = document.getElementById(this._sTimerId);
    if (oDiv != null) {
        var oTimerIcon = pega.util.Dom.getElementsById(this._sIconElem, oDiv)[0];
        var oElapsedContainer = pega.util.Dom.getElementsById(this._sElapsed, oDiv)[0];
        var oGoalContainer = pega.util.Dom.getElementsById(this._sGoalTime, oDiv)[0];
        oTimerIcon.className = this._iconClassDeadline;
        if (oTimeComponents.days != 0) {
            var sTime = oTimeComponents.days+"d " + cti.util.pad0(oTimeComponents.hours) + ":" + cti.util.pad0(oTimeComponents.minutes) + ":" +
                cti.util.pad0(oTimeComponents.seconds);
        } else if (oTimeComponents.hours != 0) {
            var sTime = cti.util.pad0(oTimeComponents.hours) + ":" + cti.util.pad0(oTimeComponents.minutes) + ":" +
                cti.util.pad0(oTimeComponents.seconds);
        } else {
            var sTime = cti.util.pad0(oTimeComponents.minutes) + ":" + cti.util.pad0(oTimeComponents.seconds);
        }
        pega.util.Dom.setInnerText(oElapsedContainer, sTime);
        oElapsedContainer.className = this._elapsedClassDeadline;
        oElapsedContainer.style.display = "inline-block";
    }
    $(".cs_timer_control").removeClass("cs_timer_on_goal cs_timer_on_deadline cs_timer_deadline_exceed").addClass("cs_timer_on_deadline");
  //Adding change to not show tooltip when sla timer is hidden for BUG-559150
  if(typeof document.getElementById("showTimer") !== "undefined" && document.getElementById("showTimer") !== null){
      var title =   document.getElementById("showTimer").value;
      if(title.includes("showTimer"))
         $(".cs_timer_control").attr('title',$(oElapsedContainer).text()+"/"+$(oGoalContainer).text());
  }
      var csTimerTotal = document.getElementById('cs-timer-total');
      if(csTimerTotal != null) {
        csTimerTotal.setAttribute("stroke", "#F4BF7E");
      
    }
}
DefaultTimerActionHandler.prototype.setAngleTimeCircle = function(currentTime, totalTime) {
    var circle = document.getElementById('cs-timer-circle');
    if (circle !== null) {
        var radius = circle.getAttribute('r');
        var circum = Math.PI * (radius * 2);
        var angle_increment = 100 / (totalTime / (this._refreshRate / 1000));
        var angle = 100 - currentTime * angle_increment;
        circle.setAttribute("stroke-dasharray", ((100 - angle) / 100) * circum + ", 20000");
    }
}
DefaultTimerActionHandler.prototype.setLateDisplay = function(oTimeComponents) {
    var sId = this._oTimerContainerDiv.id;
    var oDiv = document.getElementById(this._sTimerId);
    if (oDiv != null) {
        var oTimerIcon = pega.util.Dom.getElementsById(this._sIconElem, oDiv)[0];
        var oElapsedContainer = pega.util.Dom.getElementsById(this._sElapsed, oDiv)[0];
        var oGoalContainer = pega.util.Dom.getElementsById(this._sGoalTime, oDiv)[0];
        oTimerIcon.className = this._iconClassLate;
        if (oTimeComponents.days != 0) {
            var sTime = oTimeComponents.days+"d " + cti.util.pad0(oTimeComponents.hours) + ":" + cti.util.pad0(oTimeComponents.minutes) + ":" +
                cti.util.pad0(oTimeComponents.seconds);
        } else if (oTimeComponents.hours != 0) {
            var sTime = cti.util.pad0(oTimeComponents.hours) + ":" + cti.util.pad0(oTimeComponents.minutes) + ":" +
                cti.util.pad0(oTimeComponents.seconds);
        } else {
            var sTime = cti.util.pad0(oTimeComponents.minutes) + ":" + cti.util.pad0(oTimeComponents.seconds);
        }
        pega.util.Dom.setInnerText(oElapsedContainer, sTime);
        oElapsedContainer.className = this._elapsedClassLate;
        oElapsedContainer.style.display = "inline-block";
    }
    $(".cs_timer_control").removeClass("cs_timer_on_goal cs_timer_on_deadline cs_timer_deadline_exceed").addClass("cs_timer_deadline_exceed");
  //Adding change to not show tooltip when sla timer is hidden for BUG-559150
  if(typeof document.getElementById("showTimer") !== "undefined" && document.getElementById("showTimer") !== null){
     var title =   document.getElementById("showTimer").value;
     if(title.includes("showTimer"))
//Making change to show proper tooltip value past reaching the deadline of the CTI call timer for Bug-755361
        $(".cs_timer_control").attr('title',$(oElapsedContainer).text()+"/"+$(oGoalContainer).text());
  }
    var csTimerTotal = document.getElementById('cs-timer-total');
    if(csTimerTotal!= null){
      csTimerTotal.setAttribute("stroke", "#EF85B3");
    
    }
}
//static-content-hash-trigger-YUI
/*

The variable sCPMEventContextId is used to seperate events that fire from one tab context from affecting another.  
In the composite portal world different tabs share the same event management context.  


*/

/* Added for globalisation of units */
if (!pega)
  	var pega = {};
if (!pega.cpm)
  	pega.cpm = {};
if(!pega.cpm.UNITS)
           pega.cpm.UNITS = "px";
/* End */


//***********************************************************
// Event Listener Object
//***********************************************************

/*
@constructor
@protected - Object representing a single listener to an event.
@param $Object$objFunction – function to invoke when event occurs.
@param $Object$objData – data to pass along to the function.
@return $void$- .
*/
function CPMEventListener(objFunction, objData ,scope) 
{
	this.eventFunction= objFunction;
	this.data= objData;
	this.execute= CPMEventListener_executeFunction;
	this.scope= scope;
}

/*@protected
 * Executes a listening function 
 * @param objEventData - data about the event (passed from sendEvent)
 * @param curEventName– parameter description goes here.
 * @param objEventData– parameter description goes here.
 * @return $boolean$ false if calling function failed, otherwise true
 **/


function CPMEventListener_executeFunction(objEventData) {
	var result= true;
	try {
		if(this.scope){
			this.eventFunction.call(this.scope,objEventData,this.data);
		}else this.eventFunction(objEventData,this.data);
	}
	catch (exception) {
		result= false;
	}
	return result;
}



function determineCPMEventContextId() {


	// if calling from a popup window, the tab contexts is in the window.opener.
	if (window.opener) {
		if (window.opener.pega.cpm ) {
   			if( window.opener.pega.cpm.tabbedInterface ){ 
     				return window.opener.pega.cpm.tabbedInterface.getCorrespondingTabIdFromInteraction(window.opener.document.body);
  			} 
			else {
    				return "";
   			}
		} 
		else {
  			return "";
		}

	}
	else {

		if ( pega.cpm ) {
   			if( pega.cpm.tabbedInterface ){ 
     				return pega.cpm.tabbedInterface.getCorrespondingTabIdFromInteraction(document.body);
   			} 
			else {
    				return "";
   			}
		} 
		else {
  			return "";
		}

	}

}

function filterEvent(oEventData, oEventListenerContainer) {

    if(oEventData) 
       if(oEventData.sCPMEventContextId == oEventListenerContainer.sContextId)
           oEventListenerContainer.oEventListener.execute(oEventData.oParams);
}

var eventsRegistered = new Array();

function registerForCPMEvent(strEventName, objFunction, objData ,scope  ) {

var tobj = {};
    tobj.sContextId = determineCPMEventContextId();
    tobj.oEventListener = new CPMEventListener(objFunction,objData,scope);
eventsRegistered.push( strEventName );

registerEventListener (strEventName, filterEvent, tobj)

}



function sendCPMEvent (strEventName, objEventData,mode,delay) {

var oTObj = {};
    oTObj.sCPMEventContextId = determineCPMEventContextId();
    oTObj.oParams = objEventData;


    sendEvent(strEventName,oTObj,mode,delay);    
}



/*********************
 * Event Types
 *********************/
var LOAD_INTERACTIONDRIVER = "pega.framework.cpm.6.interactiondriver.load";
var CLOSETAB_TABBEDNAVIGATION = "pega.framework.cpm.6.tabbednavigation.closetab";
var UPDATETABLABEL_TABBEDNAVIGATION = "pega.framework.cpm.6.tabbednavigation.updatetablabel";

var TABBEDNAVIGATION_PROCESSTABCLOSED= "pega.framework.cpm.6.tabbednavigation.processtabclosed";
var TABBEDNAVIGATION_PROCESSTABLOADED= "pega.framework.cpm.6.tabbednavigation.processtabloaded";

var TABBEDNAVIGATION_OPENCOMPOSITETAB= "pega.framework.cpm.6.tabbednavigation.opencompositetab";
var TABBEDNAVIGATION_OPENASSIGNMENT= "pega.framework.cpm.6.tabbednavigation.openassignment";

var TABBEDNAVIGATION_STARTNEWPROCESS_SPECIFICTASK= "pega.framework.cpm.6.tabbednavigation.startprocess.specifictask";
var TABBEDNAVIGATION_STARTTASK_BY_KEYS= "pega.framework.cpm.6.tabbednavigation.starttask.bykeys";
var TABBEDNAVIGATION_REVIEW_ITEM= "pega.framework.cpm.6.tabbednavigation.reviewworkitem";
var TABBEDNAVIGATION_REVIEW_CURRENT_ITEM= "pega.framework.cpm.6.tabbednavigation.reviewcurrentworkitem";
var TABBEDNAVIGATION_REVIEW_OR_PROCESS_ITEM= "pega.framework.cpm.6.tabbednavigation.revieworprocessworkitem";
var TABBEDNAVIGATION_TAB_IN_FOCUS = "pega.framework.cpm.6.tabbednavigation.tabinfocus";
var TABBEDNAVIGATION_TRIGGER_TAB_IN_FOCUS_EVENT = "pega.framework.cpm.6.tabbednavigation.trigger.tabinfocus";
var TABBEDNAVIGATION_ACTIONLOADED = "pega.framework.cpm.6.tabbednavigation.actionloaded";
var TABBEDNAVIGATION_FOCUS_TAB_BY_TABID ="pega.framework.cpm.6.tabbednavigation.focustabbytabid";
var TABBEDNAVIGATION_END_INTERACTION ="pega.framework.cpm.6.tabbednavigation.endinteraction";
var TABBEDNAVIGATION_NPROCESSTABS ="pega.framework.cpm.6.tabbednavigation.nprocesstabs";
var TABBEDNAVIGATION_FORCE_TABCOUNT_EVENT="pega.framework.cpm.6.tabbednavigation.forcetabcountevent";

var TABBEDNAVIGATION_NCOMPOSITETABS ="pega.framework.cpm.6.tabbednavigation.ncompositetabs";
var TABBEDNAVIGATION_FORCE_COMPOSITETABCOUNT_EVENT="pega.framework.cpm.6.tabbednavigation.forcecompositetabcountevent";
var CPM_HARNESS_LOADED = "pega.framework.cpm.harness.loaded";

var NAVIGATION_SETTING_CHANGE ="pega.framework.cpm.6.navigation.navigationsettingchanged";


var REFRESH_COMPOSITE = "pega.framework.cpm.customercomposite.refresh";
var RELOAD_COMPOSITE  = "pega.framework.cpm.customercomposite.reload";
var COMPOSITE_LOADED  = "pega.framework.cpm.customercomposite.loaded";
var COMPOSITE_SHRINK  = "pega.framework.cpm.customercomposite.minimize";
var COMPOSITE_ENLARGE = "pega.framework.cpm.customercomposite.maximize";
var COMPOSITE_RESET   = "pega.framework.cpm.customercomposite.defaultsize";

var INTERACTIONDRIVER_LOADED = "pega.framework.cpm.interactiondriver.loaded";
var INTERACTIONDRIVER_UNLOADED = "pega.framework.cpm.interactiondriver.unloaded";
var INTERACTIONDRIVER_INVALIDATE_TASKS = "pega.framework.cpm.interactiondriver.invalidate";
var INTERACTIONDRIVER_CHECKIFEXISTS = "pega.framework.cpm.interactiondriver.checkexists";
var INTERACTIONDRIVER_EXISTS = "pega.framework.cpm.interactiondriver.exists";
var INTERACTIONDRIVER_CATEGORIESLOADED = "pega.framework.cpm.interactiondriver.categoriesloaded";
var INTERACTIONDRIVER_PAUSE = "pega.framework.cpm.interactiondriver.pause";

var CLEAR_INTERACTIONDRIVER = "pega.framework.cpm.6.interactiondriver.clear";
var START_TABBEDTASK ="pega.framework.cpm.6.interactiondriver.starttabbedtask";
var START_TABDEPENDANTTASK ="pega.framework.cpm.6.interactiondriver.starttabdependanttask";

var REFRESH_CONTACTINFORMATION = "pega.framework.cpm.contactinformation.refresh";
var REFRESH_INTERACTIONLOG = "pega.framework.cpm.runtimeinteractionlog.refresh";

var KNOWLEDGECONTENT_LOADED = "pega.framework.cpm.knowledgecontent.loaded";
var DIALOG_REFRESH = "pega.framework.cpm.6.dialog.refresh";
var COACHINGTIP_REFRESH = "pega.framework.cpm.6.cochingtip.refresh";

var HOTKEY_TASK_EVENT = "pega.framework.cpm.hotkey";
var RELOAD_DRIVERANDSUGGESTIONS="pega.framework.cpm.customercomposite.reloaddriverandsuggestion";

function EventMGMT_TaskHotKey(sTaskCategory,sTaskName){
   sendCPMEvent(HOTKEY_TASK_EVENT,{TaskCategory:sTaskCategory,TaskName:sTaskName},SYNC);
}

function EventMGMT_ForceTabCountEvent() {
  sendCPMEvent(TABBEDNAVIGATION_FORCE_TABCOUNT_EVENT,null,ASYNC,15);
}

function EventMGMT_ForceCompositeTabCountEvent() {
  sendCPMEvent(TABBEDNAVIGATION_FORCE_COMPOSITETABCOUNT_EVENT,null,ASYNC,15);
}

function EventMGMT_NProcessTabs(oParams){
  sendCPMEvent(TABBEDNAVIGATION_NPROCESSTABS,oParams,ASYNC,15);
}

function EventMGMT_NCompositeTabs(oParams){
  sendCPMEvent(TABBEDNAVIGATION_NCOMPOSITETABS,oParams,ASYNC,15);
}


function EventMGMT_EndInteraction(oParams) {
  sendCPMEvent(TABBEDNAVIGATION_END_INTERACTION,oParams,ASYNC,15);
}

function EventMGMT_NavSettingChanged(oSettings) {
  sendCPMEvent(NAVIGATION_SETTING_CHANGE,oSettings,ASYNC,15);
} 

function EventMGMT_Trigger_FocusTabByID(sID) {
   sendCPMEvent(TABBEDNAVIGATION_FOCUS_TAB_BY_TABID,sID,ASYNC,15);
}

//used to determine which tab if anyu is currently in focus
function EventMGMT_Trigger_TabInFocus() {
   
   sendCPMEvent(TABBEDNAVIGATION_TRIGGER_TAB_IN_FOCUS_EVENT,null,ASYNC,15);
}

function EventMGMT_ActionLoaded(oTabData) {

    if (oTabData != null) {
	var oBody = document.body;
	var sInteractionId = pega.cpm.tabbedInterface.getCorrespondingTabIdFromInteraction(oBody);
	oTabData.TabInteractionId = sInteractionId;
    }

    /*
     oTabData is expected to contain
     This opens a new tab or refreshes the current tab

     {TabDesc: "blah",TabID:"?",TabType:"process/composite",TabTaskName:""}     
    */
   sendCPMEvent(TABBEDNAVIGATION_ACTIONLOADED,oTabData,ASYNC,15);
}

function EventMGMT_HarnessLoaded(oTabData) {
    /*
     oTabData is expected to contain
     This opens a new tab or refreshes the current tab
     {CPMURL, CPMURLLong }     
    */
 
  sendCPMEvent(CPM_HARNESS_LOADED,oTabData,ASYNC,15);
}



function EventMGMT_TabInFocus(oTabData) {
    /*
     oTabData is expected to contain
     This opens a new tab or refreshes the current tab

     {TabDesc: "blah",TabID:"?",TabType:"process/composite",TabTaskName:""}     
    */
 
  sendCPMEvent(TABBEDNAVIGATION_TAB_IN_FOCUS,oTabData,ASYNC,15);
}



function EventMGMT_OpenCompositeTab(oTabData) {
    /*
     oTabData is expected to contain
     This opens a new tab or refreshes the current tab

     {CategoryName: "blah",KeyOfItem:"key"}     
    */
   sendCPMEvent(TABBEDNAVIGATION_OPENCOMPOSITETAB,oTabData,SYNC,15);
}

function EventMGMT_OpenAssignment(oTabData) {
  sendCPMEvent(TABBEDNAVIGATION_OPENASSIGNMENT,oTabData,ASYNC,15);

}

function EventMGMT_StartNewProcessTab_SpecificTask(oTabData) {
/*
  oTabData is expected to 
  {TaskClass:"Category of task", TaskControlPage:"Page Name", TaskName:"Name of Task" }
*/
  sendCPMEvent(TABBEDNAVIGATION_STARTNEWPROCESS_SPECIFICTASK,oTabData,ASYNC,15);
}

function EventMGMT_StartNewTaskTab_ByKeys(oTabData) {
/*
  oTabData is expected to 
  {TaskClass:"Category of task", TaskControlPage:"Page Name", TaskName:"Name of Task" }
*/
  sendCPMEvent(TABBEDNAVIGATION_STARTTASK_BY_KEYS, oTabData, ASYNC, 15);
}

function EventMGMT_StartNewProcessTab_ReviewCurrentItem(oTabData) {
/*
  oTabData is expected to 
*/
  sendCPMEvent(TABBEDNAVIGATION_REVIEW_CURRENT_ITEM,oTabData,ASYNC,15);
}


function EventMGMT_StartNewProcessTab_ReviewItem(oTabData) {
/*
  oTabData is expected to 
  {Class:"Class of Item to Open", KeyOfItem:"", KeyIsHandle:"true/false" }
*/
  sendCPMEvent(TABBEDNAVIGATION_REVIEW_ITEM,oTabData,ASYNC,15);
}

function EventMGMT_StartNewProcessTab_ReviewOrProcess(oTabData) {
/*
  oTabData is expected to 
  {Class:"Class of Item to Open", KeyOfItem:"", KeyIsHandle:"true/false",Label:"tab label" }
*/
  sendCPMEvent(TABBEDNAVIGATION_REVIEW_OR_PROCESS_ITEM,oTabData,ASYNC,15);
}


function EventMGMT_StartTabDependantTask(oParams) {
    sendCPMEvent(START_TABDEPENDANTTASK,oParams,ASYNC,15);
}

function EventMGMT_ProcessTabLoaded(sSrcID,tabid, sThread) {
    if ( typeof(sSrcID) != "undefined") {
         var local_sSrcID = sSrcID;
	sendCPMEvent(TABBEDNAVIGATION_PROCESSTABLOADED,{sSrcID:local_sSrcID,TabUniqueID:tabid,  ThreadName: sThread},SYNC);
    } 
}

function EventMGMT_ProcessTabClosed(sSrcID,tabid) {
    if ( typeof(sSrcID) != "undefined") {
         var local_sSrcID = sSrcID;
	sendCPMEvent(TABBEDNAVIGATION_PROCESSTABCLOSED,{sSrcID:local_sSrcID,TabUniqueID:tabid },SYNC);
    } 
}

function EventMGMT_CloseTab(sGadgetID,sTabSubGroup) {

    if ( typeof(sGadgetID) != "undefined") {

	var sJSON = '{"EventType": "Busy"}';
	sendEvent("pega_ui_busyIndicator", sJSON, SYNC);

          var local_sGadgetID = sGadgetID;
	sendCPMEvent(CLOSETAB_TABBEDNAVIGATION,{sGadgetID:local_sGadgetID,SRC:sTabSubGroup}, ASYNC,15);
    }
}

function EventMGMT_UpdateTabLabel(oParams) {
sendCPMEvent(UPDATETABLABEL_TABBEDNAVIGATION,oParams, ASYNC,15);

}

function EventMGMT_KnowledgeContentLoaded(){
	sendCPMEvent(KNOWLEDGECONTENT_LOADED,null,ASYNC,15);
}

function EventMGMT_RefreshDialog(oParams){
	sendCPMEvent(DIALOG_REFRESH ,oParams, ASYNC,15);
}

function EventMGMT_RefreshCoachingTip(oParams){
	sendCPMEvent(COACHINGTIP_REFRESH ,oParams, ASYNC,15);
}


function EventMGMT_StartTabbedTask(oParams) {
  sendCPMEvent(START_TABBEDTASK ,oParams, ASYNC,10);
}

function EventMGMT_ClearInteractionDriver() {
  sendCPMEvent(CLEAR_INTERACTIONDRIVER,null,ASYNC,10);
}

function EventMGMT_LoadInteractionDriver() {
  sendCPMEvent(LOAD_INTERACTIONDRIVER,null,ASYNC,10);
}

// sMyID is used for targeted events
function EventMGMT_InteractionDriverCheckExists(sMyId) { 
  sendCPMEvent(INTERACTIONDRIVER_CHECKIFEXISTS, sMyId, ASYNC,10);
}

// sMyID is used for targeted events
function EventMGMT_InteractionDriverExists(sMyId) {
 sendCPMEvent(INTERACTIONDRIVER_EXISTS,sMyId,ASYNC,10);
}
//Syncronous event
function EventMGMT_InteractionDriverPause() {
  sendCPMEvent(INTERACTIONDRIVER_PAUSE,null,SYNC,10);
}

function EventMGMT_InteractionDriverLoaded() {
  sendCPMEvent(INTERACTIONDRIVER_LOADED,null,ASYNC,10);
}

function EventMGMT_InteractionDriverUnloaded() {
  sendCPMEvent(INTERACTIONDRIVER_UNLOADED,null,ASYNC,10);
}

function EventMGMT_InteractionDriverInvalidate() {
  sendCPMEvent(INTERACTIONDRIVER_INVALIDATE_TASKS ,null,ASYNC,10);
}

function EventMGMT_RefreshComposite() {
  sendCPMEvent(REFRESH_COMPOSITE,{bReload:false},ASYNC,10);
}

function EventMGMT_ReloadComposite() {
  sendCPMEvent(RELOAD_COMPOSITE,{bReload:true},ASYNC,10);
}


function EventMGMT_CompositeLoaded() {
  sendCPMEvent(COMPOSITE_LOADED,null,ASYNC,10);
}

function EventMGMT_RefreshContactInformation(){
  sendCPMEvent(REFRESH_CONTACTINFORMATION,null,ASYNC,10);
}

function EventMGMT_RefreshRuntimeInteractionLog(){
  sendCPMEvent(REFRESH_INTERACTIONLOG,null,ASYNC,10);
}

function cancelCPMEvents( eventName ) {
    if (eventName == null) {
       for (var i=0; i<eventsRegistered.length; i++) {
           cancelEventListener(eventsRegistered[i],filterEvent);
       }
    } else {
       cancelEventListener(eventName, filterEvent);
    }
}

function EventMGMT_ReloadTakeActionDriverAndSuggestions() {
  sendCPMEvent(RELOAD_DRIVERANDSUGGESTIONS,null,ASYNC,10);
}
//static-content-hash-trigger-YUI
/*@package
pega_cpm_localization.js
CPM Localization functions
*/

 
if (!pega)
  	var pega = {};


if (!pega.cpm)
  	pega.cpm = {};



// singleton functions
// This package provides localization for JS (alerts, messages, etc.)
// The array "pega_cpm_arLocalization" must already exist somewhere.  Generally this is found in a fragment (like CPMPortalLocalization), that is stream 
// processed with some default values (so don't have to go to server to get them.)
// If doesn't exist in your code, then you need to declare it (var pega_cpm_arLocalization = new Array();)
pega.cpm.localization = {
	

	/*
	@public - Get a localized string value.  Will see if in cache (array) first, if not, call the server.  Because may need to call server, this function is asynchronous and you will get the data back via a callback. If you are coding with packages (prototype, etc.), pass in "this" to the scope.
	@param $String$sClass - class of the field value, will default to CPM-Portal if none provided.
	@param $String$sProperty - property of the field value (pyMessageLabel, pyActionPrompt, etc.)
	@param $String$sValue - the string to be localized. Include "\t" if using parameters.
	@param $reference$oCallback - call back function.  Function should have one parameter (sLocalized) which will be the localized string
	@param $reference$scope - will generally be "this", so in packages and instantiation, "this.xxx" will work.
	@return $void$
	*/
	getLocalizedValue : function(sClass, sProperty, sValue, oCallback, scope) {


		if (sClass == null) {
			sClass = "CPM-Portal";
		}

		if (scope == null) {
			scope = window;
		}

		var sReturn = "";
		var sIndex = sClass + ":" + sProperty + ":" + sValue;


		// need the array "pega_cpm_arLocalization" to exist, generally put in a fragment that will be stream processed
		// with some default values.
		if (pega_cpm_arLocalization != null) {
			sReturn = pega_cpm_arLocalization[sIndex];

			if (sReturn == null) {

				arValues = sValue.split("\t");

				var oSafeUrl = new SafeURL("@baseclass.CPMGetLocalizedTextForString");
				oSafeUrl.put("AppliesTo", sClass);
				oSafeUrl.put("PropertyName", sProperty);
				oSafeUrl.put("StringToLocalize", arValues[0]);

				for (var el=1; el < arValues.length; el++) {
					oSafeUrl.put("s" + el, arValues[el]);
				}

				var _this = this;
				pega.u.d.asyncRequest("POST",
					oSafeUrl,
						{
							success:function(oResponse){
								sReturn = oResponse.responseText;
									// add to cache
								pega_cpm_arLocalization[sIndex] = sReturn;

								oCallback.call(scope, this._removeWhiteSpace(sReturn));


								},
							failure: function(){
								console.log("An error was encoutered while getting the localized version of "+arValues[0]+";Returning the non-localized version instead");
                                sReturn = arValues[0];
                                for (var el=1; el < arValues.length; el++) {
					                sReturn = sReturn.replace("{"+el+"}", arValues[el]);
				                }
                                oCallback.call(scope, this._removeWhiteSpace(sReturn));
						    },
							scope:this
						},
				"");



			}
			else {
				oCallback.call(scope, this._removeWhiteSpace(sReturn));

			}
			

		}


	},



	/*
	@private - Remove extra white spaces from a string.
	@param $String$str - string to remove the whitespaces.
	@return $String$ - string free of extra whitespaces.  
	*/
	_removeWhiteSpace: function (str) {
  		str = str.replace(/\s+/g, " ");
  		str = str.replace(/^\s(.*)/, "$1");
  		str = str.replace(/(.*)\s$/, "$1");		
		return (str);
	},




	_lastFunction: function() {


	}

}
//static-content-hash-trigger-YUI
/* ChatAgentEventHandler.JS - This file contains the code to handle the agent level chat events. This code runs in the Portal scope */

if (!pega)
  var pega = {};

if (!pega.chat)
  pega.chat = {};


pega.chat.chatEventHandler = function() {
  this.chatIntervalId = -1;
  this.chatHeartbeatInterval = 30000;
  this.interactionLoadingForChats = {};
  this.pendingChats = new Object();
  this.acceptPendingChats = new Object();
  this._monitoredChats = {};
  this._transferredChats = {};
  this._chatEventHandlerMap = {};
  var _interactionChatMap = sessionStorage.getItem("_interactionChatMap")
  _interactionChatMap = _interactionChatMap ? JSON.parse(_interactionChatMap) : {};
  this._interactionChatMap = _interactionChatMap;
  this._queuedEventsMap = {};
  this.acceptFailedChats = {};
  this._currentServerName = "";
  this._currentServerQueue = "";

  this._lastLoginChatEvent = null;
  this._lastStatusChatEvent = null;
  this.sOldQueue = "";
  this._chatInteractionHandlers = {
    "SendMsgToServer": this._sendMessageToServer.bind(this),
    "EndChat": this._endChat.bind(this),
    "TransferToQueue": this._transferToQueue.bind(this),
    "Composing": this._sendComposing.bind(this),
    "Cobrowse-Request": this._cobrowseRequest.bind(this)
  }

  this.getChatIntervalId = function() { return this.chatIntervalId; };
  this.setChatIntervalId = function(id) { this.chatIntervalId = id; };
};

function documentOnBeforeClose(gadgetName, viewDoc) {
  var docObj = pega.web.api.doAction(gadgetName,"getUIDoc");
  var interactionId = docObj && docObj.getID ? docObj.getID() : '';
  var docKey = viewDoc && viewDoc.key ? viewDoc.key : '';
  if (!interactionId && docKey) {
    interactionId = docKey.split(' ')[docKey.split(' ').length - 1];
  }
  interactionId = interactionId ? interactionId : (viewDoc && viewDoc.label ? viewDoc.label : '');
  interactionId = interactionId ? interactionId : (viewDoc && viewDoc.docObj && viewDoc.docObj.pyLabel ? viewDoc.docObj.pyLabel : '');
  if (interactionId && oPegaChatEventHandler._interactionChatMap[interactionId]) {
    oPegaChatEventHandler._endChat && oPegaChatEventHandler._endChat({pyCallId: oPegaChatEventHandler._interactionChatMap[interactionId]});
    oPegaChatEventHandler.deleteInteractionBeforeClose(interactionId);
  }
  
  //Clean up session storage
  pega.cs.voiceai.clearUnReviewedEntityList(interactionId);
  
  /*INC-164868 - When a tab is closed, all the other windows opened with it will be closed with the below code. As this method is overridden in CS layer, including the platform code here.*/
  try {  
      /*INC-195932 - Launch url - Form submit not working: Created SkipCloseCurrentWindow variable to determine whether to 
      close the child objects or not. Should set this variable in UserWorkForm*/
      var skipCloseCurrentWindow = pega.u.d.skipCloseCurrentWindow ? pega.u.d.skipCloseCurrentWindow : false;
      var app = pega.desktop.support.getDesktopApplication();
      var gadgetIframe = document.getElementById(gadgetName + "Ifr");     
      if (app && gadgetIframe) {
        var openedWindows = app.openedWindows;
        var gadgetWindow = gadgetIframe.contentWindow;       
        for (var i = openedWindows.length - 1; i >= 0; --i) {
          var currWindow = openedWindows[i];
          var winOpener = currWindow.opener;
          // Here we have to check opener parent window because for attachments we will create an inner iframe.
          if (!skipCloseCurrentWindow && winOpener && (winOpener === gadgetWindow || (winOpener.name === "Attachment Data" && winOpener.parent === gadgetWindow))) {
            currWindow.close();
            openedWindows.splice(i, 1);
          }
        }
      }
    } catch(e) { console.log("Error closing opened windows");}
}

pega.chat.chatEventHandler.prototype = {
  

  /*
   * This function checks the ACD state and resets the UI if there has been a prior login
   */
  initialize: function() {
  },

 
  registerForEvents: function() {
    try {
      registerEventListener("ChatAgentStateEvent", this.callHandleAgentStateEvents, "", this);
      registerEventListener("ChatCallStateEvent", this.callHandleCallStateEvents, "", this);
    } catch (e) {
      //alert("System failure: Unable to register pega call chat events." + "\n" + e);
    }
  },

  initializeChatInteraction: function(chatId){
    var typeAheadEl = document.querySelector("[name$=TypeAhead]");
    var typeAhead = typeAheadEl && typeAheadEl.value === 'true' ? true : false;
    var oEvent = {
      pyEventName: "Initialize",
      pyCallId: chatId,
      settings: {
        typeAhead: typeAhead
      }
    }
    this.delegateChatEvent(oEvent);
  },

  /* Register a new chat */
  registerChatEventHandler: function(chatId, interactionId, handler) {
    if (interactionId) {
      this._interactionChatMap[interactionId] = chatId;
      sessionStorage.setItem("_interactionChatMap", JSON.stringify(this._interactionChatMap));
    }
		this.setChatEventHandler(chatId, handler);
    this.initializeChatInteraction(chatId);
    this.processQueuedEvents(chatId);
    delete this.interactionLoadingForChats[chatId];
  },

  /* Unregister a chat. Needed for stopping monitoring and in case chat ends */
  unRegisterChatEventHandler: function(chatId) {
    delete this._chatEventHandlerMap[chatId];
  },

  getChatEventHandler: function(chatId) {
    return this._chatEventHandlerMap[chatId];
  },

  setChatEventHandler: function(chatId, handler) {
    this._chatEventHandlerMap[chatId] = handler;
  },

  getQueuedEvents: function(chatId) {
    if (!this._queuedEventsMap[chatId]) {
      this._queuedEventsMap[chatId] = { events: [] };
    }
    return this._queuedEventsMap[chatId].events;
  },

  queueEvent: function(chatId, event) {
    this.getQueuedEvents(chatId).push(event);
  },

  clearQueuedEvents: function(chatId) {
    delete this._queuedEventsMap[chatId];
  },

  processQueuedEvents: function(chatId) {
    var handler = this.getChatEventHandler(chatId);
    var events = this.getQueuedEvents(chatId);
    if (handler) {
      while (events.length > 0) {
        handler(events.shift());
      }
    }
    this.clearQueuedEvents(chatId);
  },

  delegateChatEvent: function(oEvent) {
    var chatId = oEvent.pyCallId;
    var handler = this.getChatEventHandler(chatId);
    if (handler) {
      try{
       handler(oEvent); 
      }catch(err){
        console.log(err);
      }
    } else if(this.interactionLoadingForChats[chatId] || sessionStorage.getItem(chatId)){ //interaction has not yet loaded, queue the event
      this.queueEvent(chatId, oEvent);
    }
  },
  
  delegateGlobalEvent: function(oEvent) {
    for (var chatId in this._chatEventHandlerMap) {
      var handler = this._chatEventHandlerMap[chatId];
      if (handler) {
        try{
           handler(oEvent); 
        }catch(err){
          console.log(err);
        }
      }
    }
  },
  
  handleChatEvent: function(oEvent) {
    var eventName = oEvent.pyEventName;
    if (this._chatInteractionHandlers[eventName]) {
      this._chatInteractionHandlers[eventName](oEvent);
    } else {
      console.log("Unrecognised event '" + eventName + "'");
    }
  },

  handleClose: function() {
    this.closeDiv();
  },



  // at show dialog, see if already in a state, if so restore it.
  handleShowDialog: function() {

    if ((this._lastLoginChatEvent != null) && (this._lastStatusChatEvent != null)) {
      window.setTimeout("oPegaChatEventHandler.handleRestoreState()", 600);

    }

  },

  handlePinnedDialog: function() {

  },

  handleUnpinnedDialog: function() {

  },




  handleRestoreState: function() {
    this.handleAgentStateEvents(serialize(this._lastLoginChatEvent));
    this.handleAgentStateEvents(serialize(this._lastStatusChatEvent));
  },

  callHandleAgentStateEvents: function(oData) {
    try {
      this.handleAgentStateEvents(oData);
    } catch (e) {
      // alert("Caught an exception while trying to process Agent state Event:" + deserialize(oData)+"\n" + e);
    }
  },

  handleAgentStateEvents: function(oData) {
    var oEvent = deserialize(oData);
    var sEvent = oEvent.pyEventName;
    var sMedia = oEvent.pyMedia;

    switch (sEvent) {
      case "Login":
        if (sessionStorage.getItem("agentConnected") == "true") {
          sessionStorage.removeItem("ReconnectInprogress");
          clearInterval(reconnectIntervalId);
        }
        if (typeof(pega) != 'undefined' && pega.u.d) {
          //doModalAction(pega.u.d.submitModalDlgParam, "click");
          
          // Commented the above API invocation to fix URL tampering issue - BUG-497023/BUG-497023
          // This API is provided by platform to close the overlay. The above used API is not proper
           pega.u.d.getPopOver().close();
        }
        // have to refresh the section in order for the menu to redraw
        // and show the new selected queue.
     
        pega.u.d.setProperty("$PD_CPMPortalContext$pokRefreshChatMenu", "true");
        pega.u.d.setProperty("$PD_CPMPortalContext$pisChatLoggedIn", "true");
     //publish presence for chat status
       var oSafeUrl = new SafeURL("@baseclass.SetCsrPresenceRecordForLogin");
        pega.u.d.asyncRequest("POST", SafeURL_createFromURL(oSafeUrl.toURL()), {
                success: function(oResponse) {
                pega.api.ui.actions.refreshSection ({ 'section' : 'PegaChatSection' });
                },
                failure: function() {
                console.log("Error while updating presence");
      },
      scope: this
    }, null);            
            //end of publish presence
        var _this = this;
        _this.handleChatLogin();
        _this._currentServerName = oEvent.pyAgentServerName;
        _this._currentServerQueue = oEvent.pyAgentQueue;
        $("button[data-click*='sendMessage']") && $("button[data-click*='sendMessage']").attr('disabled', false)
          // save the event
        _this._lastLoginChatEvent = oEvent;
        setUserStart();
        // Added as part of US-111230 for Agent Reconnected
        sessionStorage.setItem("agentConnected", "true");
        UpdateRetrySettings();
        oEvent.updateOnlineStatus = true;
        this.delegateGlobalEvent(oEvent);

        break;

      case "Ready":

        this.updateReadyAgentState("true");
        //Change queue 
        var oSafeURL = new SafeURL("ChannelServices-Device-Chat.ChangeSelectedQueue");
        oSafeURL.put("selectedQueueName", sessionStorage.getItem("Currentqueue"));
        pega.u.d.asyncRequest("GET", SafeURL_createFromURL(oSafeURL.toURL()), null, null);


        // save the event
        this._lastStatusChatEvent = oEvent;
        displayReconnectedIcon(false);


        break;
      case "NotReady":

        this.updateReadyAgentState("false");
        // save the event
        this._lastStatusChatEvent = oEvent;

        // Added as part of US-111230 for Agent Reconnected
        displayReconnectedIcon(false);
        sessionStorage.setItem("agentConnected", "false");
        break;
      case "Logout":

        if ((oEvent.pyAgentQueue) && (oEvent.pyAgentQueue != "")) {
          // When the Agent Queue is present then it is a change queue logout event
          this._lastStatusChatEvent = oEvent;
        } else {
          // When the Agent Queue is not present then it is an event for a logout request.
          //TODO: No need to start.stop heartbeats 
          if (sMedia == "Chat") {
            this.stopChatHeartbeat();
          }

          var reconnectInProgress = sessionStorage.getItem("ReconnectInprogress");
          if (reconnectInProgress == "undefined" || reconnectInProgress == null) {
            this.handleChatLogout();
            this.changeStatus();
          } else {
            // Added as part of US-111230 for Agent Reconnected
            displayReconnectedIcon(true);
          }

          oEvent.CallId = "-1";
          this._lastLoginChatEvent = null;
          this._lastStatusChatEvent = null;
        }
        break;
      case "ChangedQueue":
        this.finishQueueChange(oEvent.pyQueueName);
        break;
      case "RefreshChatMenu":
        this.refreshChatMenu();
        break;

      case "Error":
        if (oEvent.pyErrorMessage == "Connection Failed") {
          var reconnectInProgress = sessionStorage.getItem("ReconnectInprogress");
          if (reconnectInProgress == "undefined" || reconnectInProgress == null) {
            
            sessionStorage.setItem("ReconnectInprogress", "true");
            $("button[data-click*='sendMessage']") && $("button[data-click*='sendMessage']").attr('disabled', true);
            
           pega.u.d.setProperty("$PD_CPMPortalContext$pisChatLoggedIn", "false");
           //publish presence for chat status
             var oSafeUrl = new SafeURL("@baseclass.SetCsrPresenceRecordForReconnect");
              pega.u.d.asyncRequest("POST", SafeURL_createFromURL(oSafeUrl.toURL()), {
                success: function(oResponse) {
                pega.api.ui.actions.refreshSection ({ 'section' : 'PegaChatSection' });
                },
                failure: function() {
                console.log("Error while updating presence");
      },
      scope: this
    }, null);            
            //end of publish presence
            
            ReconnectAgentState();
          }
        } else {
          alert(oEvent.pyOperation + " FAILED : " + oEvent.pyErrorMessage);
          // This means that there has been an auth fail or unspecified error. 
          // Logout of the Chat so that icon reflects the correct status
          this.setChatLogout();
        }
        break;

    }
    sessionStorage.setItem("statusEvent", this._lastStatusChatEvent.pyEventName);
  },

  callHandleCallStateEvents: function(oData) {
    try {
      this.handleCallStateEvents(oData);
    } catch (e) {
      // alert("Caught an exception while trying to process Call state Event:" + deserialize(oData)+"\n" + e);
    }
  },

  handleCallStateEvents: function(oData) {
    var oEvent = deserialize(oData);
    var sEvent = oEvent.pyEventName;
    switch (sEvent) {
      case "Alerting":
        this.handleChatAlerting(oEvent);
        break;
      case "Established":
        this.handleChatEstablished(oEvent);
        break;
      case "Connected":
        var sParty = oEvent.pyOtherPartyName;
        var _this = this;
        var displayName = sessionStorage.getItem('displayName');
        if (displayName !== sParty) {
          pega.cpm.localization.getLocalizedValue("CPM-Portal", "pyMessageLabel", "{1} has connected.\t" + sParty,
            function(sMessage) {
              var oEvent = deserialize(oData);
              oEvent.pyEventName = "SystemMesssage";
              oEvent.pyOtherPartyName = "SYSTEM";
              oEvent.pyMessageBody = sMessage;
              oEvent.pyCreatedAt = oEvent.pyCreatedAt;
              this.delegateChatEvent(oEvent);
            }, _this);
        } else {
          var Refresh = document.querySelector("[name$=TriggerChatRefresh]");
          if (Refresh != null) Refresh.click();
        }

        break;
     case "Disconnected":
        var sParty = oEvent.pyOtherPartyName;
        var _this = this;
        pega.cpm.localization.getLocalizedValue("CPM-Portal", "pyMessageLabel", "{1} has disconnected.\t" + sParty,
          function(sMessage) {
            var event = deserialize(oData);
            event.pyEventName = "SystemMesssage";
            event.pyOtherPartyName = "SYSTEM";
            event.pyMessageBody = sMessage;
            event.pyCreatedAt = oEvent.pyCreatedAt;
            event.isDisconnected = "true";
            this.delegateChatEvent(event);
          }, _this);
        break;
      case "Messages":
      case "Message":
      case "Composing":
        this.delegateChatEvent(oEvent);
        break;
    }
  },

  //TODO: Remove the heartbeat functions below

  startChatHeartbeat: function() {
    if (this.chatHeartbeatInterval != -1) {
      var id = setInterval("sendChatHeartbeat()", this.chatHeartbeatInterval);
      this.setChatIntervalId(id);
    } else {
      // Turning it off here to handle the case where the heartbeat is turned off 
      // and the agent is logging back in again after logging in then out. 
      this.setChatIntervalId(-1);
    }
  },

  stopChatHeartbeat: function() {
    if (this.getChatIntervalId() != -1) {
      clearInterval(this.getChatIntervalId());
      this.setChatIntervalId(-1);
    }
  },


  retrieveHeartbeatInfo: function() {
    var heartbeatRequest;
    var oSafeURL = new SafeURL("ChannelServices-Device-Chat.RetrieveHeartbeatInfo");

    oSafeURL.put("pzPrimaryPageName", "ChatDevice");

    if (window.XMLHttpRequest) {
      heartbeatRequest = new XMLHttpRequest();
    } else if (window.ActiveXObject) {
      heartbeatRequest = new ActiveXObject("Microsoft.XMLHTTP");
    }

    if (heartbeatRequest != null) {
      // Sending it synchronously 
      heartbeatRequest.open("GET", oSafeURL.toURL(), false);
      heartbeatRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      heartbeatRequest.send(null);

      if ((heartbeatRequest.responseText != null) && (heartbeatRequest.responseText != "") && (heartbeatRequest.responseText != "false")) {
        // Heartbeat interval needs to be in milliseconds and it is defined on the server as seconds.
        this.chatHeartbeatInterval = (heartbeatRequest.responseText * 1000);
      } else {
        this.chatHeartbeatInterval = -1;
      }
    }
  },



  //deperacted event..used in CS 8.2 prior versions
  handleChatLogin: function() {
    pega.u.d.setProperty("$PD_CPMPortalContext$pisChatLoggedIn", "true");
    var queues = sessionStorage.getItem("Currentqueue");
    if (queues !== null) {
      queues.replace(/\t+/g, ",").split(",").forEach(function(queue) {
        queue = queue.trim();
        if (queue != null && queue != '') {
          oPegaChatAgentConnection.joinWorkGroup({ queue: queue });
        }

      });
    } else {
      this.setChatNotAvailable();
    }
    var oSafeURL = new SafeURL("CPM-Portal.UpdateChatLoginState");
    oSafeURL.put("chatLoggedIn", true);
    oSafeURL.put("serverName", sessionStorage.getItem("PSCserver"));
    pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
    pega.u.d.asyncRequest("POST", SafeURL_createFromURL(oSafeURL.toURL()), null, null);
  },

  handleChatLogout: function() {
    pega.u.d.setProperty("$PD_CPMPortalContext$pisChatLoggedIn", "false");
    pega.u.d.setProperty("$PD_CPMPortalContext$pIsChatAgentReconnecting", "false");
  },

  updateReadyAgentState: function(isReady) {
    pega.u.d.setProperty("$PD_CPMPortalContext$pIsChatAgentReady", isReady);
  },
    handleTransferChats: function(sId){
         oEvent = this.pendingChats[sId];
         var isTransfer="false";
         var isAssignmentOpened="false";
         var assignKey= oEvent && oEvent.pyAssignmentInsKey;
         if(assignKey===undefined || assignKey===null)
         assignKey= sessionStorage.getItem("assignmentkey");
         
         if(assignKey!==undefined && assignKey!==null)
           {
             pega.desktop.openAssignment(assignKey,"","",{"shouldCreateAssociateRequestor":"true"});
             isAssignmentOpened="true";
           }
          if((oEvent && oEvent.IsTransferToAgent != null && oEvent.IsTransferToAgent == "true") || (oEvent && oEvent.czInteractionId != null && oEvent.czInteractionId != "") || (oEvent && oEvent.czInteractionID != null && oEvent.czInteractionID != ""))
          { 
            isTransfer="true";
            if(isAssignmentOpened==="false")
            pega.desktop.openAssignment(assignKey,"","",{"shouldCreateAssociateRequestor":"true"}); 
          }
                  
         /* Update script to presence & schema updates for transfer cases*/
         if(isTransfer==="true" || isAssignmentOpened==="true"){ 
           if ($("#toasterpop").length) {
              hideToasterPop();
           }
           sessionStorage.removeItem("assignmentkey");
           var updateOnAgentAction;
           updateOnAgentAction = new SafeURL("@baseclass.CaptureTransferResponse");
           updateOnAgentAction.put("Action","Accepted");
           pega.u.d.asyncRequest("POST",
                   SafeURL_createFromURL(updateOnAgentAction.toURL()),
	          {
		        success:function(o) { 
              console.log("Response updated successfully");
            },
          
		        failure: function() {
			      console.log("Failed to update response");
		        },
		    scope:this
	    },
	    null)
        }
         /* end of schema updated*/ 
  },

handleChatAcceptChat: function(sId,queueName,agentID,sAssignKey) {
   var conversationStatusResponse = new SafeURL("@baseclass.czCheckConversationStatus");
    conversationStatusResponse.put("chatID",sId);
   conversationStatusResponse.put("CheckPresence","true");
      if(sAssignKey!==null && sAssignKey!==undefined)
        conversationStatusResponse.put("AssignmentKey",sAssignKey);
  if(sId.startsWith("BotAgent"))
     conversationStatusResponse.put("InvokedFrom","BotAgentTransfer"); 
    var conversationStatus;
    var self = this;
    pega.u.d.asyncRequest("POST",
	      SafeURL_createFromURL(conversationStatusResponse.toURL()),
	        {
		        success:function(o) { 
              conversationStatus = o.responseText;
              var oEvent; 
              var typeAheadEl = document.querySelector("[name$=TypeAhead]");
              var typeAhead = typeAheadEl && typeAheadEl.value === 'true' ? true : false;
              var chatId = sId.startsWith("BotAgent")? sId: 'chat' + sId;
              this.interactionLoadingForChats[chatId] = true;
              for (sId in this.pendingChats) {
                 oEvent = this.pendingChats[sId];
                 if (oEvent.czConversationID == sId) {
                   if(oEvent.intervalId != null){
                       clearInterval(oEvent.intervalId);
                   }
                 if(conversationStatus=="AlreadyOpened"){
             var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
             oSafeURL.put("pyPurpose", "AlreadyOpened");
             pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true)) ;
         DismissExpireChatToasterPop(sId,"ChatActive");   
        }
        
         else if(conversationStatus=="ChatActive:false"){
             var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
             oSafeURL.put("pyPurpose", "MaxLimit");
             pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true)) ;
         DismissExpireChatToasterPop(sId,"ChatActive");   
        }
     else if(conversationStatus=="ChatEnded:false" || conversationStatus=="ChatEnded:true"){
             var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
             oSafeURL.put("pyPurpose", "expiredChat");
             pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true)) ;
         DismissExpireChatToasterPop(sId,"ChatEnded");   
        }
         else{
                        /* SE-55314 - Implementation Starts */
                        var transferChats = pega.cs.commonutils.readCookie('transferChats');		
                        transferChats = transferChats ? JSON.parse(transferChats) : {};
                        if(transferChats[sId]){
                           oPegaChatEventHandler.unRegisterChatEventHandler('chat'+sId);
                           oPegaChatEventHandler.deleteTransferChatIdFromMap(sId);
                        }			
         
                         /* SE-55314 - Implementation Ends */
                    
                     if(sId.startsWith("BotAgent")){
                       this.handleTransferChats(sId);
                      if(this.pendingChats[sId])
                          delete this.pendingChats[sId];
                    }
         
         
         /* clearing queued events on accepting normal chat or transferred chat*/
         this.clearQueuedEvents(chatId);
             
         if(!sId.startsWith("BotAgent"))
          {
             oPegaChatAgentConnection.acceptOffer(oEvent.czQueueName+"@workgroup", sId, oEvent.czCSRIdentified, typeAhead); 
             var acceptTimeout = setTimeout(function(){
             if ($("#toasterpop").length) {
                 hideToasterPop();
                 var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
                 oSafeURL.put("pyPurpose", "networkdisconnect");
                 pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true)) ;
                 delete self.acceptPendingChats[chatId];
                 self.acceptFailedChats[chatId] = chatId;
                 DismissExpireChatToasterPop(sId, "ChatActive");
              }
            },15000);
            this.acceptPendingChats[chatId] = {};
            this.acceptPendingChats[chatId].TimeoutId = acceptTimeout;
             } 
            }
              break;
            }
          } 
         }, failure: function() {
			      console.log("Failed to update response");
		        },
		    scope:this
	    },
	    null)
    },
  
  /* This function is used to dismm expire chat toaster pop after one second*/
DismissExpireChatToasterPop: function(offerId,action){
    var oEvent;
    for (offerId in this.pendingChats) {
      oEvent = this.pendingChats[offerId];
    }
    if(action == "ChatEnded")
      action = "TransferAbandoned";
    else if (action == "ChatActive")
      action = "Expired";
    
      setTimeout(function(){
              var updateOnAgentAction;
             if((oEvent && oEvent.IsTransferToAgent != null && oEvent.IsTransferToAgent == "true") || (oEvent && oEvent.czInteractionId != null && oEvent.czInteractionId != "") || (oEvent && oEvent.czInteractionID != null && oEvent.czInteractionID != "")){ 
                 /* for transfer scenarios */   
                updateOnAgentAction = new SafeURL("@baseclass.CaptureTransferResponse");
                updateOnAgentAction.put("Action",action);          
				pega.u.d.asyncRequest("POST",
	      SafeURL_createFromURL(updateOnAgentAction.toURL()),
	        {
		        success:function(o) { 
              console.log("Response updated successfully");
          },
          
		        failure: function() {
			      console.log("Failed to update response");
		        },
		    scope:this
	    },
	    null)
             }            
      
           },1000);
    if(this.pendingChats[offerId]) delete this.pendingChats[offerId];
      sessionStorage.removeItem("assignmentkey");
  },
   
  loggingToasterPopActivity: function(MessageToLog){
     var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
     oSafeURL.put("MessageToLog", MessageToLog);
     oSafeURL.put("LoggingLevel", "Error");
    oSafeURL.put("Action", "Logging");
     var writetolog = pega.u.d.asyncRequest(
        "POST",
        SafeURL_createFromURL(oSafeURL.toURL()),
        {
          success: function () { },
          failure: function () {},
          scope: this,
        },
        null
      );
  },
  /* This function finds the "Accept" button in the Toaster Pop and adds a timeout value next to it */
/* Since this one is for Chat, it is set to 30 seconds by default */
  showCountdownTimer: function(offer_timeout,data) {
  var acceptButton = $(".chat_toaster_accept_button button").get(0);
   var offerID = data.detail.response.czConversationID;
   var requestData = new Object;
   requestData = data;
   var request = JSON.stringify(data.detail.response);
    var defAcceptText;
  if (acceptButton != null) {
      var IsClassPresent= document.getElementsByClassName('chat_toaster_accept_button').length > 0;
    oPegaChatEventHandler.loggingToasterPopActivity("In showCountdownTimer function and accept class here is " + IsClassPresent + " for conversationID " + offerID);
    defAcceptText=$(acceptButton).text();
    if ($(acceptButton).attr('data-original-text') == null) {
      $(acceptButton).attr('data-original-text', defAcceptText);
    }
     offer_timeout = offer_timeout || 30000;
    var timer = parseInt(offer_timeout / 1000, 10);
    var intervalId = setInterval(function() {
      $(acceptButton).text(defAcceptText + " (" + timer + ")");
      if (--timer < 0) {
          requestData.detail.response.pyPurpose = "expiredChat";
        requestData.detail.response.offerTimeout = true;
       oPegaChatEventHandler.showChatToasterPop(requestData);
        $(acceptButton).text(defAcceptText);
        clearInterval(intervalId);      
        
      }
    }, 1000);
     if(offerID in this.pendingChats){
      this.pendingChats[offerID].intervalId = intervalId;
    }
    }else{
   oPegaChatEventHandler.loggingToasterPopActivity("In showCountdownTimer function if acceptButton is null with conversationID " + offerID);
  }
},
 showChatToasterPop: function(data){

    var queueName=data.detail.response.czQueueName;
    var agentID=data.detail.response.czCSRIdentified;
    var request = JSON.stringify(data.detail.response);
    var offerId = data.detail.response.czConversationID;
    var chatSource = data.detail.response.czSource;
    var czOfferTimeout;
     
    if(data.detail.response.czOfferTimeOut != null || data.detail.response.czOfferTimeOut !="")
      czOfferTimeout= data.detail.response.czOfferTimeOut * 1000;
    else czOfferTimeout = 30000;
    
    var oSafeURL;

    oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
   
    if((data.detail.response.offerTimeout != null) && (data.detail.response.offerTimeout = "true")){
      
      if(data.detail.response.pyPurpose == "expiredChat"){
        oSafeURL.put("pyPurpose", "expiredChat");
     
      }
      
    }else{
      var iDiv = document.createElement("div");  
      iDiv.id = 'overlay';
      document.getElementsByTagName('body')[0].appendChild(iDiv);
      var totaldiv= document.getElementById("overlay");
      totaldiv.style.display = "block"; 
      
      if(data.detail.response.pyPurpose == null)
      this.pendingChats[offerId] = data.detail.response;
      
      oSafeURL.put("pyPurpose", "AlertingChat");
      data.detail.response.offerTimeout = false;
    }

      oSafeURL.put("RoutingResponseJSON", request);
      if(data.detail.response.czCustomerID!==null && data.detail.response.czCustomerID!==undefined)
      oSafeURL.put("czCustomerID",data.detail.response.czCustomerID);
     // pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true)) ;
    if((data.detail.response.offerTimeout != null) && (data.detail.response.offerTimeout = "true")){
       if(data.detail.response.pyPurpose == "expiredChat"){
         DismissExpireChatToasterPop(offerId, "ChatActive");
          if(offerId in this.pendingChats)
             delete this.pendingChats[offerId];
       }
    }
  
   pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true), function(isSuccess){
     if(isSuccess){
        pega.cs.notificationmanager.playNotificationSound();
        var offer_timeout =  czOfferTimeout;
        oPegaChatEventHandler.loggingToasterPopActivity("In success call back of showChatToasterPop with conversationID " + offerId);
        oPegaChatEventHandler.showCountdownTimer(offer_timeout,data);
        if (data.detail.response.pyPurpose === 'AlertingChat') {
          //Delaying chat:offered event to ensure that the timer on PegaCS is started.
          setTimeout(function() {
            oPegaChatAgentConnection.chatOffered(queueName+"@workgroup",offerId, agentID);
          }, 0);
        }
       if(data.detail.response.pyPurpose == "expiredChat"){
        hideToasterPop();
       }
     }
   },offerId,data) ;
      oSafeURL.nullify();
      oSafeURL = null;
  },
  
 handleChatDeclineChat: function(sId){
    var oEvent;
    for (sId in this.pendingChats) {
      oEvent = this.pendingChats[sId];
      if (oEvent.czConversationID == sId) {
         if(oEvent.intervalId != null){
            clearInterval(oEvent.intervalId);
        }
       // oPegaChatAgentConnection.declineOffer(oEvent.czQueueName+"@workgroup", oEvent.czConversationID, oEvent.czCSRIdentified);
        delete this.pendingChats[sId];
        break;
      }
    }

    if ($("#toasterpop").length) {
      hideToasterPop();
    }
 },
  
  handleBotAgentChat: function(sId){
       var conversationStatusResponse = new SafeURL("@baseclass.czCheckConversationStatus");
    conversationStatusResponse.put("chatID",sId);
    var conversationStatus;
    
    pega.u.d.asyncRequest("POST",
	      SafeURL_createFromURL(conversationStatusResponse.toURL()),
	        {
		        success:function(o) { 
              conversationStatus = o.responseText;
              var oEvent;
              for (sId in this.pendingChats) {
                oEvent = this.pendingChats[sId];
                  if (oEvent.czConversationID == sId) {
                       if(oEvent.intervalId != null){
                               clearInterval(oEvent.intervalId);
                          }    
                  if(conversationStatus=="ChatActive:false"){
             var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
             oSafeURL.put("pyPurpose", "MaxLimit");
             pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true)) ;
         DismissExpireChatToasterPop(sId,"ChatActive");   
        }
     else if(conversationStatus=="ChatEnded:false" || conversationStatus=="ChatEnded:true"){
             var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
             oSafeURL.put("pyPurpose", "expiredChat");
             pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true)) ;
         DismissExpireChatToasterPop(sId,"ChatEnded");   
        }else{
                      oEvent.pyCallId = sId;
                     this.handleChatEstablished(oEvent);
                         if ($("#toasterpop").length) {
                                hideToasterPop();
                            }

                   }
      }
    }
            },
      		        failure: function() {
			      console.log("Failed to update response");
		        },
		    scope:this
	    },
	    null)

 },
  
  handleChatAlerting: function(oEvent) {

     if ($("#toasterpop").length) {
       var sUniqueId = oEvent.pyCallId;
      var conversationid = sUniqueId.substr(4,sUniqueId.length);
      for (sUniqueId in this.AcceptPendingChats) {
      var acceptPendingChats = this.AcceptPendingChats[sUniqueId];
        if(acceptPendingChats.TimeoutId != null){
            clearTimeout(acceptPendingChats.TimeoutId);
        }
        delete this.AcceptPendingChats[sUniqueId];
      }
      hideToasterPop();
      var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
      oSafeURL.put("pyPurpose", "expiredChat");
      pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true)) ;
      DismissExpireChatToasterPop(conversationid,"ChatEnded");   
    } 

  },

  notifyAgent: function() {
    /*
    // Let's check if the browser supports notifications
    if (!("Notification" in window)) {
      alert("This browser does not support desktop notification");
    }
    // Let's check if the user is okay to get some notification
    else if (Notification.permission === "granted") {
      // If it's okay let's create a notification
      var options = {
        body: "There is an incoming chat request.",
        icon: "https://s3.amazonaws.com/firefly-us-chat2-prod/img/chatAssets/pega-logo%402x.png",
        dir: "ltr"
      };
      var notification = new Notification("Chat Request...", options);

      notification.onclick = function() {
        parent.focus();
        window.focus();
        this.close();
      };
    }

    // Otherwise, we need to ask the user for permission
    // Note, Chrome does not implement the permission static property
    // So we have to check for NOT 'denied' instead of 'default'
    else if (Notification.permission !== 'denied') {
      Notification.requestPermission(function(permission) {
        // Whatever the user answers, we make sure we store the information
        if (!('permission' in Notification)) {
          Notification.permission = permission;
        }

        // If the user is okay, let's create a notification
        if (permission === "granted") {
          var options = {
            body: "There is an incoming chat request.",
            icon: "https://s3.amazonaws.com/firefly-us-chat2-prod/img/chatAssets/pega-logo%402x.png",
            dir: "ltr"
          };
          var notification = new Notification("Chat Request...", options);
        }
      });
    }

    // At last, if the user already denied any notification, and you
    // want to be respectful there is no need to bother them any more.
    */
  },


 handleChatEstablished: function(oEvent) {
    var sUniqueId = oEvent.pyCallId;
    for (sUniqueId in this.acceptPendingChats) {
      var acceptPendingChats = this.acceptPendingChats[sUniqueId];
        if(acceptPendingChats.TimeoutId != null){
            clearTimeout(acceptPendingChats.TimeoutId);
        }
        delete this.acceptPendingChats[sUniqueId];
    }
   /* SE-56574 Checking whether the chat requesy offered is for current CSR are not before creating work object */
    var conversationid = sUniqueId.startsWith("BotAgent")? sUniqueId: sUniqueId.substr(4,sUniqueId.length);
    var safeURL = new SafeURL("@baseclass.czIsChatForMe");
    safeURL.put("ConversationID",conversationid);
     var statusresponse;
    
    pega.u.d.asyncRequest("POST",
	      SafeURL_createFromURL(safeURL.toURL()),
	        {
		        success:function(o) { 
              statusresponse = o.responseText;
               var recentUrl = new SafeURL("@baseclass.CPMGetDynamicReferenceActivity");
               pega.u.d.asyncRequest('GET', SafeURL_createFromURL(recentUrl.toURL()), {
                success: function (respObject) {
                 var applicationSettings = JSON.parse(respObject.responseText);
                  
                   if ($("#toasterpop").length) {
                          hideToasterPop();
                     }
                  if(!sUniqueId.startsWith("BotAgent"))
                    this.handleTransferChats(conversationid);
                  if(this.pendingChats[conversationid])
                    delete this.pendingChats[conversationid];
            if (this.isChatMonitored(sUniqueId) || this.isTransferredChat(sUniqueId)) {
              return;
             }
            if ($("#toasterpop").length) {
                /* BAC- URL Tampering : Registered CreateNewWork in ChatToasterPop section on Accept button*/
              if(statusresponse==="true"){
                 sUniqueId.startsWith("BotAgent")?
                  pega.desktop.createNewWork(applicationSettings.InteractionChatClass, "", "CPMInteraction", "&shouldCreateAssociateRequestor=true&ChanServInsName=" + sUniqueId+"&Source=chat", "", "", "", "", ""):
                  pega.desktop.createNewWork(applicationSettings.InteractionChatClass, "", "CPMInteraction", "&ChannelSvscID=" + sUniqueId+"&shouldCreateAssociateRequestor=true&ChanServInsName=" + sUniqueId+"&Source=Chat", "", "", "", "", "");
              } else {
              var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
              oSafeURL.put("pyPurpose", "expiredChat");
              pega.cpm.toasterpop.loadToasterPop(oSafeURL.toURL(true,true)) ;
              DismissExpireChatToasterPop(conversationid,"ChatEnded");
              }
            } else {
                pega.cpm.tabbedInterface.createNewTab("chat", applicationSettings.InteractionClassGroup + ".CPMInvokeInteractionStartActivityForChat&InteractionType=chat&ChannelSvscID=" + sUniqueId, sUniqueId);
                pega.cpm.tabbedInterface.selectTab(sUniqueId);
            }
                 
                },
              failure: function () {
                  console.log("failed");
                },
              scope: this
              }, null);       
          },
          
		        failure: function() {
			      console.log("Failed to update response");
		        },
		    scope:this
	    },
	    null)
  },

  /* chat functionality */
  setChatAvailable: function() {
    if (sessionStorage.getItem("Currentqueue") != null)
      oPegaChatAgentConnection.setState("chat");


  },

  setChatNotAvailable: function(statusEvent) {
    if (statusEvent == "NotReady")
      sessionStorage.setItem("statusEvent", "NotReady");

    if (sessionStorage.getItem("statusEvent") == "Ready" && statusEvent != "NotReady")
      oPegaChatAgentConnection.setState("chat");
    else
      oPegaChatAgentConnection.setState("xa");

    // Clear out the current queues. The portal UI will also reflect that no queues are joined.
    sessionStorage.removeItem("Currentqueue");


  },

  setChatLogout: function(cb) {

    agentID = sessionStorage.removeItem("agentID");
    pwd = sessionStorage.removeItem("pwd");
    serverURL = sessionStorage.removeItem("serverURL");
    sessionStorage.removeItem("statusEvent");
    var queue = sessionStorage.getItem("Currentqueue");
    sessionStorage.removeItem("Currentqueue");
    sessionStorage.removeItem("agentConnected");
    sessionStorage.removeItem("ReconnectAttempts");
    sessionStorage.removeItem("ReconnectInterval");
    
    pega.cs.commonutils.removeCookie("employeeID");


    clearSessionVaraibles();
    hideToasterPop();
    if (queue)
      this.leaveAllQueues(queue);
    oPegaChatAgentConnection.logout();
    pega.u.d.setProperty("$PD_CPMPortalContext$pisChatLoggedIn", "false");
    pega.u.d.setProperty("$PD_CPMPortalContext$pIsChatAgentReconnecting", "false");
    var oSafeURL = new SafeURL("CPM-Portal.UpdateChatLoginState");
    oSafeURL.put("chatLoggedIn", false);
    pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
    pega.u.d.asyncRequest("POST", SafeURL_createFromURL(oSafeURL.toURL()), {
      success: function(oResponse) {
        if (cb) {
          cb(null, { success: true });
        }
      },
      failure: function(err) {
        if(data.statusText == "communication failure" || data.statusText == "transaction aborted"){
          if (cb) {
          cb(null, { success: true });
          }
        } else {
            pega.cpm.localization.getLocalizedValue("CPM-Portal", "pyMessageLabel", "Request from server failed.",
            function(sMessage) {
              if (cb) {
                 cb(sMessage, { success: false });
              }
            });
          }
      },
      scope: this
    }, null);

  },


  //TODO: Call this from Login button of login dialog	
  // the server url should be of the form http://<host>:7070 

  // you can use "http:vspegacall042k8:7070"  with AgentID "demo" Password "demo"
  //Jagan- 7070 is hardcoded. Need to revisit this function once PRPC has a property for port
  //Fergb- add the node to the agentID if missing
 
  chatLoginDirect: function(serverURL, agentID, pwd, displayName, resourceID, skipRouting) {
    skipRouting = typeof(skipRouting) === 'undefined' ? true : false;
    if (resourceID == null || resourceID == "")
      resourceID = "CPM";
    if (agentID != "" && pwd != "" && serverURL != "") {
      sessionStorage.setItem("agentID", agentID);
      sessionStorage.setItem("serverURL", serverURL);
      sessionStorage.setItem("pwd", pwd);
      sessionStorage.setItem("displayName", displayName);
      sessionStorage.setItem("resourceID", resourceID);

    }
    if (agentID != null) {
      var parser = document.createElement('a');
      parser.href = serverURL;
      agentID = agentID.replace(/@/g, "\\40");
      agentID = agentID.replace(/'/g, "\\27");
      agentID = agentID.replace(/&/g, "\\26");
      agentID = agentID.replace(/ /g, "\\20");
      agentID = agentID + "@" + parser.hostname;
    }

    if (resourceID == "CPM") {
      sessionStorage.removeItem("PSCserver");
      sessionStorage.removeItem("employeeID");
      var oSafeURL = new SafeURL("pzRunActionWrapper");	
      oSafeURL.put("pzPrimaryPageName", "pyWorkPage");	
      oSafeURL.put("pzDataTransform", "UpdateIsChatLoggedIn");	
      oSafeURL.put("pySubAction", "runDT");	
      pega.u.d.asyncRequest('POST', SafeURL_createFromURL(oSafeURL.toURL()), {	
        success: function (response) {	
          pega.api.ui.actions.refreshSection ({ 'section' : 'PegaChatSection' });
        },	
        failure: function () {	
           console.log("UpdateIsChatLoggedIn failed");	
        },	
            scope: this	
        }, null);	
       pega.u.d.setProperty("$PD_CPMPortalContext$pisChatLoggedIn", "true");
    } else {
      var ssoURL = new SafeURL("@baseclass.GetSSOToken");
      ssoURL.put("ChatServerName", sessionStorage.getItem("PSCserver"));
       
      pega.cs.commonutils.readCookie("employeeID") && ssoURL.put("EmployeeID", pega.cs.commonutils.readCookie("employeeID"));
      pega.u.d.asyncRequest('GET', SafeURL_createFromURL(ssoURL.toURL()), {
      success: function (respObject) {
       if (respObject.status === 200) {
        pwd = respObject.responseText.trim();
        var employeeID = pwd.split('_')[2];
        if (employeeID) {
          pega.cs.commonutils.setCookie("employeeID",employeeID);
        }
        
        //added to reset the chatconnectionstatus
          var oSafeUrl = new SafeURL("@baseclass.SetCsrPresenceRecordForLogin");
         pega.u.d.asyncRequest("POST", SafeURL_createFromURL(oSafeUrl.toURL()), {
                success: function(oResponse) {
                pega.api.ui.actions.refreshSection ({ 'section' : 'PegaChatSection' });
                },
                failure: function() {
                console.log("Error while updating presenc");
      },
      scope: this
    }, null);            
            //end of publish presence 
        pega.u.d.setProperty("$PD_CPMPortalContext$pisChatLoggedIn", "true");
        
        oPegaChatAgentConnection.login((serverURL + "/xmpp" + (skipRouting ? "?skipRouting=true" : "")), agentID + "/" + resourceID, pwd, displayName);
      } else {
        if (typeof(pega) != 'undefined' && pega.u.d) {
          doModalAction(pega.u.d.submitModalDlgParam, "click");
        }
        var reconnectInProgress = sessionStorage.getItem("ReconnectInprogress");
        
        ///Added to update on the reconnect
         var oSafeUrl = new SafeURL("@baseclass.SetCsrPresenceRecordForReconnect");
         pega.u.d.asyncRequest("POST", SafeURL_createFromURL(oSafeUrl.toURL()), {
                success: function(oResponse) {
                pega.api.ui.actions.refreshSection ({ 'section' : 'PegaChatSection' });
                },
                failure: function() {
                console.log("Error while updating presenc");
      },
      scope: this
    }, null);            
            //end of publish presence
        pega.u.d.setProperty("$PD_CPMPortalContext$pisChatLoggedIn", "false");
       
        if (reconnectInProgress == "undefined" || reconnectInProgress == null) {
          ReconnectAgentState();
          sessionStorage.setItem("ReconnectInprogress", "true");
          $("button[data-click*='sendMessage']") && $("button[data-click*='sendMessage']").attr('disabled', true);
        }
      }
        
         },
      failure: function () {
        console.log("Error inside chatLoginDirect");
      },
      scope: this
    }, null);
    }
  },

  chatLogin: function(event) {
    var oSafeUrl = new SafeURL("ChannelServices-Device-Chat.DisplayLoginScreen");
    var sOpts = "left=0,top=0,width=425,height=450,scrollbars=1,resizable=1";
    var windowObject = window.open(oSafeUrl.toURL(), "ChatSettings", sOpts + ",width=350px,height=250px,left=200,top=200");
    if (windowObject.addEventListener) {
      windowObject.addEventListener('load', function() {
        windowObject.document.body.style.overflow = "hidden"; //*** Added this css property to remove horizontal scroll bar for chrome.***
      }, false);
    } else if (windowObject.attachEvent) {
      windowObject.attachEvent('onload', function() {
        windowObject.document.body.style.overflow = "hidden"; //*** Added this css property to remove horizontal scroll bar for ie.***
      }, false);
    }
    oSafeUrl.nullify();
    oSafeUrl = null;
  },


  //TODO: Change UI menu to specify queue/workgroup names

  changeQueue: function(sNewQueueName, sOldQueueName) {
    sOldQueueName = sessionStorage.getItem("Currentqueue");
    if (sOldQueueName != null && sOldQueueName)
      this.leaveAllQueues(sOldQueueName);

    this.joinAllQueues(sNewQueueName);
    sessionStorage.setItem("Currentqueue", sNewQueueName);
  },


  refreshChatMenu: function() {
    pega.u.d.setProperty("$PD_CPMPortalContext$pokRefreshChatMenu", "true");
  },

  changeStatus: function() {
    return;
  },

  getStatusFromElement: function(id) {
    return "";
  },

  getPhoneNumberInputBoxElement: function() {
    return document.querySelector("[name$=pyCpmPhoneNumberInputBox]");
  },

  leaveAllQueues: function(sOldQueueNames) {
    /* loop through the tab-delimited list of queues and close each connection */
    var queues, queueName;
    if (sOldQueueNames != null && sOldQueueNames) {
      queues = sOldQueueNames.split("\t");
      for (var i = 0; i < queues.length; i++) {
        queueName = queues[i];
        if (queueName !== "") {
          oPegaChatAgentConnection.leaveWorkGroup(queueName);
        }
      }
    }
  },

  joinAllQueues: function(sNewQueueNames) {
    /* loop through the tab-delimited list of queues and connect to each */
    var queues, queueName;
    if (sNewQueueNames != null && sNewQueueNames) {
      queues = sNewQueueNames.split("\t");
      for (var i = 0; i < queues.length; i++) {
        queueName = queues[i];
        if (queueName !== "") {
          oPegaChatAgentConnection.joinWorkGroup({ queue: queueName });
        }
      }
    }
  },

  multipleQueues: function(sResultQueueNames) {
    var sNewQueueNames = sResultQueueNames;
    if (sResultQueueNames == "") {
      this.updateReadyAgentState("false");
    }
    /* get the list of existing queue connections */
    var sOldQueueNames = sessionStorage.getItem("Currentqueue");

    /* remove any queue names that are on both lists (current and new) */
    var oldQueues, oldQueueName, newQueues, newQueueName;
    if (sOldQueueNames != null && sOldQueueNames && sNewQueueNames != null && sNewQueueNames) {
      oldQueues = sOldQueueNames.split("\t");
      newQueues = sNewQueueNames.split("\t");
      sOldQueueNames = "\t" + sOldQueueNames;
      sNewQueueNames = "\t" + sNewQueueNames;
      for (var i = 0; i < oldQueues.length; i++) {
        oldQueueName = oldQueues[i];
        for (var j = 0; j < newQueues.length; j++) {
          newQueueName = newQueues[j];
          if (oldQueueName == newQueueName) {
            /* user is staying on this queue */
            sNewQueueNames = sNewQueueNames.replace("\t" + newQueueName + "\t", "\t");
            sOldQueueNames = sOldQueueNames.replace("\t" + oldQueueName + "\t", "\t");
          }
        }
      }
    }

    /* close any existing queue connections, other than ones we are staying on */
    this.leaveAllQueues(sOldQueueNames);

    /* save the ORIGINAL new queue list */
    sessionStorage.setItem("Currentqueue", sResultQueueNames);

    /* loop through the new queues and connect to each */
    this.joinAllQueues(sNewQueueNames);

    /* finally, close the overlay */
    var _this = this;
    if (typeof(pega) != 'undefined' && pega.u.d) {
      setUserStart();
      doModalAction(pega.u.d.submitModalDlgParam, "click");
    }
  },
  ClosePopup: function() {
    var po =  pega.u.d.getPopOver();
    po.close('cancel');

  },

  setChatText: function(text) {
    var iframe = $('div.dc-main div[tabindex="0"] iframe')[0]; //picks the active interaction iframe
    if (iframe) {
      var event = {
        pyEventName: "SetChatText",
        text: text
      }
      iframe.contentWindow.oChatTabEventHandler.eventHandler(event);
    }
  },
  setChatPlaceHolderText: function(text) {
    var iframe = $('div.dc-main div[tabindex="0"] iframe')[0]; //picks the active interaction iframe
    if (iframe) {
      var event = {
        pyEventName: "SetChatPlaceHolderText",
        text: text
      }

      iframe.contentWindow.oChatTabEventHandler.eventHandler(event);
    }
  },

  _sendMessageToServer: function(oEvent) {
    if (oEvent.pyCallId && oEvent.message) {
      oPegaChatAgentConnection.sendMessage(oEvent.pyCallId, oEvent.message, oEvent.category);
    } else {
      console.log("Invalid event:", oEvent);
    }
  },

    _endChat: function(oEvent) {
    var chatId = oEvent.pyCallId;
    var transferChatIds = pega.cs.commonutils.readCookie("transferChats");
    var isMonitor = sessionStorage.getItem(chatId + "-manager-chat-mode");
    isMonitor? isMonitor: "";
    transferChatIds = transferChatIds ? JSON.parse(transferChatIds) : {};
    var sChatId = chatId.replace(/chat/g,'');
    if (chatId) {
      this.delegateChatEvent({ pyEventName: "EndChat", pyCallId: chatId });
      if(transferChatIds[sChatId]==undefined && isMonitor!="monitor"){
        oPegaChatAgentConnection.leaveChat(chatId);
      }else if(transferChatIds[sChatId]==undefined && isMonitor=="monitor"){
        delete this._monitoredChats[chatId];
        oPegaChatAgentConnection.leaveChat(chatId);
      }else if(transferChatIds[sChatId]=="agent"){
        oPegaChatEventHandler.deleteTransferChatIdFromMap(sChatId);
      }
      this.unRegisterChatEventHandler(chatId);
    } else {
      console.log("Invalid event:", oEvent);
    }
  },


  _transferToQueue: function(oEvent) {
    if (oEvent.pyCallId) {
      oPegaChatAgentConnection.blindTransferToQueue(oEvent.pyCallId,
        oEvent.message,
        oEvent.queueInfo,
        oEvent.reason,
        oEvent.announcement,
        oEvent.priority,
        oEvent.metadata);
      this.unRegisterChatEventHandler(oEvent.pyCallId);
    } else {
      console.log("Invalid event:", oEvent);
    }
    
  },
  _sendComposing: function(oEvent) {
    if (oEvent.pyCallId) {
      oPegaChatAgentConnection.sendComposing(oEvent.pyCallId);
    } else {
      console.log("Invalid event:", oEvent);
    }
  },
  _cobrowseRequest: function(oEvent) {
    if (oEvent.pyCallId) {
      oPegaChatAgentConnection.cobrowseRequest(oEvent.pyCallId, oEvent.message);
    } else {
      console.log("Invalid event:", oEvent);
    }
  },
  isChatMonitored: function(chatId) {
    return !!this._monitoredChats[chatId];
  },

  registerChatForMonitoring: function(chatId) {
    if(chatId.lastIndexOf('chat',0)) {
      chatId = 'chat' + chatId;
    }
    this._monitoredChats[chatId] = true;
  },
  
  deleteInteractionBeforeClose: function(chatId) {
    oPegaChatEventHandler._interactionChatMap[chatId] = null;
    delete oPegaChatEventHandler._interactionChatMap[chatId];
    sessionStorage.setItem("_interactionChatMap", JSON.stringify(oPegaChatEventHandler._interactionChatMap));
  },
  
  deleteTransferChatIdFromMap : function(chatId){
    var transferChatIds = JSON.parse(pega.cs.commonutils.readCookie("transferChats"));
    delete transferChatIds[chatId];
    pega.cs.commonutils.setCookie('transferChats', JSON.stringify(transferChatIds));    
  },

  stopMonitoring: function(chatId) {
    if (chatId && oPegaChatEventHandler._interactionChatMap[chatId]) {
      oPegaChatEventHandler._endChat && oPegaChatEventHandler._endChat({pyCallId: oPegaChatEventHandler._interactionChatMap[chatId]});
      oPegaChatEventHandler.deleteInteractionBeforeClose(chatId);
    }
  },
  
  isTransferredChat: function(chatId) {
    return !!this._transferredChats[chatId];
  },

  registerTransferredChat: function(chatId) {
    if(chatId.lastIndexOf('chat',0)) {
      chatId = 'chat' + chatId;
    }
    this._transferredChats[chatId] = true;
  },
  /* KEEP THIS AS THE LAST FUNCTION */
  _lastFunction: function() {}
};




var oPegaChatEventHandler = new pega.chat.chatEventHandler();
window.setTimeout("oPegaChatEventHandler.registerForEvents()", 500);

// Called from the acccept/decline window via Pega-Chat AlertingChatButtons
function acceptChat(sId,queueName,agentID) {
 oPegaChatEventHandler.handleChatAcceptChat(sId,queueName,agentID);
}

function declineChat(sId) {
 oPegaChatEventHandler.handleChatDeclineChat(sId);
}

function acceptTransferredChat(sAssignKey,sId,queueName,agentID) {
  /* BAC- URL Tampering : Registered Open Assignment in ChatToasterPop section on Accept button*/
  /*pega.desktop.openAssignment(sAssignKey,"","",{"shouldCreateAssociateRequestor":"true"}); */
  sessionStorage.setItem("assignmentkey" ,sAssignKey);
  oPegaChatEventHandler.handleChatAcceptChat(sId,queueName,agentID,sAssignKey);
  oPegaChatEventHandler.registerTransferredChat(sId);
}

function DismissExpireChatToasterPop(offerId, action){
  oPegaChatEventHandler.DismissExpireChatToasterPop(offerId,action);
}
function showChatAlert(data){
  oPegaChatEventHandler.showChatToasterPop(data);
}
function showCountdownTimer(offer_timeout,data){
  oPegaChatEventHandler.showCountdownTimer(offer_timeout,data);
}
function sendChatHeartbeat() {
  var heartbeatMessageRequest;
  var agentId;

  if (oPegaChatEventHandler._lastStatusChatEvent != null) {
    agentId = oPegaChatEventHandler._lastStatusChatEvent.pyAgentID;
  }

  var oSafeURL = new SafeURL("ChannelServices-Device-Chat.InvokeChatActivity");
  oSafeURL.put("pzPrimaryPageName", "ChatDevice");
  oSafeURL.put("AgentID", agentId);

  oSafeURL.put("ChatActivityName", "sendHeartbeat");

  pega.util.Connect.initHeader("Content-Type", "application/x-www-form-urlencoded");
     /**INC-171009 changes START**/
  pega.u.d.convertToRunActivityAction(oSafeURL);
  pega.u.d.asyncRequest("POST", oSafeURL, null, null);
  
  /**INC-171009 changes END**/
}

function hideToasterPop() {
  $("#toasterpop").removeClass("alerting");
}



var reconnectIntervalId;
  function UpdateRetrySettings() {
  var oSafeURL = new SafeURL("@baseclass.ChatServerReconnectDetails");
  oSafeURL.put("pzPrimaryPageName", "ChatDevice");
  oSafeURL.put("LookUpValue", "ReconnectInterval");

  pega.u.d.asyncRequest('POST', SafeURL_createFromURL(oSafeURL.toURL()), {
      success: function(data) {
          response = data.responseText
          if (response == "" || isNaN(parseInt(response))) {
              response = 10;
          }
          sessionStorage.setItem("ReconnectInterval", response);
          var oSafeURL_Reconnect = new SafeURL("@baseclass.ChatServerReconnectDetails");
          oSafeURL_Reconnect.put("pzPrimaryPageName", "ChatDevice");
          oSafeURL_Reconnect.put("LookUpValue", "ServerRetries");

          pega.u.d.asyncRequest('POST', SafeURL_createFromURL(oSafeURL_Reconnect.toURL()), {
              success: function(data) {
                  response = data.responseText
                  if (response == "" || isNaN(parseInt(response))) {
                      response = 60;
                  }
                  sessionStorage.setItem("ReconnectAttempts", response);
                  clearSessionVaraibles();
              },
              failure: function() {
                  console.log("Failed to retrieve ServerRetries");
              },
              scope: this
          }, null);
      },
      failure: function() {
          console.log("Failed to retrieve ReconnectInterval");
      },
      scope: this
  }, null);
}

function clearSessionVaraibles() {
  sessionStorage.removeItem("RetryAttempts");
  sessionStorage.removeItem("ReconnectInprogress");

  if (reconnectIntervalId != 'undefined') {
    clearInterval(reconnectIntervalId);
  }
}

function retryLogin() {
  var updateRetryAttempt = "1";
  var reconnectAttempts = sessionStorage.getItem("RetryAttempts");

  if (reconnectAttempts == "undefined" || reconnectAttempts == null) {
    sessionStorage.setItem("RetryAttempts", updateRetryAttempt);
  } else {
    updateRetryAttempt = parseInt(reconnectAttempts) + 1;
    sessionStorage.setItem("RetryAttempts", updateRetryAttempt);
  }

  RefreshAgentState();

  if (parseInt(sessionStorage.getItem("RetryAttempts")) == parseInt(sessionStorage.getItem("ReconnectAttempts"))) {
    sessionStorage.removeItem("ReconnectInprogress");
    clearInterval(reconnectIntervalId);
  }
}


function ReconnectAgentState() {
  var agentStatus = sessionStorage.getItem("agentConnected");
  if (agentStatus == "true") {
    displayReconnectedIcon(true);
    var reconnectInterval = parseInt(sessionStorage.getItem("ReconnectInterval")) * 1000;
    reconnectIntervalId = setInterval(function() { retryLogin() }, reconnectInterval);
  }
}


function displayReconnectedIcon(displayValue) {
  pega.u.d.setProperty("$PD_CPMPortalContext$pIsChatAgentReconnecting", displayValue);
  if(displayValue)
    {
      //publish presence for chat status
       var oSafeUrl = new SafeURL("@baseclass.SetCsrPresenceRecordForLogin");
        pega.u.d.asyncRequest("POST", SafeURL_createFromURL(oSafeUrl.toURL()), {
                success: function(oResponse) {
                pega.api.ui.actions.refreshSection ({ 'section' : 'PegaChatSection' });
                },
                failure: function() {
                console.log("Error while updating presence");
      },
      scope: this
    }, null);            
            //end of publish presence
    }
  else
    {
      //publish presence for chat status
       var oSafeUrl = new SafeURL("@baseclass.SetCsrPresenceRecordForReconnect");
        pega.u.d.asyncRequest("POST", SafeURL_createFromURL(oSafeUrl.toURL()), {
                success: function(oResponse) {
                pega.api.ui.actions.refreshSection ({ 'section' : 'PegaChatSection' });
                },
                failure: function() {
                console.log("Error while updating presence");
      },
      scope: this
    }, null);            
            //end of publish presence
    }
}

function RefreshAgentState() {
  var agentID = sessionStorage.getItem("agentID");
  var pwd = sessionStorage.getItem("pwd");
  var serverURL = sessionStorage.getItem("serverURL");
  var displayName = sessionStorage.getItem("displayName");
  var resourceID = sessionStorage.getItem("resourceID");


  if (agentID != "null" && pwd != "null" && serverURL != "null" &&
    agentID != null && pwd != null && serverURL != null &&
    agentID != undefined && pwd != undefined && serverURL != undefined){
    oPegaChatEventHandler.chatLoginDirect(serverURL, agentID, pwd, displayName, resourceID);
  } else {
      /* The below code is converted to use asyncReuqest API instead of returnXMLHttpObj */
     var chatAutologinURL = new SafeURL("@baseclass.GetChatAutologinSettings");
    pega.u.d.asyncRequest('GET', SafeURL_createFromURL(chatAutologinURL.toURL()), {
      success: function (respObject) {
        response = respObject.responseText.trim().split('#');
         if (response.length === 7) {
          sessionStorage.setItem("PSCserver", response[5]);
          //sessionStorage.setItem("employeeID", response[2]);
          sessionStorage.setItem("customized_display_name", response[6]);
          agentID = response[1];
          pwd = response[2];
          serverURL = response[0];
          displayName = response[6];
          resourceID = response[3];
          oPegaChatEventHandler.chatLoginDirect(serverURL, agentID, pwd, displayName, resourceID);
        } else {
          oPegaChatEventHandler.handleChatLogout();
        }
      },
      failure: function () {
        console.log("failed");
      },
      scope: this
    }, null);
  }
  
}




$(document).ready(function() {

  try {
   
    RefreshAgentState();
  } catch (e) {

  }

});


function CPMGetDynamicReference() {
  var recentUrl = new SafeURL("@baseclass.CPMGetDynamicReferenceActivity");
  pega.u.d.asyncRequest('GET', SafeURL_createFromURL(recentUrl.toURL()), {
  success: function (respObject) {
    var applicationSettings = JSON.parse(respObject.responseText);
    return applicationSettings;
  },
  failure: function () {
    console.log("failed");
  },
  scope: this
  }, null);
}


//returns the xmlhttpobject dpending upon different browsers
function returnXMLHttpObj() {
  var request = null;
  if (window.XMLHttpRequest) {
    //For Non IE Browser
    request = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    //For IE Browser
    try {
      request = new ActiveXObject("Microsoft.XMLHTTP");
    } catch (e1) {
      try {
        request = new ActiveXObject("MSXML2.XMLHTTP");
      } catch (e2) {
        try {
          request = new ActiveXObject("MSXML3.XMLHTTP");
        } catch (e3) {
          alert("Create Ajax Failed!" + e3)
        }
      }
    }
  }
  return request;
}
 
function sendBlindTransferToQueue(transferEvent) {
  var userName = transferEvent.$ev.detail.response.SelectedEmployee;
  var userID = transferEvent.$ev.detail.response.EmployeeIDforTransfer;

  var metadata = {};
  var sChatId = transferEvent.$ev.detail.response.ChatIdForTransfer;
  metadata.AppTransferWorkID = transferEvent.$ev.detail.response.InteractionID;

  metadata.AppTransferReason = transferEvent.$ev.detail.response.TransferReason || "";

  metadata.AppTransferComment = transferEvent.$ev.detail.response.TransferComment || "";

  var queueInfo = {};
  queueInfo.queue = transferEvent.$ev.detail.response.pyDestination;
  if (!queueInfo.queue) {
    queueInfo.queue = transferEvent.$ev.detail.response.SelectedQueueforTransfer;
  }
  if (userName) {
    queueInfo.agent = userID;
  }

  var message = (queueInfo.agent) ? "You are being transferred to " + userName + "." : "You are being transferred to the " + queueInfo.queue + " queue.";
  var oEvent = {
    pyEventName: "TransferToQueue",
    pyCallId: sChatId,
    queueInfo: queueInfo,
    announcement: message,
    priority: "100",
    metadata: metadata
  }
  oPegaChatEventHandler.handleChatEvent(oEvent);
  sessionStorage.removeItem(sChatId);
}


//static-content-hash-trigger-GCC
/* function called from chat dialog window*/

var sAgentName = "";

function loginSucceded(sId, sAlias, sQueue, sServer) {

	sAgentName = sAlias;

	// Moved to pega_cpm_callchat file due to timing issues 
	// registerEventCallback("Chat", handleChatEvent); 
}

function handleChatEvent(sXml) {


	var oJSON = generateJSONFromEvent(sXml);
	var oDate = new Date();
	oJSON.TimeStamp = oDate.getTime();

	oDate = null;

	var sEvent = serialize(oJSON);

	sendEvent("ChannelAgentStateEvent", sEvent);

}

function getXMLEventObject(xmlString) {
  var xmlDoc;
  try {
    xmlDoc = pega.tools.XMLDocument.get();
    xmlDoc.loadXML(xmlString);
  } catch(e) {    
       alert("Unable to load the XML Document.");
  }
  return xmlDoc;
}



function generateJSONFromEvent(eventXML) {
	var objXMLDoc = getXMLEventObject(eventXML);
	var oRETURNOBJ = new Object(); 
	/* initialize oReturnObject */
	oRETURNOBJ.Media ="";
	oRETURNOBJ.CallId ="";
	oRETURNOBJ.OtherDN ="";
	oRETURNOBJ.OtherDNName ="";
	oRETURNOBJ.EventName ="";
	oRETURNOBJ.AgentId ="";
	oRETURNOBJ.AgentName = sAgentName;

	oRETURNOBJ.AgentQueue = "";
	oRETURNOBJ.AgentServerName = "";

	oRETURNOBJ.oEventData = new Object();

	var oCurrNode = null;
	var oBaseNode = null;
	var oCurrElem = null;
	var oDescNode = null;
	   
	if (objXMLDoc == null) {
		return oRETURNOBJ;
	}
	else {      
		var oBaseNode = pega.util.Dom.getFirstChild(objXMLDoc);
		if (oBaseNode == null) {
			return oRETURNOBJ;
		}
		
                  var oBodyNode  = pega.util.Dom.getFirstChild(oBaseNode);
		if (oBodyNode == null) {
			return oRETURNOBJ;
		}

		var oEventNode = pega.util.Dom.getFirstChild(oBodyNode);
		if (oEventNode == null) {
			return oRETURNOBJ;
		}
							  
		oCurrNode = pega.util.Dom.getFirstChild(oEventNode);
		while (oCurrNode != null) {              
			switch (oCurrNode.tagName) {
				case "pyEventName":
					oRETURNOBJ.EventName = oCurrNode.text;
					break;
				case "pyCallId":
					oRETURNOBJ.CallId = oCurrNode.text;
					break;
				case "pyOtherPartyID":
					oRETURNOBJ.OtherDN = oCurrNode.text;
					break;
				case "pyMedia":
					oRETURNOBJ.Media = oCurrNode.text;
					break;
				case "pyAgentID":
					oRETURNOBJ.AgentId = oCurrNode.text;
					break;
				case "pyOtherPartyName":
					oRETURNOBJ.OtherDNName = oCurrNode.text;
					break;
				case "pyMessageBody" :
					oRETURNOBJ.MessageBody = oCurrNode.text;
					break;
				case "pxObjClass" :
					oRETURNOBJ.ObjClass = oCurrNode.text;
					break;
				case "pyUserAlias" :
					oRETURNOBJ.AgentName = oCurrNode.text;
					break;
				case "pyAgentQueue" :
					oRETURNOBJ.AgentQueue = oCurrNode.text;
					break;
				case "pyAgentServerName" :
					oRETURNOBJ.AgentServerName = oCurrNode.text;
					break;
				default:
					oRETURNOBJ.oEventData[oCurrNode.tagName] = oCurrNode.text;
					break;
			} // switch
			
			oCurrNode = pega.util.Dom.getNextSibling(oCurrNode);
                 }
	}

	return oRETURNOBJ;
}
/* start of CSmdcswitch */
/* register events for ajax container switch */

pega.ui.EventsEmitter.subscribe("onACSwitch", CSOnMdcSwitch, null, null, null, true);
pega.ui.EventsEmitter.subscribe("postMDCRender", CSOnMdcPost, null, null, null, true);
pega.ui.EventsEmitter.subscribe("preMDCRender", CSOnMdcPre, null, null, null, true);

function hideActionAreaInner() {
    scrollWorkAreaToTop();
    //hide the docs in ajax container
    var ajaxDocs = pega.redux.Utils.getAjaxContainerState().mdcDocs;
    for (var i = 0; i < ajaxDocs.length; ++i) {
        var recordId = ajaxDocs[i].recordId;
        if (ajaxDocs[i].isStatic !== "true") {
            document.querySelector("div[data-mdc-recordid=" + recordId + "]").setAttribute("class", "hide");
        }
        else {
            document.querySelector("div[data-mdc-recordid=" + recordId + "]").setAttribute("class", "show");
        }
    }
    $("div").find(".wrap-up-visibility").css("display", "block");
}

function refreshKMView() {

    //updating the harness context for interaction
    var currentInteractionContext = pega.ctxmgr.getContextByProperty("strPyID", pega.redux.Utils.getAjaxContainerState().parentKey);
    pega.ctxmgr.setContext(currentInteractionContext);

    var sectionKMNode = pega.u.d.getSectionByName("CSKMArticlesDisplayWrapper", "", document.body);
    if (sectionKMNode) {
        pega.u.d.reloadSection(sectionKMNode, "", "", false, true, "", false);
    }
    var KMSuggestionCount = pega.u.d.getSectionByName("SuggestedArticleCountForIntentTask", "", document.body);
    if (KMSuggestionCount) {
        pega.u.d.reloadSection(KMSuggestionCount, "", "", false, true, "", false);
    }
    var sectionKMHNode = pega.u.d.getSectionByName("CSKMHeader", "", document.body);
    if (sectionKMHNode) {
        pega.u.d.reloadSection(sectionKMHNode, "", "", false, true, "", false);
    }

    pega.ctxmgr.resetContext();

}

function CSOnMdcPre() {
    scrollWorkAreaToTop();
    //updating the harness context for interaction
    var currentInteractionContext = pega.ctxmgr.getContextByProperty("strPyID", pega.redux.Utils.getAjaxContainerState().parentKey);
    pega.ctxmgr.setContext(currentInteractionContext);

    var sectionTasksNode = pega.u.d.getSectionByName("CPMInteractionTasksWrapper", "", document.body);
    if (sectionTasksNode) {
        pega.u.d.reloadSection(sectionTasksNode, "", "", false, true, "", false);
    }
  
    var sectionAddTaskNode = pega.u.d.getSectionByName("CSInteractionDriverAddTask", "", document.body);
    if (sectionAddTaskNode) {
        pega.u.d.reloadSection(sectionAddTaskNode, "", "", false, true, "", false);
    }
  
    var sectionWrapUpNode = pega.u.d.getSectionByName("InteractionWrapUp", "", document.body);
    if (sectionWrapUpNode) {
        pega.u.d.reloadSection(sectionWrapUpNode, "", "", false, true, "", false);
    }

    var sectionSuggestionsNode = pega.u.d.getSectionByName("CSSuggestionsWrapper", "", document.body);
    if (sectionSuggestionsNode) {
        pega.u.d.reloadSection(sectionSuggestionsNode, "", "", false, true, "", false);
    }

    var sectionKMNode = pega.u.d.getSectionByName("CSKMArticlesDisplayWrapper", "", document.body);
    if (sectionKMNode) {
        pega.u.d.reloadSection(sectionKMNode, "", "", false, true, "", false);
    }
    var KMSuggestionCount = pega.u.d.getSectionByName("SuggestedArticleCountForIntentTask", "", document.body);
    if (KMSuggestionCount) {
        pega.u.d.reloadSection(KMSuggestionCount, "", "", false, true, "", false);
    }
    var sectionKMHNode = pega.u.d.getSectionByName("CSKMHeader", "", document.body);
    if (sectionKMHNode) {
        pega.u.d.reloadSection(sectionKMHNode, "", "", false, true, "", false);
    }
    var sectionCompHeaderNode = pega.u.d.getSectionByName("CPMcompositesHeader", "", document.body);
    if (sectionCompHeaderNode) {
        pega.u.d.reloadSection(sectionCompHeaderNode, "", "", false, true, "", false);
    }
    var sectionCaseactionNode = pega.u.d.getSectionByName("pyCaseActionArea", "", document.body);
    var compositesNode = pega.u.d.getSectionByName("CPMCompositesContainer", "", document.body);
    var activeDocsLen = pega.redux.Utils.getAjaxContainerState().activeDocs.length;
    var activeDocInd = pega.redux.Utils.getAjaxContainerState().activeDocs[activeDocsLen - 1];
    if (activeDocInd > 0 && !sectionCaseactionNode.contains(compositesNode)) {
        $("div").find(".wrap-up-visibility").css("display", "none");

        if (activeDocInd > 0) {
            var ajaxDocs = pega.redux.Utils.getAjaxContainerState().mdcDocs;
            var recordId = ajaxDocs[0].recordId;
            document.querySelector("div[data-mdc-recordid=" + recordId + "]").setAttribute("class", "hide");
        }
    }
    else
        $("div").find(".wrap-up-visibility").css("display", "block");

    pega.ctxmgr.resetContext();

}

function CSOnMdcPost() {
    scrollWorkAreaToTop();
    var oSafeURL = new SafeURL("System-User-Recents.CSRecentContextSwitch");
    if (pega.ctx.strPyID !== null)
        oSafeURL.put("pyRecordID", pega.ctx.strPyID);
    if (pega.ctx.recordId !== null && pega.ctx.recordId !== undefined)
        oSafeURL.put("pyDomID", pega.ctx.recordId);
    if (pega.ctx.strHarnessClass !== null && pega.ctx.strHarnessClass !== undefined)
        oSafeURL.put("pyClassName", pega.ctx.strHarnessClass);
    if (pega.ctx.strKey !== null && pega.ctx.strKey != undefined)
        oSafeURL.put("pyRecordKey", pega.ctx.strKey);
    if (pega.ctx.strHarnessPurpose !== null && pega.ctx.strHarnessPurpose !== undefined) {
        oSafeURL.put("HarnessPurpose", pega.ctx.strHarnessPurpose);
        if (pega.ctx.strHarnessPurpose == "New") {
            var mdcDocsLen = pega.redux.Utils.getAjaxContainerState().mdcDocs.length;
            oSafeURL.put("pyRecordKey", pega.redux.Utils.getAjaxContainerState().mdcDocs[mdcDocsLen - 1].recordKey);
        }
    }

    if (pega.redux.Utils.getAjaxContainerState().parentKey !== null && pega.redux.Utils.getAjaxContainerState().parentKey !== undefined)
        oSafeURL.put("pyParentKey", pega.redux.Utils.getAjaxContainerState().parentKey);

    if (pega.ctx.strPyLabel !== null && pega.ctx.strPyLabel != undefined)
        oSafeURL.put("pyLabel", pega.ctx.strPyLabel);
    oSafeURL.put("MdcAction", "MDCPost");

    pega.u.d.asyncRequest('GET', SafeURL_createFromURL(oSafeURL.toURL()), {
        success: function (oResponse) {
            //updating the harness context for interaction
            var currentInteractionContext = pega.ctxmgr.getContextByProperty("strPyID", pega.redux.Utils.getAjaxContainerState().parentKey);
            pega.ctxmgr.setContext(currentInteractionContext);

            var sectionKMNode = pega.u.d.getSectionByName("CSKMArticlesDisplayWrapper", "", document.body);
            if (sectionKMNode) {
                pega.u.d.reloadSection(sectionKMNode, "", "", false, true, "", false);
            }
            //Start --- US-211310. Refresh the count section in post MDC
            var KMSuggestionCount = pega.u.d.getSectionByName("SuggestedArticleCountForIntentTask", "", document.body);
            if (KMSuggestionCount) {
                pega.u.d.reloadSection(KMSuggestionCount, "", "", false, true, "", false);
            }
            //END --- US-211310. Refresh the count section in post MDC
            var sectionKMHNode = pega.u.d.getSectionByName("CSKMHeader", "", document.body);
            if (sectionKMHNode) {
                pega.u.d.reloadSection(sectionKMHNode, "", "", false, true, "", false);
            }
            var sectionCompHeaderNode = pega.u.d.getSectionByName("CPMcompositesHeader", "", document.body);
            if (sectionCompHeaderNode) {
                pega.u.d.reloadSection(sectionCompHeaderNode, "", "", false, true, "", false);
            }

            var ShowCustomerWrapper = pega.u.d.getSectionByName("ShowCustomerWrapper", "", document.body);
            if (ShowCustomerWrapper) {
                pega.u.d.reloadSection(pega.u.d.getSectionByName("ShowCustomerWrapper", "", ""));
            }
            /* Hide the interaction dialog */
            var ajaxDocs = pega.redux.Utils.getAjaxContainerState().mdcDocs;
            if (ajaxDocs.length > 0) {
                var recordId = ajaxDocs[0].recordId;
                document.querySelector("div[data-mdc-recordid=" + recordId + "]").setAttribute("class", "hide");
            }
        },
        failure: function () {
            //Start --- US-211310. Need to Refresh the count section even on failure
            var KMSuggestionCount = pega.u.d.getSectionByName("SuggestedArticleCountForIntentTask", "", document.body);
            if (KMSuggestionCount) {
                pega.u.d.reloadSection(KMSuggestionCount, "", "", false, true, "", false);
            }
            //US-211310. Need to Refresh the count section even on failure --- END
            console.log("Unable to update the list for record " + pega.ctx.strPyID);
        }
    }, '');
    pega.ctxmgr.resetContext();
    if (pega.chat !== undefined && pega.chat.ChatComponentEventHandler !== undefined) {
        pega.chat.ChatComponentEventHandler.publishChatEvents("UpdateServiceCaseID", {
            'id': pega.ctx.strPyID,
            'type': 'SERVICE CASE IN-PROGRESS'
        });
    }
    /* Auto map any detected entities */
    if (typeof autoMapDetectedEntities == "function") {
        autoMapDetectedEntities();
    }
}


function CSOnMdcSwitch() {
    scrollWorkAreaToTop();
    var oSafeURL = new SafeURL("System-User-Recents.CSRecentContextSwitch");
    if (pega.ctx.strPyID !== null)
        oSafeURL.put("pyRecordID", pega.ctx.strPyID);
    if (pega.ctx.recordId !== null && pega.ctx.recordId !== undefined)
        oSafeURL.put("pyDomID", pega.ctx.recordId);
    if (pega.ctx.strHarnessClass !== null && pega.ctx.strHarnessClass !== undefined)
        oSafeURL.put("pyClassName", pega.ctx.strHarnessClass);
    if (pega.ctx.strKey !== null && pega.ctx.strKey != undefined)
        oSafeURL.put("pyRecordKey", pega.ctx.strKey);
    if (pega.ctx.strHarnessPurpose !== null && pega.ctx.strHarnessPurpose !== undefined) {
        oSafeURL.put("HarnessPurpose", pega.ctx.strHarnessPurpose);
        if (pega.ctx.strHarnessPurpose == "New") {
            var mdcDocsLen = pega.redux.Utils.getAjaxContainerState().mdcDocs.length;
            oSafeURL.put("pyRecordKey", pega.redux.Utils.getAjaxContainerState().mdcDocs[mdcDocsLen - 1].recordKey);
        }
    }
    if (pega.redux.Utils.getAjaxContainerState().parentKey !== null && pega.redux.Utils.getAjaxContainerState().parentKey !== undefined)
        oSafeURL.put("pyParentKey", pega.redux.Utils.getAjaxContainerState().parentKey);

    if (pega.ctx.strPyLabel !== null && pega.ctx.strPyLabel != undefined)
        oSafeURL.put("pyLabel", pega.ctx.strPyLabel);
    oSafeURL.put("MdcAction", "MDCSwitch");
    pega.u.d.asyncRequest('GET', SafeURL_createFromURL(oSafeURL.toURL()), {
        success: function (oResponse) {
            //updating the harness context for interaction
            var currentInteractionContext = pega.ctxmgr.getContextByProperty("strPyID", pega.redux.Utils.getAjaxContainerState().parentKey);
            pega.ctxmgr.setContext(currentInteractionContext);

            var sectionTasksNode = pega.u.d.getSectionByName("CPMInteractionTasksWrapper", "", document.body);
            if (sectionTasksNode) {
                pega.u.d.reloadSection(sectionTasksNode, "", "", false, true, "", false);
            }
          
            var sectionAddTaskNode = pega.u.d.getSectionByName("CSInteractionDriverAddTask", "", document.body);
            if (sectionAddTaskNode) {
                pega.u.d.reloadSection(sectionAddTaskNode, "", "", false, true, "", false);
            }

            var sectionWrapUpNode = pega.u.d.getSectionByName("InteractionWrapUp", "", document.body);
            if (sectionWrapUpNode) {
                pega.u.d.reloadSection(sectionWrapUpNode, "", "", false, true, "", false);
            }

            var sectionKMNode = pega.u.d.getSectionByName("CSKMArticlesDisplayWrapper", "", document.body);
            if (sectionKMNode) {
                pega.u.d.reloadSection(sectionKMNode, "", "", false, true, "", false);
            }
            var KMSuggestionCount = pega.u.d.getSectionByName("SuggestedArticleCountForIntentTask", "", document.body);
            if (KMSuggestionCount) {
                pega.u.d.reloadSection(KMSuggestionCount, "", "", false, true, "", false);
            }
            var sectionKMHNode = pega.u.d.getSectionByName("CSKMHeader", "", document.body);
            if (sectionKMHNode) {
                pega.u.d.reloadSection(sectionKMHNode, "", "", false, true, "", false);
            }
            var sectionCompHeaderNode = pega.u.d.getSectionByName("CPMcompositesHeader", "", document.body);
            if (sectionCompHeaderNode) {
                pega.u.d.reloadSection(sectionCompHeaderNode, "", "", false, true, "", false);
            }

            var sectionCaseactionNode = pega.u.d.getSectionByName("pyCaseActionArea", "", document.body);
            var compositesNode = pega.u.d.getSectionByName("CPMCompositesContainer", "", document.body);
            var activeDocsLen = pega.redux.Utils.getAjaxContainerState().activeDocs.length;
            var activeDocInd = pega.redux.Utils.getAjaxContainerState().activeDocs[activeDocsLen - 1];

            if (activeDocsLen == 1) {
                var sectionCoachingTipDialog = pega.u.d.getSectionByName("CPMCoachingTipDialogWrapper", "", document.body);
                if (sectionCoachingTipDialog) {
                    pega.u.d.reloadSection(sectionCoachingTipDialog, "", "", false, true, "", false);
                }
                //display search box when service case is opened and cancelled for anonymous caller
                var sectionWrapUpNode = pega.u.d.getSectionByName("CAWrapUp", "", document.body);
                if (!sectionWrapUpNode)
                    if (!sectionCaseactionNode.contains(compositesNode)) {
                        if (compositesNode) {
                            $("div").find(".wrap-up-visibility").css("display", "none");
                        } else {
                            $("div").find(".wrap-up-visibility").css("display", "block");
                        }
                    }
                /******** SE-56520 fix starts****************/
                var sectionWrapUpNode = pega.u.d.getSectionByName("CAWrapUp", "", document.body);
                if (!sectionWrapUpNode)
                    if (!sectionCaseactionNode.contains(compositesNode)) {
                        $("div").find(".wrap-up-visibility").css("display", "block");
                    }
                /******** SE-56520 fix ends****************/
            }
            if (activeDocInd > 0 && !sectionCaseactionNode.contains(compositesNode)) {
                $("div").find(".wrap-up-visibility").css("display", "none");
                if (activeDocInd > 0) {
                    var ajaxDocs = pega.redux.Utils.getAjaxContainerState().mdcDocs;
                    var recordId = ajaxDocs[0].recordId;
                    document.querySelector("div[data-mdc-recordid=" + recordId + "]").setAttribute("class", "hide");
                }
            }
            else {
                // Commented out so the wrap-up is only displayed after clicking. This allows for refresh of the section. 
                // $("div").find(".wrap-up-visibility").css("display","block");

                if ($(".cpmsearch-visibility input#OfferAccepted").val() == "Declined") {
                    $("div").find(".wrap-up-visibility").css("display", "block");
                }
            }
        },
        failure: function () {
            console.log("Unable to update the list for record " + pega.ctx.strPyID);
        }
    }, '');
    pega.ctxmgr.resetContext();
    if (pega.chat !== undefined && pega.chat.ChatComponentEventHandler !== undefined) {
        pega.chat.ChatComponentEventHandler.publishChatEvents("UpdateServiceCaseID", {
            'id': pega.ctx.strPyID,
            'type': 'SERVICE CASE ENDED'
        });
    }

    /* Auto map any detected entities */
    if (typeof autoMapDetectedEntities == "function") {
        autoMapDetectedEntities();
    }
}

function CSCloseRecent(activeMDCIndex) {
    if (activeMDCIndex != "") {
        var nextHarnessContext = pega.ctxmgr.getContextByProperty("recordId", activeMDCIndex);

        //switch the harness context to next active context  
        pega.ctxmgr.setContext(nextHarnessContext);
        pega.ctx.gDirtyOverride = false;
        pega.u.d.doClose();
        pega.ctxmgr.resetContext();
        /******** SE-56520 fix starts****************/
        var sectionCaseactionNode = pega.u.d.getSectionByName("pyCaseActionArea", "", document.body);
        var sectionWrapUpNode = pega.u.d.getSectionByName("CAWrapUp", "", document.body);

        if (!sectionWrapUpNode) {
            if (!sectionCaseactionNode.contains(compositesNode)) {
                pega.ctx.gDirtyOverride = false;
            }
        }
        else
            pega.ctx.gDirtyOverride = true;
        /******** SE-56520 fix ends****************/
    }
}

function switchToThisServiceCase(event) {
    if (event && event.target) {
        $(".task-selected").removeClass("task-selected");
        $(event.target).closest(".service-case-wrapper").find(".service-case-task").addClass("task-selected")
    }
}

/* end of csmdcswitch */

/* used to evalaute verification questions when display one questionat a time is selected */
function checkIfVerficationIsEvaluated(eventtype) {
    if (eventtype == "fail")
        $('.VerificationFail button')[0].blur();
    var oSafeURL = new SafeURL("@baseclass.czShowProperyResponse");
    oSafeURL.put("pzPrimaryPageName", "pyWorkPage");
    oSafeURL.put("ShowProperty", "Verified");
    pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
    var transaction = pega.u.d.asyncRequest('POST', oSafeURL, {
        success: function (respObject) {
            Verified1 = respObject.responseText;
            if (Verified1 != "true" && Verified1 != "false") {
                return;
            }
            else
                doFormSubmit('pyActivity=FinishAssignment');
        },
        failure: function () { },
        scope: this
    }, null);

}

if (!pega)
    var pega = {};

if (!pega.cpm)
    pega.cpm = {};

if (!pega.cpm.IP)
    pega.cpm.IP = {};


if (!pega.cpm.IP.NonNativeCase)
    pega.cpm.IP.NonNativeCase = {};


pega.cpm.IP.closeChatInteraction = function (sid) {
    if (sid) {
        window.parent.oPegaChatAgentConnection.leaveChat(sid);
    }

}

pega.cpm.IP.doClientClose = function (paramRecordID) {
    if (typeof (paramRecordID) != 'undefined') {
        oChatTabEventHandler._endChatInteraction(paramRecordID);
    }

    /* if what we are closing is the monitoring of a chat, tell the chat server */
    if (typeof (parent.channelIDObj) != 'undefined' && typeof (parent.channelIDObj[paramRecordID]) != 'undefined') {
        parent.oPegaChatAgentConnection.leaveChat(parent.channelIDObj[paramRecordID]);
        delete parent.channelIDObj[paramRecordID];
    }
}

/* End Event Raisers */




/* Invokes the finish assignment on the given iframe - this is called on confirm button of confirm screen when we've to submit an assignment in interaction thread to take it cpminteraction driver from a service case context*/
pega.cpm.IP.submitAssignmentInInteractionThread = function (interactionThreadName) {
    /* Find iframes */
    var iframes = $(window.parent.document).find("iframe");
    for (i = 0; i < iframes.length; i++) {
        /* Check thread name to find corresponding iframe */
        /* BUG-358499 changed indexof to strict comparision */
        if ($(iframes[i].parentNode).attr("pegathread") == interactionThreadName) {

            iframes[i].contentWindow.doFormSubmit('pyActivity=FinishAssignment', this, "Submitting", null);

            break;
        }
    }
    delete iframes; /* Cleaning object */
}

/*Invoking Application Guides scripts*/
pega.cpm.toggleAppGuide = function () {
    var composerWinCtx = pega.ui.composer.getCurrentComposerWindow();
    composerWinCtx.pega.ui.guide.toggle();
    var guidePanel = composerWinCtx.document.querySelector(".pz-guide-panel");
    if (guidePanel) {
        guidePanel.style.height = null;
    }
}
/*End of App guide scripts*/

/* For closing remote cases */
pega.cpm.IP.close = function (ThreadName) {
    /* Find iframes */
    var iframes = $(window.parent.document).find("iframe");
    var ifrIndx = 0
    for (; ifrIndx < iframes.length; ifrIndx++) {
        /* Check thread name to find corresponding iframe */
        var thread = $(iframes[ifrIndx].parentNode).attr("pegathread");
        if (ThreadName.indexOf(thread) != -1) {
            /* get iframe document and link */
            var iframeDoc = iframes[ifrIndx].contentWindow.document;
            var closeLink = iframeDoc.getElementsByClassName("CloseLayout")[0].getElementsByTagName("a")[0];
            /* Trigerring click on the hidden link for closing the item */
            pega.control.actionSequencer.fireTopPriorityEvent(closeLink, "click");
            break;
        }
    }
    delete iframes; /* Cleaning object */
}



pega.cpm.IP.NonNativeCase.cancel = function (event) {
    if (event.caseKey == pega.cpm.IP.NonNativeCase.caseKey) /* checking whether event is intended for this document */ {
        pega.cpm.IP.close(caseKey);
    }
};

pega.cpm.IP.NonNativeCase.close = function (event) {
    if (event.caseKey == pega.cpm.IP.NonNativeCase.caseKey) /* checking whether event is intended for this document */ {
        pega.cpm.IP.close(caseKey);
    }
};

/* This will be called after the remote case body onload */
pega.cpm.IP.NonNativeCase.resizeIframe = function (ThreadName, height) {

    /* loop iframes */
    try {
        var iframes = $(window.parent.document).find("iframe"),
            targetIframe, nonNativeframe;

        for (var i = 0; i < iframes.length; i++) {
            /* Check thread name to find corresponding iframe */
            if ($(iframes[i].parentNode).attr("pegathread") == ThreadName) {
                targetIframe = iframes[i];
                nonNativeframe = window.document.getElementsByTagName("iframe")[0]; //this will take the caseframe
                break;
            }
        }

        if (height && height <= 800) {
            nonNativeframe.style.height = height + 'px';
        } else if (height && height > 800) {
            nonNativeframe.style.overflow = 'auto';
            nonNativeframe.style.height = '800px';
        } else {
            nonNativeframe.style.height = '430px';
        }

    } catch (e) {
        // console.log(e);
    }

};


/* Start utility functions */

//To handle multiple select for the Add Task button in interaction
function queueIntentTask(param_TaskName, param_TaskClass, param_TaskFlow, label, RemoteCaseType, IsNonNativeCase, event) {

    var UniqueTaskId = new Date().getTime();
    gSelectedTasksStack.push({ TaskName: param_TaskName, TaskClass: param_TaskClass, TaskFlow: param_TaskFlow, label: label, RemoteCaseType: RemoteCaseType, UniqueTaskId: UniqueTaskId, IsNonNativeCase: IsNonNativeCase });
    /* set unique attribute for the element */
    var currentDomElement = pega.util.Event.getTarget(event);
    $(currentDomElement).parents().eq(4).attr("UniqueTaskId", UniqueTaskId);
}

function removeIntentTask(event) {

    /* get unique attribute for the element */
    var currentDomElement = pega.util.Event.getTarget(event);
    var selectedUniqueTaskId = $(currentDomElement).parents().eq(4).attr("UniqueTaskId");
    for (i = 0; i < gSelectedTasksStack.length; i++) {
        if (gSelectedTasksStack[i].UniqueTaskId == selectedUniqueTaskId) {
            gSelectedTasksStack.splice(i, 1);
            break;
        }
    }
}

function launchTasksSelected(interactionID) {
  
    pega.u.d.gBusyInd && pega.u.d.gBusyInd.show(true,true);
    gSelectedTaskListSize = gSelectedTasksStack.length;

    if (gSelectedTaskListSize == 0) {
        return;
    }
    else if (gSelectedTaskListSize > 0) {

        copySelectedTasksStack = gSelectedTasksStack.slice();

        var thisTask = copySelectedTasksStack.shift();
        var thisTaskClass = thisTask.TaskClass;
        var thisTaskFlow = thisTask.TaskFlow;
        var flowParams = "";

        if (thisTask.RemoteCaseType != "")
            flowParams += "&RemoteCaseType=" + thisTask.RemoteCaseType;
        if (thisTask.IsNonNativeCase != "")
            flowParams += "&IsNonNativeCase=" + thisTask.IsNonNativeCase;

        queueselectedtasks(gSelectedTasksStack, interactionID, function () {
            window.createNewWork(thisTaskClass, "", thisTaskFlow, flowParams, "", "", "", { target: "microdc" });
        });

    }
}



function queueselectedtasks(copySelectedTasksStack, interactionID, createWorkCall) {

    var QueuedTasks = "";
    for (var selectedTaskIndex in copySelectedTasksStack) {
        var selectedTask = copySelectedTasksStack[selectedTaskIndex];
        if (!selectedTask) continue;

        QueuedTasks += selectedTask.TaskName + ":" + selectedTask.TaskClass + ":" + selectedTask.TaskFlow + ":" + selectedTask.label;
        /*SE-69136:Intent with comma in desc/id is not Launching from Add Task*/
        QueuedTasks += ";;";
    }

    var oSafeURL = new SafeURL("PegaCA-Work-Interaction.CSQueueTasks");

    oSafeURL.put("QueuedTasks", QueuedTasks);
    oSafeURL.put("InteractionID", interactionID);

    pega.u.d.asyncRequest('POST', SafeURL_createFromURL(oSafeURL.toURL()), {
        success: function (oResponse) {
            /* Display the busy indicator */
            /*SE-63028 commented below line*/
            //parent.showCPMBusyIndicator("driver");
            createWorkCall();
        },
        failure: function () {
        }
    }, "");

}


function initializeTasks() {
    gSelectedTasksStack = new Array();
    copySelectedTasksStack = new Array();

}

function initializeTasksMenu() {
    gSelectedTasksStack = new Array();
    copySelectedTasksStack = new Array();
}


function launchResearchItem() {
    var flowParams = "";
    var CPMResearchIntClass = arguments[0];
    var CPMResearchIntFlow = arguments[1];
    var CPMDataSource = arguments[2];
    flowParams = flowParams + "&CPMDataSource=" + CPMDataSource;
    //iterating over the additional parameters that will be passed to the param page of the flow's data transform
    for (var i = 3; i < arguments.length; i++) {
        //as the first two parameters are pre-fixed rectifying the argument number for additional parameters.
        var k = i - 2;
        flowParams = flowParams + "&Parameter" + k + "=" + arguments[i];
    }

    pega.desktop.createNewWork(CPMResearchIntClass, "", CPMResearchIntFlow, flowParams, "", "", "", "");
}

function CPMGetDetailsOfDataSource() {
    var CPMDataSource = arguments[0];
    var parameter = arguments[1];
    var oSafeURL = new SafeURL("CPMGetDetailsOfDataSource");
    var recentUrl = SafeURL_createFromURL(oSafeURL.toURL())
    recentUrl.put("DataSource", CPMDataSource);

    var transaction1 = pega.u.d.asyncRequest('GET', recentUrl, {
        success: function (oResponse) {
            var result = oResponse.responseText;
            var resultarr = result.split(";");
            launchResearchItem(resultarr[0], resultarr[1], CPMDataSource, parameter);
        },
        failure: function () { },
        scope: this
    },
        "");

}



/* The below function is custom implementation of CS for PRPC Skip to content feature */
/* SE-23159 */
function cpm_skipToContent(contentType) {
    var activeFrame = $("#moduleGroupDiv").children(".iframe-wrapper").filter(function () {
        return ($(this).css('display') == 'block');
    }).find('iframe')[0];
    if (!activeFrame) {
        return;
    }
    var activeWindow = activeFrame.contentWindow;

    var selectorForTarget = "[data-skip-target='" + contentType + "']" //this should ideally get the inner Dynamic Layout  
    //If you need to go for custom areas then use a css class at which point modify the pattern
    //var selectorForTarget = ".CPMTarget_" + contentType; //contentType = main, navigation, search, etc
    if (activeWindow) {
        var contentDiv = activeWindow.$(selectorForTarget)[0];
    }


    if (contentDiv) {
        contentDiv.setAttribute('tabindex', '-1');
        try {
            //contentDiv.focus();
            var focusableElements = $($(contentDiv).find('a[href], button, input[type!="hidden"], select, textarea, img[tabindex]').filter(":visible").toArray());
            var firstElement = focusableElements.eq(0);
            firstElement = (firstElement.length > 0) ? firstElement[0] : null;
            var focusElement = firstElement;
            if (focusElement != null) {
                var keyupAttr = focusElement.getAttribute("data-keyup");

                if (keyupAttr) {
                    focusElement.removeAttribute("data-keyup");
                }
                setTimeout(function () { focusElement.focus(); }, 500);
                if (keyupAttr) {
                    setTimeout(function () { focusElement.setAttribute("data-keyup", keyupAttr); }, 500);
                }
            }
            else { pega.u.d.getNextFocusableElement(null, contentDiv).focus(); }

            return;
        } catch (e) {
            //console.log(e);
        }
    }
}

/* This function is used to call Skip To Content in an Interaction tab.*/
function pega_cpm_IP_skipToMainContent(interactionThreadName) {

    /*  console.log("incoming thread name is "+interactionThreadName);*/

    /* Find iframes */
    var iframes = $(window.parent.document).find("iframe");
    /*  for(i=0;i<iframes.length;i++) 
    {
      console.log("for frame with thread "+$(iframes[i].parentNode).attr("pegathread")+", function type is "+typeof iframes[i].contentWindow.cpm_skipToMainContent);
    } */

    for (i = 0; i < iframes.length; i++) {
        if ($(iframes[i].parentNode).attr("pegathread") == interactionThreadName) {
            /*  console.log("Calling skiptomaincontent in iframe "+$(iframes[i].parentNode).attr("pegathread"));*/
            iframes[i].contentWindow.cpm_skipToMainContent();
            break;
        }
    }
    delete iframes; /* Cleaning object */
}

/* End PRPC Skip to content feature */

/* switch portal utilities */
function switchPortal(strNewPortal, ownerName, ExpressPortal) {
    var strConfirmMsg = "Re-display the Desktop using the '" + trim(strNewPortal) + "' layout?";
    var con = false;

    con = confirm(strConfirmMsg);


    if (con) {
        var bSafeURL = new SafeURL("@baseclass.CPMSwitchPortal");
        pega.u.d.asyncRequest('GET', SafeURL_createFromURL(bSafeURL.toURL()), '');
        var strURL = "";
        /*pass expressportal as some value to force the thread context to standard*/
        if (ExpressPortal === 'true') {
            strURL = new SafeURL("Data-Portal.ShowSelectedPortal");
            strURL.put("pxReqURI", requestHomeURI + "/!STANDARD");
            strURL.put("portal", strNewPortal);
            strURL.put("developer", ownerName);
            pega.u.d.convertToRunActivityAction(strURL);
        } else {
            strURL = new SafeURL("Data-Portal.ShowSelectedPortal");
            strURL.put("pxReqURI", requestURI);
            strURL.put("portal", strNewPortal);
            strURL.put("developer", ownerName);
            pega.u.d.convertToRunActivityAction(strURL);
        }

        var objParent = window.parent;
        while (objParent != objParent.parent) {
            try {
                objParent = objParent.parent;
            } catch (e) { }
        }
        gCurrentPortal = strNewPortal;
        desktopsharedscript_setURL(objParent, strURL.toURL());

    }
}
function desktopsharedscript_setURL(windowObject, strURL) {
    if (windowObject.navigate) {

        windowObject.navigate(strURL);
    } else {

        windowObject.location = strURL;
    }

}
/* switch portal end utilities */

/**************** KM Toggling - START *****************/

function showKM() {
    $("body").addClass("km-expanded");
    $(".int-ui-right-pane-wrapper").removeClass("collapsed").find(":focusable").first().focus();
    $(".int-ui-right-pane-wrapper").attr("data-expanded", "true");
    $(".cs-home-right-pane").find(":focusable").first().focus();
    $(window).trigger('resize');
}

function hideKM(collapseRightPane) {
    var kmPaneCurrentScrollPos = $(".int-ui-right-pane>div.item-2").scrollTop();
    $("body").removeClass("km-expanded");
    if ($("body").hasClass("scroll-chat-to-bottom")) {
        $("body").removeClass("scroll-chat-to-bottom");
        scrollRightPaneToBottom("Chat");
    }
    if (collapseRightPane != null && (collapseRightPane == 'true' || collapseRightPane == true)) {
        /* If the collapseRightPage is true, only collapse if there's no other div under int-ui-right-pane-header. 
           If there's more than 1, that means this is a chat or email interaction and collapsing the pane will hide the content */
        if (HasOnlyKMPane) {
            $(".int-ui-right-pane-wrapper").addClass("collapsed");
            $(".km-floating-button").focus();
        }
    }
    $(window).trigger('resize');
}

/**************** KM Toggling - END ********************/

/* For triggering composite refresh */
function TriggerCompositeRefresh(Thread) {
    /* Find iframes */
    var iframes = $(window.parent.document).find("iframe");
    for (i = 0; i < iframes.length; i++) {
        var parNode = $(iframes[i].parentNode);
        var pegathrd = parNode.attr("pegathread");
        /* Check thread name to find corresponding iframe */
        /* BUG-358499 changed indexof to strict comparision  */
        if ($(iframes[i].parentNode).attr("pegathread") == Thread) {
            var iframeDoc = iframes[i].contentWindow.document;
            var refreshLink = iframeDoc.getElementById("CompositeRefreshTrigger");
            refreshLink.click();
            break;
        }
    }
    delete iframes; /* Cleaning object */
}
/* End triggering composite refresh */


/* End utilities */

/* Hide internal content in KM articles when PegaKM:Internal role is not available*/

/** to remove all elements having class for internal content **/
function removeInternalContent() {
    $(".internalKC").remove();
}

/** displays all elements having class for internal content **/
function showInternalContent() {

    $(".internalKC").show();
}

/*End Hide internal content in KM articles when PegaKM:Internal role is not available*/

/** Function to fetch article from article link within the content**/

function openArticleReference() {

    $('.clickableKC').attr('onClick', 'articleLink(event);');
}

/*Fetch article*/

function articleLink(event) {

    var id = event.target.id;

    var params = "ContentID=" + id;

    handleClientEvent('SERVER', 'CSKMFetchLatestKCPforKC', params, '-1', event);

}

/** End of function to fetch article from article link within the content**/


/* function to simulate click when account is selected from overview tab*/
function switchCompositeFocus() {

    $("[node_name='CPMCompositesContainer'] .layout.count-3:nth-child(1)").trigger("click");
}

/** Launch service cases from troubleshooter articles **/
function launchServiceCase() {
    $('.case-type-link').attr('onClick', 'showServiceCase(event);');
}

function showServiceCase(event) {
    var caseTypeMeta = $('.case-type-link').attr("casetypemeta");
    var caseTypeMetaJS = JSON.parse(caseTypeMeta);
    var strClassName = caseTypeMetaJS.id;
    var harnessVersion = "";
    var strFlowName = "pyStartCase";
    var strFlowParams = "";
    var contentID = "";
    var dynamicContainerID = "";
    var skipConflictCheck = "";

    createTaskFromArticle(strClassName, harnessVersion, strFlowName, strFlowParams, contentID, dynamicContainerID,
        skipConflictCheck);
}
/** EO: Launch service cases from troubleshooter articles **/
//static-content-hash-trigger-YUI

/* Event handler function for entity drop-down controller - START */
function entitydropdowneventhandler(event) {
    var target = $('[data-mdc-id="acprimary"] div.show');
    if (target.length > 0) {
        var container = $(event.target).closest(".int-ui-right-pane-content");
        if (!container || container.length === 0) {
            container = $(event.target).closest(".ai-found-entities");
        }
        pega.cs.formfiller.invokeformfiller({ "scope": target, "event": event, "container": container, mapCallback: trainEmailNLP });
        event.preventDefault();
        event.stopPropagation();
    }
}

function entitydropdowneventhandlerForSelection(event) {
    var selection = window.getSelection();
    if (selection && selection.focusNode && selection.focusNode.data && selection.focusNode.data.trim().length > 0) {
        var textSelected = selection.focusNode.data.substring(selection.anchorOffset, selection.focusOffset);

        /* getting the class name of parent node */
        var parentEleClassName = selection.focusNode.parentElement.className;
        /* parent class name has "entity" in it continue */
        if (textSelected.length > 0 || (parentEleClassName.includes("entity"))) {
            var target = $('[data-mdc-id="acprimary"] div.show');
            var duplicateCases = $(target).find('.duplicatecasesinfo');
            if (textSelected.length <= 0) {
                textSelected = selection.focusNode.data
            }
            else {
                textSelected = selection.toString();
            }
            if (target.length > 0 && duplicateCases.length < 1) {
                event.preventDefault();
                event.stopPropagation();
                var container = $(event.target).closest(".int-ui-right-pane-content");
                if (!container || container.length === 0) {
                    container = $(event.target).closest(".ai-found-entities");
                }
                pega.cs.formfiller.invokeformfiller({ "scope": target, "event": event, "container": container, textSelected: textSelected, mapCallback: trainEmailNLP });
            }

        }
    }

}

function trainEmailNLP(mapping) {
    pega.api.ui.actions.runDataTransform({
        name: "SetMappedEntities",
        parameters: [
            { name: "SelectedProperty", value: mapping.propertyMappedToField, isProperty: false },
            { name: "SelectedText", value: mapping.selectedText, isProperty: false }
        ],
        event: mapping.event
    });
}

/* Event handler function for entity drop-down controller - END */

/*********************** Smart Email - Floating email composer - START *******************/

pega.namespace("pega.cs.smartemail");
pega.cs.smartemail = (function () {

    function toggleCollapse(event) {
        var smartEmailReplyPane = event.target.closest(".floating-email-composer");
        smartEmailReplyPane.classList.toggle("collapsed");
    }

    function toggleMaximize(event) {
        var smartEmailReplyPane = event.target.closest(".floating-email-composer");
        smartEmailReplyPane.classList.toggle("maximized");
        if (smartEmailReplyPane.classList.contains("maximized")) {
            smartEmailReplyPane.classList.remove("collapsed");
        }
    }

    return {
        toggleCollapse: toggleCollapse,
        toggleMaximize: toggleMaximize
    }
})();

/*********************** Smart Email - Floating email composer - END *********************/

//static-content-hash-trigger-YUI

function closeInteraction() {
    console.log("Event received for closing interaction");
    pega.u.d.doClose();
}
//static-content-hash-trigger-YUI
//BUG-583957
function clearDirtyFlag() {
    pega.ctxmgr.setRootDocumentContext();
    pega.ctx.gDirtyOverride = false;
}

/** Functions for Knowledge component **/
/* Called from Run script action of Pega UI controls */
function publishReloadKMEvent(id, event, data) {
    var articleId
    if (data != "") {
        var strArr = data.split(" ");
        if (strArr.length > 1) {
            articleId = data.split(" ")[1];
        } else {
            articleId = data.split(" ")[0];
        }

    }

    pega.desktop.support.getDesktopWindow().knowledge.publishKMEvent(id, event, articleId);
}

/* Used to remove all events for interaction and service cases launched in that interaction */
function unsubscribeCSPubSubEvents(id) {
    var interactionIdCases = id + "_cases";
    var csPubSubObj = pega.desktop.support.getDesktopWindow().CSPubSub;
    if (null != csPubSubObj.subscribers[interactionIdCases] && null != csPubSubObj.subscribers[interactionIdCases]["CLEANUP CASES"]) {
        var svcPubSubArr = csPubSubObj.subscribers[interactionIdCases]["CLEANUP CASES"].split(",");
        for (var i = 0; i < svcPubSubArr.length; i++) {
            if (null != csPubSubObj.subscribers[svcPubSubArr[i]])
                csPubSubObj.unsubscribe(svcPubSubArr[i], null);
        }
        csPubSubObj.unsubscribe(interactionIdCases, null);
    }
    csPubSubObj.unsubscribe(id, null);
}

//static-content-hash-trigger-GCC
function pegaCSNotificationHandler(event) {
  var payload= event.detail.response.Value;
  /* Show the slide-in message */
  toastr.slideIn(payload, {timeOut: 5000, extendedTimeOut: 1000 });   
}

function onNewEmailNotification(event){
  var payload= event.detail.response.Value;
  var InteractionID = event.detail.response.CurrentInteractionID;
  if(!pega.cs.notificationmanager.isInteractionLoadedInDC(InteractionID)){
    toastr.slideIn(payload, {timeOut: 60000, extendedTimeOut: 15000, escapeHtml: false});   
  }
}

function openAssignmentFromToasterPop(event){
  var target = event.target;
  var assignmentKey = $(target).closest(".layout").find(".assignmentKeyHolder").find('span').text();
  if(assignmentKey != null){
    pega.desktop.openAssignment(assignmentKey);
  }
  $(target).closest(".toast-slidein").find(".toast-close-button").trigger("click");
}
//static-content-hash-trigger-GCC
function displayPopoverWhenSwitchfails(){
  var popover = pega.u.d.getPopOver();
       /* popover.open({ 
          content: { type: 'section', name: 'pzSwitchAppDisplayLoginScreen'}, 
          buttons: { ok: false, cancel: false },
          visual: { displayLoader: false, customShowLoader: null, customHideLoader: null, contentClass: '' }, 
          position: { fieldAttach: 'leftBottom', popOverAttach: 'leftTop'}, 
          extraParams: { refresh: false, bIsDisableClickaway: "false", bIsCenterOverlay: "true" } });*/
  
  popover.open({
        content: {
          type: 'section', 
        name: 'pzSwitchAppDisplayLoginScreen'
        },
        bindings: {
            associatedElement: pega.u.d.insertButton
        },
        buttons: {
            ok: false,
            cancel: false
        },
        callbacks: {
            onContentDisplayed: [pega.u.d.focusOverlay, '', pega.u.d],
            onClose: [pega.u.d.closeOverlay, '', pega.u.d],
            onContentReady: [pega.u.d.handleOverlayContentReady, '', pega.u.d]
        },
        position: {
            fieldAttach: 'leftBottom',
            popOverAttach: 'leftTop',
            size: {
                min: {
                    y: 20
                }
            }
        },
        visual: {
            displayLoader: false,
            contentClass: 'overlayPO'
        },
        extraParams: {
            refresh: true,
            setMaxHeightAndWidth: true,
            bIsDisableClickaway: 'true',
            bIsCenterOverlay: 'true'
        }
    });
}

function switchApplication(accessGroup) {
    /* BUG-236225 moved redirectandrun call to the activity so F5 refresh would work */
    if (accessGroup == null) {
        accessGroup = document.getElementById('<pega:reference name="$this-Definition(pyPropertyName)"/>').value;
    }
    var  safeURL=new SafeURL();
  safeURL.put("pzActivity","pzRunActionWrapper");
  safeURL.put("pyActivity","Code-Security.pyValidateSwitchApplication");
 safeURL.put('AccessGroup',accessGroup);
pega.u.d.asyncRequest("POST",SafeURL_createFromURL(safeURL.toURL()) ,{
success: function (o) {
  var responseVal=o.responseText;
  try { 
      responseVal= JSON.parse(o.responseText);
    } catch(e) {}
    if(responseVal === "Success" || responseVal.status === "Success"){
    var oShowDesktopUrl;
  var oLocationUrl = SafeURL_createFromURL(pega.desktop.showDesktop);
    var topWinTmp;
    if (pega.ui.composer && pega.ui.composer.isComposerPreviewFrame()) {
        topWinTmp = pega.ui.composer.getCurrentComposerWindow();
        oShowDesktopUrl = topWinTmp.SafeURL_createFromURL(pega.desktop.pzProcessApplicationSwitch);
    } else {
        oShowDesktopUrl = SafeURL_createFromURL(pega.desktop.pzProcessApplicationSwitch);
    }
    oShowDesktopUrl.put("AccessGroupName", accessGroup);
    oShowDesktopUrl.put("Location",oLocationUrl.toQueryString());
      var portalWindow = pega.desktop.support.getDesktopWindow();
    /*BUG-487945 portalWindow.logout setting to true for not to trigger unload request(pyDeleterDocumentPg) which is creating the thread.
     On application switch, we are removing/cleanup all threads created on the current application, before switihing to new application. Unload requests(pyDeleterDocumentPg) are recreating thread and causing to skin issues.
    */
    if(portalWindow){
       portalWindow.logout = true;
    }
    if (pega.ui.composer && pega.ui.composer.isComposerPreviewFrame()) {
        topWinTmp = pega.ui.composer.getCurrentComposerWindow();
        topWinTmp.location.href = responseVal.url ? responseVal.url : oShowDesktopUrl.toURL();
    } else {
        window.location.href = responseVal.url ? responseVal.url : oShowDesktopUrl.toURL();
    }
      }else{
   displayPopoverWhenSwitchfails();
  }
  },

failure: function (o) {

 displayPopoverWhenSwitchfails();

 
}
},undefined);
}



function changePortal(strNewPortal, currentPortal, strNewPortalLabel) {
    if (strNewPortal !== currentPortal) {
        if (strNewPortalLabel == null || typeof strNewPortalLabel === undefined || strNewPortalLabel.length <= 0) {
            strNewPortalLabel = strNewPortal;
        }
        var strportalname = pega.u.d.fieldValuesList.get(strNewPortalLabel);
        if (typeof strportalname === "undefined") {
            strportalname = strNewPortalLabel;
        }
        var strConfirmMsg = pega.u.d.fieldValuesList.get("SwitchPortal") + " " + strportalname + " " + pega.u.d.fieldValuesList
            .get("PortalText");
        if (confirm(strConfirmMsg)) {
            var oSafeURLTmp = SafeURL_createFromURL(pega.desktop.pzProcessPortalSwitch);
            oSafeURLTmp.put("portal", strNewPortal);
            oSafeURLTmp.put("Name", currentPortal);
            oSafeURLTmp.put("developer", false);
            if (pega.ui.composer && pega.ui.composer.isComposerPreviewFrame()) {
                oSafeURLTmp.put("isPreviewFrame", true)
            }
          var portalWindow = pega.desktop.support.getDesktopWindow();
          /*BUG-487944 portalWindow.logout setting to true for not to trigger unload request(pyDeleterDocumentPg) which is creating the thread.
     On portal switch, we are removing/cleanup all threads created on the current application, before switihing to new portal. Unload requests(pyDeleterDocumentPg) are recreating thread and csuing to skin issues.
    */
          if(portalWindow){
            portalWindow.logout = true;
          }
            window.location.href = oSafeURLTmp.toURL();
        }
    }
}
/**
 * @public Displays a given harness in the current window 
 * @param $String$ className - "Applies to" class of the harness to be shown
 * @param $String$ harnessName - pyStreamName of the harness to be shown
 * @param $String$ harnessLabel - pyLabel of the harness to be shown
 * @param $Event$ event - The event to be passed when harness is launched
 */
function showPortalPage(className, harnessName, harnessLabel, event) {
    if (!event) {
        event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
    }
    var params = {
        harness: harnessName,
        harnessClass: className,
        displayMode: pega.api.ui.constants.NEW_DOCUMENT,
        tabName: {
            value: harnessLabel,
            isProperty: false
        },
        windowName: harnessLabel,
        readOnly: false,
        doSubmit: false,
        event: event
    };
    pega.api.ui.actions.launchHarness(params);
}

function getNextWorkItem(strUserId) {
    var args = arguments[0];
    var oSafeURLTmp;
    if (typeof args === "object" && args.name === "safeURL") {
        oSafeURLTmp = SafeURL_clone(args);
        strUserId = oSafeURLTmp.get("strUserId");
    }
    if (!oSafeURLTmp) {
        oSafeURLTmp = new SafeURL();
    }
    oSafeURLTmp.put("param", strUserId);
    if (!pega.desktop.support.openSpace("Work", oSafeURLTmp, "getnextwork")) {
        strUserId = oSafeURLTmp.toQueryString();
        var strURL = pega.desktop.support.constructUrl(strUserId, "getnextwork");
        pega.desktop.openUrlInWindow(strURL, "pyWorkPage", WorkFormSize + PopupWindowFeatures);
    }
}

function pzCaseMgrLogOff(event) {
    pega.control && pega.control.menu && pega.control.menu.clearState();
    setUserStart('replace');
    pega.u.d.replace('pyActivity=LogOff&pzPrimaryPageName=pyDisplayHarness', event);
}
if (!(pega && pega.desktop && pega.desktop.wks)) {
    pega.namespace("pega.desktop");
    pega.desktop.wks = (function() {
        /////////////////////////////////////////////////////////////////////////////////
        //                          PRIVATE GLOBALS                                    //
        /////////////////////////////////////////////////////////////////////////////////
        var _ind = null;
      
        /////////////////////////////////////////////////////////////////////////////////
        //                              PRIVATE FUNCTIONS                              //
        /////////////////////////////////////////////////////////////////////////////////
        var _deleteBackButton = function() {
            var fixedElem = top.document.getElementsByClassName("wks-back");
            if (fixedElem.length > 0) {
                fixedElem[0].parentNode.removeChild(fixedElem[0]);
            }
        }
        var _showBackButton = function() {
            var fixedElem = top.document.getElementsByClassName("wks-back");
            if (fixedElem.length > 0) {
                fixedElem[0].classList.add("visible");
            }
        }
        var _createNewRule = function(ruletype, rulename, classname, isObject, objRuleInfo) {
            var extraInfo = ""
            if (!isObject) {
                if (ruletype.toUpperCase() === "RULE-OBJ-WHEN") {
                    extraInfo += "&KeypyBlockName=" + rulename;
                } else if (ruletype.toUpperCase() === "RULE-OBJ-VALIDATE") {
                    extraInfo += "&KeypyActivityName=" + rulename;
                } else if (ruletype.toUpperCase() === "RULE-OBJ-MODEL") {
                    extraInfo += "&KeypyModelName=" + rulename;
                } else {
                    extraInfo += "&KeypyPurpose=" + rulename;
                }
                pega.desktop.createNewWork("Work-ProjectManagement-New", "", "NewModalFlow", "&newObjClass=" +
                    ruletype + "&newClassName=" + classname + "&KeypyClassName=" + classname +
                    "&newLabel=" + rulename + extraInfo);
            } else {
                for (var key in objRuleInfo) {
                    if (key !== "pxObjClass") {
                        extraInfo += "&Key" + key + "=" + objRuleInfo[key];
                    }
                }
                pega.desktop.createNewWork("Work-ProjectManagement-New", "", "NewModalFlow", "&newObjClass=" +
                    ruletype + "&newClassName=" + classname + "&KeypyClassName=" + classname + extraInfo
                );
            }
        };
        var _switchWindowInner = function(fromElIframe, portalEl, portalName) {
            if (_ind != null) {
                _ind.hide();
                _ind = null;
            }
            if (fromElIframe.length > 0) {
                fromElIframe.css('display', 'none');
            } else {
                $('body').addClass('hide-main-doc');
            }
            portalEl.css('display', 'block');
            setTimeout(function() {
                if (portalEl.length > 0 && portalEl[0].contentWindow.document.body && portalEl[0].contentWindow
                    .document.body.classList) {
                    portalEl[0].contentWindow.document.body.classList.remove("wks-switch");
                    setTimeout(function() {
                        var ev;
                        if (typeof(Event) === 'function') {
                            ev = new Event('');
                        } else {
                            ev = document.createEvent('Event');
                            ev.initEvent('', true, true);
                        }
                        Object.defineProperty(ev, 'target', {
                            writable: false,
                            value: portalEl[0].contentWindow
                        });
                        portalEl[0].contentWindow.pega.u.d.getTrackerChanges(ev);
                        portalEl[0].contentWindow.document.body.classList.remove(
                            "wks-preswitch");
                        if (portalName === "Developer") {
                            portalEl[0].contentWindow.pega.ui.screenLayout.resizeScreenLayout();
                        }
                    }, 800);
                }
            }, 10);
            if(typeof this._wksTitle === "undefined") {
              this._wksTitle = {};
            }
            if(typeof this._wksTitle[portalEl[0].contentWindow.name] === "undefined" ) {
              this._wksTitle[portalEl[0].contentWindow.name] = portalEl[0].contentWindow.document.title
            } 
            document.title = this._wksTitle[portalEl[0].contentWindow.name];
            //BUG-559791: switching the focus to the current window
            portalEl[0].contentWindow.focus();
        };
        var _dismissBackButton = function(portalName) {
            _deleteBackButton();
            if (typeof portalName !== "undefined") {
                top.pega.desktop.wks.injectIframe("", portalName);
            }
        };
        var _generateBackButton = function(portalName, actionObj) {
            var fixedElem = top.document.getElementsByClassName("wks-back");
            if (fixedElem.length > 0) {
                fixedElem[0].parentNode.removeChild(fixedElem[0]);
            }
            var mainElem = top.document.createElement("DIV");
            mainElem.classList.add("wks-back");
            mainElem.setAttribute("data-fromportal", pega.desktop.portalName);
            mainElem.setAttribute("data-toportal", portalName);
            top.document.body.insertBefore(mainElem, top.document.getElementsByClassName("screen-layout")[0]
                .nextSibling);
            $(mainElem).draggable({
                containment: "parent",
                scroll: false
            });
            $(mainElem).click(function(e) {
                var el = e.target;
                if (el.tagName === 'I') {
                    el = el.parentNode;
                }
                if (el.className === 'back' || el.className === 'back-full' || el.tagName === "SPAN" ||
                    el.tagName === "CANVAS") {
                    _dismissBackButton(pega.desktop.portalName);
                } else if (el.className === 'minimize') {
                    $(this).removeClass("expanded").addClass("minimized");
                } else if (el.className === 'expand') {
                    $(this).addClass("expanded").removeClass("minimized");
                }
            });
            if (typeof html2canvas == "function") {
                mainElem.innerHTML = "<div class='info'><span>" + pega.u.d.fieldValuesList.get("Home") +
                    "</span><span>" + document.title + "</span></div>" +
                    "<div class='actions'><a class='back' title='" + gStrBack +
                    "'><i class='pz-pi pi-arrow-bend-left'></i>" + gStrBack + "</a>" +
                    "<a class='back-full' title='" + gStrBack + "'><i class='pz-pi pi-arrow-bend-left'></i>" +
                    pega.u.d.fieldValuesList.get("BackTo") + " " + document.title + "</a>" + "<a title='" +
                    pega.u.d.fieldValuesList.get("Minimize") + "' class='minimize'>" + pega.u.d.fieldValuesList
                    .get("Minimize") + "</a><a title='" + pega.u.d.fieldValuesList.get("pzExpandPreview") +
                    "' class='expand'><i class='pi pi-arrows-ne-sw-join'></i></a></div>";
                try {
                    html2canvas(document.body, {
                        logging: "false"
                    }).then(function(canvas) {
                        mainElem.insertBefore(canvas, mainElem.firstElementChild);
                        if (!mainElem.classList.contains("minimized")) {
                            mainElem.classList.add("expanded");
                        }
                        pega.desktop.wks.switchWorkspace(portalName, actionObj);
                    });
                } catch (e) {
                    pega.desktop.wks.switchWorkspace(portalName, actionObj);
                }
            } else {
                mainElem.innerHTML = "<div class='actions'><a class='back-full' title='" + gStrBack +
                    "'><i class='pz-pi pi-arrow-bend-left'></i>" + pega.u.d.fieldValuesList.get("BackTo") +
                    " " + document.title + "</a></div>";
                pega.desktop.wks.switchWorkspace(portalName, actionObj);
            }
        };
        /////////////////////////////////////////////////////////////////////////////////
        //                                 PUBLIC API                                  //
        /////////////////////////////////////////////////////////////////////////////////
        return {
            /**
             * injectIframe PRIVATE METHOD called on load of the iframe
             * Inject iframe with a workspace
             * fromportalName - name of the from portal
             * portalName - portal Name
             * url - url
             * actionObj - action to execute after switching the workspace
             */
            injectIframe: function(fromportalName, portalName, url, actionObj) {
                var fromElIframe;
                if (!this._title) {
                    this._title = document.title;
                }
                if (!actionObj && this._actionObj && this._actionObj != null) {
                    actionObj = this._actionObj;
                    this._actionObj = null;
                }
                if (fromportalName === "") {
                    /* if the fromportalName is not set - then used the last one that was switched to */
                    fromportalName = this._portalName;
                }
                this._portalName = portalName;
                /* If the back button is visible and the portalName is the same that back is pointing to, then delete the back button */
                var fixedElem = top.document.getElementsByClassName("wks-back");
                if (fixedElem.length > 0) {
                    var fromportal = fixedElem[0].getAttribute("data-fromportal");
                    if (fromportal != null && fromportal === portalName) {
                        _deleteBackButton();
                    }
                }
                var portalEl = $('iframe#' + portalName);
                if (typeof portalName === 'undefined' || portalName === "" || pega.desktop.portalName ===
                    portalName) {
                    // top level for the destination
                    fromElIframe = $('iframe#' + fromportalName);
                    if (fromElIframe.length > 0) {
                        fromElIframe[0].contentWindow.document.body.classList.add("wks-preswitch");
                        fromElIframe[0].contentWindow.document.body.classList.add("wks-switch");
                    }
                    document.body.classList.add("wks-preswitch");
                    document.body.classList.add("wks-switch");
                    document.title = this._title;
                    setTimeout(function() {
                        fromElIframe.css('display', 'none');
                        $('body').removeClass('hide-main-doc');
                        setTimeout(function() {
                            document.body.classList.remove("wks-switch");
                            setTimeout(function() {
                                var ev;
                                if (typeof(Event) === 'function') {
                                    ev = new Event('');
                                } else {
                                    ev = document.createEvent('Event');
                                    ev.initEvent('', true, true);
                                }
                                Object.defineProperty(ev, 'target', {
                                    writable: false,
                                    value: window
                                });
                                pega.u.d.getTrackerChanges(ev);
                                document.body.classList.remove("wks-preswitch");
                                if (portalName === "Developer") {
                                    pega.ui.screenLayout.resizeScreenLayout();
                                }
                            }, 800);
                        }, 10);
                    }, 800);
                } else if (portalEl.length > 0) {
                    // portal already loaded - just switch to it
                    fromElIframe = $('iframe#' + fromportalName);
                    portalEl[0].contentWindow.document.body.classList.add("wks-preswitch");
                    portalEl[0].contentWindow.document.body.classList.add("wks-switch");
                    if (fromElIframe.length > 0) {
                        fromElIframe[0].contentWindow.document.body.classList.add("wks-preswitch");
                        fromElIframe[0].contentWindow.document.body.classList.add("wks-switch");
                    } else {
                        document.body.classList.add("wks-preswitch");
                        document.body.classList.add("wks-switch");
                    }
                    setTimeout(function() {
                        _switchWindowInner(fromElIframe, portalEl, portalName);
                    }, 800);
                } else if (url) {
                    if (fromportalName && pega.desktop.portalName === fromportalName) {
                        document.body.classList.add("wks-preswitch");
                        document.body.classList.add("wks-switch");
                        setTimeout(function() {
                            _ind = pega.u.d.setBusyIndicator(document.body, true);
                        }, 200);
                    } else {
                        fromElIframe = $('iframe#' + fromportalName);
                        fromElIframe[0].contentWindow.document.body.classList.add("wks-preswitch");
                        fromElIframe[0].contentWindow.document.body.classList.add("wks-switch");
                        setTimeout(function() {
                            _ind = fromElIframe[0].contentWindow.pega.u.d.setBusyIndicator(
                                fromElIframe[0].contentWindow.document.body, true);
                        }, 200);
                    }
                    this._actionObj = actionObj;
                    $('<iframe src="' + url + '" title="' + portalName + '" id="' +
                        portalName + '"  name="' + portalName +
                        '" onload="try { if(pega && pega.desktop && pega.desktop.wks) { pega.desktop.wks.injectIframe(\'' +
                        fromportalName + '\',\'' + portalName + '\');} }catch(e) {}"/>').css({
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        display: 'none',
                        background: '#FFF',
                        border: 'none'
                    }).appendTo('body');
                    return;
                }
                if (typeof actionObj !== "undefined" && actionObj !== "" && actionObj !== "undefined") {
                    var actionArray = actionObj;
                    if (actionArray[0] === 'openharness') {
                        if (portalEl.length > 0) {
                            portalEl[0].contentWindow.pega.desktop.wks.openHarness(actionArray[1],
                                actionArray[2], actionArray[3], actionArray[4], actionArray[5]);
                        } else {
                            parent.pega.desktop.wks.openHarness(actionArray[1], actionArray[2], actionArray[
                                3], actionArray[4], actionArray[5]);
                        }
                    } else if (actionArray[0] === 'openrule') {
                        if (portalEl.length > 0) {
                            portalEl[0].contentWindow.pega.desktop.wks.openRule(actionArray[1], actionArray[
                                2], actionArray[3], actionArray[4], actionArray[5], actionArray[6]);
                        } else {
                            parent.pega.desktop.wks.openRule(actionArray[1], actionArray[2], actionArray[3],
                                actionArray[4], actionArray[5], actionArray[6]);
                        }
                    } else if (actionArray[0] === 'openworkbyhandle') {
                        if (portalEl.length > 0) {
                            portalEl[0].contentWindow.pega.desktop.wks.openWorkByHandle(actionArray[1],
                                actionArray[2], actionArray[3]);
                        } else {
                            parent.pega.desktop.wks.openWorkByHandle(actionArray[1], actionArray[2],
                                actionArray[3]);
                        }
                    }
                }
            },
            /**
             * switchWorkspace - PRIVATE METHOD called by the top level menu switch
             * switch the workspace
             * portalName - portal Name.
             * actionObj - action to execute after switching the workspace
             */
            switchWorkspace: function(portalName, actionObj) {
                var fixedElem = document.getElementsByClassName("workspace-menu");
                if (fixedElem.length > 0) {
                    fixedElem[0].classList.remove('visible');
                }
                // Build the base RedirectAndRun url to show the portal
                var redirectAndRunURL = new SafeURL("Embed-PortalLayout.RedirectAndRun");
                redirectAndRunURL.put("ThreadName", "OpenPortal_" + portalName);
                redirectAndRunURL.put("bPurgeTargetThread", true);
                redirectAndRunURL.put("bEncodeLocation", true);
                // Build up the Location param for RedirectAndRun which is really a url for a
                // show selected portal URL, which shows the portal that is specified in portalName param
                var showSelectedPortalURL = new SafeURL("Data-Portal.ShowSelectedPortal");
                showSelectedPortalURL.put("ThreadName", "OpenPortal_" + portalName);
                showSelectedPortalURL.put("portal", portalName);
                showSelectedPortalURL.put("Name", portalName);
                showSelectedPortalURL.put("developer", false);
                // Add the query string of the ShowSelectedPortal url to the location param for redirect and run
                redirectAndRunURL.put("Location", showSelectedPortalURL.toQueryString());
                pega.u.d.convertToRunActivityAction(redirectAndRunURL);
                parent.pega.desktop.wks.injectIframe(pega.desktop.portalName, portalName, redirectAndRunURL.toURL(),
                    actionObj);
            },
            /**
             * openRule - PUBLIC METHOD
             * open a rule in a specific workspace - if the rule is not present, display the new rule harness -  
                 it is possible to display a back button to go back to our current portal. 
                 set rulename and classname to "" and pass the pzInskey to open the rule by InsKey
             * portalName - string - workspace name to transition to.
             * ruletype - string - rule type or pzInsKey (if rulename and classname are empty)
             * rulename - string or object - rule Name. optional if open rule by inskey - 
             * classname - string - class Name. optional - for some rules, set it to ""
             * showBackButton - string - set to "true" to show the backbutton
             * forceCreate - string - set to "true" to force creating a new rule
             */
            openRule: function(portalName, ruletype, rulename, classname, showBackButton, forceCreate) {
                if (typeof portalName === "undefined") return;
                if (typeof ruletype === "undefined") return;
                if (typeof rulename === "undefined") rulename = "";
                if (typeof classname === "undefined") classname = "";
                if (typeof showBackButton === "undefined") showBackButton = "false";
                if (typeof forceCreate == "undefined") forceCreate = "false";
                ruletype = ruletype.trim();
                if (typeof rulename === "string") rulename = rulename.trim();
                classname = classname.trim();
                if (pega.desktop.portalName !== portalName) {
                    var actionObj = ["openrule", portalName, ruletype, rulename, classname, showBackButton,
                        forceCreate];
                    _deleteBackButton();
                    if (showBackButton && showBackButton === "true") {
                        _generateBackButton(portalName, actionObj);
                    } else {
                        pega.desktop.wks.switchWorkspace(portalName, actionObj);
                    }
                } else {
                    var isObject = false;
                    var objRuleInfo;
                    try {
                        /* If rulename is a stringified object- convert back to object */
                        if (typeof rulename == "string" && rulename !== "") {
                            objRuleInfo = JSON.parse(rulename);
                            if (typeof objRuleInfo == "object") {
                                rulename = objRuleInfo;
                            }
                        }
                        if (typeof rulename === "object") {
                            rulename.pxObjClass = ruletype;
                            objRuleInfo = rulename;
                            rulename = JSON.stringify(objRuleInfo);
                            isObject = true;
                        }
                    } catch (e) {}
                    if (forceCreate === "false" && (rulename !== "" || ruletype.indexOf(" ")!==-1)) {
                        var oSafeURLTmp = new SafeURL("@baseclass.pzGetRuleInfo", getReqURI());
                        if (rulename === "") { /* open by InsHandle - we should not open this specific rule */
                            pega.desktop.openRule(ruletype, true);
                            _showBackButton();
                            return;
                        } else {
                            if (isObject) {
                                oSafeURLTmp.put("JSONKeys", rulename);
                            } else {
                                if (classname && classname !== "" && classname !== "undefined") {
                                    oSafeURLTmp.put("InsName", classname.toUpperCase() + "!" + rulename.toUpperCase());
                                } else {
                                    oSafeURLTmp.put("InsName", rulename.toUpperCase());
                                }
                                oSafeURLTmp.put("ClassName", ruletype);
                            }
                        }
                        var strUrl = oSafeURLTmp.toURL();
                        var callback = {
                            success: function(oResponse) {
                                var ruleInfoJsonText = JSON.parse(oResponse.responseText).output;
                                if (ruleInfoJsonText === "" || ruleInfoJsonText.indexOf("Error:") >=
                                    0) {
                                    _createNewRule(ruletype, rulename, classname, isObject,
                                        objRuleInfo);
                                } else {
                                    pega.desktop.openRule(ruleInfoJsonText, true);
                                }
                                _showBackButton();
                            },
                            failure: function(oResponse) {}
                        };
                        pega.util.Connect.asyncRequest('GET', strUrl, callback);
                    } else {
                        _createNewRule(ruletype, rulename, classname, isObject, objRuleInfo);
                        _showBackButton();
                    }
                }
            },
            /**
             * openWorkByHandle - PUBLIC METHOD
             * open an work object in a specific workspace - it is possible to display a back button to go back to our current portal. 
             * portalName - string - workspace name to transition to.
             * pzInskey - string - pzInsKey of the assignment
             * showBackButton - string - set to "true" to show the backbutton
             */
            openWorkByHandle: function(portalName, pzInskey, showBackButton) {
                if (typeof portalName === "undefined") return;
                if (typeof pzInskey === "undefined") return;
                if (typeof showBackButton === "undefined") showBackButton = "false";
                if (pega.desktop.portalName !== portalName) {
                    var actionObj = ["openworkbyhandle", portalName, pzInskey, showBackButton];
                    _deleteBackButton();
                    if (showBackButton && showBackButton === "true") {
                        _generateBackButton(portalName, actionObj);
                    } else {
                        pega.desktop.wks.switchWorkspace(portalName, actionObj);
                    }
                } else {
                    pega.desktop.openWorkByHandle(pzInskey);
                    _showBackButton();
                }
            },
            /**
             * openHarness - PUBLIC METHOD
             * show a harness in a specific workspace - it is possible to display a back button to go back to our current portal
             * portalName - string - workspace name to transition to.
             * rulename - string - name of the harness rule.
             * classname - string - className of the harness to open.
             * harnesslabel - string - label of the harness to show in the browser title.
             * showBackButton - string - set to true to show the backbutton
             */
            openHarness: function(portalName, rulename, classname, harnesslabel, showBackButton) {
                if (typeof portalName === "undefined") return;
                if (typeof rulename === "undefined") return;
                if (typeof classname === "undefined") return;
                if (typeof harnesslabel === "undefined") harnesslabel = "";
                if (typeof showBackButton === "undefined") showBackButton = "false";
                if (pega.desktop.portalName !== portalName) {
                    var actionObj = ["openharness", portalName, rulename, classname, harnesslabel,
                        showBackButton];
                    _deleteBackButton();
                    if (showBackButton && showBackButton === "true") {
                        _generateBackButton(portalName, actionObj);
                    } else {
                        pega.desktop.wks.switchWorkspace(portalName, actionObj);
                    }
                } else {
                    var params = {
                        harness: rulename,
                        harnessClass: classname,
                        displayMode: "3",
                        tabName: {
                            value: harnesslabel,
                            isProperty: false
                        },
                        windowName: harnesslabel,
                        readOnly: false,
                        doSubmit: false
                    };
                    if (pega && pega.api && pega.api.ui && pega.api.ui.actions) {
                        pega.api.ui.actions.launchHarness(params);
                    }
                    _showBackButton();
                }
            }
        }
    })();
}
//static-content-hash-trigger-GCC
if (!pega)
	var pega = {};

if (!pega.chat)
  	pega.chat = {};

pega.chat.agentConnection = function() {

	this._currentQueue = "";
	this._nickname = "";
	this._conflictNickname = "";

};

pega.chat.agentConnection.prototype = {
		
	getAgentID: function () {

		return Strophe.getBareJidFromJid(chatConnection.getJid());
	},


	login : function(url, user, pwd, displayName) {

		chatConnection.login (user, pwd, url, this);
		if (displayName != null) {
			this._nickname = displayName;
			this._conflictNickname = displayName + '2';
		}
     
	},

  isConnected: function () {
    return chatConnection.isConnected();
  },
	logout : function() {

		chatConnection.logout ("logout");
 		
	},


	joinWorkGroup: function(data) {
    var workGroup = data.queue, maxChats = data.maxChats;

		chatConnection.setState("chat");	

               	var fullWorkGroup = workGroup;
		var hasDomain = Strophe.getBareJidFromJid(workGroup).indexOf("@") > 0;
		if (!hasDomain)
			fullWorkGroup = workGroup + "@workgroup." + Strophe.getDomainFromJid(chatConnection.getJid());
 
		chatConnection.agentJoinWorkGroup (fullWorkGroup, maxChats);
																				},


	leaveWorkGroup: function(workGroup) {
		
               	var fullWorkGroup = workGroup;
		var hasDomain = Strophe.getBareJidFromJid(workGroup).indexOf("@") > 0;
		if (!hasDomain)
			fullWorkGroup = workGroup + "@workgroup." + Strophe.getDomainFromJid(chatConnection.getJid());
																					chatConnection.agentLeaveWorkGroup (fullWorkGroup);
 
 	},
 
	setState: function(state) {
		chatConnection.setState (state);
 
 	},

																				queryWorkGroups: function(workGroup) {

	
		var fullWorkGroup = workGroup;
		if (!workGroup)
			fullWorkGroup = "workgroup." + Strophe.getDomainFromJid(chatConnection.getJid());

		chatConnection.queryWorkGroups (fullWorkGroup);
 
 	},
  chatOffered: function(workGroup, offerId, userId) {

		chatConnection.chatOffered(workGroup, offerId, userId);
 
 	},


	acceptOffer: function(workGroup, offerId, userId, typeAhead) {

		chatConnection.acceptOffer (workGroup, offerId, userId, typeAhead);
 
 	},

					
	declineOffer: function(workGroup, offerId, userId) {

		chatConnection.declineOffer (workGroup, offerId, userId);
	
	},

	leaveChat: function (chatId) {
 
		var fullChatId = chatId.replace('chat', '');
		var hasDomain = Strophe.getBareJidFromJid(chatId).indexOf("@") > 0;
    var agentJid = chatConnection.getJid();
    if (!hasDomain && !agentJid) {
      return;
    }
  
		if (!hasDomain) {
			fullChatId = fullChatId + "@conference." + Strophe.getDomainFromJid(chatConnection.getJid());
    }
		chatConnection.leaveChat (fullChatId);

 	},

	sendMessage: function (chatId, msg, category) {
               	
		var fullChatId = chatId.replace('chat', '');
		var hasDomain = Strophe.getBareJidFromJid(chatId).indexOf("@") > 0;
		if (!hasDomain)
			fullChatId = fullChatId + "@conference." + Strophe.getDomainFromJid(chatConnection.getJid());
		chatConnection.sendMessage (fullChatId, msg, "groupchat", category);
 
 	},

  	blindTransferToQueue: function (chatId, msg, queueInfo, reason, announcement, priority, metadata) {
		var fullChatId = chatId.replace('chat', '');
		var hasDomain = Strophe.getBareJidFromJid(chatId).indexOf("@") > 0;
		if (!hasDomain)
			fullChatId = fullChatId + "@conference." + Strophe.getDomainFromJid(chatConnection.getJid());
      	var attributes = {
          message:msg,
          chatType:"groupchat",
          queueInfo:queueInfo,
          reason:reason,
          announcement:announcement,
          priority:priority,
          metadata:metadata
        };
		chatConnection.transferChat(fullChatId, attributes);
 
 	},

  
 	sendComposing: function (chatId) {
               	
		var fullChatId = chatId.replace('chat', '');
		var hasDomain = Strophe.getBareJidFromJid(chatId).indexOf("@") > 0;
		if (!hasDomain)
			fullChatId = fullChatId + "@conference." + Strophe.getDomainFromJid(chatConnection.getJid());
		chatConnection.sendComposing (fullChatId, "groupchat");
 
 	},

	joinChat: function (chatId, nickname, affiliation, role, options) {
    var chatConnectionTimer = null;
    var self = this;
    if (chatConnection.getJid()) {
      chatConnectionTimer && clearTimeout(chatConnectionTimer);
      chatConnectionTimer = null;
      if (nickname == null || nickname == "")
			if (sessionStorage[chatId])
				nickname = sessionStorage[chatId];
			
		  var lclChatId = chatId.replace('chat', '');
		  var fullChatId = lclChatId;
		  var hasDomain = Strophe.getBareJidFromJid(lclChatId).indexOf("@") > 0;
		  if (!hasDomain) {
			fullChatId = lclChatId + "@conference." + Strophe.getDomainFromJid(chatConnection.getJid());
			fullChatId = fullChatId + "/";
			if (nickname != null && nickname != "")
				fullChatId = fullChatId + nickname;
			else
				fullChatId = fullChatId + Strophe.getNodeFromJid(chatConnection.getJid());
		  }
		  else
			 lclChatId = Strophe.getNodeFromJid(fullChatId);

		  sessionStorage[chatId] =  Strophe.getResourceFromJid(fullChatId);
		  chatConnection.joinChat (lclChatId, fullChatId, affiliation, role, options);
    } else {
      chatConnectionTimer = setTimeout(function() {
        self.joinChat(chatId, nickname, affiliation, role, options)
      },500)
    }
		

 	},

  
  	cobrowseRequest: function (chatId, msg) {
      
		var fullChatId = chatId.replace('chat', '');
		var hasDomain = Strophe.getBareJidFromJid(chatId).indexOf("@") > 0;
		if (!hasDomain)
			fullChatId = fullChatId + "@conference." + Strophe.getDomainFromJid(chatConnection.getJid());
		chatConnection.cobrowseRequest (fullChatId, msg, "groupchat");
    },
  

      
   	pagePushRequest: function (chatId, msg, pageUrl, isOpenNewTab,pageName) {
      
		var fullChatId = chatId.replace('chat', '');
		var hasDomain = Strophe.getBareJidFromJid(chatId).indexOf("@") > 0;
		if (!hasDomain)
			fullChatId = fullChatId + "@conference." + Strophe.getDomainFromJid(chatConnection.getJid());
		chatConnection.pagePushRequest (fullChatId, msg, "groupchat", pageUrl, isOpenNewTab,pageName);
    },
      
    

    /*
    @protected - Handles events generated by chatConnection object.
    @param  string sData  – The stringified event object.
    @return null 
    */
    handleChatConnectionEvents: function(sData) {

        // Dispatch function for chat events received on our chat connection 
		
        try {												
            var oEvent = JSON.parse(sData);
			
            if (oEvent.connection)
                this.handleConnectionEvent (oEvent);
            else if (oEvent.presence)
                this.handlePresenceEvent (oEvent);
	          else if (oEvent.iq)
                this.handleIqEvent (oEvent);
	          else if (oEvent.message)
                this.handleMessageEvent (oEvent);
            else if (oEvent.messagesResult)
                this.handleMessagesEvent (oEvent);
        }
        catch (e) {
        }                 
    },
  
    queryMessages: function(chatId) {
		  var fullChatId = chatId.replace('chat', '');
		  var hasDomain = Strophe.getBareJidFromJid(chatId).indexOf("@") > 0;
		  if (!hasDomain)
			  fullChatId = fullChatId + "@conference." + Strophe.getDomainFromJid(chatConnection.getJid());
      chatConnection.queryMessages(fullChatId);
    },

    /*
    @protected - Handles connection events for the chat connection.
    @param  object oEvent – The event object.
    @return null
    */
    handleConnectionEvent: function (oEvent) {

        switch (oEvent.connection.status) {
            case "CONNECTED":
		this.handleLogin (oEvent);
		break;
            case "DISCONNECTED":
		this.handleLogout (oEvent);
		break;
            case "CONNECTING":
            case "DISCONNECTING":
            case "AUTHENTICATING":
		break;
            case "CONNFAILED":
		this.sendError ("Agent", "Login", "CONNFAILED", "Connection Failed");
 		break;
            case "AUTHFAILED":
 		this.sendError ("Agent", "Login", "AUTHFAILED", "Authentication Failed");
 		break;
            case "ERROR":
		this.sendError ("Agent", "Login", "ERROR", "Unspecific Error");
 		break;
            case "ATTACHED":
            default:
                break;
         }

    },

    sendError: function (type, operation, code, msg) {

	var PegaChatEvent = {};
	PegaChatEvent.pyEventName = "Error";
	PegaChatEvent.pyMedia = "Chat";
        PegaChatEvent.pyOperation = operation;
	PegaChatEvent.pyErrorCode = code;
	PegaChatEvent.pyErrorMessage = msg;

	this.publishChatEvent ("Chat" + type + "StateEvent", PegaChatEvent);

    },
    handleLogin: function (oEvent) {

	var PegaChatEvent = new Object();

	PegaChatEvent.pyEventName = "Login";
	PegaChatEvent.pyMedia = "Chat";
	PegaChatEvent.pyAgentID = Strophe.getBareJidFromJid(chatConnection.jid);
	this.publishChatEvent ("ChatAgentStateEvent", PegaChatEvent);
	    },


    handleLogout: function (oEvent) {

	var PegaChatEvent = new Object();

	PegaChatEvent.pyEventName = "Logout";
	PegaChatEvent.pyMedia = "Chat";
	PegaChatEvent.pyAgentID = Strophe.getBareJidFromJid(chatConnection.jid);
	this.publishChatEvent ("ChatAgentStateEvent", PegaChatEvent);
	this.publishPresence("");
    },
	

    handleQueueJoin: function (oEvent) {

/*
	
	var PegaChatEvent = new Object();

	PegaChatEvent.pyEventName = "Ready";
	PegaChatEvent.pyMedia = "Chat";
	PegaChatEvent.pyAgentID = Strophe.getBareJidFromJid(oEvent.presence["@attributes"].to);
	PegaChatEvent.pyAgentQueue = Strophe.getBareJidFromJid(oEvent.presence["@attributes"].from);
	this.publishChatEvent ("ChatAgentStateEvent", PegaChatEvent);
*/
	this._currentQueue = Strophe.getBareJidFromJid(oEvent.presence["@attributes"].from);
    this.publishPresence("Available");
    },
   
    isNotReadyStatus: function (status) {
      
 	
	switch (status) {
	    case "online":
	    case "chat": 
		return false;
		break;

	    default:
		return true
	}
     
    },

    handlePresenceChange: function (oEvent) {

	

	if (oEvent.presence["@attributes"].from != oEvent.presence["@attributes"].to)
		return;

	var PegaChatEvent = new Object();
		

	if (this.isNotReadyStatus(oEvent.presence.show["#text"])){
		PegaChatEvent.pyEventName = "NotReady";
      this.publishPresence("Unavailable");
    }
	else	{
	PegaChatEvent.pyEventName = "Ready";
     this.publishPresence("Available");
    }
	PegaChatEvent.pyMedia = "Chat";
	PegaChatEvent.pyAgentID = Strophe.getBareJidFromJid(oEvent.presence["@attributes"].to);
	PegaChatEvent.pyAgentQueue = this._currentQueue;
	this.publishChatEvent ("ChatAgentStateEvent", PegaChatEvent);
 	
    },


    handlePresenceError: function (oEvent) {

	if (oEvent.presence.error)
		if (oEvent.presence.error.conflict)
			this.joinChat("chat" + Strophe.getNodeFromJid(oEvent.presence["@attributes"].from), this._conflictNickname);
						

    },


  	handleOffer : function (oEvent) {

		var PegaChatEvent = {};
		PegaChatEvent.pyEventName = "Alerting";
		PegaChatEvent.pyMedia = "Chat";
		PegaChatEvent.pyPurpose = "AlertingChat";
		//	PegaChatEvent.pyAgentID = oEvent.iq["@attributes"].to;
		PegaChatEvent.pyAgentID = this.getAgentID();
		PegaChatEvent.pyAgentQueue = oEvent.iq["@attributes"].from;
		PegaChatEvent.pyOtherPartyName = Strophe.getNodeFromJid(oEvent.iq.offer["@attributes"].jid); ;
		PegaChatEvent.pyOtherPartyID = oEvent.iq.offer["@attributes"].jid;
		PegaChatEvent.pyCallId = 'chat' + oEvent.iq.offer.session["@attributes"].id;
		PegaChatEvent.pyOfferID = oEvent.iq["@attributes"].id;
		PegaChatEvent.offerTimeout = oEvent.iq.offer.timeout["#text"];

		PegaChatEvent.pyUserData = {};
		for (index = 0; index < oEvent.iq.offer.metadata.value.length; index++) {
			PegaChatEvent.pyUserData[oEvent.iq.offer.metadata.value[index]["@attributes"].name] = oEvent.iq.offer.metadata.value[index]["#text"];
			if (oEvent.iq.offer.metadata.value[index]["@attributes"].name.toLowerCase() == "username")
				PegaChatEvent.pyOtherPartyName = oEvent.iq.offer.metadata.value[index]["#text"];
		}

		try {
			if (oEvent.iq.offer.transfer) {
				PegaChatEvent.TransferData = {};
				PegaChatEvent.TransferData.pyUserData = {};
				PegaChatEvent.TransferData.type = oEvent.iq.offer.transfer["@attributes"].type;
				for (idx = 0; idx < oEvent.iq.offer.transfer.metadata.value.length; idx++) {
					PegaChatEvent.TransferData.pyUserData[oEvent.iq.offer.transfer.metadata.value[idx]["@attributes"].name] = oEvent.iq.offer.transfer.metadata.value[idx]["#text"];
				}
				PegaChatEvent.TransferData.from = oEvent.iq.offer.transfer.from_employee_id["#text"];
			}
		} catch (e) {}

		this.publishChatEvent("ChatCallStateEvent", PegaChatEvent);

	},

    handleOfferRevoke: function (oEvent) {

        var PegaChatEvent = {};
	      PegaChatEvent.pyEventName = "Alerting";
	      PegaChatEvent.pyCallId = 'chat' + oEvent.iq["@attributes"].id;
	      this.publishChatEvent ("ChatCallStateEvent", PegaChatEvent);
    },

    isFromMe: function (jid) {
      var me = false;
      if (pega.cs.commonutils.readCookie("chat" + Strophe.getNodeFromJid(jid))) 
        if (pega.cs.commonutils.readCookie("chat" + Strophe.getNodeFromJid(jid))  == Strophe.getResourceFromJid(jid))
          me = true;
    	return me;
    },
    
     transferredFromMe: function (chatId,calledfrom) {
   try  
      {
    var transferChats = pega.cs.commonutils.readCookie('transferChats');		
    transferChats = transferChats ? JSON.parse(transferChats) : {};
      if(transferChats[chatId]!= undefined){
        /*delete transferchats from cookies if it is queue transfer */
           if(transferChats[chatId]=="queue"){
              if(calledfrom == "handleconferencejoin")
             oPegaChatEventHandler.deleteTransferChatIdFromMap(chatId);
           }
           /*oPegaChatEventHandler.unRegisterChatEventHandler('chat'+chatId);*/
           this.leaveChat(chatId);
      return true;
     } else {
        return false;}
      }
      catch(err)
        {}
    },

    handleConferenceJoin: function (oEvent) {

	  var PegaChatEvent = {};
    if (this.isFromMe(oEvent.presence["@attributes"].from)) {
    if(this.transferredFromMe(Strophe.getNodeFromJid(oEvent.presence["@attributes"].from),"handleconferencejoin")) return;
		PegaChatEvent.pyEventName = "Established";
		PegaChatEvent.pyAgentID = Strophe.getBareJidFromJid(chatConnection.getJid());
		PegaChatEvent.pyAgentName = Strophe.getNodeFromJid(chatConnection.getJid());
		PegaChatEvent.pyOtherPartyName = "";

    
	}
	else {
		PegaChatEvent.pyOtherPartyName = Strophe.getResourceFromJid(oEvent.presence["@attributes"].from);
		PegaChatEvent.pyOtherPartyID = oEvent.presence["@attributes"].from;
    PegaChatEvent.pyCreatedAt = oEvent.presence["@attributes"].created_at;
		PegaChatEvent.pyEventName = "Connected";
		PegaChatEvent.pyAgentID = Strophe.getBareJidFromJid(oEvent.presence["@attributes"].to);
	}

	PegaChatEvent.pyMedia = "Chat";
	PegaChatEvent.pyCallId = 'chat' + Strophe.getNodeFromJid(oEvent.presence["@attributes"].from);
  PegaChatEvent.pyCreatedAt = oEvent.presence["@attributes"].created_at;
	this.publishChatEvent ("ChatCallStateEvent", PegaChatEvent);
      

    },


    handleConferenceLeave: function (oEvent) {

	var PegaChatEvent = {};

	if (this.isFromMe(oEvent.presence["@attributes"].from)) {
	
		return;
	}
	else {
		PegaChatEvent.pyOtherPartyName = Strophe.getResourceFromJid(oEvent.presence["@attributes"].from);
		PegaChatEvent.pyOtherPartyID = oEvent.presence["@attributes"].from;
    PegaChatEvent.pyCreatedAt = oEvent.presence["@attributes"].created_at;
		PegaChatEvent.pyEventName = "Disconnected";
	}


	PegaChatEvent.pyMedia = "Chat";
	PegaChatEvent.pyAgentID = oEvent.presence["@attributes"].to;
	PegaChatEvent.pyCallId = 'chat' + Strophe.getNodeFromJid(oEvent.presence["@attributes"].from);

	this.publishChatEvent ("ChatCallStateEvent", PegaChatEvent);

    },



    handleOtherPartyStatusChange: function (oEvent) {
/*
	var PegaChatEvent = new Object();

	PegaChatEvent.pyEventName = "Alerting";
	PegaChatEvent.pyMedia = "Chat";
	PegaChatEvent.pyPurpose = "AlertingChat";
	PegaChatEvent.pyAgentID = oEvent.iq["@attributes"].to;
	PegaChatEvent.pyAgentQueue = oEvent.iq["@attributes"].from;
	PegaChatEvent.pyOtherPartyName = Strophe.getNodeFromJid(oEvent.iq.offer["@attributes"].jid);;
	PegaChatEvent.pyOtherPartyID = oEvent.iq.offer["@attributes"].jid;
	PegaChatEvent.pyCallId = 'chat' + oEvent.iq["@attributes"].id;

	this.publishChatEvent ("ChatCallStateEvent", PegaChatEvent);
*/
    },


    /*
    @protected - Handle Presence Event 
    @param  object oEvent  – The Presence Event Object.
    @return null
    */
    handlePresenceEvent: function (oEvent) {

   	if (oEvent.presence["notify-queue"])
		this.handleQueueJoin (oEvent);
	else if (oEvent.presence.show)
		this.handlePresenceChange(oEvent);
	else if (oEvent.presence.status)
		this.handleOtherPartyStatusChange (oEvent);
	else if (oEvent.presence.error)
		this.handlePresenceError(oEvent); 
 	else if (oEvent.presence.x.item["@attributes"].role == "participant")
		this.handleConferenceJoin (oEvent);
        else if (oEvent.presence.x.item["@attributes"].role == "none")
		this.handleConferenceLeave (oEvent);
    },


    handleWorkGroupList: function (oEvent) {

	var PegaChatEvent = {};
	PegaChatEvent.pyEventName = "WorkGroupList";
	PegaChatEvent.pyMedia = "Chat";
	PegaChatEvent.pyAgentWorkGroups = [];

	if(oEvent.iq.workgroups.workgroup.length)																for (var i=0; i < oEvent.iq.workgroups.workgroup.length; i++)
			 PegaChatEvent.pyAgentWorkGroups.push(Strophe.getNodeFromJid(oEvent.iq.workgroups.workgroup[i]["@attributes"].jid));
	else
		PegaChatEvent.pyAgentWorkGroups.push(Strophe.getNodeFromJid(oEvent.iq.workgroups.workgroup["@attributes"].jid));

	this.publishChatEvent ("ChatAgentStateEvent", PegaChatEvent);

    },


    handleIQResult: function (oEvent) {

	if (oEvent.iq["@attributes"].id == "idWGL")
		this.handleWorkGroupList(oEvent);

    },
  
    handleIQError: function (oEvent) {
      var PegaChatEvent = new Object();
      PegaChatEvent.pyEventName = "Error";
      PegaChatEvent.pyMedia = "Chat";
      PegaChatEvent.pyErrorMessage = 'Connection Failed';
      this.publishChatEvent ("ChatAgentStateEvent", PegaChatEvent);
    },

    /*
    @protected - Handle IQ events.
    @param  object oEvent – The IQ event object.
    @return null
    */
    handleIqEvent: function (oEvent) {
	if (oEvent.iq["@attributes"].type == "result")
		this.handleIQResult(oEvent);
    else if(oEvent.iq["@attributes"].type == "error") 
        this.handleIQError(oEvent);
	else if (oEvent.iq.offer)
		this.handleOffer(oEvent);
	else if (oEvent.iq["offer-revoke"])
		this.handleOfferRevoke(oEvent);
  else if (oEvent.iq["messages"])
    this.handleMessages(oEvent);

/*
        if (oEvent.iq["@attributes"].type == "error")
            if (oEvent.iq.error["service-unavailable"])
                addToChatArea ("", oEvent.iq["@attributes"].from + " is not currently staffed.");
*/           
    },


    /*
    @protected - Checks to see if a message is a group chat invite
    @param object oEvent – The Message Event Object.
    @return boolean      - True if message is chat invite.
    */
    isInvite: function (oEvent) {

         if (oEvent.message)
            if (oEvent.message.x)
              for (i=0; i < oEvent.message.x.length; i++)
                if (oEvent.message.x[i].invite)
                  return true;
        return false;
    },

    /*
    @protected - Handle Message Event.
    @param  object oEvent – The Message Object.
    @return null
    */
    handleMessageEvent: function (oEvent) {

        // Multiple XMPP events come in as message objects
        //
        // INVITE: an invitation to chat, agents auto accept this invitation (since they already accepted the offer)
        //
        // MESSAGE: A chat message to be displayed.
       

        if (this.isInvite(oEvent)) {
			this.handleInvite(oEvent);
        }
        else if (oEvent.message.body) {
			this.handleMessageText(oEvent);
        }
		else if (oEvent.message.x) {
			if (oEvent.message.x.composing)
				this.handleComposing(oEvent);
		}
      	else if (oEvent.message.composing)
          	this.handleComposing(oEvent);
    },

    handleInvite: function (oEvent) {												
    	this.room = oEvent.message["@attributes"].from;
      var monitoringSessionStorageKey = 'chat' + this.room.split('@')[0] + "-manager-chat-mode";
      if (sessionStorage.getItem(monitoringSessionStorageKey)) {
        return;
      }
      this.roomJid = oEvent.message["@attributes"].from + "/";
      if (this._nickname)
         this.roomJid = this.roomJid + this._nickname;
      else
         this.roomJid = this.roomJid + Strophe.getNodeFromJid (oEvent.message["@attributes"].to);																	
      if(this.transferredFromMe(Strophe.getNodeFromJid(this.roomJid),"")) return;
      sessionStorage["chat" + Strophe.getNodeFromJid(this.roomJid)] = Strophe.getResourceFromJid(this.roomJid);  
	    if (oEvent.message.session)
		     chatConnection.acceptInvitation (this.roomJid,
         oEvent.message["@attributes"].to,  
         oEvent.message.session["@attributes"].id);
	    else
		     chatConnection.acceptInvitation (this.roomJid,
         oEvent.message["@attributes"].to);
    },

	  handleMessageText: function (oEvent) {
		  var PegaChatEvent = this._getMessageObject(oEvent);
		  this.publishChatEvent ("ChatCallStateEvent", PegaChatEvent);
	  },
    _getMessageObject: function (oEvent) {
      var PegaChatEvent = new Object();
		  PegaChatEvent.pyEventName = "Message";
		  PegaChatEvent.pyMedia = "Chat";
		  PegaChatEvent.pyCallId = 'chat' + Strophe.getNodeFromJid(oEvent.message["@attributes"].from);		
		  PegaChatEvent.pyMessageId = oEvent.message["@attributes"].id;      
      	PegaChatEvent.pyCreatedAt = oEvent.message["@attributes"].createdAt;	
      	PegaChatEvent.pyDisplayName = oEvent.message["@attributes"].displayName;	
      	PegaChatEvent.pyDisplayRole = oEvent.message["@attributes"].displayRole;	      
		  PegaChatEvent.pyMessageBody = oEvent.message.body["#text"]
      
       PegaChatEvent.pyCategory=oEvent.message["@attributes"].category;				  
       PegaChatEvent.pyMessageEvent = oEvent.message["@attributes"].event;
       PegaChatEvent.pyCategoryType= oEvent.message["@attributes"].categoryType; 
       PegaChatEvent.pyResponseType= oEvent.message["@attributes"].responseType; 
       if(PegaChatEvent.pyMessageEvent){         		
       		PegaChatEvent.pyMessageEventdata = oEvent.message.eventdata["@attributes"];		
    	} 

        if (oEvent.message.firefly)
          PegaChatEvent.firefly = oEvent.message.firefly;
			
      if (this.isFromMe(oEvent.message["@attributes"].from))
		  {
			// truncated delay messages to self
			if (oEvent.message.delay)
				return;

      //PegaChatEvent.pyAgentID = oEvent.message["@attributes"].from;
			PegaChatEvent.pyAgentID = Strophe.getBareJidFromJid(chatConnection.jid);
	    PegaChatEvent.pyAgentName = Strophe.getNodeFromJid(chatConnection.getJid());
      //PegaChatEvent.pyOtherPartyName = Strophe.getResourceFromJid (oEvent.message["@attributes"].to);
			PegaChatEvent.pyOtherPartyName = this.replaceToSpecialChars(Strophe.getNodeFromJid(chatConnection.getJid()));
		} else {
	    		PegaChatEvent.pyAgentID = oEvent.message["@attributes"].to;
			PegaChatEvent.pyAgentID = Strophe.getBareJidFromJid(chatConnection.jid);
	    		PegaChatEvent.pyAgentName = Strophe.getNodeFromJid(chatConnection.getJid());
			var username = oEvent.message["@attributes"].userName ? oEvent.message["@attributes"].userName: Strophe.getResourceFromJid (oEvent.message["@attributes"].from);
      PegaChatEvent.pyOtherPartyName = this.replaceToSpecialChars(username);
		}
    return PegaChatEvent;
  },
  replaceToSpecialChars: function(username){
    username = username.replace(/\\40/g, "@");
    username = username.replace(/\\27/g, "'");
    username = username.replace(/\\26/g, "&");
    username = username.replace(/\\20/g, " ");
    return username;   
  },
  handleMessagesEvent: function(oEvent) {
      var PegaChatEvent = new Object();
      PegaChatEvent.pyEventName = "Messages";
      PegaChatEvent.pyMedia = "Chat";
		  PegaChatEvent.pyCallId = 'chat' + Strophe.getNodeFromJid(oEvent.messagesResult["@attributes"].from);		
      PegaChatEvent.messages = [];
      var allMessages = oEvent.messagesResult.messages.message;
      for (var i=0; i < allMessages.length; i++){
        PegaChatEvent.messages.push(this._getMessageObject({message: allMessages[i]}));
      }
      this.publishChatEvent ("ChatCallStateEvent", PegaChatEvent);
  },
	handleComposing: function (oEvent) {

		var fromOtherAgent = (oEvent.message.composing['@attributes'].fromAgent === 'true') ? true: false;
    var PegaChatEvent = new Object();
      	PegaChatEvent.pyEventName = "Composing";
		PegaChatEvent.pyMedia = "Chat";
		PegaChatEvent.pyCallId = 'chat' + Strophe.getNodeFromJid(oEvent.message["@attributes"].from);
    PegaChatEvent.typeAhead = oEvent.message["@attributes"].typeAhead || '';

        		if (this.isFromMe(oEvent.message["@attributes"].from))
		{
	    		PegaChatEvent.pyAgentID = oEvent.message["@attributes"].from;
	    		PegaChatEvent.pyAgentName = Strophe.getNodeFromJid(oEvent.message["@attributes"].from);
			PegaChatEvent.pyOtherPartyName = "";
		}
        		else
		{
	    		PegaChatEvent.pyAgentID = oEvent.message["@attributes"].to;
	    		PegaChatEvent.pyAgentName = Strophe.getNodeFromJid(oEvent.message["@attributes"].to);
			PegaChatEvent.pyOtherPartyName = Strophe.getResourceFromJid (oEvent.message["@attributes"].from);
      PegaChatEvent.fromOtherAgent = fromOtherAgent;
		}


		this.publishChatEvent ("ChatCallStateEvent", PegaChatEvent);

	},


	publishChatEvent: function (type, oEvent) {

		var sEvent = serialize(oEvent);
		sendEvent(type, sEvent);

	},
  	publishPresence: function (state){
  
  	var oSafeURL = new SafeURL("ChannelServices-Device-Chat.SetOperatorPresenceForChat");
    		                oSafeURL.put("pzPrimaryPageName","ChatDevice");   	
      						oSafeURL.put("AgentState", state);
                            pega.u.d.asyncRequest("GET", oSafeURL, null, null); 
},

	/* KEEP THIS AS THE LAST FUNCTION */
	_lastFunction: function() {
	}
  
  
};


var oPegaChatAgentConnection = new pega.chat.agentConnection();
//static-content-hash-trigger-GCC
if (!pega)
	var pega = {};

if (!pega.chat)
  	pega.chat = {};


pega.chat.ChatConnection = function() {

        this.node = null;
        this.connection = null;
        this.eventHandler = null;
        this.jid = null;
        this.logOutFromChat = false;
	this.getJid = function() { return this.jid; };
};


pega.chat.ChatConnection.prototype = {
		
   
    login: function (user, pwd, url, handler) {

            this.eventHandler = handler;
            this.connection = new Strophe.Connection(url);

	    this.errors = 0;
	    var _this = this;
	    this.connection._proto._hitError = function (reqStatus) {

        		_this.errors++;
        		Strophe.warn("request errored, status: " + reqStatus + ", number of errors: " + _this.errors);
        		if (_this.errors > 2) {
			_this.onConnect(Strophe.Status.CONNFAIL);
			this._onDisconnectTimeout();
		}
    	    };

            this.connection.connect(user, pwd, this.onConnect);        
    },

    isConnected: function() {
      return this.jid ? this.connection && this.connection.connected : false;
    },
    logout: function (reason) {
      this.connection && this.connection.disconnect(reason);        
    },

    leaveChat: function (toJid) {
      var request = $pres({to: toJid, type: 'unavailable'});
      this.connection && this.connection.connected && this.connection.send(request.tree());
    },

    sendMessage: function (toJid, msgText, chatType, category) {
      var theMsg = $msg({to: toJid, type: chatType, category: category || ''}).c("body").t(msgText).up().c('active', {xmlns: 'http://jabber.org/protocol/chatstates'});
      this.connection.send(theMsg.tree());
    },
  
  
     transferChat: function (toJid, attributes) {
       var msgText = attributes.messages,
           chatType = attributes.chatType,
           queue = attributes.queueInfo.queue,
           reason = attributes.reason,
           announcement = attributes.announcement,
           agent = attributes.queueInfo.agent,
           metadata = attributes.metadata;
   
       	var pega = $build('pega', {xmlns: 'http://pega.com/pegachat', type: 'BlindTransfer'});
       		pega = pega.c("queue").t(queue).up().c("announcement").t(announcement).up().c("reason").t(reason).up();

       	if(agent) {
          pega = pega.c("agent").t(agent).up()
        }
   		var form = $build('metadata', {xmlns: 'http://jivesoftware.com/protocol/workgroup'});
        if (metadata) {
 			for (var key in metadata) {
				var field = $build('value', {name: key}).t(metadata[key]);
                form.node.appendChild(field.node);
            }
        }

		pega.cnode(form.node);
		var theMsg = $msg({to: toJid, type: chatType}).c("body").t(msgText).up().cnode(pega.up().node);
  		this.connection.send(theMsg.tree());
    },
  
  
    sendComposing: function (toJid, chatType) {
            var theMsg = $msg({to: toJid, type: chatType}).c('composing', {xmlns: 'http://jabber.org/protocol/chatstates',fromAgent: 'true'});
            this.connection.send(theMsg.tree());      
    },
  
  	cobrowseRequest: function (toJid, msgText, chatType) {
      
            var theMsg = $msg({to: toJid, type: chatType}).c("body").t(msgText).up()
            theMsg = theMsg.c('firefly', {xmlns: 'http://usefirefly.com/firefly', type: 'coBrowseRequest'});
            this.connection.send(theMsg.tree());
      
      
    },

  
   	pagePushRequest: function (toJid, msgText, chatType, pageUrl, isOpenNewTab,pageName) {
            var theMsg = $msg({to: toJid, type: chatType}).c("body").t(msgText).up()
            theMsg = theMsg.c("firefly", {xmlns: 'http://usefirefly.com/firefly', type: 'pagePushRequest'}).c('url').t(pageUrl).up().c('pageName').t(pageName).up().c('isOpenNewTab').t(isOpenNewTab);
            this.connection.send(theMsg.tree());
      
      
    },
  
    acceptInvitation: function (to, from, id) {

            var resp;
      var customized_display_name = sessionStorage.getItem("customized_display_name") || sessionStorage.getItem("displayName")
       if(customized_display_name==null)
        {
           var oXmlHttp = returnXMLHttpObj();
           var chatAutologinURL = new SafeURL("@baseclass.GetChatAutologinSettings");
           oXmlHttp.open("GET", chatAutologinURL.toURL(), false);
           oXmlHttp.send(null);
           var response = oXmlHttp.responseText.trim().split('#');
           if (response.length == 7) {
                sessionStorage.setItem("customized_display_name", response[6]);
                customized_display_name=response[6];
            } 
        }
      pega.cs.commonutils.setCookie("chat"+id,customized_display_name);
  
            if (id)
		resp = $pres({from : from, to: to, id: id, display_name:customized_display_name}).c('x', {xmlns: 'http://jabber.org/protocol/muc'});
            else
		resp = $pres({from : from, to: to, display_name:customized_display_name}).c('x', {xmlns: 'http://jabber.org/protocol/muc'});
            this.connection.send(resp.tree());
    },
    chatOffered: function (workgroup, id, user) {

            var resp = $iq({to: workgroup, type: 'set', id: id}).c('chat-offered', {xmlns: 'http://jabber.org/protocol/workgroup', jid : user});
            this.connection.send(resp.tree());
    },

    acceptOffer: function (workgroup, id, user, typeAhead) {
            var resp;
      var customized_display_name = sessionStorage.getItem("customized_display_name") || sessionStorage.getItem("displayName")
      pega.cs.commonutils.setCookie("chat"+id,customized_display_name);
            resp = $iq({to: workgroup, type: 'set', id: id, typeAhead: typeAhead, display_name: customized_display_name}).c('offer-accept', {xmlns: 'http://jabber.org/protocol/workgroup',jid : user});
            this.connection.send(resp.tree());
    },


    declineOffer: function (workgroup, id, user) {

            var resp = $iq({to: workgroup, type: 'set', id: id}).c('offer-reject', {xmlns: 'http://jabber.org/protocol/workgroup', jid : user});
            this.connection.send(resp.tree());
    },

/*
    declineInvitation: function (from, to, id, invitor) {

            var resp = $msg({from: to, to: from, id: id}).c('x', {xmlns: 'http://jabber.org/protocol/muc#user'}.c('decline', {from: invitor}));
            this_connection.send(resp);
    },
*/

    agentJoinWorkGroup: function (workgroup, maxChats) {
            var agentStatus = $pres({to: workgroup}).c("status").t("online").up();
            var displayName = sessionStorage.getItem("displayName");
      		agentStatus = agentStatus.c("agent-status", {xmlns: 'http://jabber.org/protocol/workgroup'}).c("display-name").t(displayName).up().c("maxChats").t(maxChats);
            this.connection.send (agentStatus.tree());
    },

    agentLeaveWorkGroup: function (workgroup) {
            var agentStatus = $pres({to: workgroup, type: "unavailable"});
            this.connection.send (agentStatus.tree());
    },

    joinChat: function (id, room, affil, role, options) {
      	options = options || {};
      	options.affiliation = affil ? affil : "none";
      	options.role = role ? role : "none";
      var customized_display_name = sessionStorage.getItem("customized_display_name") || sessionStorage.getItem("displayName")
      pega.cs.commonutils.setCookie("chat"+id,customized_display_name);
		var pres = $pres({to: room, display_name:customized_display_name}).c('x', {xmlns: 'http://jabber.org/protocol/muc#user'}).c('item', options);
	    this.connection.send (pres.tree());
    },       

 
    setState: function (state) {

            var notify = $pres().c("show").t(state)
            this.connection.send(notify.tree());

    },


    joinQueue: function (queue, metadata, id) {

            var form = $build('x', {xmlns: 'jabber:x:data', type: 'submit'});
            
            if (metadata) {
                for (var key in metadata) {
                    var val = $build('value').t(metadata[key]);
                    var field = $build('field', {key: key}).cnode(val.node);
                    form.node.appendChild(field.up().node);
                }
            }
 
            var join = $iq({to: queue, type: 'set', id: id}).c('join-queue', {xmlns: 'http://jabber.org/protocol/workgroup'})
                                           .c('queue-notifications').up().cnode(form.node); 
            
            this.connection.send(join.tree());


    },

/*
    departQueue: function (from, to) {

            var depart = $iq({from: from, to: to, type: 'set', id: 'id3'})
                         .c('depart-queue', {xmlns: 'http://jabber.org/protocol/workgroup'});
            this._connection.send(depart.tree());


    },
*/


    dispatchEvent: function (event) {
            
            try {
                var eventString = JSON.stringify(event);
//                sendEvent("ChatConnectionEvent", eventString);
                this.eventHandler.handleChatConnectionEvents(eventString);
            }
            catch (e) {
            }
    
    },

    queryWorkGroups: function (workgroup) {

	var query = $iq({to: workgroup, type: 'get', id: 'idWGL'}).c('workgroups', {xmlns: 'http://jabber.org/protocol/workgroup', jid: this.jid});
        this.connection.send(query.tree());
    },


    QueryWorkGroup: function (workgroup) {

        var query = $iq({to: workgroup, type: 'get', id: 'id3'}).c('query', {xmlns: 'http://jabber.org/protocol/disco#info'});
        this.connection.send(query.tree());

    },

    QueryWorkGroupQueues: function (workgroup) {


        var query = $iq({to: workgroup, type: 'get', id: 'id3'}).c('query', {xmlns: 'http://jabber.org/protocol/disco#items'});
        this.connection.send(query.tree());

    },

  
  	sendResult: function (to, id) {
        var result = $iq({to: to, type: 'result', id: id});
        this.connection.send(result.tree());
      
    },
  
    queryMessages: function(toJid) {		  
      var query = $iq({to: toJid, type: 'get', id:'idMessagesQuery'}).c("query", {xmlns: 'http://jabber.org/protocol/disco#items'});		
      this.connection && this.connection.connected && this.connection.send(query.tree());		
    },
  
    onConnect: function (status, reason) {


 
            var event = new Object ();
            event.connection = {};
      		
            switch (status) {
            
                case Strophe.Status.CONNECTING: 
                     event.connection.status = "CONNECTING";
                     break;

                case Strophe.Status.AUTHENTICATING: 
                     event.connection.status = "AUTHENTICATING";
                     break;

                case Strophe.Status.AUTHFAIL:
                     event.connection.status = "AUTHFAILED";
                     break;

                case Strophe.Status.CONNFAIL:
                     event.connection.status = "CONNFAILED";
                     break;

                case Strophe.Status.DISCONNECTING:
                     event.connection.status = "DISCONNECTING";
                     if (reason === 'logout') {
                       this.logOutFromChat = true;
                     }
                     break;
 
                case Strophe.Status.DISCONNECTED:
                     if (this.logOutFromChat) {
                       event.connection.status = "DISCONNECTED";
                     } else {
                       event.connection.status = "CONNFAILED";
                     }
                     
                     break;

                case Strophe.Status.CONNECTED:        
                     event.connection.status = "CONNECTED";
                      this.logOutFromChat = false;
                     break;

                case Strophe.Status.ERROR: 
                     event.connection.status = "ERROR";
                     break;
 
                case Strophe.Status.ATTACHED: 
                     event.connection.status = "ATTACHED";
                     break;

               default:
                     event.connection.status = "UNKNOWN";
                     break;

            }

	   if (status === Strophe.Status.CONNECTED) {

                chatConnection.jid = this.jid;

                // Base Handlers
                this.addHandler(chatConnection.onPresence, null, 'presence', null, null, null);
                this.addHandler(chatConnection.onIqGet, null, 'iq', 'get');
                this.addHandler(chatConnection.onIqResult, null, 'iq', 'result');
                this.addHandler(chatConnection.onIqError, null, 'iq', 'error');
	       		this.addHandler(chatConnection.onMessage, null, 'message', null, null,  null);
                this.addHandler(chatConnection.onChatState, 'http://jabber.org/protocol/chatstates');

                // Group Chat
//	       this.addHandler(chatConnection.onInvite, 'jabber:x:conference');


                // Workgroup Handlers
                this.addHandler(chatConnection.onWorkGroupIqSet, 'http://jabber.org/protocol/workgroup', 'iq', 'set');
                this.addHandler(chatConnection.onWorkGroupIqGet, 'http://jabber.org/protocol/workgroup', 'iq', 'get');
                this.addHandler(chatConnection.onWorkGroupPresence, 'http://jabber.org/protocol/workgroup', 'presence');
                this.addHandler(chatConnection.onChatMessagessResult, 'http://jabber.org/protocol/messages', 'iq');
            }

            chatConnection.dispatchEvent(event);

    },


    onChatMessagessResult: function(messages) {		
      var eventObj= {};		
      eventObj.messagesResult = xmlToJson(messages);		
      chatConnection.dispatchEvent(eventObj);		
      return true;		
    },
  
    onChatState: function (cs) {


    },


    onWorkGroupIqSet: function (iq) {

            var eventObj = {};
	    eventObj.iq = xmlToJson(iq);
	    chatConnection.dispatchEvent(eventObj);
            return true;
    },

    onWorkGroupIqGet: function (iq) {

            var eventObj = {};
	    eventObj.iq = xmlToJson(iq); 
	    chatConnection.dispatchEvent(eventObj);
            return true;
    },


  	onIqGet: function (iq) {
      	var eventObj = {};
	    eventObj.iq = xmlToJson(iq);
      	if (eventObj.iq.ping)
	    	chatConnection.sendResult(eventObj.iq["@attributes"].from, eventObj.iq["@attributes"].id);
        return true;
    },
  
    onIqError: function (iq) {
            var eventObj = {};
            eventObj.iq = xmlToJson(iq); 
	    	chatConnection.dispatchEvent(eventObj);
            return true;
    },


    onIqResult: function (iq) {
            var eventObj = {};
            eventObj.iq = xmlToJson(iq); 
			chatConnection.dispatchEvent(eventObj);
      		return true;
    },



    onWorkGroupPresence: function (presence) {

            var eventObj= {};
            eventObj.presence = xmlToJson(presence, null);
	    	chatConnection.dispatchEvent(eventObj);
            return true;
    },

    onPresence: function (presence) {

            var eventObj= {};
            eventObj.presence = xmlToJson(presence, null);
	    	chatConnection.dispatchEvent(eventObj);
            return true;
    },


    onInvite: function (invitation) {


            var eventObj= {};
            eventObj.message = xmlToJson(invitation);
	    chatConnection.dispatchEvent(eventObj);

            return true;
    },


        onMessage: function (msg) {
    

            var eventObj= {};
            eventObj.message = xmlToJson(msg);
            chatConnection.dispatchEvent(eventObj);

            return true;
    },


	_lastFunction: function() {
    }
};

function xmlToJson(xml) {
    var attr,
        child,
        attrs = xml.attributes,
        children = xml.childNodes,
        key = xml.nodeType,
        obj = {},
        i = -1;

    if (key === 1 && attrs.length) {
      obj[key = '@attributes'] = {};
      while (attr = attrs.item(++i)) {
        obj[key][attr.nodeName] = attr.nodeValue;
      }
      i = -1;
    } else if (key === 3) {
      obj = xml.nodeValue;
    }
    while (child = children.item(++i)) {
      key = child.nodeName;
      if (obj.hasOwnProperty(key)) {
        if (obj.toString.call(obj[key]) !== '[object Array]') {
          obj[key] = [obj[key]];
        }
        obj[key].push(xmlToJson(child));
      }
      else {
        obj[key] = xmlToJson(child);
      }
    }
    return obj;
  }


var chatConnection = new pega.chat.ChatConnection();
//static-content-hash-trigger-GCC
/** File: strophe.js
 *  A JavaScript library for writing XMPP clients.
 *
 *  This library uses either Bidirectional-streams Over Synchronous HTTP (BOSH)
 *  to emulate a persistent, stateful, two-way connection to an XMPP server or
 *  alternatively WebSockets.
 *
 *  More information on BOSH can be found in XEP 124.
 *  For more information on XMPP-over WebSocket see this RFC:
 *  http://tools.ietf.org/html/rfc7395
 */

/* All of the Strophe globals are defined in this special function below so
 * that references to the globals become closures.  This will ensure that
 * on page reload, these references will still be available to callbacks
 * that are still executing.
 */

/* jshint ignore:start */
(function (callback) {
/* jshint ignore:end */

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-base64', function () {
            return factory();
        });
    } else {
        // Browser globals
        root.Base64 = factory();
    }
}(this, function () {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    var obj = {
        /**
         * Encodes a string in base64
         * @param {String} input The string to encode in base64.
         */
        encode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc2 = ((chr1 & 3) << 4);
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
            } while (i < input.length);

            return output;
        },

        /**
         * Decodes a base64 string.
         * @param {String} input The string to decode.
         */
        decode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }
            } while (i < input.length);

            return output;
        }
    };
    return obj;
}));

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/* jshint undef: true, unused: true:, noarg: true, latedef: false */
/* global define */

/* Some functions and variables have been stripped for use with Strophe */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-sha1', function () {
            return factory();
        });
    } else {
        // Browser globals
        root.SHA1 = factory();
    }
}(this, function () {

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = new Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  var i, j, t, olda, oldb, oldc, oldd, olde;
  for (i = 0; i < x.length; i += 16)
  {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    olde = e;

    for (j = 0; j < 80; j++)
    {
      if (j < 16) { w[j] = x[i + j]; }
      else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }
      t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return [a, b, c, d, e];
}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if (t < 20) { return (b & c) | ((~b) & d); }
  if (t < 40) { return b ^ c ^ d; }
  if (t < 60) { return (b & c) | (b & d) | (c & d); }
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }

  var ipad = new Array(16), opad = new Array(16);
  for (var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = [];
  var mask = 255;
  for (var i = 0; i < str.length * 8; i += 8)
  {
    bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);
  }
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = 255;
  for (var i = 0; i < bin.length * 32; i += 8)
  {
    str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  var triplet, j;
  for (var i = 0; i < binarray.length * 4; i += 3)
  {
    triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
              (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
               ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for (j = 0; j < 4; j++)
    {
      if (i * 8 + j * 6 > binarray.length * 32) { str += "="; }
      else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
    }
  }
  return str;
}

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
return {
    b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },
    b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },
    binb2str:       binb2str,
    core_hmac_sha1: core_hmac_sha1,
    str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },
    str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },
};
}));

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Everything that isn't used by Strophe has been stripped here!
 */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-md5', function () {
            return factory();
        });
    } else {
        // Browser globals
        root.MD5 = factory();
    }
}(this, function (b) {
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    var safe_add = function (x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    };

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    var bit_rol = function (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    };

    /*
     * Convert a string to an array of little-endian words
     */
    var str2binl = function (str) {
        var bin = [];
        for(var i = 0; i < str.length * 8; i += 8)
        {
            bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);
        }
        return bin;
    };

    /*
     * Convert an array of little-endian words to a string
     */
    var binl2str = function (bin) {
        var str = "";
        for(var i = 0; i < bin.length * 32; i += 8)
        {
            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a hex string.
     */
    var binl2hex = function (binarray) {
        var hex_tab = "0123456789abcdef";
        var str = "";
        for(var i = 0; i < binarray.length * 4; i++)
        {
            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
        }
        return str;
    };

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    var md5_cmn = function (q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
    };

    var md5_ff = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    };

    var md5_gg = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    };

    var md5_hh = function (a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };

    var md5_ii = function (a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    };

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length
     */
    var core_md5 = function (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var a =  1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d =  271733878;

        var olda, oldb, oldc, oldd;
        for (var i = 0; i < x.length; i += 16)
        {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    };

    var obj = {
        /*
         * These are the functions you'll usually want to call.
         * They take string arguments and return either hex or base-64 encoded
         * strings.
         */
        hexdigest: function (s) {
            return binl2hex(core_md5(str2binl(s), s.length * 8));
        },

        hash: function (s) {
            return binl2str(core_md5(str2binl(s), s.length * 8));
        }
    };
    return obj;
}));

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-utils', function () {
            return factory();
        });
    } else {
        // Browser globals
        root.stropheUtils = factory();
    }
}(this, function () {

    var utils = {

        utf16to8: function (str) {
            var i, c;
            var out = "";
            var len = str.length;
            for (i = 0; i < len; i++) {
                c = str.charCodeAt(i);
                if ((c >= 0x0000) && (c <= 0x007F)) {
                    out += str.charAt(i);
                } else if (c > 0x07FF) {
                    out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));
                    out += String.fromCharCode(0x80 | ((c >>  6) & 0x3F));
                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                } else {
                    out += String.fromCharCode(0xC0 | ((c >>  6) & 0x1F));
                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                }
            }
            return out;
        },

        addCookies: function (cookies) {
            /* Parameters:
             *  (Object) cookies - either a map of cookie names
             *    to string values or to maps of cookie values.
             *
             * For example:
             * { "myCookie": "1234" }
             *
             * or:
             * { "myCookie": {
             *      "value": "1234",
             *      "domain": ".example.org",
             *      "path": "/",
             *      "expires": expirationDate
             *      }
             *  }
             *
             *  These values get passed to Strophe.Connection via
             *   options.cookies
             */
            var cookieName, cookieObj, isObj, cookieValue, expires, domain, path;
            for (cookieName in (cookies || {})) {
                expires = '';
                domain = '';
                path = '';
                cookieObj = cookies[cookieName];
                isObj = typeof cookieObj == "object";
                cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));
                if (isObj) {
                    expires = cookieObj.expires ? ";expires="+cookieObj.expires : '';
                    domain = cookieObj.domain ? ";domain="+cookieObj.domain : '';
                    path = cookieObj.path ? ";path="+cookieObj.path : '';
                }
                document.cookie =
                    cookieName+'='+cookieValue + expires + domain + path;
            }
        }
    };
    return utils;
}));

/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/* global define */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-polyfill', [], function () {
            return factory();
        });
    } else {
        // Browser globals
        return factory();
    }
}(this, function () {

/** Function: Function.prototype.bind
 *  Bind a function to an instance.
 *
 *  This Function object extension method creates a bound method similar
 *  to those in Python.  This means that the 'this' object will point
 *  to the instance you want.  See <MDC's bind() documentation at https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind>
 *  and <Bound Functions and Function Imports in JavaScript at http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/>
 *  for a complete explanation.
 *
 *  This extension already exists in some browsers (namely, Firefox 3), but
 *  we provide it to support those that don't.
 *
 *  Parameters:
 *    (Object) obj - The object that will become 'this' in the bound function.
 *    (Object) argN - An option argument that will be prepended to the
 *      arguments given for the function call
 *
 *  Returns:
 *    The bound function.
 */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (obj /*, arg1, arg2, ... */) {
        var func = this;
        var _slice = Array.prototype.slice;
        var _concat = Array.prototype.concat;
        var _args = _slice.call(arguments, 1);
        return function () {
            return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)));
        };
    };
}

/** Function: Array.isArray
 *  This is a polyfill for the ES5 Array.isArray method.
 */
if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/** Function: Array.prototype.indexOf
 *  Return the index of an object in an array.
 *
 *  This function is not supplied by some JavaScript implementations, so
 *  we provide it if it is missing.  This code is from:
 *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
 *
 *  Parameters:
 *    (Object) elt - The object to look for.
 *    (Integer) from - The index from which to start looking. (optional).
 *
 *  Returns:
 *    The index of elt in the array or -1 if not found.
 */
if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(elt /*, from*/) {
            var len = this.length;
            var from = Number(arguments[1]) || 0;
            from = (from < 0) ? Math.ceil(from) : Math.floor(from);
            if (from < 0) {
                from += len;
            }

            for (; from < len; from++) {
                if (from in this && this[from] === elt) {
                    return from;
                }
            }
            return -1;
        };
    }
}));


/** Function: Array.prototype.forEach
 *
 *  This function is not available in IE < 9
 *
 *  See <forEach on developer.mozilla.org at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>
 */
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(callback, thisArg) {
        var T, k;
        if (this === null) {
            throw new TypeError(' this is null or not defined');
        }

        // 1. Let O be the result of calling toObject() passing the
        // |this| value as the argument.
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get() internal
        // method of O with the argument "length".
        // 3. Let len be toUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If isCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== "function") {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let
        // T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        // 7. Repeat, while k < len
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //        This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty
            //        internal method of O with argument Pk.
            //        This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal
                // method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as
                // the this value and argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}

/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/*global define, document, window, setTimeout, clearTimeout, ActiveXObject, DOMParser */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-core', [
            'strophe-sha1',
            'strophe-base64',
            'strophe-md5',
            'strophe-utils',
            "strophe-polyfill"
        ], function () {
            return factory.apply(this, arguments);
        });
    } else {
        // Browser globals
        var o = factory(root.SHA1, root.Base64, root.MD5, root.stropheUtils);
        window.Strophe =        o.Strophe;
        window.$build =         o.$build;
        window.$iq =            o.$iq;
        window.$msg =           o.$msg;
        window.$pres =          o.$pres;
        window.SHA1 =           o.SHA1;
        window.Base64 =         o.Base64;
        window.MD5 =            o.MD5;
        window.b64_hmac_sha1 =  o.SHA1.b64_hmac_sha1;
        window.b64_sha1 =       o.SHA1.b64_sha1;
        window.str_hmac_sha1 =  o.SHA1.str_hmac_sha1;
        window.str_sha1 =       o.SHA1.str_sha1;
    }
}(this, function (SHA1, Base64, MD5, utils) {

var Strophe;

/** Function: $build
 *  Create a Strophe.Builder.
 *  This is an alias for 'new Strophe.Builder(name, attrs)'.
 *
 *  Parameters:
 *    (String) name - The root element name.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $build(name, attrs) { return new Strophe.Builder(name, attrs); }

/** Function: $msg
 *  Create a Strophe.Builder with a <message/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <message/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $msg(attrs) { return new Strophe.Builder("message", attrs); }

/** Function: $iq
 *  Create a Strophe.Builder with an <iq/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <iq/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $iq(attrs) { return new Strophe.Builder("iq", attrs); }

/** Function: $pres
 *  Create a Strophe.Builder with a <presence/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <presence/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $pres(attrs) { return new Strophe.Builder("presence", attrs); }

/** Class: Strophe
 *  An object container for all Strophe library functions.
 *
 *  This class is just a container for all the objects and constants
 *  used in the library.  It is not meant to be instantiated, but to
 *  provide a namespace for library objects, constants, and functions.
 */
Strophe = {
    /** Constant: VERSION
     *  The version of the Strophe library. Unreleased builds will have
     *  a version of head-HASH where HASH is a partial revision.
     */
    VERSION: "1.2.12",

    /** Constants: XMPP Namespace Constants
     *  Common namespace constants from the XMPP RFCs and XEPs.
     *
     *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
     *  NS.BOSH - BOSH namespace from XEP 206.
     *  NS.CLIENT - Main XMPP client namespace.
     *  NS.AUTH - Legacy authentication namespace.
     *  NS.ROSTER - Roster operations namespace.
     *  NS.PROFILE - Profile namespace.
     *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
     *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
     *  NS.MUC - Multi-User Chat namespace from XEP 45.
     *  NS.SASL - XMPP SASL namespace from RFC 3920.
     *  NS.STREAM - XMPP Streams namespace from RFC 3920.
     *  NS.BIND - XMPP Binding namespace from RFC 3920.
     *  NS.SESSION - XMPP Session namespace from RFC 3920.
     *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.
     *  NS.XHTML - XHTML body namespace from XEP 71.
     */
    NS: {
        HTTPBIND: "http://jabber.org/protocol/httpbind",
        BOSH: "urn:xmpp:xbosh",
        CLIENT: "jabber:client",
        AUTH: "jabber:iq:auth",
        ROSTER: "jabber:iq:roster",
        PROFILE: "jabber:iq:profile",
        DISCO_INFO: "http://jabber.org/protocol/disco#info",
        DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
        MUC: "http://jabber.org/protocol/muc",
        SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
        STREAM: "http://etherx.jabber.org/streams",
        FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
        BIND: "urn:ietf:params:xml:ns:xmpp-bind",
        SESSION: "urn:ietf:params:xml:ns:xmpp-session",
        VERSION: "jabber:iq:version",
        STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
        XHTML_IM: "http://jabber.org/protocol/xhtml-im",
        XHTML: "http://www.w3.org/1999/xhtml"
    },

    /** Constants: XHTML_IM Namespace
     *  contains allowed tags, tag attributes, and css properties.
     *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.
     *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended
     *  allowed tags and their attributes.
     */
    XHTML: {
        tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],
        attributes: {
            'a':          ['href'],
            'blockquote': ['style'],
            'br':         [],
            'cite':       ['style'],
            'em':         [],
            'img':        ['src', 'alt', 'style', 'height', 'width'],
            'li':         ['style'],
            'ol':         ['style'],
            'p':          ['style'],
            'span':       ['style'],
            'strong':     [],
            'ul':         ['style'],
            'body':       []
        },
        css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],
        /** Function: XHTML.validTag
         *
         * Utility method to determine whether a tag is allowed
         * in the XHTML_IM namespace.
         *
         * XHTML tag names are case sensitive and must be lower case.
         */
        validTag: function(tag) {
            for (var i = 0; i < Strophe.XHTML.tags.length; i++) {
                if (tag == Strophe.XHTML.tags[i]) {
                    return true;
                }
            }
            return false;
        },
        /** Function: XHTML.validAttribute
         *
         * Utility method to determine whether an attribute is allowed
         * as recommended per XEP-0071
         *
         * XHTML attribute names are case sensitive and must be lower case.
         */
        validAttribute: function(tag, attribute) {
            if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                    if (attribute == Strophe.XHTML.attributes[tag][i]) {
                        return true;
                    }
                }
            }
        return false;
        },
        validCSS: function(style) {
            for (var i = 0; i < Strophe.XHTML.css.length; i++) {
                if (style == Strophe.XHTML.css[i]) {
                    return true;
                }
            }
            return false;
        }
    },

    /** Constants: Connection Status Constants
     *  Connection status constants for use by the connection handler
     *  callback.
     *
     *  Status.ERROR - An error has occurred
     *  Status.CONNECTING - The connection is currently being made
     *  Status.CONNFAIL - The connection attempt failed
     *  Status.AUTHENTICATING - The connection is authenticating
     *  Status.AUTHFAIL - The authentication attempt failed
     *  Status.CONNECTED - The connection has succeeded
     *  Status.DISCONNECTED - The connection has been terminated
     *  Status.DISCONNECTING - The connection is currently being terminated
     *  Status.ATTACHED - The connection has been attached
     *  Status.CONNTIMEOUT - The connection has timed out
     */
    Status: {
        ERROR: 0,
        CONNECTING: 1,
        CONNFAIL: 2,
        AUTHENTICATING: 3,
        AUTHFAIL: 4,
        CONNECTED: 5,
        DISCONNECTED: 6,
        DISCONNECTING: 7,
        ATTACHED: 8,
        REDIRECT: 9,
        CONNTIMEOUT: 10
    },
    
  /** Set the default logging to false **/
   enableLogging:false,
  

    /** Constants: Log Level Constants
     *  Logging level indicators.
     *
     *  LogLevel.DEBUG - Debug output
     *  LogLevel.INFO - Informational output
     *  LogLevel.WARN - Warnings
     *  LogLevel.ERROR - Errors
     *  LogLevel.FATAL - Fatal errors
     */
    LogLevel: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        FATAL: 4
    },

    /** PrivateConstants: DOM Element Type Constants
     *  DOM element types.
     *
     *  ElementType.NORMAL - Normal element.
     *  ElementType.TEXT - Text data element.
     *  ElementType.FRAGMENT - XHTML fragment element.
     */
    ElementType: {
        NORMAL: 1,
        TEXT: 3,
        CDATA: 4,
        FRAGMENT: 11
    },

    /** PrivateConstants: Timeout Values
     *  Timeout values for error states.  These values are in seconds.
     *  These should not be changed unless you know exactly what you are
     *  doing.
     *
     *  TIMEOUT - Timeout multiplier. A waiting request will be considered
     *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 1.1, and with default wait, 66 seconds.
     *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
     *      Strophe can detect early failure, it will consider the request
     *      failed if it doesn't return after
     *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 0.1, and with default wait, 6 seconds.
     */
    TIMEOUT: 1.1,
    SECONDARY_TIMEOUT: 0.1,

    /** Function: addNamespace
     *  This function is used to extend the current namespaces in
     *  Strophe.NS.  It takes a key and a value with the key being the
     *  name of the new namespace, with its actual value.
     *  For example:
     *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
     *
     *  Parameters:
     *    (String) name - The name under which the namespace will be
     *      referenced under Strophe.NS
     *    (String) value - The actual namespace.
     */
    addNamespace: function (name, value) {
        Strophe.NS[name] = value;
    },

    /** Function: forEachChild
     *  Map a function over some or all child elements of a given element.
     *
     *  This is a small convenience function for mapping a function over
     *  some or all of the children of an element.  If elemName is null, all
     *  children will be passed to the function, otherwise only children
     *  whose tag names match elemName will be passed.
     *
     *  Parameters:
     *    (XMLElement) elem - The element to operate on.
     *    (String) elemName - The child element tag name filter.
     *    (Function) func - The function to apply to each child.  This
     *      function should take a single argument, a DOM element.
     */
    forEachChild: function (elem, elemName, func) {
        var i, childNode;
        for (i = 0; i < elem.childNodes.length; i++) {
            childNode = elem.childNodes[i];
            if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                (!elemName || this.isTagEqual(childNode, elemName))) {
                func(childNode);
            }
        }
    },

    /** Function: isTagEqual
     *  Compare an element's tag name with a string.
     *
     *  This function is case sensitive.
     *
     *  Parameters:
     *    (XMLElement) el - A DOM element.
     *    (String) name - The element name.
     *
     *  Returns:
     *    true if the element's tag name matches _el_, and false
     *    otherwise.
     */
    isTagEqual: function (el, name) {
        return el.tagName == name;
    },

    /** PrivateVariable: _xmlGenerator
     *  _Private_ variable that caches a DOM document to
     *  generate elements.
     */
    _xmlGenerator: null,

    /** PrivateFunction: _makeGenerator
     *  _Private_ function that creates a dummy XML DOM document to serve as
     *  an element and text node generator.
     */
    _makeGenerator: function () {
        var doc;
        // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.
        // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be
                // less than 10 in the case of IE9 and below.
        if (document.implementation.createDocument === undefined ||
                        document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
            doc = this._getIEXmlDom();
            doc.appendChild(doc.createElement('strophe'));
        } else {
            doc = document.implementation
                .createDocument('jabber:client', 'strophe', null);
        }
        return doc;
    },

    /** Function: xmlGenerator
     *  Get the DOM document to generate elements.
     *
     *  Returns:
     *    The currently used DOM document.
     */
    xmlGenerator: function () {
        if (!Strophe._xmlGenerator) {
            Strophe._xmlGenerator = Strophe._makeGenerator();
        }
        return Strophe._xmlGenerator;
    },

    /** PrivateFunction: _getIEXmlDom
     *  Gets IE xml doc object
     *
     *  Returns:
     *    A Microsoft XML DOM Object
     *  See Also:
     *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
     */
    _getIEXmlDom : function() {
        var doc = null;
        var docStrings = [
            "Msxml2.DOMDocument.6.0",
            "Msxml2.DOMDocument.5.0",
            "Msxml2.DOMDocument.4.0",
            "MSXML2.DOMDocument.3.0",
            "MSXML2.DOMDocument",
            "MSXML.DOMDocument",
            "Microsoft.XMLDOM"
        ];

        for (var d = 0; d < docStrings.length; d++) {
            if (doc === null) {
                try {
                    doc = new ActiveXObject(docStrings[d]);
                } catch (e) {
                    doc = null;
                }
            } else {
                break;
            }
        }
        return doc;
    },

    /** Function: xmlElement
     *  Create an XML DOM element.
     *
     *  This function creates an XML DOM element correctly across all
     *  implementations. Note that these are not HTML DOM elements, which
     *  aren't appropriate for XMPP stanzas.
     *
     *  Parameters:
     *    (String) name - The name for the element.
     *    (Array|Object) attrs - An optional array or object containing
     *      key/value pairs to use as element attributes. The object should
     *      be in the format {'key': 'value'} or {key: 'value'}. The array
     *      should have the format [['key1', 'value1'], ['key2', 'value2']].
     *    (String) text - The text child data for the element.
     *
     *  Returns:
     *    A new XML DOM element.
     */
    xmlElement: function (name) {
        if (!name) { return null; }

        var node = Strophe.xmlGenerator().createElement(name);
        // FIXME: this should throw errors if args are the wrong type or
        // there are more than two optional args
        var a, i, k;
        for (a = 1; a < arguments.length; a++) {
            var arg = arguments[a];
            if (!arg) { continue; }
            if (typeof(arg) == "string" ||
                typeof(arg) == "number") {
                node.appendChild(Strophe.xmlTextNode(arg));
            } else if (typeof(arg) == "object" &&
                       typeof(arg.sort) == "function") {
                for (i = 0; i < arg.length; i++) {
                    var attr = arg[i];
                    if (typeof(attr) == "object" &&
                        typeof(attr.sort) == "function" &&
                        attr[1] !== undefined &&
                        attr[1] !== null) {
                        node.setAttribute(attr[0], attr[1]);
                    }
                }
            } else if (typeof(arg) == "object") {
                for (k in arg) {
                    if (arg.hasOwnProperty(k)) {
                        if (arg[k] !== undefined &&
                            arg[k] !== null) {
                            node.setAttribute(k, arg[k]);
                        }
                    }
                }
            }
        }

        return node;
    },

    /*  Function: xmlescape
     *  Excapes invalid xml characters.
     *
     *  Parameters:
     *     (String) text - text to escape.
     *
     *  Returns:
     *      Escaped text.
     */
    xmlescape: function(text) {
        text = text.replace(/\&/g, "&amp;");
        text = text.replace(/</g,  "&lt;");
        text = text.replace(/>/g,  "&gt;");
        text = text.replace(/'/g,  "&apos;");
        text = text.replace(/"/g,  "&quot;");
        return text;
    },

    /*  Function: xmlunescape
    *  Unexcapes invalid xml characters.
    *
    *  Parameters:
    *     (String) text - text to unescape.
    *
    *  Returns:
    *      Unescaped text.
    */
    xmlunescape: function(text) {
        text = text.replace(/\&amp;/g, "&");
        text = text.replace(/&lt;/g,  "<");
        text = text.replace(/&gt;/g,  ">");
        text = text.replace(/&apos;/g,  "'");
        text = text.replace(/&quot;/g,  "\"");
        return text;
    },

    /** Function: xmlTextNode
     *  Creates an XML DOM text node.
     *
     *  Provides a cross implementation version of document.createTextNode.
     *
     *  Parameters:
     *    (String) text - The content of the text node.
     *
     *  Returns:
     *    A new XML DOM text node.
     */
    xmlTextNode: function (text) {
        return Strophe.xmlGenerator().createTextNode(text);
    },

    /** Function: xmlHtmlNode
     *  Creates an XML DOM html node.
     *
     *  Parameters:
     *    (String) html - The content of the html node.
     *
     *  Returns:
     *    A new XML DOM text node.
     */
    xmlHtmlNode: function (html) {
        var node;
        //ensure text is escaped
        if (window.DOMParser) {
            var parser = new DOMParser();
            node = parser.parseFromString(html, "text/xml");
        } else {
            node = new ActiveXObject("Microsoft.XMLDOM");
            node.async="false";
            node.loadXML(html);
        }
        return node;
    },

    /** Function: getText
     *  Get the concatenation of all text children of an element.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A String with the concatenated text of all text element children.
     */
    getText: function (elem) {
        if (!elem) { return null; }

        var str = "";
        if (elem.childNodes.length === 0 && elem.nodeType ==
            Strophe.ElementType.TEXT) {
            str += elem.nodeValue;
        }

        for (var i = 0; i < elem.childNodes.length; i++) {
            if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                str += elem.childNodes[i].nodeValue;
            }
        }

        return Strophe.xmlescape(str);
    },

    /** Function: copyElement
     *  Copy an XML DOM element.
     *
     *  This function copies a DOM element and all its descendants and returns
     *  the new copy.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A new, copied DOM element tree.
     */
    copyElement: function (elem) {
        var i, el;
        if (elem.nodeType == Strophe.ElementType.NORMAL) {
            el = Strophe.xmlElement(elem.tagName);

            for (i = 0; i < elem.attributes.length; i++) {
                el.setAttribute(elem.attributes[i].nodeName,
                                elem.attributes[i].value);
            }

            for (i = 0; i < elem.childNodes.length; i++) {
                el.appendChild(Strophe.copyElement(elem.childNodes[i]));
            }
        } else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
        }
        return el;
    },


    /** Function: createHtml
     *  Copy an HTML DOM element into an XML DOM.
     *
     *  This function copies a DOM element and all its descendants and returns
     *  the new copy.
     *
     *  Parameters:
     *    (HTMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A new, copied DOM element tree.
     */
    createHtml: function (elem) {
        var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;
        if (elem.nodeType == Strophe.ElementType.NORMAL) {
            tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.
            if(Strophe.XHTML.validTag(tag)) {
                try {
                    el = Strophe.xmlElement(tag);
                    for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                        attribute = Strophe.XHTML.attributes[tag][i];
                        value = elem.getAttribute(attribute);
                        if(typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {
                            continue;
                        }
                        if(attribute == 'style' && typeof value == 'object') {
                            if(typeof value.cssText != 'undefined') {
                                value = value.cssText; // we're dealing with IE, need to get CSS out
                            }
                        }
                        // filter out invalid css styles
                        if(attribute == 'style') {
                            css = [];
                            cssAttrs = value.split(';');
                            for(j = 0; j < cssAttrs.length; j++) {
                                attr = cssAttrs[j].split(':');
                                cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                if(Strophe.XHTML.validCSS(cssName)) {
                                    cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                    css.push(cssName + ': ' + cssValue);
                                }
                            }
                            if(css.length > 0) {
                                value = css.join('; ');
                                el.setAttribute(attribute, value);
                            }
                        } else {
                            el.setAttribute(attribute, value);
                        }
                    }

                    for (i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                    }
                } catch(e) { // invalid elements
                  el = Strophe.xmlTextNode('');
                }
            } else {
                el = Strophe.xmlGenerator().createDocumentFragment();
                for (i = 0; i < elem.childNodes.length; i++) {
                    el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                }
            }
        } else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
            el = Strophe.xmlGenerator().createDocumentFragment();
            for (i = 0; i < elem.childNodes.length; i++) {
                el.appendChild(Strophe.createHtml(elem.childNodes[i]));
            }
        } else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlTextNode(elem.nodeValue);
        }
        return el;
    },

    /** Function: escapeNode
     *  Escape the node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An escaped node (or local part).
     */
    escapeNode: function (node) {
        if (typeof node !== "string") { return node; }
        return node.replace(/^\s+|\s+$/g, '')
            .replace(/\\/g,  "\\5c")
            .replace(/ /g,   "\\20")
            .replace(/\"/g,  "\\22")
            .replace(/\&/g,  "\\26")
            .replace(/\'/g,  "\\27")
            .replace(/\//g,  "\\2f")
            .replace(/:/g,   "\\3a")
            .replace(/</g,   "\\3c")
            .replace(/>/g,   "\\3e")
            .replace(/@/g,   "\\40");
    },

    /** Function: unescapeNode
     *  Unescape a node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An unescaped node (or local part).
     */
    unescapeNode: function (node) {
        if (typeof node !== "string") { return node; }
        return node.replace(/\\20/g, " ")
            .replace(/\\22/g, '"')
            .replace(/\\26/g, "&")
            .replace(/\\27/g, "'")
            .replace(/\\2f/g, "/")
            .replace(/\\3a/g, ":")
            .replace(/\\3c/g, "<")
            .replace(/\\3e/g, ">")
            .replace(/\\40/g, "@")
            .replace(/\\5c/g, "\\");
    },

    /** Function: getNodeFromJid
     *  Get the node portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the node.
     */
    getNodeFromJid: function (jid) {
        if (jid.indexOf("@") < 0) { return null; }
        return jid.split("@")[0];
    },

    /** Function: getDomainFromJid
     *  Get the domain portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the domain.
     */
    getDomainFromJid: function (jid) {
        var bare = Strophe.getBareJidFromJid(jid);
        if (bare.indexOf("@") < 0) {
            return bare;
        } else {
            var parts = bare.split("@");
            parts.splice(0, 1);
            return parts.join('@');
        }
    },

    /** Function: getResourceFromJid
     *  Get the resource portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the resource.
     */
    getResourceFromJid: function (jid) {
        var s = jid.split("/");
        if (s.length < 2) { return null; }
        s.splice(0, 1);
        return s.join('/');
    },

    /** Function: getBareJidFromJid
     *  Get the bare JID from a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the bare JID.
     */
    getBareJidFromJid: function (jid) {
        return jid ? jid.split("/")[0] : null;
    },

    /** PrivateFunction: _handleError
     *  _Private_ function that properly logs an error to the console
     */
    _handleError: function (e) {
        if (typeof e.stack !== "undefined") {
            Strophe.fatal(e.stack);
        }
        if (e.sourceURL) {
            Strophe.fatal("error: " + this.handler + " " + e.sourceURL + ":" +
                          e.line + " - " + e.name + ": " + e.message);
        } else if (e.fileName) {
            Strophe.fatal("error: " + this.handler + " " +
                          e.fileName + ":" + e.lineNumber + " - " +
                          e.name + ": " + e.message);
        } else {
            Strophe.fatal("error: " + e.message);
        }
    },

    /** Function: log
     *  User overrideable logging function.
     *
     *  This function is called whenever the Strophe library calls any
     *  of the logging functions.  The default implementation of this
     *  function does nothing.  If client code wishes to handle the logging
     *  messages, it should override this with
     *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
     *
     *  Please note that data sent and received over the wire is logged
     *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
     *
     *  The different levels and their meanings are
     *
     *    DEBUG - Messages useful for debugging purposes.
     *    INFO - Informational messages.  This is mostly information like
     *      'disconnect was called' or 'SASL auth succeeded'.
     *    WARN - Warnings about potential problems.  This is mostly used
     *      to report transient connection errors like request timeouts.
     *    ERROR - Some error occurred.
     *    FATAL - A non-recoverable fatal error occurred.
     *
     *  Parameters:
     *    (Integer) level - The log level of the log message.  This will
     *      be one of the values in Strophe.LogLevel.
     *    (String) msg - The log message.
     */
    /* jshint ignore:start */
    log: function (level, msg) {
      if (this.enableLogging == false)
        return;
      
      if ( pega.cti.API.Logger == null ||   typeof(pega.cti.API.Logger) == 'undefined') return;
      
   switch(level) {
  case this.LogLevel.DEBUG:
   pega.cti.API.Logger.debug("Strophe:  "+msg);
    break;
  case this.LogLevel.INFO:
   pega.cti.API.Logger.info("Strophe:  "+msg);
    break;
   case this.LogLevel.WARN:
      pega.cti.API.Logger.warn("Strophe:  "+msg);
   break;
   case this.LogLevel.ERROR:
   pega.cti.API.Logger.Error("Strophe:  "+msg);
    break;
   case this.LogLevel.FATAL:
   pega.cti.API.Logger.fatal("Strophe:  "+msg);
    break;


}
      
    },
    /* jshint ignore:end */

    /** Function: debug
     *  Log a message at the Strophe.LogLevel.DEBUG level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    debug: function(msg) {
        this.log(this.LogLevel.DEBUG, msg);
    },

    /** Function: info
     *  Log a message at the Strophe.LogLevel.INFO level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    info: function (msg) {
        this.log(this.LogLevel.INFO, msg);
    },

    /** Function: warn
     *  Log a message at the Strophe.LogLevel.WARN level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    warn: function (msg) {
        this.log(this.LogLevel.WARN, msg);
    },

    /** Function: error
     *  Log a message at the Strophe.LogLevel.ERROR level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    error: function (msg) {
        this.log(this.LogLevel.ERROR, msg);
    },

    /** Function: fatal
     *  Log a message at the Strophe.LogLevel.FATAL level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    fatal: function (msg) {
        this.log(this.LogLevel.FATAL, msg);
    },

    /** Function: serialize
     *  Render a DOM element and all descendants to a String.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The serialized element tree as a String.
     */
    serialize: function (elem) {
        var result;

        if (!elem) { return null; }

        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }

        var nodeName = elem.nodeName;
        var i, child;

        if (elem.getAttribute("_realname")) {
            nodeName = elem.getAttribute("_realname");
        }

        result = "<" + nodeName;
        for (i = 0; i < elem.attributes.length; i++) {
             if(elem.attributes[i].nodeName != "_realname") {
               result += " " + elem.attributes[i].nodeName +
                   "='" + Strophe.xmlescape(elem.attributes[i].value) + "'";
             }
        }

        if (elem.childNodes.length > 0) {
            result += ">";
            for (i = 0; i < elem.childNodes.length; i++) {
                child = elem.childNodes[i];
                switch( child.nodeType ){
                  case Strophe.ElementType.NORMAL:
                    // normal element, so recurse
                    result += Strophe.serialize(child);
                    break;
                  case Strophe.ElementType.TEXT:
                    // text element to escape values
                    result += Strophe.xmlescape(child.nodeValue);
                    break;
                  case Strophe.ElementType.CDATA:
                    // cdata section so don't escape values
                    result += "<![CDATA["+child.nodeValue+"]]>";
                }
            }
            result += "</" + nodeName + ">";
        } else {
            result += "/>";
        }

        return result;
    },

    /** PrivateVariable: _requestId
     *  _Private_ variable that keeps track of the request ids for
     *  connections.
     */
    _requestId: 0,

    /** PrivateVariable: Strophe.connectionPlugins
     *  _Private_ variable Used to store plugin names that need
     *  initialization on Strophe.Connection construction.
     */
    _connectionPlugins: {},

    /** Function: addConnectionPlugin
     *  Extends the Strophe.Connection object with the given plugin.
     *
     *  Parameters:
     *    (String) name - The name of the extension.
     *    (Object) ptype - The plugin's prototype.
     */
    addConnectionPlugin: function (name, ptype) {
        Strophe._connectionPlugins[name] = ptype;
    }
};

/** Class: Strophe.Builder
 *  XML DOM builder.
 *
 *  This object provides an interface similar to JQuery but for building
 *  DOM elements easily and rapidly.  All the functions except for toString()
 *  and tree() return the object, so calls can be chained.  Here's an
 *  example using the $iq() builder helper.
 *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
 *  >     .c('query', {xmlns: 'strophe:example'})
 *  >     .c('example')
 *  >     .toString()
 *
 *  The above generates this XML fragment
 *  > <iq to='you' from='me' type='get' id='1'>
 *  >   <query xmlns='strophe:example'>
 *  >     <example/>
 *  >   </query>
 *  > </iq>
 *  The corresponding DOM manipulations to get a similar fragment would be
 *  a lot more tedious and probably involve several helper variables.
 *
 *  Since adding children makes new operations operate on the child, up()
 *  is provided to traverse up the tree.  To add two children, do
 *  > builder.c('child1', ...).up().c('child2', ...)
 *  The next operation on the Builder will be relative to the second child.
 */

/** Constructor: Strophe.Builder
 *  Create a Strophe.Builder object.
 *
 *  The attributes should be passed in object notation.  For example
 *  > var b = new Builder('message', {to: 'you', from: 'me'});
 *  or
 *  > var b = new Builder('messsage', {'xml:lang': 'en'});
 *
 *  Parameters:
 *    (String) name - The name of the root element.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder.
 */
Strophe.Builder = function (name, attrs) {
    // Set correct namespace for jabber:client elements
    if (name == "presence" || name == "message" || name == "iq") {
        if (attrs && !attrs.xmlns) {
            attrs.xmlns = Strophe.NS.CLIENT;
        } else if (!attrs) {
            attrs = {xmlns: Strophe.NS.CLIENT};
        }
    }

    // Holds the tree being built.
    this.nodeTree = Strophe.xmlElement(name, attrs);

    // Points to the current operation node.
    this.node = this.nodeTree;
};

Strophe.Builder.prototype = {
    /** Function: tree
     *  Return the DOM tree.
     *
     *  This function returns the current DOM tree as an element object.  This
     *  is suitable for passing to functions like Strophe.Connection.send().
     *
     *  Returns:
     *    The DOM tree as a element object.
     */
    tree: function () {
        return this.nodeTree;
    },

    /** Function: toString
     *  Serialize the DOM tree to a String.
     *
     *  This function returns a string serialization of the current DOM
     *  tree.  It is often used internally to pass data to a
     *  Strophe.Request object.
     *
     *  Returns:
     *    The serialized DOM tree in a String.
     */
    toString: function () {
        return Strophe.serialize(this.nodeTree);
    },

    /** Function: up
     *  Make the current parent element the new current element.
     *
     *  This function is often used after c() to traverse back up the tree.
     *  For example, to add two children to the same element
     *  > builder.c('child1', {}).up().c('child2', {});
     *
     *  Returns:
     *    The Stophe.Builder object.
     */
    up: function () {
        this.node = this.node.parentNode;
        return this;
    },

    /** Function: root
     *  Make the root element the new current element.
     *
     *  When at a deeply nested element in the tree, this function can be used
     *  to jump back to the root of the tree, instead of having to repeatedly
     *  call up().
     *
     *  Returns:
     *    The Stophe.Builder object.
     */
    root: function () {
        this.node = this.nodeTree;
        return this;
    },

    /** Function: attrs
     *  Add or modify attributes of the current element.
     *
     *  The attributes should be passed in object notation.  This function
     *  does not move the current element pointer.
     *
     *  Parameters:
     *    (Object) moreattrs - The attributes to add/modify in object notation.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    attrs: function (moreattrs) {
        for (var k in moreattrs) {
            if (moreattrs.hasOwnProperty(k)) {
                if (moreattrs[k] === undefined) {
                    this.node.removeAttribute(k);
                } else {
                    this.node.setAttribute(k, moreattrs[k]);
                }
            }
        }
        return this;
    },

    /** Function: c
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function moves the current element pointer to the child,
     *  unless text is provided.  If you need to add another child, it
     *  is necessary to use up() to go back to the parent in the tree.
     *
     *  Parameters:
     *    (String) name - The name of the child.
     *    (Object) attrs - The attributes of the child in object notation.
     *    (String) text - The text to add to the child.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    c: function (name, attrs, text) {
        var child = Strophe.xmlElement(name, attrs, text);
        this.node.appendChild(child);
        if (typeof text !== "string" && typeof text !=="number") {
            this.node = child;
        }
        return this;
    },

    /** Function: cnode
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function is the same as c() except that instead of using a
     *  name and an attributes object to create the child it uses an
     *  existing DOM element object.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    cnode: function (elem) {
        var impNode;
        var xmlGen = Strophe.xmlGenerator();
        try {
            impNode = (xmlGen.importNode !== undefined);
        } catch (e) {
            impNode = false;
        }
        var newElem = impNode ?
                      xmlGen.importNode(elem, true) :
                      Strophe.copyElement(elem);
        this.node.appendChild(newElem);
        this.node = newElem;
        return this;
    },

    /** Function: t
     *  Add a child text element.
     *
     *  This *does not* make the child the new current element since there
     *  are no children of text elements.
     *
     *  Parameters:
     *    (String) text - The text data to append to the current element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    t: function (text) {
        var child = Strophe.xmlTextNode(text);
        this.node.appendChild(child);
        return this;
    },

    /** Function: h
     *  Replace current element contents with the HTML passed in.
     *
     *  This *does not* make the child the new current element
     *
     *  Parameters:
     *    (String) html - The html to insert as contents of current element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    h: function (html) {
        var fragment = document.createElement('body');

        // force the browser to try and fix any invalid HTML tags
        fragment.innerHTML = html;

        // copy cleaned html into an xml dom
        var xhtml = Strophe.createHtml(fragment);

        while(xhtml.childNodes.length > 0) {
            this.node.appendChild(xhtml.childNodes[0]);
        }
        return this;
    }
};

/** PrivateClass: Strophe.Handler
 *  _Private_ helper class for managing stanza handlers.
 *
 *  A Strophe.Handler encapsulates a user provided callback function to be
 *  executed when matching stanzas are received by the connection.
 *  Handlers can be either one-off or persistant depending on their
 *  return value. Returning true will cause a Handler to remain active, and
 *  returning false will remove the Handler.
 *
 *  Users will not use Strophe.Handler objects directly, but instead they
 *  will use Strophe.Connection.addHandler() and
 *  Strophe.Connection.deleteHandler().
 */

/** PrivateConstructor: Strophe.Handler
 *  Create and initialize a new Strophe.Handler.
 *
 *  Parameters:
 *    (Function) handler - A function to be executed when the handler is run.
 *    (String) ns - The namespace to match.
 *    (String) name - The element name to match.
 *    (String) type - The element type to match.
 *    (String) id - The element id attribute to match.
 *    (String) from - The element from attribute to match.
 *    (Object) options - Handler options
 *
 *  Returns:
 *    A new Strophe.Handler object.
 */
Strophe.Handler = function (handler, ns, name, type, id, from, options) {
    this.handler = handler;
    this.ns = ns;
    this.name = name;
    this.type = type;
    this.id = id;
    this.options = options || {'matchBareFromJid': false, 'ignoreNamespaceFragment': false};
    // BBB: Maintain backward compatibility with old `matchBare` option
    if (this.options.matchBare) {
        Strophe.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.');
        this.options.matchBareFromJid = this.options.matchBare;
        delete this.options.matchBare;
    }

    if (this.options.matchBareFromJid) {
        this.from = from ? Strophe.getBareJidFromJid(from) : null;
    } else {
        this.from = from;
    }
    // whether the handler is a user handler or a system handler
    this.user = true;
};

Strophe.Handler.prototype = {
    /** PrivateFunction: getNamespace
     *  Returns the XML namespace attribute on an element.
     *  If `ignoreNamespaceFragment` was passed in for this handler, then the
     *  URL fragment will be stripped.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML element with the namespace.
     *
     *  Returns:
     *    The namespace, with optionally the fragment stripped.
     */
    getNamespace: function (elem) {
        var elNamespace = elem.getAttribute("xmlns");
        if (elNamespace && this.options.ignoreNamespaceFragment) {
            elNamespace = elNamespace.split('#')[0];
        }
        return elNamespace;
    },

    /** PrivateFunction: namespaceMatch
     *  Tests if a stanza matches the namespace set for this Strophe.Handler.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML element to test.
     *
     *  Returns:
     *    true if the stanza matches and false otherwise.
     */
    namespaceMatch: function (elem) {
        var nsMatch = false;
        if (!this.ns) {
            return true;
        } else {
            var that = this;
            Strophe.forEachChild(elem, null, function (elem) {
                if (that.getNamespace(elem) === that.ns) {
                    nsMatch = true;
                }
            });
            nsMatch = nsMatch || this.getNamespace(elem) === this.ns;
        }
        return nsMatch;
    },

    /** PrivateFunction: isMatch
     *  Tests if a stanza matches the Strophe.Handler.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML element to test.
     *
     *  Returns:
     *    true if the stanza matches and false otherwise.
     */
    isMatch: function (elem) {
        var from = elem.getAttribute('from');
        if (this.options.matchBareFromJid) {
            from = Strophe.getBareJidFromJid(from);
        }
        var elem_type = elem.getAttribute("type");
        if (this.namespaceMatch(elem) &&
            (!this.name || Strophe.isTagEqual(elem, this.name)) &&
            (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) != -1 : elem_type == this.type)) &&
            (!this.id || elem.getAttribute("id") == this.id) &&
            (!this.from || from == this.from)) {
                return true;
        }
        return false;
    },

    /** PrivateFunction: run
     *  Run the callback on a matching stanza.
     *
     *  Parameters:
     *    (XMLElement) elem - The DOM element that triggered the
     *      Strophe.Handler.
     *
     *  Returns:
     *    A boolean indicating if the handler should remain active.
     */
    run: function (elem) {
        var result = null;
        try {
            result = this.handler(elem);
        } catch (e) {
            Strophe._handleError(e);
            throw e;
        }
        return result;
    },

    /** PrivateFunction: toString
     *  Get a String representation of the Strophe.Handler object.
     *
     *  Returns:
     *    A String.
     */
    toString: function () {
        return "{Handler: " + this.handler + "(" + this.name + "," +
            this.id + "," + this.ns + ")}";
    }
};

/** PrivateClass: Strophe.TimedHandler
 *  _Private_ helper class for managing timed handlers.
 *
 *  A Strophe.TimedHandler encapsulates a user provided callback that
 *  should be called after a certain period of time or at regular
 *  intervals.  The return value of the callback determines whether the
 *  Strophe.TimedHandler will continue to fire.
 *
 *  Users will not use Strophe.TimedHandler objects directly, but instead
 *  they will use Strophe.Connection.addTimedHandler() and
 *  Strophe.Connection.deleteTimedHandler().
 */

/** PrivateConstructor: Strophe.TimedHandler
 *  Create and initialize a new Strophe.TimedHandler object.
 *
 *  Parameters:
 *    (Integer) period - The number of milliseconds to wait before the
 *      handler is called.
 *    (Function) handler - The callback to run when the handler fires.  This
 *      function should take no arguments.
 *
 *  Returns:
 *    A new Strophe.TimedHandler object.
 */
Strophe.TimedHandler = function (period, handler) {
    this.period = period;
    this.handler = handler;
    this.lastCalled = new Date().getTime();
    this.user = true;
};

Strophe.TimedHandler.prototype = {
    /** PrivateFunction: run
     *  Run the callback for the Strophe.TimedHandler.
     *
     *  Returns:
     *    true if the Strophe.TimedHandler should be called again, and false
     *      otherwise.
     */
    run: function () {
        this.lastCalled = new Date().getTime();
        return this.handler();
    },

    /** PrivateFunction: reset
     *  Reset the last called time for the Strophe.TimedHandler.
     */
    reset: function () {
        this.lastCalled = new Date().getTime();
    },

    /** PrivateFunction: toString
     *  Get a string representation of the Strophe.TimedHandler object.
     *
     *  Returns:
     *    The string representation.
     */
    toString: function () {
        return "{TimedHandler: " + this.handler + "(" + this.period +")}";
    }
};

/** Class: Strophe.Connection
 *  XMPP Connection manager.
 *
 *  This class is the main part of Strophe.  It manages a BOSH or websocket
 *  connection to an XMPP server and dispatches events to the user callbacks
 *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1
 *  and legacy authentication.
 *
 *  After creating a Strophe.Connection object, the user will typically
 *  call connect() with a user supplied callback to handle connection level
 *  events like authentication failure, disconnection, or connection
 *  complete.
 *
 *  The user will also have several event handlers defined by using
 *  addHandler() and addTimedHandler().  These will allow the user code to
 *  respond to interesting stanzas or do something periodically with the
 *  connection. These handlers will be active once authentication is
 *  finished.
 *
 *  To send data to the connection, use send().
 */

/** Constructor: Strophe.Connection
 *  Create and initialize a Strophe.Connection object.
 *
 *  The transport-protocol for this connection will be chosen automatically
 *  based on the given service parameter. URLs starting with "ws://" or
 *  "wss://" will use WebSockets, URLs starting with "http://", "https://"
 *  or without a protocol will use BOSH.
 *
 *  To make Strophe connect to the current host you can leave out the protocol
 *  and host part and just pass the path, e.g.
 *
 *  > var conn = new Strophe.Connection("/http-bind/");
 *
 *  Options common to both Websocket and BOSH:
 *  ------------------------------------------
 *
 *  cookies:
 *
 *  The *cookies* option allows you to pass in cookies to be added to the
 *  document. These cookies will then be included in the BOSH XMLHttpRequest
 *  or in the websocket connection.
 *
 *  The passed in value must be a map of cookie names and string values.
 *
 *  > { "myCookie": {
 *  >     "value": "1234",
 *  >     "domain": ".example.org",
 *  >     "path": "/",
 *  >     "expires": expirationDate
 *  >     }
 *  > }
 *
 *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).
 *  Those cookies need to be set under those domains, for example they can be
 *  set server-side by making a XHR call to that domain to ask it to set any
 *  necessary cookies.
 *
 *  mechanisms:
 *
 *  The *mechanisms* option allows you to specify the SASL mechanisms that this
 *  instance of Strophe.Connection (and therefore your XMPP client) will
 *  support.
 *
 *  The value must be an array of objects with Strophe.SASLMechanism
 *  prototypes.
 *
 *  If nothing is specified, then the following mechanisms (and their
 *  priorities) are registered:
 *
 *      OAUTHBEARER - 60
 *      SCRAM-SHA1 - 50
 *      DIGEST-MD5 - 40
 *      PLAIN - 30
 *      ANONYMOUS - 20
 *      EXTERNAL - 10
 *
 *  WebSocket options:
 *  ------------------
 *
 *  If you want to connect to the current host with a WebSocket connection you
 *  can tell Strophe to use WebSockets through a "protocol" attribute in the
 *  optional options parameter. Valid values are "ws" for WebSocket and "wss"
 *  for Secure WebSocket.
 *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
 *
 *  > var conn = new Strophe.Connection("/xmpp-websocket/", {protocol: "wss"});
 *
 *  Note that relative URLs _NOT_ starting with a "/" will also include the path
 *  of the current site.
 *
 *  Also because downgrading security is not permitted by browsers, when using
 *  relative URLs both BOSH and WebSocket connections will use their secure
 *  variants if the current connection to the site is also secure (https).
 *
 *  BOSH options:
 *  -------------
 *
 *  By adding "sync" to the options, you can control if requests will
 *  be made synchronously or not. The default behaviour is asynchronous.
 *  If you want to make requests synchronous, make "sync" evaluate to true.
 *  > var conn = new Strophe.Connection("/http-bind/", {sync: true});
 *
 *  You can also toggle this on an already established connection.
 *  > conn.options.sync = true;
 *
 *  The *customHeaders* option can be used to provide custom HTTP headers to be
 *  included in the XMLHttpRequests made.
 *
 *  The *keepalive* option can be used to instruct Strophe to maintain the
 *  current BOSH session across interruptions such as webpage reloads.
 *
 *  It will do this by caching the sessions tokens in sessionStorage, and when
 *  "restore" is called it will check whether there are cached tokens with
 *  which it can resume an existing session.
 *
 *  The *withCredentials* option should receive a Boolean value and is used to
 *  indicate wether cookies should be included in ajax requests (by default
 *  they're not).
 *  Set this value to true if you are connecting to a BOSH service
 *  and for some reason need to send cookies to it.
 *  In order for this to work cross-domain, the server must also enable
 *  credentials by setting the Access-Control-Allow-Credentials response header
 *  to "true". For most usecases however this setting should be false (which
 *  is the default).
 *  Additionally, when using Access-Control-Allow-Credentials, the
 *  Access-Control-Allow-Origin header can't be set to the wildcard "*", but
 *  instead must be restricted to actual domains.
 *
 *  The *contentType* option can be set to change the default Content-Type
 *  of "text/xml; charset=utf-8", which can be useful to reduce the amount of
 *  CORS preflight requests that are sent to the server.
 *
 *  Parameters:
 *    (String) service - The BOSH or WebSocket service URL.
 *    (Object) options - A hash of configuration options
 *
 *  Returns:
 *    A new Strophe.Connection object.
 */
Strophe.Connection = function (service, options) {
    // The service URL
    this.service = service;
    // Configuration options
    this.options = options || {};
    var proto = this.options.protocol || "";

    // Select protocal based on service or options
    if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 ||
            proto.indexOf("ws") === 0) {
        this._proto = new Strophe.Websocket(this);
    } else {
        this._proto = new Strophe.Bosh(this);
    }

    /* The connected JID. */
    this.jid = "";
    /* the JIDs domain */
    this.domain = null;
    /* stream:features */
    this.features = null;

    // SASL
    this._sasl_data = {};
    this.do_session = false;
    this.do_bind = false;

    // handler lists
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this.protocolErrorHandlers = {
        'HTTP': {},
        'websocket': {}
    };

    this._idleTimeout = null;
    this._disconnectTimeout = null;

    this.authenticated = false;
    this.connected = false;
    this.disconnecting = false;
    this.do_authentication = true;
    this.paused = false;
    this.restored = false;

    this._data = [];
    this._uniqueId = 0;

    this._sasl_success_handler = null;
    this._sasl_failure_handler = null;
    this._sasl_challenge_handler = null;

    // Max retries before disconnecting
    this.maxRetries = 5;

    // Call onIdle callback every 1/10th of a second
    // XXX: setTimeout should be called only with function expressions (23974bc1)
    this._idleTimeout = setTimeout(function() {
        this._onIdle();
    }.bind(this), 100);

    utils.addCookies(this.options.cookies);
    this.registerSASLMechanisms(this.options.mechanisms);

    // initialize plugins
    for (var k in Strophe._connectionPlugins) {
        if (Strophe._connectionPlugins.hasOwnProperty(k)) {
            var ptype = Strophe._connectionPlugins[k];
            // jslint complaints about the below line, but this is fine
            var F = function () {}; // jshint ignore:line
            F.prototype = ptype;
            this[k] = new F();
            this[k].init(this);
        }
    }
};

Strophe.Connection.prototype = {
    /** Function: reset
     *  Reset the connection.
     *
     *  This function should be called after a connection is disconnected
     *  before that connection is reused.
     */
    reset: function () {
        this._proto._reset();

        // SASL
        this.do_session = false;
        this.do_bind = false;

        // handler lists
        this.timedHandlers = [];
        this.handlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];

        this.authenticated = false;
        this.connected = false;
        this.disconnecting = false;
        this.restored = false;

        this._data = [];
        this._requests = [];
        this._uniqueId = 0;
    },

    /** Function: pause
     *  Pause the request manager.
     *
     *  This will prevent Strophe from sending any more requests to the
     *  server.  This is very useful for temporarily pausing
     *  BOSH-Connections while a lot of send() calls are happening quickly.
     *  This causes Strophe to send the data in a single request, saving
     *  many request trips.
     */
    pause: function () {
        this.paused = true;
    },

    /** Function: resume
     *  Resume the request manager.
     *
     *  This resumes after pause() has been called.
     */
    resume: function () {
        this.paused = false;
    },

    /** Function: getUniqueId
     *  Generate a unique ID for use in <iq/> elements.
     *
     *  All <iq/> stanzas are required to have unique id attributes.  This
     *  function makes creating these easy.  Each connection instance has
     *  a counter which starts from zero, and the value of this counter
     *  plus a colon followed by the suffix becomes the unique id. If no
     *  suffix is supplied, the counter is used as the unique id.
     *
     *  Suffixes are used to make debugging easier when reading the stream
     *  data, and their use is recommended.  The counter resets to 0 for
     *  every new connection for the same reason.  For connections to the
     *  same server that authenticate the same way, all the ids should be
     *  the same, which makes it easy to see changes.  This is useful for
     *  automated testing as well.
     *
     *  Parameters:
     *    (String) suffix - A optional suffix to append to the id.
     *
     *  Returns:
     *    A unique string to be used for the id attribute.
     */
    getUniqueId: function(suffix) {
        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0,
                v = c == 'x' ? r : r & 0x3 | 0x8;
            return v.toString(16);
        });
        if (typeof(suffix) == "string" || typeof(suffix) == "number") {
            return uuid + ":" + suffix;
        } else {
            return uuid + "";
        }
    },

    /** Function: addProtocolErrorHandler
     *  Register a handler function for when a protocol (websocker or HTTP)
     *  error occurs.
     *
     *  NOTE: Currently only HTTP errors for BOSH requests are handled.
     *  Patches that handle websocket errors would be very welcome.
     *
     *  Parameters:
     *    (String) protocol - 'HTTP' or 'websocket' 
     *    (Integer) status_code - Error status code (e.g 500, 400 or 404)
     *    (Function) callback - Function that will fire on Http error
     *
     *  Example:
     *  function onError(err_code){
     *    //do stuff
     *  }
     *
     *  var conn = Strophe.connect('http://example.com/http-bind');
     *  conn.addProtocolErrorHandler('HTTP', 500, onError);
     *  // Triggers HTTP 500 error and onError handler will be called
     *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);
     */
    addProtocolErrorHandler: function(protocol, status_code, callback){
        this.protocolErrorHandlers[protocol][status_code] = callback;
    },


    /** Function: connect
     *  Starts the connection process.
     *
     *  As the connection process proceeds, the user supplied callback will
     *  be triggered multiple times with status updates.  The callback
     *  should take two arguments - the status code and the error condition.
     *
     *  The status code will be one of the values in the Strophe.Status
     *  constants.  The error condition will be one of the conditions
     *  defined in RFC 3920 or the condition 'strophe-parsererror'.
     *
     *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant
     *  for BOSH connections. Please see XEP 124 for a more detailed explanation
     *  of the optional parameters.
     *
     *  Parameters:
     *    (String) jid - The user's JID.  This may be a bare JID,
     *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
     *      authentication will be attempted.
     *    (String) pass - The user's password.
     *    (Function) callback - The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (String) route - The optional route value.
     *    (String) authcid - The optional alternative authentication identity
     *      (username) if intending to impersonate another user.
     *      When using the SASL-EXTERNAL authentication mechanism, for example
     *      with client certificates, then the authcid value is used to
     *      determine whether an authorization JID (authzid) should be sent to
     *      the server. The authzid should not be sent to the server if the
     *      authzid and authcid are the same. So to prevent it from being sent
     *      (for example when the JID is already contained in the client
     *      certificate), set authcid to that same JID. See XEP-178 for more
     *      details.
     */
    connect: function (jid, pass, callback, wait, hold, route, authcid) {
        this.jid = jid;
        /** Variable: authzid
         *  Authorization identity.
         */
        this.authzid = Strophe.getBareJidFromJid(this.jid);

        /** Variable: authcid
         *  Authentication identity (User name).
         */
        this.authcid = authcid || Strophe.getNodeFromJid(this.jid);

        /** Variable: pass
         *  Authentication identity (User password).
         */
        this.pass = pass;

        /** Variable: servtype
         *  Digest MD5 compatibility.
         */
        this.servtype = "xmpp";

        this.connect_callback = callback;
        this.disconnecting = false;
        this.connected = false;
        this.authenticated = false;
        this.restored = false;

        // parse jid for domain
        this.domain = Strophe.getDomainFromJid(this.jid);

        this._changeConnectStatus(Strophe.Status.CONNECTING, null);

        this._proto._connect(wait, hold, route);
    },

    /** Function: attach
     *  Attach to an already created and authenticated BOSH session.
     *
     *  This function is provided to allow Strophe to attach to BOSH
     *  sessions which have been created externally, perhaps by a Web
     *  application.  This is often used to support auto-login type features
     *  without putting user credentials into the page.
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *    (String) sid - The SID of the BOSH session.
     *    (String) rid - The current RID of the BOSH session.  This RID
     *      will be used by the next request.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    attach: function (jid, sid, rid, callback, wait, hold, wind) {
        if (this._proto instanceof Strophe.Bosh) {
            this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
        } else {
            throw {
                name: 'StropheSessionError',
                message: 'The "attach" method can only be used with a BOSH connection.'
            };
        }
    },

    /** Function: restore
     *  Attempt to restore a cached BOSH session.
     *
     *  This function is only useful in conjunction with providing the
     *  "keepalive":true option when instantiating a new Strophe.Connection.
     *
     *  When "keepalive" is set to true, Strophe will cache the BOSH tokens
     *  RID (Request ID) and SID (Session ID) and then when this function is
     *  called, it will attempt to restore the session from those cached
     *  tokens.
     *
     *  This function must therefore be called instead of connect or attach.
     *
     *  For an example on how to use it, please see examples/restore.js
     *
     *  Parameters:
     *    (String) jid - The user's JID.  This may be a bare JID or a full JID.
     *    (Function) callback - The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    restore: function (jid, callback, wait, hold, wind) {
        if (this._sessionCachingSupported()) {
            this._proto._restore(jid, callback, wait, hold, wind);
        } else {
            throw {
                name: 'StropheSessionError',
                message: 'The "restore" method can only be used with a BOSH connection.'
            };
        }
    },

    /** PrivateFunction: _sessionCachingSupported
     * Checks whether sessionStorage and JSON are supported and whether we're
     * using BOSH.
     */
    _sessionCachingSupported: function () {
        if (this._proto instanceof Strophe.Bosh) {
            if (!JSON) { return false; }
            try {
                window.sessionStorage.setItem('_strophe_', '_strophe_');
                window.sessionStorage.removeItem('_strophe_');
            } catch (e) {
                return false;
            }
            return true;
        }
        return false;
    },

    /** Function: xmlInput
     *  User overrideable function that receives XML data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Due to limitations of current Browsers' XML-Parsers the opening and closing
     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
     *
     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
     *  <Strophe.Bosh.strip> if you want to strip this tag.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML data received by the connection.
     */
    /* jshint unused:false */
    xmlInput: function (elem) {
        return;
    },
    /* jshint unused:true */

    /** Function: xmlOutput
     *  User overrideable function that receives XML data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Due to limitations of current Browsers' XML-Parsers the opening and closing
     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
     *
     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
     *  <Strophe.Bosh.strip> if you want to strip this tag.
     *
     *  Parameters:
     *    (XMLElement) elem - The XMLdata sent by the connection.
     */
    /* jshint unused:false */
    xmlOutput: function (elem) {
        return;
    },
    /* jshint unused:true */

    /** Function: rawInput
     *  User overrideable function that receives raw data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data received by the connection.
     */
    /* jshint unused:false */
    rawInput: function (data) {
        return;
    },
    /* jshint unused:true */

    /** Function: rawOutput
     *  User overrideable function that receives raw data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data sent by the connection.
     */
    /* jshint unused:false */
    rawOutput: function (data) {
        return;
    },
    /* jshint unused:true */

    /** Function: nextValidRid
     *  User overrideable function that receives the new valid rid.
     *
     *  The default function does nothing. User code can override this with
     *  > Strophe.Connection.nextValidRid = function (rid) {
     *  >    (user code)
     *  > };
     *
     *  Parameters:
     *    (Number) rid - The next valid rid
     */
    /* jshint unused:false */
    nextValidRid: function (rid) {
        return;
    },
    /* jshint unused:true */

    /** Function: send
     *  Send a stanza.
     *
     *  This function is called to push data onto the send queue to
     *  go out over the wire.  Whenever a request is sent to the BOSH
     *  server, all pending data is sent and the queue is flushed.
     *
     *  Parameters:
     *    (XMLElement |
     *     [XMLElement] |
     *     Strophe.Builder) elem - The stanza to send.
     */
    send: function (elem) {
        if (elem === null) { return ; }
        if (typeof(elem.sort) === "function") {
            for (var i = 0; i < elem.length; i++) {
                this._queueData(elem[i]);
            }
        } else if (typeof(elem.tree) === "function") {
            this._queueData(elem.tree());
        } else {
            this._queueData(elem);
        }

        this._proto._send();
    },

    /** Function: flush
     *  Immediately send any pending outgoing data.
     *
     *  Normally send() queues outgoing data until the next idle period
     *  (100ms), which optimizes network use in the common cases when
     *  several send()s are called in succession. flush() can be used to
     *  immediately send all pending data.
     */
    flush: function () {
        // cancel the pending idle period and run the idle function
        // immediately
        clearTimeout(this._idleTimeout);
        this._onIdle();
    },

    /** Function: sendPresence
     *  Helper function to send presence stanzas. The main benefit is for
     *  sending presence stanzas for which you expect a responding presence
     *  stanza with the same id (for example when leaving a chat room).
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza to send.
     *    (Function) callback - The callback function for a successful request.
     *    (Function) errback - The callback function for a failed or timed
     *      out request.  On timeout, the stanza will be null.
     *    (Integer) timeout - The time specified in milliseconds for a
     *      timeout to occur.
     *
     *  Returns:
     *    The id used to send the presence.
     */
    sendPresence: function(elem, callback, errback, timeout) {
        var timeoutHandler = null;
        var that = this;
        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }
        var id = elem.getAttribute('id');
        if (!id) { // inject id if not found
            id = this.getUniqueId("sendPresence");
            elem.setAttribute("id", id);
        }

        if (typeof callback === "function" || typeof errback === "function") {
            var handler = this.addHandler(function (stanza) {
                // remove timeout handler if there is one
                if (timeoutHandler) {
                    that.deleteTimedHandler(timeoutHandler);
                }
                var type = stanza.getAttribute('type');
                if (type == 'error') {
                    if (errback) {
                        errback(stanza);
                    }
                } else if (callback) {
                    callback(stanza);
                }
            }, null, 'presence', null, id);

            // if timeout specified, set up a timeout handler.
            if (timeout) {
                timeoutHandler = this.addTimedHandler(timeout, function () {
                    // get rid of normal handler
                    that.deleteHandler(handler);
                    // call errback on timeout with null stanza
                    if (errback) {
                        errback(null);
                    }
                    return false;
                });
            }
        }
        this.send(elem);
        return id;
    },

    /** Function: sendIQ
     *  Helper function to send IQ stanzas.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza to send.
     *    (Function) callback - The callback function for a successful request.
     *    (Function) errback - The callback function for a failed or timed
     *      out request.  On timeout, the stanza will be null.
     *    (Integer) timeout - The time specified in milliseconds for a
     *      timeout to occur.
     *
     *  Returns:
     *    The id used to send the IQ.
    */
    sendIQ: function(elem, callback, errback, timeout) {
        var timeoutHandler = null;
        var that = this;
        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }
        var id = elem.getAttribute('id');
        if (!id) { // inject id if not found
            id = this.getUniqueId("sendIQ");
            elem.setAttribute("id", id);
        }

        if (typeof callback === "function" || typeof errback === "function") {
            var handler = this.addHandler(function (stanza) {
                // remove timeout handler if there is one
                if (timeoutHandler) {
                    that.deleteTimedHandler(timeoutHandler);
                }
                var iqtype = stanza.getAttribute('type');
                if (iqtype == 'result') {
                    if (callback) {
                        callback(stanza);
                    }
                } else if (iqtype == 'error') {
                    if (errback) {
                        errback(stanza);
                    }
                } else {
                    throw {
                        name: "StropheError",
                        message: "Got bad IQ type of " + iqtype
                    };
                }
            }, null, 'iq', ['error', 'result'], id);

            // if timeout specified, set up a timeout handler.
            if (timeout) {
                timeoutHandler = this.addTimedHandler(timeout, function () {
                    // get rid of normal handler
                    that.deleteHandler(handler);
                    // call errback on timeout with null stanza
                    if (errback) {
                        errback(null);
                    }
                    return false;
                });
            }
        }
        this.send(elem);
        return id;
    },

    /** PrivateFunction: _queueData
     *  Queue outgoing data for later sending.  Also ensures that the data
     *  is a DOMElement.
     */
    _queueData: function (element) {
        if (element === null ||
            !element.tagName ||
            !element.childNodes) {
            throw {
                name: "StropheError",
                message: "Cannot queue non-DOMElement."
            };
        }
        this._data.push(element);
    },

    /** PrivateFunction: _sendRestart
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function () {
        this._data.push("restart");
        this._proto._sendRestart();
        // XXX: setTimeout should be called only with function expressions (23974bc1)
        this._idleTimeout = setTimeout(function() {
            this._onIdle();
        }.bind(this), 100);
    },

    /** Function: addTimedHandler
     *  Add a timed handler to the connection.
     *
     *  This function adds a timed handler.  The provided handler will
     *  be called every period milliseconds until it returns false,
     *  the connection is terminated, or the handler is removed.  Handlers
     *  that wish to continue being invoked should return true.
     *
     *  Because of method binding it is necessary to save the result of
     *  this function if you wish to remove a handler with
     *  deleteTimedHandler().
     *
     *  Note that user handlers are not active until authentication is
     *  successful.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addTimedHandler: function (period, handler) {
        var thand = new Strophe.TimedHandler(period, handler);
        this.addTimeds.push(thand);
        return thand;
    },

    /** Function: deleteTimedHandler
     *  Delete a timed handler for a connection.
     *
     *  This function removes a timed handler from the connection.  The
     *  handRef parameter is *not* the function passed to addTimedHandler(),
     *  but is the reference returned from addTimedHandler().
     *
     *  Parameters:
     *    (Strophe.TimedHandler) handRef - The handler reference.
     */
    deleteTimedHandler: function (handRef) {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeTimeds.push(handRef);
    },

    /** Function: addHandler
     *  Add a stanza handler for the connection.
     *
     *  This function adds a stanza handler to the connection.  The
     *  handler callback will be called for any stanza that matches
     *  the parameters.  Note that if multiple parameters are supplied,
     *  they must all match for the handler to be invoked.
     *
     *  The handler will receive the stanza that triggered it as its argument.
     *  *The handler should return true if it is to be invoked again;
     *  returning false will remove the handler after it returns.*
     *
     *  As a convenience, the ns parameters applies to the top level element
     *  and also any of its immediate children.  This is primarily to make
     *  matching /iq/query elements easy.
     *
     *  Options
     *  ~~~~~~~
     *  With the options argument, you can specify boolean flags that affect how
     *  matches are being done.
     *
     *  Currently two flags exist:
     *
     *  - matchBareFromJid:
     *      When set to true, the from parameter and the
     *      from attribute on the stanza will be matched as bare JIDs instead
     *      of full JIDs. To use this, pass {matchBareFromJid: true} as the
     *      value of options. The default value for matchBareFromJid is false.
     *
     *  - ignoreNamespaceFragment:
     *      When set to true, a fragment specified on the stanza's namespace
     *      URL will be ignored when it's matched with the one configured for
     *      the handler.
     *
     *      This means that if you register like this:
     *      >   connection.addHandler(
     *      >       handler,
     *      >       'http://jabber.org/protocol/muc',
     *      >       null, null, null, null,
     *      >       {'ignoreNamespaceFragment': true}
     *      >   );
     *
     *      Then a stanza with XML namespace of
     *      'http://jabber.org/protocol/muc#user' will also be matched. If
     *      'ignoreNamespaceFragment' is false, then only stanzas with
     *      'http://jabber.org/protocol/muc' will be matched.
     *
     *  Deleting the handler
     *  ~~~~~~~~~~~~~~~~~~~~
     *  The return value should be saved if you wish to remove the handler
     *  with deleteHandler().
     *
     *  Parameters:
     *    (Function) handler - The user callback.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String|Array) type - The stanza type (or types if an array) to match.
     *    (String) id - The stanza id attribute to match.
     *    (String) from - The stanza from attribute to match.
     *    (String) options - The handler options
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addHandler: function (handler, ns, name, type, id, from, options) {
        var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
        this.addHandlers.push(hand);
        return hand;
    },

    /** Function: deleteHandler
     *  Delete a stanza handler for a connection.
     *
     *  This function removes a stanza handler from the connection.  The
     *  handRef parameter is *not* the function passed to addHandler(),
     *  but is the reference returned from addHandler().
     *
     *  Parameters:
     *    (Strophe.Handler) handRef - The handler reference.
     */
    deleteHandler: function (handRef) {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeHandlers.push(handRef);
        // If a handler is being deleted while it is being added,
        // prevent it from getting added
        var i = this.addHandlers.indexOf(handRef);
        if (i >= 0) {
            this.addHandlers.splice(i, 1);
        }
    },

    /** Function: registerSASLMechanisms
     *
     * Register the SASL mechanisms which will be supported by this instance of
     * Strophe.Connection (i.e. which this XMPP client will support).
     *
     *  Parameters:
     *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes
     *
     */
    registerSASLMechanisms: function (mechanisms) {
        this.mechanisms = {};
        mechanisms = mechanisms || [
            Strophe.SASLAnonymous,
            Strophe.SASLExternal,
            Strophe.SASLMD5,
            Strophe.SASLOAuthBearer,
            Strophe.SASLPlain,
            Strophe.SASLSHA1
        ];
        mechanisms.forEach(this.registerSASLMechanism.bind(this));
    },

    /** Function: registerSASLMechanism
     *
     * Register a single SASL mechanism, to be supported by this client.
     *
     *  Parameters:
     *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype
     *
     */
    registerSASLMechanism: function (mechanism) {
        this.mechanisms[mechanism.prototype.name] = mechanism;
    },

    /** Function: disconnect
     *  Start the graceful disconnection process.
     *
     *  This function starts the disconnection process.  This process starts
     *  by sending unavailable presence and sending BOSH body of type
     *  terminate.  A timeout handler makes sure that disconnection happens
     *  even if the BOSH server does not respond.
     *  If the Connection object isn't connected, at least tries to abort all pending requests
     *  so the connection object won't generate successful requests (which were already opened).
     *
     *  The user supplied connection callback will be notified of the
     *  progress as this process happens.
     *
     *  Parameters:
     *    (String) reason - The reason the disconnect is occuring.
     */
    disconnect: function (reason) {
        this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);

        Strophe.info("Disconnect was called because: " + reason);
        if (this.connected) {
            var pres = false;
            this.disconnecting = true;
            if (this.authenticated) {
                pres = $pres({
                    xmlns: Strophe.NS.CLIENT,
                    type: 'unavailable'
                });
            }
            // setup timeout handler
            this._disconnectTimeout = this._addSysTimedHandler(
                3000, this._onDisconnectTimeout.bind(this));
            this._proto._disconnect(pres);
        } else {
            Strophe.info("Disconnect was called before Strophe connected to the server");
            this._proto._abortAllRequests();
            this._doDisconnect();
        }
    },

    /** PrivateFunction: _changeConnectStatus
     *  _Private_ helper function that makes sure plugins and the user's
     *  callback are notified of connection status changes.
     *
     *  Parameters:
     *    (Integer) status - the new connection status, one of the values
     *      in Strophe.Status
     *    (String) condition - the error condition or null
     */
    _changeConnectStatus: function (status, condition) {
        // notify all plugins listening for status changes
        for (var k in Strophe._connectionPlugins) {
            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                var plugin = this[k];
                if (plugin.statusChanged) {
                    try {
                        plugin.statusChanged(status, condition);
                    } catch (err) {
                        Strophe.error("" + k + " plugin caused an exception " +
                                      "changing status: " + err);
                    }
                }
            }
        }

        // notify the user's callback
        if (this.connect_callback) {
            try {
                this.connect_callback(status, condition);
            } catch (e) {
                Strophe._handleError(e);
                Strophe.error(
                    "User connection callback caused an "+"exception: "+e);
            }
        }
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  This is the last piece of the disconnection logic.  This resets the
     *  connection and alerts the user's connection callback.
     */
    _doDisconnect: function (condition) {
        if (typeof this._idleTimeout == "number") {
            clearTimeout(this._idleTimeout);
        }

        // Cancel Disconnect Timeout
        if (this._disconnectTimeout !== null) {
            this.deleteTimedHandler(this._disconnectTimeout);
            this._disconnectTimeout = null;
        }

        Strophe.info("_doDisconnect was called");
        this._proto._doDisconnect();

        this.authenticated = false;
        this.disconnecting = false;
        this.restored = false;

        // delete handlers
        this.handlers = [];
        this.timedHandlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];

        // tell the parent we disconnected
        this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);
        this.connected = false;
    },

    /** PrivateFunction: _dataRecv
     *  _Private_ handler to processes incoming data from the the connection.
     *
     *  Except for _connect_cb handling the initial connection request,
     *  this function handles the incoming data for all requests.  This
     *  function also fires stanza handlers that match each incoming
     *  stanza.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request that has data ready.
     *    (string) req - The stanza a raw string (optiona).
     */
    _dataRecv: function (req, raw) {
        Strophe.info("_dataRecv called");
        var elem = this._proto._reqToData(req);
        if (elem === null) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
                this.xmlInput(elem.childNodes[0]);
            } else {
                this.xmlInput(elem);
            }
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            if (raw) {
                this.rawInput(raw);
            } else {
                this.rawInput(Strophe.serialize(elem));
            }
        }

        // remove handlers scheduled for deletion
        var i, hand;
        while (this.removeHandlers.length > 0) {
            hand = this.removeHandlers.pop();
            i = this.handlers.indexOf(hand);
            if (i >= 0) {
                this.handlers.splice(i, 1);
            }
        }

        // add handlers scheduled for addition
        while (this.addHandlers.length > 0) {
            this.handlers.push(this.addHandlers.pop());
        }

        // handle graceful disconnect
        if (this.disconnecting && this._proto._emptyQueue()) {
            this._doDisconnect();
            return;
        }

        var type = elem.getAttribute("type");
        var cond, conflict;
        if (type !== null && type == "terminate") {
            // Don't process stanzas that come in after disconnect
            if (this.disconnecting) {
                return;
            }

            // an error occurred
            cond = elem.getAttribute("condition");
            conflict = elem.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            this._doDisconnect(cond);
            return;
        }

  //Handling conflict error steam.
var errors = elem.getElementsByTagName("stream:error");
if (errors.length > 0) {
    if (this.disconnecting) {
        return;
    }

    var error = errors[0];
    for (var i = 0; i < error.childNodes.length; i++) {
      var e= error.childNodes[i];
        if (e.nodeName == "conflict"){
            this._doDisconnect(e.nodeName);
            return;}
    }

}

        // send each incoming stanza through the handler chain
        var that = this;
        Strophe.forEachChild(elem, null, function (child) {
            var i, newList;
            // process handlers
            newList = that.handlers;
            that.handlers = [];
            for (i = 0; i < newList.length; i++) {
                var hand = newList[i];
                // encapsulate 'handler.run' not to lose the whole handler list if
                // one of the handlers throws an exception
                try {
                    if (hand.isMatch(child) &&
                        (that.authenticated || !hand.user)) {
                        if (hand.run(child)) {
                            that.handlers.push(hand);
                        }
                    } else {
                        that.handlers.push(hand);
                    }
                } catch(e) {
                    // if the handler throws an exception, we consider it as false
                    Strophe.warn('Removing Strophe handlers due to uncaught exception: '+e.message);
                }
            }
        });
    },


    /** Attribute: mechanisms
     *  SASL Mechanisms available for Connection.
     */
    mechanisms: {},

    /** PrivateFunction: _connect_cb
     *  _Private_ handler for initial connection request.
     *
     *  This handler is used to process the initial connection request
     *  response from the BOSH server. It is used to set up authentication
     *  handlers and start the authentication process.
     *
     *  SASL authentication will be attempted if available, otherwise
     *  the code will fall back to legacy authentication.
     *
     *  Parameters:
     *    (Strophe.Request) req - The current request.
     *    (Function) _callback - low level (xmpp) connect callback function.
     *      Useful for plugins with their own xmpp connect callback (when their)
     *      want to do something special).
     */
    _connect_cb: function (req, _callback, raw) {
        Strophe.info("_connect_cb was called");
        this.connected = true;

        var bodyWrap;
        try {
            bodyWrap = this._proto._reqToData(req);
        } catch (e) {
            if (e != "badformat") { throw e; }
            this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');
            this._doDisconnect('bad-format');
        }
        if (!bodyWrap) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
                this.xmlInput(bodyWrap.childNodes[0]);
            } else {
                this.xmlInput(bodyWrap);
            }
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            if (raw) {
                this.rawInput(raw);
            } else {
                this.rawInput(Strophe.serialize(bodyWrap));
            }
        }

        var conncheck = this._proto._connect_cb(bodyWrap);
        if (conncheck === Strophe.Status.CONNFAIL) {
            return;
        }

        // Check for the stream:features tag
        var hasFeatures;
        if (bodyWrap.getElementsByTagNameNS) {
            hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "features").length > 0;
        } else {
            hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 ||
                            bodyWrap.getElementsByTagName("features").length > 0;
        }
        if (!hasFeatures) {
            this._proto._no_auth_received(_callback);
            return;
        }

        var matched = [], i, mech;
        var mechanisms = bodyWrap.getElementsByTagName("mechanism");
        if (mechanisms.length > 0) {
            for (i = 0; i < mechanisms.length; i++) {
                mech = Strophe.getText(mechanisms[i]);
                if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);
            }
        }
        if (matched.length === 0) {
            if (bodyWrap.getElementsByTagName("auth").length === 0) {
                // There are no matching SASL mechanisms and also no legacy
                // auth available.
                this._proto._no_auth_received(_callback);
                return;
            }
        }
        if (this.do_authentication !== false) {
            this.authenticate(matched);
        }
    },

    /** Function: sortMechanismsByPriority
     *
     *  Sorts an array of objects with prototype SASLMechanism according to
     *  their priorities.
     *
     *  Parameters:
     *    (Array) mechanisms - Array of SASL mechanisms.
     *
     */
    sortMechanismsByPriority: function (mechanisms) {
        // Sorting mechanisms according to priority.
        var i, j, higher, swap;
        for (i = 0; i < mechanisms.length - 1; ++i) {
            higher = i;
            for (j = i + 1; j < mechanisms.length; ++j) {
                if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {
                    higher = j;
                }
            }
            if (higher != i) {
                swap = mechanisms[i];
                mechanisms[i] = mechanisms[higher];
                mechanisms[higher] = swap;
            }
        }
        return mechanisms;
    },

    /** PrivateFunction: _attemptSASLAuth
     *
     *  Iterate through an array of SASL mechanisms and attempt authentication
     *  with the highest priority (enabled) mechanism.
     *
     *  Parameters:
     *    (Array) mechanisms - Array of SASL mechanisms.
     *
     *  Returns:
     *    (Boolean) mechanism_found - true or false, depending on whether a
     *          valid SASL mechanism was found with which authentication could be
     *          started.
     */
    _attemptSASLAuth: function (mechanisms) {
        mechanisms = this.sortMechanismsByPriority(mechanisms || []);
        var i = 0, mechanism_found = false;
        for (i = 0; i < mechanisms.length; ++i) {
            if (!mechanisms[i].prototype.test(this)) {
                continue;
            }
            this._sasl_success_handler = this._addSysHandler(
                this._sasl_success_cb.bind(this), null,
                "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);
            this._sasl_challenge_handler = this._addSysHandler(
                this._sasl_challenge_cb.bind(this), null,
                "challenge", null, null);

            this._sasl_mechanism = new mechanisms[i]();
            this._sasl_mechanism.onStart(this);

            var request_auth_exchange = $build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: this._sasl_mechanism.name
            });
            if (this._sasl_mechanism.isClientFirst) {
                var response = this._sasl_mechanism.onChallenge(this, null);
                request_auth_exchange.t(Base64.encode(response));
            }
            this.send(request_auth_exchange.tree());
            mechanism_found = true;
            break;
        }
        return mechanism_found;
    },

    /** PrivateFunction: _attemptLegacyAuth
     *
     *  Attempt legacy (i.e. non-SASL) authentication.
     *
     */
    _attemptLegacyAuth: function () {
        if (Strophe.getNodeFromJid(this.jid) === null) {
            // we don't have a node, which is required for non-anonymous
            // client connections
            this._changeConnectStatus(
                Strophe.Status.CONNFAIL,
                'x-strophe-bad-non-anon-jid'
            );
            this.disconnect('x-strophe-bad-non-anon-jid');
        } else {
            // Fall back to legacy authentication
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._addSysHandler(
                this._auth1_cb.bind(this),
                null, null, null, "_auth_1"
            );
            this.send($iq({
                    'type': "get",
                    'to': this.domain,
                    'id': "_auth_1"
                }).c("query", {xmlns: Strophe.NS.AUTH})
                .c("username", {}).t(Strophe.getNodeFromJid(this.jid))
                .tree());
        }
    },

    /** Function: authenticate
     * Set up authentication
     *
     *  Continues the initial connection request by setting up authentication
     *  handlers and starting the authentication process.
     *
     *  SASL authentication will be attempted if available, otherwise
     *  the code will fall back to legacy authentication.
     *
     *  Parameters:
     *    (Array) matched - Array of SASL mechanisms supported.
     *
     */
    authenticate: function (matched) {
        if (!this._attemptSASLAuth(matched)) {
            this._attemptLegacyAuth();
        }
    },

    /** PrivateFunction: _sasl_challenge_cb
     *  _Private_ handler for the SASL challenge
     *
     */
    _sasl_challenge_cb: function(elem) {
      var challenge = Base64.decode(Strophe.getText(elem));
      var response = this._sasl_mechanism.onChallenge(this, challenge);
      var stanza = $build('response', {
          'xmlns': Strophe.NS.SASL
      });
      if (response !== "") {
        stanza.t(Base64.encode(response));
      }
      this.send(stanza.tree());
      return true;
    },

    /** PrivateFunction: _auth1_cb
     *  _Private_ handler for legacy authentication.
     *
     *  This handler is called in response to the initial <iq type='get'/>
     *  for legacy authentication.  It builds an authentication <iq/> and
     *  sends it, creating a handler (calling back to _auth2_cb()) to
     *  handle the result
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    /* jshint unused:false */
    _auth1_cb: function (elem) {
        // build plaintext auth iq
        var iq = $iq({type: "set", id: "_auth_2"})
            .c('query', {xmlns: Strophe.NS.AUTH})
            .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
            .up()
            .c('password').t(this.pass);

        if (!Strophe.getResourceFromJid(this.jid)) {
            // since the user has not supplied a resource, we pick
            // a default one here.  unlike other auth methods, the server
            // cannot do this for us.
            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
        }
        iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

        this._addSysHandler(this._auth2_cb.bind(this), null,
                            null, null, "_auth_2");
        this.send(iq.tree());
        return false;
    },
    /* jshint unused:true */

    /** PrivateFunction: _sasl_success_cb
     *  _Private_ handler for succesful SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_success_cb: function (elem) {
        if (this._sasl_data["server-signature"]) {
            var serverSignature;
            var success = Base64.decode(Strophe.getText(elem));
            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
            var matches = success.match(attribMatch);
            if (matches[1] == "v") {
                serverSignature = matches[2];
            }

            if (serverSignature != this._sasl_data["server-signature"]) {
              // remove old handlers
              this.deleteHandler(this._sasl_failure_handler);
              this._sasl_failure_handler = null;
              if (this._sasl_challenge_handler) {
                this.deleteHandler(this._sasl_challenge_handler);
                this._sasl_challenge_handler = null;
              }

              this._sasl_data = {};
              return this._sasl_failure_cb(null);
            }
        }
        Strophe.info("SASL authentication succeeded.");

        if (this._sasl_mechanism) {
          this._sasl_mechanism.onSuccess();
        }

        // remove old handlers
        this.deleteHandler(this._sasl_failure_handler);
        this._sasl_failure_handler = null;
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        var streamfeature_handlers = [];
        var wrapper = function(handlers, elem) {
            while (handlers.length) {
                this.deleteHandler(handlers.pop());
            }
            this._sasl_auth1_cb.bind(this)(elem);
            return false;
        };
        streamfeature_handlers.push(this._addSysHandler(function(elem) {
            wrapper.bind(this)(streamfeature_handlers, elem);
        }.bind(this), null, "stream:features", null, null));
        streamfeature_handlers.push(this._addSysHandler(function(elem) {
            wrapper.bind(this)(streamfeature_handlers, elem);
        }.bind(this), Strophe.NS.STREAM, "features", null, null));

        // we must send an xmpp:restart now
        this._sendRestart();

        return false;
    },

    /** PrivateFunction: _sasl_auth1_cb
     *  _Private_ handler to start stream binding.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_auth1_cb: function (elem) {
        // save stream:features for future usage
        this.features = elem;
        var i, child;
        for (i = 0; i < elem.childNodes.length; i++) {
            child = elem.childNodes[i];
            if (child.nodeName == 'bind') {
                this.do_bind = true;
            }

            if (child.nodeName == 'session') {
                this.do_session = true;
            }
        }

        if (!this.do_bind) {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        } else {
            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,
                                null, "_bind_auth_2");

            var resource = Strophe.getResourceFromJid(this.jid);
            if (resource) {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .c('resource', {}).t(resource).tree());
            } else {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .tree());
            }
        }
        return false;
    },

    /** PrivateFunction: _sasl_bind_cb
     *  _Private_ handler for binding result and session start.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_bind_cb: function (elem) {
        if (elem.getAttribute("type") == "error") {
            Strophe.info("SASL binding failed.");
            var conflict = elem.getElementsByTagName("conflict"), condition;
            if (conflict.length > 0) {
                condition = 'conflict';
            }
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
            return false;
        }

        // TODO - need to grab errors
        var bind = elem.getElementsByTagName("bind");
        var jidNode;
        if (bind.length > 0) {
            // Grab jid
            jidNode = bind[0].getElementsByTagName("jid");
            if (jidNode.length > 0) {
                this.jid = Strophe.getText(jidNode[0]);

                if (this.do_session) {
                    this._addSysHandler(this._sasl_session_cb.bind(this),
                                        null, null, null, "_session_auth_2");

                    this.send($iq({type: "set", id: "_session_auth_2"})
                                  .c('session', {xmlns: Strophe.NS.SESSION})
                                  .tree());
                } else {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                }
            }
        } else {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }
    },

    /** PrivateFunction: _sasl_session_cb
     *  _Private_ handler to finish successful SASL connection.
     *
     *  This sets Connection.authenticated to true on success, which
     *  starts the processing of user handlers.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_session_cb: function (elem) {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            Strophe.info("Session creation failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }
        return false;
    },

    /** PrivateFunction: _sasl_failure_cb
     *  _Private_ handler for SASL authentication failure.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    /* jshint unused:false */
    _sasl_failure_cb: function (elem) {
        // delete unneeded handlers
        if (this._sasl_success_handler) {
            this.deleteHandler(this._sasl_success_handler);
            this._sasl_success_handler = null;
        }
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        if(this._sasl_mechanism)
          this._sasl_mechanism.onFailure();
        this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
        return false;
    },
    /* jshint unused:true */

    /** PrivateFunction: _auth2_cb
     *  _Private_ handler to finish legacy authentication.
     *
     *  This handler is called when the result from the jabber:iq:auth
     *  <iq/> stanza is returned.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _auth2_cb: function (elem) {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            this.disconnect('authentication failed');
        }
        return false;
    },

    /** PrivateFunction: _addSysTimedHandler
     *  _Private_ function to add a system level timed handler.
     *
     *  This function is used to add a Strophe.TimedHandler for the
     *  library code.  System timed handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     */
    _addSysTimedHandler: function (period, handler) {
        var thand = new Strophe.TimedHandler(period, handler);
        thand.user = false;
        this.addTimeds.push(thand);
        return thand;
    },

    /** PrivateFunction: _addSysHandler
     *  _Private_ function to add a system level stanza handler.
     *
     *  This function is used to add a Strophe.Handler for the
     *  library code.  System stanza handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Function) handler - The callback function.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String) type - The stanza type attribute to match.
     *    (String) id - The stanza id attribute to match.
     */
    _addSysHandler: function (handler, ns, name, type, id) {
        var hand = new Strophe.Handler(handler, ns, name, type, id);
        hand.user = false;
        this.addHandlers.push(hand);
        return hand;
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  If the graceful disconnect process does not complete within the
     *  time allotted, this handler finishes the disconnect anyway.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _onDisconnectTimeout: function () {
        Strophe.info("_onDisconnectTimeout was called");
        this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);
        this._proto._onDisconnectTimeout();
        // actually disconnect
        this._doDisconnect();
        return false;
    },

    /** PrivateFunction: _onIdle
     *  _Private_ handler to process events during idle cycle.
     *
     *  This handler is called every 100ms to fire timed handlers that
     *  are ready and keep poll requests going.
     */
    _onIdle: function () {
        var i, thand, since, newList;

        // add timed handlers scheduled for addition
        // NOTE: we add before remove in the case a timed handler is
        // added and then deleted before the next _onIdle() call.
        while (this.addTimeds.length > 0) {
            this.timedHandlers.push(this.addTimeds.pop());
        }

        // remove timed handlers that have been scheduled for deletion
        while (this.removeTimeds.length > 0) {
            thand = this.removeTimeds.pop();
            i = this.timedHandlers.indexOf(thand);
            if (i >= 0) {
                this.timedHandlers.splice(i, 1);
            }
        }

        // call ready timed handlers
        var now = new Date().getTime();
        newList = [];
        for (i = 0; i < this.timedHandlers.length; i++) {
            thand = this.timedHandlers[i];
            if (this.authenticated || !thand.user) {
                since = thand.lastCalled + thand.period;
                if (since - now <= 0) {
                    if (thand.run()) {
                        newList.push(thand);
                    }
                } else {
                    newList.push(thand);
                }
            }
        }
        this.timedHandlers = newList;

        clearTimeout(this._idleTimeout);

        this._proto._onIdle();

        // reactivate the timer only if connected
        if (this.connected) {
            // XXX: setTimeout should be called only with function expressions (23974bc1)
            this._idleTimeout = setTimeout(function() {
                this._onIdle();
            }.bind(this), 100);
        }
    }
};

/** Class: Strophe.SASLMechanism
 *
 *  encapsulates SASL authentication mechanisms.
 *
 *  User code may override the priority for each mechanism or disable it completely.
 *  See <priority> for information about changing priority and <test> for informatian on
 *  how to disable a mechanism.
 *
 *  By default, all mechanisms are enabled and the priorities are
 *
 *  EXTERNAL - 60
 *  OAUTHBEARER - 50
 *  SCRAM-SHA1 - 40
 *  DIGEST-MD5 - 30
 *  PLAIN - 20
 *  ANONYMOUS - 10
 *
 *  See: Strophe.Connection.addSupportedSASLMechanisms
 */

/**
 * PrivateConstructor: Strophe.SASLMechanism
 * SASL auth mechanism abstraction.
 *
 *  Parameters:
 *    (String) name - SASL Mechanism name.
 *    (Boolean) isClientFirst - If client should send response first without challenge.
 *    (Number) priority - Priority.
 *
 *  Returns:
 *    A new Strophe.SASLMechanism object.
 */
Strophe.SASLMechanism = function(name, isClientFirst, priority) {
  /** PrivateVariable: name
   *  Mechanism name.
   */
  this.name = name;
  /** PrivateVariable: isClientFirst
   *  If client sends response without initial server challenge.
   */
  this.isClientFirst = isClientFirst;
  /** Variable: priority
   *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).
   *  Users may override this to prioritize mechanisms differently.
   *
   *  In the default configuration the priorities are
   *
   *  SCRAM-SHA1 - 40
   *  DIGEST-MD5 - 30
   *  Plain - 20
   *
   *  Example: (This will cause Strophe to choose the mechanism that the server sent first)
   *
   *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;
   *
   *  See <SASL mechanisms> for a list of available mechanisms.
   *
   */
  this.priority = priority;
};

Strophe.SASLMechanism.prototype = {
  /**
   *  Function: test
   *  Checks if mechanism able to run.
   *  To disable a mechanism, make this return false;
   *
   *  To disable plain authentication run
   *  > Strophe.SASLPlain.test = function() {
   *  >   return false;
   *  > }
   *
   *  See <SASL mechanisms> for a list of available mechanisms.
   *
   *  Parameters:
   *    (Strophe.Connection) connection - Target Connection.
   *
   *  Returns:
   *    (Boolean) If mechanism was able to run.
   */
  /* jshint unused:false */
  test: function(connection) {
    return true;
  },
  /* jshint unused:true */

  /** PrivateFunction: onStart
   *  Called before starting mechanism on some connection.
   *
   *  Parameters:
   *    (Strophe.Connection) connection - Target Connection.
   */
  onStart: function(connection) {
    this._connection = connection;
  },

  /** PrivateFunction: onChallenge
   *  Called by protocol implementation on incoming challenge. If client is
   *  first (isClientFirst == true) challenge will be null on the first call.
   *
   *  Parameters:
   *    (Strophe.Connection) connection - Target Connection.
   *    (String) challenge - current challenge to handle.
   *
   *  Returns:
   *    (String) Mechanism response.
   */
  /* jshint unused:false */
  onChallenge: function(connection, challenge) {
    throw new Error("You should implement challenge handling!");
  },
  /* jshint unused:true */

  /** PrivateFunction: onFailure
   *  Protocol informs mechanism implementation about SASL failure.
   */
  onFailure: function() {
    this._connection = null;
  },

  /** PrivateFunction: onSuccess
   *  Protocol informs mechanism implementation about SASL success.
   */
  onSuccess: function() {
    this._connection = null;
  }
};

  /** Constants: SASL mechanisms
   *  Available authentication mechanisms
   *
   *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.
   *  Strophe.SASLPlain - SASL PLAIN authentication.
   *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication
   *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication
   *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication
   *  Strophe.SASLExternal - SASL EXTERNAL authentication
   */

// Building SASL callbacks

/** PrivateConstructor: SASLAnonymous
 *  SASL ANONYMOUS authentication.
 */
Strophe.SASLAnonymous = function() {};
Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 20);

Strophe.SASLAnonymous.prototype.test = function(connection) {
    return connection.authcid === null;
};


/** PrivateConstructor: SASLPlain
 *  SASL PLAIN authentication.
 */
Strophe.SASLPlain = function() {};
Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 30);

Strophe.SASLPlain.prototype.test = function(connection) {
    return connection.authcid !== null;
};

Strophe.SASLPlain.prototype.onChallenge = function(connection) {
    var auth_str = connection.authzid;
    auth_str = auth_str + "\u0000";
    auth_str = auth_str + connection.authcid;
    auth_str = auth_str + "\u0000";
    auth_str = auth_str + connection.pass;
    return utils.utf16to8(auth_str);
};


/** PrivateConstructor: SASLSHA1
 *  SASL SCRAM SHA 1 authentication.
 */
Strophe.SASLSHA1 = function() {};
Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 50);

Strophe.SASLSHA1.prototype.test = function(connection) {
    return connection.authcid !== null;
};

Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
  var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);
  var auth_str = "n=" + utils.utf16to8(connection.authcid);
  auth_str += ",r=";
  auth_str += cnonce;
  connection._sasl_data.cnonce = cnonce;
  connection._sasl_data["client-first-message-bare"] = auth_str;

  auth_str = "n,," + auth_str;

  this.onChallenge = function (connection, challenge) {
    var nonce, salt, iter, Hi, U, U_old, i, k, pass;
    var clientKey, serverKey, clientSignature;
    var responseText = "c=biws,";
    var authMessage = connection._sasl_data["client-first-message-bare"] + "," +
      challenge + ",";
    var cnonce = connection._sasl_data.cnonce;
    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;

    while (challenge.match(attribMatch)) {
      var matches = challenge.match(attribMatch);
      challenge = challenge.replace(matches[0], "");
      switch (matches[1]) {
      case "r":
        nonce = matches[2];
        break;
      case "s":
        salt = matches[2];
        break;
      case "i":
        iter = matches[2];
        break;
      }
    }

    if (nonce.substr(0, cnonce.length) !== cnonce) {
      connection._sasl_data = {};
      return connection._sasl_failure_cb();
    }

    responseText += "r=" + nonce;
    authMessage += responseText;

    salt = Base64.decode(salt);
    salt += "\x00\x00\x00\x01";

    pass = utils.utf16to8(connection.pass);
    Hi = U_old = SHA1.core_hmac_sha1(pass, salt);
    for (i = 1; i < iter; i++) {
      U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));
      for (k = 0; k < 5; k++) {
        Hi[k] ^= U[k];
      }
      U_old = U;
    }
    Hi = SHA1.binb2str(Hi);

    clientKey = SHA1.core_hmac_sha1(Hi, "Client Key");
    serverKey = SHA1.str_hmac_sha1(Hi, "Server Key");
    clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);
    connection._sasl_data["server-signature"] = SHA1.b64_hmac_sha1(serverKey, authMessage);

    for (k = 0; k < 5; k++) {
      clientKey[k] ^= clientSignature[k];
    }

    responseText += ",p=" + Base64.encode(SHA1.binb2str(clientKey));
    return responseText;
  }.bind(this);

  return auth_str;
};


/** PrivateConstructor: SASLMD5
 *  SASL DIGEST MD5 authentication.
 */
Strophe.SASLMD5 = function() {};
Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 40);

Strophe.SASLMD5.prototype.test = function(connection) {
    return connection.authcid !== null;
};

/** PrivateFunction: _quote
 *  _Private_ utility function to backslash escape and quote strings.
 *
 *  Parameters:
 *    (String) str - The string to be quoted.
 *
 *  Returns:
 *    quoted string
 */
Strophe.SASLMD5.prototype._quote = function (str) {
    return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
    //" end string workaround for emacs
};

Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
  var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
  var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
  var realm = "";
  var host = null;
  var nonce = "";
  var qop = "";
  var matches;

  while (challenge.match(attribMatch)) {
    matches = challenge.match(attribMatch);
    challenge = challenge.replace(matches[0], "");
    matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
    switch (matches[1]) {
    case "realm":
      realm = matches[2];
      break;
    case "nonce":
      nonce = matches[2];
      break;
    case "qop":
      qop = matches[2];
      break;
    case "host":
      host = matches[2];
      break;
    }
  }

  var digest_uri = connection.servtype + "/" + connection.domain;
  if (host !== null) {
    digest_uri = digest_uri + "/" + host;
  }

  var cred = utils.utf16to8(connection.authcid + ":" + realm + ":" + this._connection.pass);
  var A1 = MD5.hash(cred) + ":" + nonce + ":" + cnonce;
  var A2 = 'AUTHENTICATE:' + digest_uri;

  var responseText = "";
  responseText += 'charset=utf-8,';
  responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';
  responseText += 'realm=' + this._quote(realm) + ',';
  responseText += 'nonce=' + this._quote(nonce) + ',';
  responseText += 'nc=00000001,';
  responseText += 'cnonce=' + this._quote(cnonce) + ',';
  responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
  responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + ":" +
                                              nonce + ":00000001:" +
                                              cnonce + ":auth:" +
                                              MD5.hexdigest(A2)) + ",";
  responseText += 'qop=auth';

  this.onChallenge = function () {
      return "";
  };
  return responseText;
};


/** PrivateConstructor: SASLOAuthBearer
 *  SASL OAuth Bearer authentication.
 */
Strophe.SASLOAuthBearer = function() {};
Strophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism("OAUTHBEARER", true, 60);

Strophe.SASLOAuthBearer.prototype.test = function(connection) {
    return connection.authcid !== null;
};

Strophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {
    var auth_str = 'n,a=';
    auth_str = auth_str + connection.authzid;
    auth_str = auth_str + ',';
    auth_str = auth_str + "\u0001";
    auth_str = auth_str + 'auth=Bearer ';
    auth_str = auth_str + connection.pass;
    auth_str = auth_str + "\u0001";
    auth_str = auth_str + "\u0001";
    return utils.utf16to8(auth_str);
};


/** PrivateConstructor: SASLExternal
 *  SASL EXTERNAL authentication.
 *
 *  The EXTERNAL mechanism allows a client to request the server to use
 *  credentials established by means external to the mechanism to
 *  authenticate the client. The external means may be, for instance,
 *  TLS services.
 */
Strophe.SASLExternal = function() {};
Strophe.SASLExternal.prototype = new Strophe.SASLMechanism("EXTERNAL", true, 10);

Strophe.SASLExternal.prototype.onChallenge = function(connection) {
    /** According to XEP-178, an authzid SHOULD NOT be presented when the
     * authcid contained or implied in the client certificate is the JID (i.e.
     * authzid) with which the user wants to log in as.
     *
     * To NOT send the authzid, the user should therefore set the authcid equal
     * to the JID when instantiating a new Strophe.Connection object.
     */
    return connection.authcid === connection.authzid ? '' : connection.authzid;
};

return {
    Strophe:        Strophe,
    $build:         $build,
    $msg:           $msg,
    $iq:            $iq,
    $pres:          $pres,
    SHA1:           SHA1,
    Base64:         Base64,
    MD5:            MD5,
};
}));

/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-bosh', ['strophe-core'], function (core) {
            return factory(
                core.Strophe,
                core.$build
            );
        });
    } else {
        // Browser globals
        return factory(Strophe, $build);
    }
}(this, function (Strophe, $build) {

/** PrivateClass: Strophe.Request
 *  _Private_ helper class that provides a cross implementation abstraction
 *  for a BOSH related XMLHttpRequest.
 *
 *  The Strophe.Request class is used internally to encapsulate BOSH request
 *  information.  It is not meant to be used from user's code.
 */

/** PrivateConstructor: Strophe.Request
 *  Create and initialize a new Strophe.Request object.
 *
 *  Parameters:
 *    (XMLElement) elem - The XML data to be sent in the request.
 *    (Function) func - The function that will be called when the
 *      XMLHttpRequest readyState changes.
 *    (Integer) rid - The BOSH rid attribute associated with this request.
 *    (Integer) sends - The number of times this same request has been sent.
 */
Strophe.Request = function (elem, func, rid, sends) {
    this.id = ++Strophe._requestId;
    this.xmlData = elem;
    this.data = Strophe.serialize(elem);
    // save original function in case we need to make a new request
    // from this one.
    this.origFunc = func;
    this.func = func;
    this.rid = rid;
    this.date = NaN;
    this.sends = sends || 0;
    this.abort = false;
    this.dead = null;

    this.age = function () {
        if (!this.date) { return 0; }
        var now = new Date();
        return (now - this.date) / 1000;
    };
    this.timeDead = function () {
        if (!this.dead) { return 0; }
        var now = new Date();
        return (now - this.dead) / 1000;
    };
    this.xhr = this._newXHR();
};

Strophe.Request.prototype = {
    /** PrivateFunction: getResponse
     *  Get a response from the underlying XMLHttpRequest.
     *
     *  This function attempts to get a response from the request and checks
     *  for errors.
     *
     *  Throws:
     *    "parsererror" - A parser error occured.
     *    "badformat" - The entity has sent XML that cannot be processed.
     *
     *  Returns:
     *    The DOM element tree of the response.
     */
    getResponse: function () {
        var node = null;
        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
            node = this.xhr.responseXML.documentElement;
            if (node.tagName == "parsererror") {
                Strophe.error("invalid response received");
                Strophe.error("responseText: " + this.xhr.responseText);
                Strophe.error("responseXML: " +
                              Strophe.serialize(this.xhr.responseXML));
                throw "parsererror";
            }
        } else if (this.xhr.responseText) {
            Strophe.error("invalid response received");
            Strophe.error("responseText: " + this.xhr.responseText);
            throw "badformat";
        }

        return node;
    },

    /** PrivateFunction: _newXHR
     *  _Private_ helper function to create XMLHttpRequests.
     *
     *  This function creates XMLHttpRequests across all implementations.
     *
     *  Returns:
     *    A new XMLHttpRequest.
     */
    _newXHR: function () {
        var xhr = null;
        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
            if (xhr.overrideMimeType) {
                xhr.overrideMimeType("text/xml; charset=utf-8");
            }
        } else if (window.ActiveXObject) {
            xhr = new ActiveXObject("Microsoft.XMLHTTP");
        }
        // use Function.bind() to prepend ourselves as an argument
        xhr.onreadystatechange = this.func.bind(null, this);
        return xhr;
    }
};

/** Class: Strophe.Bosh
 *  _Private_ helper class that handles BOSH Connections
 *
 *  The Strophe.Bosh class is used internally by Strophe.Connection
 *  to encapsulate BOSH sessions. It is not meant to be used from user's code.
 */

/** File: bosh.js
 *  A JavaScript library to enable BOSH in Strophejs.
 *
 *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)
 *  to emulate a persistent, stateful, two-way connection to an XMPP server.
 *  More information on BOSH can be found in XEP 124.
 */

/** PrivateConstructor: Strophe.Bosh
 *  Create and initialize a Strophe.Bosh object.
 *
 *  Parameters:
 *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.
 *
 *  Returns:
 *    A new Strophe.Bosh object.
 */
Strophe.Bosh = function(connection) {
    this._conn = connection;
    /* request id for body tags */
    this.rid = Math.floor(Math.random() * 4294967295);
    /* The current session ID. */
    this.sid = null;

    // default BOSH values
    this.hold = 1;
    this.wait = 60;
    this.window = 5;
    this.errors = 0;
    this.inactivity = null;

    this._requests = [];
};

Strophe.Bosh.prototype = {
    /** Variable: strip
     *
     *  BOSH-Connections will have all stanzas wrapped in a <body> tag when
     *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.
     *  To strip this tag, User code can set <Strophe.Bosh.strip> to "body":
     *
     *  > Strophe.Bosh.prototype.strip = "body";
     *
     *  This will enable stripping of the body tag in both
     *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.
     */
    strip: null,

    /** PrivateFunction: _buildBody
     *  _Private_ helper function to generate the <body/> wrapper for BOSH.
     *
     *  Returns:
     *    A Strophe.Builder with a <body/> element.
     */
    _buildBody: function () {
        var bodyWrap = $build('body', {
            rid: this.rid++,
            xmlns: Strophe.NS.HTTPBIND
        });
        if (this.sid !== null) {
            bodyWrap.attrs({sid: this.sid});
        }
        if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
            this._cacheSession();
        }
        return bodyWrap;
    },

    /** PrivateFunction: _reset
     *  Reset the connection.
     *
     *  This function is called by the reset function of the Strophe Connection
     */
    _reset: function () {
        this.rid = Math.floor(Math.random() * 4294967295);
        this.sid = null;
        this.errors = 0;
        if (this._conn._sessionCachingSupported()) {
            window.sessionStorage.removeItem('strophe-bosh-session');
        }

        this._conn.nextValidRid(this.rid);
    },

    /** PrivateFunction: _connect
     *  _Private_ function that initializes the BOSH connection.
     *
     *  Creates and sends the Request that initializes the BOSH connection.
     */
    _connect: function (wait, hold, route) {
        this.wait = wait || this.wait;
        this.hold = hold || this.hold;
        this.errors = 0;

        // build the body tag
        var body = this._buildBody().attrs({
            to: this._conn.domain,
            "xml:lang": "en",
            wait: this.wait,
            hold: this.hold,
            content: "text/xml; charset=utf-8",
            ver: "1.6",
            "xmpp:version": "1.0",
            "xmlns:xmpp": Strophe.NS.BOSH
        });

        if(route){
            body.attrs({
                route: route
            });
        }

        var _connect_cb = this._conn._connect_cb;

        this._requests.push(
            new Strophe.Request(body.tree(),
                                this._onRequestStateChange.bind(
                                    this, _connect_cb.bind(this._conn)),
                                body.tree().getAttribute("rid")));
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _attach
     *  Attach to an already created and authenticated BOSH session.
     *
     *  This function is provided to allow Strophe to attach to BOSH
     *  sessions which have been created externally, perhaps by a Web
     *  application.  This is often used to support auto-login type features
     *  without putting user credentials into the page.
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *    (String) sid - The SID of the BOSH session.
     *    (String) rid - The current RID of the BOSH session.  This RID
     *      will be used by the next request.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    _attach: function (jid, sid, rid, callback, wait, hold, wind) {
        this._conn.jid = jid;
        this.sid = sid;
        this.rid = rid;

        this._conn.connect_callback = callback;

        this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);

        this._conn.authenticated = true;
        this._conn.connected = true;

        this.wait = wait || this.wait;
        this.hold = hold || this.hold;
        this.window = wind || this.window;

        this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);
    },

    /** PrivateFunction: _restore
     *  Attempt to restore a cached BOSH session
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *      This parameter is optional but recommended, specifically in cases
     *      where prebinded BOSH sessions are used where it's important to know
     *      that the right session is being restored.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    _restore: function (jid, callback, wait, hold, wind) {
        var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
        if (typeof session !== "undefined" &&
                   session !== null &&
                   session.rid &&
                   session.sid &&
                   session.jid &&
                   (    typeof jid === "undefined" ||
                        jid === null ||
                        Strophe.getBareJidFromJid(session.jid) == Strophe.getBareJidFromJid(jid) ||
                        // If authcid is null, then it's an anonymous login, so
                        // we compare only the domains:
                        ((Strophe.getNodeFromJid(jid) === null) && (Strophe.getDomainFromJid(session.jid) == jid))
                    )
        ) {
            this._conn.restored = true;
            this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
        } else {
            throw { name: "StropheSessionError", message: "_restore: no restoreable session." };
        }
    },

    /** PrivateFunction: _cacheSession
     *  _Private_ handler for the beforeunload event.
     *
     *  This handler is used to process the Bosh-part of the initial request.
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     */
    _cacheSession: function () {
        if (this._conn.authenticated) {
            if (this._conn.jid && this.rid && this.sid) {
                window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({
                    'jid': this._conn.jid,
                    'rid': this.rid,
                    'sid': this.sid
                }));
            }
        } else {
            window.sessionStorage.removeItem('strophe-bosh-session');
        }
    },

    /** PrivateFunction: _connect_cb
     *  _Private_ handler for initial connection request.
     *
     *  This handler is used to process the Bosh-part of the initial request.
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     */
    _connect_cb: function (bodyWrap) {
        var typ = bodyWrap.getAttribute("type");
        var cond, conflict;
        if (typ !== null && typ == "terminate") {
            // an error occurred
            cond = bodyWrap.getAttribute("condition");
            Strophe.error("BOSH-Connection failed: " + cond);
            conflict = bodyWrap.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            this._conn._doDisconnect(cond);
            return Strophe.Status.CONNFAIL;
        }

        // check to make sure we don't overwrite these if _connect_cb is
        // called multiple times in the case of missing stream:features
        if (!this.sid) {
            this.sid = bodyWrap.getAttribute("sid");
        }
        var wind = bodyWrap.getAttribute('requests');
        if (wind) { this.window = parseInt(wind, 10); }
        var hold = bodyWrap.getAttribute('hold');
        if (hold) { this.hold = parseInt(hold, 10); }
        var wait = bodyWrap.getAttribute('wait');
        if (wait) { this.wait = parseInt(wait, 10); }
        var inactivity = bodyWrap.getAttribute('inactivity');
        if (inactivity) { this.inactivity = parseInt(inactivity, 10); }
    },

    /** PrivateFunction: _disconnect
     *  _Private_ part of Connection.disconnect for Bosh
     *
     *  Parameters:
     *    (Request) pres - This stanza will be sent before disconnecting.
     */
    _disconnect: function (pres) {
        this._sendTerminate(pres);
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  Resets the SID and RID.
     */
    _doDisconnect: function () {
        this.sid = null;
        this.rid = Math.floor(Math.random() * 4294967295);
        if (this._conn._sessionCachingSupported()) {
            window.sessionStorage.removeItem('strophe-bosh-session');
        }

        this._conn.nextValidRid(this.rid);
    },

    /** PrivateFunction: _emptyQueue
     * _Private_ function to check if the Request queue is empty.
     *
     *  Returns:
     *    True, if there are no Requests queued, False otherwise.
     */
    _emptyQueue: function () {
        return this._requests.length === 0;
    },

    /** PrivateFunction: _callProtocolErrorHandlers
     *  _Private_ function to call error handlers registered for HTTP errors.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request that is changing readyState.
     */
    _callProtocolErrorHandlers: function (req) {
        var reqStatus = this._getRequestStatus(req),
            err_callback;
        err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];
        if (err_callback) {
            err_callback.call(this, reqStatus);
        }
    },

    /** PrivateFunction: _hitError
     *  _Private_ function to handle the error count.
     *
     *  Requests are resent automatically until their error count reaches
     *  5.  Each time an error is encountered, this function is called to
     *  increment the count and disconnect if the count is too high.
     *
     *  Parameters:
     *    (Integer) reqStatus - The request status.
     */
    _hitError: function (reqStatus) {
        this.errors++;
        Strophe.warn("request errored, status: " + reqStatus +
                     ", number of errors: " + this.errors);
        if (this.errors > 4) {
            this._conn._onDisconnectTimeout();
        }
    },

    /** PrivateFunction: _no_auth_received
     *
     * Called on stream start/restart when no stream:features
     * has been received and sends a blank poll request.
     */
    _no_auth_received: function (_callback) {
        if (_callback) {
            _callback = _callback.bind(this._conn);
        } else {
            _callback = this._conn._connect_cb.bind(this._conn);
        }
        var body = this._buildBody();
        this._requests.push(
                new Strophe.Request(body.tree(),
                    this._onRequestStateChange.bind(
                        this, _callback.bind(this._conn)),
                    body.tree().getAttribute("rid")));
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  Cancels all remaining Requests and clears the queue.
     */
    _onDisconnectTimeout: function () {
        this._abortAllRequests();
    },

    /** PrivateFunction: _abortAllRequests
     *  _Private_ helper function that makes sure all pending requests are aborted.
     */
    _abortAllRequests: function _abortAllRequests() {
        var req;
        while (this._requests.length > 0) {
            req = this._requests.pop();
            req.abort = true;
            req.xhr.abort();
            // jslint complains, but this is fine. setting to empty func
            // is necessary for IE6
            req.xhr.onreadystatechange = function () {}; // jshint ignore:line
        }
    },

    /** PrivateFunction: _onIdle
     *  _Private_ handler called by Strophe.Connection._onIdle
     *
     *  Sends all queued Requests or polls with empty Request if there are none.
     */
    _onIdle: function () {
        var data = this._conn._data;
        // if no requests are in progress, poll
        if (this._conn.authenticated && this._requests.length === 0 &&
            data.length === 0 && !this._conn.disconnecting) {
            Strophe.info("no requests during idle cycle, sending " +
                         "blank request");
            data.push(null);
        }

        if (this._conn.paused) {
            return;
        }

        if (this._requests.length < 2 && data.length > 0) {
            var body = this._buildBody();
            for (var i = 0; i < data.length; i++) {
                if (data[i] !== null) {
                    if (data[i] === "restart") {
                        body.attrs({
                            to: this._conn.domain,
                            "xml:lang": "en",
                            "xmpp:restart": "true",
                            "xmlns:xmpp": Strophe.NS.BOSH
                        });
                    } else {
                        body.cnode(data[i]).up();
                    }
                }
            }
            delete this._conn._data;
            this._conn._data = [];
            this._requests.push(
                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, this._conn._dataRecv.bind(this._conn)),
                                    body.tree().getAttribute("rid")));
            this._throttledRequestHandler();
        }

        if (this._requests.length > 0) {
            var time_elapsed = this._requests[0].age();
            if (this._requests[0].dead !== null) {
                if (this._requests[0].timeDead() >
                    Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                    this._throttledRequestHandler();
                }
            }

            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                Strophe.warn("Request " +
                             this._requests[0].id +
                             " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                             " seconds since last activity");
                this._throttledRequestHandler();
            }
        }
    },

    /** PrivateFunction: _getRequestStatus
     *
     *  Returns the HTTP status code from a Strophe.Request
     *
     *  Parameters:
     *    (Strophe.Request) req - The Strophe.Request instance.
     *    (Integer) def - The default value that should be returned if no
     *          status value was found.
     */
    _getRequestStatus: function (req, def) {
        var reqStatus;
        if (req.xhr.readyState == 4) {
            try {
                reqStatus = req.xhr.status;
            } catch (e) {
                // ignore errors from undefined status attribute. Works
                // around a browser bug
                Strophe.error(
                    "Caught an error while retrieving a request's status, " +
                    "reqStatus: " + reqStatus);
            }
        }
        if (typeof(reqStatus) == "undefined") {
            reqStatus = typeof def === 'number' ? def : 0;
        }
        return reqStatus;
    },

    /** PrivateFunction: _onRequestStateChange
     *  _Private_ handler for Strophe.Request state changes.
     *
     *  This function is called when the XMLHttpRequest readyState changes.
     *  It contains a lot of error handling logic for the many ways that
     *  requests can fail, and calls the request callback when requests
     *  succeed.
     *
     *  Parameters:
     *    (Function) func - The handler for the request.
     *    (Strophe.Request) req - The request that is changing readyState.
     */
    _onRequestStateChange: function (func, req) {
        Strophe.debug("request id "+req.id+"."+req.sends+
                      " state changed to "+req.xhr.readyState);
        if (req.abort) {
            req.abort = false;
            return;
        }
        if (req.xhr.readyState !== 4) {
            // The request is not yet complete
            return;
        }
        var reqStatus = this._getRequestStatus(req);
        if (this.disconnecting && reqStatus >= 400) {
            this._hitError(reqStatus);
            this._callProtocolErrorHandlers(req);
            return;
        }

        if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
            // remove from internal queue
            this._removeRequest(req);
            Strophe.debug("request id "+req.id+" should now be removed");
        }

        if (reqStatus == 200) {
            // request succeeded
            var reqIs0 = (this._requests[0] == req);
            var reqIs1 = (this._requests[1] == req);
            // if request 1 finished, or request 0 finished and request
            // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
            // restart the other - both will be in the first spot, as the
            // completed request has been removed from the queue already
            if (reqIs1 ||
                (reqIs0 && this._requests.length > 0 &&
                    this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                this._restartRequest(0);
            }
            this._conn.nextValidRid(Number(req.rid) + 1);
            Strophe.debug("request id "+req.id+"."+req.sends+" got 200");
            func(req); // call handler
            this.errors = 0;
        } else if (reqStatus === 0 ||
                   (reqStatus >= 400 && reqStatus < 600) ||
                   reqStatus >= 12000) {
            // request failed
            Strophe.error("request id "+req.id+"."+req.sends+" error "+reqStatus+" happened");
            this._hitError(reqStatus);
            this._callProtocolErrorHandlers(req);
            if (reqStatus >= 400 && reqStatus < 500) {
                this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
                this._conn._doDisconnect();
            }
        } else {
            Strophe.error("request id "+req.id+"."+req.sends+" error "+reqStatus+" happened");
        }
        if (!(reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
            this._throttledRequestHandler();
        }
    },

    /** PrivateFunction: _processRequest
     *  _Private_ function to process a request in the queue.
     *
     *  This function takes requests off the queue and sends them and
     *  restarts dead requests.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _processRequest: function (i) {
        var self = this;
        var req = this._requests[i];
        var reqStatus = this._getRequestStatus(req, -1);

        // make sure we limit the number of retries
        if (req.sends > this._conn.maxRetries) {
            this._conn._onDisconnectTimeout();
            return;
        }

        var time_elapsed = req.age();
        var primaryTimeout = (!isNaN(time_elapsed) &&
                              time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
        var secondaryTimeout = (req.dead !== null &&
                                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
        var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
                                               (reqStatus < 1 || reqStatus >= 500));
        if (primaryTimeout || secondaryTimeout ||
            requestCompletedWithServerError) {
            if (secondaryTimeout) {
                Strophe.error("Request " + this._requests[i].id +
                              " timed out (secondary), restarting");
            }
            req.abort = true;
            req.xhr.abort();
            // setting to null fails on IE6, so set to empty function
            req.xhr.onreadystatechange = function () {};
            this._requests[i] = new Strophe.Request(req.xmlData,
                                                    req.origFunc,
                                                    req.rid,
                                                    req.sends);
            req = this._requests[i];
        }

        if (req.xhr.readyState === 0) {
            Strophe.debug("request id "+req.id+"."+req.sends+" posting");

            try {
                var contentType = this._conn.options.contentType || "text/xml; charset=utf-8";
                req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
                if (typeof req.xhr.setRequestHeader !== 'undefined') {
                    // IE9 doesn't have setRequestHeader
                    req.xhr.setRequestHeader("Content-Type", contentType);
                }
                if (this._conn.options.withCredentials) {
                    req.xhr.withCredentials = true;
                }
            } catch (e2) {
                Strophe.error("XHR open failed.");
                if (!this._conn.connected) {
                    this._conn._changeConnectStatus(
                            Strophe.Status.CONNFAIL, "bad-service");
                }
                this._conn.disconnect();
                return;
            }

            // Fires the XHR request -- may be invoked immediately
            // or on a gradually expanding retry window for reconnects
            var sendFunc = function () {
                req.date = new Date();
                if (self._conn.options.customHeaders){
                    var headers = self._conn.options.customHeaders;
                    for (var header in headers) {
                        if (headers.hasOwnProperty(header)) {
                            req.xhr.setRequestHeader(header, headers[header]);
                        }
                    }
                }
                req.xhr.send(req.data);
            };

            // Implement progressive backoff for reconnects --
            // First retry (send == 1) should also be instantaneous
            if (req.sends > 1) {
                // Using a cube of the retry number creates a nicely
                // expanding retry window
                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                       Math.pow(req.sends, 3)) * 1000;
                setTimeout(function() {
                    // XXX: setTimeout should be called only with function expressions (23974bc1)
                    sendFunc();
                }, backoff);
            } else {
                sendFunc();
            }

            req.sends++;

            if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                    this._conn.xmlOutput(req.xmlData.childNodes[0]);
                } else {
                    this._conn.xmlOutput(req.xmlData);
                }
            }
            if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                this._conn.rawOutput(req.data);
            }
        } else {
            Strophe.debug("_processRequest: " +
                          (i === 0 ? "first" : "second") +
                          " request has readyState of " +
                          req.xhr.readyState);
        }
    },

    /** PrivateFunction: _removeRequest
     *  _Private_ function to remove a request from the queue.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request to remove.
     */
    _removeRequest: function (req) {
        Strophe.debug("removing request");
        var i;
        for (i = this._requests.length - 1; i >= 0; i--) {
            if (req == this._requests[i]) {
                this._requests.splice(i, 1);
            }
        }
        // IE6 fails on setting to null, so set to empty function
        req.xhr.onreadystatechange = function () {};
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _restartRequest
     *  _Private_ function to restart a request that is presumed dead.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _restartRequest: function (i) {
        var req = this._requests[i];
        if (req.dead === null) {
            req.dead = new Date();
        }

        this._processRequest(i);
    },

    /** PrivateFunction: _reqToData
     * _Private_ function to get a stanza out of a request.
     *
     * Tries to extract a stanza out of a Request Object.
     * When this fails the current connection will be disconnected.
     *
     *  Parameters:
     *    (Object) req - The Request.
     *
     *  Returns:
     *    The stanza that was passed.
     */
    _reqToData: function (req) {
        try {
            return req.getResponse();
        } catch (e) {
            if (e != "parsererror") { throw e; }
            this._conn.disconnect("strophe-parsererror");
        }
    },

    /** PrivateFunction: _sendTerminate
     *  _Private_ function to send initial disconnect sequence.
     *
     *  This is the first step in a graceful disconnect.  It sends
     *  the BOSH server a terminate body and includes an unavailable
     *  presence if authentication has completed.
     */
    _sendTerminate: function (pres) {
        Strophe.info("_sendTerminate was called");
        var body = this._buildBody().attrs({type: "terminate"});
        if (pres) {
            body.cnode(pres.tree());
        }
        var req = new Strophe.Request(
            body.tree(),
            this._onRequestStateChange.bind(
            this, this._conn._dataRecv.bind(this._conn)),
            body.tree().getAttribute("rid")
        );
        this._requests.push(req);
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _send
     *  _Private_ part of the Connection.send function for BOSH
     *
     * Just triggers the RequestHandler to send the messages that are in the queue
     */
    _send: function () {
        clearTimeout(this._conn._idleTimeout);
        this._throttledRequestHandler();

        // XXX: setTimeout should be called only with function expressions (23974bc1)
        this._conn._idleTimeout = setTimeout(function() {
            this._onIdle();
        }.bind(this._conn), 100);
    },

    /** PrivateFunction: _sendRestart
     *
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function () {
        this._throttledRequestHandler();
        clearTimeout(this._conn._idleTimeout);
    },

    /** PrivateFunction: _throttledRequestHandler
     *  _Private_ function to throttle requests to the connection window.
     *
     *  This function makes sure we don't send requests so fast that the
     *  request ids overflow the connection window in the case that one
     *  request died.
     */
    _throttledRequestHandler: function () {
        if (!this._requests) {
            Strophe.debug("_throttledRequestHandler called with " +
                          "undefined requests");
        } else {
            Strophe.debug("_throttledRequestHandler called with " +
                          this._requests.length + " requests");
        }

        if (!this._requests || this._requests.length === 0) {
            return;
        }

        if (this._requests.length > 0) {
            this._processRequest(0);
        }

        if (this._requests.length > 1 &&
            Math.abs(this._requests[0].rid -
                     this._requests[1].rid) < this.window) {
            this._processRequest(1);
        }
    }
};
return Strophe;
}));

/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-websocket', ['strophe-core'], function (core) {
            return factory(
                core.Strophe,
                core.$build
            );
        });
    } else {
        // Browser globals
        return factory(Strophe, $build);
    }
}(this, function (Strophe, $build) {

/** Class: Strophe.WebSocket
 *  _Private_ helper class that handles WebSocket Connections
 *
 *  The Strophe.WebSocket class is used internally by Strophe.Connection
 *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.
 */

/** File: websocket.js
 *  A JavaScript library to enable XMPP over Websocket in Strophejs.
 *
 *  This file implements XMPP over WebSockets for Strophejs.
 *  If a Connection is established with a Websocket url (ws://...)
 *  Strophe will use WebSockets.
 *  For more information on XMPP-over-WebSocket see RFC 7395:
 *  http://tools.ietf.org/html/rfc7395
 *
 *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)
 */

/** PrivateConstructor: Strophe.Websocket
 *  Create and initialize a Strophe.WebSocket object.
 *  Currently only sets the connection Object.
 *
 *  Parameters:
 *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.
 *
 *  Returns:
 *    A new Strophe.WebSocket object.
 */
Strophe.Websocket = function(connection) {
    this._conn = connection;
    this.strip = "wrapper";

    var service = connection.service;
    if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
        // If the service is not an absolute URL, assume it is a path and put the absolute
        // URL together from options, current URL and the path.
        var new_service = "";

        if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
            new_service += "ws";
        } else {
            new_service += "wss";
        }

        new_service += "://" + window.location.host;

        if (service.indexOf("/") !== 0) {
            new_service += window.location.pathname + service;
        } else {
            new_service += service;
        }

        connection.service = new_service;
    }
};

Strophe.Websocket.prototype = {
    /** PrivateFunction: _buildStream
     *  _Private_ helper function to generate the <stream> start tag for WebSockets
     *
     *  Returns:
     *    A Strophe.Builder with a <stream> element.
     */
    _buildStream: function () {
        return $build("open", {
            "xmlns": Strophe.NS.FRAMING,
            "to": this._conn.domain,
            "version": '1.0'
        });
    },

    /** PrivateFunction: _check_streamerror
     * _Private_ checks a message for stream:error
     *
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     *    connectstatus - The ConnectStatus that will be set on error.
     *  Returns:
     *     true if there was a streamerror, false otherwise.
     */
    _check_streamerror: function (bodyWrap, connectstatus) {
        var errors;
        if (bodyWrap.getElementsByTagNameNS) {
            errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "error");
        } else {
            errors = bodyWrap.getElementsByTagName("stream:error");
        }
        if (errors.length === 0) {
            return false;
        }
        var error = errors[0];

        var condition = "";
        var text = "";

        var ns = "urn:ietf:params:xml:ns:xmpp-streams";
        for (var i = 0; i < error.childNodes.length; i++) {
            var e = error.childNodes[i];
            if (e.getAttribute("xmlns") !== ns) {
                break;
            } if (e.nodeName === "text") {
                text = e.textContent;
            } else {
                condition = e.nodeName;
            }
        }

        var errorString = "WebSocket stream error: ";

        if (condition) {
            errorString += condition;
        } else {
            errorString += "unknown";
        }

        if (text) {
            errorString += " - " + condition;
        }

        Strophe.error(errorString);

        // close the connection on stream_error
        this._conn._changeConnectStatus(connectstatus, condition);
        this._conn._doDisconnect(condition);
        return true;
    },

    /** PrivateFunction: _reset
     *  Reset the connection.
     *
     *  This function is called by the reset function of the Strophe Connection.
     *  Is not needed by WebSockets.
     */
    _reset: function () {
        return;
    },

    /** PrivateFunction: _connect
     *  _Private_ function called by Strophe.Connection.connect
     *
     *  Creates a WebSocket for a connection and assigns Callbacks to it.
     *  Does nothing if there already is a WebSocket.
     */
    _connect: function () {
        // Ensure that there is no open WebSocket from a previous Connection.
        this._closeSocket();

        // Create the new WobSocket
        this.socket = new WebSocket(this._conn.service, "xmpp");
        this.socket.onopen = this._onOpen.bind(this);
        this.socket.onerror = this._onError.bind(this);
        this.socket.onclose = this._onClose.bind(this);
        this.socket.onmessage = this._connect_cb_wrapper.bind(this);
    },

    /** PrivateFunction: _connect_cb
     *  _Private_ function called by Strophe.Connection._connect_cb
     *
     * checks for stream:error
     *
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     */
    _connect_cb: function(bodyWrap) {
        var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
        if (error) {
            return Strophe.Status.CONNFAIL;
        }
    },

    /** PrivateFunction: _handleStreamStart
     * _Private_ function that checks the opening <open /> tag for errors.
     *
     * Disconnects if there is an error and returns false, true otherwise.
     *
     *  Parameters:
     *    (Node) message - Stanza containing the <open /> tag.
     */
    _handleStreamStart: function(message) {
        var error = false;

        // Check for errors in the <open /> tag
        var ns = message.getAttribute("xmlns");
        if (typeof ns !== "string") {
            error = "Missing xmlns in <open />";
        } else if (ns !== Strophe.NS.FRAMING) {
            error = "Wrong xmlns in <open />: " + ns;
        }

        var ver = message.getAttribute("version");
        if (typeof ver !== "string") {
            error = "Missing version in <open />";
        } else if (ver !== "1.0") {
            error = "Wrong version in <open />: " + ver;
        }

        if (error) {
            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
            this._conn._doDisconnect();
            return false;
        }

        return true;
    },

    /** PrivateFunction: _connect_cb_wrapper
     * _Private_ function that handles the first connection messages.
     *
     * On receiving an opening stream tag this callback replaces itself with the real
     * message handler. On receiving a stream error the connection is terminated.
     */
    _connect_cb_wrapper: function(message) {
        if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
            // Strip the XML Declaration, if there is one
            var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
            if (data === '') return;

            var streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
            this._conn.xmlInput(streamStart);
            this._conn.rawInput(message.data);

            //_handleStreamSteart will check for XML errors and disconnect on error
            if (this._handleStreamStart(streamStart)) {
                //_connect_cb will check for stream:error and disconnect on error
                this._connect_cb(streamStart);
            }
        } else if (message.data.indexOf("<close ") === 0) { //'<close xmlns="urn:ietf:params:xml:ns:xmpp-framing />') {
            this._conn.rawInput(message.data);
            this._conn.xmlInput(message);
            var see_uri = message.getAttribute("see-other-uri");
            if (see_uri) {
                this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");
                this._conn.reset();
                this._conn.service = see_uri;
                this._connect();
            } else {
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
                this._conn._doDisconnect();
            }
        } else {
            var string = this._streamWrap(message.data);
            var elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
            this.socket.onmessage = this._onMessage.bind(this);
            this._conn._connect_cb(elem, null, message.data);
        }
    },

    /** PrivateFunction: _disconnect
     *  _Private_ function called by Strophe.Connection.disconnect
     *
     *  Disconnects and sends a last stanza if one is given
     *
     *  Parameters:
     *    (Request) pres - This stanza will be sent before disconnecting.
     */
    _disconnect: function (pres) {
        if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
            if (pres) {
                this._conn.send(pres);
            }
            var close = $build("close", { "xmlns": Strophe.NS.FRAMING });
            this._conn.xmlOutput(close);
            var closeString = Strophe.serialize(close);
            this._conn.rawOutput(closeString);
            try {
                this.socket.send(closeString);
            } catch (e) {
                Strophe.info("Couldn't send <close /> tag.");
            }
        }
        this._conn._doDisconnect();
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  Just closes the Socket for WebSockets
     */
    _doDisconnect: function () {
        Strophe.info("WebSockets _doDisconnect was called");
        this._closeSocket();
    },

    /** PrivateFunction _streamWrap
     *  _Private_ helper function to wrap a stanza in a <stream> tag.
     *  This is used so Strophe can process stanzas from WebSockets like BOSH
     */
    _streamWrap: function (stanza) {
        return "<wrapper>" + stanza + '</wrapper>';
    },


    /** PrivateFunction: _closeSocket
     *  _Private_ function to close the WebSocket.
     *
     *  Closes the socket if it is still open and deletes it
     */
    _closeSocket: function () {
        if (this.socket) { try {
            this.socket.close();
        } catch (e) {} }
        this.socket = null;
    },

    /** PrivateFunction: _emptyQueue
     * _Private_ function to check if the message queue is empty.
     *
     *  Returns:
     *    True, because WebSocket messages are send immediately after queueing.
     */
    _emptyQueue: function () {
        return true;
    },

    /** PrivateFunction: _onClose
     * _Private_ function to handle websockets closing.
     *
     * Nothing to do here for WebSockets
     */
    _onClose: function() {
        if(this._conn.connected && !this._conn.disconnecting) {
            Strophe.error("Websocket closed unexpectedly");
            this._conn._doDisconnect();
        } else {
            Strophe.info("Websocket closed");
        }
    },

    /** PrivateFunction: _no_auth_received
     *
     * Called on stream start/restart when no stream:features
     * has been received.
     */
    _no_auth_received: function (_callback) {
        Strophe.error("Server did not send any auth methods");
        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
        if (_callback) {
            _callback = _callback.bind(this._conn);
            _callback();
        }
        this._conn._doDisconnect();
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  This does nothing for WebSockets
     */
    _onDisconnectTimeout: function () {},

    /** PrivateFunction: _abortAllRequests
     *  _Private_ helper function that makes sure all pending requests are aborted.
     */
    _abortAllRequests: function () {},

    /** PrivateFunction: _onError
     * _Private_ function to handle websockets errors.
     *
     * Parameters:
     * (Object) error - The websocket error.
     */
    _onError: function(error) {
        Strophe.error("Websocket error " + error);
        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected.");
        this._disconnect();
    },

    /** PrivateFunction: _onIdle
     *  _Private_ function called by Strophe.Connection._onIdle
     *
     *  sends all queued stanzas
     */
    _onIdle: function () {
        var data = this._conn._data;
        if (data.length > 0 && !this._conn.paused) {
            for (var i = 0; i < data.length; i++) {
                if (data[i] !== null) {
                    var stanza, rawStanza;
                    if (data[i] === "restart") {
                        stanza = this._buildStream().tree();
                    } else {
                        stanza = data[i];
                    }
                    rawStanza = Strophe.serialize(stanza);
                    this._conn.xmlOutput(stanza);
                    this._conn.rawOutput(rawStanza);
                    this.socket.send(rawStanza);
                }
            }
            this._conn._data = [];
        }
    },

    /** PrivateFunction: _onMessage
     * _Private_ function to handle websockets messages.
     *
     * This function parses each of the messages as if they are full documents.
     * [TODO : We may actually want to use a SAX Push parser].
     *
     * Since all XMPP traffic starts with
     *  <stream:stream version='1.0'
     *                 xml:lang='en'
     *                 xmlns='jabber:client'
     *                 xmlns:stream='http://etherx.jabber.org/streams'
     *                 id='3697395463'
     *                 from='SERVER'>
     *
     * The first stanza will always fail to be parsed.
     *
     * Additionally, the seconds stanza will always be <stream:features> with
     * the stream NS defined in the previous stanza, so we need to 'force'
     * the inclusion of the NS in this stanza.
     *
     * Parameters:
     * (string) message - The websocket message.
     */
    _onMessage: function(message) {
        var elem, data;
        // check for closing stream
        var close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
        if (message.data === close) {
            this._conn.rawInput(close);
            this._conn.xmlInput(message);
            if (!this._conn.disconnecting) {
                this._conn._doDisconnect();
            }
            return;
        } else if (message.data.search("<open ") === 0) {
            // This handles stream restarts
            elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
            if (!this._handleStreamStart(elem)) {
                return;
            }
        } else {
            data = this._streamWrap(message.data);
            data = data.replace(/[\u0002]/gm, '');
            elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
        }

        if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
            return;
        }

        //handle unavailable presence stanza before disconnecting
        if (this._conn.disconnecting &&
                elem.firstChild.nodeName === "presence" &&
                elem.firstChild.getAttribute("type") === "unavailable") {
            this._conn.xmlInput(elem);
            this._conn.rawInput(Strophe.serialize(elem));
            // if we are already disconnecting we will ignore the unavailable stanza and
            // wait for the </stream:stream> tag before we close the connection
            return;
        }
        this._conn._dataRecv(elem, message.data);
    },

    /** PrivateFunction: _onOpen
     * _Private_ function to handle websockets connection setup.
     *
     * The opening stream tag is sent here.
     */
    _onOpen: function() {
        Strophe.info("Websocket open");
        var start = this._buildStream();
        this._conn.xmlOutput(start.tree());

        var startString = Strophe.serialize(start);
        this._conn.rawOutput(startString);
        this.socket.send(startString);
    },

    /** PrivateFunction: _reqToData
     * _Private_ function to get a stanza out of a request.
     *
     * WebSockets don't use requests, so the passed argument is just returned.
     *
     *  Parameters:
     *    (Object) stanza - The stanza.
     *
     *  Returns:
     *    The stanza that was passed.
     */
    _reqToData: function (stanza) {
        return stanza;
    },

    /** PrivateFunction: _send
     *  _Private_ part of the Connection.send function for WebSocket
     *
     * Just flushes the messages that are in the queue
     */
    _send: function () {
        this._conn.flush();
    },

    /** PrivateFunction: _sendRestart
     *
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function () {
        clearTimeout(this._conn._idleTimeout);
        this._conn._onIdle.bind(this._conn)();
    }
};
return Strophe;
}));

(function(root){
    if(typeof define === 'function' && define.amd){
        define("strophe", [
            "strophe-core",
            "strophe-bosh",
            "strophe-websocket"
        ], function (wrapper) {
            return wrapper;
        });
    }
})(this);

/* jshint ignore:start */
if (callback) {
    if(typeof define === 'function' && define.amd){
        //For backwards compatability
        var n_callback = callback;
        if (typeof requirejs === 'function') {
            requirejs(["strophe"], function(o){
                n_callback(o.Strophe,o.$build,o.$msg,o.$iq,o.$pres);
            });
        } else {
            require(["strophe"], function(o){
                n_callback(o.Strophe,o.$build,o.$msg,o.$iq,o.$pres);
            });
        }
    }else{
        return callback(Strophe, $build, $msg, $iq, $pres);
    }
}


})(function (Strophe, build, msg, iq, pres) {
    window.Strophe = Strophe;
    window.$build = build;
    window.$msg = msg;
    window.$iq = iq;
    window.$pres = pres;
});
/* jshint ignore:end */
//static-content-hash-trigger-GCC


/*
* Based on Ping Strophejs plugins (https://github.com/metajack/strophejs-plugins/tree/master/ping)
* This plugin is distributed under the terms of the MIT licence.
* Please see the LICENCE file for details.
*
* Copyright (c) Markus Kohlhase, 2010
* Refactored by Pavel Lang, 2011
* AMD Support added by Thierry
* UMD support by LeartS
*/

Strophe.addConnectionPlugin('ping', {
    _c: null,

    // called by the Strophe.Connection constructor
    init: function(conn) {
        this._c = conn;
        Strophe.addNamespace('PING', "urn:xmpp:ping");
    },

    /**
    * Function: ping
    *
    * @param {string} to - The JID you want to ping
    * @param {function} success - Callback function on success
    * @param {function} error - Callback function on error
    * @param {number} timeout - Timeout in milliseconds
    */
    ping: function(jid, success, error, timeout) {
        var id = this._c.getUniqueId('ping');
        var iq = $iq({type: 'get', to: jid, id: id}).c(
                        'ping', {xmlns: Strophe.NS.PING});
        this._c.sendIQ(iq, success, error, timeout);
    },

    /**
    * Function: pong
    *    
    * @param {Object} ping - The ping stanza from the server 
    */
    pong: function(ping) {
        var from = ping.getAttribute('from');
        var id = ping.getAttribute('id');
        var iq = $iq({type: 'result', to: from,id: id});
        this._c.sendIQ(iq);
    },

    /**
    * Function: addPingHandler
    *    
    * @param {Function} handler - Ping handler
    *
    * @returns A reference to the handler that can be used to remove it.
    */
    addPingHandler: function(handler) {
        return this._c.addHandler(handler, Strophe.NS.PING, "iq", "get");
    }
});
//static-content-hash-trigger-GCC
function controlLink(action, link, linkHandle, linkType, soapUrl, useDotNet){

   var yes = confirm("Are you sure you wish to "+action+" link: " + link + "?");
   var statusMessage = "";

   if(yes){
   if("stop" == action ){
   	statusMessage= stopLink(link, linkHandle, linkType, soapUrl, useDotNet);
   }
   else if("start" == action){
   	statusMessage= startLink(link, linkHandle, linkType, soapUrl, useDotNet);
   }
   else if("restart" == action){
   	statusMessage= restartLink(linkHandle);
   }
   else if("failover" == action){
   	statusMessage= failoverLink(link);
   }

   updatePageList(linkHandle, linkType);

   if(statusMessage == "GOOD"){
   	// window.location.reload(true);
    }
   }
}




function startLink(link, linkHandle, linkType, soapUrl, useDotNet)
{
        var activityUrl = new SafeURL("ChannelServices-Admin-CTILink.StartLink");
        activityUrl.put("LinkHandle", linkHandle);
        activityUrl.put("LinkType", linkType);
        activityUrl.put("SoapUrl", soapUrl);
        activityUrl.put("UseDotNet", useDotNet);
        
        var temp = activityUrl.toURL();
        var request = invokeRequest(temp);
        var statusMessage = request.responseText;
        if(statusMessage != "GOOD")
        {
            alert(statusMessage);
        }
        return statusMessage;
}

function stopLink(link, linkHandle, linkType, soapUrl, useDotNet)
{
  
        var activityUrl = new SafeURL("ChannelServices-Admin-CTILink.StopLink");
        activityUrl.put("LinkHandle", linkHandle);
        activityUrl.put("LinkType", linkType);
        activityUrl.put("SoapUrl", soapUrl);
        activityUrl.put("UseDotNet", useDotNet);
        
        var temp = activityUrl.toURL();
        var request = invokeRequest(temp);
        var statusMessage = request.responseText;
        if(statusMessage != "GOOD")
        {
            alert(statusMessage);
        }
        return statusMessage;
}

function restartLink(linkHandle)
{
        var activityUrl = new SafeURL("ChannelServices-Admin-CTILink.RestartLink");
        activityUrl.put("LinkHandle", linkHandle);
             
        var temp = activityUrl.toURL();
        var request = invokeRequest(temp);
        var statusMessage = request.responseText;
        if(statusMessage != "GOOD")
        {
            alert(statusMessage);
        }
        return statusMessage;
}

function addCTILink(linkClass)
{
  var objRMAction = new pega.rf.RMAction();
  objRMAction.put("DefaultClass",linkClass);
  var bSuccess=objRMAction.newRule(function(){}); 
}

function failoverLink(link)
{
  
        var activityUrl = new SafeURL("ChannelServices-Admin-CTILink.UIFailoverLink");
        activityUrl.put("LinkName", link);

        var temp = activityUrl.toURL();
        var request = invokeRequest(temp);
        var statusMessage = request.responseText;
        if(statusMessage != "GOOD")
        {
            alert(statusMessage);
        }
        return statusMessage;
}

function refreshStatus(link, type)
{

  var activityUrl = new SafeURL("ChannelServices-Admin-CTILink.GetLinkStatusInfo");
  activityUrl.put("LinkName", link );
  activityUrl.put("LinkType", type );

  var temp = activityUrl.toURL();
  var request = invokeRequest(temp);
  //var statusMessage = request.responseText;

  //return statusMessage;
}


function updatePageList(linkHandle, type)
{
  var activityUrl = new SafeURL("ChannelServices-Landing-PegaCTI.GetLinkDefinitionStatusUpdates"); 
  activityUrl.put("LinkHandle", linkHandle );
  activityUrl.put("LinkType", type );

  var temp = activityUrl.toURL();
  var request = invokeRequest(temp);
  var statusMessage = request.responseText;

  //window.location.reload(true);

  return statusMessage;
}

function logoutAgent(link, session, device, agent, insKey)
{
    var yes = confirm("Are you sure you wish to logout agent " + agent + "?");
    if(yes)
    {    
        var activityUrl = new SafeURL("ChannelServices-Embed-Device-Phone.LogoutAgent");
        activityUrl.put("Link", link);
        activityUrl.put("Session", session);
        activityUrl.put("Device", device);
        activityUrl.put("Agent", agent);
        activityUrl.put("Queue", "");
        activityUrl.put("ConfigKey", insKey);

        var temp = activityUrl.toURL();
        var request = invokeRequest(temp);
        var statusMessage = request.responseText;
        if(statusMessage != "GOOD")
        {
            alert(statusMessage);
        }
        //window.parent.location.reload(true);
    }
}


function closeDevice(link, session, device, insKey)
{
    var yes = confirm("Are you sure you wish to close device " + device + "?");
    if(yes)
    {    
        var activityUrl = new SafeURL("ChannelServices-Embed-Device-Phone.CloseDevice");
        activityUrl.put("Link", link);
        activityUrl.put("Session", session);
        activityUrl.put("Device", device);
        activityUrl.put("ConfigKey", insKey);
        var temp = activityUrl.toURL();
        var request = invokeRequest(temp);
        var statusMessage = request.responseText;
        if(statusMessage != "GOOD")
        {
            alert(statusMessage);
        }
        //window.parent.location.reload(true);
    }
}

function invokeRequest(url) 
{
  var request; 
  var requestReturnCopy;
  if(window.XMLHttpRequest) 
  { 

    request = new XMLHttpRequest();
  } 
  else if(window.ActiveXObject) 
  {

    request = new ActiveXObject("Microsoft.XMLHTTP");
  }

  if (request != null) 
  {

    request.onreadystatechange = function() 
    {  
      if(request.readyState == 4) 
      { 
        requestReturnCopy = request;
      }  
    };

    request.open("POST", url, false);
    request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

    request.send(null);

  }

  return requestReturnCopy;
}

//this method is used to give fade in fadeout effect once the connection is ok
function fadeInFadeOutText(status){
  		
  $("div[data-ui-meta*='TestConnectivity'] i").remove(); //remove the icon;
  
  if(status && status.toLowerCase().indexOf("success") > -1){
     $("div[data-ui-meta*='TestConnectivity'] span").addClass("pegaCallSuccessText").css("color","#0EEA0E").append(status);
  }else{
     $("div[data-ui-meta*='TestConnectivity'] span").addClass("pegaCallSuccessText pegaCallAlertMessageRed").append(status);
  }
  
  $("div[data-ui-meta*='TestConnectivity'] span").fadeIn(3000);
  	  
}

function repositionCallOverlay(e){
  console.log("repositionCallOverlay->level");
  try{
    var target = pega.util.Event.getTarget(e),
        level = pega.u.d.getPopOverLevel(target);
    console.log("repositionCallOverlay->level" + level);
    if (level >= 0) {
      var popOver = pega.u.d.getPopOver(level);
      $(pega.u.d.getPopOver(0).getActivePopOverElement()).css('visibility','hidden');
      setTimeout(function(){
        popOver.reposit();
        $(pega.u.d.getPopOver(0).getActivePopOverElement()).css('visibility','visible');
      },500);
    }
  }catch(ex){
    console.log(ex);
  }
}
//static-content-hash-trigger-YUI
/*! nanoScrollerJS - v0.8.7 - (c) 2015 James Florentino; Licensed MIT */ ! function(a) {
    return "function" == typeof define && define.amd ? define(["jquery"], function(b) {
        return a(b, window, document)
    }) : "object" == typeof exports ? module.exports = a(require("jquery"), window, document) : a(jQuery, window,
        document)
}(function(a, b, c) {
    "use strict";
    var d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H;
    z = {
            paneClass: "nano-pane",
            sliderClass: "nano-slider",
            contentClass: "nano-content",
            enabledClass: "has-scrollbar",
            flashedClass: "flashed",
            activeClass: "active",
            iOSNativeScrolling: !1,
            preventPageScrolling: !1,
            disableResize: !1,
            alwaysVisible: !1,
            flashDelay: 1500,
            sliderMinHeight: 20,
            sliderMaxHeight: null,
            documentContext: null,
            windowContext: null
        }, u = "scrollbar", t = "scroll", l = "mousedown", m = "mouseenter", n = "mousemove", p = "mousewheel", o =
        "mouseup", s = "resize", h = "drag", i = "enter", w = "up", r = "panedown", f = "DOMMouseScroll", g = "down",
        x = "wheel", j = "keydown", k = "keyup", v = "touchmove", d = "Microsoft Internet Explorer" === b.navigator.appName &&
        /msie 7./i.test(b.navigator.appVersion) && b.ActiveXObject, e = null, D = b.requestAnimationFrame, y = b.cancelAnimationFrame,
        F = c.createElement("div").style, H = function() {
            var a, b, c, d, e, f;
            for (d = ["t", "webkitT", "MozT", "msT", "OT"], a = e = 0, f = d.length; f > e; a = ++e)
                if (c = d[a], b = d[a] + "ransform", b in F) return d[a].substr(0, d[a].length - 1);
            return !1
        }(), G = function(a) {
            return H === !1 ? !1 : "" === H ? a : H + a.charAt(0).toUpperCase() + a.substr(1)
        }, E = G("transform"), B = E !== !1, A = function() {
            var a, b, d;
            return a = c.createElement("div"), b = a.style, b.position = "absolute", b.width = "100px", b.height =
                "100px", b.overflow = t, b.top = "-9999px", c.body.appendChild(a), d = a.offsetWidth - a.clientWidth,
                c.body.removeChild(a), d
        }, C = function() {
            var a, c, d;
            return c = b.navigator.userAgent, (a = /(?=.+Mac OS X)(?=.+Firefox)/.test(c)) ? (d = /Firefox\/\d{2}\./.exec(
                c), d && (d = d[0].replace(/\D+/g, "")), a && +d > 23) : !1
        }, q = function() {
            function j(d, f) {
                this.el = d, this.options = f, e || (e = A()), this.$el = a(this.el), this.doc = a(this.options.documentContext ||
                        c), this.win = a(this.options.windowContext || b), this.body = this.doc.find("body"), this.$content =
                    this.$el.children("." + this.options.contentClass), this.$content.attr("tabindex", this.options.tabIndex ||
                        0), this.content = this.$content[0], this.previousPosition = 0, this.options.iOSNativeScrolling &&
                    null != this.el.style.WebkitOverflowScrolling ? this.nativeScrolling() : this.generate(), this.createEvents(),
                    this.addEvents(), this.reset()
            }
            return j.prototype.preventScrolling = function(a, b) {
                if (this.isActive)
                    if (a.type === f)(b === g && a.originalEvent.detail > 0 || b === w && a.originalEvent.detail <
                        0) && a.preventDefault();
                    else if (a.type === p) {
                    if (!a.originalEvent || !a.originalEvent.wheelDelta) return;
                    (b === g && a.originalEvent.wheelDelta < 0 || b === w && a.originalEvent.wheelDelta > 0) &&
                    a.preventDefault()
                }
            }, j.prototype.nativeScrolling = function() {
                this.$content.css({
                    WebkitOverflowScrolling: "touch"
                }), this.iOSNativeScrolling = !0, this.isActive = !0
            }, j.prototype.updateScrollValues = function() {
                var a, b;
                a = this.content, this.maxScrollTop = a.scrollHeight - a.clientHeight, this.prevScrollTop = this
                    .contentScrollTop || 0, this.contentScrollTop = a.scrollTop, b = this.contentScrollTop >
                    this.previousPosition ? "down" : this.contentScrollTop < this.previousPosition ? "up" :
                    "same", this.previousPosition = this.contentScrollTop, "same" !== b && this.$el.trigger(
                        "update", {
                            position: this.contentScrollTop,
                            maximum: this.maxScrollTop,
                            direction: b
                        }), this.iOSNativeScrolling || (this.maxSliderTop = this.paneHeight - this.sliderHeight,
                        this.sliderTop = 0 === this.maxScrollTop ? 0 : this.contentScrollTop * this.maxSliderTop /
                        this.maxScrollTop)
            }, j.prototype.setOnScrollStyles = function() {
                var a;
                B ? (a = {}, a[E] = "translate(0, " + this.sliderTop + "px)") : a = {
                    top: this.sliderTop
                }, D ? (y && this.scrollRAF && y(this.scrollRAF), this.scrollRAF = D(function(b) {
                    return function() {
                        return b.scrollRAF = null, b.slider.css(a)
                    }
                }(this))) : this.slider.css(a)
            }, j.prototype.createEvents = function() {
                this.events = {
                    down: function(a) {
                        return function(b) {
                            return a.isBeingDragged = !0, a.offsetY = b.pageY - a.slider.offset().top,
                                a.slider.is(b.target) || (a.offsetY = 0), a.pane.addClass(a.options.activeClass),
                                a.doc.bind(n, a.events[h]).bind(o, a.events[w]), a.body.bind(m, a.events[
                                    i]), !1
                        }
                    }(this),
                    drag: function(a) {
                        return function(b) {
                            return a.sliderY = b.pageY - a.$el.offset().top - a.paneTop - (a.offsetY ||
                                    .5 * a.sliderHeight), a.scroll(), a.contentScrollTop >= a.maxScrollTop &&
                                a.prevScrollTop !== a.maxScrollTop ? a.$el.trigger("scrollend") : 0 ===
                                a.contentScrollTop && 0 !== a.prevScrollTop && a.$el.trigger(
                                    "scrolltop"), !1
                        }
                    }(this),
                    up: function(a) {
                        return function(b) {
                            return a.isBeingDragged = !1, a.pane.removeClass(a.options.activeClass),
                                a.doc.unbind(n, a.events[h]).unbind(o, a.events[w]), a.body.unbind(m,
                                    a.events[i]), !1
                        }
                    }(this),
                    resize: function(a) {
                        return function(b) {
                            a.reset()
                        }
                    }(this),
                    panedown: function(a) {
                        return function(b) {
                            return a.sliderY = (b.offsetY || b.originalEvent.layerY) - .5 * a.sliderHeight,
                                a.scroll(), a.events.down(b), !1
                        }
                    }(this),
                    scroll: function(a) {
                        return function(b) {
                            a.updateScrollValues(), a.isBeingDragged || (a.iOSNativeScrolling || (a.sliderY =
                                a.sliderTop, a.setOnScrollStyles()), null != b && (a.contentScrollTop >=
                                a.maxScrollTop ? (a.options.preventPageScrolling && a.preventScrolling(
                                    b, g), a.prevScrollTop !== a.maxScrollTop && a.$el.trigger(
                                    "scrollend")) : 0 === a.contentScrollTop && (a.options.preventPageScrolling &&
                                    a.preventScrolling(b, w), 0 !== a.prevScrollTop && a.$el
                                    .trigger("scrolltop"))))
                        }
                    }(this),
                    wheel: function(a) {
                        return function(b) {
                            var c;
                            if (null != b) return c = b.delta || b.wheelDelta || b.originalEvent &&
                                b.originalEvent.wheelDelta || -b.detail || b.originalEvent && -b
                                .originalEvent.detail, c && (a.sliderY += -c / 3), a.scroll(), !
                                1
                        }
                    }(this),
                    enter: function(a) {
                        return function(b) {
                            var c;
                            if (a.isBeingDragged) return 1 !== (b.buttons || b.which) ? (c = a.events)[
                                w].apply(c, arguments) : void 0
                        }
                    }(this)
                }
            }, j.prototype.addEvents = function() {
                var a;
                this.removeEvents(), a = this.events, this.options.disableResize || this.win.bind(s, a[s]), this
                    .iOSNativeScrolling || (this.slider.bind(l, a[g]), this.pane.bind(l, a[r]).bind("" + p + " " +
                        f, a[x])), this.$content.bind("" + t + " " + p + " " + f + " " + v, a[t])
            }, j.prototype.removeEvents = function() {
                var a;
                a = this.events, this.win.unbind(s, a[s]), this.iOSNativeScrolling || (this.slider.unbind(),
                    this.pane.unbind()), this.$content.unbind("" + t + " " + p + " " + f + " " + v, a[t])
            }, j.prototype.generate = function() {
                var a, c, d, f, g, h, i;
                return f = this.options, h = f.paneClass, i = f.sliderClass, a = f.contentClass, (g = this.$el.children(
                        "." + h)).length || g.children("." + i).length || this.$el.append('<div class="' + h +
                        '"><div class="' + i + '" /></div>'), this.pane = this.$el.children("." + h), this.slider =
                    this.pane.find("." + i), 0 === e && C() ? (d = b.getComputedStyle(this.content, null).getPropertyValue(
                        "padding-right").replace(/[^0-9.]+/g, ""), c = {
                        right: -14,
                        paddingRight: +d + 14
                    }) : e && (c = {
                        right: -e
                    }, this.$el.addClass(f.enabledClass)), null != c && this.$content.css(c), this
            }, j.prototype.restore = function() {
                this.stopped = !1, this.iOSNativeScrolling || this.pane.show(), this.addEvents()
            }, j.prototype.reset = function() {
                var a, b, c, f, g, h, i, j, k, l, m, n;
                return this.iOSNativeScrolling ? void(this.contentHeight = this.content.scrollHeight) : (this.$el
                    .find("." + this.options.paneClass).length || this.generate().stop(), this.stopped &&
                    this.restore(), a = this.content, f = a.style, g = f.overflowY, d && this.$content.css({
                        height: this.$content.height()
                    }), b = a.scrollHeight + e, l = parseInt(this.$el.css("max-height"), 10), l > 0 && (this
                        .$el.height(""), this.$el.height(a.scrollHeight > l ? l : a.scrollHeight)), i = this
                    .pane.outerHeight(!1), k = parseInt(this.pane.css("top"), 10), h = parseInt(this.pane.css(
                        "bottom"), 10), j = i + k + h, n = Math.round(j / b * i), n < this.options.sliderMinHeight ?
                    n = this.options.sliderMinHeight : null != this.options.sliderMaxHeight && n > this.options
                    .sliderMaxHeight && (n = this.options.sliderMaxHeight), g === t && f.overflowX !== t &&
                    (n += e), this.maxSliderTop = j - n, this.contentHeight = b, this.paneHeight = i, this.paneOuterHeight =
                    j, this.sliderHeight = n, this.paneTop = k, this.slider.height(n), this.events.scroll(),
                    this.pane.show(), this.isActive = !0, a.scrollHeight === a.clientHeight || this.pane.outerHeight(!
                        0) >= a.scrollHeight && g !== t ? (this.pane.hide(), this.isActive = !1) : this.el.clientHeight ===
                    a.scrollHeight && g === t ? this.slider.hide() : this.slider.show(), this.pane.css({
                        opacity: this.options.alwaysVisible ? 1 : "",
                        visibility: this.options.alwaysVisible ? "visible" : ""
                    }), c = this.$content.css("position"), ("static" === c || "relative" === c) && (m =
                        parseInt(this.$content.css("right"), 10), m && this.$content.css({
                            right: "",
                            marginRight: m
                        })), this)
            }, j.prototype.scroll = function() {
                return this.isActive ? (this.sliderY = Math.max(0, this.sliderY), this.sliderY = Math.min(this.maxSliderTop,
                            this.sliderY), this.$content.scrollTop(this.maxScrollTop * this.sliderY / this.maxSliderTop),
                        this.iOSNativeScrolling || (this.updateScrollValues(), this.setOnScrollStyles()), this) :
                    void 0
            }, j.prototype.scrollBottom = function(a) {
                return this.isActive ? (this.$content.scrollTop(this.contentHeight - this.$content.height() - a)
                    .trigger(p), this.stop().restore(), this) : void 0
            }, j.prototype.scrollTop = function(a) {
                return this.isActive ? (this.$content.scrollTop(+a).trigger(p), this.stop().restore(), this) :
                    void 0
            }, j.prototype.scrollTo = function(a) {
                return this.isActive ? (this.scrollTop(this.$el.find(a).get(0).offsetTop), this) : void 0
            }, j.prototype.stop = function() {
                return y && this.scrollRAF && (y(this.scrollRAF), this.scrollRAF = null), this.stopped = !0,
                    this.removeEvents(), this.iOSNativeScrolling || this.pane.hide(), this
            }, j.prototype.destroy = function() {
                return this.stopped || this.stop(), !this.iOSNativeScrolling && this.pane.length && this.pane.remove(),
                    d && this.$content.height(""), this.$content.removeAttr("tabindex"), this.$el.hasClass(this.options
                        .enabledClass) && (this.$el.removeClass(this.options.enabledClass), this.$content.css({
                        right: ""
                    })), this
            }, j.prototype.flash = function() {
                return !this.iOSNativeScrolling && this.isActive ? (this.reset(), this.pane.addClass(this.options
                    .flashedClass), setTimeout(function(a) {
                    return function() {
                        a.pane.removeClass(a.options.flashedClass)
                    }
                }(this), this.options.flashDelay), this) : void 0
            }, j
        }(), a.fn.nanoScroller = function(b) {
            return this.each(function() {
                var c, d;
                if ((d = this.nanoscroller) || (c = a.extend({}, z, b), this.nanoscroller = d = new q(this,
                        c)), b && "object" == typeof b) {
                    if (a.extend(d.options, b), null != b.scrollBottom) return d.scrollBottom(b.scrollBottom);
                    if (null != b.scrollTop) return d.scrollTop(b.scrollTop);
                    if (b.scrollTo) return d.scrollTo(b.scrollTo);
                    if ("bottom" === b.scroll) return d.scrollBottom(0);
                    if ("top" === b.scroll) return d.scrollTop(0);
                    if (b.scroll && b.scroll instanceof a) return d.scrollTo(b.scroll);
                    if (b.stop) return d.stop();
                    if (b.destroy) return d.destroy();
                    if (b.flash) return d.flash()
                }
                return d.reset()
            })
        }, a.fn.nanoScroller.Constructor = q
});

function debounce(func, wait, immediate) {
    var timeout;
    return function() {
        var context = this,
            args = arguments;
        var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
};
 function loggingToasterPopActivityIP(MessageToLog,Reason,OfferID,postdata){
      if (OfferID=="" || OfferID==undefined)
   {return;}
     
   if(postdata.detail.response.pyPurpose === 'expiredChat')
     { return;
     }
     var oSafeURL = new SafeURL("ChannelServices-Interaction-Chat.ToasterPopForChat");
     oSafeURL.put("MessageToLog", MessageToLog);
     oSafeURL.put("LoggingLevel", "Error");
    oSafeURL.put("Action", "Logging");
    oSafeURL.put("Reason", Reason);
       oSafeURL.put("OfferID", OfferID);
     var writetolog = pega.u.d.asyncRequest(
        "POST",
        SafeURL_createFromURL(oSafeURL.toURL()),
        {
          success: function () { },
          failure: function () {},
          scope: this,
        },
        null
      );
  };
/**
 * This jQuery plugin resizes a textarea to adapt it automatically to the content.
 * @author Amaury Carrade
 * @version 1.1
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lessier General Public License version 3 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lessier General Public License for more details.
 *
 * You should have received a copy of the GNU Lessier General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
(function($) {
    $(document).ready(function() {
        $('body').append(
            '<div id="autoResizeTextareaCopy" style="box-sizing: border-box; -moz-box-sizing: border-box;  -ms-box-sizing: border-box; -webkit-box-sizing: border-box; visibility: hidden;"></div>'
        );
        var $copy = $('#autoResizeTextareaCopy');

        function autoSize($textarea, options) {
            $copy.css({
                fontFamily: $textarea.css('fontFamily'),
                fontSize: $textarea.css('fontSize'),
                padding: $textarea.css('padding'),
                paddingLeft: $textarea.css('paddingLeft'),
                paddingRight: $textarea.css('paddingRight'),
                paddingTop: $textarea.css('paddingTop'),
                paddingBottom: $textarea.css('paddingBottom'),
                width: $textarea.css('width')
            });
            $textarea.css('overflow', 'hidden');
            var text = $textarea.val().replace(/\n/g, '<br/>').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(
                /"/g, '&quot;'); /***Changed as part of HFIX-48009***/
            $copy.html(text + '<br />');
            var newHeight = $copy.css('height');
            $copy.html('');
            if (parseInt(newHeight) != 0) {
                if ((options.maxHeight != null && parseInt(newHeight) < parseInt(options.maxHeight)) ||
                    options.maxHeight == null) {
                    if (options.animate.enabled) {
                        $textarea.animate({
                            height: newHeight
                        }, {
                            duration: options.animate.duration,
                            complete: options.animate.complete,
                            step: options.animate.step,
                            queue: false
                        });
                    } else {
                        $textarea.css('height', newHeight);
                    }
                    $textarea.css('overflow-y', 'hidden');
                } else {
                    $textarea.css('overflow-y', 'scroll');
                }
            }
        }
        $.fn.autoResize = function(options) {
            var $this = $(this),
                defaultOptions = {
                    animate: {
                        enabled: false,
                        duration: 100,
                        complete: null,
                        step: null
                    },
                    maxHeight: null
                };
            options = (options == undefined) ? {} : options;
            options = $.extend(true, defaultOptions, options);
            $this.change(function() {
                autoSize($this, options);
            }).keydown(function() {
                autoSize($this, options);
            }).keyup(function() {
                autoSize($this, options);
            }).focus(function() {
                autoSize($this, options);
            });
            $this.on("input propertychange", function() {
                autoSize($this, options);
            });
            startupOptions = options;
            startupOptions.animate.enabled = options.animate.enabled;
            autoSize($this, startupOptions);
        };
    });
})(jQuery);
/***************** Config for Common Utils - START ***********************/
var overlapRuntimeToolBar = true;
/***************** Config for Common Utils - END *************************/
/* this will resize the DC height */
function resizeInteractionPortalDcHeight() {
    var runTimeToolBarHeight = 0;
    var runTimeToolBar = $('[node_name="pzRuntimeToolsTopBar"]');
    if (runTimeToolBar.length > 0 && !overlapRuntimeToolBar) {
        runTimeToolBarHeight = runTimeToolBar.height();
    }
    var footer = $("footer");
    var finalHeight = $("body").height() - $("header").height() - (footer.height() != null ? footer.height() : 0) -
        runTimeToolBarHeight;
  if (finalHeight!=0){
     $("#workarea").height(finalHeight);
  }
   
    $(".cs-social-panel").height(finalHeight);
    $(".inbound-email-pane").height(finalHeight);
    adjustChatContentArea();
}

function toggleKBSection(event) {
    var kbSection = $(".CpmKmwrapper");
    var kbToggleBtn = $(".cskm-toggle-button i.icons");
    kbSection.slideToggle("slow", function() {
        kbToggleBtn.toggleClass("cskm-toggle-button-blue");
        resizeInteractionPortalDcHeight();
        adjustChatContentArea();
    });
}

function toggleKMWidget() {
    $("body").toggleClass("KM-Expanded");
    /*if($("body").hasClass("KM-Expanded")){
     $(".km-toggle-icon").removeClass("cs-icon-status-warm").addClass("cs-icon-status-positive");
    }else{
      $(".km-toggle-icon").removeClass("cs-icon-status-positive").addClass("cs-icon-status-warm");
    }*/
}
/* this will be called from interaction context to toggle others*/
function setWorkAreaFullWidth() {
    var dcwrapper = $(".dc-wrapper");
    var chatWrapper = $(".chat-wrapper");
    var inboundWrapper = $(".inbound-wrapper");
    var socialWrapper = $(".social-wrapper");
    var footer = $("footer");
    var runTimeToolBar = $('[node_name="pzRuntimeToolsTopBar"]');
    var runTimeToolBarHeight = 0;
    if (runTimeToolBar.length > 0 && !overlapRuntimeToolBar) {
        runTimeToolBarHeight = runTimeToolBar.height();
    }
    if (dcwrapper.length && chatWrapper.length) {
        $(dcwrapper[0]).css("width", "100%");
        $(chatWrapper[0]).css("display", "none");
        $(inboundWrapper[0]).css("display", "none");
        $(socialWrapper[0]).css("display", "none");
        $("#workarea").height($("body").height() - $("header").height() - (footer.height() != null ? footer.height() : 0) -
            runTimeToolBarHeight);
        if (pega.u.d.resizeHarness != null) {
            pega.u.d.resizeHarness();
        }
    }
}
/* this will be called from Inbound Corr context to toggle others*/
function configureInboundCorrSection(cpmSearchHeaderDisp, headerVisible, showEmailContent) {
    var dcwrapper = $(".dc-wrapper");
    var chatWrapper = $(".chat-wrapper");
    var inboundWrapper = $(".inbound-wrapper");
    var socialWrapper = $(".social-wrapper");
    var runTimeToolBar = $('[node_name="pzRuntimeToolsTopBar"]');
    var runTimeToolBarHeight = 0;
    var footer = $("footer");
    if (runTimeToolBar.length > 0 && !overlapRuntimeToolBar) {
        runTimeToolBarHeight = runTimeToolBar.height();
    }
    if (dcwrapper.length && chatWrapper.length) {
        $(dcwrapper).css("flex", 1).css("width", "100%");
        $(chatWrapper[0]).css("display", "none");
        $(socialWrapper[0]).css("display", "none");
        if ((cpmSearchHeaderDisp && headerVisible) || showEmailContent) {
            $(inboundWrapper[0]).css({
                "display": "flex",
                "flex": "0 1 600px",
                "width": "600px"
            });
        } else {
            $(inboundWrapper[0]).css("display", "none");
        }
        console.log("runtime tool bar height " + runTimeToolBarHeight)
        $("#workarea").height($("body").height() - $("header").height() - (footer.height() != null ? footer.height() : 0) -
            runTimeToolBarHeight);
        if (pega.u.d.resizeHarness != null) {
            pega.u.d.resizeHarness();
        }
    }
}
/* this will be called from CHAT context to toggle others*/
function configureChatSection(cpmSearchHeaderDisp, headerVisible) {
    var dcwrapper = $(".dc-wrapper");
    var chatWrapper = $(".chat-wrapper");
    var inboundWrapper = $(".inbound-wrapper");
    var socialWrapper = $(".social-wrapper");
    var footer = $("footer");
    var runTimeToolBar = $('[node_name="pzRuntimeToolsTopBar"]');
    var runTimeToolBarHeight = 0;
    if (runTimeToolBar.length > 0 && overlapRuntimeToolBar) {
        runTimeToolBarHeight = runTimeToolBar.height();
    }
    if (dcwrapper.length && chatWrapper.length) {
        $(dcwrapper).css("flex", 1).css("width", "100%");
        $(inboundWrapper[0]).css("display", "none");
        $(socialWrapper[0]).css("display", "none");
        if (cpmSearchHeaderDisp == "true" && headerVisible == "true") {
            $(chatWrapper[0]).css({
                "display": "flex",
                "flex": "0 1 350px"
            });
        } else {
            $(chatWrapper[0]).css("display", "none");
        }
        $("#workarea").height($("body").height() - $("header").height() - (footer.height() != null ? footer.height() : 0) -
            runTimeToolBarHeight);
        if (pega.u.d.resizeHarness != null) {
            pega.u.d.resizeHarness();
        }
    }
}
/* this will be called from CHAT context to toggle others*/
function adjustSocialSection(cpmSearchHeaderDisp, headerVisible) {
    var dcwrapper = $(".dc-wrapper");
    var chatWrapper = $(".chat-wrapper");
    var inboundWrapper = $(".inbound-wrapper");
    var socialWrapper = $(".social-wrapper");
    var footer = $("footer");
    if (dcwrapper.length && socialWrapper.length) {
        $(dcwrapper).css("flex", 1).css("width", "100%");
        $(inboundWrapper[0]).css("display", "none");
        $(chatWrapper[0]).css("display", "none");
        if (cpmSearchHeaderDisp == "true" && headerVisible == "true") {
            $(socialWrapper[0]).css({
                "display": "flex",
                "flex": "0 1 600px"
            });
        } else {
            $(socialWrapper[0]).css("display", "none");
        }
        $("#workarea").height($("body").height() - $("header").height() - (footer.height() != null ? footer.height() : 0));
        if (pega.u.d.resizeHarness != null) {
            pega.u.d.resizeHarness();
        }
    }
}
/* this function will calculate the height we need to set for the chat content or the nano pane */
function adjustChatContentArea() {
    var cpmChatWrapper = $(".chat-wrapper");
    var footer = $("footer");
    if (cpmChatWrapper && cpmChatWrapper.length) {
        var totalHeight = $("body").height() - $("header").height() - (footer.height() != null ? footer.height() : 0);
        cpmChatWrapper.height(totalHeight);
        var chatHeaderHeight = $(".chat-header-wrapper").outerHeight();
        var cmpChatStackChildren = $(".chat-stack").children();
        var cmpChatStackitem1 = $(cmpChatStackChildren[0]),
            cmpChatStackitem2 = $(cmpChatStackChildren[1]);
        /* removed the -20 from the end of this calculation. It seems like it was there to account for the express header,
           but that should not be there for an end user anyway, so it's not needed */
        var finalHeight = totalHeight - cmpChatStackitem2.height() - chatHeaderHeight;
        cmpChatStackitem1.css("height", finalHeight);
        $(".nano .nano-content").prepend($(".chat-bot-area").detach());
        $(".nano").height(finalHeight);
        $(".nano").nanoScroller();
    }
}
/* this function will resize the chat text area based on typing */
function autoReziseChatTextArea() {
    $("textarea.cpm-chat-area").autoResize({
        animate: {
            enabled: true,
            duration: 'fast',
            complete: function() {
                adjustChatContentArea();
            }
        },
        maxHeight: '100px'
    });
}
/* this function will be called when we click the edit icon in chat text */
function pushChatDialog() {
    var editor = document.getElementsByClassName("cke_contents")[0];
    if (editor != null) {
        var editorframe = editor.getElementsByTagName("iframe")[0];
        var body = editorframe.contentDocument || editorframe.contentWindow.document;
        var bodytext = body.getElementsByTagName("body")[0];
        /* This changes the text from placeholder to editable */
        $(bodytext).removeClass("placeholder");
        bodytext.focus();
        typeof showTextLimit =='function' && showTextLimit();
    }
}
function getMessageLength(message) {        
  if (!message){           
    message = '';
  }
  return message.replace(/<\/?[^>]+(>|$)/g, "").replace(/(\&nbsp;)+/g, '').replace(/\u200B/g,'').trim().length;
}

function pushDialog(dialogText, pushType) {
    var editor;
    var editorlength;
    /* If suggested disposition is used */
    if (pushType == "used") {
        editor = document.querySelector("[name$=TabChatEntry]")
        editor.value = dialogText.replace(/[\s\n\r]+/g, ' ').replace(/&nbsp;/gi, '');
        editor.focus();
    } else {
        /*BUG-613772 - appending the dialog text where the cursor is located instead of appending it at the end*/
        var textAreaId;	     
  	    var ckeditors = document.getElementsByClassName("PEGACKEDITOR textAreaStyle");
	      editorlength = ckeditors.length;
        if (editorlength>0){
          editor = ckeditors[editorlength-1];
        } else {
          editor = ckeditors[0];
        }
  	    if(editor != null){
  	      textAreaId = editor.id;    
 		      var ckeditorInstance = CKEDITOR.instances[textAreaId];  
		      var textAreaElem = ckeditorInstance.element.$;  
          var dialogTextFinal = dialogText.replace(/[\s\n\r]+/g, ' ').replace(/&nbsp;/gi, '');
	      	$(textAreaElem).trigger("insertTextOn", dialogTextFinal);
      	}
    }
   typeof showTextLimit =='function' && showTextLimit();
}

/* Toggle search and close icon based on text value */
function handleAdvancedSearch(event) {
    if (!event) {
        return;
    }
    var txtInput = $(event.target);
    var advWrapper = $(txtInput).closest(".advanced-search-wrapper");
    var searchIcon = $(advWrapper).find(".item-2");
    var closeIcon = $(advWrapper).find(".item-3");
    var dInput = txtInput.val();
    if (dInput) {
        searchIcon.css("display", "none");
        closeIcon.css("display", "block");
    } else {
        searchIcon.css("display", "block");
        closeIcon.css("display", "none");
    }
}
/* Clear the typed text value */
function clearAdvancedSearchText(event) {
    if (!event) {
        return;
    }
    var advWrapper = $(event.target).closest(".advanced-search-wrapper");
    var txtInput = $(advWrapper).find("input[type='text']");
    var searchIcon = $(advWrapper).find(".item-2");
    var closeIcon = $(advWrapper).find(".item-3");
    if (txtInput.val()) {
        txtInput.val('');
        searchIcon.css("display", "none");
        closeIcon.css("display", "block");
    } else {
        searchIcon.css("display", "block");
        closeIcon.css("display", "none");
    }
}
/**************** this IIFE block will help us to configure the chat toaster pop **************/
/*************** function to close ovarlay which is already opened - Start **********************/
function closeOverlays() {
    $("#modalOverlay").trigger("click");
}
/*************** function to close ovarlay which is already opened - End**********************/
(function(pega) {
    if (!pega) var pega = {};
    if (!pega.cpm) pega.cpm = {};
    if (!pega.cpm.toasterpop) pega.cpm.toasterpop = {};
    /* Start Toaster popup utility functions */
    pega.cpm.toasterpop.hideToasterPop = function() {
        if ($("#toasterpop").length > 0) {
            $("#toasterpop").removeClass("alerting");
        }
    }
    pega.cpm.toasterpop.loadToasterPop = function(url, cb, offerId,postdata) {
        var safeURL = SafeURL_createFromURL(url);
        pega.u.d.asyncRequest("POST", safeURL, {
            success: function(oResponse) {
                var toasterpop = $("#toasterpop");
                toasterpop.addClass("alerting").html(oResponse.responseText);
               if(document.querySelector('#toasterpop').offsetHeight>0)
                {
                  var msg="In loadToasterPop function after addclass when offsetHeight is greaterthan 0 "+offerId;
                  loggingToasterPopActivityIP(msg,"success",offerId,postdata);
                }
              else
                {
                  var msg="In loadToasterPop function after addclass when offsetHeight is not created"+offerId;
                  loggingToasterPopActivityIP(msg,"fail",offerId,postdata);
                }
                /* toasterpop.attr("tabindex", -1).focus().css("outline", "none");*/
                cb && cb(true);
            },
            failure: function() {
                alert("Request from server failed.");
                cb && cb(false);
            }
        }, null);
    }
})(pega);
/*Start -- Functions referred from CPMHistory control*/
function addHistory(strCategory, historyMemo, reasonFieldValue, fieldValue, interactionClassName) {
    var oSafeURL = new SafeURL(interactionClassName + ".CPMAddHistory");
    var recentUrl = SafeURL_createFromURL(oSafeURL.toURL());
    recentUrl.put("pzPrimaryPageName", "pyWorkPage");
    recentUrl.put("strMessageKey", historyMemo);
    recentUrl.put("strCategory", strCategory);
    recentUrl.put("strReasonFieldValue", reasonFieldValue);
    recentUrl.put("strFieldValue", fieldValue);
    var bHistoryAdded = false;
    var transaction1 = pega.u.d.asyncRequest('GET', recentUrl, {
        success: function(oResponse) {
            bHistoryAdded = oResponse.responseText;
        },
        failure: function() {},
        scope: this
    }, "");
}

function showHistory(strCategory, historyMemo, interactionClassName) {
    var oSafeURL = new SafeURL(interactionClassName + ".CPMGetLocalizedTextForFieldValue");
    var recentUrl = SafeURL_createFromURL(oSafeURL.toURL());
    recentUrl.put("PropertyReference", strCategory);
    recentUrl.put("StringToLocalize", historyMemo);
    var transaction2 = pega.u.d.asyncRequest('GET', recentUrl, {
        success: function(oResponse) {
            alert(oResponse.responseText);
        },
        failure: function() {},
        scope: this
    }, "");
}
/*End -- Functions referred from CPMHistory control*/
/********************************* Driver Script - Start **********************************/
function adjustDriver() {
    var targetedHeight = $(".workarea-view-scroll-wrapper").height() - 200;
    var CPMInteractionTasksDiv = $('div[node_name="CPMInteractionTasks"]');
    var CPMInteractionTasksDivContent = $('div[node_name="CPMInteractionTasks"]>div>div>div');
    $(CPMInteractionTasksDiv).addClass("nano has-scrollbar");
    if (targetedHeight >= $(CPMInteractionTasksDivContent).height()) {
        $(CPMInteractionTasksDiv).css("height", $(CPMInteractionTasksDivContent).height());
    } else {
        $(CPMInteractionTasksDiv).css("height", targetedHeight);
    }
    $('div[node_name="CPMInteractionTasks"]>div').addClass("nano-content content");
    $(CPMInteractionTasksDiv).nanoScroller();
  
    var CPMInteractionTasksChildDiv = $('div[node_name="CPMInteractionTasks"]>div');
    $(CPMInteractionTasksChildDiv).attr('tabindex','-1');
}
/********************************* Driver Script - END ****************************/
/********************************* Express Toggle History - Scripts - START ******************************/
function toggleExpressHistory(element, interactionClassName) {
    var isExpressToggleHistoryEnabled;
    isExpressToggleHistoryEnabled = $(element).is(":checked");
    $(".cpm-history-checkbox[data-is-express-history-enabled]").attr("data-is-express-history-enabled",
        isExpressToggleHistoryEnabled);
    var oSafeURL = new SafeURL(interactionClassName + ".CheckExpressHistoryStatus");
    var recentUrl = SafeURL_createFromURL(oSafeURL.toURL());
    recentUrl.put("PropertyReference", isExpressToggleHistoryEnabled);
    var transaction2 = pega.u.d.asyncRequest('GET', recentUrl, {
        success: function(oResponse) {},
        failure: function() {},
        scope: this
    }, "");
}

function markFieldAsReviewed(ele, FieldName, historyMemo, printableHistoryMemo, ReasonValue, FieldValue,
    interactionClassName, checkedToolTip) {
    if (!$(ele).is('[readonly]')) {
        $(ele).prop('checked', true);
        $(ele).prop('readonly', true);
        $(ele).prop('title', checkedToolTip);
        addHistory(FieldName, historyMemo, ReasonValue, FieldValue, interactionClassName);
       console.log("interaction clas name ",interactionClassName);
        if (printableHistoryMemo != "") {
            if (typeof pushDialog == 'function') {
                /* Added as part of react chat work*/
                if(pega.chat!== undefined && pega.chat.ChatComponentEventHandler!==undefined )
                  {
                    var pushData = {"dialogText" : printableHistoryMemo};
                    pega.chat.ChatComponentEventHandler.publishEvent("CHAT COMPOSER EVENT", "PUSH DIALOG", pushData);
                  }
                else
                  {
                    pushDialog(printableHistoryMemo);
                  }
               
                
                /* Added as part of react chat work*/
            }
        }
        return true;
    } else {
        return false;
    }
}
/********************************* Express Toggle History - Scripts - END ******************************/
/******************************** Utility Scripts for Actions - Start **********************************/
/******************************** Script to toggle a css class for an item in RDL - Start **********************************/
function toggleCssClassForListItem(event, containerSelector, itemSelector, classToBeToggled, resetIfAlreadySelected) {
    var target = event.target;
    var container = $(target).closest(containerSelector);
    var currentSelectedItem = $(container).find(itemSelector + "." + classToBeToggled);
    var itemToBeSelected = $(target).closest(itemSelector);
    if (currentSelectedItem.is(itemToBeSelected) && resetIfAlreadySelected === 'true') {
        currentSelectedItem.removeClass(classToBeToggled);
        return;
    }
    if (!currentSelectedItem.is(itemToBeSelected)) {
        currentSelectedItem.removeClass(classToBeToggled);
    }
    $(itemToBeSelected).addClass(classToBeToggled);
}

function toggleCssClass(elementSelector, cssClass) {
    $(elementSelector).toggleClass(cssClass);
}

function scrollRightPaneToBottom(pane){
  /** BUG-438757 - START **/
  //If no Pane is passed, considering the default pane as Chat pane
  pane = pane || "Chat";
  var scrollPos = 0;
  if(pane === "Chat"){
    if($("body").hasClass("km-expanded")){
      $("body").addClass("km-expanded scroll-chat-to-bottom");
    }
     var IsTabInFocus = pega.cs.notificationmanager.isCurrentDCTabInFocus();
    if(IsTabInFocus){
      scrollPos = $(".int-ui-right-pane .int-ui-right-pane-chat-content>div").height();
      $(".int-ui-right-pane .int-ui-right-pane-chat-content").animate({scrollTop: scrollPos}, 'slow');
    }
  }else if(pane === "KM"){
    scrollPos = $(".int-ui-right-pane .int-ui-right-pane-km-content>div").height();
    $(".int-ui-right-pane .int-ui-right-pane-km-content").animate({scrollTop: scrollPos}, 'slow');
  }else if(pane === "Email"){
    scrollPos = $(".int-ui-right-pane .int-ui-right-pane-email-content>div").height();
    $(".int-ui-right-pane .int-ui-right-pane-email-content").animate({scrollTop: scrollPos}, 'slow');
  }
  /** BUG-438757 - END **/
}

function scrollWorkAreaToTop() {
    $(".workarea-view-content").animate({
        scrollTop: 0
    }, 'slow');
}
/******************************** Script to toggle a css class for an item in RDL - End **********************************/
/******************************** Script to scroll to bottom of the element - START **************************************/
function scrollToBottom(elementSelector, animate, duration) {
    var ele = $(elementSelector);
    if (ele.length > 0) {
        ele = ele[0];
        var elementHeight = ele.scrollHeight;
        if (animate == 'true') {
            if (duration == null) {
                duration = 1000;
            }
            $(ele).animate({
                scrollTop: elementHeight
            }, duration);
        } else {
            $(ele).scrollTop(elementHeight);
        }
    }
}

function ShowSmartInfo() {
    $("#_popOversContainer").show();
}

function HideSmartInfo() {
    $("#_popOversContainer").hide();
}
/******************************** Script to scroll to bottom of the element - END **************************************/
/******************************** Script to attach a css file - START ************************************/
function attachCssFile(filename, foldername) {
    if ($("link[ref-id='" + filename + "']").length == 0) {
        var cssLinkEle = document.createElement("link");
        $(cssLinkEle).attr({
            "href": foldername + "/" + filename + ".css",
            "rel": "stylesheet",
            "type": "text/css",
            "ref-id": filename
        });
        $("head").append(cssLinkEle);
    }
}
/******************************** Script to attach a css file - END **************************************/
/******************************** Script to disable a element - START ************************************/
function disableElement(event) {
    if (event && event.target) {
        $(event.target).prop('disabled', true);
    }
}
/******************************** Script to disable a element - END **************************************/
/******************************** Utility Scripts for Actions - End **********************************/
/**************************************************** Poly Fills - Start ****************************************************/
/******* Polyfill to support String.includes method  - Start *********************/
if (!String.prototype.includes) {
    String.prototype.includes = function(search, start) {
        'use strict';
        if (typeof start !== 'number') {
            start = 0;
        }
        if (start + search.length > this.length) {
            return false;
        } else {
            return this.indexOf(search, start) !== -1;
        }
    };
}
/******* Polyfill to support String.includes method  - END *********************/
/*********************** Pega.CS.Textchannel--NamespacedFunctions - START *******************/
pega.namespace("pega.cs.textchannel");
pega.cs.textchannel = (function() {
    /*start of US-259627 Always display the anchor text for the article not the URL */
    function pushArticleLink(url, title, abstract, leadintext, setleadintext, setshareabstract, event, articleID) {
        var LeadIntText = (setleadintext === 'true') ? leadintext : "";
        var Abstract = (setshareabstract === 'true') ? abstract : "";
        var finalurl = "<a class=\"articlelink\" data-articleid=\"" + articleID + "\"href=" + url + " target = '_blank'>" + title + "</a>";
        var KMArticleLink = (Abstract !== "") ? (LeadIntText + "<br>" + Abstract + "<br>" + finalurl) : (
            LeadIntText + "<br>" + finalurl);
        pega.cs.textchannel.pushTextToRTEContent(KMArticleLink, event);
    }
    /*end of US-259627 Always display the anchor text for the article not the URL */
    function pushArticleText(event) {
        var KMArticleContainer = $('.KMContent').clone();
        KMArticleContainer.find("img").remove();
        KMArticleContainer.find(".internal").remove();
        var KMArticleContent = KMArticleContainer[0].innerHTML;
        KMArticleContent = KMArticleContent.replace(/\<\/p\>/gi, "\n");
        KMArticleContent = KMArticleContent.replace(/\<br\>/gi, "\n");
        pega.cs.textchannel.pushTextToRTEContent(KMArticleContent, event);
    }
    /*For new KM react UI, as the div used is different */
 var contextData = {
    leadInText: "",
    setLeadInText: "",
    setShareAbstract: "",
    event: null
};
 function pushArticleTextKMReact(event,articleContainerDiv) {
       var KMArticleContainer = $("."+articleContainerDiv).clone();
        KMArticleContainer.find(".internal").remove();
        var KMArticleContent = KMArticleContainer[0].innerHTML;
        KMArticleContent = KMArticleContent.replace(/\<\/p\>/gi, "\n");
        KMArticleContent = KMArticleContent.replace(/\<br\>/gi, "\n");
        pega.cs.textchannel.pushTextToRTEContent(KMArticleContent, event);
    }

function setContextData(response) {
    response.ArticleAbstract = response.ArticleAbstract.replace(/(?:\\[rn])+/g, "");
    var sectionData = {
        section: "",
        event: event,
        dataTransform: {
            name: "",
            parameters: []
        },
        activity: null,
        submitOnRefresh: true
    }
    pega.cs.textchannel.pushArticleLink(response.ShareableURL, response.ArticleTitle, response.ArticleAbstract, contextData.leadInText, contextData.setLeadInText,
        contextData.setShareAbstract, contextData.event, response.pxInsName);
    if (response.IsInteractionSocial == "true") {
        sectionData.section = "SocialResponseTextArea";
        sectionData.dataTransform.name = "CopyArticleLinkIntoSocialArea";
        sectionData.dataTransform.parameters = [{ name: "LinkURL", value: url }, { name: "abstract", value: abstract }];
        pega.api.ui.actions.refreshSection(sectionData);
    }
    sectionData.section = "LoadSocialUIContext";
    sectionData.dataTransform = null;
    pega.api.ui.actions.refreshSection(sectionData);
    sectionData.section = "SocialResponseTextArea"
    sectionData.submitOnRefresh = false;
    pega.api.ui.actions.refreshSection(sectionData);
}

function handleArtilclePushKMReact(event, leadInText, contextPage, setLeadInText, setShareAbstract,pushContentLabel,pushLinkLabel,channelType) {
  if(channelType !== "chat"){
    contextData.leadInText = leadInText;
    contextData.setLeadInText = setLeadInText;
    contextData.setShareAbstract = setShareAbstract;
    contextData.event = event;
    if (event.srcElement.innerText !== null && event.srcElement.innerText !== undefined && event.srcElement.innerText.toLowerCase() === pushLinkLabel.toLowerCase()) {
        var dataPageOptions = {
            name: contextPage,
            parameters: [],
            callback: setContextData,
            event: event
        }
        pega.api.ui.actions.getDataPage(dataPageOptions);
    }
    if (event.srcElement.innerText !== null && event.srcElement.innerText !== undefined 
        && event.srcElement.innerText.toLowerCase() === pushContentLabel.toLowerCase()) {
        pega.cs.textchannel.pushArticleTextKMReact(event, "article-content-container")
    }
  }
}
    
/**************************************************end of KM react scripts*************************************************************/  
 function pushTextToRTEContent(TextValue, event) {
        var textAreaElem = pega.cs.textchannel.getCKEditorTextArea(event);
        if (textAreaElem) {
          $(textAreaElem).trigger("insertTextOn", [TextValue]);
          /*BUG-575826 -  .trigger is not working when RTE visibility is hidden. Text value is appended to iframe body instead of textArea
          $(textAreaElem).parent().find('iframe').contents().find('body').append(TextValue);*/
        }
    }
  
  
    function getCKEditorInstance(event) {
        var textAreaId = $(event.currentTarget.getElementsByClassName("cpm-textchannel-rte-component")).find(
            "textarea").attr("id");
        if (!textAreaId) {
          /* for chat, the class name comes from application settings, but it might not be defined,
             so look for it a different way */
          textAreaId = $(event.currentTarget.getElementsByClassName("PEGACKEDITOR textAreaStyle"))[0].id;
        }
        if (textAreaId) return CKEDITOR.instances[textAreaId];
    }

    function getCKEditorTextArea(event) {
        var ckeditorInstance = pega.cs.textchannel.getCKEditorInstance(event);
        if (ckeditorInstance) return ckeditorInstance.element.$;
    }

    function getDOMContext(e) {
        return e.currentTarget;
    }
    return {
        pushArticleLink: pushArticleLink,
        pushArticleText: pushArticleText,
        pushArticleTextKMReact:pushArticleTextKMReact,
        pushTextToRTEContent: pushTextToRTEContent,
        getCKEditorInstance: getCKEditorInstance,
        getCKEditorTextArea: getCKEditorTextArea,
        handleArtilclePushKMReact:handleArtilclePushKMReact,
        getDOMContext: getDOMContext
    }
})();
/*********************** Pega.CS.Textchannel--NamespacedFunctions - END *******************/
/************************************************ Poly Fills - End *********************************************************/
//static-content-hash-trigger-YUI
/* pega.cs.managertools - named space functions start*/
pega.namespace("pega.cs.managertools");
pega.cs.managertools = (function() {
    var chatQueueMonitorRefreshIntervalId, chatCsrMonitorRefreshIntervalId;
    /* below functions are used to start and stop auto refresh in queue monitor section  */
    function manageAutoRefreshForQueueMonitor() {
        chatQueueMonitorRefreshIntervalId && clearInterval(chatQueueMonitorRefreshIntervalId);
        chatCsrMonitorRefreshIntervalId && clearInterval(chatCsrMonitorRefreshIntervalId);
        var options = {
            section: "MonitoringQueues",
            event: window.event,
            activity: {
                name: "FlushMonitorDataPage"
            }
        };
        chatQueueMonitorRefreshIntervalId = setInterval(function() {
            var isElementVisible = document.getElementsByClassName("monitoringQueuesObserverClass").length ==
                0 ? false : true;
            if (isElementVisible) {
                pega.api.ui.actions.refreshSection(options);
            } else { 
                chatQueueMonitorRefreshIntervalId && clearInterval(chatQueueMonitorRefreshIntervalId);
                chatQueueMonitorRefreshIntervalId = null;
            }
        }, 30000);
    }

    function manageAutoRefreshForCsrMonitor() {
        chatQueueMonitorRefreshIntervalId && clearInterval(chatQueueMonitorRefreshIntervalId);
        chatCsrMonitorRefreshIntervalId && clearInterval(chatCsrMonitorRefreshIntervalId);
        var options = {
            section: "MonitoringCsrs",
            event: window.event,
            activity: {
                name: "FlushMonitorCSRDataPage"
            }
        };
        chatCsrMonitorRefreshIntervalId = setInterval(function() {
            var isElementVisible = document.getElementsByClassName("monitoringCsrsObserverClass").length ==
                0 ? false : true;
            if (isElementVisible) {
                pega.api.ui.actions.refreshSection(options);
            } else {
                chatCsrMonitorRefreshIntervalId && clearInterval(chatCsrMonitorRefreshIntervalId);
                chatCsrMonitorRefreshIntervalId = null;
            }
        }, 90000);
    }
    return {
        manageAutoRefreshForQueueMonitor: manageAutoRefreshForQueueMonitor,
        manageAutoRefreshForCsrMonitor: manageAutoRefreshForCsrMonitor
    }
})();
/* pega.cs.managertools - named space functions end */
//static-content-hash-trigger-YUI


/* pega.cs.commonutils - named space functions start*/
pega.namespace("pega.cs.commonutils");
pega.cs.commonutils = (function() {
    
  function _setCookie(cookieName, cookieValue, nDays) {		
		var today = new Date();		
		var expire = new Date();		
		if(nDays === null || nDays === 0)		
			nDays=1;		
		expire.setTime(today.getTime() + 3600000*24*nDays);		
		document.cookie = cookieName+"="+escape(cookieValue) + 		
			";expires="+expire.toGMTString();		
	}
	function _downloadTranscript(objClass) {
    if (typeof(objClass) == "undefined") {
      objClass = "PegaCA-Work-Interaction";
    }
    var sourceurl = new SafeURL(objClass+".DownloadCsrTranscript");
    //sourceurl.put("pzPrimaryPageName","pyWorkPage");   	
	  pega.u.d.asyncRequest("POST", SafeURL_createFromURL(sourceurl.toURL()), {
		success: function(o) {
      console.log("success");
       // parent.postMessage(JSON.stringify({command: "downloadBotTranscript", transcript:o.responseText}),sourceurl);
        var element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(o.responseText));
        element.setAttribute('download', "Transcript.txt");
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
		},
	  failure: function(o) {
		  console.log("Failed get chatbot transcript");
	  },
	  scope:this
	});
    }	
	function _readCookie(cookieName) {		
		var theCookie= "" + document.cookie;		
		var ind = theCookie.indexOf(cookieName);		
		if (ind === -1 || cookieName === "") 		
			return ""; 		
		var ind1 = theCookie.indexOf(';', ind);		
		if (ind1 === -1) 		
			ind1 = theCookie.length; 		
		return unescape(theCookie.substring(ind + cookieName.length+1, ind1));		
	}
  
  function _removeCookie(cookieName) {
    document.cookie = cookieName + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;';
  }
    return {
        setCookie: _setCookie,
        readCookie: _readCookie,
        removeCookie: _removeCookie,
        downloadTranscript:_downloadTranscript
    }
})();
/* pega.cs.managertools - named space functions end */

/********************* pega.cs.interactionguidance namespaced functions *******************/
pega.namespace("pega.cs.interactionguidance");
pega.cs.interactionguidance = (function() {
  function hideGuidance() {
    if ($("#interactionguidance").length > 0) {
      $("#interactionguidance").removeClass("alerting");
      window.setTimeout(function(){ 
        $("#interactionguidance").hide();
      },600);
    }
  }

  function showGuidance() {     
    var id = pega.ctx.strPyID;       
    var guidanceDiv = document.getElementById("interactionguidance");
    /* BUG-636869 :Perf CS 86: Memory leak observed during soak test - added check for service case context 
    to avoid loading interaction page with service case id */
    var recordid=pega.ctx.recordId;
    if (id === "" || guidanceDiv == null || (typeof recordid !== 'undefined' && recordid.includes("acprimary"))){  
      /* Not in a valid interaction or the interactionguidance placeholder is not present (dialogs disabled), 
         don't show the interaction guidance */
      return;
    }

    var oSafeURL = new SafeURL("PegaCA-Work-Interaction.GetInteractionGuidanceMessage");
    oSafeURL.put("interactionId", id);
    pega.u.d.asyncRequest("POST", oSafeURL, {
      success: function(oResponse) {
        if (oResponse.responseText != "NoInteractionGuidance") { 
          var guidance = $("#interactionguidance");
          $("#interactionguidance").show();
          guidance.addClass("alerting").html(oResponse.responseText);      
        }
      },
      failure: function() {
        /*console.log("Failure while getting interaction guidance");*/
      }
    }, null);
  }

  return {
    showGuidance: showGuidance,
    hideGuidance: hideGuidance
  }
})();

/****************** pega.cs.interactionguidance namespaced functions - End ****************/

/* Invoke the populate harness page to ensure it's ready for phrase search*/
$( document ).ready(function() {
  var interactionTypeEl = document.querySelector("[name$=InteractionType]");
  if (interactionTypeEl) {
    var recentUrl = new SafeURL("PegaCA-Work-Interaction.PopulateHarnessPage");
    recentUrl.put("channelType", interactionTypeEl.value);
    var transaction1 = pega.u.d.asyncRequest('POST', recentUrl, {
      success: function(oResponse) {
        /*
        console.log("set the harness page");
        */
      },
      failure: function() {},
        scope: this
      }, "");
  } else {
    /*
    console.log("No identifiable interaction");
    */
  }
  /* Trigger the showing of Interaction guidance after one second and remove it after 15 addl */
  /* This value is not configurable at the time, but can be made so in the future */
  window.setTimeout(pega.cs.interactionguidance.showGuidance,1000);
  window.setTimeout(pega.cs.interactionguidance.hideGuidance, 16000);
});
//static-content-hash-trigger-GCC
var socialwindow;
var loadwindow;

function resetLoadScriptFlag(){
  loadwindow="openwindow";
 }

function OpenNewWindow() {

    if (socialwindow == null) {

        socialwindow = window.open(URL, "social", "toolbar=yes,scrollbars=yes,resizable=yes,top=250,left=1150,width=1000,height=500");

    } else {


        if (socialwindow.closed) {
            socialwindow = window.open(URL, "social", "toolbar=yes,scrollbars=yes,resizable=yes,top=250,left=1150,width=1000,height=500");
        } else {
            socialwindow.location.href = URL;
        }

    }
}
function forwardSocialEvent(event) {
 /* 
console.log("Response from "+ event.detail.response.AuthorID);
console.log(event.detail.response.pyText); */
  
  var payload= event.detail.response.pyText;
  /* Show the slide-in message */
  	toastr.slideIn(payload, {timeOut: 5000, extendedTimeOut: 1000 });   
    /* Extract the case id */
  	var caseIDIndex = payload.indexOf("#CASEID#");
    var subString1 = payload.substr(caseIDIndex);
 	var caseid = subString1.replace(/(.*#@)(.*)(@#.*)/, '$2');
	
    /* for debugging
  	console.log("caseIDIndex :: "+ caseIDIndex);
    console.log("subString1 ::  "+ subString1);
    console.log("caseid ::  "+ caseid);
    */
   
    
    var oSafeURL = new SafeURL("PegaCA-Work-Interaction-Social.CSSocialRefreshSocialMessages");
    oSafeURL.put("CaseID",caseid);
    pega.u.d.asyncRequest("POST", oSafeURL); 
}

/*enable reply button for private twitter messages*/
function enableTweetReply() {  
  //var selectedButton = $("input[class='Radio rb_']:checked");
  var selectedButton = $("input[type=radio][class='Radio rb_ ']:checked").attr('value');  
  var replyButton = $(".twitter-submit-tweet-button button");  
  if(selectedButton == "Private")
   	 replyButton.removeAttr("disabled");
  
}
//static-content-hash-trigger-YUI
/*
 * Toastr
 * Copyright 2012-2015
 * Authors: John Papa, Hans Fjällemark, and Tim Ferrell.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * ARIA Support: Greta Krafsig
 *
 * Project: https://github.com/CodeSeven/toastr
 */
/* global define */
(function (define) {
    define(['jquery'], function ($) {
        return (function () {
            var $container;
            var listener;
            var toastId = 0;
            var toastType = {
                error: 'error',
                info: 'info',
                success: 'success',
                warning: 'warning',
                slideIn:'slidein'
            };

          // set `escapeHtml: false` in options when calling slideIn,error,info,success functions,
          // from other js files to show html content passed as message to the respective called function. 
          // (ex:pyinteractionutils => openAssignmentFromToasterPop)
            var toastr = {
                clear: clear,
                remove: remove,
                error: error,
                getContainer: getContainer,
                info: info,
                options: {escapeHtml: true},  
                subscribe: subscribe,
                success: success,
                version: '2.1.4',
                warning: warning,
                slideIn:slideIn
            };

            var previousToast;

            return toastr;

            ////////////////

            function error(message, title, optionsOverride) {
                return notify({
                    type: toastType.error,
                    iconClass: getOptions().iconClasses.error,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function getContainer(options, create) {
                if (!options) { options = getOptions(); }
                $container = $('#' + options.containerId);
                if ($container.length) {
                    return $container;
                }
                if (create) {
                    $container = createContainer(options);
                }
                return $container;
            }

            function info(message, title, optionsOverride) {
                return notify({
                    type: toastType.info,
                    iconClass: getOptions().iconClasses.info,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function subscribe(callback) {
                listener = callback;
            }

            function success(message, title, optionsOverride) {
                return notify({
                    type: toastType.success,
                    iconClass: getOptions().iconClasses.success,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            /* This is for CS Social portal */
            function slideIn(message, optionsOverride) {      
                return notify({
                    type: toastType.slideIn,
                    iconClass:  getOptions().iconClasses.slideIn,
                    message: message,
                    optionsOverride: optionsOverride
                });
            }

            function warning(message, title, optionsOverride) {
                return notify({
                    type: toastType.warning,
                    iconClass: getOptions().iconClasses.warning,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function clear($toastElement, clearOptions) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if (!clearToast($toastElement, options, clearOptions)) {
                    clearContainer(options);
                }
            }

            function remove($toastElement) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if ($toastElement && $(':focus', $toastElement).length === 0) {
                    removeToast($toastElement);
                    return;
                }
                if ($container.children().length) {
                    $container.remove();
                }
            }

            // internal functions

            function clearContainer (options) {
                var toastsToClear = $container.children();
                for (var i = toastsToClear.length - 1; i >= 0; i--) {
                    clearToast($(toastsToClear[i]), options);
                }
            }

            function clearToast ($toastElement, options, clearOptions) {
                var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
                    $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function () { removeToast($toastElement); }
                    });
                    return true;
                }
                return false;
            }

            function createContainer(options) {
                $container = $('<div/>')
                    .attr('id', options.containerId)
                    .addClass(options.positionClass)
                    .attr('aria-live', 'polite')
                    .attr('role', 'alert');

                $container.appendTo($(options.target));
                return $container;
            }

            function getDefaults() {
                return {
                    tapToDismiss: true,
                    toastClass: 'toast',
                    containerId: 'toast-container',
                    debug: false,

                    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
                    showDuration: 300,
                    showEasing: 'swing', //swing and linear are built into jQuery
                    onShown: undefined,
                    hideMethod: 'fadeOut',
                    hideDuration: 1000,
                    hideEasing: 'swing',
                    onHidden: undefined,
                    closeMethod: false,
                    closeDuration: false,
                    closeEasing: false,
                    closeOnHover: true,
                    closeButton :true,

                    extendedTimeOut: 1000,
                    iconClasses: {
                        error: 'toast-error',
                        info: 'toast-info',
                        success: 'toast-success',
                        warning: 'toast-warning',
                        slideIn:'toast-slidein'
                    },
                    iconClass: 'toast-info',
                    positionClass: 'toast-top-right',
                    timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
                    titleClass: 'toast-title',
                    messageClass: 'toast-message',
                    escapeHtml: false,
                    target: 'body',
                    closeHtml: '<button type="button"><span><i href="" class="pi pi-times pi-regular pi-grey" tabindex="0" role="button" title="close" alt="close icon"></i></span></button>',
                    closeClass: 'toast-close-button',
                    newestOnTop: true,
                    preventDuplicates: false,
                    progressBar: false,
                    progressClass: 'toast-progress',
                    rtl: false
                };
            }

            function publish(args) {
                if (!listener) { return; }
                listener(args);
            }

            function notify(map) {
                var options = getOptions();
                var iconClass = map.iconClass || options.iconClass;

                if (typeof (map.optionsOverride) !== 'undefined') {
                    options = $.extend(options, map.optionsOverride);
                    iconClass = map.optionsOverride.iconClass || iconClass;
                }

                if (shouldExit(options, map)) { return; }

                toastId++;

                $container = getContainer(options, true);

                var intervalId = null;
                var $toastElement = $('<div/>');
                var $titleElement = $('<div/>');
                var $messageElement = $('<div/>');
                var $progressElement = $('<div/>');
                var $closeElement = $(options.closeHtml);
                var $fadeWrapElement = $('<div/>');
                var progressBar = {
                    intervalId: null,
                    hideEta: null,
                    maxHideTime: null
                };
                var response = {
                    toastId: toastId,
                    state: 'visible',
                    startTime: new Date(),
                    options: options,
                    map: map
                };

                personalizeToast();

                displayToast();

                handleEvents();

                publish(response);

                if (options.debug && console) {
                    console.log(response);
                }

                return $toastElement;

                function escapeHtml(source) {
                    if (source == null) {
                        source = '';
                    }

                    return source
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }

                function personalizeToast() {
                    setIcon();
                    if(!map.type ==="slidein"){
                        setTitle();
                    }
                    setMessage();
                    setCloseButton();
                    setProgressBar();
                    setRTL();
                    setSequence();
                    setAria();
                    if(map.type ==="slidein"){
                        setFadingEffect();
                    }
                }

                function setAria() {
                    var ariaValue = '';
                    switch (map.iconClass) {
                        case 'toast-success':
                        case 'toast-info':
                            ariaValue =  'polite';
                            break;
                        default:
                            ariaValue = 'assertive';
                    }
                    $toastElement.attr('aria-live', ariaValue);
                }

                function handleEvents() {
                    if (options.closeOnHover) {
                        $toastElement.hover(stickAround, delayedHideToast);
                    }

                    if (!options.onclick && options.tapToDismiss) {
                        $toastElement.click(hideToast);
                    }

                    if (options.closeButton && $closeElement) {
                        $closeElement.click(function (event) {
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                event.cancelBubble = true;
                            }

                            if (options.onCloseClick) {
                                options.onCloseClick(event);
                            }

                            hideToast(true);
                        });
                    }

                    if (options.onclick) {
                        $toastElement.click(function (event) {
                            options.onclick(event);
                            hideToast();
                        });
                    }
                }

                function displayToast() {
                    if(map.type ==="slidein"){
                        $toastElement.css("right","-362px");
                        $toastElement.hide();
                        $toastElement.css("display","block").css("right","-12px").css("top","-12px").css("transition","right 0.3s cubic-bezier(0.645,0.045,0.355,1)");
                    }else{
                       $toastElement.hide();
                       $toastElement[options.showMethod](
                       {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                      );
                    }

                    $toastElement[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                    );

                    if (options.timeOut > 0) {
                        intervalId = setTimeout(hideToast, options.timeOut);
                        progressBar.maxHideTime = parseFloat(options.timeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                        if (options.progressBar) {
                            progressBar.intervalId = setInterval(updateProgress, 10);
                        }
                    }
                }

                function setIcon() {
                    if (map.iconClass) {
                        $toastElement.addClass(options.toastClass).addClass(iconClass);
                    }
                }

                function setSequence() {
                    if (options.newestOnTop) {
                        $container.prepend($toastElement);
                    } else {
                        $container.append($toastElement);
                    }
                }

                function setTitle() {
                    if (map.title) {
                        var suffix = map.title;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.title);
                        }
                        $titleElement.append(suffix).addClass(options.titleClass);
                        $toastElement.append($titleElement);
                    }
                }

                function setMessage() {
                    if (map.message) {
                        var suffix = map.message;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.message);
                        }
                        $messageElement.append(suffix).addClass(options.messageClass);
                        $toastElement.append($messageElement);
                    }
                }

                function setCloseButton() {
                    if (options.closeButton) {
                        $closeElement.addClass(options.closeClass).attr('role', 'button');
                        $toastElement.prepend($closeElement);
                    }
                }

                function setProgressBar() {
                    if (options.progressBar) {
                        $progressElement.addClass(options.progressClass);
                        $toastElement.prepend($progressElement);
                    }
                }

                function setFadingEffect(){                  
                    $fadeWrapElement.addClass('toast-fadeWrap');
                    $toastElement.append($fadeWrapElement);
                }

                function setRTL() {
                    if (options.rtl) {
                        $toastElement.addClass('rtl');
                    }
                }

                function shouldExit(options, map) {
                    if (options.preventDuplicates) {
                        if (map.message === previousToast) {
                            return true;
                        } else {
                            previousToast = map.message;
                        }
                    }
                    return false;
                }

                function hideToast(override) {
                    var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                    var duration = override && options.closeDuration !== false ?
                        options.closeDuration : options.hideDuration;
                    var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                    if ($(':focus', $toastElement).length && !override) {
                        return;
                    }
                    clearTimeout(progressBar.intervalId);
                    return $toastElement[method]({
                        duration: duration,
                        easing: easing,
                        complete: function () {
                            removeToast($toastElement);
                            clearTimeout(intervalId);
                            if (options.onHidden && response.state !== 'hidden') {
                                options.onHidden();
                            }
                            response.state = 'hidden';
                            response.endTime = new Date();
                            publish(response);
                        }
                    });
                }

                function delayedHideToast() {
                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
                        progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                    }
                }

                function stickAround() {
                    clearTimeout(intervalId);
                    progressBar.hideEta = 0;
                    $toastElement.stop(true, true)[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing}
                    );
                }

                function updateProgress() {
                    var percentage = ((progressBar.hideEta - (new Date().getTime())) / progressBar.maxHideTime) * 100;
                    $progressElement.width(percentage + '%');
                }
            }

            function getOptions() {
                return $.extend({}, getDefaults(), toastr.options);
            }

            function removeToast($toastElement) {
                if (!$container) { $container = getContainer(); }
                if ($toastElement.is(':visible')) {
                    return;
                }
                $toastElement.remove();
                $toastElement = null;
                if ($container.children().length === 0) {
                    $container.remove();
                    previousToast = undefined;
                }
            }

        })();
    });
}(typeof define === 'function' && define.amd ? define : function (deps, factory) {
    if (typeof module !== 'undefined' && module.exports) { //Node
        module.exports = factory(require('jquery'));
    } else {
        window.toastr = factory(window.jQuery);
    }
}));
//static-content-hash-trigger-YUI
$(document).ready(function() {
  	var oSafeURL = new SafeURL("@baseclass.SetCsrPresenceStatus");
	oSafeURL.put("CSRStaus","Available");
	pega.u.d.asyncRequest("POST", oSafeURL);
});
(function(cs){
  var debug = pega.ui.logger.LogHelper.debug;
  pega.desktop.registerEventListener("DesktopAction", function(actionInfo){ 
    actionInfo = actionInfo.hashtable;
    if(actionInfo.api === "WorkLoaded"){
      if(actionInfo.action.toLowerCase() === "createnewwork"){
        debug("Interaction created ", "id:"+ actionInfo.label, "handle:"+ actionInfo.key, "GadgetName:"+ actionInfo.GadgetName);
        var data = {
          id: getIntIDFromKey(actionInfo.key),
          handle: actionInfo.key,
          gadgetName: actionInfo.GadgetName
        };
        executeCallback("startInteraction", "startInteraction", data);
        fireEvent("interactionStarted", data);
      } else {
        debug("Interaction opened ", "id:"+ actionInfo.label, "handle:"+ actionInfo.key, "GadgetName:"+ actionInfo.GadgetName);
      }
    }
  });

  pega.desktop.registerEventListener("DCDocumentClose", function(data){ 
    debug("Interaction closed", "id:"+data.id, "handle:"+data.handle, "GadgetName:"+ data.gadgetName);

    data = {
      id: getIntIDFromKey(data.handle), 
      handle : data.handle,
      gadgetName : data.GadgetName
    };
    
    executeCallback("endInteraction", data.id, data);
    fireEvent("interactionEnded", data);
  });

  pega.desktop.registerEventListener('DCTabSwitch', function(data){
    debug("Switched interactions ", "from tab id:"+data.fromTab.id, 
                "handle:"+data.fromTab.handle, "GadgetName:"+ data.fromTab.GadgetName, 
                "to tab id:"+data.toTab.id, "handle:"+data.toTab.handle, 
                "GadgetName:"+ data.toTab.GadgetName);
    
    data = {
      id: getIntIDFromKey(data.toTab.handle), 
      handle : data.toTab.handle,
      gadgetName : data.toTab.GadgetName
    };
    executeCallback("switchInteraction", data.id, data);
    fireEvent("interactionSwitched", data);
  });
  
  var getIntIDFromKey = function(key){
    var insTokens = key.split(" ");
    if(insTokens.length !== 2){
       debug("Interaction level document key seems to be overriden as "+ key);
    }
    return insTokens[insTokens.length -1];
  };

  var getDCTabView = function(){
    for(var tabViewName in pega.u.d.tabViewMap){
      if(pega.u.d.tabViewMap[tabViewName].isDCTabView){
        return pega.u.d.tabViewMap[tabViewName];
      }
    }
  };

  var getTabFromTabView = function(dcTabView, workObjectID){
    var tabs = dcTabView.get("tabs");
    for(var i=0;i<tabs.length; i++){
      if(tabs[i].key && getIntIDFromKey(tabs[i].key) === workObjectID){
        return tabs[i];
      }
    }
  };
  
  var getDCTab = function(workObjectID){
    var dcTabView = getDCTabView();
    if(!dcTabView){
      throw "DCDoesNotExist";
    }
    return getTabFromTabView(dcTabView, workObjectID);
  };

  var getGadgetNameByID = function(workObjectID){
    var dcTab = getDCTab(workObjectID);
    if(!dcTab){
      throw "InteractionDoesNotExist";
    }
    return dcTab.GadgetName;
  };
  
  var getQueryString = function(paramObj){
    var sURL = new SafeURL();
    for(var paramName in paramObj){
      sURL.put(paramName, paramObj[paramName]);
    }
    return sURL.toQueryString();
  };
  
  var callbackObj = {};
  var registerCallback = function(action, identifier, callback){
    callbackObj[action] = callbackObj[action] || {};
    callbackObj[action][identifier] = callbackObj[action][identifier] || [];
    callbackObj[action][identifier].push(callback);
    console.log(callbackObj);
  };
  
  var executeCallback = function(action, identifier, data){
    if(!callbackObj[action]){
      return;
    }
    
    if(!callbackObj[action][identifier]){
      return;
    }
    
    var callback = callbackObj[action][identifier].pop();
    if(callbackObj[action][identifier].length === 0){
      delete callbackObj[action][identifier];
    }
    if(Object.keys(callbackObj[action]).length === 0){
      delete callbackObj[action];
    }
    if(callback){
      callback(data);
    }
  };
  
  var fireEvent = function(type, data){
    var evt = document.createEvent('Event');
    evt.data = data;
    evt.initEvent(type, false, false);
    window.dispatchEvent(evt);
  };

  cs.startInteraction = function(interactionClass, interactionFlow, additionalParameters, callback){
    var flowParams = getQueryString(additionalParameters);
    registerCallback("startInteraction", "startInteraction", callback);
    pega.desktop.createNewWork(interactionClass, "", interactionFlow, flowParams, "", "");
  };

  cs.switchInteraction = function(interactionID, callback){
    var dcTab = getDCTab(interactionID);
    if(!dcTab){
      throw "InteractionDoesNotExist";
    }
    registerCallback("switchInteraction", interactionID, callback);
    pega.util.Event.fireEvent(dcTab.get("element"), "click");
  };

  cs.endInteraction = function(interactionID, callback){
    var gadgetName = getGadgetNameByID(interactionID);
    if(!gadgetName){
      throw "InteractionDoesNotExist";
    }
    registerCallback("endInteraction", interactionID, callback);
    pega.ui.WorkAreaGadget.onGadgetClose(gadgetName);
  };
})(pega.CS = pega.CS || {});
pega.namespace("pega.cs");
pega.namespace("pega.cs.notificationmanager");
pega.cs.notificationmanager = (function(){
  
  var audioNotificationSound = null;
  var audioNotificationSoundRepeatCount = null;
  var allowAudioNotifications = null;
  
  function _setAudioConfig(file,count,allow){
    audioNotificationSound = new Audio(file);
    audioNotificationSoundRepeatCount = count;
    allowAudioNotifications = allow;
  }
  
  function _isCurrentDCTabInFocus(){
    var desktopWin = pega.desktop.support.getDesktopWindow();
    var tabViewMap = desktopWin.pega.u.d.tabViewMap;
    for (var tabViewName in tabViewMap) {
      var tabViewObj = tabViewMap[tabViewName];
      //if it is a DC tabview
      if (tabViewObj.isDCTabView) {
        //if the activetab thread is same as current tab threadname (stripping off, if necessary, extra like /microdc_1)
        if (tabViewObj.get("activeTab").ThreadName === pega.u.d.getThreadName().split('/')[0]) {
          return true;   
        } else {
          return false;
        }
      }else{
        return false;
      }
    }
  }
  
  function _isKmInFocus(){
    return $("body").hasClass("km-expanded");
  }
  
  function _isTextChannelInFocus(){
    return !_isKmInFocus();
  }
  
  function tabSwitchHandler(){
    console.log("Switched to Tab " + pega.u.d.getThreadName().split('/')[0]);
    var oSafeURL = new SafeURL("Work-.ResetNotificationMessageCounter");
    oSafeURL.put("IsTabInFocus", pega.cs.notificationmanager.isCurrentDCTabInFocus());
    oSafeURL.put("IsChannelInFocus", pega.cs.notificationmanager.isTextChannelInFocus());
    oSafeURL.put("AJAXTrackID", pega.ui.ChangeTrackerMap.getTracker().id);
    pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
    var transaction = pega.u.d.asyncRequest('POST', oSafeURL, {
      success: function(respObject) {
        var currentCT = pega.ui.ChangeTrackerMap.getTracker();
        currentCT.parseForChangeTrackerDiv(respObject.responseText, false);
        if(currentCT.changedPropertiesList.length > 0) {
          pega.u.d.evaluateClientConditions('TCL');
        }
        scrollRightPaneToBottom("Chat");
      },
      failure: function() {},
      scope: this
    }, null);
  }
  
  function _incrementMessage(){
    console.log("New message increment counter");
    var oSafeURL = new SafeURL("Work-.IncrementNotificationMessageCounter");
    var IsTabInFocus = pega.cs.notificationmanager.isCurrentDCTabInFocus();
    var IsChannelInFocus = pega.cs.notificationmanager.isTextChannelInFocus();
    oSafeURL.put("IsTabInFocus", IsTabInFocus);
    oSafeURL.put("IsChannelInFocus", IsChannelInFocus);
    if(!IsTabInFocus || !IsChannelInFocus){
      _initiateNotificationSoundRequest();
    }
    oSafeURL.put("AJAXTrackID", pega.ui.ChangeTrackerMap.getTracker().id);
    pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
    var transaction = pega.u.d.asyncRequest('POST', oSafeURL, {
      success: function(respObject) {
        var currentCT = pega.ui.ChangeTrackerMap.getTracker();
        currentCT.parseForChangeTrackerDiv(respObject.responseText, false);
        if(currentCT.changedPropertiesList.length > 0) {
          pega.u.d.evaluateClientConditions('TCL');
        }
      },
      failure: function() {},
      scope: this
    }, null);
  }
  
  pega.u.d.attachOnload(function() {
    pega.ui.EventsEmitter.subscribe("onTabSwitch", tabSwitchHandler, null, null, null, true);
  });
  
  function _isInteractionLoadedInDC(interactionId){
    var interactionWindowFound = false;
    window.top.$(".dc-main .iframe-wrapper>iframe").each(function(i,iframe){
      //BUG-588722 - Get the current harness context
      var currentCTX = iframe.contentWindow.window.pega.ctx;    
      //Set the context to root document to get the interaction ID
      iframe.contentWindow.window.pega.ctxmgr.setRootDocumentContext();      
      if(iframe.contentWindow.window.pega.u.d.getID() === interactionId){
        interactionWindowFound = true;
      }
      //Reset the current harness context
      iframe.contentWindow.window.pega.ctxmgr.setContext(currentCTX);      
    });
    return interactionWindowFound;
  }
  
  function _playNotificationSound(){
    if(allowAudioNotifications && !isNaN(audioNotificationSound.duration)){
      var notificationDuration = audioNotificationSound.duration * audioNotificationSoundRepeatCount * 1000;
      audioNotificationSound.pause();
      audioNotificationSound.loop = true; 
      audioNotificationSound.currentTime = 0;
      setTimeout(function(){
        audioNotificationSound.pause();
      },notificationDuration);
      audioNotificationSound.play();
    }
  }
  function _pushCSRNotification(event){
    var payloadObj= event.detail.response;
    var oSafeURL = new SafeURL("Application-Notifications.PushCSRNotificationDetails");
    oSafeURL.put("Message", payloadObj.pyMessage);
    pega.u.d.asyncRequest('POST', oSafeURL, {
      success: function(respObject) {
        var rdlNode = $('.csr-notification').removeClass("rdlHasNoRows");
        if(rdlNode.length > 0){
          pega.u.RDL.fetchAndAppend(null, {"fetchLastRow" : true, rdlNode: rdlNode.get(0)}); 
        }
      },
      failure: function() {},
      scope: this
    }, null);
  }
 
  function _initiateNotificationSoundRequest(){
    if(window.top === window.self){
      _playNotificationSound();
    }else{
      window.top.postMessage("NotifictionSound","*");
    }
  }
  
  window.addEventListener("message",function(event){
    if(event.data === "NotifictionSound"){
      _playNotificationSound(); 
    }
  });
  
  return {
    setAudioConfig: _setAudioConfig,
    isCurrentDCTabInFocus : _isCurrentDCTabInFocus,
    isKmInFocus : _isKmInFocus,
    isTextChannelInFocus : _isTextChannelInFocus,
    resetNotificationCounter : tabSwitchHandler,
    incrementMessage : _incrementMessage,
    isInteractionLoadedInDC: _isInteractionLoadedInDC,
    playNotificationSound: _initiateNotificationSoundRequest,
    pushCSRNotification: _pushCSRNotification
  }
})();
//static-content-hash-trigger-GCC
//static-content-hash-trigger-GCC
if (window.oCSFocusFactor == null) { 
  pega.namespace("pega.cs.focusfactor");

  pega.cs.focusfactor = function() {
    this.interactionData = {};
    this.intervalTimer = setInterval(this.updateFocusValues, 1000);
    this.currentFocus = "Home";
  };

  window.addEventListener("message", function(event){ 
    try{
      var message = JSON.parse(event.data);
      if(message){
      if (message.command) { 
        if (message.command === "registerInteraction"){ 
          oCSFocusFactor.registerInteraction(message);
        }
      }
    }
    }catch (e) {
      console.log("Error parsing event data in pega_focus_factor");
    } 
  });
  
  pega.cs.focusfactor.prototype = {
    /* Register a new interaction. message object contains id, thread and initial */
        registerInteraction: function(message) {
      /* console.log("Registering a new interaction "+message.id+","+message.thread+","+message.initial); */
      if (message.id) {
        var tabDiv = document.getElementById(message.tabId);
        if(oCSFocusFactor.interactionData[message.id]){
          var prevValue = oCSFocusFactor.interactionData[message.id];
          oCSFocusFactor.interactionData[message.id] = {
            id: message.id, 
            time: prevValue.time, 
            thread: message.thread,
            classname: message.classname,
            tabdiv: tabDiv,
            harness: message.harness
          }
        }
        else{
          oCSFocusFactor.interactionData[message.id] = {
            id: message.id, 
            time: message.initial ? message.initial : 0, 
            thread: message.thread,
            classname: message.classname,
            tabdiv: tabDiv,
            harness: message.harness
          };
        }
      }
    },
    
    /* Unregister a new interaction */
    unregisterInteraction: function(interactionId) {
      /* console.log("Unregistering an interaction "+interactionId); */
      if (interactionId && oCSFocusFactor.interactionData[interactionId]) {
        /* Update the focus factor time before deleting this entry */
        oCSFocusFactor.updateFocusFactorTime(interactionId,oCSFocusFactor.interactionData[interactionId].thread, 
                                             oCSFocusFactor.interactionData[interactionId].classname, oCSFocusFactor.interactionData[interactionId].time,
                                             oCSFocusFactor.interactionData[interactionId].harness);
        delete oCSFocusFactor.interactionData[interactionId];
      }
    },

    convertToTime: function(seconds) {
      if (seconds < 3600)
        return moment.utc((seconds)*1000).format('mm:ss');  
      else if (seconds < 86400 )    
        return moment.utc((seconds)*1000).format('HH:mm:ss');
      else if (seconds < 172800)       
        return parseInt(seconds/86400) + " day " + moment.utc((seconds % 86400)*1000).format('HH:mm:ss');
      else       
        return parseInt(seconds/86400) + " days " + moment.utc((seconds % 86400)*1000).format('HH:mm:ss');
   },

   updateFocusFactorTime: function(index, thread, classname, time, harness) {
     var reqURI = pega.desktop.getReqURI();
     var oSafeURL = new SafeURL("PegaCA-Work-Interaction.InvokeUpdateFocusTimes");
      oSafeURL.put("pxReqURI",reqURI);
      oSafeURL.put("FocusTime", time);
      oSafeURL.put("InteractionId", index);
      oSafeURL.put("className", classname);
      oSafeURL.put("harness", harness);     
      pega.u.d.asyncRequest('GET',SafeURL_createFromURL(oSafeURL.toURL()),{
        success:function(oResponse) {},
        failure:function() { console.log("Unable to update focus time for Interaction "+index);}
      },'');
    },

    updateFocusValues: function() {
      for(var index in oCSFocusFactor.interactionData) { 
        /* Check to see if the tab is in focus. This is the only time it should be updated */
        if (oCSFocusFactor.interactionData[index].tabdiv.className.indexOf("tab-li-t-ns-selected") !== -1) {
            oCSFocusFactor.interactionData[index].time++;
            var timestring = oCSFocusFactor.convertToTime(oCSFocusFactor.interactionData[index].time);
            var focusDiv = oCSFocusFactor.interactionData[index].tabdiv.querySelector(".FocusTime");
            if (focusDiv)
              focusDiv.text = timestring;
        }
      }
    },

    /* KEEP THIS AS THE LAST FUNCTION */
    _lastFunction: function() {}
    };
    window.oCSFocusFactor = new pega.cs.focusfactor();
  }

pega.desktop.registerEventListener("DCDocumentBeforeClose", onDcDocumentClose);
function onDcDocumentClose(paramObj){ 
  if(paramObj){
      var docObj = paramObj.docObj;
      var interactionId = docObj && docObj.getID ? docObj.getID() : '';
      if(window.oCSFocusFactor && interactionId) {
        oCSFocusFactor.unregisterInteraction(interactionId);
      } 
  }

}


  //static-content-hash-trigger-GCC
"use strict";function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance");}function _iterableToArray(iter){if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)==="[object Arguments]")return Array.from(iter);}function _arrayWithoutHoles(arr){if(Array.isArray(arr)){for(var i=0,arr2=new Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}}function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}(function(f){if((typeof exports==="undefined"?"undefined":_typeof(exports))==="object"&&typeof module!=="undefined"){module.exports=f();}else if(typeof define==="function"&&define.amd){define([],f);}else{var g;if(typeof window!=="undefined"){g=window;}else if(typeof global!=="undefined"){g=global;}else if(typeof self!=="undefined"){g=self;}else{g=this;}g.sanitizeHtml=f();}})(function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a;}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r);},p,p.exports,r,e,n,t);}return n[i].exports;}for(var u="function"==typeof require&&require,i=0;i<t.length;i++){o(t[i]);}return o;}return r;}()({1:[function(require,module,exports){'use strict';exports.byteLength=byteLength;exports.toByteArray=toByteArray;exports.fromByteArray=fromByteArray;var lookup=[];var revLookup=[];var Arr=typeof Uint8Array!=='undefined'?Uint8Array:Array;var code='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';for(var i=0,len=code.length;i<len;++i){lookup[i]=code[i];revLookup[code.charCodeAt(i)]=i;}// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)]=62;revLookup['_'.charCodeAt(0)]=63;function getLens(b64){var len=b64.length;if(len%4>0){throw new Error('Invalid string. Length must be a multiple of 4');}// Trim off extra bytes after placeholder bytes are found
// See: https://github.com/beatgammit/base64-js/issues/42
var validLen=b64.indexOf('=');if(validLen===-1)validLen=len;var placeHoldersLen=validLen===len?0:4-validLen%4;return[validLen,placeHoldersLen];}// base64 is 4/3 + up to two characters of the original data
function byteLength(b64){var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function _byteLength(b64,validLen,placeHoldersLen){return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function toByteArray(b64){var tmp;var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];var arr=new Arr(_byteLength(b64,validLen,placeHoldersLen));var curByte=0;// if there are placeholders, only get up to the last complete 4 chars
var len=placeHoldersLen>0?validLen-4:validLen;var i;for(i=0;i<len;i+=4){tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)];arr[curByte++]=tmp>>16&0xFF;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===2){tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===1){tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}return arr;}function tripletToBase64(num){return lookup[num>>18&0x3F]+lookup[num>>12&0x3F]+lookup[num>>6&0x3F]+lookup[num&0x3F];}function encodeChunk(uint8,start,end){var tmp;var output=[];for(var i=start;i<end;i+=3){tmp=(uint8[i]<<16&0xFF0000)+(uint8[i+1]<<8&0xFF00)+(uint8[i+2]&0xFF);output.push(tripletToBase64(tmp));}return output.join('');}function fromByteArray(uint8){var tmp;var len=uint8.length;var extraBytes=len%3;// if we have 1 byte left, pad 2 bytes
var parts=[];var maxChunkLength=16383;// must be multiple of 3
// go through the array every three bytes, we'll deal with trailing stuff later
for(var i=0,len2=len-extraBytes;i<len2;i+=maxChunkLength){parts.push(encodeChunk(uint8,i,i+maxChunkLength>len2?len2:i+maxChunkLength));}// pad the end with zeros, but make sure to not forget the extra bytes
if(extraBytes===1){tmp=uint8[len-1];parts.push(lookup[tmp>>2]+lookup[tmp<<4&0x3F]+'==');}else if(extraBytes===2){tmp=(uint8[len-2]<<8)+uint8[len-1];parts.push(lookup[tmp>>10]+lookup[tmp>>4&0x3F]+lookup[tmp<<2&0x3F]+'=');}return parts.join('');}},{}],2:[function(require,module,exports){},{}],3:[function(require,module,exports){(function(Buffer){/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */'use strict';var base64=require('base64-js');var ieee754=require('ieee754');var customInspectSymbol=typeof Symbol==='function'&&typeof Symbol["for"]==='function'?Symbol["for"]('nodejs.util.inspect.custom'):null;exports.Buffer=Buffer;exports.SlowBuffer=SlowBuffer;exports.INSPECT_MAX_BYTES=50;var K_MAX_LENGTH=0x7fffffff;exports.kMaxLength=K_MAX_LENGTH;/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!=='undefined'&&typeof console.error==='function'){console.error('This browser lacks typed array (Uint8Array) support which is required by '+'`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');}function typedArraySupport(){// Can typed array instances can be augmented?
try{var arr=new Uint8Array(1);var proto={foo:function foo(){return 42;}};Object.setPrototypeOf(proto,Uint8Array.prototype);Object.setPrototypeOf(arr,proto);return arr.foo()===42;}catch(e){return false;}}Object.defineProperty(Buffer.prototype,'parent',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.buffer;}});Object.defineProperty(Buffer.prototype,'offset',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset;}});function createBuffer(length){if(length>K_MAX_LENGTH){throw new RangeError('The value "'+length+'" is invalid for option "size"');}// Return an augmented `Uint8Array` instance
var buf=new Uint8Array(length);Object.setPrototypeOf(buf,Buffer.prototype);return buf;}/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */function Buffer(arg,encodingOrOffset,length){// Common case.
if(typeof arg==='number'){if(typeof encodingOrOffset==='string'){throw new TypeError('The "string" argument must be of type string. Received type number');}return allocUnsafe(arg);}return from(arg,encodingOrOffset,length);}// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if(typeof Symbol!=='undefined'&&Symbol.species!=null&&Buffer[Symbol.species]===Buffer){Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:true,enumerable:false,writable:false});}Buffer.poolSize=8192;// not used by this implementation
function from(value,encodingOrOffset,length){if(typeof value==='string'){return fromString(value,encodingOrOffset);}if(ArrayBuffer.isView(value)){return fromArrayLike(value);}if(value==null){throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}if(isInstance(value,ArrayBuffer)||value&&isInstance(value.buffer,ArrayBuffer)){return fromArrayBuffer(value,encodingOrOffset,length);}if(typeof value==='number'){throw new TypeError('The "value" argument must not be of type number. Received type number');}var valueOf=value.valueOf&&value.valueOf();if(valueOf!=null&&valueOf!==value){return Buffer.from(valueOf,encodingOrOffset,length);}var b=fromObject(value);if(b)return b;if(typeof Symbol!=='undefined'&&Symbol.toPrimitive!=null&&typeof value[Symbol.toPrimitive]==='function'){return Buffer.from(value[Symbol.toPrimitive]('string'),encodingOrOffset,length);}throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/Buffer.from=function(value,encodingOrOffset,length){return from(value,encodingOrOffset,length);};// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(size){if(typeof size!=='number'){throw new TypeError('"size" argument must be of type number');}else if(size<0){throw new RangeError('The value "'+size+'" is invalid for option "size"');}}function alloc(size,fill,encoding){assertSize(size);if(size<=0){return createBuffer(size);}if(fill!==undefined){// Only pay attention to encoding if it's a string. This
// prevents accidentally sending in a number that would
// be interpretted as a start offset.
return typeof encoding==='string'?createBuffer(size).fill(fill,encoding):createBuffer(size).fill(fill);}return createBuffer(size);}/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/Buffer.alloc=function(size,fill,encoding){return alloc(size,fill,encoding);};function allocUnsafe(size){assertSize(size);return createBuffer(size<0?0:checked(size)|0);}/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */Buffer.allocUnsafe=function(size){return allocUnsafe(size);};/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */Buffer.allocUnsafeSlow=function(size){return allocUnsafe(size);};function fromString(string,encoding){if(typeof encoding!=='string'||encoding===''){encoding='utf8';}if(!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}var length=byteLength(string,encoding)|0;var buf=createBuffer(length);var actual=buf.write(string,encoding);if(actual!==length){// Writing a hex string, for example, that contains invalid characters will
// cause everything after the first invalid character to be ignored. (e.g.
// 'abxxcd' will be treated as 'ab')
buf=buf.slice(0,actual);}return buf;}function fromArrayLike(array){var length=array.length<0?0:checked(array.length)|0;var buf=createBuffer(length);for(var i=0;i<length;i+=1){buf[i]=array[i]&255;}return buf;}function fromArrayBuffer(array,byteOffset,length){if(byteOffset<0||array.byteLength<byteOffset){throw new RangeError('"offset" is outside of buffer bounds');}if(array.byteLength<byteOffset+(length||0)){throw new RangeError('"length" is outside of buffer bounds');}var buf;if(byteOffset===undefined&&length===undefined){buf=new Uint8Array(array);}else if(length===undefined){buf=new Uint8Array(array,byteOffset);}else{buf=new Uint8Array(array,byteOffset,length);}// Return an augmented `Uint8Array` instance
Object.setPrototypeOf(buf,Buffer.prototype);return buf;}function fromObject(obj){if(Buffer.isBuffer(obj)){var len=checked(obj.length)|0;var buf=createBuffer(len);if(buf.length===0){return buf;}obj.copy(buf,0,0,len);return buf;}if(obj.length!==undefined){if(typeof obj.length!=='number'||numberIsNaN(obj.length)){return createBuffer(0);}return fromArrayLike(obj);}if(obj.type==='Buffer'&&Array.isArray(obj.data)){return fromArrayLike(obj.data);}}function checked(length){// Note: cannot use `length < K_MAX_LENGTH` here because that fails when
// length is NaN (which is otherwise coerced to zero.)
if(length>=K_MAX_LENGTH){throw new RangeError('Attempt to allocate Buffer larger than maximum '+'size: 0x'+K_MAX_LENGTH.toString(16)+' bytes');}return length|0;}function SlowBuffer(length){if(+length!=length){// eslint-disable-line eqeqeq
length=0;}return Buffer.alloc(+length);}Buffer.isBuffer=function isBuffer(b){return b!=null&&b._isBuffer===true&&b!==Buffer.prototype;// so Buffer.isBuffer(Buffer.prototype) will be false
};Buffer.compare=function compare(a,b){if(isInstance(a,Uint8Array))a=Buffer.from(a,a.offset,a.byteLength);if(isInstance(b,Uint8Array))b=Buffer.from(b,b.offset,b.byteLength);if(!Buffer.isBuffer(a)||!Buffer.isBuffer(b)){throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');}if(a===b)return 0;var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len;++i){if(a[i]!==b[i]){x=a[i];y=b[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};Buffer.isEncoding=function isEncoding(encoding){switch(String(encoding).toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return true;default:return false;}};Buffer.concat=function concat(list,length){if(!Array.isArray(list)){throw new TypeError('"list" argument must be an Array of Buffers');}if(list.length===0){return Buffer.alloc(0);}var i;if(length===undefined){length=0;for(i=0;i<list.length;++i){length+=list[i].length;}}var buffer=Buffer.allocUnsafe(length);var pos=0;for(i=0;i<list.length;++i){var buf=list[i];if(isInstance(buf,Uint8Array)){buf=Buffer.from(buf);}if(!Buffer.isBuffer(buf)){throw new TypeError('"list" argument must be an Array of Buffers');}buf.copy(buffer,pos);pos+=buf.length;}return buffer;};function byteLength(string,encoding){if(Buffer.isBuffer(string)){return string.length;}if(ArrayBuffer.isView(string)||isInstance(string,ArrayBuffer)){return string.byteLength;}if(typeof string!=='string'){throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. '+'Received type '+_typeof(string));}var len=string.length;var mustMatch=arguments.length>2&&arguments[2]===true;if(!mustMatch&&len===0)return 0;// Use a for loop to avoid recursion
var loweredCase=false;for(;;){switch(encoding){case'ascii':case'latin1':case'binary':return len;case'utf8':case'utf-8':return utf8ToBytes(string).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return len*2;case'hex':return len>>>1;case'base64':return base64ToBytes(string).length;default:if(loweredCase){return mustMatch?-1:utf8ToBytes(string).length;// assume utf8
}encoding=(''+encoding).toLowerCase();loweredCase=true;}}}Buffer.byteLength=byteLength;function slowToString(encoding,start,end){var loweredCase=false;// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
// property of a typed array.
// This behaves neither like String nor Uint8Array in that we set start/end
// to their upper/lower bounds if the value passed is out of range.
// undefined is handled specially as per ECMA-262 6th Edition,
// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
if(start===undefined||start<0){start=0;}// Return early if start > this.length. Done here to prevent potential uint32
// coercion fail below.
if(start>this.length){return'';}if(end===undefined||end>this.length){end=this.length;}if(end<=0){return'';}// Force coersion to uint32. This will also coerce falsey/NaN values to 0.
end>>>=0;start>>>=0;if(end<=start){return'';}if(!encoding)encoding='utf8';while(true){switch(encoding){case'hex':return hexSlice(this,start,end);case'utf8':case'utf-8':return utf8Slice(this,start,end);case'ascii':return asciiSlice(this,start,end);case'latin1':case'binary':return latin1Slice(this,start,end);case'base64':return base64Slice(this,start,end);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return utf16leSlice(this,start,end);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(encoding+'').toLowerCase();loweredCase=true;}}}// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer=true;function swap(b,n,m){var i=b[n];b[n]=b[m];b[m]=i;}Buffer.prototype.swap16=function swap16(){var len=this.length;if(len%2!==0){throw new RangeError('Buffer size must be a multiple of 16-bits');}for(var i=0;i<len;i+=2){swap(this,i,i+1);}return this;};Buffer.prototype.swap32=function swap32(){var len=this.length;if(len%4!==0){throw new RangeError('Buffer size must be a multiple of 32-bits');}for(var i=0;i<len;i+=4){swap(this,i,i+3);swap(this,i+1,i+2);}return this;};Buffer.prototype.swap64=function swap64(){var len=this.length;if(len%8!==0){throw new RangeError('Buffer size must be a multiple of 64-bits');}for(var i=0;i<len;i+=8){swap(this,i,i+7);swap(this,i+1,i+6);swap(this,i+2,i+5);swap(this,i+3,i+4);}return this;};Buffer.prototype.toString=function toString(){var length=this.length;if(length===0)return'';if(arguments.length===0)return utf8Slice(this,0,length);return slowToString.apply(this,arguments);};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(b){if(!Buffer.isBuffer(b))throw new TypeError('Argument must be a Buffer');if(this===b)return true;return Buffer.compare(this,b)===0;};Buffer.prototype.inspect=function inspect(){var str='';var max=exports.INSPECT_MAX_BYTES;str=this.toString('hex',0,max).replace(/(.{2})/g,'$1 ').trim();if(this.length>max)str+=' ... ';return'<Buffer '+str+'>';};if(customInspectSymbol){Buffer.prototype[customInspectSymbol]=Buffer.prototype.inspect;}Buffer.prototype.compare=function compare(target,start,end,thisStart,thisEnd){if(isInstance(target,Uint8Array)){target=Buffer.from(target,target.offset,target.byteLength);}if(!Buffer.isBuffer(target)){throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. '+'Received type '+_typeof(target));}if(start===undefined){start=0;}if(end===undefined){end=target?target.length:0;}if(thisStart===undefined){thisStart=0;}if(thisEnd===undefined){thisEnd=this.length;}if(start<0||end>target.length||thisStart<0||thisEnd>this.length){throw new RangeError('out of range index');}if(thisStart>=thisEnd&&start>=end){return 0;}if(thisStart>=thisEnd){return-1;}if(start>=end){return 1;}start>>>=0;end>>>=0;thisStart>>>=0;thisEnd>>>=0;if(this===target)return 0;var x=thisEnd-thisStart;var y=end-start;var len=Math.min(x,y);var thisCopy=this.slice(thisStart,thisEnd);var targetCopy=target.slice(start,end);for(var i=0;i<len;++i){if(thisCopy[i]!==targetCopy[i]){x=thisCopy[i];y=targetCopy[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){// Empty buffer means no match
if(buffer.length===0)return-1;// Normalize byteOffset
if(typeof byteOffset==='string'){encoding=byteOffset;byteOffset=0;}else if(byteOffset>0x7fffffff){byteOffset=0x7fffffff;}else if(byteOffset<-0x80000000){byteOffset=-0x80000000;}byteOffset=+byteOffset;// Coerce to Number.
if(numberIsNaN(byteOffset)){// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
byteOffset=dir?0:buffer.length-1;}// Normalize byteOffset: negative offsets start from the end of the buffer
if(byteOffset<0)byteOffset=buffer.length+byteOffset;if(byteOffset>=buffer.length){if(dir)return-1;else byteOffset=buffer.length-1;}else if(byteOffset<0){if(dir)byteOffset=0;else return-1;}// Normalize val
if(typeof val==='string'){val=Buffer.from(val,encoding);}// Finally, search either indexOf (if dir is true) or lastIndexOf
if(Buffer.isBuffer(val)){// Special case: looking for empty string/buffer always fails
if(val.length===0){return-1;}return arrayIndexOf(buffer,val,byteOffset,encoding,dir);}else if(typeof val==='number'){val=val&0xFF;// Search for a byte value [0-255]
if(typeof Uint8Array.prototype.indexOf==='function'){if(dir){return Uint8Array.prototype.indexOf.call(buffer,val,byteOffset);}else{return Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset);}}return arrayIndexOf(buffer,[val],byteOffset,encoding,dir);}throw new TypeError('val must be string, number or Buffer');}function arrayIndexOf(arr,val,byteOffset,encoding,dir){var indexSize=1;var arrLength=arr.length;var valLength=val.length;if(encoding!==undefined){encoding=String(encoding).toLowerCase();if(encoding==='ucs2'||encoding==='ucs-2'||encoding==='utf16le'||encoding==='utf-16le'){if(arr.length<2||val.length<2){return-1;}indexSize=2;arrLength/=2;valLength/=2;byteOffset/=2;}}function read(buf,i){if(indexSize===1){return buf[i];}else{return buf.readUInt16BE(i*indexSize);}}var i;if(dir){var foundIndex=-1;for(i=byteOffset;i<arrLength;i++){if(read(arr,i)===read(val,foundIndex===-1?0:i-foundIndex)){if(foundIndex===-1)foundIndex=i;if(i-foundIndex+1===valLength)return foundIndex*indexSize;}else{if(foundIndex!==-1)i-=i-foundIndex;foundIndex=-1;}}}else{if(byteOffset+valLength>arrLength)byteOffset=arrLength-valLength;for(i=byteOffset;i>=0;i--){var found=true;for(var j=0;j<valLength;j++){if(read(arr,i+j)!==read(val,j)){found=false;break;}}if(found)return i;}}return-1;}Buffer.prototype.includes=function includes(val,byteOffset,encoding){return this.indexOf(val,byteOffset,encoding)!==-1;};Buffer.prototype.indexOf=function indexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,true);};Buffer.prototype.lastIndexOf=function lastIndexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,false);};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining;}else{length=Number(length);if(length>remaining){length=remaining;}}var strLen=string.length;if(length>strLen/2){length=strLen/2;}for(var i=0;i<length;++i){var parsed=parseInt(string.substr(i*2,2),16);if(numberIsNaN(parsed))return i;buf[offset+i]=parsed;}return i;}function utf8Write(buf,string,offset,length){return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length);}function asciiWrite(buf,string,offset,length){return blitBuffer(asciiToBytes(string),buf,offset,length);}function latin1Write(buf,string,offset,length){return asciiWrite(buf,string,offset,length);}function base64Write(buf,string,offset,length){return blitBuffer(base64ToBytes(string),buf,offset,length);}function ucs2Write(buf,string,offset,length){return blitBuffer(utf16leToBytes(string,buf.length-offset),buf,offset,length);}Buffer.prototype.write=function write(string,offset,length,encoding){// Buffer#write(string)
if(offset===undefined){encoding='utf8';length=this.length;offset=0;// Buffer#write(string, encoding)
}else if(length===undefined&&typeof offset==='string'){encoding=offset;length=this.length;offset=0;// Buffer#write(string, offset[, length][, encoding])
}else if(isFinite(offset)){offset=offset>>>0;if(isFinite(length)){length=length>>>0;if(encoding===undefined)encoding='utf8';}else{encoding=length;length=undefined;}}else{throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');}var remaining=this.length-offset;if(length===undefined||length>remaining)length=remaining;if(string.length>0&&(length<0||offset<0)||offset>this.length){throw new RangeError('Attempt to write outside buffer bounds');}if(!encoding)encoding='utf8';var loweredCase=false;for(;;){switch(encoding){case'hex':return hexWrite(this,string,offset,length);case'utf8':case'utf-8':return utf8Write(this,string,offset,length);case'ascii':return asciiWrite(this,string,offset,length);case'latin1':case'binary':return latin1Write(this,string,offset,length);case'base64':// Warning: maxLength not taken into account in base64Write
return base64Write(this,string,offset,length);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return ucs2Write(this,string,offset,length);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(''+encoding).toLowerCase();loweredCase=true;}}};Buffer.prototype.toJSON=function toJSON(){return{type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)};};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return base64.fromByteArray(buf);}else{return base64.fromByteArray(buf.slice(start,end));}}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);var res=[];var i=start;while(i<end){var firstByte=buf[i];var codePoint=null;var bytesPerSequence=firstByte>0xEF?4:firstByte>0xDF?3:firstByte>0xBF?2:1;if(i+bytesPerSequence<=end){var secondByte,thirdByte,fourthByte,tempCodePoint;switch(bytesPerSequence){case 1:if(firstByte<0x80){codePoint=firstByte;}break;case 2:secondByte=buf[i+1];if((secondByte&0xC0)===0x80){tempCodePoint=(firstByte&0x1F)<<0x6|secondByte&0x3F;if(tempCodePoint>0x7F){codePoint=tempCodePoint;}}break;case 3:secondByte=buf[i+1];thirdByte=buf[i+2];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0xC|(secondByte&0x3F)<<0x6|thirdByte&0x3F;if(tempCodePoint>0x7FF&&(tempCodePoint<0xD800||tempCodePoint>0xDFFF)){codePoint=tempCodePoint;}}break;case 4:secondByte=buf[i+1];thirdByte=buf[i+2];fourthByte=buf[i+3];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80&&(fourthByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0x12|(secondByte&0x3F)<<0xC|(thirdByte&0x3F)<<0x6|fourthByte&0x3F;if(tempCodePoint>0xFFFF&&tempCodePoint<0x110000){codePoint=tempCodePoint;}}}}if(codePoint===null){// we did not generate a valid codePoint so insert a
// replacement char (U+FFFD) and advance only 1 byte
codePoint=0xFFFD;bytesPerSequence=1;}else if(codePoint>0xFFFF){// encode to utf16 (surrogate pair dance)
codePoint-=0x10000;res.push(codePoint>>>10&0x3FF|0xD800);codePoint=0xDC00|codePoint&0x3FF;}res.push(codePoint);i+=bytesPerSequence;}return decodeCodePointsArray(res);}// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH=0x1000;function decodeCodePointsArray(codePoints){var len=codePoints.length;if(len<=MAX_ARGUMENTS_LENGTH){return String.fromCharCode.apply(String,codePoints);// avoid extra slice()
}// Decode in chunks to avoid "call stack size exceeded".
var res='';var i=0;while(i<len){res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH));}return res;}function asciiSlice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]&0x7F);}return ret;}function latin1Slice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]);}return ret;}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out='';for(var i=start;i<end;++i){out+=hexSliceLookupTable[buf[i]];}return out;}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res='';for(var i=0;i<bytes.length;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256);}return res;}Buffer.prototype.slice=function slice(start,end){var len=this.length;start=~~start;end=end===undefined?len:~~end;if(start<0){start+=len;if(start<0)start=0;}else if(start>len){start=len;}if(end<0){end+=len;if(end<0)end=0;}else if(end>len){end=len;}if(end<start)end=start;var newBuf=this.subarray(start,end);// Return an augmented `Uint8Array` instance
Object.setPrototypeOf(newBuf,Buffer.prototype);return newBuf;};/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */function checkOffset(offset,ext,length){if(offset%1!==0||offset<0)throw new RangeError('offset is not uint');if(offset+ext>length)throw new RangeError('Trying to access beyond buffer length');}Buffer.prototype.readUIntLE=function readUIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}return val;};Buffer.prototype.readUIntBE=function readUIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){checkOffset(offset,byteLength,this.length);}var val=this[offset+--byteLength];var mul=1;while(byteLength>0&&(mul*=0x100)){val+=this[offset+--byteLength]*mul;}return val;};Buffer.prototype.readUInt8=function readUInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);return this[offset];};Buffer.prototype.readUInt16LE=function readUInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]|this[offset+1]<<8;};Buffer.prototype.readUInt16BE=function readUInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]<<8|this[offset+1];};Buffer.prototype.readUInt32LE=function readUInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return(this[offset]|this[offset+1]<<8|this[offset+2]<<16)+this[offset+3]*0x1000000;};Buffer.prototype.readUInt32BE=function readUInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]*0x1000000+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3]);};Buffer.prototype.readIntLE=function readIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readIntBE=function readIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var i=byteLength;var mul=1;var val=this[offset+--i];while(i>0&&(mul*=0x100)){val+=this[offset+--i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readInt8=function readInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);if(!(this[offset]&0x80))return this[offset];return(0xff-this[offset]+1)*-1;};Buffer.prototype.readInt16LE=function readInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset]|this[offset+1]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt16BE=function readInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset+1]|this[offset]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt32LE=function readInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24;};Buffer.prototype.readInt32BE=function readInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3];};Buffer.prototype.readFloatLE=function readFloatLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,true,23,4);};Buffer.prototype.readFloatBE=function readFloatBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,false,23,4);};Buffer.prototype.readDoubleLE=function readDoubleLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,true,52,8);};Buffer.prototype.readDoubleBE=function readDoubleBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,false,52,8);};function checkInt(buf,value,offset,ext,max,min){if(!Buffer.isBuffer(buf))throw new TypeError('"buffer" argument must be a Buffer instance');if(value>max||value<min)throw new RangeError('"value" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError('Index out of range');}Buffer.prototype.writeUIntLE=function writeUIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var mul=1;var i=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUIntBE=function writeUIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var i=byteLength-1;var mul=1;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUInt8=function writeUInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0xff,0);this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeUInt16LE=function writeUInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeUInt16BE=function writeUInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeUInt32LE=function writeUInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset+3]=value>>>24;this[offset+2]=value>>>16;this[offset+1]=value>>>8;this[offset]=value&0xff;return offset+4;};Buffer.prototype.writeUInt32BE=function writeUInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};Buffer.prototype.writeIntLE=function writeIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=0;var mul=1;var sub=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i-1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeIntBE=function writeIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=byteLength-1;var mul=1;var sub=0;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i+1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeInt8=function writeInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0x7f,-0x80);if(value<0)value=0xff+value+1;this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeInt16LE=function writeInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeInt16BE=function writeInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeInt32LE=function writeInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);this[offset]=value&0xff;this[offset+1]=value>>>8;this[offset+2]=value>>>16;this[offset+3]=value>>>24;return offset+4;};Buffer.prototype.writeInt32BE=function writeInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);if(value<0)value=0xffffffff+value+1;this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError('Index out of range');if(offset<0)throw new RangeError('Index out of range');}function writeFloat(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,4,3.4028234663852886e+38,-3.4028234663852886e+38);}ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4;}Buffer.prototype.writeFloatLE=function writeFloatLE(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert);};Buffer.prototype.writeFloatBE=function writeFloatBE(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert);};function writeDouble(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,8,1.7976931348623157E+308,-1.7976931348623157E+308);}ieee754.write(buf,value,offset,littleEndian,52,8);return offset+8;}Buffer.prototype.writeDoubleLE=function writeDoubleLE(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert);};Buffer.prototype.writeDoubleBE=function writeDoubleBE(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert);};// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy=function copy(target,targetStart,start,end){if(!Buffer.isBuffer(target))throw new TypeError('argument should be a Buffer');if(!start)start=0;if(!end&&end!==0)end=this.length;if(targetStart>=target.length)targetStart=target.length;if(!targetStart)targetStart=0;if(end>0&&end<start)end=start;// Copy 0 bytes; we're done
if(end===start)return 0;if(target.length===0||this.length===0)return 0;// Fatal error conditions
if(targetStart<0){throw new RangeError('targetStart out of bounds');}if(start<0||start>=this.length)throw new RangeError('Index out of range');if(end<0)throw new RangeError('sourceEnd out of bounds');// Are we oob?
if(end>this.length)end=this.length;if(target.length-targetStart<end-start){end=target.length-targetStart+start;}var len=end-start;if(this===target&&typeof Uint8Array.prototype.copyWithin==='function'){// Use built-in when available, missing from IE11
this.copyWithin(targetStart,start,end);}else if(this===target&&start<targetStart&&targetStart<end){// descending copy from end
for(var i=len-1;i>=0;--i){target[i+targetStart]=this[i+start];}}else{Uint8Array.prototype.set.call(target,this.subarray(start,end),targetStart);}return len;};// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill=function fill(val,start,end,encoding){// Handle string cases:
if(typeof val==='string'){if(typeof start==='string'){encoding=start;start=0;end=this.length;}else if(typeof end==='string'){encoding=end;end=this.length;}if(encoding!==undefined&&typeof encoding!=='string'){throw new TypeError('encoding must be a string');}if(typeof encoding==='string'&&!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}if(val.length===1){var code=val.charCodeAt(0);if(encoding==='utf8'&&code<128||encoding==='latin1'){// Fast path: If `val` fits into a single byte, use that numeric value.
val=code;}}}else if(typeof val==='number'){val=val&255;}else if(typeof val==='boolean'){val=Number(val);}// Invalid ranges are not set to a default, so can range check early.
if(start<0||this.length<start||this.length<end){throw new RangeError('Out of range index');}if(end<=start){return this;}start=start>>>0;end=end===undefined?this.length:end>>>0;if(!val)val=0;var i;if(typeof val==='number'){for(i=start;i<end;++i){this[i]=val;}}else{var bytes=Buffer.isBuffer(val)?val:Buffer.from(val,encoding);var len=bytes.length;if(len===0){throw new TypeError('The value "'+val+'" is invalid for argument "value"');}for(i=0;i<end-start;++i){this[i+start]=bytes[i%len];}}return this;};// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g;function base64clean(str){// Node takes equal signs as end of the Base64 encoding
str=str.split('=')[0];// Node strips out invalid characters like \n and \t from the string, base64-js does not
str=str.trim().replace(INVALID_BASE64_RE,'');// Node converts strings with length < 2 to ''
if(str.length<2)return'';// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
while(str.length%4!==0){str=str+'=';}return str;}function utf8ToBytes(string,units){units=units||Infinity;var codePoint;var length=string.length;var leadSurrogate=null;var bytes=[];for(var i=0;i<length;++i){codePoint=string.charCodeAt(i);// is surrogate component
if(codePoint>0xD7FF&&codePoint<0xE000){// last char was a lead
if(!leadSurrogate){// no lead yet
if(codePoint>0xDBFF){// unexpected trail
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}else if(i+1===length){// unpaired lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}// valid lead
leadSurrogate=codePoint;continue;}// 2 leads in a row
if(codePoint<0xDC00){if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);leadSurrogate=codePoint;continue;}// valid surrogate pair
codePoint=(leadSurrogate-0xD800<<10|codePoint-0xDC00)+0x10000;}else if(leadSurrogate){// valid bmp char, but last char was a lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);}leadSurrogate=null;// encode utf8
if(codePoint<0x80){if((units-=1)<0)break;bytes.push(codePoint);}else if(codePoint<0x800){if((units-=2)<0)break;bytes.push(codePoint>>0x6|0xC0,codePoint&0x3F|0x80);}else if(codePoint<0x10000){if((units-=3)<0)break;bytes.push(codePoint>>0xC|0xE0,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else if(codePoint<0x110000){if((units-=4)<0)break;bytes.push(codePoint>>0x12|0xF0,codePoint>>0xC&0x3F|0x80,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else{throw new Error('Invalid code point');}}return bytes;}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;++i){// Node's code seems to be doing this and not & 0x7F..
byteArray.push(str.charCodeAt(i)&0xFF);}return byteArray;}function utf16leToBytes(str,units){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;++i){if((units-=2)<0)break;c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi);}return byteArray;}function base64ToBytes(str){return base64.toByteArray(base64clean(str));}function blitBuffer(src,dst,offset,length){for(var i=0;i<length;++i){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i];}return i;}// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj,type){return obj instanceof type||obj!=null&&obj.constructor!=null&&obj.constructor.name!=null&&obj.constructor.name===type.name;}function numberIsNaN(obj){// For IE11 support
return obj!==obj;// eslint-disable-line no-self-compare
}// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable=function(){var alphabet='0123456789abcdef';var table=new Array(256);for(var i=0;i<16;++i){var i16=i*16;for(var j=0;j<16;++j){table[i16+j]=alphabet[i]+alphabet[j];}}return table;}();}).call(this,require("buffer").Buffer);},{"base64-js":1,"buffer":3,"ieee754":40}],4:[function(require,module,exports){module.exports={"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}};},{}],5:[function(require,module,exports){/*
  Module dependencies
*/var ElementType=require('domelementtype');var entities=require('entities');/* mixed-case SVG and MathML tags & attributes
   recognized by the HTML parser, see
   https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
*/var foreignNames=require('./foreignNames.json');foreignNames.elementNames.__proto__=null;/* use as a simple dictionary */foreignNames.attributeNames.__proto__=null;var unencodedElements={__proto__:null,style:true,script:true,xmp:true,iframe:true,noembed:true,noframes:true,plaintext:true,noscript:true};/*
  Format attributes
*/function formatAttrs(attributes,opts){if(!attributes)return;var output='';var value;// Loop through the attributes
for(var key in attributes){value=attributes[key];if(output){output+=' ';}if(opts.xmlMode==='foreign'){/* fix up mixed-case attribute names */key=foreignNames.attributeNames[key]||key;}output+=key;if(value!==null&&value!==''||opts.xmlMode){output+='="'+(opts.decodeEntities?entities.encodeXML(value):value.replace(/\"/g,'&quot;'))+'"';}}return output;}/*
  Self-enclosing tags (stolen from node-htmlparser)
*/var singleTag={__proto__:null,area:true,base:true,basefont:true,br:true,col:true,command:true,embed:true,frame:true,hr:true,img:true,input:true,isindex:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};var render=module.exports=function(dom,opts){if(!Array.isArray(dom)&&!dom.cheerio)dom=[dom];opts=opts||{};var output='';for(var i=0;i<dom.length;i++){var elem=dom[i];if(elem.type==='root')output+=render(elem.children,opts);else if(ElementType.isTag(elem))output+=renderTag(elem,opts);else if(elem.type===ElementType.Directive)output+=renderDirective(elem);else if(elem.type===ElementType.Comment)output+=renderComment(elem);else if(elem.type===ElementType.CDATA)output+=renderCdata(elem);else output+=renderText(elem,opts);}return output;};var foreignModeIntegrationPoints=['mi','mo','mn','ms','mtext','annotation-xml','foreignObject','desc','title'];function renderTag(elem,opts){// Handle SVG / MathML in HTML
if(opts.xmlMode==='foreign'){/* fix up mixed-case element names */elem.name=foreignNames.elementNames[elem.name]||elem.name;/* exit foreign mode at integration points */if(elem.parent&&foreignModeIntegrationPoints.indexOf(elem.parent.name)>=0)opts=Object.assign({},opts,{xmlMode:false});}if(!opts.xmlMode&&['svg','math'].indexOf(elem.name)>=0){opts=Object.assign({},opts,{xmlMode:'foreign'});}var tag='<'+elem.name;var attribs=formatAttrs(elem.attribs,opts);if(attribs){tag+=' '+attribs;}if(opts.xmlMode&&(!elem.children||elem.children.length===0)){tag+='/>';}else{tag+='>';if(elem.children){tag+=render(elem.children,opts);}if(!singleTag[elem.name]||opts.xmlMode){tag+='</'+elem.name+'>';}}return tag;}function renderDirective(elem){return'<'+elem.data+'>';}function renderText(elem,opts){var data=elem.data||'';// if entities weren't decoded, no need to encode them back
if(opts.decodeEntities&&!(elem.parent&&elem.parent.name in unencodedElements)){data=entities.encodeXML(data);}return data;}function renderCdata(elem){return'<![CDATA['+elem.children[0].data+']]>';}function renderComment(elem){return'<!--'+elem.data+'-->';}},{"./foreignNames.json":4,"domelementtype":6,"entities":10}],6:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */function isTag(elem){return elem.type==="tag"/* Tag */||elem.type==="script"/* Script */||elem.type==="style"/* Style */;}exports.isTag=isTag;// Exports for backwards compatibility
exports.Text="text"/* Text */;//Text
exports.Directive="directive"/* Directive */;//<? ... ?>
exports.Comment="comment"/* Comment */;//<!-- ... -->
exports.Script="script"/* Script */;//<script> tags
exports.Style="style"/* Style */;//<style> tags
exports.Tag="tag"/* Tag */;//Any tag
exports.CDATA="cdata"/* CDATA */;//<![CDATA[ ... ]]>
exports.Doctype="doctype"/* Doctype */;},{}],7:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var entities_json_1=__importDefault(require("./maps/entities.json"));var legacy_json_1=__importDefault(require("./maps/legacy.json"));var xml_json_1=__importDefault(require("./maps/xml.json"));var decode_codepoint_1=__importDefault(require("./decode_codepoint"));exports.decodeXML=getStrictDecoder(xml_json_1["default"]);exports.decodeHTMLStrict=getStrictDecoder(entities_json_1["default"]);function getStrictDecoder(map){var keys=Object.keys(map).join("|");var replace=getReplacer(map);keys+="|#[xX][\\da-fA-F]+|#\\d+";var re=new RegExp("&(?:"+keys+");","g");return function(str){return String(str).replace(re,replace);};}var sorter=function sorter(a,b){return a<b?1:-1;};exports.decodeHTML=function(){var legacy=Object.keys(legacy_json_1["default"]).sort(sorter);var keys=Object.keys(entities_json_1["default"]).sort(sorter);for(var i=0,j=0;i<keys.length;i++){if(legacy[j]===keys[i]){keys[i]+=";?";j++;}else{keys[i]+=";";}}var re=new RegExp("&(?:"+keys.join("|")+"|#[xX][\\da-fA-F]+;?|#\\d+;?)","g");var replace=getReplacer(entities_json_1["default"]);function replacer(str){if(str.substr(-1)!==";")str+=";";return replace(str);}//TODO consider creating a merged map
return function(str){return String(str).replace(re,replacer);};}();function getReplacer(map){return function replace(str){if(str.charAt(1)==="#"){if(str.charAt(2)==="X"||str.charAt(2)==="x"){return decode_codepoint_1["default"](parseInt(str.substr(3),16));}return decode_codepoint_1["default"](parseInt(str.substr(2),10));}return map[str.slice(1,-1)];};}},{"./decode_codepoint":8,"./maps/entities.json":12,"./maps/legacy.json":13,"./maps/xml.json":14}],8:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var decode_json_1=__importDefault(require("./maps/decode.json"));// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint){if(codePoint>=0xd800&&codePoint<=0xdfff||codePoint>0x10ffff){return"\uFFFD";}if(codePoint in decode_json_1["default"]){// @ts-ignore
codePoint=decode_json_1["default"][codePoint];}var output="";if(codePoint>0xffff){codePoint-=0x10000;output+=String.fromCharCode(codePoint>>>10&0x3ff|0xd800);codePoint=0xdc00|codePoint&0x3ff;}output+=String.fromCharCode(codePoint);return output;}exports["default"]=decodeCodePoint;},{"./maps/decode.json":11}],9:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var xml_json_1=__importDefault(require("./maps/xml.json"));var inverseXML=getInverseObj(xml_json_1["default"]);var xmlReplacer=getInverseReplacer(inverseXML);exports.encodeXML=getInverse(inverseXML,xmlReplacer);var entities_json_1=__importDefault(require("./maps/entities.json"));var inverseHTML=getInverseObj(entities_json_1["default"]);var htmlReplacer=getInverseReplacer(inverseHTML);exports.encodeHTML=getInverse(inverseHTML,htmlReplacer);function getInverseObj(obj){return Object.keys(obj).sort().reduce(function(inverse,name){inverse[obj[name]]="&"+name+";";return inverse;},{});}function getInverseReplacer(inverse){var single=[];var multiple=[];Object.keys(inverse).forEach(function(k){return k.length===1?// Add value to single array
single.push("\\"+k):// Add value to multiple array
multiple.push(k);});//TODO add ranges
multiple.unshift("["+single.join("")+"]");return new RegExp(multiple.join("|"),"g");}var reNonASCII=/[^\0-\x7F]/g;var reAstralSymbols=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g;function singleCharReplacer(c){return"&#x"+c.charCodeAt(0).toString(16).toUpperCase()+";";}// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
function astralReplacer(c,_){// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
var high=c.charCodeAt(0);var low=c.charCodeAt(1);var codePoint=(high-0xd800)*0x400+low-0xdc00+0x10000;return"&#x"+codePoint.toString(16).toUpperCase()+";";}function getInverse(inverse,re){return function(data){return data.replace(re,function(name){return inverse[name];}).replace(reAstralSymbols,astralReplacer).replace(reNonASCII,singleCharReplacer);};}var reXmlChars=getInverseReplacer(inverseXML);function escape(data){return data.replace(reXmlChars,singleCharReplacer).replace(reAstralSymbols,astralReplacer).replace(reNonASCII,singleCharReplacer);}exports.escape=escape;},{"./maps/entities.json":12,"./maps/xml.json":14}],10:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var decode_1=require("./decode");var encode_1=require("./encode");function decode(data,level){return(!level||level<=0?decode_1.decodeXML:decode_1.decodeHTML)(data);}exports.decode=decode;function decodeStrict(data,level){return(!level||level<=0?decode_1.decodeXML:decode_1.decodeHTMLStrict)(data);}exports.decodeStrict=decodeStrict;function encode(data,level){return(!level||level<=0?encode_1.encodeXML:encode_1.encodeHTML)(data);}exports.encode=encode;var encode_2=require("./encode");exports.encodeXML=encode_2.encodeXML;exports.encodeHTML=encode_2.encodeHTML;exports.escape=encode_2.escape;// Legacy aliases
exports.encodeHTML4=encode_2.encodeHTML;exports.encodeHTML5=encode_2.encodeHTML;var decode_2=require("./decode");exports.decodeXML=decode_2.decodeXML;exports.decodeHTML=decode_2.decodeHTML;exports.decodeHTMLStrict=decode_2.decodeHTMLStrict;// Legacy aliases
exports.decodeHTML4=decode_2.decodeHTML;exports.decodeHTML5=decode_2.decodeHTML;exports.decodeHTML4Strict=decode_2.decodeHTMLStrict;exports.decodeHTML5Strict=decode_2.decodeHTMLStrict;exports.decodeXMLStrict=decode_2.decodeXML;},{"./decode":7,"./encode":9}],11:[function(require,module,exports){module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376};},{}],12:[function(require,module,exports){module.exports={"Aacute":"\xC1","aacute":"\xE1","Abreve":"\u0102","abreve":"\u0103","ac":"\u223E","acd":"\u223F","acE":"\u223E\u0333","Acirc":"\xC2","acirc":"\xE2","acute":"\xB4","Acy":"\u0410","acy":"\u0430","AElig":"\xC6","aelig":"\xE6","af":"\u2061","Afr":"\uD835\uDD04","afr":"\uD835\uDD1E","Agrave":"\xC0","agrave":"\xE0","alefsym":"\u2135","aleph":"\u2135","Alpha":"\u0391","alpha":"\u03B1","Amacr":"\u0100","amacr":"\u0101","amalg":"\u2A3F","amp":"&","AMP":"&","andand":"\u2A55","And":"\u2A53","and":"\u2227","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angmsd":"\u2221","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\xC5","angzarr":"\u237C","Aogon":"\u0104","aogon":"\u0105","Aopf":"\uD835\uDD38","aopf":"\uD835\uDD52","apacir":"\u2A6F","ap":"\u2248","apE":"\u2A70","ape":"\u224A","apid":"\u224B","apos":"'","ApplyFunction":"\u2061","approx":"\u2248","approxeq":"\u224A","Aring":"\xC5","aring":"\xE5","Ascr":"\uD835\uDC9C","ascr":"\uD835\uDCB6","Assign":"\u2254","ast":"*","asymp":"\u2248","asympeq":"\u224D","Atilde":"\xC3","atilde":"\xE3","Auml":"\xC4","auml":"\xE4","awconint":"\u2233","awint":"\u2A11","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","Backslash":"\u2216","Barv":"\u2AE7","barvee":"\u22BD","barwed":"\u2305","Barwed":"\u2306","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","Bcy":"\u0411","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","Because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","Bernoullis":"\u212C","Beta":"\u0392","beta":"\u03B2","beth":"\u2136","between":"\u226C","Bfr":"\uD835\uDD05","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bNot":"\u2AED","bnot":"\u2310","Bopf":"\uD835\uDD39","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxbox":"\u29C9","boxdl":"\u2510","boxdL":"\u2555","boxDl":"\u2556","boxDL":"\u2557","boxdr":"\u250C","boxdR":"\u2552","boxDr":"\u2553","boxDR":"\u2554","boxh":"\u2500","boxH":"\u2550","boxhd":"\u252C","boxHd":"\u2564","boxhD":"\u2565","boxHD":"\u2566","boxhu":"\u2534","boxHu":"\u2567","boxhU":"\u2568","boxHU":"\u2569","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxul":"\u2518","boxuL":"\u255B","boxUl":"\u255C","boxUL":"\u255D","boxur":"\u2514","boxuR":"\u2558","boxUr":"\u2559","boxUR":"\u255A","boxv":"\u2502","boxV":"\u2551","boxvh":"\u253C","boxvH":"\u256A","boxVh":"\u256B","boxVH":"\u256C","boxvl":"\u2524","boxvL":"\u2561","boxVl":"\u2562","boxVL":"\u2563","boxvr":"\u251C","boxvR":"\u255E","boxVr":"\u255F","boxVR":"\u2560","bprime":"\u2035","breve":"\u02D8","Breve":"\u02D8","brvbar":"\xA6","bscr":"\uD835\uDCB7","Bscr":"\u212C","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsolb":"\u29C5","bsol":"\\","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","Bumpeq":"\u224E","bumpeq":"\u224F","Cacute":"\u0106","cacute":"\u0107","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","cap":"\u2229","Cap":"\u22D2","capcup":"\u2A47","capdot":"\u2A40","CapitalDifferentialD":"\u2145","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","Cayleys":"\u212D","ccaps":"\u2A4D","Ccaron":"\u010C","ccaron":"\u010D","Ccedil":"\xC7","ccedil":"\xE7","Ccirc":"\u0108","ccirc":"\u0109","Cconint":"\u2230","ccups":"\u2A4C","ccupssm":"\u2A50","Cdot":"\u010A","cdot":"\u010B","cedil":"\xB8","Cedilla":"\xB8","cemptyv":"\u29B2","cent":"\xA2","centerdot":"\xB7","CenterDot":"\xB7","cfr":"\uD835\uDD20","Cfr":"\u212D","CHcy":"\u0427","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","Chi":"\u03A7","chi":"\u03C7","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","CircleDot":"\u2299","circledR":"\xAE","circledS":"\u24C8","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","cir":"\u25CB","cirE":"\u29C3","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","clubs":"\u2663","clubsuit":"\u2663","colon":":","Colon":"\u2237","Colone":"\u2A74","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","Congruent":"\u2261","conint":"\u222E","Conint":"\u222F","ContourIntegral":"\u222E","copf":"\uD835\uDD54","Copf":"\u2102","coprod":"\u2210","Coproduct":"\u2210","copy":"\xA9","COPY":"\xA9","copysr":"\u2117","CounterClockwiseContourIntegral":"\u2233","crarr":"\u21B5","cross":"\u2717","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cupbrcap":"\u2A48","cupcap":"\u2A46","CupCap":"\u224D","cup":"\u222A","Cup":"\u22D3","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curren":"\xA4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dagger":"\u2020","Dagger":"\u2021","daleth":"\u2138","darr":"\u2193","Darr":"\u21A1","dArr":"\u21D3","dash":"\u2010","Dashv":"\u2AE4","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","Dcaron":"\u010E","dcaron":"\u010F","Dcy":"\u0414","dcy":"\u0434","ddagger":"\u2021","ddarr":"\u21CA","DD":"\u2145","dd":"\u2146","DDotrahd":"\u2911","ddotseq":"\u2A77","deg":"\xB0","Del":"\u2207","Delta":"\u0394","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","Dfr":"\uD835\uDD07","dfr":"\uD835\uDD21","dHar":"\u2965","dharl":"\u21C3","dharr":"\u21C2","DiacriticalAcute":"\xB4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","diam":"\u22C4","diamond":"\u22C4","Diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\xA8","DifferentialD":"\u2146","digamma":"\u03DD","disin":"\u22F2","div":"\xF7","divide":"\xF7","divideontimes":"\u22C7","divonx":"\u22C7","DJcy":"\u0402","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","Dopf":"\uD835\uDD3B","dopf":"\uD835\uDD55","Dot":"\xA8","dot":"\u02D9","DotDot":"\u20DC","doteq":"\u2250","doteqdot":"\u2251","DotEqual":"\u2250","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","DoubleContourIntegral":"\u222F","DoubleDot":"\xA8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrowBar":"\u2913","downarrow":"\u2193","DownArrow":"\u2193","Downarrow":"\u21D3","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVectorBar":"\u2956","DownLeftVector":"\u21BD","DownRightTeeVector":"\u295F","DownRightVectorBar":"\u2957","DownRightVector":"\u21C1","DownTeeArrow":"\u21A7","DownTee":"\u22A4","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","Dscr":"\uD835\uDC9F","dscr":"\uD835\uDCB9","DScy":"\u0405","dscy":"\u0455","dsol":"\u29F6","Dstrok":"\u0110","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","DZcy":"\u040F","dzcy":"\u045F","dzigrarr":"\u27FF","Eacute":"\xC9","eacute":"\xE9","easter":"\u2A6E","Ecaron":"\u011A","ecaron":"\u011B","Ecirc":"\xCA","ecirc":"\xEA","ecir":"\u2256","ecolon":"\u2255","Ecy":"\u042D","ecy":"\u044D","eDDot":"\u2A77","Edot":"\u0116","edot":"\u0117","eDot":"\u2251","ee":"\u2147","efDot":"\u2252","Efr":"\uD835\uDD08","efr":"\uD835\uDD22","eg":"\u2A9A","Egrave":"\xC8","egrave":"\xE8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","Element":"\u2208","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","Emacr":"\u0112","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","EmptySmallSquare":"\u25FB","emptyv":"\u2205","EmptyVerySmallSquare":"\u25AB","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","ENG":"\u014A","eng":"\u014B","ensp":"\u2002","Eogon":"\u0118","eogon":"\u0119","Eopf":"\uD835\uDD3C","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","Epsilon":"\u0395","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","Equal":"\u2A75","equals":"=","EqualTilde":"\u2242","equest":"\u225F","Equilibrium":"\u21CC","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erarr":"\u2971","erDot":"\u2253","escr":"\u212F","Escr":"\u2130","esdot":"\u2250","Esim":"\u2A73","esim":"\u2242","Eta":"\u0397","eta":"\u03B7","ETH":"\xD0","eth":"\xF0","Euml":"\xCB","euml":"\xEB","euro":"\u20AC","excl":"!","exist":"\u2203","Exists":"\u2203","expectation":"\u2130","exponentiale":"\u2147","ExponentialE":"\u2147","fallingdotseq":"\u2252","Fcy":"\u0424","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","Ffr":"\uD835\uDD09","ffr":"\uD835\uDD23","filig":"\uFB01","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","Fopf":"\uD835\uDD3D","fopf":"\uD835\uDD57","forall":"\u2200","ForAll":"\u2200","fork":"\u22D4","forkv":"\u2AD9","Fouriertrf":"\u2131","fpartint":"\u2A0D","frac12":"\xBD","frac13":"\u2153","frac14":"\xBC","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac34":"\xBE","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","Fscr":"\u2131","gacute":"\u01F5","Gamma":"\u0393","gamma":"\u03B3","Gammad":"\u03DC","gammad":"\u03DD","gap":"\u2A86","Gbreve":"\u011E","gbreve":"\u011F","Gcedil":"\u0122","Gcirc":"\u011C","gcirc":"\u011D","Gcy":"\u0413","gcy":"\u0433","Gdot":"\u0120","gdot":"\u0121","ge":"\u2265","gE":"\u2267","gEl":"\u2A8C","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","gescc":"\u2AA9","ges":"\u2A7E","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","Gfr":"\uD835\uDD0A","gfr":"\uD835\uDD24","gg":"\u226B","Gg":"\u22D9","ggg":"\u22D9","gimel":"\u2137","GJcy":"\u0403","gjcy":"\u0453","gla":"\u2AA5","gl":"\u2277","glE":"\u2A92","glj":"\u2AA4","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gnE":"\u2269","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","Gopf":"\uD835\uDD3E","gopf":"\uD835\uDD58","grave":"`","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","gtcc":"\u2AA7","gtcir":"\u2A7A","gt":">","GT":">","Gt":"\u226B","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","Hacek":"\u02C7","hairsp":"\u200A","half":"\xBD","hamilt":"\u210B","HARDcy":"\u042A","hardcy":"\u044A","harrcir":"\u2948","harr":"\u2194","hArr":"\u21D4","harrw":"\u21AD","Hat":"^","hbar":"\u210F","Hcirc":"\u0124","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","Hfr":"\u210C","HilbertSpace":"\u210B","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","Hopf":"\u210D","horbar":"\u2015","HorizontalLine":"\u2500","hscr":"\uD835\uDCBD","Hscr":"\u210B","hslash":"\u210F","Hstrok":"\u0126","hstrok":"\u0127","HumpDownHump":"\u224E","HumpEqual":"\u224F","hybull":"\u2043","hyphen":"\u2010","Iacute":"\xCD","iacute":"\xED","ic":"\u2063","Icirc":"\xCE","icirc":"\xEE","Icy":"\u0418","icy":"\u0438","Idot":"\u0130","IEcy":"\u0415","iecy":"\u0435","iexcl":"\xA1","iff":"\u21D4","ifr":"\uD835\uDD26","Ifr":"\u2111","Igrave":"\xCC","igrave":"\xEC","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","IJlig":"\u0132","ijlig":"\u0133","Imacr":"\u012A","imacr":"\u012B","image":"\u2111","ImaginaryI":"\u2148","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","Im":"\u2111","imof":"\u22B7","imped":"\u01B5","Implies":"\u21D2","incare":"\u2105","in":"\u2208","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","intcal":"\u22BA","int":"\u222B","Int":"\u222C","integers":"\u2124","Integral":"\u222B","intercal":"\u22BA","Intersection":"\u22C2","intlarhk":"\u2A17","intprod":"\u2A3C","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","IOcy":"\u0401","iocy":"\u0451","Iogon":"\u012E","iogon":"\u012F","Iopf":"\uD835\uDD40","iopf":"\uD835\uDD5A","Iota":"\u0399","iota":"\u03B9","iprod":"\u2A3C","iquest":"\xBF","iscr":"\uD835\uDCBE","Iscr":"\u2110","isin":"\u2208","isindot":"\u22F5","isinE":"\u22F9","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","Itilde":"\u0128","itilde":"\u0129","Iukcy":"\u0406","iukcy":"\u0456","Iuml":"\xCF","iuml":"\xEF","Jcirc":"\u0134","jcirc":"\u0135","Jcy":"\u0419","jcy":"\u0439","Jfr":"\uD835\uDD0D","jfr":"\uD835\uDD27","jmath":"\u0237","Jopf":"\uD835\uDD41","jopf":"\uD835\uDD5B","Jscr":"\uD835\uDCA5","jscr":"\uD835\uDCBF","Jsercy":"\u0408","jsercy":"\u0458","Jukcy":"\u0404","jukcy":"\u0454","Kappa":"\u039A","kappa":"\u03BA","kappav":"\u03F0","Kcedil":"\u0136","kcedil":"\u0137","Kcy":"\u041A","kcy":"\u043A","Kfr":"\uD835\uDD0E","kfr":"\uD835\uDD28","kgreen":"\u0138","KHcy":"\u0425","khcy":"\u0445","KJcy":"\u040C","kjcy":"\u045C","Kopf":"\uD835\uDD42","kopf":"\uD835\uDD5C","Kscr":"\uD835\uDCA6","kscr":"\uD835\uDCC0","lAarr":"\u21DA","Lacute":"\u0139","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","Lambda":"\u039B","lambda":"\u03BB","lang":"\u27E8","Lang":"\u27EA","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","Laplacetrf":"\u2112","laquo":"\xAB","larrb":"\u21E4","larrbfs":"\u291F","larr":"\u2190","Larr":"\u219E","lArr":"\u21D0","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","latail":"\u2919","lAtail":"\u291B","lat":"\u2AAB","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lBarr":"\u290E","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","Lcaron":"\u013D","lcaron":"\u013E","Lcedil":"\u013B","lcedil":"\u013C","lceil":"\u2308","lcub":"{","Lcy":"\u041B","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","lE":"\u2266","LeftAngleBracket":"\u27E8","LeftArrowBar":"\u21E4","leftarrow":"\u2190","LeftArrow":"\u2190","Leftarrow":"\u21D0","LeftArrowRightArrow":"\u21C6","leftarrowtail":"\u21A2","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVectorBar":"\u2959","LeftDownVector":"\u21C3","LeftFloor":"\u230A","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","LeftRightArrow":"\u2194","Leftrightarrow":"\u21D4","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","LeftRightVector":"\u294E","LeftTeeArrow":"\u21A4","LeftTee":"\u22A3","LeftTeeVector":"\u295A","leftthreetimes":"\u22CB","LeftTriangleBar":"\u29CF","LeftTriangle":"\u22B2","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVectorBar":"\u2958","LeftUpVector":"\u21BF","LeftVectorBar":"\u2952","LeftVector":"\u21BC","lEg":"\u2A8B","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","lescc":"\u2AA8","les":"\u2A7D","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","lessgtr":"\u2276","LessLess":"\u2AA1","lesssim":"\u2272","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","lfisht":"\u297C","lfloor":"\u230A","Lfr":"\uD835\uDD0F","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lHar":"\u2962","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","LJcy":"\u0409","ljcy":"\u0459","llarr":"\u21C7","ll":"\u226A","Ll":"\u22D8","llcorner":"\u231E","Lleftarrow":"\u21DA","llhard":"\u296B","lltri":"\u25FA","Lmidot":"\u013F","lmidot":"\u0140","lmoustache":"\u23B0","lmoust":"\u23B0","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lnE":"\u2268","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","LongLeftArrow":"\u27F5","Longleftarrow":"\u27F8","longleftrightarrow":"\u27F7","LongLeftRightArrow":"\u27F7","Longleftrightarrow":"\u27FA","longmapsto":"\u27FC","longrightarrow":"\u27F6","LongRightArrow":"\u27F6","Longrightarrow":"\u27F9","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","Lopf":"\uD835\uDD43","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","Lscr":"\u2112","lsh":"\u21B0","Lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","Lstrok":"\u0141","lstrok":"\u0142","ltcc":"\u2AA6","ltcir":"\u2A79","lt":"<","LT":"<","Lt":"\u226A","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","ltrPar":"\u2996","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","macr":"\xAF","male":"\u2642","malt":"\u2720","maltese":"\u2720","Map":"\u2905","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","Mcy":"\u041C","mcy":"\u043C","mdash":"\u2014","mDDot":"\u223A","measuredangle":"\u2221","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","mfr":"\uD835\uDD2A","mho":"\u2127","micro":"\xB5","midast":"*","midcir":"\u2AF0","mid":"\u2223","middot":"\xB7","minusb":"\u229F","minus":"\u2212","minusd":"\u2238","minusdu":"\u2A2A","MinusPlus":"\u2213","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","Mopf":"\uD835\uDD44","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","Mscr":"\u2133","mstpos":"\u223E","Mu":"\u039C","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nabla":"\u2207","Nacute":"\u0143","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natural":"\u266E","naturals":"\u2115","natur":"\u266E","nbsp":"\xA0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","Ncaron":"\u0147","ncaron":"\u0148","Ncedil":"\u0145","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","Ncy":"\u041D","ncy":"\u043D","ndash":"\u2013","nearhk":"\u2924","nearr":"\u2197","neArr":"\u21D7","nearrow":"\u2197","ne":"\u2260","nedot":"\u2250\u0338","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\n","nexist":"\u2204","nexists":"\u2204","Nfr":"\uD835\uDD11","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","nGg":"\u22D9\u0338","ngsim":"\u2275","nGt":"\u226B\u20D2","ngt":"\u226F","ngtr":"\u226F","nGtv":"\u226B\u0338","nharr":"\u21AE","nhArr":"\u21CE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","NJcy":"\u040A","njcy":"\u045A","nlarr":"\u219A","nlArr":"\u21CD","nldr":"\u2025","nlE":"\u2266\u0338","nle":"\u2270","nleftarrow":"\u219A","nLeftarrow":"\u21CD","nleftrightarrow":"\u21AE","nLeftrightarrow":"\u21CE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nLl":"\u22D8\u0338","nlsim":"\u2274","nLt":"\u226A\u20D2","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nLtv":"\u226A\u0338","nmid":"\u2224","NoBreak":"\u2060","NonBreakingSpace":"\xA0","nopf":"\uD835\uDD5F","Nopf":"\u2115","Not":"\u2AEC","not":"\xAC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","notin":"\u2209","notindot":"\u22F5\u0338","notinE":"\u22F9\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangle":"\u22EB","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","nparallel":"\u2226","npar":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","nprec":"\u2280","npreceq":"\u2AAF\u0338","npre":"\u2AAF\u0338","nrarrc":"\u2933\u0338","nrarr":"\u219B","nrArr":"\u21CF","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nRightarrow":"\u21CF","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","Nscr":"\uD835\uDCA9","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","Ntilde":"\xD1","ntilde":"\xF1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","Nu":"\u039D","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvDash":"\u22AD","nVdash":"\u22AE","nVDash":"\u22AF","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvHarr":"\u2904","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwarhk":"\u2923","nwarr":"\u2196","nwArr":"\u21D6","nwarrow":"\u2196","nwnear":"\u2927","Oacute":"\xD3","oacute":"\xF3","oast":"\u229B","Ocirc":"\xD4","ocirc":"\xF4","ocir":"\u229A","Ocy":"\u041E","ocy":"\u043E","odash":"\u229D","Odblac":"\u0150","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","OElig":"\u0152","oelig":"\u0153","ofcir":"\u29BF","Ofr":"\uD835\uDD12","ofr":"\uD835\uDD2C","ogon":"\u02DB","Ograve":"\xD2","ograve":"\xF2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","Omacr":"\u014C","omacr":"\u014D","Omega":"\u03A9","omega":"\u03C9","Omicron":"\u039F","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","Oopf":"\uD835\uDD46","oopf":"\uD835\uDD60","opar":"\u29B7","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","operp":"\u29B9","oplus":"\u2295","orarr":"\u21BB","Or":"\u2A54","or":"\u2228","ord":"\u2A5D","order":"\u2134","orderof":"\u2134","ordf":"\xAA","ordm":"\xBA","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oS":"\u24C8","Oscr":"\uD835\uDCAA","oscr":"\u2134","Oslash":"\xD8","oslash":"\xF8","osol":"\u2298","Otilde":"\xD5","otilde":"\xF5","otimesas":"\u2A36","Otimes":"\u2A37","otimes":"\u2297","Ouml":"\xD6","ouml":"\xF6","ovbar":"\u233D","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","para":"\xB6","parallel":"\u2225","par":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","PartialD":"\u2202","Pcy":"\u041F","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","Pfr":"\uD835\uDD13","pfr":"\uD835\uDD2D","Phi":"\u03A6","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","Pi":"\u03A0","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plus":"+","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","PlusMinus":"\xB1","plusmn":"\xB1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\xB1","Poincareplane":"\u210C","pointint":"\u2A15","popf":"\uD835\uDD61","Popf":"\u2119","pound":"\xA3","prap":"\u2AB7","Pr":"\u2ABB","pr":"\u227A","prcue":"\u227C","precapprox":"\u2AB7","prec":"\u227A","preccurlyeq":"\u227C","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","pre":"\u2AAF","prE":"\u2AB3","precsim":"\u227E","prime":"\u2032","Prime":"\u2033","primes":"\u2119","prnap":"\u2AB9","prnE":"\u2AB5","prnsim":"\u22E8","prod":"\u220F","Product":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","Proportional":"\u221D","Proportion":"\u2237","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","Pscr":"\uD835\uDCAB","pscr":"\uD835\uDCC5","Psi":"\u03A8","psi":"\u03C8","puncsp":"\u2008","Qfr":"\uD835\uDD14","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","Qopf":"\u211A","qprime":"\u2057","Qscr":"\uD835\uDCAC","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quot":"\"","QUOT":"\"","rAarr":"\u21DB","race":"\u223D\u0331","Racute":"\u0154","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","Rang":"\u27EB","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raquo":"\xBB","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarr":"\u2192","Rarr":"\u21A0","rArr":"\u21D2","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","Rarrtl":"\u2916","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","rAtail":"\u291C","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rBarr":"\u290F","RBarr":"\u2910","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","Rcaron":"\u0158","rcaron":"\u0159","Rcedil":"\u0156","rcedil":"\u0157","rceil":"\u2309","rcub":"}","Rcy":"\u0420","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","Re":"\u211C","rect":"\u25AD","reg":"\xAE","REG":"\xAE","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","Rfr":"\u211C","rHar":"\u2964","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","Rho":"\u03A1","rho":"\u03C1","rhov":"\u03F1","RightAngleBracket":"\u27E9","RightArrowBar":"\u21E5","rightarrow":"\u2192","RightArrow":"\u2192","Rightarrow":"\u21D2","RightArrowLeftArrow":"\u21C4","rightarrowtail":"\u21A3","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVectorBar":"\u2955","RightDownVector":"\u21C2","RightFloor":"\u230B","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","RightTeeArrow":"\u21A6","RightTee":"\u22A2","RightTeeVector":"\u295B","rightthreetimes":"\u22CC","RightTriangleBar":"\u29D0","RightTriangle":"\u22B3","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVectorBar":"\u2954","RightUpVector":"\u21BE","RightVectorBar":"\u2953","RightVector":"\u21C0","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoustache":"\u23B1","rmoust":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","Ropf":"\u211D","roplus":"\u2A2E","rotimes":"\u2A35","RoundImplies":"\u2970","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","Rrightarrow":"\u21DB","rsaquo":"\u203A","rscr":"\uD835\uDCC7","Rscr":"\u211B","rsh":"\u21B1","Rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","RuleDelayed":"\u29F4","ruluhar":"\u2968","rx":"\u211E","Sacute":"\u015A","sacute":"\u015B","sbquo":"\u201A","scap":"\u2AB8","Scaron":"\u0160","scaron":"\u0161","Sc":"\u2ABC","sc":"\u227B","sccue":"\u227D","sce":"\u2AB0","scE":"\u2AB4","Scedil":"\u015E","scedil":"\u015F","Scirc":"\u015C","scirc":"\u015D","scnap":"\u2ABA","scnE":"\u2AB6","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","Scy":"\u0421","scy":"\u0441","sdotb":"\u22A1","sdot":"\u22C5","sdote":"\u2A66","searhk":"\u2925","searr":"\u2198","seArr":"\u21D8","searrow":"\u2198","sect":"\xA7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","Sfr":"\uD835\uDD16","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","SHCHcy":"\u0429","shchcy":"\u0449","SHcy":"\u0428","shcy":"\u0448","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","shortmid":"\u2223","shortparallel":"\u2225","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","shy":"\xAD","Sigma":"\u03A3","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","SmallCircle":"\u2218","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","SOFTcy":"\u042C","softcy":"\u044C","solbar":"\u233F","solb":"\u29C4","sol":"/","Sopf":"\uD835\uDD4A","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","Sqrt":"\u221A","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","square":"\u25A1","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","squarf":"\u25AA","squ":"\u25A1","squf":"\u25AA","srarr":"\u2192","Sscr":"\uD835\uDCAE","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","Star":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\xAF","sub":"\u2282","Sub":"\u22D0","subdot":"\u2ABD","subE":"\u2AC5","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","Subset":"\u22D0","subseteq":"\u2286","subseteqq":"\u2AC5","SubsetEqual":"\u2286","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succapprox":"\u2AB8","succ":"\u227B","succcurlyeq":"\u227D","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","SuchThat":"\u220B","sum":"\u2211","Sum":"\u2211","sung":"\u266A","sup1":"\xB9","sup2":"\xB2","sup3":"\xB3","sup":"\u2283","Sup":"\u22D1","supdot":"\u2ABE","supdsub":"\u2AD8","supE":"\u2AC6","supe":"\u2287","supedot":"\u2AC4","Superset":"\u2283","SupersetEqual":"\u2287","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","Supset":"\u22D1","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swarhk":"\u2926","swarr":"\u2199","swArr":"\u21D9","swarrow":"\u2199","swnwar":"\u292A","szlig":"\xDF","Tab":"\t","target":"\u2316","Tau":"\u03A4","tau":"\u03C4","tbrk":"\u23B4","Tcaron":"\u0164","tcaron":"\u0165","Tcedil":"\u0162","tcedil":"\u0163","Tcy":"\u0422","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","Tfr":"\uD835\uDD17","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","Therefore":"\u2234","Theta":"\u0398","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","THORN":"\xDE","thorn":"\xFE","tilde":"\u02DC","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","timesbar":"\u2A31","timesb":"\u22A0","times":"\xD7","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","topbot":"\u2336","topcir":"\u2AF1","top":"\u22A4","Topf":"\uD835\uDD4B","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","TRADE":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","TripleDot":"\u20DB","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","Tscr":"\uD835\uDCAF","tscr":"\uD835\uDCC9","TScy":"\u0426","tscy":"\u0446","TSHcy":"\u040B","tshcy":"\u045B","Tstrok":"\u0166","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","Uacute":"\xDA","uacute":"\xFA","uarr":"\u2191","Uarr":"\u219F","uArr":"\u21D1","Uarrocir":"\u2949","Ubrcy":"\u040E","ubrcy":"\u045E","Ubreve":"\u016C","ubreve":"\u016D","Ucirc":"\xDB","ucirc":"\xFB","Ucy":"\u0423","ucy":"\u0443","udarr":"\u21C5","Udblac":"\u0170","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","Ufr":"\uD835\uDD18","ufr":"\uD835\uDD32","Ugrave":"\xD9","ugrave":"\xF9","uHar":"\u2963","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","Umacr":"\u016A","umacr":"\u016B","uml":"\xA8","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","uogon":"\u0173","Uopf":"\uD835\uDD4C","uopf":"\uD835\uDD66","UpArrowBar":"\u2912","uparrow":"\u2191","UpArrow":"\u2191","Uparrow":"\u21D1","UpArrowDownArrow":"\u21C5","updownarrow":"\u2195","UpDownArrow":"\u2195","Updownarrow":"\u21D5","UpEquilibrium":"\u296E","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","upsi":"\u03C5","Upsi":"\u03D2","upsih":"\u03D2","Upsilon":"\u03A5","upsilon":"\u03C5","UpTeeArrow":"\u21A5","UpTee":"\u22A5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","Uring":"\u016E","uring":"\u016F","urtri":"\u25F9","Uscr":"\uD835\uDCB0","uscr":"\uD835\uDCCA","utdot":"\u22F0","Utilde":"\u0168","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","Uuml":"\xDC","uuml":"\xFC","uwangle":"\u29A7","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","vArr":"\u21D5","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vBar":"\u2AE8","Vbar":"\u2AEB","vBarv":"\u2AE9","Vcy":"\u0412","vcy":"\u0432","vdash":"\u22A2","vDash":"\u22A8","Vdash":"\u22A9","VDash":"\u22AB","Vdashl":"\u2AE6","veebar":"\u22BB","vee":"\u2228","Vee":"\u22C1","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","Verbar":"\u2016","vert":"|","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","Vopf":"\uD835\uDD4D","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","Vscr":"\uD835\uDCB1","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","Vvdash":"\u22AA","vzigzag":"\u299A","Wcirc":"\u0174","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","Wedge":"\u22C0","wedgeq":"\u2259","weierp":"\u2118","Wfr":"\uD835\uDD1A","wfr":"\uD835\uDD34","Wopf":"\uD835\uDD4E","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","Wscr":"\uD835\uDCB2","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","Xfr":"\uD835\uDD1B","xfr":"\uD835\uDD35","xharr":"\u27F7","xhArr":"\u27FA","Xi":"\u039E","xi":"\u03BE","xlarr":"\u27F5","xlArr":"\u27F8","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","Xopf":"\uD835\uDD4F","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrarr":"\u27F6","xrArr":"\u27F9","Xscr":"\uD835\uDCB3","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","Yacute":"\xDD","yacute":"\xFD","YAcy":"\u042F","yacy":"\u044F","Ycirc":"\u0176","ycirc":"\u0177","Ycy":"\u042B","ycy":"\u044B","yen":"\xA5","Yfr":"\uD835\uDD1C","yfr":"\uD835\uDD36","YIcy":"\u0407","yicy":"\u0457","Yopf":"\uD835\uDD50","yopf":"\uD835\uDD6A","Yscr":"\uD835\uDCB4","yscr":"\uD835\uDCCE","YUcy":"\u042E","yucy":"\u044E","yuml":"\xFF","Yuml":"\u0178","Zacute":"\u0179","zacute":"\u017A","Zcaron":"\u017D","zcaron":"\u017E","Zcy":"\u0417","zcy":"\u0437","Zdot":"\u017B","zdot":"\u017C","zeetrf":"\u2128","ZeroWidthSpace":"\u200B","Zeta":"\u0396","zeta":"\u03B6","zfr":"\uD835\uDD37","Zfr":"\u2128","ZHcy":"\u0416","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","Zopf":"\u2124","Zscr":"\uD835\uDCB5","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"};},{}],13:[function(require,module,exports){module.exports={"Aacute":"\xC1","aacute":"\xE1","Acirc":"\xC2","acirc":"\xE2","acute":"\xB4","AElig":"\xC6","aelig":"\xE6","Agrave":"\xC0","agrave":"\xE0","amp":"&","AMP":"&","Aring":"\xC5","aring":"\xE5","Atilde":"\xC3","atilde":"\xE3","Auml":"\xC4","auml":"\xE4","brvbar":"\xA6","Ccedil":"\xC7","ccedil":"\xE7","cedil":"\xB8","cent":"\xA2","copy":"\xA9","COPY":"\xA9","curren":"\xA4","deg":"\xB0","divide":"\xF7","Eacute":"\xC9","eacute":"\xE9","Ecirc":"\xCA","ecirc":"\xEA","Egrave":"\xC8","egrave":"\xE8","ETH":"\xD0","eth":"\xF0","Euml":"\xCB","euml":"\xEB","frac12":"\xBD","frac14":"\xBC","frac34":"\xBE","gt":">","GT":">","Iacute":"\xCD","iacute":"\xED","Icirc":"\xCE","icirc":"\xEE","iexcl":"\xA1","Igrave":"\xCC","igrave":"\xEC","iquest":"\xBF","Iuml":"\xCF","iuml":"\xEF","laquo":"\xAB","lt":"<","LT":"<","macr":"\xAF","micro":"\xB5","middot":"\xB7","nbsp":"\xA0","not":"\xAC","Ntilde":"\xD1","ntilde":"\xF1","Oacute":"\xD3","oacute":"\xF3","Ocirc":"\xD4","ocirc":"\xF4","Ograve":"\xD2","ograve":"\xF2","ordf":"\xAA","ordm":"\xBA","Oslash":"\xD8","oslash":"\xF8","Otilde":"\xD5","otilde":"\xF5","Ouml":"\xD6","ouml":"\xF6","para":"\xB6","plusmn":"\xB1","pound":"\xA3","quot":"\"","QUOT":"\"","raquo":"\xBB","reg":"\xAE","REG":"\xAE","sect":"\xA7","shy":"\xAD","sup1":"\xB9","sup2":"\xB2","sup3":"\xB3","szlig":"\xDF","THORN":"\xDE","thorn":"\xFE","times":"\xD7","Uacute":"\xDA","uacute":"\xFA","Ucirc":"\xDB","ucirc":"\xFB","Ugrave":"\xD9","ugrave":"\xF9","uml":"\xA8","Uuml":"\xDC","uuml":"\xFC","Yacute":"\xDD","yacute":"\xFD","yen":"\xA5","yuml":"\xFF"};},{}],14:[function(require,module,exports){module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""};},{}],15:[function(require,module,exports){//Types of elements found in the DOM
module.exports={Text:"text",//Text
Directive:"directive",//<? ... ?>
Comment:"comment",//<!-- ... -->
Script:"script",//<script> tags
Style:"style",//<style> tags
Tag:"tag",//Any tag
CDATA:"cdata",//<![CDATA[ ... ]]>
Doctype:"doctype",isTag:function isTag(elem){return elem.type==="tag"||elem.type==="script"||elem.type==="style";}};},{}],16:[function(require,module,exports){var ElementType=require("domelementtype");var re_whitespace=/\s+/g;var NodePrototype=require("./lib/node");var ElementPrototype=require("./lib/element");function DomHandler(callback,options,elementCB){if(_typeof(callback)==="object"){elementCB=options;options=callback;callback=null;}else if(typeof options==="function"){elementCB=options;options=defaultOpts;}this._callback=callback;this._options=options||defaultOpts;this._elementCB=elementCB;this.dom=[];this._done=false;this._tagStack=[];this._parser=this._parser||null;}//default options
var defaultOpts={normalizeWhitespace:false,//Replace all whitespace with single spaces
withStartIndices:false,//Add startIndex properties to nodes
withEndIndices:false//Add endIndex properties to nodes
};DomHandler.prototype.onparserinit=function(parser){this._parser=parser;};//Resets the handler back to starting state
DomHandler.prototype.onreset=function(){DomHandler.call(this,this._callback,this._options,this._elementCB);};//Signals the handler that parsing is done
DomHandler.prototype.onend=function(){if(this._done)return;this._done=true;this._parser=null;this._handleCallback(null);};DomHandler.prototype._handleCallback=DomHandler.prototype.onerror=function(error){if(typeof this._callback==="function"){this._callback(error,this.dom);}else{if(error)throw error;}};DomHandler.prototype.onclosetag=function(){//if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));
var elem=this._tagStack.pop();if(this._options.withEndIndices&&elem){elem.endIndex=this._parser.endIndex;}if(this._elementCB)this._elementCB(elem);};DomHandler.prototype._createDomElement=function(properties){if(!this._options.withDomLvl1)return properties;var element;if(properties.type==="tag"){element=Object.create(ElementPrototype);}else{element=Object.create(NodePrototype);}for(var key in properties){if(properties.hasOwnProperty(key)){element[key]=properties[key];}}return element;};DomHandler.prototype._addDomElement=function(element){var parent=this._tagStack[this._tagStack.length-1];var siblings=parent?parent.children:this.dom;var previousSibling=siblings[siblings.length-1];element.next=null;if(this._options.withStartIndices){element.startIndex=this._parser.startIndex;}if(this._options.withEndIndices){element.endIndex=this._parser.endIndex;}if(previousSibling){element.prev=previousSibling;previousSibling.next=element;}else{element.prev=null;}siblings.push(element);element.parent=parent||null;};DomHandler.prototype.onopentag=function(name,attribs){var properties={type:name==="script"?ElementType.Script:name==="style"?ElementType.Style:ElementType.Tag,name:name,attribs:attribs,children:[]};var element=this._createDomElement(properties);this._addDomElement(element);this._tagStack.push(element);};DomHandler.prototype.ontext=function(data){//the ignoreWhitespace is officially dropped, but for now,
//it's an alias for normalizeWhitespace
var normalize=this._options.normalizeWhitespace||this._options.ignoreWhitespace;var lastTag;if(!this._tagStack.length&&this.dom.length&&(lastTag=this.dom[this.dom.length-1]).type===ElementType.Text){if(normalize){lastTag.data=(lastTag.data+data).replace(re_whitespace," ");}else{lastTag.data+=data;}}else{if(this._tagStack.length&&(lastTag=this._tagStack[this._tagStack.length-1])&&(lastTag=lastTag.children[lastTag.children.length-1])&&lastTag.type===ElementType.Text){if(normalize){lastTag.data=(lastTag.data+data).replace(re_whitespace," ");}else{lastTag.data+=data;}}else{if(normalize){data=data.replace(re_whitespace," ");}var element=this._createDomElement({data:data,type:ElementType.Text});this._addDomElement(element);}}};DomHandler.prototype.oncomment=function(data){var lastTag=this._tagStack[this._tagStack.length-1];if(lastTag&&lastTag.type===ElementType.Comment){lastTag.data+=data;return;}var properties={data:data,type:ElementType.Comment};var element=this._createDomElement(properties);this._addDomElement(element);this._tagStack.push(element);};DomHandler.prototype.oncdatastart=function(){var properties={children:[{data:"",type:ElementType.Text}],type:ElementType.CDATA};var element=this._createDomElement(properties);this._addDomElement(element);this._tagStack.push(element);};DomHandler.prototype.oncommentend=DomHandler.prototype.oncdataend=function(){this._tagStack.pop();};DomHandler.prototype.onprocessinginstruction=function(name,data){var element=this._createDomElement({name:name,data:data,type:ElementType.Directive});this._addDomElement(element);};module.exports=DomHandler;},{"./lib/element":17,"./lib/node":18,"domelementtype":15}],17:[function(require,module,exports){// DOM-Level-1-compliant structure
var NodePrototype=require('./node');var ElementPrototype=module.exports=Object.create(NodePrototype);var domLvl1={tagName:"name"};Object.keys(domLvl1).forEach(function(key){var shorthand=domLvl1[key];Object.defineProperty(ElementPrototype,key,{get:function get(){return this[shorthand]||null;},set:function set(val){this[shorthand]=val;return val;}});});},{"./node":18}],18:[function(require,module,exports){// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var NodePrototype=module.exports={get firstChild(){var children=this.children;return children&&children[0]||null;},get lastChild(){var children=this.children;return children&&children[children.length-1]||null;},get nodeType(){return nodeTypes[this.type]||nodeTypes.element;}};var domLvl1={tagName:"name",childNodes:"children",parentNode:"parent",previousSibling:"prev",nextSibling:"next",nodeValue:"data"};var nodeTypes={element:1,text:3,cdata:4,comment:8};Object.keys(domLvl1).forEach(function(key){var shorthand=domLvl1[key];Object.defineProperty(NodePrototype,key,{get:function get(){return this[shorthand]||null;},set:function set(val){this[shorthand]=val;return val;}});});},{}],19:[function(require,module,exports){var DomUtils=module.exports;[require("./lib/stringify"),require("./lib/traversal"),require("./lib/manipulation"),require("./lib/querying"),require("./lib/legacy"),require("./lib/helpers")].forEach(function(ext){Object.keys(ext).forEach(function(key){DomUtils[key]=ext[key].bind(DomUtils);});});},{"./lib/helpers":20,"./lib/legacy":21,"./lib/manipulation":22,"./lib/querying":23,"./lib/stringify":24,"./lib/traversal":25}],20:[function(require,module,exports){// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets=function(nodes){var idx=nodes.length,node,ancestor,replace;// Check if each node (or one of its ancestors) is already contained in the
// array.
while(--idx>-1){node=ancestor=nodes[idx];// Temporarily remove the node under consideration
nodes[idx]=null;replace=true;while(ancestor){if(nodes.indexOf(ancestor)>-1){replace=false;nodes.splice(idx,1);break;}ancestor=ancestor.parent;}// If the node has been found to be unique, re-insert it.
if(replace){nodes[idx]=node;}}return nodes;};// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION={DISCONNECTED:1,PRECEDING:2,FOLLOWING:4,CONTAINS:8,CONTAINED_BY:16};// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos=exports.compareDocumentPosition=function(nodeA,nodeB){var aParents=[];var bParents=[];var current,sharedParent,siblings,aSibling,bSibling,idx;if(nodeA===nodeB){return 0;}current=nodeA;while(current){aParents.unshift(current);current=current.parent;}current=nodeB;while(current){bParents.unshift(current);current=current.parent;}idx=0;while(aParents[idx]===bParents[idx]){idx++;}if(idx===0){return POSITION.DISCONNECTED;}sharedParent=aParents[idx-1];siblings=sharedParent.children;aSibling=aParents[idx];bSibling=bParents[idx];if(siblings.indexOf(aSibling)>siblings.indexOf(bSibling)){if(sharedParent===nodeB){return POSITION.FOLLOWING|POSITION.CONTAINED_BY;}return POSITION.FOLLOWING;}else{if(sharedParent===nodeA){return POSITION.PRECEDING|POSITION.CONTAINS;}return POSITION.PRECEDING;}};// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort=function(nodes){var idx=nodes.length,node,position;nodes=nodes.slice();while(--idx>-1){node=nodes[idx];position=nodes.indexOf(node);if(position>-1&&position<idx){nodes.splice(idx,1);}}nodes.sort(function(a,b){var relative=comparePos(a,b);if(relative&POSITION.PRECEDING){return-1;}else if(relative&POSITION.FOLLOWING){return 1;}return 0;});return nodes;};},{}],21:[function(require,module,exports){var ElementType=require("domelementtype");var isTag=exports.isTag=ElementType.isTag;exports.testElement=function(options,element){for(var key in options){if(!options.hasOwnProperty(key));else if(key==="tag_name"){if(!isTag(element)||!options.tag_name(element.name)){return false;}}else if(key==="tag_type"){if(!options.tag_type(element.type))return false;}else if(key==="tag_contains"){if(isTag(element)||!options.tag_contains(element.data)){return false;}}else if(!element.attribs||!options[key](element.attribs[key])){return false;}}return true;};var Checks={tag_name:function tag_name(name){if(typeof name==="function"){return function(elem){return isTag(elem)&&name(elem.name);};}else if(name==="*"){return isTag;}else{return function(elem){return isTag(elem)&&elem.name===name;};}},tag_type:function tag_type(type){if(typeof type==="function"){return function(elem){return type(elem.type);};}else{return function(elem){return elem.type===type;};}},tag_contains:function tag_contains(data){if(typeof data==="function"){return function(elem){return!isTag(elem)&&data(elem.data);};}else{return function(elem){return!isTag(elem)&&elem.data===data;};}}};function getAttribCheck(attrib,value){if(typeof value==="function"){return function(elem){return elem.attribs&&value(elem.attribs[attrib]);};}else{return function(elem){return elem.attribs&&elem.attribs[attrib]===value;};}}function combineFuncs(a,b){return function(elem){return a(elem)||b(elem);};}exports.getElements=function(options,element,recurse,limit){var funcs=Object.keys(options).map(function(key){var value=options[key];return key in Checks?Checks[key](value):getAttribCheck(key,value);});return funcs.length===0?[]:this.filter(funcs.reduce(combineFuncs),element,recurse,limit);};exports.getElementById=function(id,element,recurse){if(!Array.isArray(element))element=[element];return this.findOne(getAttribCheck("id",id),element,recurse!==false);};exports.getElementsByTagName=function(name,element,recurse,limit){return this.filter(Checks.tag_name(name),element,recurse,limit);};exports.getElementsByTagType=function(type,element,recurse,limit){return this.filter(Checks.tag_type(type),element,recurse,limit);};},{"domelementtype":15}],22:[function(require,module,exports){exports.removeElement=function(elem){if(elem.prev)elem.prev.next=elem.next;if(elem.next)elem.next.prev=elem.prev;if(elem.parent){var childs=elem.parent.children;childs.splice(childs.lastIndexOf(elem),1);}};exports.replaceElement=function(elem,replacement){var prev=replacement.prev=elem.prev;if(prev){prev.next=replacement;}var next=replacement.next=elem.next;if(next){next.prev=replacement;}var parent=replacement.parent=elem.parent;if(parent){var childs=parent.children;childs[childs.lastIndexOf(elem)]=replacement;}};exports.appendChild=function(elem,child){child.parent=elem;if(elem.children.push(child)!==1){var sibling=elem.children[elem.children.length-2];sibling.next=child;child.prev=sibling;child.next=null;}};exports.append=function(elem,next){var parent=elem.parent,currNext=elem.next;next.next=currNext;next.prev=elem;elem.next=next;next.parent=parent;if(currNext){currNext.prev=next;if(parent){var childs=parent.children;childs.splice(childs.lastIndexOf(currNext),0,next);}}else if(parent){parent.children.push(next);}};exports.prepend=function(elem,prev){var parent=elem.parent;if(parent){var childs=parent.children;childs.splice(childs.lastIndexOf(elem),0,prev);}if(elem.prev){elem.prev.next=prev;}prev.parent=parent;prev.prev=elem.prev;prev.next=elem;elem.prev=prev;};},{}],23:[function(require,module,exports){var isTag=require("domelementtype").isTag;module.exports={filter:filter,find:find,findOneChild:findOneChild,findOne:findOne,existsOne:existsOne,findAll:findAll};function filter(test,element,recurse,limit){if(!Array.isArray(element))element=[element];if(typeof limit!=="number"||!isFinite(limit)){limit=Infinity;}return find(test,element,recurse!==false,limit);}function find(test,elems,recurse,limit){var result=[],childs;for(var i=0,j=elems.length;i<j;i++){if(test(elems[i])){result.push(elems[i]);if(--limit<=0)break;}childs=elems[i].children;if(recurse&&childs&&childs.length>0){childs=find(test,childs,recurse,limit);result=result.concat(childs);limit-=childs.length;if(limit<=0)break;}}return result;}function findOneChild(test,elems){for(var i=0,l=elems.length;i<l;i++){if(test(elems[i]))return elems[i];}return null;}function findOne(test,elems){var elem=null;for(var i=0,l=elems.length;i<l&&!elem;i++){if(!isTag(elems[i])){continue;}else if(test(elems[i])){elem=elems[i];}else if(elems[i].children.length>0){elem=findOne(test,elems[i].children);}}return elem;}function existsOne(test,elems){for(var i=0,l=elems.length;i<l;i++){if(isTag(elems[i])&&(test(elems[i])||elems[i].children.length>0&&existsOne(test,elems[i].children))){return true;}}return false;}function findAll(test,rootElems){var result=[];var stack=rootElems.slice();while(stack.length){var elem=stack.shift();if(!isTag(elem))continue;if(elem.children&&elem.children.length>0){stack.unshift.apply(stack,elem.children);}if(test(elem))result.push(elem);}return result;}},{"domelementtype":15}],24:[function(require,module,exports){var ElementType=require("domelementtype"),getOuterHTML=require("dom-serializer"),isTag=ElementType.isTag;module.exports={getInnerHTML:getInnerHTML,getOuterHTML:getOuterHTML,getText:getText};function getInnerHTML(elem,opts){return elem.children?elem.children.map(function(elem){return getOuterHTML(elem,opts);}).join(""):"";}function getText(elem){if(Array.isArray(elem))return elem.map(getText).join("");if(isTag(elem))return elem.name==="br"?"\n":getText(elem.children);if(elem.type===ElementType.CDATA)return getText(elem.children);if(elem.type===ElementType.Text)return elem.data;return"";}},{"dom-serializer":5,"domelementtype":15}],25:[function(require,module,exports){var getChildren=exports.getChildren=function(elem){return elem.children;};var getParent=exports.getParent=function(elem){return elem.parent;};exports.getSiblings=function(elem){var parent=getParent(elem);return parent?getChildren(parent):[elem];};exports.getAttributeValue=function(elem,name){return elem.attribs&&elem.attribs[name];};exports.hasAttrib=function(elem,name){return!!elem.attribs&&hasOwnProperty.call(elem.attribs,name);};exports.getName=function(elem){return elem.name;};},{}],26:[function(require,module,exports){var decodeMap=require("../maps/decode.json");module.exports=decodeCodePoint;// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint){if(codePoint>=0xd800&&codePoint<=0xdfff||codePoint>0x10ffff){return"\uFFFD";}if(codePoint in decodeMap){codePoint=decodeMap[codePoint];}var output="";if(codePoint>0xffff){codePoint-=0x10000;output+=String.fromCharCode(codePoint>>>10&0x3ff|0xd800);codePoint=0xdc00|codePoint&0x3ff;}output+=String.fromCharCode(codePoint);return output;}},{"../maps/decode.json":27}],27:[function(require,module,exports){module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376};},{}],28:[function(require,module,exports){module.exports={"Aacute":"\xC1","aacute":"\xE1","Abreve":"\u0102","abreve":"\u0103","ac":"\u223E","acd":"\u223F","acE":"\u223E\u0333","Acirc":"\xC2","acirc":"\xE2","acute":"\xB4","Acy":"\u0410","acy":"\u0430","AElig":"\xC6","aelig":"\xE6","af":"\u2061","Afr":"\uD835\uDD04","afr":"\uD835\uDD1E","Agrave":"\xC0","agrave":"\xE0","alefsym":"\u2135","aleph":"\u2135","Alpha":"\u0391","alpha":"\u03B1","Amacr":"\u0100","amacr":"\u0101","amalg":"\u2A3F","amp":"&","AMP":"&","andand":"\u2A55","And":"\u2A53","and":"\u2227","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angmsd":"\u2221","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\xC5","angzarr":"\u237C","Aogon":"\u0104","aogon":"\u0105","Aopf":"\uD835\uDD38","aopf":"\uD835\uDD52","apacir":"\u2A6F","ap":"\u2248","apE":"\u2A70","ape":"\u224A","apid":"\u224B","apos":"'","ApplyFunction":"\u2061","approx":"\u2248","approxeq":"\u224A","Aring":"\xC5","aring":"\xE5","Ascr":"\uD835\uDC9C","ascr":"\uD835\uDCB6","Assign":"\u2254","ast":"*","asymp":"\u2248","asympeq":"\u224D","Atilde":"\xC3","atilde":"\xE3","Auml":"\xC4","auml":"\xE4","awconint":"\u2233","awint":"\u2A11","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","Backslash":"\u2216","Barv":"\u2AE7","barvee":"\u22BD","barwed":"\u2305","Barwed":"\u2306","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","Bcy":"\u0411","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","Because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","Bernoullis":"\u212C","Beta":"\u0392","beta":"\u03B2","beth":"\u2136","between":"\u226C","Bfr":"\uD835\uDD05","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bNot":"\u2AED","bnot":"\u2310","Bopf":"\uD835\uDD39","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxbox":"\u29C9","boxdl":"\u2510","boxdL":"\u2555","boxDl":"\u2556","boxDL":"\u2557","boxdr":"\u250C","boxdR":"\u2552","boxDr":"\u2553","boxDR":"\u2554","boxh":"\u2500","boxH":"\u2550","boxhd":"\u252C","boxHd":"\u2564","boxhD":"\u2565","boxHD":"\u2566","boxhu":"\u2534","boxHu":"\u2567","boxhU":"\u2568","boxHU":"\u2569","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxul":"\u2518","boxuL":"\u255B","boxUl":"\u255C","boxUL":"\u255D","boxur":"\u2514","boxuR":"\u2558","boxUr":"\u2559","boxUR":"\u255A","boxv":"\u2502","boxV":"\u2551","boxvh":"\u253C","boxvH":"\u256A","boxVh":"\u256B","boxVH":"\u256C","boxvl":"\u2524","boxvL":"\u2561","boxVl":"\u2562","boxVL":"\u2563","boxvr":"\u251C","boxvR":"\u255E","boxVr":"\u255F","boxVR":"\u2560","bprime":"\u2035","breve":"\u02D8","Breve":"\u02D8","brvbar":"\xA6","bscr":"\uD835\uDCB7","Bscr":"\u212C","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsolb":"\u29C5","bsol":"\\","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","Bumpeq":"\u224E","bumpeq":"\u224F","Cacute":"\u0106","cacute":"\u0107","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","cap":"\u2229","Cap":"\u22D2","capcup":"\u2A47","capdot":"\u2A40","CapitalDifferentialD":"\u2145","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","Cayleys":"\u212D","ccaps":"\u2A4D","Ccaron":"\u010C","ccaron":"\u010D","Ccedil":"\xC7","ccedil":"\xE7","Ccirc":"\u0108","ccirc":"\u0109","Cconint":"\u2230","ccups":"\u2A4C","ccupssm":"\u2A50","Cdot":"\u010A","cdot":"\u010B","cedil":"\xB8","Cedilla":"\xB8","cemptyv":"\u29B2","cent":"\xA2","centerdot":"\xB7","CenterDot":"\xB7","cfr":"\uD835\uDD20","Cfr":"\u212D","CHcy":"\u0427","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","Chi":"\u03A7","chi":"\u03C7","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","CircleDot":"\u2299","circledR":"\xAE","circledS":"\u24C8","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","cir":"\u25CB","cirE":"\u29C3","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","clubs":"\u2663","clubsuit":"\u2663","colon":":","Colon":"\u2237","Colone":"\u2A74","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","Congruent":"\u2261","conint":"\u222E","Conint":"\u222F","ContourIntegral":"\u222E","copf":"\uD835\uDD54","Copf":"\u2102","coprod":"\u2210","Coproduct":"\u2210","copy":"\xA9","COPY":"\xA9","copysr":"\u2117","CounterClockwiseContourIntegral":"\u2233","crarr":"\u21B5","cross":"\u2717","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cupbrcap":"\u2A48","cupcap":"\u2A46","CupCap":"\u224D","cup":"\u222A","Cup":"\u22D3","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curren":"\xA4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dagger":"\u2020","Dagger":"\u2021","daleth":"\u2138","darr":"\u2193","Darr":"\u21A1","dArr":"\u21D3","dash":"\u2010","Dashv":"\u2AE4","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","Dcaron":"\u010E","dcaron":"\u010F","Dcy":"\u0414","dcy":"\u0434","ddagger":"\u2021","ddarr":"\u21CA","DD":"\u2145","dd":"\u2146","DDotrahd":"\u2911","ddotseq":"\u2A77","deg":"\xB0","Del":"\u2207","Delta":"\u0394","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","Dfr":"\uD835\uDD07","dfr":"\uD835\uDD21","dHar":"\u2965","dharl":"\u21C3","dharr":"\u21C2","DiacriticalAcute":"\xB4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","diam":"\u22C4","diamond":"\u22C4","Diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\xA8","DifferentialD":"\u2146","digamma":"\u03DD","disin":"\u22F2","div":"\xF7","divide":"\xF7","divideontimes":"\u22C7","divonx":"\u22C7","DJcy":"\u0402","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","Dopf":"\uD835\uDD3B","dopf":"\uD835\uDD55","Dot":"\xA8","dot":"\u02D9","DotDot":"\u20DC","doteq":"\u2250","doteqdot":"\u2251","DotEqual":"\u2250","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","DoubleContourIntegral":"\u222F","DoubleDot":"\xA8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrowBar":"\u2913","downarrow":"\u2193","DownArrow":"\u2193","Downarrow":"\u21D3","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVectorBar":"\u2956","DownLeftVector":"\u21BD","DownRightTeeVector":"\u295F","DownRightVectorBar":"\u2957","DownRightVector":"\u21C1","DownTeeArrow":"\u21A7","DownTee":"\u22A4","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","Dscr":"\uD835\uDC9F","dscr":"\uD835\uDCB9","DScy":"\u0405","dscy":"\u0455","dsol":"\u29F6","Dstrok":"\u0110","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","DZcy":"\u040F","dzcy":"\u045F","dzigrarr":"\u27FF","Eacute":"\xC9","eacute":"\xE9","easter":"\u2A6E","Ecaron":"\u011A","ecaron":"\u011B","Ecirc":"\xCA","ecirc":"\xEA","ecir":"\u2256","ecolon":"\u2255","Ecy":"\u042D","ecy":"\u044D","eDDot":"\u2A77","Edot":"\u0116","edot":"\u0117","eDot":"\u2251","ee":"\u2147","efDot":"\u2252","Efr":"\uD835\uDD08","efr":"\uD835\uDD22","eg":"\u2A9A","Egrave":"\xC8","egrave":"\xE8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","Element":"\u2208","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","Emacr":"\u0112","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","EmptySmallSquare":"\u25FB","emptyv":"\u2205","EmptyVerySmallSquare":"\u25AB","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","ENG":"\u014A","eng":"\u014B","ensp":"\u2002","Eogon":"\u0118","eogon":"\u0119","Eopf":"\uD835\uDD3C","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","Epsilon":"\u0395","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","Equal":"\u2A75","equals":"=","EqualTilde":"\u2242","equest":"\u225F","Equilibrium":"\u21CC","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erarr":"\u2971","erDot":"\u2253","escr":"\u212F","Escr":"\u2130","esdot":"\u2250","Esim":"\u2A73","esim":"\u2242","Eta":"\u0397","eta":"\u03B7","ETH":"\xD0","eth":"\xF0","Euml":"\xCB","euml":"\xEB","euro":"\u20AC","excl":"!","exist":"\u2203","Exists":"\u2203","expectation":"\u2130","exponentiale":"\u2147","ExponentialE":"\u2147","fallingdotseq":"\u2252","Fcy":"\u0424","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","Ffr":"\uD835\uDD09","ffr":"\uD835\uDD23","filig":"\uFB01","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","Fopf":"\uD835\uDD3D","fopf":"\uD835\uDD57","forall":"\u2200","ForAll":"\u2200","fork":"\u22D4","forkv":"\u2AD9","Fouriertrf":"\u2131","fpartint":"\u2A0D","frac12":"\xBD","frac13":"\u2153","frac14":"\xBC","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac34":"\xBE","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","Fscr":"\u2131","gacute":"\u01F5","Gamma":"\u0393","gamma":"\u03B3","Gammad":"\u03DC","gammad":"\u03DD","gap":"\u2A86","Gbreve":"\u011E","gbreve":"\u011F","Gcedil":"\u0122","Gcirc":"\u011C","gcirc":"\u011D","Gcy":"\u0413","gcy":"\u0433","Gdot":"\u0120","gdot":"\u0121","ge":"\u2265","gE":"\u2267","gEl":"\u2A8C","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","gescc":"\u2AA9","ges":"\u2A7E","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","Gfr":"\uD835\uDD0A","gfr":"\uD835\uDD24","gg":"\u226B","Gg":"\u22D9","ggg":"\u22D9","gimel":"\u2137","GJcy":"\u0403","gjcy":"\u0453","gla":"\u2AA5","gl":"\u2277","glE":"\u2A92","glj":"\u2AA4","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gnE":"\u2269","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","Gopf":"\uD835\uDD3E","gopf":"\uD835\uDD58","grave":"`","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","gtcc":"\u2AA7","gtcir":"\u2A7A","gt":">","GT":">","Gt":"\u226B","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","Hacek":"\u02C7","hairsp":"\u200A","half":"\xBD","hamilt":"\u210B","HARDcy":"\u042A","hardcy":"\u044A","harrcir":"\u2948","harr":"\u2194","hArr":"\u21D4","harrw":"\u21AD","Hat":"^","hbar":"\u210F","Hcirc":"\u0124","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","Hfr":"\u210C","HilbertSpace":"\u210B","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","Hopf":"\u210D","horbar":"\u2015","HorizontalLine":"\u2500","hscr":"\uD835\uDCBD","Hscr":"\u210B","hslash":"\u210F","Hstrok":"\u0126","hstrok":"\u0127","HumpDownHump":"\u224E","HumpEqual":"\u224F","hybull":"\u2043","hyphen":"\u2010","Iacute":"\xCD","iacute":"\xED","ic":"\u2063","Icirc":"\xCE","icirc":"\xEE","Icy":"\u0418","icy":"\u0438","Idot":"\u0130","IEcy":"\u0415","iecy":"\u0435","iexcl":"\xA1","iff":"\u21D4","ifr":"\uD835\uDD26","Ifr":"\u2111","Igrave":"\xCC","igrave":"\xEC","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","IJlig":"\u0132","ijlig":"\u0133","Imacr":"\u012A","imacr":"\u012B","image":"\u2111","ImaginaryI":"\u2148","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","Im":"\u2111","imof":"\u22B7","imped":"\u01B5","Implies":"\u21D2","incare":"\u2105","in":"\u2208","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","intcal":"\u22BA","int":"\u222B","Int":"\u222C","integers":"\u2124","Integral":"\u222B","intercal":"\u22BA","Intersection":"\u22C2","intlarhk":"\u2A17","intprod":"\u2A3C","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","IOcy":"\u0401","iocy":"\u0451","Iogon":"\u012E","iogon":"\u012F","Iopf":"\uD835\uDD40","iopf":"\uD835\uDD5A","Iota":"\u0399","iota":"\u03B9","iprod":"\u2A3C","iquest":"\xBF","iscr":"\uD835\uDCBE","Iscr":"\u2110","isin":"\u2208","isindot":"\u22F5","isinE":"\u22F9","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","Itilde":"\u0128","itilde":"\u0129","Iukcy":"\u0406","iukcy":"\u0456","Iuml":"\xCF","iuml":"\xEF","Jcirc":"\u0134","jcirc":"\u0135","Jcy":"\u0419","jcy":"\u0439","Jfr":"\uD835\uDD0D","jfr":"\uD835\uDD27","jmath":"\u0237","Jopf":"\uD835\uDD41","jopf":"\uD835\uDD5B","Jscr":"\uD835\uDCA5","jscr":"\uD835\uDCBF","Jsercy":"\u0408","jsercy":"\u0458","Jukcy":"\u0404","jukcy":"\u0454","Kappa":"\u039A","kappa":"\u03BA","kappav":"\u03F0","Kcedil":"\u0136","kcedil":"\u0137","Kcy":"\u041A","kcy":"\u043A","Kfr":"\uD835\uDD0E","kfr":"\uD835\uDD28","kgreen":"\u0138","KHcy":"\u0425","khcy":"\u0445","KJcy":"\u040C","kjcy":"\u045C","Kopf":"\uD835\uDD42","kopf":"\uD835\uDD5C","Kscr":"\uD835\uDCA6","kscr":"\uD835\uDCC0","lAarr":"\u21DA","Lacute":"\u0139","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","Lambda":"\u039B","lambda":"\u03BB","lang":"\u27E8","Lang":"\u27EA","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","Laplacetrf":"\u2112","laquo":"\xAB","larrb":"\u21E4","larrbfs":"\u291F","larr":"\u2190","Larr":"\u219E","lArr":"\u21D0","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","latail":"\u2919","lAtail":"\u291B","lat":"\u2AAB","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lBarr":"\u290E","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","Lcaron":"\u013D","lcaron":"\u013E","Lcedil":"\u013B","lcedil":"\u013C","lceil":"\u2308","lcub":"{","Lcy":"\u041B","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","lE":"\u2266","LeftAngleBracket":"\u27E8","LeftArrowBar":"\u21E4","leftarrow":"\u2190","LeftArrow":"\u2190","Leftarrow":"\u21D0","LeftArrowRightArrow":"\u21C6","leftarrowtail":"\u21A2","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVectorBar":"\u2959","LeftDownVector":"\u21C3","LeftFloor":"\u230A","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","LeftRightArrow":"\u2194","Leftrightarrow":"\u21D4","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","LeftRightVector":"\u294E","LeftTeeArrow":"\u21A4","LeftTee":"\u22A3","LeftTeeVector":"\u295A","leftthreetimes":"\u22CB","LeftTriangleBar":"\u29CF","LeftTriangle":"\u22B2","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVectorBar":"\u2958","LeftUpVector":"\u21BF","LeftVectorBar":"\u2952","LeftVector":"\u21BC","lEg":"\u2A8B","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","lescc":"\u2AA8","les":"\u2A7D","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","lessgtr":"\u2276","LessLess":"\u2AA1","lesssim":"\u2272","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","lfisht":"\u297C","lfloor":"\u230A","Lfr":"\uD835\uDD0F","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lHar":"\u2962","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","LJcy":"\u0409","ljcy":"\u0459","llarr":"\u21C7","ll":"\u226A","Ll":"\u22D8","llcorner":"\u231E","Lleftarrow":"\u21DA","llhard":"\u296B","lltri":"\u25FA","Lmidot":"\u013F","lmidot":"\u0140","lmoustache":"\u23B0","lmoust":"\u23B0","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lnE":"\u2268","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","LongLeftArrow":"\u27F5","Longleftarrow":"\u27F8","longleftrightarrow":"\u27F7","LongLeftRightArrow":"\u27F7","Longleftrightarrow":"\u27FA","longmapsto":"\u27FC","longrightarrow":"\u27F6","LongRightArrow":"\u27F6","Longrightarrow":"\u27F9","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","Lopf":"\uD835\uDD43","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","Lscr":"\u2112","lsh":"\u21B0","Lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","Lstrok":"\u0141","lstrok":"\u0142","ltcc":"\u2AA6","ltcir":"\u2A79","lt":"<","LT":"<","Lt":"\u226A","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","ltrPar":"\u2996","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","macr":"\xAF","male":"\u2642","malt":"\u2720","maltese":"\u2720","Map":"\u2905","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","Mcy":"\u041C","mcy":"\u043C","mdash":"\u2014","mDDot":"\u223A","measuredangle":"\u2221","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","mfr":"\uD835\uDD2A","mho":"\u2127","micro":"\xB5","midast":"*","midcir":"\u2AF0","mid":"\u2223","middot":"\xB7","minusb":"\u229F","minus":"\u2212","minusd":"\u2238","minusdu":"\u2A2A","MinusPlus":"\u2213","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","Mopf":"\uD835\uDD44","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","Mscr":"\u2133","mstpos":"\u223E","Mu":"\u039C","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nabla":"\u2207","Nacute":"\u0143","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natural":"\u266E","naturals":"\u2115","natur":"\u266E","nbsp":"\xA0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","Ncaron":"\u0147","ncaron":"\u0148","Ncedil":"\u0145","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","Ncy":"\u041D","ncy":"\u043D","ndash":"\u2013","nearhk":"\u2924","nearr":"\u2197","neArr":"\u21D7","nearrow":"\u2197","ne":"\u2260","nedot":"\u2250\u0338","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\n","nexist":"\u2204","nexists":"\u2204","Nfr":"\uD835\uDD11","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","nGg":"\u22D9\u0338","ngsim":"\u2275","nGt":"\u226B\u20D2","ngt":"\u226F","ngtr":"\u226F","nGtv":"\u226B\u0338","nharr":"\u21AE","nhArr":"\u21CE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","NJcy":"\u040A","njcy":"\u045A","nlarr":"\u219A","nlArr":"\u21CD","nldr":"\u2025","nlE":"\u2266\u0338","nle":"\u2270","nleftarrow":"\u219A","nLeftarrow":"\u21CD","nleftrightarrow":"\u21AE","nLeftrightarrow":"\u21CE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nLl":"\u22D8\u0338","nlsim":"\u2274","nLt":"\u226A\u20D2","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nLtv":"\u226A\u0338","nmid":"\u2224","NoBreak":"\u2060","NonBreakingSpace":"\xA0","nopf":"\uD835\uDD5F","Nopf":"\u2115","Not":"\u2AEC","not":"\xAC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","notin":"\u2209","notindot":"\u22F5\u0338","notinE":"\u22F9\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangle":"\u22EB","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","nparallel":"\u2226","npar":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","nprec":"\u2280","npreceq":"\u2AAF\u0338","npre":"\u2AAF\u0338","nrarrc":"\u2933\u0338","nrarr":"\u219B","nrArr":"\u21CF","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nRightarrow":"\u21CF","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","Nscr":"\uD835\uDCA9","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","Ntilde":"\xD1","ntilde":"\xF1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","Nu":"\u039D","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvDash":"\u22AD","nVdash":"\u22AE","nVDash":"\u22AF","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvHarr":"\u2904","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwarhk":"\u2923","nwarr":"\u2196","nwArr":"\u21D6","nwarrow":"\u2196","nwnear":"\u2927","Oacute":"\xD3","oacute":"\xF3","oast":"\u229B","Ocirc":"\xD4","ocirc":"\xF4","ocir":"\u229A","Ocy":"\u041E","ocy":"\u043E","odash":"\u229D","Odblac":"\u0150","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","OElig":"\u0152","oelig":"\u0153","ofcir":"\u29BF","Ofr":"\uD835\uDD12","ofr":"\uD835\uDD2C","ogon":"\u02DB","Ograve":"\xD2","ograve":"\xF2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","Omacr":"\u014C","omacr":"\u014D","Omega":"\u03A9","omega":"\u03C9","Omicron":"\u039F","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","Oopf":"\uD835\uDD46","oopf":"\uD835\uDD60","opar":"\u29B7","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","operp":"\u29B9","oplus":"\u2295","orarr":"\u21BB","Or":"\u2A54","or":"\u2228","ord":"\u2A5D","order":"\u2134","orderof":"\u2134","ordf":"\xAA","ordm":"\xBA","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oS":"\u24C8","Oscr":"\uD835\uDCAA","oscr":"\u2134","Oslash":"\xD8","oslash":"\xF8","osol":"\u2298","Otilde":"\xD5","otilde":"\xF5","otimesas":"\u2A36","Otimes":"\u2A37","otimes":"\u2297","Ouml":"\xD6","ouml":"\xF6","ovbar":"\u233D","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","para":"\xB6","parallel":"\u2225","par":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","PartialD":"\u2202","Pcy":"\u041F","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","Pfr":"\uD835\uDD13","pfr":"\uD835\uDD2D","Phi":"\u03A6","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","Pi":"\u03A0","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plus":"+","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","PlusMinus":"\xB1","plusmn":"\xB1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\xB1","Poincareplane":"\u210C","pointint":"\u2A15","popf":"\uD835\uDD61","Popf":"\u2119","pound":"\xA3","prap":"\u2AB7","Pr":"\u2ABB","pr":"\u227A","prcue":"\u227C","precapprox":"\u2AB7","prec":"\u227A","preccurlyeq":"\u227C","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","pre":"\u2AAF","prE":"\u2AB3","precsim":"\u227E","prime":"\u2032","Prime":"\u2033","primes":"\u2119","prnap":"\u2AB9","prnE":"\u2AB5","prnsim":"\u22E8","prod":"\u220F","Product":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","Proportional":"\u221D","Proportion":"\u2237","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","Pscr":"\uD835\uDCAB","pscr":"\uD835\uDCC5","Psi":"\u03A8","psi":"\u03C8","puncsp":"\u2008","Qfr":"\uD835\uDD14","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","Qopf":"\u211A","qprime":"\u2057","Qscr":"\uD835\uDCAC","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quot":"\"","QUOT":"\"","rAarr":"\u21DB","race":"\u223D\u0331","Racute":"\u0154","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","Rang":"\u27EB","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raquo":"\xBB","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarr":"\u2192","Rarr":"\u21A0","rArr":"\u21D2","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","Rarrtl":"\u2916","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","rAtail":"\u291C","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rBarr":"\u290F","RBarr":"\u2910","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","Rcaron":"\u0158","rcaron":"\u0159","Rcedil":"\u0156","rcedil":"\u0157","rceil":"\u2309","rcub":"}","Rcy":"\u0420","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","Re":"\u211C","rect":"\u25AD","reg":"\xAE","REG":"\xAE","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","Rfr":"\u211C","rHar":"\u2964","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","Rho":"\u03A1","rho":"\u03C1","rhov":"\u03F1","RightAngleBracket":"\u27E9","RightArrowBar":"\u21E5","rightarrow":"\u2192","RightArrow":"\u2192","Rightarrow":"\u21D2","RightArrowLeftArrow":"\u21C4","rightarrowtail":"\u21A3","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVectorBar":"\u2955","RightDownVector":"\u21C2","RightFloor":"\u230B","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","RightTeeArrow":"\u21A6","RightTee":"\u22A2","RightTeeVector":"\u295B","rightthreetimes":"\u22CC","RightTriangleBar":"\u29D0","RightTriangle":"\u22B3","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVectorBar":"\u2954","RightUpVector":"\u21BE","RightVectorBar":"\u2953","RightVector":"\u21C0","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoustache":"\u23B1","rmoust":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","Ropf":"\u211D","roplus":"\u2A2E","rotimes":"\u2A35","RoundImplies":"\u2970","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","Rrightarrow":"\u21DB","rsaquo":"\u203A","rscr":"\uD835\uDCC7","Rscr":"\u211B","rsh":"\u21B1","Rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","RuleDelayed":"\u29F4","ruluhar":"\u2968","rx":"\u211E","Sacute":"\u015A","sacute":"\u015B","sbquo":"\u201A","scap":"\u2AB8","Scaron":"\u0160","scaron":"\u0161","Sc":"\u2ABC","sc":"\u227B","sccue":"\u227D","sce":"\u2AB0","scE":"\u2AB4","Scedil":"\u015E","scedil":"\u015F","Scirc":"\u015C","scirc":"\u015D","scnap":"\u2ABA","scnE":"\u2AB6","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","Scy":"\u0421","scy":"\u0441","sdotb":"\u22A1","sdot":"\u22C5","sdote":"\u2A66","searhk":"\u2925","searr":"\u2198","seArr":"\u21D8","searrow":"\u2198","sect":"\xA7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","Sfr":"\uD835\uDD16","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","SHCHcy":"\u0429","shchcy":"\u0449","SHcy":"\u0428","shcy":"\u0448","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","shortmid":"\u2223","shortparallel":"\u2225","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","shy":"\xAD","Sigma":"\u03A3","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","SmallCircle":"\u2218","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","SOFTcy":"\u042C","softcy":"\u044C","solbar":"\u233F","solb":"\u29C4","sol":"/","Sopf":"\uD835\uDD4A","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","Sqrt":"\u221A","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","square":"\u25A1","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","squarf":"\u25AA","squ":"\u25A1","squf":"\u25AA","srarr":"\u2192","Sscr":"\uD835\uDCAE","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","Star":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\xAF","sub":"\u2282","Sub":"\u22D0","subdot":"\u2ABD","subE":"\u2AC5","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","Subset":"\u22D0","subseteq":"\u2286","subseteqq":"\u2AC5","SubsetEqual":"\u2286","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succapprox":"\u2AB8","succ":"\u227B","succcurlyeq":"\u227D","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","SuchThat":"\u220B","sum":"\u2211","Sum":"\u2211","sung":"\u266A","sup1":"\xB9","sup2":"\xB2","sup3":"\xB3","sup":"\u2283","Sup":"\u22D1","supdot":"\u2ABE","supdsub":"\u2AD8","supE":"\u2AC6","supe":"\u2287","supedot":"\u2AC4","Superset":"\u2283","SupersetEqual":"\u2287","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","Supset":"\u22D1","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swarhk":"\u2926","swarr":"\u2199","swArr":"\u21D9","swarrow":"\u2199","swnwar":"\u292A","szlig":"\xDF","Tab":"\t","target":"\u2316","Tau":"\u03A4","tau":"\u03C4","tbrk":"\u23B4","Tcaron":"\u0164","tcaron":"\u0165","Tcedil":"\u0162","tcedil":"\u0163","Tcy":"\u0422","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","Tfr":"\uD835\uDD17","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","Therefore":"\u2234","Theta":"\u0398","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","THORN":"\xDE","thorn":"\xFE","tilde":"\u02DC","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","timesbar":"\u2A31","timesb":"\u22A0","times":"\xD7","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","topbot":"\u2336","topcir":"\u2AF1","top":"\u22A4","Topf":"\uD835\uDD4B","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","TRADE":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","TripleDot":"\u20DB","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","Tscr":"\uD835\uDCAF","tscr":"\uD835\uDCC9","TScy":"\u0426","tscy":"\u0446","TSHcy":"\u040B","tshcy":"\u045B","Tstrok":"\u0166","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","Uacute":"\xDA","uacute":"\xFA","uarr":"\u2191","Uarr":"\u219F","uArr":"\u21D1","Uarrocir":"\u2949","Ubrcy":"\u040E","ubrcy":"\u045E","Ubreve":"\u016C","ubreve":"\u016D","Ucirc":"\xDB","ucirc":"\xFB","Ucy":"\u0423","ucy":"\u0443","udarr":"\u21C5","Udblac":"\u0170","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","Ufr":"\uD835\uDD18","ufr":"\uD835\uDD32","Ugrave":"\xD9","ugrave":"\xF9","uHar":"\u2963","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","Umacr":"\u016A","umacr":"\u016B","uml":"\xA8","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","uogon":"\u0173","Uopf":"\uD835\uDD4C","uopf":"\uD835\uDD66","UpArrowBar":"\u2912","uparrow":"\u2191","UpArrow":"\u2191","Uparrow":"\u21D1","UpArrowDownArrow":"\u21C5","updownarrow":"\u2195","UpDownArrow":"\u2195","Updownarrow":"\u21D5","UpEquilibrium":"\u296E","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","upsi":"\u03C5","Upsi":"\u03D2","upsih":"\u03D2","Upsilon":"\u03A5","upsilon":"\u03C5","UpTeeArrow":"\u21A5","UpTee":"\u22A5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","Uring":"\u016E","uring":"\u016F","urtri":"\u25F9","Uscr":"\uD835\uDCB0","uscr":"\uD835\uDCCA","utdot":"\u22F0","Utilde":"\u0168","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","Uuml":"\xDC","uuml":"\xFC","uwangle":"\u29A7","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","vArr":"\u21D5","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vBar":"\u2AE8","Vbar":"\u2AEB","vBarv":"\u2AE9","Vcy":"\u0412","vcy":"\u0432","vdash":"\u22A2","vDash":"\u22A8","Vdash":"\u22A9","VDash":"\u22AB","Vdashl":"\u2AE6","veebar":"\u22BB","vee":"\u2228","Vee":"\u22C1","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","Verbar":"\u2016","vert":"|","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","Vopf":"\uD835\uDD4D","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","Vscr":"\uD835\uDCB1","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","Vvdash":"\u22AA","vzigzag":"\u299A","Wcirc":"\u0174","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","Wedge":"\u22C0","wedgeq":"\u2259","weierp":"\u2118","Wfr":"\uD835\uDD1A","wfr":"\uD835\uDD34","Wopf":"\uD835\uDD4E","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","Wscr":"\uD835\uDCB2","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","Xfr":"\uD835\uDD1B","xfr":"\uD835\uDD35","xharr":"\u27F7","xhArr":"\u27FA","Xi":"\u039E","xi":"\u03BE","xlarr":"\u27F5","xlArr":"\u27F8","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","Xopf":"\uD835\uDD4F","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrarr":"\u27F6","xrArr":"\u27F9","Xscr":"\uD835\uDCB3","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","Yacute":"\xDD","yacute":"\xFD","YAcy":"\u042F","yacy":"\u044F","Ycirc":"\u0176","ycirc":"\u0177","Ycy":"\u042B","ycy":"\u044B","yen":"\xA5","Yfr":"\uD835\uDD1C","yfr":"\uD835\uDD36","YIcy":"\u0407","yicy":"\u0457","Yopf":"\uD835\uDD50","yopf":"\uD835\uDD6A","Yscr":"\uD835\uDCB4","yscr":"\uD835\uDCCE","YUcy":"\u042E","yucy":"\u044E","yuml":"\xFF","Yuml":"\u0178","Zacute":"\u0179","zacute":"\u017A","Zcaron":"\u017D","zcaron":"\u017E","Zcy":"\u0417","zcy":"\u0437","Zdot":"\u017B","zdot":"\u017C","zeetrf":"\u2128","ZeroWidthSpace":"\u200B","Zeta":"\u0396","zeta":"\u03B6","zfr":"\uD835\uDD37","Zfr":"\u2128","ZHcy":"\u0416","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","Zopf":"\u2124","Zscr":"\uD835\uDCB5","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"};},{}],29:[function(require,module,exports){module.exports={"Aacute":"\xC1","aacute":"\xE1","Acirc":"\xC2","acirc":"\xE2","acute":"\xB4","AElig":"\xC6","aelig":"\xE6","Agrave":"\xC0","agrave":"\xE0","amp":"&","AMP":"&","Aring":"\xC5","aring":"\xE5","Atilde":"\xC3","atilde":"\xE3","Auml":"\xC4","auml":"\xE4","brvbar":"\xA6","Ccedil":"\xC7","ccedil":"\xE7","cedil":"\xB8","cent":"\xA2","copy":"\xA9","COPY":"\xA9","curren":"\xA4","deg":"\xB0","divide":"\xF7","Eacute":"\xC9","eacute":"\xE9","Ecirc":"\xCA","ecirc":"\xEA","Egrave":"\xC8","egrave":"\xE8","ETH":"\xD0","eth":"\xF0","Euml":"\xCB","euml":"\xEB","frac12":"\xBD","frac14":"\xBC","frac34":"\xBE","gt":">","GT":">","Iacute":"\xCD","iacute":"\xED","Icirc":"\xCE","icirc":"\xEE","iexcl":"\xA1","Igrave":"\xCC","igrave":"\xEC","iquest":"\xBF","Iuml":"\xCF","iuml":"\xEF","laquo":"\xAB","lt":"<","LT":"<","macr":"\xAF","micro":"\xB5","middot":"\xB7","nbsp":"\xA0","not":"\xAC","Ntilde":"\xD1","ntilde":"\xF1","Oacute":"\xD3","oacute":"\xF3","Ocirc":"\xD4","ocirc":"\xF4","Ograve":"\xD2","ograve":"\xF2","ordf":"\xAA","ordm":"\xBA","Oslash":"\xD8","oslash":"\xF8","Otilde":"\xD5","otilde":"\xF5","Ouml":"\xD6","ouml":"\xF6","para":"\xB6","plusmn":"\xB1","pound":"\xA3","quot":"\"","QUOT":"\"","raquo":"\xBB","reg":"\xAE","REG":"\xAE","sect":"\xA7","shy":"\xAD","sup1":"\xB9","sup2":"\xB2","sup3":"\xB3","szlig":"\xDF","THORN":"\xDE","thorn":"\xFE","times":"\xD7","Uacute":"\xDA","uacute":"\xFA","Ucirc":"\xDB","ucirc":"\xFB","Ugrave":"\xD9","ugrave":"\xF9","uml":"\xA8","Uuml":"\xDC","uuml":"\xFC","Yacute":"\xDD","yacute":"\xFD","yen":"\xA5","yuml":"\xFF"};},{}],30:[function(require,module,exports){module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""};},{}],31:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var objectCreate=Object.create||objectCreatePolyfill;var objectKeys=Object.keys||objectKeysPolyfill;var bind=Function.prototype.bind||functionBindPolyfill;function EventEmitter(){if(!this._events||!Object.prototype.hasOwnProperty.call(this,'_events')){this._events=objectCreate(null);this._eventsCount=0;}this._maxListeners=this._maxListeners||undefined;}module.exports=EventEmitter;// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners=10;var hasDefineProperty;try{var o={};if(Object.defineProperty)Object.defineProperty(o,'x',{value:0});hasDefineProperty=o.x===0;}catch(err){hasDefineProperty=false;}if(hasDefineProperty){Object.defineProperty(EventEmitter,'defaultMaxListeners',{enumerable:true,get:function get(){return defaultMaxListeners;},set:function set(arg){// check whether the input is a positive number (whose value is zero or
// greater and not a NaN).
if(typeof arg!=='number'||arg<0||arg!==arg)throw new TypeError('"defaultMaxListeners" must be a positive number');defaultMaxListeners=arg;}});}else{EventEmitter.defaultMaxListeners=defaultMaxListeners;}// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners=function setMaxListeners(n){if(typeof n!=='number'||n<0||isNaN(n))throw new TypeError('"n" argument must be a positive number');this._maxListeners=n;return this;};function $getMaxListeners(that){if(that._maxListeners===undefined)return EventEmitter.defaultMaxListeners;return that._maxListeners;}EventEmitter.prototype.getMaxListeners=function getMaxListeners(){return $getMaxListeners(this);};// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler,isFn,self){if(isFn)handler.call(self);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self);}}}function emitOne(handler,isFn,self,arg1){if(isFn)handler.call(self,arg1);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1);}}}function emitTwo(handler,isFn,self,arg1,arg2){if(isFn)handler.call(self,arg1,arg2);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2);}}}function emitThree(handler,isFn,self,arg1,arg2,arg3){if(isFn)handler.call(self,arg1,arg2,arg3);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2,arg3);}}}function emitMany(handler,isFn,self,args){if(isFn)handler.apply(self,args);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].apply(self,args);}}}EventEmitter.prototype.emit=function emit(type){var er,handler,len,args,i,events;var doError=type==='error';events=this._events;if(events)doError=doError&&events.error==null;else if(!doError)return false;// If there is no 'error' event listener then throw.
if(doError){if(arguments.length>1)er=arguments[1];if(er instanceof Error){throw er;// Unhandled 'error' event
}else{// At least give some kind of context to the user
var err=new Error('Unhandled "error" event. ('+er+')');err.context=er;throw err;}return false;}handler=events[type];if(!handler)return false;var isFn=typeof handler==='function';len=arguments.length;switch(len){// fast cases
case 1:emitNone(handler,isFn,this);break;case 2:emitOne(handler,isFn,this,arguments[1]);break;case 3:emitTwo(handler,isFn,this,arguments[1],arguments[2]);break;case 4:emitThree(handler,isFn,this,arguments[1],arguments[2],arguments[3]);break;// slower
default:args=new Array(len-1);for(i=1;i<len;i++){args[i-1]=arguments[i];}emitMany(handler,isFn,this,args);}return true;};function _addListener(target,type,listener,prepend){var m;var events;var existing;if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');events=target._events;if(!events){events=target._events=objectCreate(null);target._eventsCount=0;}else{// To avoid recursion in the case that type === "newListener"! Before
// adding it to the listeners, first emit "newListener".
if(events.newListener){target.emit('newListener',type,listener.listener?listener.listener:listener);// Re-assign `events` because a newListener handler could have caused the
// this._events to be assigned to a new object
events=target._events;}existing=events[type];}if(!existing){// Optimize the case of one listener. Don't need the extra array object.
existing=events[type]=listener;++target._eventsCount;}else{if(typeof existing==='function'){// Adding the second element, need to change to array.
existing=events[type]=prepend?[listener,existing]:[existing,listener];}else{// If we've already got an array, just append.
if(prepend){existing.unshift(listener);}else{existing.push(listener);}}// Check for listener leak
if(!existing.warned){m=$getMaxListeners(target);if(m&&m>0&&existing.length>m){existing.warned=true;var w=new Error('Possible EventEmitter memory leak detected. '+existing.length+' "'+String(type)+'" listeners '+'added. Use emitter.setMaxListeners() to '+'increase limit.');w.name='MaxListenersExceededWarning';w.emitter=target;w.type=type;w.count=existing.length;if((typeof console==="undefined"?"undefined":_typeof(console))==='object'&&console.warn){console.warn('%s: %s',w.name,w.message);}}}}return target;}EventEmitter.prototype.addListener=function addListener(type,listener){return _addListener(this,type,listener,false);};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.prependListener=function prependListener(type,listener){return _addListener(this,type,listener,true);};function onceWrapper(){if(!this.fired){this.target.removeListener(this.type,this.wrapFn);this.fired=true;switch(arguments.length){case 0:return this.listener.call(this.target);case 1:return this.listener.call(this.target,arguments[0]);case 2:return this.listener.call(this.target,arguments[0],arguments[1]);case 3:return this.listener.call(this.target,arguments[0],arguments[1],arguments[2]);default:var args=new Array(arguments.length);for(var i=0;i<args.length;++i){args[i]=arguments[i];}this.listener.apply(this.target,args);}}}function _onceWrap(target,type,listener){var state={fired:false,wrapFn:undefined,target:target,type:type,listener:listener};var wrapped=bind.call(onceWrapper,state);wrapped.listener=listener;state.wrapFn=wrapped;return wrapped;}EventEmitter.prototype.once=function once(type,listener){if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');this.on(type,_onceWrap(this,type,listener));return this;};EventEmitter.prototype.prependOnceListener=function prependOnceListener(type,listener){if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');this.prependListener(type,_onceWrap(this,type,listener));return this;};// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener=function removeListener(type,listener){var list,events,position,i,originalListener;if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');events=this._events;if(!events)return this;list=events[type];if(!list)return this;if(list===listener||list.listener===listener){if(--this._eventsCount===0)this._events=objectCreate(null);else{delete events[type];if(events.removeListener)this.emit('removeListener',type,list.listener||listener);}}else if(typeof list!=='function'){position=-1;for(i=list.length-1;i>=0;i--){if(list[i]===listener||list[i].listener===listener){originalListener=list[i].listener;position=i;break;}}if(position<0)return this;if(position===0)list.shift();else spliceOne(list,position);if(list.length===1)events[type]=list[0];if(events.removeListener)this.emit('removeListener',type,originalListener||listener);}return this;};EventEmitter.prototype.removeAllListeners=function removeAllListeners(type){var listeners,events,i;events=this._events;if(!events)return this;// not listening for removeListener, no need to emit
if(!events.removeListener){if(arguments.length===0){this._events=objectCreate(null);this._eventsCount=0;}else if(events[type]){if(--this._eventsCount===0)this._events=objectCreate(null);else delete events[type];}return this;}// emit removeListener for all listeners on all events
if(arguments.length===0){var keys=objectKeys(events);var key;for(i=0;i<keys.length;++i){key=keys[i];if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events=objectCreate(null);this._eventsCount=0;return this;}listeners=events[type];if(typeof listeners==='function'){this.removeListener(type,listeners);}else if(listeners){// LIFO order
for(i=listeners.length-1;i>=0;i--){this.removeListener(type,listeners[i]);}}return this;};function _listeners(target,type,unwrap){var events=target._events;if(!events)return[];var evlistener=events[type];if(!evlistener)return[];if(typeof evlistener==='function')return unwrap?[evlistener.listener||evlistener]:[evlistener];return unwrap?unwrapListeners(evlistener):arrayClone(evlistener,evlistener.length);}EventEmitter.prototype.listeners=function listeners(type){return _listeners(this,type,true);};EventEmitter.prototype.rawListeners=function rawListeners(type){return _listeners(this,type,false);};EventEmitter.listenerCount=function(emitter,type){if(typeof emitter.listenerCount==='function'){return emitter.listenerCount(type);}else{return listenerCount.call(emitter,type);}};EventEmitter.prototype.listenerCount=listenerCount;function listenerCount(type){var events=this._events;if(events){var evlistener=events[type];if(typeof evlistener==='function'){return 1;}else if(evlistener){return evlistener.length;}}return 0;}EventEmitter.prototype.eventNames=function eventNames(){return this._eventsCount>0?Reflect.ownKeys(this._events):[];};// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list,index){for(var i=index,k=i+1,n=list.length;k<n;i+=1,k+=1){list[i]=list[k];}list.pop();}function arrayClone(arr,n){var copy=new Array(n);for(var i=0;i<n;++i){copy[i]=arr[i];}return copy;}function unwrapListeners(arr){var ret=new Array(arr.length);for(var i=0;i<ret.length;++i){ret[i]=arr[i].listener||arr[i];}return ret;}function objectCreatePolyfill(proto){var F=function F(){};F.prototype=proto;return new F();}function objectKeysPolyfill(obj){var keys=[];for(var k in obj){if(Object.prototype.hasOwnProperty.call(obj,k)){keys.push(k);}}return k;}function functionBindPolyfill(context){var fn=this;return function(){return fn.apply(context,arguments);};}},{}],32:[function(require,module,exports){module.exports=CollectingHandler;function CollectingHandler(cbs){this._cbs=cbs||{};this.events=[];}var EVENTS=require("./").EVENTS;Object.keys(EVENTS).forEach(function(name){if(EVENTS[name]===0){name="on"+name;CollectingHandler.prototype[name]=function(){this.events.push([name]);if(this._cbs[name])this._cbs[name]();};}else if(EVENTS[name]===1){name="on"+name;CollectingHandler.prototype[name]=function(a){this.events.push([name,a]);if(this._cbs[name])this._cbs[name](a);};}else if(EVENTS[name]===2){name="on"+name;CollectingHandler.prototype[name]=function(a,b){this.events.push([name,a,b]);if(this._cbs[name])this._cbs[name](a,b);};}else{throw Error("wrong number of arguments");}});CollectingHandler.prototype.onreset=function(){this.events=[];if(this._cbs.onreset)this._cbs.onreset();};CollectingHandler.prototype.restart=function(){if(this._cbs.onreset)this._cbs.onreset();for(var i=0,len=this.events.length;i<len;i++){if(this._cbs[this.events[i][0]]){var num=this.events[i].length;if(num===1){this._cbs[this.events[i][0]]();}else if(num===2){this._cbs[this.events[i][0]](this.events[i][1]);}else{this._cbs[this.events[i][0]](this.events[i][1],this.events[i][2]);}}}};},{"./":39}],33:[function(require,module,exports){var DomHandler=require("domhandler");var DomUtils=require("domutils");//TODO: make this a streamable handler
function FeedHandler(callback,options){this.init(callback,options);}require("inherits")(FeedHandler,DomHandler);FeedHandler.prototype.init=DomHandler;function getElements(what,where){return DomUtils.getElementsByTagName(what,where,true);}function getOneElement(what,where){return DomUtils.getElementsByTagName(what,where,true,1)[0];}function fetch(what,where,recurse){return DomUtils.getText(DomUtils.getElementsByTagName(what,where,recurse,1)).trim();}function addConditionally(obj,prop,what,where,recurse){var tmp=fetch(what,where,recurse);if(tmp)obj[prop]=tmp;}var isValidFeed=function isValidFeed(value){return value==="rss"||value==="feed"||value==="rdf:RDF";};FeedHandler.prototype.onend=function(){var feed={},feedRoot=getOneElement(isValidFeed,this.dom),tmp,childs;if(feedRoot){if(feedRoot.name==="feed"){childs=feedRoot.children;feed.type="atom";addConditionally(feed,"id","id",childs);addConditionally(feed,"title","title",childs);if((tmp=getOneElement("link",childs))&&(tmp=tmp.attribs)&&(tmp=tmp.href))feed.link=tmp;addConditionally(feed,"description","subtitle",childs);if(tmp=fetch("updated",childs))feed.updated=new Date(tmp);addConditionally(feed,"author","email",childs,true);feed.items=getElements("entry",childs).map(function(item){var entry={},tmp;item=item.children;addConditionally(entry,"id","id",item);addConditionally(entry,"title","title",item);if((tmp=getOneElement("link",item))&&(tmp=tmp.attribs)&&(tmp=tmp.href))entry.link=tmp;if(tmp=fetch("summary",item)||fetch("content",item))entry.description=tmp;if(tmp=fetch("updated",item))entry.pubDate=new Date(tmp);return entry;});}else{childs=getOneElement("channel",feedRoot.children).children;feed.type=feedRoot.name.substr(0,3);feed.id="";addConditionally(feed,"title","title",childs);addConditionally(feed,"link","link",childs);addConditionally(feed,"description","description",childs);if(tmp=fetch("lastBuildDate",childs))feed.updated=new Date(tmp);addConditionally(feed,"author","managingEditor",childs,true);feed.items=getElements("item",feedRoot.children).map(function(item){var entry={},tmp;item=item.children;addConditionally(entry,"id","guid",item);addConditionally(entry,"title","title",item);addConditionally(entry,"link","link",item);addConditionally(entry,"description","description",item);if(tmp=fetch("pubDate",item))entry.pubDate=new Date(tmp);return entry;});}}this.dom=feed;DomHandler.prototype._handleCallback.call(this,feedRoot?null:Error("couldn't find root of feed"));};module.exports=FeedHandler;},{"domhandler":16,"domutils":19,"inherits":41}],34:[function(require,module,exports){var Tokenizer=require("./Tokenizer.js");/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/ /*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/var formTags={input:true,option:true,optgroup:true,select:true,button:true,datalist:true,textarea:true};var openImpliesClose={tr:{tr:true,th:true,td:true},th:{th:true},td:{thead:true,th:true,td:true},body:{head:true,link:true,script:true},li:{li:true},p:{p:true},h1:{p:true},h2:{p:true},h3:{p:true},h4:{p:true},h5:{p:true},h6:{p:true},select:formTags,input:formTags,output:formTags,button:formTags,datalist:formTags,textarea:formTags,option:{option:true},optgroup:{optgroup:true}};var voidElements={__proto__:null,area:true,base:true,basefont:true,br:true,col:true,command:true,embed:true,frame:true,hr:true,img:true,input:true,isindex:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};var foreignContextElements={__proto__:null,math:true,svg:true};var htmlIntegrationElements={__proto__:null,mi:true,mo:true,mn:true,ms:true,mtext:true,"annotation-xml":true,foreignObject:true,desc:true,title:true};var re_nameEnd=/\s|\//;function Parser(cbs,options){this._options=options||{};this._cbs=cbs||{};this._tagname="";this._attribname="";this._attribvalue="";this._attribs=null;this._stack=[];this._foreignContext=[];this.startIndex=0;this.endIndex=null;this._lowerCaseTagNames="lowerCaseTags"in this._options?!!this._options.lowerCaseTags:!this._options.xmlMode;this._lowerCaseAttributeNames="lowerCaseAttributeNames"in this._options?!!this._options.lowerCaseAttributeNames:!this._options.xmlMode;if(this._options.Tokenizer){Tokenizer=this._options.Tokenizer;}this._tokenizer=new Tokenizer(this._options,this);if(this._cbs.onparserinit)this._cbs.onparserinit(this);}require("inherits")(Parser,require("events").EventEmitter);Parser.prototype._updatePosition=function(initialOffset){if(this.endIndex===null){if(this._tokenizer._sectionStart<=initialOffset){this.startIndex=0;}else{this.startIndex=this._tokenizer._sectionStart-initialOffset;}}else this.startIndex=this.endIndex+1;this.endIndex=this._tokenizer.getAbsoluteIndex();};//Tokenizer event handlers
Parser.prototype.ontext=function(data){this._updatePosition(1);this.endIndex--;if(this._cbs.ontext)this._cbs.ontext(data);};Parser.prototype.onopentagname=function(name){if(this._lowerCaseTagNames){name=name.toLowerCase();}this._tagname=name;if(!this._options.xmlMode&&name in openImpliesClose){for(var el;(el=this._stack[this._stack.length-1])in openImpliesClose[name];this.onclosetag(el)){;}}if(this._options.xmlMode||!(name in voidElements)){this._stack.push(name);if(name in foreignContextElements)this._foreignContext.push(true);else if(name in htmlIntegrationElements)this._foreignContext.push(false);}if(this._cbs.onopentagname)this._cbs.onopentagname(name);if(this._cbs.onopentag)this._attribs={};};Parser.prototype.onopentagend=function(){this._updatePosition(1);if(this._attribs){if(this._cbs.onopentag)this._cbs.onopentag(this._tagname,this._attribs);this._attribs=null;}if(!this._options.xmlMode&&this._cbs.onclosetag&&this._tagname in voidElements){this._cbs.onclosetag(this._tagname);}this._tagname="";};Parser.prototype.onclosetag=function(name){this._updatePosition(1);if(this._lowerCaseTagNames){name=name.toLowerCase();}if(name in foreignContextElements||name in htmlIntegrationElements){this._foreignContext.pop();}if(this._stack.length&&(!(name in voidElements)||this._options.xmlMode)){var pos=this._stack.lastIndexOf(name);if(pos!==-1){if(this._cbs.onclosetag){pos=this._stack.length-pos;while(pos--){this._cbs.onclosetag(this._stack.pop());}}else this._stack.length=pos;}else if(name==="p"&&!this._options.xmlMode){this.onopentagname(name);this._closeCurrentTag();}}else if(!this._options.xmlMode&&(name==="br"||name==="p")){this.onopentagname(name);this._closeCurrentTag();}};Parser.prototype.onselfclosingtag=function(){if(this._options.xmlMode||this._options.recognizeSelfClosing||this._foreignContext[this._foreignContext.length-1]){this._closeCurrentTag();}else{this.onopentagend();}};Parser.prototype._closeCurrentTag=function(){var name=this._tagname;this.onopentagend();//self-closing tags will be on the top of the stack
//(cheaper check than in onclosetag)
if(this._stack[this._stack.length-1]===name){if(this._cbs.onclosetag){this._cbs.onclosetag(name);}this._stack.pop();}};Parser.prototype.onattribname=function(name){if(this._lowerCaseAttributeNames){name=name.toLowerCase();}this._attribname=name;};Parser.prototype.onattribdata=function(value){this._attribvalue+=value;};Parser.prototype.onattribend=function(){if(this._cbs.onattribute)this._cbs.onattribute(this._attribname,this._attribvalue);if(this._attribs&&!Object.prototype.hasOwnProperty.call(this._attribs,this._attribname)){this._attribs[this._attribname]=this._attribvalue;}this._attribname="";this._attribvalue="";};Parser.prototype._getInstructionName=function(value){var idx=value.search(re_nameEnd),name=idx<0?value:value.substr(0,idx);if(this._lowerCaseTagNames){name=name.toLowerCase();}return name;};Parser.prototype.ondeclaration=function(value){if(this._cbs.onprocessinginstruction){var name=this._getInstructionName(value);this._cbs.onprocessinginstruction("!"+name,"!"+value);}};Parser.prototype.onprocessinginstruction=function(value){if(this._cbs.onprocessinginstruction){var name=this._getInstructionName(value);this._cbs.onprocessinginstruction("?"+name,"?"+value);}};Parser.prototype.oncomment=function(value){this._updatePosition(4);if(this._cbs.oncomment)this._cbs.oncomment(value);if(this._cbs.oncommentend)this._cbs.oncommentend();};Parser.prototype.oncdata=function(value){this._updatePosition(1);if(this._options.xmlMode||this._options.recognizeCDATA){if(this._cbs.oncdatastart)this._cbs.oncdatastart();if(this._cbs.ontext)this._cbs.ontext(value);if(this._cbs.oncdataend)this._cbs.oncdataend();}else{this.oncomment("[CDATA["+value+"]]");}};Parser.prototype.onerror=function(err){if(this._cbs.onerror)this._cbs.onerror(err);};Parser.prototype.onend=function(){if(this._cbs.onclosetag){for(var i=this._stack.length;i>0;this._cbs.onclosetag(this._stack[--i])){;}}if(this._cbs.onend)this._cbs.onend();};//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset=function(){if(this._cbs.onreset)this._cbs.onreset();this._tokenizer.reset();this._tagname="";this._attribname="";this._attribs=null;this._stack=[];if(this._cbs.onparserinit)this._cbs.onparserinit(this);};//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete=function(data){this.reset();this.end(data);};Parser.prototype.write=function(chunk){this._tokenizer.write(chunk);};Parser.prototype.end=function(chunk){this._tokenizer.end(chunk);};Parser.prototype.pause=function(){this._tokenizer.pause();};Parser.prototype.resume=function(){this._tokenizer.resume();};//alias for backwards compat
Parser.prototype.parseChunk=Parser.prototype.write;Parser.prototype.done=Parser.prototype.end;module.exports=Parser;},{"./Tokenizer.js":37,"events":31,"inherits":41}],35:[function(require,module,exports){module.exports=ProxyHandler;function ProxyHandler(cbs){this._cbs=cbs||{};}var EVENTS=require("./").EVENTS;Object.keys(EVENTS).forEach(function(name){if(EVENTS[name]===0){name="on"+name;ProxyHandler.prototype[name]=function(){if(this._cbs[name])this._cbs[name]();};}else if(EVENTS[name]===1){name="on"+name;ProxyHandler.prototype[name]=function(a){if(this._cbs[name])this._cbs[name](a);};}else if(EVENTS[name]===2){name="on"+name;ProxyHandler.prototype[name]=function(a,b){if(this._cbs[name])this._cbs[name](a,b);};}else{throw Error("wrong number of arguments");}});},{"./":39}],36:[function(require,module,exports){module.exports=Stream;var Parser=require("./WritableStream.js");function Stream(options){Parser.call(this,new Cbs(this),options);}require("inherits")(Stream,Parser);Stream.prototype.readable=true;function Cbs(scope){this.scope=scope;}var EVENTS=require("../").EVENTS;Object.keys(EVENTS).forEach(function(name){if(EVENTS[name]===0){Cbs.prototype["on"+name]=function(){this.scope.emit(name);};}else if(EVENTS[name]===1){Cbs.prototype["on"+name]=function(a){this.scope.emit(name,a);};}else if(EVENTS[name]===2){Cbs.prototype["on"+name]=function(a,b){this.scope.emit(name,a,b);};}else{throw Error("wrong number of arguments!");}});},{"../":39,"./WritableStream.js":38,"inherits":41}],37:[function(require,module,exports){module.exports=Tokenizer;var decodeCodePoint=require("entities/lib/decode_codepoint.js");var entityMap=require("entities/maps/entities.json");var legacyMap=require("entities/maps/legacy.json");var xmlMap=require("entities/maps/xml.json");var i=0;var TEXT=i++;var BEFORE_TAG_NAME=i++;//after <
var IN_TAG_NAME=i++;var IN_SELF_CLOSING_TAG=i++;var BEFORE_CLOSING_TAG_NAME=i++;var IN_CLOSING_TAG_NAME=i++;var AFTER_CLOSING_TAG_NAME=i++;//attributes
var BEFORE_ATTRIBUTE_NAME=i++;var IN_ATTRIBUTE_NAME=i++;var AFTER_ATTRIBUTE_NAME=i++;var BEFORE_ATTRIBUTE_VALUE=i++;var IN_ATTRIBUTE_VALUE_DQ=i++;// "
var IN_ATTRIBUTE_VALUE_SQ=i++;// '
var IN_ATTRIBUTE_VALUE_NQ=i++;//declarations
var BEFORE_DECLARATION=i++;// !
var IN_DECLARATION=i++;//processing instructions
var IN_PROCESSING_INSTRUCTION=i++;// ?
//comments
var BEFORE_COMMENT=i++;var IN_COMMENT=i++;var AFTER_COMMENT_1=i++;var AFTER_COMMENT_2=i++;//cdata
var BEFORE_CDATA_1=i++;// [
var BEFORE_CDATA_2=i++;// C
var BEFORE_CDATA_3=i++;// D
var BEFORE_CDATA_4=i++;// A
var BEFORE_CDATA_5=i++;// T
var BEFORE_CDATA_6=i++;// A
var IN_CDATA=i++;// [
var AFTER_CDATA_1=i++;// ]
var AFTER_CDATA_2=i++;// ]
//special tags
var BEFORE_SPECIAL=i++;//S
var BEFORE_SPECIAL_END=i++;//S
var BEFORE_SCRIPT_1=i++;//C
var BEFORE_SCRIPT_2=i++;//R
var BEFORE_SCRIPT_3=i++;//I
var BEFORE_SCRIPT_4=i++;//P
var BEFORE_SCRIPT_5=i++;//T
var AFTER_SCRIPT_1=i++;//C
var AFTER_SCRIPT_2=i++;//R
var AFTER_SCRIPT_3=i++;//I
var AFTER_SCRIPT_4=i++;//P
var AFTER_SCRIPT_5=i++;//T
var BEFORE_STYLE_1=i++;//T
var BEFORE_STYLE_2=i++;//Y
var BEFORE_STYLE_3=i++;//L
var BEFORE_STYLE_4=i++;//E
var AFTER_STYLE_1=i++;//T
var AFTER_STYLE_2=i++;//Y
var AFTER_STYLE_3=i++;//L
var AFTER_STYLE_4=i++;//E
var BEFORE_ENTITY=i++;//&
var BEFORE_NUMERIC_ENTITY=i++;//#
var IN_NAMED_ENTITY=i++;var IN_NUMERIC_ENTITY=i++;var IN_HEX_ENTITY=i++;//X
var j=0;var SPECIAL_NONE=j++;var SPECIAL_SCRIPT=j++;var SPECIAL_STYLE=j++;function whitespace(c){return c===" "||c==="\n"||c==="\t"||c==="\f"||c==="\r";}function ifElseState(upper,SUCCESS,FAILURE){var lower=upper.toLowerCase();if(upper===lower){return function(c){if(c===lower){this._state=SUCCESS;}else{this._state=FAILURE;this._index--;}};}else{return function(c){if(c===lower||c===upper){this._state=SUCCESS;}else{this._state=FAILURE;this._index--;}};}}function consumeSpecialNameChar(upper,NEXT_STATE){var lower=upper.toLowerCase();return function(c){if(c===lower||c===upper){this._state=NEXT_STATE;}else{this._state=IN_TAG_NAME;this._index--;//consume the token again
}};}function Tokenizer(options,cbs){this._state=TEXT;this._buffer="";this._sectionStart=0;this._index=0;this._bufferOffset=0;//chars removed from _buffer
this._baseState=TEXT;this._special=SPECIAL_NONE;this._cbs=cbs;this._running=true;this._ended=false;this._xmlMode=!!(options&&options.xmlMode);this._decodeEntities=!!(options&&options.decodeEntities);}Tokenizer.prototype._stateText=function(c){if(c==="<"){if(this._index>this._sectionStart){this._cbs.ontext(this._getSection());}this._state=BEFORE_TAG_NAME;this._sectionStart=this._index;}else if(this._decodeEntities&&this._special===SPECIAL_NONE&&c==="&"){if(this._index>this._sectionStart){this._cbs.ontext(this._getSection());}this._baseState=TEXT;this._state=BEFORE_ENTITY;this._sectionStart=this._index;}};Tokenizer.prototype._stateBeforeTagName=function(c){if(c==="/"){this._state=BEFORE_CLOSING_TAG_NAME;}else if(c==="<"){this._cbs.ontext(this._getSection());this._sectionStart=this._index;}else if(c===">"||this._special!==SPECIAL_NONE||whitespace(c)){this._state=TEXT;}else if(c==="!"){this._state=BEFORE_DECLARATION;this._sectionStart=this._index+1;}else if(c==="?"){this._state=IN_PROCESSING_INSTRUCTION;this._sectionStart=this._index+1;}else{this._state=!this._xmlMode&&(c==="s"||c==="S")?BEFORE_SPECIAL:IN_TAG_NAME;this._sectionStart=this._index;}};Tokenizer.prototype._stateInTagName=function(c){if(c==="/"||c===">"||whitespace(c)){this._emitToken("onopentagname");this._state=BEFORE_ATTRIBUTE_NAME;this._index--;}};Tokenizer.prototype._stateBeforeCloseingTagName=function(c){if(whitespace(c));else if(c===">"){this._state=TEXT;}else if(this._special!==SPECIAL_NONE){if(c==="s"||c==="S"){this._state=BEFORE_SPECIAL_END;}else{this._state=TEXT;this._index--;}}else{this._state=IN_CLOSING_TAG_NAME;this._sectionStart=this._index;}};Tokenizer.prototype._stateInCloseingTagName=function(c){if(c===">"||whitespace(c)){this._emitToken("onclosetag");this._state=AFTER_CLOSING_TAG_NAME;this._index--;}};Tokenizer.prototype._stateAfterCloseingTagName=function(c){//skip everything until ">"
if(c===">"){this._state=TEXT;this._sectionStart=this._index+1;}};Tokenizer.prototype._stateBeforeAttributeName=function(c){if(c===">"){this._cbs.onopentagend();this._state=TEXT;this._sectionStart=this._index+1;}else if(c==="/"){this._state=IN_SELF_CLOSING_TAG;}else if(!whitespace(c)){this._state=IN_ATTRIBUTE_NAME;this._sectionStart=this._index;}};Tokenizer.prototype._stateInSelfClosingTag=function(c){if(c===">"){this._cbs.onselfclosingtag();this._state=TEXT;this._sectionStart=this._index+1;}else if(!whitespace(c)){this._state=BEFORE_ATTRIBUTE_NAME;this._index--;}};Tokenizer.prototype._stateInAttributeName=function(c){if(c==="="||c==="/"||c===">"||whitespace(c)){this._cbs.onattribname(this._getSection());this._sectionStart=-1;this._state=AFTER_ATTRIBUTE_NAME;this._index--;}};Tokenizer.prototype._stateAfterAttributeName=function(c){if(c==="="){this._state=BEFORE_ATTRIBUTE_VALUE;}else if(c==="/"||c===">"){this._cbs.onattribend();this._state=BEFORE_ATTRIBUTE_NAME;this._index--;}else if(!whitespace(c)){this._cbs.onattribend();this._state=IN_ATTRIBUTE_NAME;this._sectionStart=this._index;}};Tokenizer.prototype._stateBeforeAttributeValue=function(c){if(c==='"'){this._state=IN_ATTRIBUTE_VALUE_DQ;this._sectionStart=this._index+1;}else if(c==="'"){this._state=IN_ATTRIBUTE_VALUE_SQ;this._sectionStart=this._index+1;}else if(!whitespace(c)){this._state=IN_ATTRIBUTE_VALUE_NQ;this._sectionStart=this._index;this._index--;//reconsume token
}};Tokenizer.prototype._stateInAttributeValueDoubleQuotes=function(c){if(c==='"'){this._emitToken("onattribdata");this._cbs.onattribend();this._state=BEFORE_ATTRIBUTE_NAME;}else if(this._decodeEntities&&c==="&"){this._emitToken("onattribdata");this._baseState=this._state;this._state=BEFORE_ENTITY;this._sectionStart=this._index;}};Tokenizer.prototype._stateInAttributeValueSingleQuotes=function(c){if(c==="'"){this._emitToken("onattribdata");this._cbs.onattribend();this._state=BEFORE_ATTRIBUTE_NAME;}else if(this._decodeEntities&&c==="&"){this._emitToken("onattribdata");this._baseState=this._state;this._state=BEFORE_ENTITY;this._sectionStart=this._index;}};Tokenizer.prototype._stateInAttributeValueNoQuotes=function(c){if(whitespace(c)||c===">"){this._emitToken("onattribdata");this._cbs.onattribend();this._state=BEFORE_ATTRIBUTE_NAME;this._index--;}else if(this._decodeEntities&&c==="&"){this._emitToken("onattribdata");this._baseState=this._state;this._state=BEFORE_ENTITY;this._sectionStart=this._index;}};Tokenizer.prototype._stateBeforeDeclaration=function(c){this._state=c==="["?BEFORE_CDATA_1:c==="-"?BEFORE_COMMENT:IN_DECLARATION;};Tokenizer.prototype._stateInDeclaration=function(c){if(c===">"){this._cbs.ondeclaration(this._getSection());this._state=TEXT;this._sectionStart=this._index+1;}};Tokenizer.prototype._stateInProcessingInstruction=function(c){if(c===">"){this._cbs.onprocessinginstruction(this._getSection());this._state=TEXT;this._sectionStart=this._index+1;}};Tokenizer.prototype._stateBeforeComment=function(c){if(c==="-"){this._state=IN_COMMENT;this._sectionStart=this._index+1;}else{this._state=IN_DECLARATION;}};Tokenizer.prototype._stateInComment=function(c){if(c==="-")this._state=AFTER_COMMENT_1;};Tokenizer.prototype._stateAfterComment1=function(c){if(c==="-"){this._state=AFTER_COMMENT_2;}else{this._state=IN_COMMENT;}};Tokenizer.prototype._stateAfterComment2=function(c){if(c===">"){//remove 2 trailing chars
this._cbs.oncomment(this._buffer.substring(this._sectionStart,this._index-2));this._state=TEXT;this._sectionStart=this._index+1;}else if(c!=="-"){this._state=IN_COMMENT;}// else: stay in AFTER_COMMENT_2 (`--->`)
};Tokenizer.prototype._stateBeforeCdata1=ifElseState("C",BEFORE_CDATA_2,IN_DECLARATION);Tokenizer.prototype._stateBeforeCdata2=ifElseState("D",BEFORE_CDATA_3,IN_DECLARATION);Tokenizer.prototype._stateBeforeCdata3=ifElseState("A",BEFORE_CDATA_4,IN_DECLARATION);Tokenizer.prototype._stateBeforeCdata4=ifElseState("T",BEFORE_CDATA_5,IN_DECLARATION);Tokenizer.prototype._stateBeforeCdata5=ifElseState("A",BEFORE_CDATA_6,IN_DECLARATION);Tokenizer.prototype._stateBeforeCdata6=function(c){if(c==="["){this._state=IN_CDATA;this._sectionStart=this._index+1;}else{this._state=IN_DECLARATION;this._index--;}};Tokenizer.prototype._stateInCdata=function(c){if(c==="]")this._state=AFTER_CDATA_1;};Tokenizer.prototype._stateAfterCdata1=function(c){if(c==="]")this._state=AFTER_CDATA_2;else this._state=IN_CDATA;};Tokenizer.prototype._stateAfterCdata2=function(c){if(c===">"){//remove 2 trailing chars
this._cbs.oncdata(this._buffer.substring(this._sectionStart,this._index-2));this._state=TEXT;this._sectionStart=this._index+1;}else if(c!=="]"){this._state=IN_CDATA;}//else: stay in AFTER_CDATA_2 (`]]]>`)
};Tokenizer.prototype._stateBeforeSpecial=function(c){if(c==="c"||c==="C"){this._state=BEFORE_SCRIPT_1;}else if(c==="t"||c==="T"){this._state=BEFORE_STYLE_1;}else{this._state=IN_TAG_NAME;this._index--;//consume the token again
}};Tokenizer.prototype._stateBeforeSpecialEnd=function(c){if(this._special===SPECIAL_SCRIPT&&(c==="c"||c==="C")){this._state=AFTER_SCRIPT_1;}else if(this._special===SPECIAL_STYLE&&(c==="t"||c==="T")){this._state=AFTER_STYLE_1;}else this._state=TEXT;};Tokenizer.prototype._stateBeforeScript1=consumeSpecialNameChar("R",BEFORE_SCRIPT_2);Tokenizer.prototype._stateBeforeScript2=consumeSpecialNameChar("I",BEFORE_SCRIPT_3);Tokenizer.prototype._stateBeforeScript3=consumeSpecialNameChar("P",BEFORE_SCRIPT_4);Tokenizer.prototype._stateBeforeScript4=consumeSpecialNameChar("T",BEFORE_SCRIPT_5);Tokenizer.prototype._stateBeforeScript5=function(c){if(c==="/"||c===">"||whitespace(c)){this._special=SPECIAL_SCRIPT;}this._state=IN_TAG_NAME;this._index--;//consume the token again
};Tokenizer.prototype._stateAfterScript1=ifElseState("R",AFTER_SCRIPT_2,TEXT);Tokenizer.prototype._stateAfterScript2=ifElseState("I",AFTER_SCRIPT_3,TEXT);Tokenizer.prototype._stateAfterScript3=ifElseState("P",AFTER_SCRIPT_4,TEXT);Tokenizer.prototype._stateAfterScript4=ifElseState("T",AFTER_SCRIPT_5,TEXT);Tokenizer.prototype._stateAfterScript5=function(c){if(c===">"||whitespace(c)){this._special=SPECIAL_NONE;this._state=IN_CLOSING_TAG_NAME;this._sectionStart=this._index-6;this._index--;//reconsume the token
}else this._state=TEXT;};Tokenizer.prototype._stateBeforeStyle1=consumeSpecialNameChar("Y",BEFORE_STYLE_2);Tokenizer.prototype._stateBeforeStyle2=consumeSpecialNameChar("L",BEFORE_STYLE_3);Tokenizer.prototype._stateBeforeStyle3=consumeSpecialNameChar("E",BEFORE_STYLE_4);Tokenizer.prototype._stateBeforeStyle4=function(c){if(c==="/"||c===">"||whitespace(c)){this._special=SPECIAL_STYLE;}this._state=IN_TAG_NAME;this._index--;//consume the token again
};Tokenizer.prototype._stateAfterStyle1=ifElseState("Y",AFTER_STYLE_2,TEXT);Tokenizer.prototype._stateAfterStyle2=ifElseState("L",AFTER_STYLE_3,TEXT);Tokenizer.prototype._stateAfterStyle3=ifElseState("E",AFTER_STYLE_4,TEXT);Tokenizer.prototype._stateAfterStyle4=function(c){if(c===">"||whitespace(c)){this._special=SPECIAL_NONE;this._state=IN_CLOSING_TAG_NAME;this._sectionStart=this._index-5;this._index--;//reconsume the token
}else this._state=TEXT;};Tokenizer.prototype._stateBeforeEntity=ifElseState("#",BEFORE_NUMERIC_ENTITY,IN_NAMED_ENTITY);Tokenizer.prototype._stateBeforeNumericEntity=ifElseState("X",IN_HEX_ENTITY,IN_NUMERIC_ENTITY);//for entities terminated with a semicolon
Tokenizer.prototype._parseNamedEntityStrict=function(){//offset = 1
if(this._sectionStart+1<this._index){var entity=this._buffer.substring(this._sectionStart+1,this._index),map=this._xmlMode?xmlMap:entityMap;if(map.hasOwnProperty(entity)){this._emitPartial(map[entity]);this._sectionStart=this._index+1;}}};//parses legacy entities (without trailing semicolon)
Tokenizer.prototype._parseLegacyEntity=function(){var start=this._sectionStart+1,limit=this._index-start;if(limit>6)limit=6;//the max length of legacy entities is 6
while(limit>=2){//the min length of legacy entities is 2
var entity=this._buffer.substr(start,limit);if(legacyMap.hasOwnProperty(entity)){this._emitPartial(legacyMap[entity]);this._sectionStart+=limit+1;return;}else{limit--;}}};Tokenizer.prototype._stateInNamedEntity=function(c){if(c===";"){this._parseNamedEntityStrict();if(this._sectionStart+1<this._index&&!this._xmlMode){this._parseLegacyEntity();}this._state=this._baseState;}else if((c<"a"||c>"z")&&(c<"A"||c>"Z")&&(c<"0"||c>"9")){if(this._xmlMode);else if(this._sectionStart+1===this._index);else if(this._baseState!==TEXT){if(c!=="="){this._parseNamedEntityStrict();}}else{this._parseLegacyEntity();}this._state=this._baseState;this._index--;}};Tokenizer.prototype._decodeNumericEntity=function(offset,base){var sectionStart=this._sectionStart+offset;if(sectionStart!==this._index){//parse entity
var entity=this._buffer.substring(sectionStart,this._index);var parsed=parseInt(entity,base);this._emitPartial(decodeCodePoint(parsed));this._sectionStart=this._index;}else{this._sectionStart--;}this._state=this._baseState;};Tokenizer.prototype._stateInNumericEntity=function(c){if(c===";"){this._decodeNumericEntity(2,10);this._sectionStart++;}else if(c<"0"||c>"9"){if(!this._xmlMode){this._decodeNumericEntity(2,10);}else{this._state=this._baseState;}this._index--;}};Tokenizer.prototype._stateInHexEntity=function(c){if(c===";"){this._decodeNumericEntity(3,16);this._sectionStart++;}else if((c<"a"||c>"f")&&(c<"A"||c>"F")&&(c<"0"||c>"9")){if(!this._xmlMode){this._decodeNumericEntity(3,16);}else{this._state=this._baseState;}this._index--;}};Tokenizer.prototype._cleanup=function(){if(this._sectionStart<0){this._buffer="";this._bufferOffset+=this._index;this._index=0;}else if(this._running){if(this._state===TEXT){if(this._sectionStart!==this._index){this._cbs.ontext(this._buffer.substr(this._sectionStart));}this._buffer="";this._bufferOffset+=this._index;this._index=0;}else if(this._sectionStart===this._index){//the section just started
this._buffer="";this._bufferOffset+=this._index;this._index=0;}else{//remove everything unnecessary
this._buffer=this._buffer.substr(this._sectionStart);this._index-=this._sectionStart;this._bufferOffset+=this._sectionStart;}this._sectionStart=0;}};//TODO make events conditional
Tokenizer.prototype.write=function(chunk){if(this._ended)this._cbs.onerror(Error(".write() after done!"));this._buffer+=chunk;this._parse();};Tokenizer.prototype._parse=function(){while(this._index<this._buffer.length&&this._running){var c=this._buffer.charAt(this._index);if(this._state===TEXT){this._stateText(c);}else if(this._state===BEFORE_TAG_NAME){this._stateBeforeTagName(c);}else if(this._state===IN_TAG_NAME){this._stateInTagName(c);}else if(this._state===BEFORE_CLOSING_TAG_NAME){this._stateBeforeCloseingTagName(c);}else if(this._state===IN_CLOSING_TAG_NAME){this._stateInCloseingTagName(c);}else if(this._state===AFTER_CLOSING_TAG_NAME){this._stateAfterCloseingTagName(c);}else if(this._state===IN_SELF_CLOSING_TAG){this._stateInSelfClosingTag(c);}else if(this._state===BEFORE_ATTRIBUTE_NAME){/*
		*	attributes
		*/this._stateBeforeAttributeName(c);}else if(this._state===IN_ATTRIBUTE_NAME){this._stateInAttributeName(c);}else if(this._state===AFTER_ATTRIBUTE_NAME){this._stateAfterAttributeName(c);}else if(this._state===BEFORE_ATTRIBUTE_VALUE){this._stateBeforeAttributeValue(c);}else if(this._state===IN_ATTRIBUTE_VALUE_DQ){this._stateInAttributeValueDoubleQuotes(c);}else if(this._state===IN_ATTRIBUTE_VALUE_SQ){this._stateInAttributeValueSingleQuotes(c);}else if(this._state===IN_ATTRIBUTE_VALUE_NQ){this._stateInAttributeValueNoQuotes(c);}else if(this._state===BEFORE_DECLARATION){/*
		*	declarations
		*/this._stateBeforeDeclaration(c);}else if(this._state===IN_DECLARATION){this._stateInDeclaration(c);}else if(this._state===IN_PROCESSING_INSTRUCTION){/*
		*	processing instructions
		*/this._stateInProcessingInstruction(c);}else if(this._state===BEFORE_COMMENT){/*
		*	comments
		*/this._stateBeforeComment(c);}else if(this._state===IN_COMMENT){this._stateInComment(c);}else if(this._state===AFTER_COMMENT_1){this._stateAfterComment1(c);}else if(this._state===AFTER_COMMENT_2){this._stateAfterComment2(c);}else if(this._state===BEFORE_CDATA_1){/*
		*	cdata
		*/this._stateBeforeCdata1(c);}else if(this._state===BEFORE_CDATA_2){this._stateBeforeCdata2(c);}else if(this._state===BEFORE_CDATA_3){this._stateBeforeCdata3(c);}else if(this._state===BEFORE_CDATA_4){this._stateBeforeCdata4(c);}else if(this._state===BEFORE_CDATA_5){this._stateBeforeCdata5(c);}else if(this._state===BEFORE_CDATA_6){this._stateBeforeCdata6(c);}else if(this._state===IN_CDATA){this._stateInCdata(c);}else if(this._state===AFTER_CDATA_1){this._stateAfterCdata1(c);}else if(this._state===AFTER_CDATA_2){this._stateAfterCdata2(c);}else if(this._state===BEFORE_SPECIAL){/*
		* special tags
		*/this._stateBeforeSpecial(c);}else if(this._state===BEFORE_SPECIAL_END){this._stateBeforeSpecialEnd(c);}else if(this._state===BEFORE_SCRIPT_1){/*
		* script
		*/this._stateBeforeScript1(c);}else if(this._state===BEFORE_SCRIPT_2){this._stateBeforeScript2(c);}else if(this._state===BEFORE_SCRIPT_3){this._stateBeforeScript3(c);}else if(this._state===BEFORE_SCRIPT_4){this._stateBeforeScript4(c);}else if(this._state===BEFORE_SCRIPT_5){this._stateBeforeScript5(c);}else if(this._state===AFTER_SCRIPT_1){this._stateAfterScript1(c);}else if(this._state===AFTER_SCRIPT_2){this._stateAfterScript2(c);}else if(this._state===AFTER_SCRIPT_3){this._stateAfterScript3(c);}else if(this._state===AFTER_SCRIPT_4){this._stateAfterScript4(c);}else if(this._state===AFTER_SCRIPT_5){this._stateAfterScript5(c);}else if(this._state===BEFORE_STYLE_1){/*
		* style
		*/this._stateBeforeStyle1(c);}else if(this._state===BEFORE_STYLE_2){this._stateBeforeStyle2(c);}else if(this._state===BEFORE_STYLE_3){this._stateBeforeStyle3(c);}else if(this._state===BEFORE_STYLE_4){this._stateBeforeStyle4(c);}else if(this._state===AFTER_STYLE_1){this._stateAfterStyle1(c);}else if(this._state===AFTER_STYLE_2){this._stateAfterStyle2(c);}else if(this._state===AFTER_STYLE_3){this._stateAfterStyle3(c);}else if(this._state===AFTER_STYLE_4){this._stateAfterStyle4(c);}else if(this._state===BEFORE_ENTITY){/*
		* entities
		*/this._stateBeforeEntity(c);}else if(this._state===BEFORE_NUMERIC_ENTITY){this._stateBeforeNumericEntity(c);}else if(this._state===IN_NAMED_ENTITY){this._stateInNamedEntity(c);}else if(this._state===IN_NUMERIC_ENTITY){this._stateInNumericEntity(c);}else if(this._state===IN_HEX_ENTITY){this._stateInHexEntity(c);}else{this._cbs.onerror(Error("unknown _state"),this._state);}this._index++;}this._cleanup();};Tokenizer.prototype.pause=function(){this._running=false;};Tokenizer.prototype.resume=function(){this._running=true;if(this._index<this._buffer.length){this._parse();}if(this._ended){this._finish();}};Tokenizer.prototype.end=function(chunk){if(this._ended)this._cbs.onerror(Error(".end() after done!"));if(chunk)this.write(chunk);this._ended=true;if(this._running)this._finish();};Tokenizer.prototype._finish=function(){//if there is remaining data, emit it in a reasonable way
if(this._sectionStart<this._index){this._handleTrailingData();}this._cbs.onend();};Tokenizer.prototype._handleTrailingData=function(){var data=this._buffer.substr(this._sectionStart);if(this._state===IN_CDATA||this._state===AFTER_CDATA_1||this._state===AFTER_CDATA_2){this._cbs.oncdata(data);}else if(this._state===IN_COMMENT||this._state===AFTER_COMMENT_1||this._state===AFTER_COMMENT_2){this._cbs.oncomment(data);}else if(this._state===IN_NAMED_ENTITY&&!this._xmlMode){this._parseLegacyEntity();if(this._sectionStart<this._index){this._state=this._baseState;this._handleTrailingData();}}else if(this._state===IN_NUMERIC_ENTITY&&!this._xmlMode){this._decodeNumericEntity(2,10);if(this._sectionStart<this._index){this._state=this._baseState;this._handleTrailingData();}}else if(this._state===IN_HEX_ENTITY&&!this._xmlMode){this._decodeNumericEntity(3,16);if(this._sectionStart<this._index){this._state=this._baseState;this._handleTrailingData();}}else if(this._state!==IN_TAG_NAME&&this._state!==BEFORE_ATTRIBUTE_NAME&&this._state!==BEFORE_ATTRIBUTE_VALUE&&this._state!==AFTER_ATTRIBUTE_NAME&&this._state!==IN_ATTRIBUTE_NAME&&this._state!==IN_ATTRIBUTE_VALUE_SQ&&this._state!==IN_ATTRIBUTE_VALUE_DQ&&this._state!==IN_ATTRIBUTE_VALUE_NQ&&this._state!==IN_CLOSING_TAG_NAME){this._cbs.ontext(data);}//else, ignore remaining data
//TODO add a way to remove current tag
};Tokenizer.prototype.reset=function(){Tokenizer.call(this,{xmlMode:this._xmlMode,decodeEntities:this._decodeEntities},this._cbs);};Tokenizer.prototype.getAbsoluteIndex=function(){return this._bufferOffset+this._index;};Tokenizer.prototype._getSection=function(){return this._buffer.substring(this._sectionStart,this._index);};Tokenizer.prototype._emitToken=function(name){this._cbs[name](this._getSection());this._sectionStart=-1;};Tokenizer.prototype._emitPartial=function(value){if(this._baseState!==TEXT){this._cbs.onattribdata(value);//TODO implement the new event
}else{this._cbs.ontext(value);}};},{"entities/lib/decode_codepoint.js":26,"entities/maps/entities.json":28,"entities/maps/legacy.json":29,"entities/maps/xml.json":30}],38:[function(require,module,exports){module.exports=Stream;var Parser=require("./Parser.js");var WritableStream=require("readable-stream").Writable;var StringDecoder=require("string_decoder").StringDecoder;var Buffer=require("buffer").Buffer;function Stream(cbs,options){var parser=this._parser=new Parser(cbs,options);var decoder=this._decoder=new StringDecoder();WritableStream.call(this,{decodeStrings:false});this.once("finish",function(){parser.end(decoder.end());});}require("inherits")(Stream,WritableStream);Stream.prototype._write=function(chunk,encoding,cb){if(chunk instanceof Buffer)chunk=this._decoder.write(chunk);this._parser.write(chunk);cb();};},{"./Parser.js":34,"buffer":3,"inherits":41,"readable-stream":2,"string_decoder":90}],39:[function(require,module,exports){var Parser=require("./Parser.js");var DomHandler=require("domhandler");function defineProp(name,value){delete module.exports[name];module.exports[name]=value;return value;}module.exports={Parser:Parser,Tokenizer:require("./Tokenizer.js"),ElementType:require("domelementtype"),DomHandler:DomHandler,get FeedHandler(){return defineProp("FeedHandler",require("./FeedHandler.js"));},get Stream(){return defineProp("Stream",require("./Stream.js"));},get WritableStream(){return defineProp("WritableStream",require("./WritableStream.js"));},get ProxyHandler(){return defineProp("ProxyHandler",require("./ProxyHandler.js"));},get DomUtils(){return defineProp("DomUtils",require("domutils"));},get CollectingHandler(){return defineProp("CollectingHandler",require("./CollectingHandler.js"));},// For legacy support
DefaultHandler:DomHandler,get RssHandler(){return defineProp("RssHandler",this.FeedHandler);},//helper methods
parseDOM:function parseDOM(data,options){var handler=new DomHandler(options);new Parser(handler,options).end(data);return handler.dom;},parseFeed:function parseFeed(feed,options){var handler=new module.exports.FeedHandler(options);new Parser(handler,options).end(feed);return handler.dom;},createDomStream:function createDomStream(cb,options,elementCb){var handler=new DomHandler(cb,options,elementCb);return new Parser(handler,options);},// List of all events that the parser emits
EVENTS:{/* Format: eventname: number of arguments */attribute:2,cdatastart:0,cdataend:0,text:1,processinginstruction:2,comment:1,commentend:0,closetag:1,opentag:2,opentagname:1,error:1,end:0}};},{"./CollectingHandler.js":32,"./FeedHandler.js":33,"./Parser.js":34,"./ProxyHandler.js":35,"./Stream.js":36,"./Tokenizer.js":37,"./WritableStream.js":38,"domelementtype":15,"domhandler":16,"domutils":19}],40:[function(require,module,exports){exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var nBits=-7;var i=isLE?nBytes-1:0;var d=isLE?-1:1;var s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8){}m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8){}if(e===0){e=1-eBias;}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity;}else{m=m+Math.pow(2,mLen);e=e-eBias;}return(s?-1:1)*m*Math.pow(2,e-mLen);};exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0;var i=isLE?0:nBytes-1;var d=isLE?1:-1;var s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax;}else{e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2;}if(e+eBias>=1){value+=rt/c;}else{value+=rt*Math.pow(2,1-eBias);}if(value*c>=2){e++;c/=2;}if(e+eBias>=eMax){m=0;e=eMax;}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias;}else{m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0;}}for(;mLen>=8;buffer[offset+i]=m&0xff,i+=d,m/=256,mLen-=8){}e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&0xff,i+=d,e/=256,eLen-=8){}buffer[offset+i-d]|=s*128;};},{}],41:[function(require,module,exports){if(typeof Object.create==='function'){// implementation from standard node.js 'util' module
module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}});}};}else{// old school shim for old browsers
module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;var TempCtor=function TempCtor(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor();ctor.prototype.constructor=ctor;}};}},{}],42:[function(require,module,exports){(function(global){/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',objectTag='[object Object]',promiseTag='[object Promise]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',weakMapTag='[object WeakMap]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(global)=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&_typeof(module)=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */function addMapEntry(map,pair){// Don't return `map.set` because it's not chainable in IE 11.
map.set(pair[0],pair[1]);return map;}/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */function addSetEntry(set,value){// Don't return `set.add` because it's not chainable in IE 11.
set.add(value);return set;}/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */function arrayEach(array,iteratee){var index=-1,length=array?array.length:0;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array?array.length:0;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function getValue(object,key){return object==null?undefined:object[key];}/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */function isHostObject(value){// Many host objects are `Object` objects that can coerce to strings
// despite having improperly defined `toString` methods.
var result=false;if(value!=null&&typeof value.toString!='function'){try{result=!!(value+'');}catch(e){}}return result;}/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=root['__core-js_shared__'];/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var objectToString=objectProto.toString;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?root.Buffer:undefined,_Symbol=root.Symbol,Uint8Array=root.Uint8Array,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeKeys=overArg(Object.keys,Object);/* Built-in method references that are verified to be native. */var DataView=getNative(root,'DataView'),Map=getNative(root,'Map'),Promise=getNative(root,'Promise'),Set=getNative(root,'Set'),WeakMap=getNative(root,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined;/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Hash(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};}/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function hashDelete(key){return this.has(key)&&delete this.__data__[key];}/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */function hashSet(key,value){var data=this.__data__;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function ListCache(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */function listCacheClear(){this.__data__=[];}/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}return true;}/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function MapCache(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */function mapCacheClear(){this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function mapCacheDelete(key){return getMapData(this,key)['delete'](key);}/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */function mapCacheSet(key,value){getMapData(this,key).set(key,value);return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Stack(entries){this.__data__=new ListCache(entries);}/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */function stackClear(){this.__data__=new ListCache();}/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function stackDelete(key){return this.__data__['delete'](key);}/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function stackGet(key){return this.__data__.get(key);}/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function stackHas(key){return this.__data__.has(key);}/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */function stackSet(key,value){var cache=this.__data__;if(cache instanceof ListCache){var pairs=cache.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);return this;}cache=this.__data__=new MapCache(pairs);}cache.set(key,value);return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */function arrayLikeKeys(value,inherited){// Safari 8.1 makes `arguments.callee` enumerable in strict mode.
// Safari 9 makes `arguments.length` enumerable in strict mode.
var result=isArray(value)||isArguments(value)?baseTimes(value.length,String):[];var length=result.length,skipIndexes=!!length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(key=='length'||isIndex(key,length)))){result.push(key);}}return result;}/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){object[key]=value;}}/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */function baseClone(value,isDeep,isFull,customizer,key,object,stack){var result;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){if(isHostObject(value)){return object?value:{};}result=initCloneObject(isFunc?{}:value);if(!isDeep){return copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,baseClone,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(!isArr){var props=isFull?getAllKeys(value):keys(value);}arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,isDeep,isFull,customizer,key,value,stack));});return result;}/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */function baseCreate(proto){return isObject(proto)?objectCreate(proto):{};}/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */function baseGetTag(value){return objectToString.call(value);}/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)||isHostObject(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var result=new buffer.constructor(buffer.length);buffer.copy(result);return result;}/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */function cloneMap(map,isDeep,cloneFunc){var array=isDeep?cloneFunc(mapToArray(map),true):mapToArray(map);return arrayReduce(array,addMapEntry,new map.constructor());}/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */function cloneSet(set,isDeep,cloneFunc){var array=isDeep?cloneFunc(setToArray(set),true):setToArray(set);return arrayReduce(array,addSetEntry,new set.constructor());}/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */function copyObject(source,props,object,customizer){object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;assignValue(object,key,newValue===undefined?source[key]:newValue);}return object;}/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */var getSymbols=nativeGetSymbols?overArg(nativeGetSymbols,Object):stubArray;/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=objectToString.call(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):undefined;if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */function initCloneArray(array){var length=array.length,result=array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */function initCloneByTag(object,tag,cloneFunc,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return cloneMap(object,isDeep,cloneFunc);case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return cloneSet(object,isDeep,cloneFunc);case symbolTag:return cloneSymbol(object);}}/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */function isIndex(value,length){length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(typeof value=='number'||reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */function cloneDeep(value){return baseClone(value,true,true);}/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */function eq(value,other){return value===other||value!==value&&other!==other;}/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */function isArguments(value){// Safari 8.1 makes `arguments.callee` enumerable in strict mode.
return isArrayLikeObject(value)&&hasOwnProperty.call(value,'callee')&&(!propertyIsEnumerable.call(value,'callee')||objectToString.call(value)==argsTag);}/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */var isBuffer=nativeIsBuffer||stubFalse;/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */function isFunction(value){// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 8-9 which returns 'object' for typed array and other constructors.
var tag=isObject(value)?objectToString.call(value):'';return tag==funcTag||tag==genTag;}/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */function isObject(value){var type=_typeof(value);return!!value&&(type=='object'||type=='function');}/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return!!value&&_typeof(value)=='object';}/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */function stubArray(){return[];}/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */function stubFalse(){return false;}module.exports=cloneDeep;}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],43:[function(require,module,exports){(function(global){/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as references for various `Number` constants. */var INFINITY=1/0;/** `Object#toString` result references. */var symbolTag='[object Symbol]';/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(global)=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Used for built-in method references. */var objectProto=Object.prototype;/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */var objectToString=objectProto.toString;/** Built-in value references. */var _Symbol2=root.Symbol;/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol2?_Symbol2.prototype:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return!!value&&_typeof(value)=='object';}/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */function isSymbol(value){return _typeof(value)=='symbol'||isObjectLike(value)&&objectToString.call(value)==symbolTag;}/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */function toString(value){return value==null?'':baseToString(value);}/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}module.exports=escapeRegExp;}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],44:[function(require,module,exports){/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** `Object#toString` result references. */var objectTag='[object Object]';/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */function isHostObject(value){// Many host objects are `Object` objects that can coerce to strings
// despite having improperly defined `toString` methods.
var result=false;if(value!=null&&typeof value.toString!='function'){try{result=!!(value+'');}catch(e){}}return result;}/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */function overArg(func,transform){return function(arg){return func(transform(arg));};}/** Used for built-in method references. */var funcProto=Function.prototype,objectProto=Object.prototype;/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var objectToString=objectProto.toString;/** Built-in value references. */var getPrototype=overArg(Object.getPrototypeOf,Object);/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return!!value&&_typeof(value)=='object';}/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */function isPlainObject(value){if(!isObjectLike(value)||objectToString.call(value)!=objectTag||isHostObject(value)){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}module.exports=isPlainObject;},{}],45:[function(require,module,exports){/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */ /** `Object#toString` result references. */var stringTag='[object String]';/** Used for built-in method references. */var objectProto=Object.prototype;/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */var objectToString=objectProto.toString;/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return!!value&&_typeof(value)=='object';}/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&objectToString.call(value)==stringTag;}module.exports=isString;},{}],46:[function(require,module,exports){(function(global){/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(global)=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&_typeof(module)=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */function baseUnary(func){return function(value){return func(value);};}/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function getValue(object,key){return object==null?undefined:object[key];}/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */function overArg(func,transform){return function(arg){return func(transform(arg));};}/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=root['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?root.Buffer:undefined,_Symbol3=root.Symbol,Uint8Array=root.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,symToStringTag=_Symbol3?_Symbol3.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/* Built-in method references for those with the same name as other `lodash` methods. */var nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeMax=Math.max,nativeNow=Date.now;/* Built-in method references that are verified to be native. */var Map=getNative(root,'Map'),nativeCreate=getNative(Object,'create');/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */function listCacheClear(){this.__data__=[];this.size=0;}/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function stackGet(key){return this.__data__.get(key);}/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function stackHas(key){return this.__data__.has(key);}/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */var baseFor=createBaseFor();/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */function isIndex(value,length){var type=_typeof(value);length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */function objectToString(value){return nativeObjectToString.call(value);}/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */var setToString=shortOut(baseSetToString);/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */function eq(value,other){return value===other||value!==value&&other!==other;}/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */var isBuffer=nativeIsBuffer||stubFalse;/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return value!=null&&_typeof(value)=='object';}/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */function constant(value){return function(){return value;};}/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */function identity(value){return value;}/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */function stubFalse(){return false;}module.exports=mergeWith;}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],47:[function(require,module,exports){(function(process){// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts,allowAboveRoot){// if the path tries to go above the root, `up` ends up > 0
var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==='.'){parts.splice(i,1);}else if(last==='..'){parts.splice(i,1);up++;}else if(up){parts.splice(i,1);up--;}}// if the path is allowed to go above the root, restore leading ..s
if(allowAboveRoot){for(;up--;up){parts.unshift('..');}}return parts;}// path.resolve([from ...], to)
// posix version
exports.resolve=function(){var resolvedPath='',resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:process.cwd();// Skip empty and invalid entries
if(typeof path!=='string'){throw new TypeError('Arguments to path.resolve must be strings');}else if(!path){continue;}resolvedPath=path+'/'+resolvedPath;resolvedAbsolute=path.charAt(0)==='/';}// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)
// Normalize the path
resolvedPath=normalizeArray(filter(resolvedPath.split('/'),function(p){return!!p;}),!resolvedAbsolute).join('/');return(resolvedAbsolute?'/':'')+resolvedPath||'.';};// path.normalize(path)
// posix version
exports.normalize=function(path){var isAbsolute=exports.isAbsolute(path),trailingSlash=substr(path,-1)==='/';// Normalize the path
path=normalizeArray(filter(path.split('/'),function(p){return!!p;}),!isAbsolute).join('/');if(!path&&!isAbsolute){path='.';}if(path&&trailingSlash){path+='/';}return(isAbsolute?'/':'')+path;};// posix version
exports.isAbsolute=function(path){return path.charAt(0)==='/';};// posix version
exports.join=function(){var paths=Array.prototype.slice.call(arguments,0);return exports.normalize(filter(paths,function(p,index){if(typeof p!=='string'){throw new TypeError('Arguments to path.join must be strings');}return p;}).join('/'));};// path.relative(from, to)
// posix version
exports.relative=function(from,to){from=exports.resolve(from).substr(1);to=exports.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=='')break;}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=='')break;}if(start>end)return[];return arr.slice(start,end-start+1);}var fromParts=trim(from.split('/'));var toParts=trim(to.split('/'));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break;}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push('..');}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join('/');};exports.sep='/';exports.delimiter=':';exports.dirname=function(path){if(typeof path!=='string')path=path+'';if(path.length===0)return'.';var code=path.charCodeAt(0);var hasRoot=code===47/*/*/;var end=-1;var matchedSlash=true;for(var i=path.length-1;i>=1;--i){code=path.charCodeAt(i);if(code===47/*/*/){if(!matchedSlash){end=i;break;}}else{// We saw the first non-path separator
matchedSlash=false;}}if(end===-1)return hasRoot?'/':'.';if(hasRoot&&end===1){// return '//';
// Backwards-compat fix:
return'/';}return path.slice(0,end);};function basename(path){if(typeof path!=='string')path=path+'';var start=0;var end=-1;var matchedSlash=true;var i;for(i=path.length-1;i>=0;--i){if(path.charCodeAt(i)===47/*/*/){// If we reached a path separator that was not part of a set of path
// separators at the end of the string, stop now
if(!matchedSlash){start=i+1;break;}}else if(end===-1){// We saw the first non-path separator, mark this as the end of our
// path component
matchedSlash=false;end=i+1;}}if(end===-1)return'';return path.slice(start,end);}// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename=function(path,ext){var f=basename(path);if(ext&&f.substr(-1*ext.length)===ext){f=f.substr(0,f.length-ext.length);}return f;};exports.extname=function(path){if(typeof path!=='string')path=path+'';var startDot=-1;var startPart=0;var end=-1;var matchedSlash=true;// Track the state of characters (if any) we see before our first dot and
// after any path separator we find
var preDotState=0;for(var i=path.length-1;i>=0;--i){var code=path.charCodeAt(i);if(code===47/*/*/){// If we reached a path separator that was not part of a set of path
// separators at the end of the string, stop now
if(!matchedSlash){startPart=i+1;break;}continue;}if(end===-1){// We saw the first non-path separator, mark this as the end of our
// extension
matchedSlash=false;end=i+1;}if(code===46/*.*/){// If this is our first dot, mark it as the start of our extension
if(startDot===-1)startDot=i;else if(preDotState!==1)preDotState=1;}else if(startDot!==-1){// We saw a non-dot and non-path separator before our dot, so we should
// have a good chance at having a non-empty extension
preDotState=-1;}}if(startDot===-1||end===-1||// We saw a non-dot character immediately before the dot
preDotState===0||// The (right-most) trimmed path component is exactly '..'
preDotState===1&&startDot===end-1&&startDot===startPart+1){return'';}return path.slice(startDot,end);};function filter(xs,f){if(xs.filter)return xs.filter(f);var res=[];for(var i=0;i<xs.length;i++){if(f(xs[i],i,xs))res.push(xs[i]);}return res;}// String.prototype.substr - negative index don't work in IE8
var substr='ab'.substr(-1)==='b'?function(str,start,len){return str.substr(start,len);}:function(str,start,len){if(start<0)start=str.length+start;return str.substr(start,len);};}).call(this,require('_process'));},{"_process":72}],48:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _container=_interopRequireDefault(require("./container"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents an at-rule.
 *
 * If it’s followed in the CSS by a {} block, this node will have
 * a nodes property representing its children.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('@charset "UTF-8"; @media print {}')
 *
 * const charset = root.first
 * charset.type  //=> 'atrule'
 * charset.nodes //=> undefined
 *
 * const media = root.last
 * media.nodes   //=> []
 */var AtRule=/*#__PURE__*/function(_Container){_inheritsLoose(AtRule,_Container);function AtRule(defaults){var _this;_this=_Container.call(this,defaults)||this;_this.type='atrule';return _this;}var _proto=AtRule.prototype;_proto.append=function append(){var _Container$prototype$;if(!this.nodes)this.nodes=[];for(var _len=arguments.length,children=new Array(_len),_key=0;_key<_len;_key++){children[_key]=arguments[_key];}return(_Container$prototype$=_Container.prototype.append).call.apply(_Container$prototype$,[this].concat(children));};_proto.prepend=function prepend(){var _Container$prototype$2;if(!this.nodes)this.nodes=[];for(var _len2=arguments.length,children=new Array(_len2),_key2=0;_key2<_len2;_key2++){children[_key2]=arguments[_key2];}return(_Container$prototype$2=_Container.prototype.prepend).call.apply(_Container$prototype$2,[this].concat(children));}/**
   * @memberof AtRule#
   * @member {string} name The at-rule’s name immediately follows the `@`.
   *
   * @example
   * const root  = postcss.parse('@media print {}')
   * media.name //=> 'media'
   * const media = root.first
   */ /**
   * @memberof AtRule#
   * @member {string} params The at-rule’s parameters, the values
   *                         that follow the at-rule’s name but precede
   *                         any {} block.
   *
   * @example
   * const root  = postcss.parse('@media print, screen {}')
   * const media = root.first
   * media.params //=> 'print, screen'
   */ /**
   * @memberof AtRule#
   * @member {object} raws Information to generate byte-to-byte equal
   *                        node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   *
   * PostCSS cleans at-rule parameters from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('  @media\nprint {\n}')
   * root.first.first.raws //=> { before: '  ',
   *                       //     between: ' ',
   *                       //     afterName: '\n',
   *                       //     after: '\n' }
   */;return AtRule;}(_container["default"]);var _default=AtRule;exports["default"]=_default;module.exports=exports["default"];},{"./container":50}],49:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _node=_interopRequireDefault(require("./node"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents a comment between declarations or statements (rule and at-rules).
 *
 * Comments inside selectors, at-rule parameters, or declaration values
 * will be stored in the `raws` properties explained above.
 *
 * @extends Node
 */var Comment=/*#__PURE__*/function(_Node){_inheritsLoose(Comment,_Node);function Comment(defaults){var _this;_this=_Node.call(this,defaults)||this;_this.type='comment';return _this;}/**
   * @memberof Comment#
   * @member {string} text The comment’s text.
   */ /**
   * @memberof Comment#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node.
   * * `left`: the space symbols between `/*` and the comment’s text.
   * * `right`: the space symbols between the comment’s text.
   */return Comment;}(_node["default"]);var _default=Comment;exports["default"]=_default;module.exports=exports["default"];},{"./node":57}],50:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _declaration=_interopRequireDefault(require("./declaration"));var _comment=_interopRequireDefault(require("./comment"));var _node=_interopRequireDefault(require("./node"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}function cleanSource(nodes){return nodes.map(function(i){if(i.nodes)i.nodes=cleanSource(i.nodes);delete i.source;return i;});}/**
 * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 *
 * @extends Node
 * @abstract
 */var Container=/*#__PURE__*/function(_Node){_inheritsLoose(Container,_Node);function Container(){return _Node.apply(this,arguments)||this;}var _proto=Container.prototype;_proto.push=function push(child){child.parent=this;this.nodes.push(child);return this;}/**
   * Iterates through the container’s immediate children,
   * calling `callback` for each child.
   *
   * Returning `false` in the callback will break iteration.
   *
   * This method only iterates through the container’s immediate children.
   * If you need to recursively iterate through all the container’s descendant
   * nodes, use {@link Container#walk}.
   *
   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
   * if you are mutating the array of child nodes during iteration.
   * PostCSS will adjust the current index to match the mutations.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * const root = postcss.parse('a { color: black; z-index: 1 }')
   * const rule = root.first
   *
   * for (const decl of rule.nodes) {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Cycle will be infinite, because cloneBefore moves the current node
   *   // to the next index
   * }
   *
   * rule.each(decl => {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Will be executed only for color and z-index
   * })
   */;_proto.each=function each(callback){if(!this.lastEach)this.lastEach=0;if(!this.indexes)this.indexes={};this.lastEach+=1;var id=this.lastEach;this.indexes[id]=0;if(!this.nodes)return undefined;var index,result;while(this.indexes[id]<this.nodes.length){index=this.indexes[id];result=callback(this.nodes[index],index);if(result===false)break;this.indexes[id]+=1;}delete this.indexes[id];return result;}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each node.
   *
   * Like container.each(), this method is safe to use
   * if you are mutating arrays during iteration.
   *
   * If you only need to iterate through the container’s immediate children,
   * use {@link Container#each}.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walk(node => {
   *   // Traverses all descendant nodes.
   * })
   */;_proto.walk=function walk(callback){return this.each(function(child,i){var result;try{result=callback(child,i);}catch(e){e.postcssNode=child;if(e.stack&&child.source&&/\n\s{4}at /.test(e.stack)){var s=child.source;e.stack=e.stack.replace(/\n\s{4}at /,"$&"+s.input.from+":"+s.start.line+":"+s.start.column+"$&");}throw e;}if(result!==false&&child.walk){result=child.walk(callback);}return result;});}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each declaration node.
   *
   * If you pass a filter, iteration will only happen over declarations
   * with matching properties.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [prop]   String or regular expression
   *                                 to filter declarations by property name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkDecls(decl => {
   *   checkPropertySupport(decl.prop)
   * })
   *
   * root.walkDecls('border-radius', decl => {
   *   decl.remove()
   * })
   *
   * root.walkDecls(/^background/, decl => {
   *   decl.value = takeFirstColorFromGradient(decl.value)
   * })
   */;_proto.walkDecls=function walkDecls(prop,callback){if(!callback){callback=prop;return this.walk(function(child,i){if(child.type==='decl'){return callback(child,i);}});}if(prop instanceof RegExp){return this.walk(function(child,i){if(child.type==='decl'&&prop.test(child.prop)){return callback(child,i);}});}return this.walk(function(child,i){if(child.type==='decl'&&child.prop===prop){return callback(child,i);}});}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each rule node.
   *
   * If you pass a filter, iteration will only happen over rules
   * with matching selectors.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [selector] String or regular expression
   *                                   to filter rules by selector.
   * @param {childIterator} callback   Iterator receives each node and index.
   *
   * @return {false|undefined} returns `false` if iteration was broke.
   *
   * @example
   * const selectors = []
   * root.walkRules(rule => {
   *   selectors.push(rule.selector)
   * })
   * console.log(`Your CSS uses ${ selectors.length } selectors`)
   */;_proto.walkRules=function walkRules(selector,callback){if(!callback){callback=selector;return this.walk(function(child,i){if(child.type==='rule'){return callback(child,i);}});}if(selector instanceof RegExp){return this.walk(function(child,i){if(child.type==='rule'&&selector.test(child.selector)){return callback(child,i);}});}return this.walk(function(child,i){if(child.type==='rule'&&child.selector===selector){return callback(child,i);}});}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each at-rule node.
   *
   * If you pass a filter, iteration will only happen over at-rules
   * that have matching names.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [name]   String or regular expression
   *                                 to filter at-rules by name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkAtRules(rule => {
   *   if (isOld(rule.name)) rule.remove()
   * })
   *
   * let first = false
   * root.walkAtRules('charset', rule => {
   *   if (!first) {
   *     first = true
   *   } else {
   *     rule.remove()
   *   }
   * })
   */;_proto.walkAtRules=function walkAtRules(name,callback){if(!callback){callback=name;return this.walk(function(child,i){if(child.type==='atrule'){return callback(child,i);}});}if(name instanceof RegExp){return this.walk(function(child,i){if(child.type==='atrule'&&name.test(child.name)){return callback(child,i);}});}return this.walk(function(child,i){if(child.type==='atrule'&&child.name===name){return callback(child,i);}});}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each comment node.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkComments(comment => {
   *   comment.remove()
   * })
   */;_proto.walkComments=function walkComments(callback){return this.walk(function(child,i){if(child.type==='comment'){return callback(child,i);}});}/**
   * Inserts new nodes to the end of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.append(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */;_proto.append=function append(){for(var _len=arguments.length,children=new Array(_len),_key=0;_key<_len;_key++){children[_key]=arguments[_key];}for(var _i=0,_children=children;_i<_children.length;_i++){var child=_children[_i];var nodes=this.normalize(child,this.last);for(var _iterator=nodes,_isArray=Array.isArray(_iterator),_i2=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i2>=_iterator.length)break;_ref=_iterator[_i2++];}else{_i2=_iterator.next();if(_i2.done)break;_ref=_i2.value;}var node=_ref;this.nodes.push(node);}}return this;}/**
   * Inserts new nodes to the start of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.prepend(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */;_proto.prepend=function prepend(){for(var _len2=arguments.length,children=new Array(_len2),_key2=0;_key2<_len2;_key2++){children[_key2]=arguments[_key2];}children=children.reverse();for(var _iterator2=children,_isArray2=Array.isArray(_iterator2),_i3=0,_iterator2=_isArray2?_iterator2:_iterator2[Symbol.iterator]();;){var _ref2;if(_isArray2){if(_i3>=_iterator2.length)break;_ref2=_iterator2[_i3++];}else{_i3=_iterator2.next();if(_i3.done)break;_ref2=_i3.value;}var child=_ref2;var nodes=this.normalize(child,this.first,'prepend').reverse();for(var _iterator3=nodes,_isArray3=Array.isArray(_iterator3),_i4=0,_iterator3=_isArray3?_iterator3:_iterator3[Symbol.iterator]();;){var _ref3;if(_isArray3){if(_i4>=_iterator3.length)break;_ref3=_iterator3[_i4++];}else{_i4=_iterator3.next();if(_i4.done)break;_ref3=_i4.value;}var node=_ref3;this.nodes.unshift(node);}for(var id in this.indexes){this.indexes[id]=this.indexes[id]+nodes.length;}}return this;};_proto.cleanRaws=function cleanRaws(keepBetween){_Node.prototype.cleanRaws.call(this,keepBetween);if(this.nodes){for(var _iterator4=this.nodes,_isArray4=Array.isArray(_iterator4),_i5=0,_iterator4=_isArray4?_iterator4:_iterator4[Symbol.iterator]();;){var _ref4;if(_isArray4){if(_i5>=_iterator4.length)break;_ref4=_iterator4[_i5++];}else{_i5=_iterator4.next();if(_i5.done)break;_ref4=_i5.value;}var node=_ref4;node.cleanRaws(keepBetween);}}}/**
   * Insert new node before old node within the container.
   *
   * @param {Node|number} exist             Child or child’s index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
   */;_proto.insertBefore=function insertBefore(exist,add){exist=this.index(exist);var type=exist===0?'prepend':false;var nodes=this.normalize(add,this.nodes[exist],type).reverse();for(var _iterator5=nodes,_isArray5=Array.isArray(_iterator5),_i6=0,_iterator5=_isArray5?_iterator5:_iterator5[Symbol.iterator]();;){var _ref5;if(_isArray5){if(_i6>=_iterator5.length)break;_ref5=_iterator5[_i6++];}else{_i6=_iterator5.next();if(_i6.done)break;_ref5=_i6.value;}var node=_ref5;this.nodes.splice(exist,0,node);}var index;for(var id in this.indexes){index=this.indexes[id];if(exist<=index){this.indexes[id]=index+nodes.length;}}return this;}/**
   * Insert new node after old node within the container.
   *
   * @param {Node|number} exist             Child or child’s index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   */;_proto.insertAfter=function insertAfter(exist,add){exist=this.index(exist);var nodes=this.normalize(add,this.nodes[exist]).reverse();for(var _iterator6=nodes,_isArray6=Array.isArray(_iterator6),_i7=0,_iterator6=_isArray6?_iterator6:_iterator6[Symbol.iterator]();;){var _ref6;if(_isArray6){if(_i7>=_iterator6.length)break;_ref6=_iterator6[_i7++];}else{_i7=_iterator6.next();if(_i7.done)break;_ref6=_i7.value;}var node=_ref6;this.nodes.splice(exist+1,0,node);}var index;for(var id in this.indexes){index=this.indexes[id];if(exist<index){this.indexes[id]=index+nodes.length;}}return this;}/**
   * Removes node from the container and cleans the parent properties
   * from the node and its children.
   *
   * @param {Node|number} child Child or child’s index.
   *
   * @return {Node} This node for methods chain
   *
   * @example
   * rule.nodes.length  //=> 5
   * rule.removeChild(decl)
   * rule.nodes.length  //=> 4
   * decl.parent        //=> undefined
   */;_proto.removeChild=function removeChild(child){child=this.index(child);this.nodes[child].parent=undefined;this.nodes.splice(child,1);var index;for(var id in this.indexes){index=this.indexes[id];if(index>=child){this.indexes[id]=index-1;}}return this;}/**
   * Removes all children from the container
   * and cleans their parent properties.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.removeAll()
   * rule.nodes.length //=> 0
   */;_proto.removeAll=function removeAll(){for(var _iterator7=this.nodes,_isArray7=Array.isArray(_iterator7),_i8=0,_iterator7=_isArray7?_iterator7:_iterator7[Symbol.iterator]();;){var _ref7;if(_isArray7){if(_i8>=_iterator7.length)break;_ref7=_iterator7[_i8++];}else{_i8=_iterator7.next();if(_i8.done)break;_ref7=_i8.value;}var node=_ref7;node.parent=undefined;}this.nodes=[];return this;}/**
   * Passes all declaration values within the container that match pattern
   * through callback, replacing those values with the returned result
   * of callback.
   *
   * This method is useful if you are using a custom unit or function
   * and need to iterate through all values.
   *
   * @param {string|RegExp} pattern      Replace pattern.
   * @param {object} opts                Options to speed up the search.
   * @param {string|string[]} opts.props An array of property names.
   * @param {string} opts.fast           String that’s used to narrow down
   *                                     values and speed up the regexp search.
   * @param {function|string} callback   String to replace pattern or callback
   *                                     that returns a new value. The callback
   *                                     will receive the same arguments
   *                                     as those passed to a function parameter
   *                                     of `String#replace`.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
   *   return 15 * parseInt(string) + 'px'
   * })
   */;_proto.replaceValues=function replaceValues(pattern,opts,callback){if(!callback){callback=opts;opts={};}this.walkDecls(function(decl){if(opts.props&&opts.props.indexOf(decl.prop)===-1)return;if(opts.fast&&decl.value.indexOf(opts.fast)===-1)return;decl.value=decl.value.replace(pattern,callback);});return this;}/**
   * Returns `true` if callback returns `true`
   * for all of the container’s children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is every child pass condition.
   *
   * @example
   * const noPrefixes = rule.every(i => i.prop[0] !== '-')
   */;_proto.every=function every(condition){return this.nodes.every(condition);}/**
   * Returns `true` if callback returns `true` for (at least) one
   * of the container’s children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is some child pass condition.
   *
   * @example
   * const hasPrefix = rule.some(i => i.prop[0] === '-')
   */;_proto.some=function some(condition){return this.nodes.some(condition);}/**
   * Returns a `child`’s index within the {@link Container#nodes} array.
   *
   * @param {Node} child Child of the current container.
   *
   * @return {number} Child index.
   *
   * @example
   * rule.index( rule.nodes[2] ) //=> 2
   */;_proto.index=function index(child){if(typeof child==='number'){return child;}return this.nodes.indexOf(child);}/**
   * The container’s first child.
   *
   * @type {Node}
   *
   * @example
   * rule.first === rules.nodes[0]
   */;_proto.normalize=function normalize(nodes,sample){var _this=this;if(typeof nodes==='string'){var parse=require('./parse');nodes=cleanSource(parse(nodes).nodes);}else if(Array.isArray(nodes)){nodes=nodes.slice(0);for(var _iterator8=nodes,_isArray8=Array.isArray(_iterator8),_i9=0,_iterator8=_isArray8?_iterator8:_iterator8[Symbol.iterator]();;){var _ref8;if(_isArray8){if(_i9>=_iterator8.length)break;_ref8=_iterator8[_i9++];}else{_i9=_iterator8.next();if(_i9.done)break;_ref8=_i9.value;}var i=_ref8;if(i.parent)i.parent.removeChild(i,'ignore');}}else if(nodes.type==='root'){nodes=nodes.nodes.slice(0);for(var _iterator9=nodes,_isArray9=Array.isArray(_iterator9),_i10=0,_iterator9=_isArray9?_iterator9:_iterator9[Symbol.iterator]();;){var _ref9;if(_isArray9){if(_i10>=_iterator9.length)break;_ref9=_iterator9[_i10++];}else{_i10=_iterator9.next();if(_i10.done)break;_ref9=_i10.value;}var _i11=_ref9;if(_i11.parent)_i11.parent.removeChild(_i11,'ignore');}}else if(nodes.type){nodes=[nodes];}else if(nodes.prop){if(typeof nodes.value==='undefined'){throw new Error('Value field is missed in node creation');}else if(typeof nodes.value!=='string'){nodes.value=String(nodes.value);}nodes=[new _declaration["default"](nodes)];}else if(nodes.selector){var Rule=require('./rule');nodes=[new Rule(nodes)];}else if(nodes.name){var AtRule=require('./at-rule');nodes=[new AtRule(nodes)];}else if(nodes.text){nodes=[new _comment["default"](nodes)];}else{throw new Error('Unknown node type in node creation');}var processed=nodes.map(function(i){if(i.parent)i.parent.removeChild(i);if(typeof i.raws.before==='undefined'){if(sample&&typeof sample.raws.before!=='undefined'){i.raws.before=sample.raws.before.replace(/[^\s]/g,'');}}i.parent=_this;return i;});return processed;}/**
   * @memberof Container#
   * @member {Node[]} nodes An array containing the container’s children.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * root.nodes.length           //=> 1
   * root.nodes[0].selector      //=> 'a'
   * root.nodes[0].nodes[0].prop //=> 'color'
   */;_createClass(Container,[{key:"first",get:function get(){if(!this.nodes)return undefined;return this.nodes[0];}/**
     * The container’s last child.
     *
     * @type {Node}
     *
     * @example
     * rule.last === rule.nodes[rule.nodes.length - 1]
     */},{key:"last",get:function get(){if(!this.nodes)return undefined;return this.nodes[this.nodes.length-1];}}]);return Container;}(_node["default"]);var _default=Container;/**
 * @callback childCondition
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @param {Node[]} nodes All container children.
 * @return {boolean}
 */ /**
 * @callback childIterator
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @return {false|undefined} Returning `false` will break iteration.
 */exports["default"]=_default;module.exports=exports["default"];},{"./at-rule":48,"./comment":49,"./declaration":52,"./node":57,"./parse":58,"./rule":65}],51:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _supportsColor=_interopRequireDefault(require("supports-color"));var _chalk=_interopRequireDefault(require("chalk"));var _terminalHighlight=_interopRequireDefault(require("./terminal-highlight"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}function _wrapNativeSuper(Class){var _cache=typeof Map==="function"?new Map():undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!=="function"){throw new TypeError("Super expression must either be null or a function");}if(typeof _cache!=="undefined"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper);}function Wrapper(){return _construct(Class,arguments,_getPrototypeOf(this).constructor);}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf(Wrapper,Class);};return _wrapNativeSuper(Class);}function isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _construct(Parent,args,Class){if(isNativeReflectConstruct()){_construct=Reflect.construct;}else{_construct=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor();if(Class)_setPrototypeOf(instance,Class.prototype);return instance;};}return _construct.apply(null,arguments);}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf("[native code]")!==-1;}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}/**
 * The CSS parser throws this error for broken CSS.
 *
 * Custom parsers can throw this error for broken custom syntax using
 * the {@link Node#error} method.
 *
 * PostCSS will use the input source map to detect the original error location.
 * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
 * PostCSS will show the original position in the Sass file.
 *
 * If you need the position in the PostCSS input
 * (e.g., to debug the previous compiler), use `error.input.file`.
 *
 * @example
 * // Catching and checking syntax error
 * try {
 *   postcss.parse('a{')
 * } catch (error) {
 *   if (error.name === 'CssSyntaxError') {
 *     error //=> CssSyntaxError
 *   }
 * }
 *
 * @example
 * // Raising error from plugin
 * throw node.error('Unknown variable', { plugin: 'postcss-vars' })
 */var CssSyntaxError=/*#__PURE__*/function(_Error){_inheritsLoose(CssSyntaxError,_Error);/**
   * @param {string} message  Error message.
   * @param {number} [line]   Source line of the error.
   * @param {number} [column] Source column of the error.
   * @param {string} [source] Source code of the broken file.
   * @param {string} [file]   Absolute path to the broken file.
   * @param {string} [plugin] PostCSS plugin name, if error came from plugin.
   */function CssSyntaxError(message,line,column,source,file,plugin){var _this;_this=_Error.call(this,message)||this;/**
     * Always equal to `'CssSyntaxError'`. You should always check error type
     * by `error.name === 'CssSyntaxError'`
     * instead of `error instanceof CssSyntaxError`,
     * because npm could have several PostCSS versions.
     *
     * @type {string}
     *
     * @example
     * if (error.name === 'CssSyntaxError') {
     *   error //=> CssSyntaxError
     * }
     */_this.name='CssSyntaxError';/**
     * Error message.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'Unclosed block'
     */_this.reason=message;if(file){/**
       * Absolute path to the broken file.
       *
       * @type {string}
       *
       * @example
       * error.file       //=> 'a.sass'
       * error.input.file //=> 'a.css'
       */_this.file=file;}if(source){/**
       * Source code of the broken file.
       *
       * @type {string}
       *
       * @example
       * error.source       //=> 'a { b {} }'
       * error.input.column //=> 'a b { }'
       */_this.source=source;}if(plugin){/**
       * Plugin name, if error came from plugin.
       *
       * @type {string}
       *
       * @example
       * error.plugin //=> 'postcss-vars'
       */_this.plugin=plugin;}if(typeof line!=='undefined'&&typeof column!=='undefined'){/**
       * Source line of the error.
       *
       * @type {number}
       *
       * @example
       * error.line       //=> 2
       * error.input.line //=> 4
       */_this.line=line;/**
       * Source column of the error.
       *
       * @type {number}
       *
       * @example
       * error.column       //=> 1
       * error.input.column //=> 4
       */_this.column=column;}_this.setMessage();if(Error.captureStackTrace){Error.captureStackTrace(_assertThisInitialized(_this),CssSyntaxError);}return _this;}var _proto=CssSyntaxError.prototype;_proto.setMessage=function setMessage(){/**
     * Full error text in the GNU error format
     * with plugin, file, line and column.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'a.css:1:1: Unclosed block'
     */this.message=this.plugin?this.plugin+': ':'';this.message+=this.file?this.file:'<css input>';if(typeof this.line!=='undefined'){this.message+=':'+this.line+':'+this.column;}this.message+=': '+this.reason;}/**
   * Returns a few lines of CSS source that caused the error.
   *
   * If the CSS has an input source map without `sourceContent`,
   * this method will return an empty string.
   *
   * @param {boolean} [color] Whether arrow will be colored red by terminal
   *                          color codes. By default, PostCSS will detect
   *                          color support by `process.stdout.isTTY`
   *                          and `process.env.NODE_DISABLE_COLORS`.
   *
   * @example
   * error.showSourceCode() //=> "  4 | }
   *                        //      5 | a {
   *                        //    > 6 |   bad
   *                        //        |   ^
   *                        //      7 | }
   *                        //      8 | b {"
   *
   * @return {string} Few lines of CSS source that caused the error.
   */;_proto.showSourceCode=function showSourceCode(color){var _this2=this;if(!this.source)return'';var css=this.source;if(_terminalHighlight["default"]){if(typeof color==='undefined')color=_supportsColor["default"].stdout;if(color)css=(0,_terminalHighlight["default"])(css);}var lines=css.split(/\r?\n/);var start=Math.max(this.line-3,0);var end=Math.min(this.line+2,lines.length);var maxWidth=String(end).length;function mark(text){if(color&&_chalk["default"].red){return _chalk["default"].red.bold(text);}return text;}function aside(text){if(color&&_chalk["default"].gray){return _chalk["default"].gray(text);}return text;}return lines.slice(start,end).map(function(line,index){var number=start+1+index;var gutter=' '+(' '+number).slice(-maxWidth)+' | ';if(number===_this2.line){var spacing=aside(gutter.replace(/\d/g,' '))+line.slice(0,_this2.column-1).replace(/[^\t]/g,' ');return mark('>')+aside(gutter)+line+'\n '+spacing+mark('^');}return' '+aside(gutter)+line;}).join('\n');}/**
   * Returns error position, message and source code of the broken part.
   *
   * @example
   * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
   *                  //    > 1 | a {
   *                  //        | ^"
   *
   * @return {string} Error position, message and source code.
   */;_proto.toString=function toString(){var code=this.showSourceCode();if(code){code='\n\n'+code+'\n';}return this.name+': '+this.message+code;}/**
   * @memberof CssSyntaxError#
   * @member {Input} input Input object with PostCSS internal information
   *                       about input file. If input has source map
   *                       from previous tool, PostCSS will use origin
   *                       (for example, Sass) source. You can use this
   *                       object to get PostCSS input source.
   *
   * @example
   * error.input.file //=> 'a.css'
   * error.file       //=> 'a.sass'
   */;return CssSyntaxError;}(_wrapNativeSuper(Error));var _default=CssSyntaxError;exports["default"]=_default;module.exports=exports["default"];},{"./terminal-highlight":2,"chalk":2,"supports-color":2}],52:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _node=_interopRequireDefault(require("./node"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents a CSS declaration.
 *
 * @extends Node
 *
 * @example
 * const root = postcss.parse('a { color: black }')
 * const decl = root.first.first
 * decl.type       //=> 'decl'
 * decl.toString() //=> ' color: black'
 */var Declaration=/*#__PURE__*/function(_Node){_inheritsLoose(Declaration,_Node);function Declaration(defaults){var _this;_this=_Node.call(this,defaults)||this;_this.type='decl';return _this;}/**
   * @memberof Declaration#
   * @member {string} prop The declaration’s property name.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.prop //=> 'color'
   */ /**
   * @memberof Declaration#
   * @member {string} value The declaration’s value.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.value //=> 'black'
   */ /**
   * @memberof Declaration#
   * @member {boolean} important `true` if the declaration
   *                             has an !important annotation.
   *
   * @example
   * const root = postcss.parse('a { color: black !important; color: red }')
   * root.first.first.important //=> true
   * root.first.last.important  //=> undefined
   */ /**
   * @memberof Declaration#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `between`: the symbols between the property and value
   *   for declarations.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans declaration from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */return Declaration;}(_node["default"]);var _default=Declaration;exports["default"]=_default;module.exports=exports["default"];},{"./node":57}],53:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _path=_interopRequireDefault(require("path"));var _cssSyntaxError=_interopRequireDefault(require("./css-syntax-error"));var _previousMap=_interopRequireDefault(require("./previous-map"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}var sequence=0;/**
 * Represents the source CSS.
 *
 * @example
 * const root  = postcss.parse(css, { from: file })
 * const input = root.source.input
 */var Input=/*#__PURE__*/function(){/**
   * @param {string} css    Input CSS source.
   * @param {object} [opts] {@link Processor#process} options.
   */function Input(css,opts){if(opts===void 0){opts={};}if(css===null||_typeof(css)==='object'&&!css.toString){throw new Error("PostCSS received "+css+" instead of CSS string");}/**
     * Input CSS source
     *
     * @type {string}
     *
     * @example
     * const input = postcss.parse('a{}', { from: file }).input
     * input.css //=> "a{}"
     */this.css=css.toString();if(this.css[0]==="\uFEFF"||this.css[0]==="\uFFFE"){this.hasBOM=true;this.css=this.css.slice(1);}else{this.hasBOM=false;}if(opts.from){if(/^\w+:\/\//.test(opts.from)||_path["default"].isAbsolute(opts.from)){/**
         * The absolute path to the CSS source file defined
         * with the `from` option.
         *
         * @type {string}
         *
         * @example
         * const root = postcss.parse(css, { from: 'a.css' })
         * root.source.input.file //=> '/home/ai/a.css'
         */this.file=opts.from;}else{this.file=_path["default"].resolve(opts.from);}}var map=new _previousMap["default"](this.css,opts);if(map.text){/**
       * The input source map passed from a compilation step before PostCSS
       * (for example, from Sass compiler).
       *
       * @type {PreviousMap}
       *
       * @example
       * root.source.input.map.consumer().sources //=> ['a.sass']
       */this.map=map;var file=map.consumer().file;if(!this.file&&file)this.file=this.mapResolve(file);}if(!this.file){sequence+=1;/**
       * The unique ID of the CSS source. It will be created if `from` option
       * is not provided (because PostCSS does not know the file path).
       *
       * @type {string}
       *
       * @example
       * const root = postcss.parse(css)
       * root.source.input.file //=> undefined
       * root.source.input.id   //=> "<input css 1>"
       */this.id='<input css '+sequence+'>';}if(this.map)this.map.file=this.from;}var _proto=Input.prototype;_proto.error=function error(message,line,column,opts){if(opts===void 0){opts={};}var result;var origin=this.origin(line,column);if(origin){result=new _cssSyntaxError["default"](message,origin.line,origin.column,origin.source,origin.file,opts.plugin);}else{result=new _cssSyntaxError["default"](message,line,column,this.css,this.file,opts.plugin);}result.input={line:line,column:column,source:this.css};if(this.file)result.input.file=this.file;return result;}/**
   * Reads the input source map and returns a symbol position
   * in the input source (e.g., in a Sass file that was compiled
   * to CSS before being passed to PostCSS).
   *
   * @param {number} line   Line in input CSS.
   * @param {number} column Column in input CSS.
   *
   * @return {filePosition} Position in input source.
   *
   * @example
   * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
   */;_proto.origin=function origin(line,column){if(!this.map)return false;var consumer=this.map.consumer();var from=consumer.originalPositionFor({line:line,column:column});if(!from.source)return false;var result={file:this.mapResolve(from.source),line:from.line,column:from.column};var source=consumer.sourceContentFor(from.source);if(source)result.source=source;return result;};_proto.mapResolve=function mapResolve(file){if(/^\w+:\/\//.test(file)){return file;}return _path["default"].resolve(this.map.consumer().sourceRoot||'.',file);}/**
   * The CSS source identifier. Contains {@link Input#file} if the user
   * set the `from` option, or {@link Input#id} if they did not.
   *
   * @type {string}
   *
   * @example
   * const root = postcss.parse(css, { from: 'a.css' })
   * root.source.input.from //=> "/home/ai/a.css"
   *
   * const root = postcss.parse(css)
   * root.source.input.from //=> "<input css 1>"
   */;_createClass(Input,[{key:"from",get:function get(){return this.file||this.id;}}]);return Input;}();var _default=Input;/**
 * @typedef  {object} filePosition
 * @property {string} file   Path to file.
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */exports["default"]=_default;module.exports=exports["default"];},{"./css-syntax-error":51,"./previous-map":61,"path":47}],54:[function(require,module,exports){(function(process){"use strict";exports.__esModule=true;exports["default"]=void 0;var _mapGenerator=_interopRequireDefault(require("./map-generator"));var _stringify2=_interopRequireDefault(require("./stringify"));var _warnOnce=_interopRequireDefault(require("./warn-once"));var _result=_interopRequireDefault(require("./result"));var _parse=_interopRequireDefault(require("./parse"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function isPromise(obj){return _typeof(obj)==='object'&&typeof obj.then==='function';}/**
 * A Promise proxy for the result of PostCSS transformations.
 *
 * A `LazyResult` instance is returned by {@link Processor#process}.
 *
 * @example
 * const lazy = postcss([autoprefixer]).process(css)
 */var LazyResult=/*#__PURE__*/function(){function LazyResult(processor,css,opts){this.stringified=false;this.processed=false;var root;if(_typeof(css)==='object'&&css!==null&&css.type==='root'){root=css;}else if(css instanceof LazyResult||css instanceof _result["default"]){root=css.root;if(css.map){if(typeof opts.map==='undefined')opts.map={};if(!opts.map.inline)opts.map.inline=false;opts.map.prev=css.map;}}else{var parser=_parse["default"];if(opts.syntax)parser=opts.syntax.parse;if(opts.parser)parser=opts.parser;if(parser.parse)parser=parser.parse;try{root=parser(css,opts);}catch(error){this.error=error;}}this.result=new _result["default"](processor,root,opts);}/**
   * Returns a {@link Processor} instance, which will be used
   * for CSS transformations.
   *
   * @type {Processor}
   */var _proto=LazyResult.prototype;/**
   * Processes input CSS through synchronous plugins
   * and calls {@link Result#warnings()}.
   *
   * @return {Warning[]} Warnings from plugins.
   */_proto.warnings=function warnings(){return this.sync().warnings();}/**
   * Alias for the {@link LazyResult#css} property.
   *
   * @example
   * lazy + '' === lazy.css
   *
   * @return {string} Output CSS.
   */;_proto.toString=function toString(){return this.css;}/**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls `onFulfilled` with a Result instance. If a plugin throws
   * an error, the `onRejected` callback will be executed.
   *
   * It implements standard Promise API.
   *
   * @param {onFulfilled} onFulfilled Callback will be executed
   *                                  when all plugins will finish work.
   * @param {onRejected}  onRejected  Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {
   *   console.log(result.css)
   * })
   */;_proto.then=function then(onFulfilled,onRejected){if(process.env.NODE_ENV!=='production'){if(!('from'in this.opts)){(0,_warnOnce["default"])('Without `from` option PostCSS could generate wrong source map '+'and will not find Browserslist config. Set it to CSS file path '+'or to `undefined` to prevent this warning.');}}return this.async().then(onFulfilled,onRejected);}/**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onRejected for each error thrown in any plugin.
   *
   * It implements standard Promise API.
   *
   * @param {onRejected} onRejected Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).then(result => {
   *   console.log(result.css)
   * }).catch(error => {
   *   console.error(error)
   * })
   */;_proto["catch"]=function _catch(onRejected){return this.async()["catch"](onRejected);}/**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onFinally on any error or when all plugins will finish work.
   *
   * It implements standard Promise API.
   *
   * @param {onFinally} onFinally Callback will be executed on any error or
   *                              when all plugins will finish work.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).finally(() => {
   *   console.log('processing ended')
   * })
   */;_proto["finally"]=function _finally(onFinally){return this.async().then(onFinally,onFinally);};_proto.handleError=function handleError(error,plugin){try{this.error=error;if(error.name==='CssSyntaxError'&&!error.plugin){error.plugin=plugin.postcssPlugin;error.setMessage();}else if(plugin.postcssVersion){if(process.env.NODE_ENV!=='production'){var pluginName=plugin.postcssPlugin;var pluginVer=plugin.postcssVersion;var runtimeVer=this.result.processor.version;var a=pluginVer.split('.');var b=runtimeVer.split('.');if(a[0]!==b[0]||parseInt(a[1])>parseInt(b[1])){console.error('Unknown error from PostCSS plugin. Your current PostCSS '+'version is '+runtimeVer+', but '+pluginName+' uses '+pluginVer+'. Perhaps this is the source of the error below.');}}}}catch(err){if(console&&console.error)console.error(err);}};_proto.asyncTick=function asyncTick(resolve,reject){var _this=this;if(this.plugin>=this.processor.plugins.length){this.processed=true;return resolve();}try{var plugin=this.processor.plugins[this.plugin];var promise=this.run(plugin);this.plugin+=1;if(isPromise(promise)){promise.then(function(){_this.asyncTick(resolve,reject);})["catch"](function(error){_this.handleError(error,plugin);_this.processed=true;reject(error);});}else{this.asyncTick(resolve,reject);}}catch(error){this.processed=true;reject(error);}};_proto.async=function async(){var _this2=this;if(this.processed){return new Promise(function(resolve,reject){if(_this2.error){reject(_this2.error);}else{resolve(_this2.stringify());}});}if(this.processing){return this.processing;}this.processing=new Promise(function(resolve,reject){if(_this2.error)return reject(_this2.error);_this2.plugin=0;_this2.asyncTick(resolve,reject);}).then(function(){_this2.processed=true;return _this2.stringify();});return this.processing;};_proto.sync=function sync(){if(this.processed)return this.result;this.processed=true;if(this.processing){throw new Error('Use process(css).then(cb) to work with async plugins');}if(this.error)throw this.error;for(var _iterator=this.result.processor.plugins,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var plugin=_ref;var promise=this.run(plugin);if(isPromise(promise)){throw new Error('Use process(css).then(cb) to work with async plugins');}}return this.result;};_proto.run=function run(plugin){this.result.lastPlugin=plugin;try{return plugin(this.result.root,this.result);}catch(error){this.handleError(error,plugin);throw error;}};_proto.stringify=function stringify(){if(this.stringified)return this.result;this.stringified=true;this.sync();var opts=this.result.opts;var str=_stringify2["default"];if(opts.syntax)str=opts.syntax.stringify;if(opts.stringifier)str=opts.stringifier;if(str.stringify)str=str.stringify;var map=new _mapGenerator["default"](str,this.result.root,this.result.opts);var data=map.generate();this.result.css=data[0];this.result.map=data[1];return this.result;};_createClass(LazyResult,[{key:"processor",get:function get(){return this.result.processor;}/**
     * Options from the {@link Processor#process} call.
     *
     * @type {processOptions}
     */},{key:"opts",get:function get(){return this.result.opts;}/**
     * Processes input CSS through synchronous plugins, converts `Root`
     * to a CSS string and returns {@link Result#css}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#css
     */},{key:"css",get:function get(){return this.stringify().css;}/**
     * An alias for the `css` property. Use it with syntaxes
     * that generate non-CSS output.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#content
     */},{key:"content",get:function get(){return this.stringify().content;}/**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#map}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {SourceMapGenerator}
     * @see Result#map
     */},{key:"map",get:function get(){return this.stringify().map;}/**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#root}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Root}
     * @see Result#root
     */},{key:"root",get:function get(){return this.sync().root;}/**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#messages}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Message[]}
     * @see Result#messages
     */},{key:"messages",get:function get(){return this.sync().messages;}}]);return LazyResult;}();var _default=LazyResult;/**
 * @callback onFulfilled
 * @param {Result} result
 */ /**
 * @callback onRejected
 * @param {Error} error
 */exports["default"]=_default;module.exports=exports["default"];}).call(this,require('_process'));},{"./map-generator":56,"./parse":58,"./result":63,"./stringify":67,"./warn-once":70,"_process":72}],55:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;/**
 * Contains helpers for safely splitting lists of CSS values,
 * preserving parentheses and quotes.
 *
 * @example
 * const list = postcss.list
 *
 * @namespace list
 */var list={split:function split(string,separators,last){var array=[];var current='';var split=false;var func=0;var quote=false;var escape=false;for(var i=0;i<string.length;i++){var letter=string[i];if(quote){if(escape){escape=false;}else if(letter==='\\'){escape=true;}else if(letter===quote){quote=false;}}else if(letter==='"'||letter==='\''){quote=letter;}else if(letter==='('){func+=1;}else if(letter===')'){if(func>0)func-=1;}else if(func===0){if(separators.indexOf(letter)!==-1)split=true;}if(split){if(current!=='')array.push(current.trim());current='';split=false;}else{current+=letter;}}if(last||current!=='')array.push(current.trim());return array;},/**
   * Safely splits space-separated values (such as those for `background`,
   * `border-radius`, and other shorthand properties).
   *
   * @param {string} string Space-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
   */space:function space(string){var spaces=[' ','\n','\t'];return list.split(string,spaces);},/**
   * Safely splits comma-separated values (such as those for `transition-*`
   * and `background` properties).
   *
   * @param {string} string Comma-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.comma('black, linear-gradient(white, black)')
   * //=> ['black', 'linear-gradient(white, black)']
   */comma:function comma(string){return list.split(string,[','],true);}};var _default=list;exports["default"]=_default;module.exports=exports["default"];},{}],56:[function(require,module,exports){(function(Buffer){"use strict";exports.__esModule=true;exports["default"]=void 0;var _sourceMap=_interopRequireDefault(require("source-map"));var _path=_interopRequireDefault(require("path"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}var MapGenerator=/*#__PURE__*/function(){function MapGenerator(stringify,root,opts){this.stringify=stringify;this.mapOpts=opts.map||{};this.root=root;this.opts=opts;}var _proto=MapGenerator.prototype;_proto.isMap=function isMap(){if(typeof this.opts.map!=='undefined'){return!!this.opts.map;}return this.previous().length>0;};_proto.previous=function previous(){var _this=this;if(!this.previousMaps){this.previousMaps=[];this.root.walk(function(node){if(node.source&&node.source.input.map){var map=node.source.input.map;if(_this.previousMaps.indexOf(map)===-1){_this.previousMaps.push(map);}}});}return this.previousMaps;};_proto.isInline=function isInline(){if(typeof this.mapOpts.inline!=='undefined'){return this.mapOpts.inline;}var annotation=this.mapOpts.annotation;if(typeof annotation!=='undefined'&&annotation!==true){return false;}if(this.previous().length){return this.previous().some(function(i){return i.inline;});}return true;};_proto.isSourcesContent=function isSourcesContent(){if(typeof this.mapOpts.sourcesContent!=='undefined'){return this.mapOpts.sourcesContent;}if(this.previous().length){return this.previous().some(function(i){return i.withContent();});}return true;};_proto.clearAnnotation=function clearAnnotation(){if(this.mapOpts.annotation===false)return;var node;for(var i=this.root.nodes.length-1;i>=0;i--){node=this.root.nodes[i];if(node.type!=='comment')continue;if(node.text.indexOf('# sourceMappingURL=')===0){this.root.removeChild(i);}}};_proto.setSourcesContent=function setSourcesContent(){var _this2=this;var already={};this.root.walk(function(node){if(node.source){var from=node.source.input.from;if(from&&!already[from]){already[from]=true;var relative=_this2.relative(from);_this2.map.setSourceContent(relative,node.source.input.css);}}});};_proto.applyPrevMaps=function applyPrevMaps(){for(var _iterator=this.previous(),_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var prev=_ref;var from=this.relative(prev.file);var root=prev.root||_path["default"].dirname(prev.file);var map=void 0;if(this.mapOpts.sourcesContent===false){map=new _sourceMap["default"].SourceMapConsumer(prev.text);if(map.sourcesContent){map.sourcesContent=map.sourcesContent.map(function(){return null;});}}else{map=prev.consumer();}this.map.applySourceMap(map,from,this.relative(root));}};_proto.isAnnotation=function isAnnotation(){if(this.isInline()){return true;}if(typeof this.mapOpts.annotation!=='undefined'){return this.mapOpts.annotation;}if(this.previous().length){return this.previous().some(function(i){return i.annotation;});}return true;};_proto.toBase64=function toBase64(str){if(Buffer){return Buffer.from(str).toString('base64');}return window.btoa(unescape(encodeURIComponent(str)));};_proto.addAnnotation=function addAnnotation(){var content;if(this.isInline()){content='data:application/json;base64,'+this.toBase64(this.map.toString());}else if(typeof this.mapOpts.annotation==='string'){content=this.mapOpts.annotation;}else{content=this.outputFile()+'.map';}var eol='\n';if(this.css.indexOf('\r\n')!==-1)eol='\r\n';this.css+=eol+'/*# sourceMappingURL='+content+' */';};_proto.outputFile=function outputFile(){if(this.opts.to){return this.relative(this.opts.to);}if(this.opts.from){return this.relative(this.opts.from);}return'to.css';};_proto.generateMap=function generateMap(){this.generateString();if(this.isSourcesContent())this.setSourcesContent();if(this.previous().length>0)this.applyPrevMaps();if(this.isAnnotation())this.addAnnotation();if(this.isInline()){return[this.css];}return[this.css,this.map];};_proto.relative=function relative(file){if(file.indexOf('<')===0)return file;if(/^\w+:\/\//.test(file))return file;var from=this.opts.to?_path["default"].dirname(this.opts.to):'.';if(typeof this.mapOpts.annotation==='string'){from=_path["default"].dirname(_path["default"].resolve(from,this.mapOpts.annotation));}file=_path["default"].relative(from,file);if(_path["default"].sep==='\\'){return file.replace(/\\/g,'/');}return file;};_proto.sourcePath=function sourcePath(node){if(this.mapOpts.from){return this.mapOpts.from;}return this.relative(node.source.input.from);};_proto.generateString=function generateString(){var _this3=this;this.css='';this.map=new _sourceMap["default"].SourceMapGenerator({file:this.outputFile()});var line=1;var column=1;var lines,last;this.stringify(this.root,function(str,node,type){_this3.css+=str;if(node&&type!=='end'){if(node.source&&node.source.start){_this3.map.addMapping({source:_this3.sourcePath(node),generated:{line:line,column:column-1},original:{line:node.source.start.line,column:node.source.start.column-1}});}else{_this3.map.addMapping({source:'<no source>',original:{line:1,column:0},generated:{line:line,column:column-1}});}}lines=str.match(/\n/g);if(lines){line+=lines.length;last=str.lastIndexOf('\n');column=str.length-last;}else{column+=str.length;}if(node&&type!=='start'){var p=node.parent||{raws:{}};if(node.type!=='decl'||node!==p.last||p.raws.semicolon){if(node.source&&node.source.end){_this3.map.addMapping({source:_this3.sourcePath(node),generated:{line:line,column:column-2},original:{line:node.source.end.line,column:node.source.end.column-1}});}else{_this3.map.addMapping({source:'<no source>',original:{line:1,column:0},generated:{line:line,column:column-1}});}}}});};_proto.generate=function generate(){this.clearAnnotation();if(this.isMap()){return this.generateMap();}var result='';this.stringify(this.root,function(i){result+=i;});return[result];};return MapGenerator;}();var _default=MapGenerator;exports["default"]=_default;module.exports=exports["default"];}).call(this,require("buffer").Buffer);},{"buffer":3,"path":47,"source-map":88}],57:[function(require,module,exports){(function(process){"use strict";exports.__esModule=true;exports["default"]=void 0;var _cssSyntaxError=_interopRequireDefault(require("./css-syntax-error"));var _stringifier=_interopRequireDefault(require("./stringifier"));var _stringify=_interopRequireDefault(require("./stringify"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function cloneNode(obj,parent){var cloned=new obj.constructor();for(var i in obj){if(!obj.hasOwnProperty(i))continue;var value=obj[i];var type=_typeof(value);if(i==='parent'&&type==='object'){if(parent)cloned[i]=parent;}else if(i==='source'){cloned[i]=value;}else if(value instanceof Array){cloned[i]=value.map(function(j){return cloneNode(j,cloned);});}else{if(type==='object'&&value!==null)value=cloneNode(value);cloned[i]=value;}}return cloned;}/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */var Node=/*#__PURE__*/function(){/**
   * @param {object} [defaults] Value for node properties.
   */function Node(defaults){if(defaults===void 0){defaults={};}this.raws={};if(process.env.NODE_ENV!=='production'){if(_typeof(defaults)!=='object'&&typeof defaults!=='undefined'){throw new Error('PostCSS nodes constructor accepts object, not '+JSON.stringify(defaults));}}for(var name in defaults){this[name]=defaults[name];}}/**
   * Returns a `CssSyntaxError` instance containing the original position
   * of the node in the source, showing line and column numbers and also
   * a small excerpt to facilitate debugging.
   *
   * If present, an input source map will be used to get the original position
   * of the source, even from a previous compilation step
   * (e.g., from Sass compilation).
   *
   * This method produces very useful error messages.
   *
   * @param {string} message     Error description.
   * @param {object} [opts]      Options.
   * @param {string} opts.plugin Plugin name that created this error.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a node’s string that should
   *                             be highlighted as the source of the error.
   * @param {number} opts.index  An index inside a node’s string that should
   *                             be highlighted as the source of the error.
   *
   * @return {CssSyntaxError} Error object to throw it.
   *
   * @example
   * if (!variables[name]) {
   *   throw decl.error('Unknown variable ' + name, { word: name })
   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
   *   //   color: $black
   *   // a
   *   //          ^
   *   //   background: white
   * }
   */var _proto=Node.prototype;_proto.error=function error(message,opts){if(opts===void 0){opts={};}if(this.source){var pos=this.positionBy(opts);return this.source.input.error(message,pos.line,pos.column,opts);}return new _cssSyntaxError["default"](message);}/**
   * This method is provided as a convenience wrapper for {@link Result#warn}.
   *
   * @param {Result} result      The {@link Result} instance
   *                             that will receive the warning.
   * @param {string} text        Warning message.
   * @param {object} [opts]      Options
   * @param {string} opts.plugin Plugin name that created this warning.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a node’s string that should
   *                             be highlighted as the source of the warning.
   * @param {number} opts.index  An index inside a node’s string that should
   *                             be highlighted as the source of the warning.
   *
   * @return {Warning} Created warning object.
   *
   * @example
   * const plugin = postcss.plugin('postcss-deprecated', () => {
   *   return (root, result) => {
   *     root.walkDecls('bad', decl => {
   *       decl.warn(result, 'Deprecated property bad')
   *     })
   *   }
   * })
   */;_proto.warn=function warn(result,text,opts){var data={node:this};for(var i in opts){data[i]=opts[i];}return result.warn(text,data);}/**
   * Removes the node from its parent and cleans the parent properties
   * from the node and its children.
   *
   * @example
   * if (decl.prop.match(/^-webkit-/)) {
   *   decl.remove()
   * }
   *
   * @return {Node} Node to make calls chain.
   */;_proto.remove=function remove(){if(this.parent){this.parent.removeChild(this);}this.parent=undefined;return this;}/**
   * Returns a CSS string representing the node.
   *
   * @param {stringifier|syntax} [stringifier] A syntax to use
   *                                           in string generation.
   *
   * @return {string} CSS string of this node.
   *
   * @example
   * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
   */;_proto.toString=function toString(stringifier){if(stringifier===void 0){stringifier=_stringify["default"];}if(stringifier.stringify)stringifier=stringifier.stringify;var result='';stringifier(this,function(i){result+=i;});return result;}/**
   * Returns an exact clone of the node.
   *
   * The resulting cloned node and its (cloned) children will retain
   * code style properties.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @example
   * decl.raws.before    //=> "\n  "
   * const cloned = decl.clone({ prop: '-moz-' + decl.prop })
   * cloned.raws.before  //=> "\n  "
   * cloned.toString()   //=> -moz-transform: scale(0)
   *
   * @return {Node} Clone of the node.
   */;_proto.clone=function clone(overrides){if(overrides===void 0){overrides={};}var cloned=cloneNode(this);for(var name in overrides){cloned[name]=overrides[name];}return cloned;}/**
   * Shortcut to clone the node and insert the resulting cloned node
   * before the current node.
   *
   * @param {object} [overrides] Mew properties to override in the clone.
   *
   * @example
   * decl.cloneBefore({ prop: '-moz-' + decl.prop })
   *
   * @return {Node} New node
   */;_proto.cloneBefore=function cloneBefore(overrides){if(overrides===void 0){overrides={};}var cloned=this.clone(overrides);this.parent.insertBefore(this,cloned);return cloned;}/**
   * Shortcut to clone the node and insert the resulting cloned node
   * after the current node.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @return {Node} New node.
   */;_proto.cloneAfter=function cloneAfter(overrides){if(overrides===void 0){overrides={};}var cloned=this.clone(overrides);this.parent.insertAfter(this,cloned);return cloned;}/**
   * Inserts node(s) before the current node and removes the current node.
   *
   * @param {...Node} nodes Mode(s) to replace current one.
   *
   * @example
   * if (atrule.name === 'mixin') {
   *   atrule.replaceWith(mixinRules[atrule.params])
   * }
   *
   * @return {Node} Current node to methods chain.
   */;_proto.replaceWith=function replaceWith(){if(this.parent){for(var _len=arguments.length,nodes=new Array(_len),_key=0;_key<_len;_key++){nodes[_key]=arguments[_key];}for(var _i=0,_nodes=nodes;_i<_nodes.length;_i++){var node=_nodes[_i];this.parent.insertBefore(this,node);}this.remove();}return this;}/**
   * Returns the next child of the node’s parent.
   * Returns `undefined` if the current node is the last child.
   *
   * @return {Node|undefined} Next node.
   *
   * @example
   * if (comment.text === 'delete next') {
   *   const next = comment.next()
   *   if (next) {
   *     next.remove()
   *   }
   * }
   */;_proto.next=function next(){if(!this.parent)return undefined;var index=this.parent.index(this);return this.parent.nodes[index+1];}/**
   * Returns the previous child of the node’s parent.
   * Returns `undefined` if the current node is the first child.
   *
   * @return {Node|undefined} Previous node.
   *
   * @example
   * const annotation = decl.prev()
   * if (annotation.type === 'comment') {
   *   readAnnotation(annotation.text)
   * }
   */;_proto.prev=function prev(){if(!this.parent)return undefined;var index=this.parent.index(this);return this.parent.nodes[index-1];}/**
   * Insert new node before current node to current node’s parent.
   *
   * Just alias for `node.parent.insertBefore(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.before('content: ""')
   */;_proto.before=function before(add){this.parent.insertBefore(this,add);return this;}/**
   * Insert new node after current node to current node’s parent.
   *
   * Just alias for `node.parent.insertAfter(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.after('color: black')
   */;_proto.after=function after(add){this.parent.insertAfter(this,add);return this;};_proto.toJSON=function toJSON(){var fixed={};for(var name in this){if(!this.hasOwnProperty(name))continue;if(name==='parent')continue;var value=this[name];if(value instanceof Array){fixed[name]=value.map(function(i){if(_typeof(i)==='object'&&i.toJSON){return i.toJSON();}else{return i;}});}else if(_typeof(value)==='object'&&value.toJSON){fixed[name]=value.toJSON();}else{fixed[name]=value;}}return fixed;}/**
   * Returns a {@link Node#raws} value. If the node is missing
   * the code style property (because the node was manually built or cloned),
   * PostCSS will try to autodetect the code style property by looking
   * at other nodes in the tree.
   *
   * @param {string} prop          Name of code style property.
   * @param {string} [defaultType] Name of default value, it can be missed
   *                               if the value is the same as prop.
   *
   * @example
   * const root = postcss.parse('a { background: white }')
   * root.nodes[0].append({ prop: 'color', value: 'black' })
   * root.nodes[0].nodes[1].raws.before   //=> undefined
   * root.nodes[0].nodes[1].raw('before') //=> ' '
   *
   * @return {string} Code style value.
   */;_proto.raw=function raw(prop,defaultType){var str=new _stringifier["default"]();return str.raw(this,prop,defaultType);}/**
   * Finds the Root instance of the node’s tree.
   *
   * @example
   * root.nodes[0].nodes[0].root() === root
   *
   * @return {Root} Root parent.
   */;_proto.root=function root(){var result=this;while(result.parent){result=result.parent;}return result;}/**
   * Clear the code style properties for the node and its children.
   *
   * @param {boolean} [keepBetween] Keep the raws.between symbols.
   *
   * @return {undefined}
   *
   * @example
   * node.raws.before  //=> ' '
   * node.cleanRaws()
   * node.raws.before  //=> undefined
   */;_proto.cleanRaws=function cleanRaws(keepBetween){delete this.raws.before;delete this.raws.after;if(!keepBetween)delete this.raws.between;};_proto.positionInside=function positionInside(index){var string=this.toString();var column=this.source.start.column;var line=this.source.start.line;for(var i=0;i<index;i++){if(string[i]==='\n'){column=1;line+=1;}else{column+=1;}}return{line:line,column:column};};_proto.positionBy=function positionBy(opts){var pos=this.source.start;if(opts.index){pos=this.positionInside(opts.index);}else if(opts.word){var index=this.toString().indexOf(opts.word);if(index!==-1)pos=this.positionInside(index);}return pos;}/**
   * @memberof Node#
   * @member {string} type String representing the node’s type.
   *                       Possible values are `root`, `atrule`, `rule`,
   *                       `decl`, or `comment`.
   *
   * @example
   * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
   */ /**
   * @memberof Node#
   * @member {Container} parent The node’s parent node.
   *
   * @example
   * root.nodes[0].parent === root
   */ /**
   * @memberof Node#
   * @member {source} source The input source of the node.
   *
   * The property is used in source map generation.
   *
   * If you create a node manually (e.g., with `postcss.decl()`),
   * that node will not have a `source` property and will be absent
   * from the source map. For this reason, the plugin developer should
   * consider cloning nodes to create new ones (in which case the new node’s
   * source will reference the original, cloned node) or setting
   * the `source` property manually.
   *
   * ```js
   * // Bad
   * const prefixed = postcss.decl({
   *   prop: '-moz-' + decl.prop,
   *   value: decl.value
   * })
   *
   * // Good
   * const prefixed = decl.clone({ prop: '-moz-' + decl.prop })
   * ```
   *
   * ```js
   * if (atrule.name === 'add-link') {
   *   const rule = postcss.rule({ selector: 'a', source: atrule.source })
   *   atrule.parent.insertBefore(atrule, rule)
   * }
   * ```
   *
   * @example
   * decl.source.input.from //=> '/home/ai/a.sass'
   * decl.source.start      //=> { line: 10, column: 2 }
   * decl.source.end        //=> { line: 10, column: 12 }
   */ /**
   * @memberof Node#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   * * `left`: the space symbols between `/*` and the comment’s text.
   * * `right`: the space symbols between the comment’s text
   *   and <code>*&#47;</code>.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans selectors, declaration values and at-rule parameters
   * from comments and extra spaces, but it stores origin content in raws
   * properties. As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */;return Node;}();var _default=Node;/**
 * @typedef {object} position
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */ /**
 * @typedef {object} source
 * @property {Input} input    {@link Input} with input file
 * @property {position} start The starting position of the node’s source.
 * @property {position} end   The ending position of the node’s source.
 */exports["default"]=_default;module.exports=exports["default"];}).call(this,require('_process'));},{"./css-syntax-error":51,"./stringifier":66,"./stringify":67,"_process":72}],58:[function(require,module,exports){(function(process){"use strict";exports.__esModule=true;exports["default"]=void 0;var _parser=_interopRequireDefault(require("./parser"));var _input=_interopRequireDefault(require("./input"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function parse(css,opts){var input=new _input["default"](css,opts);var parser=new _parser["default"](input);try{parser.parse();}catch(e){if(process.env.NODE_ENV!=='production'){if(e.name==='CssSyntaxError'&&opts&&opts.from){if(/\.scss$/i.test(opts.from)){e.message+='\nYou tried to parse SCSS with '+'the standard CSS parser; '+'try again with the postcss-scss parser';}else if(/\.sass/i.test(opts.from)){e.message+='\nYou tried to parse Sass with '+'the standard CSS parser; '+'try again with the postcss-sass parser';}else if(/\.less$/i.test(opts.from)){e.message+='\nYou tried to parse Less with '+'the standard CSS parser; '+'try again with the postcss-less parser';}}}throw e;}return parser.root;}var _default=parse;exports["default"]=_default;module.exports=exports["default"];}).call(this,require('_process'));},{"./input":53,"./parser":59,"_process":72}],59:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _declaration=_interopRequireDefault(require("./declaration"));var _tokenize=_interopRequireDefault(require("./tokenize"));var _comment=_interopRequireDefault(require("./comment"));var _atRule=_interopRequireDefault(require("./at-rule"));var _root=_interopRequireDefault(require("./root"));var _rule=_interopRequireDefault(require("./rule"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}var Parser=/*#__PURE__*/function(){function Parser(input){this.input=input;this.root=new _root["default"]();this.current=this.root;this.spaces='';this.semicolon=false;this.createTokenizer();this.root.source={input:input,start:{line:1,column:1}};}var _proto=Parser.prototype;_proto.createTokenizer=function createTokenizer(){this.tokenizer=(0,_tokenize["default"])(this.input);};_proto.parse=function parse(){var token;while(!this.tokenizer.endOfFile()){token=this.tokenizer.nextToken();switch(token[0]){case'space':this.spaces+=token[1];break;case';':this.freeSemicolon(token);break;case'}':this.end(token);break;case'comment':this.comment(token);break;case'at-word':this.atrule(token);break;case'{':this.emptyRule(token);break;default:this.other(token);break;}}this.endFile();};_proto.comment=function comment(token){var node=new _comment["default"]();this.init(node,token[2],token[3]);node.source.end={line:token[4],column:token[5]};var text=token[1].slice(2,-2);if(/^\s*$/.test(text)){node.text='';node.raws.left=text;node.raws.right='';}else{var match=text.match(/^(\s*)([^]*[^\s])(\s*)$/);node.text=match[2];node.raws.left=match[1];node.raws.right=match[3];}};_proto.emptyRule=function emptyRule(token){var node=new _rule["default"]();this.init(node,token[2],token[3]);node.selector='';node.raws.between='';this.current=node;};_proto.other=function other(start){var end=false;var type=null;var colon=false;var bracket=null;var brackets=[];var tokens=[];var token=start;while(token){type=token[0];tokens.push(token);if(type==='('||type==='['){if(!bracket)bracket=token;brackets.push(type==='('?')':']');}else if(brackets.length===0){if(type===';'){if(colon){this.decl(tokens);return;}else{break;}}else if(type==='{'){this.rule(tokens);return;}else if(type==='}'){this.tokenizer.back(tokens.pop());end=true;break;}else if(type===':'){colon=true;}}else if(type===brackets[brackets.length-1]){brackets.pop();if(brackets.length===0)bracket=null;}token=this.tokenizer.nextToken();}if(this.tokenizer.endOfFile())end=true;if(brackets.length>0)this.unclosedBracket(bracket);if(end&&colon){while(tokens.length){token=tokens[tokens.length-1][0];if(token!=='space'&&token!=='comment')break;this.tokenizer.back(tokens.pop());}this.decl(tokens);}else{this.unknownWord(tokens);}};_proto.rule=function rule(tokens){tokens.pop();var node=new _rule["default"]();this.init(node,tokens[0][2],tokens[0][3]);node.raws.between=this.spacesAndCommentsFromEnd(tokens);this.raw(node,'selector',tokens);this.current=node;};_proto.decl=function decl(tokens){var node=new _declaration["default"]();this.init(node);var last=tokens[tokens.length-1];if(last[0]===';'){this.semicolon=true;tokens.pop();}if(last[4]){node.source.end={line:last[4],column:last[5]};}else{node.source.end={line:last[2],column:last[3]};}while(tokens[0][0]!=='word'){if(tokens.length===1)this.unknownWord(tokens);node.raws.before+=tokens.shift()[1];}node.source.start={line:tokens[0][2],column:tokens[0][3]};node.prop='';while(tokens.length){var type=tokens[0][0];if(type===':'||type==='space'||type==='comment'){break;}node.prop+=tokens.shift()[1];}node.raws.between='';var token;while(tokens.length){token=tokens.shift();if(token[0]===':'){node.raws.between+=token[1];break;}else{if(token[0]==='word'&&/\w/.test(token[1])){this.unknownWord([token]);}node.raws.between+=token[1];}}if(node.prop[0]==='_'||node.prop[0]==='*'){node.raws.before+=node.prop[0];node.prop=node.prop.slice(1);}node.raws.between+=this.spacesAndCommentsFromStart(tokens);this.precheckMissedSemicolon(tokens);for(var i=tokens.length-1;i>0;i--){token=tokens[i];if(token[1].toLowerCase()==='!important'){node.important=true;var string=this.stringFrom(tokens,i);string=this.spacesFromEnd(tokens)+string;if(string!==' !important')node.raws.important=string;break;}else if(token[1].toLowerCase()==='important'){var cache=tokens.slice(0);var str='';for(var j=i;j>0;j--){var _type=cache[j][0];if(str.trim().indexOf('!')===0&&_type!=='space'){break;}str=cache.pop()[1]+str;}if(str.trim().indexOf('!')===0){node.important=true;node.raws.important=str;tokens=cache;}}if(token[0]!=='space'&&token[0]!=='comment'){break;}}this.raw(node,'value',tokens);if(node.value.indexOf(':')!==-1)this.checkMissedSemicolon(tokens);};_proto.atrule=function atrule(token){var node=new _atRule["default"]();node.name=token[1].slice(1);if(node.name===''){this.unnamedAtrule(node,token);}this.init(node,token[2],token[3]);var prev;var shift;var last=false;var open=false;var params=[];while(!this.tokenizer.endOfFile()){token=this.tokenizer.nextToken();if(token[0]===';'){node.source.end={line:token[2],column:token[3]};this.semicolon=true;break;}else if(token[0]==='{'){open=true;break;}else if(token[0]==='}'){if(params.length>0){shift=params.length-1;prev=params[shift];while(prev&&prev[0]==='space'){prev=params[--shift];}if(prev){node.source.end={line:prev[4],column:prev[5]};}}this.end(token);break;}else{params.push(token);}if(this.tokenizer.endOfFile()){last=true;break;}}node.raws.between=this.spacesAndCommentsFromEnd(params);if(params.length){node.raws.afterName=this.spacesAndCommentsFromStart(params);this.raw(node,'params',params);if(last){token=params[params.length-1];node.source.end={line:token[4],column:token[5]};this.spaces=node.raws.between;node.raws.between='';}}else{node.raws.afterName='';node.params='';}if(open){node.nodes=[];this.current=node;}};_proto.end=function end(token){if(this.current.nodes&&this.current.nodes.length){this.current.raws.semicolon=this.semicolon;}this.semicolon=false;this.current.raws.after=(this.current.raws.after||'')+this.spaces;this.spaces='';if(this.current.parent){this.current.source.end={line:token[2],column:token[3]};this.current=this.current.parent;}else{this.unexpectedClose(token);}};_proto.endFile=function endFile(){if(this.current.parent)this.unclosedBlock();if(this.current.nodes&&this.current.nodes.length){this.current.raws.semicolon=this.semicolon;}this.current.raws.after=(this.current.raws.after||'')+this.spaces;};_proto.freeSemicolon=function freeSemicolon(token){this.spaces+=token[1];if(this.current.nodes){var prev=this.current.nodes[this.current.nodes.length-1];if(prev&&prev.type==='rule'&&!prev.raws.ownSemicolon){prev.raws.ownSemicolon=this.spaces;this.spaces='';}}}// Helpers
;_proto.init=function init(node,line,column){this.current.push(node);node.source={start:{line:line,column:column},input:this.input};node.raws.before=this.spaces;this.spaces='';if(node.type!=='comment')this.semicolon=false;};_proto.raw=function raw(node,prop,tokens){var token,type;var length=tokens.length;var value='';var clean=true;var next,prev;var pattern=/^([.|#])?([\w])+/i;for(var i=0;i<length;i+=1){token=tokens[i];type=token[0];if(type==='comment'&&node.type==='rule'){prev=tokens[i-1];next=tokens[i+1];if(prev[0]!=='space'&&next[0]!=='space'&&pattern.test(prev[1])&&pattern.test(next[1])){value+=token[1];}else{clean=false;}continue;}if(type==='comment'||type==='space'&&i===length-1){clean=false;}else{value+=token[1];}}if(!clean){var raw=tokens.reduce(function(all,i){return all+i[1];},'');node.raws[prop]={value:value,raw:raw};}node[prop]=value;};_proto.spacesAndCommentsFromEnd=function spacesAndCommentsFromEnd(tokens){var lastTokenType;var spaces='';while(tokens.length){lastTokenType=tokens[tokens.length-1][0];if(lastTokenType!=='space'&&lastTokenType!=='comment')break;spaces=tokens.pop()[1]+spaces;}return spaces;};_proto.spacesAndCommentsFromStart=function spacesAndCommentsFromStart(tokens){var next;var spaces='';while(tokens.length){next=tokens[0][0];if(next!=='space'&&next!=='comment')break;spaces+=tokens.shift()[1];}return spaces;};_proto.spacesFromEnd=function spacesFromEnd(tokens){var lastTokenType;var spaces='';while(tokens.length){lastTokenType=tokens[tokens.length-1][0];if(lastTokenType!=='space')break;spaces=tokens.pop()[1]+spaces;}return spaces;};_proto.stringFrom=function stringFrom(tokens,from){var result='';for(var i=from;i<tokens.length;i++){result+=tokens[i][1];}tokens.splice(from,tokens.length-from);return result;};_proto.colon=function colon(tokens){var brackets=0;var token,type,prev;for(var i=0;i<tokens.length;i++){token=tokens[i];type=token[0];if(type==='('){brackets+=1;}if(type===')'){brackets-=1;}if(brackets===0&&type===':'){if(!prev){this.doubleColon(token);}else if(prev[0]==='word'&&prev[1]==='progid'){continue;}else{return i;}}prev=token;}return false;}// Errors
;_proto.unclosedBracket=function unclosedBracket(bracket){throw this.input.error('Unclosed bracket',bracket[2],bracket[3]);};_proto.unknownWord=function unknownWord(tokens){throw this.input.error('Unknown word',tokens[0][2],tokens[0][3]);};_proto.unexpectedClose=function unexpectedClose(token){throw this.input.error('Unexpected }',token[2],token[3]);};_proto.unclosedBlock=function unclosedBlock(){var pos=this.current.source.start;throw this.input.error('Unclosed block',pos.line,pos.column);};_proto.doubleColon=function doubleColon(token){throw this.input.error('Double colon',token[2],token[3]);};_proto.unnamedAtrule=function unnamedAtrule(node,token){throw this.input.error('At-rule without name',token[2],token[3]);};_proto.precheckMissedSemicolon=function precheckMissedSemicolon()/* tokens */{// Hook for Safe Parser
};_proto.checkMissedSemicolon=function checkMissedSemicolon(tokens){var colon=this.colon(tokens);if(colon===false)return;var founded=0;var token;for(var j=colon-1;j>=0;j--){token=tokens[j];if(token[0]!=='space'){founded+=1;if(founded===2)break;}}throw this.input.error('Missed semicolon',token[2],token[3]);};return Parser;}();exports["default"]=Parser;module.exports=exports["default"];},{"./at-rule":48,"./comment":49,"./declaration":52,"./root":64,"./rule":65,"./tokenize":68}],60:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _declaration=_interopRequireDefault(require("./declaration"));var _processor=_interopRequireDefault(require("./processor"));var _stringify=_interopRequireDefault(require("./stringify"));var _comment=_interopRequireDefault(require("./comment"));var _atRule=_interopRequireDefault(require("./at-rule"));var _vendor=_interopRequireDefault(require("./vendor"));var _parse=_interopRequireDefault(require("./parse"));var _list=_interopRequireDefault(require("./list"));var _rule=_interopRequireDefault(require("./rule"));var _root=_interopRequireDefault(require("./root"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}/**
 * Create a new {@link Processor} instance that will apply `plugins`
 * as CSS processors.
 *
 * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
 *        See {@link Processor#use} for plugin format.
 *
 * @return {Processor} Processor to process multiple CSS.
 *
 * @example
 * import postcss from 'postcss'
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css)
 * })
 *
 * @namespace postcss
 */function postcss(){for(var _len=arguments.length,plugins=new Array(_len),_key=0;_key<_len;_key++){plugins[_key]=arguments[_key];}if(plugins.length===1&&Array.isArray(plugins[0])){plugins=plugins[0];}return new _processor["default"](plugins);}/**
 * Creates a PostCSS plugin with a standard API.
 *
 * The newly-wrapped function will provide both the name and PostCSS
 * version of the plugin.
 *
 * ```js
 * const processor = postcss([replace])
 * processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
 * processor.plugins[0].postcssVersion //=> '6.0.0'
 * ```
 *
 * The plugin function receives 2 arguments: {@link Root}
 * and {@link Result} instance. The function should mutate the provided
 * `Root` node. Alternatively, you can create a new `Root` node
 * and override the `result.root` property.
 *
 * ```js
 * const cleaner = postcss.plugin('postcss-cleaner', () => {
 *   return (root, result) => {
 *     result.root = postcss.root()
 *   }
 * })
 * ```
 *
 * As a convenience, plugins also expose a `process` method so that you can use
 * them as standalone tools.
 *
 * ```js
 * cleaner.process(css, processOpts, pluginOpts)
 * // This is equivalent to:
 * postcss([ cleaner(pluginOpts) ]).process(css, processOpts)
 * ```
 *
 * Asynchronous plugins should return a `Promise` instance.
 *
 * ```js
 * postcss.plugin('postcss-import', () => {
 *   return (root, result) => {
 *     return new Promise( (resolve, reject) => {
 *       fs.readFile('base.css', (base) => {
 *         root.prepend(base)
 *         resolve()
 *       })
 *     })
 *   }
 * })
 * ```
 *
 * Add warnings using the {@link Node#warn} method.
 * Send data to other plugins using the {@link Result#messages} array.
 *
 * ```js
 * postcss.plugin('postcss-caniuse-test', () => {
 *   return (root, result) => {
 *     root.walkDecls(decl => {
 *       if (!caniuse.support(decl.prop)) {
 *         decl.warn(result, 'Some browsers do not support ' + decl.prop)
 *       }
 *     })
 *   }
 * })
 * ```
 *
 * @param {string} name          PostCSS plugin name. Same as in `name`
 *                               property in `package.json`. It will be saved
 *                               in `plugin.postcssPlugin` property.
 * @param {function} initializer Will receive plugin options
 *                               and should return {@link pluginFunction}
 *
 * @return {Plugin} PostCSS plugin.
 */postcss.plugin=function plugin(name,initializer){function creator(){var transformer=initializer.apply(void 0,arguments);transformer.postcssPlugin=name;transformer.postcssVersion=new _processor["default"]().version;return transformer;}var cache;Object.defineProperty(creator,'postcss',{get:function get(){if(!cache)cache=creator();return cache;}});creator.process=function(css,processOpts,pluginOpts){return postcss([creator(pluginOpts)]).process(css,processOpts);};return creator;};/**
 * Default function to convert a node tree into a CSS string.
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from node’s parts
 *                          or generate string and source map.
 *
 * @return {void}
 *
 * @function
 */postcss.stringify=_stringify["default"];/**
 * Parses source css and returns a new {@link Root} node,
 * which contains the source CSS nodes.
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST.
 *
 * @example
 * // Simple CSS concatenation with source map support
 * const root1 = postcss.parse(css1, { from: file1 })
 * const root2 = postcss.parse(css2, { from: file2 })
 * root1.append(root2).toResult().css
 *
 * @function
 */postcss.parse=_parse["default"];/**
 * Contains the {@link vendor} module.
 *
 * @type {vendor}
 *
 * @example
 * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
 */postcss.vendor=_vendor["default"];/**
 * Contains the {@link list} module.
 *
 * @member {list}
 *
 * @example
 * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
 */postcss.list=_list["default"];/**
 * Creates a new {@link Comment} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Comment} New comment node
 *
 * @example
 * postcss.comment({ text: 'test' })
 */postcss.comment=function(defaults){return new _comment["default"](defaults);};/**
 * Creates a new {@link AtRule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {AtRule} new at-rule node
 *
 * @example
 * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
 */postcss.atRule=function(defaults){return new _atRule["default"](defaults);};/**
 * Creates a new {@link Declaration} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Declaration} new declaration node
 *
 * @example
 * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
 */postcss.decl=function(defaults){return new _declaration["default"](defaults);};/**
 * Creates a new {@link Rule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Rule} new rule node
 *
 * @example
 * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
 */postcss.rule=function(defaults){return new _rule["default"](defaults);};/**
 * Creates a new {@link Root} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Root} new root node.
 *
 * @example
 * postcss.root({ after: '\n' }).toString() //=> "\n"
 */postcss.root=function(defaults){return new _root["default"](defaults);};var _default=postcss;exports["default"]=_default;module.exports=exports["default"];},{"./at-rule":48,"./comment":49,"./declaration":52,"./list":55,"./parse":58,"./processor":62,"./root":64,"./rule":65,"./stringify":67,"./vendor":69}],61:[function(require,module,exports){(function(Buffer){"use strict";exports.__esModule=true;exports["default"]=void 0;var _sourceMap=_interopRequireDefault(require("source-map"));var _path=_interopRequireDefault(require("path"));var _fs=_interopRequireDefault(require("fs"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function fromBase64(str){if(Buffer){return Buffer.from(str,'base64').toString();}else{return window.atob(str);}}/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' })
 * root.input.map //=> PreviousMap
 */var PreviousMap=/*#__PURE__*/function(){/**
   * @param {string}         css    Input CSS source.
   * @param {processOptions} [opts] {@link Processor#process} options.
   */function PreviousMap(css,opts){this.loadAnnotation(css);/**
     * Was source map inlined by data-uri to input CSS.
     *
     * @type {boolean}
     */this.inline=this.startWith(this.annotation,'data:');var prev=opts.map?opts.map.prev:undefined;var text=this.loadMap(opts.from,prev);if(text)this.text=text;}/**
   * Create a instance of `SourceMapGenerator` class
   * from the `source-map` library to work with source map information.
   *
   * It is lazy method, so it will create object only on first call
   * and then it will use cache.
   *
   * @return {SourceMapGenerator} Object with source map information.
   */var _proto=PreviousMap.prototype;_proto.consumer=function consumer(){if(!this.consumerCache){this.consumerCache=new _sourceMap["default"].SourceMapConsumer(this.text);}return this.consumerCache;}/**
   * Does source map contains `sourcesContent` with input source text.
   *
   * @return {boolean} Is `sourcesContent` present.
   */;_proto.withContent=function withContent(){return!!(this.consumer().sourcesContent&&this.consumer().sourcesContent.length>0);};_proto.startWith=function startWith(string,start){if(!string)return false;return string.substr(0,start.length)===start;};_proto.loadAnnotation=function loadAnnotation(css){var match=css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//);if(match)this.annotation=match[1].trim();};_proto.decodeInline=function decodeInline(text){var baseCharsetUri=/^data:application\/json;charset=utf-?8;base64,/;var baseUri=/^data:application\/json;base64,/;var uri='data:application/json,';if(this.startWith(text,uri)){return decodeURIComponent(text.substr(uri.length));}if(baseCharsetUri.test(text)||baseUri.test(text)){return fromBase64(text.substr(RegExp.lastMatch.length));}var encoding=text.match(/data:application\/json;([^,]+),/)[1];throw new Error('Unsupported source map encoding '+encoding);};_proto.loadMap=function loadMap(file,prev){if(prev===false)return false;if(prev){if(typeof prev==='string'){return prev;}else if(typeof prev==='function'){var prevPath=prev(file);if(prevPath&&_fs["default"].existsSync&&_fs["default"].existsSync(prevPath)){return _fs["default"].readFileSync(prevPath,'utf-8').toString().trim();}else{throw new Error('Unable to load previous source map: '+prevPath.toString());}}else if(prev instanceof _sourceMap["default"].SourceMapConsumer){return _sourceMap["default"].SourceMapGenerator.fromSourceMap(prev).toString();}else if(prev instanceof _sourceMap["default"].SourceMapGenerator){return prev.toString();}else if(this.isMap(prev)){return JSON.stringify(prev);}else{throw new Error('Unsupported previous source map format: '+prev.toString());}}else if(this.inline){return this.decodeInline(this.annotation);}else if(this.annotation){var map=this.annotation;if(file)map=_path["default"].join(_path["default"].dirname(file),map);this.root=_path["default"].dirname(map);if(_fs["default"].existsSync&&_fs["default"].existsSync(map)){return _fs["default"].readFileSync(map,'utf-8').toString().trim();}else{return false;}}};_proto.isMap=function isMap(map){if(_typeof(map)!=='object')return false;return typeof map.mappings==='string'||typeof map._mappings==='string';};return PreviousMap;}();var _default=PreviousMap;exports["default"]=_default;module.exports=exports["default"];}).call(this,require("buffer").Buffer);},{"buffer":3,"fs":2,"path":47,"source-map":88}],62:[function(require,module,exports){(function(process){"use strict";exports.__esModule=true;exports["default"]=void 0;var _lazyResult=_interopRequireDefault(require("./lazy-result"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss])
 * processor.process(css1).then(result => console.log(result.css))
 * processor.process(css2).then(result => console.log(result.css))
 */var Processor=/*#__PURE__*/function(){/**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
   *        See {@link Processor#use} for plugin format.
   */function Processor(plugins){if(plugins===void 0){plugins=[];}/**
     * Current PostCSS version.
     *
     * @type {string}
     *
     * @example
     * if (result.processor.version.split('.')[0] !== '6') {
     *   throw new Error('This plugin works only with PostCSS 6')
     * }
     */this.version='7.0.26';/**
     * Plugins added to this processor.
     *
     * @type {pluginFunction[]}
     *
     * @example
     * const processor = postcss([autoprefixer, precss])
     * processor.plugins.length //=> 2
     */this.plugins=this.normalize(plugins);}/**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin PostCSS plugin
   *                                                 or {@link Processor}
   *                                                 with plugins.
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss)
   *
   * @return {Processes} Current processor to make methods chain.
   */var _proto=Processor.prototype;_proto.use=function use(plugin){this.plugins=this.plugins.concat(this.normalize([plugin]));return this;}/**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesn’t make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css String with input CSS or any object
   *                                     with a `toString()` method,
   *                                     like a Buffer. Optionally, send
   *                                     a {@link Result} instance
   *                                     and the processor will take
   *                                     the {@link Root} from it.
   * @param {processOptions} [opts]      Options.
   *
   * @return {LazyResult} Promise proxy.
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css)
   *   })
   */;_proto.process=function(_process){function process(_x){return _process.apply(this,arguments);}process.toString=function(){return _process.toString();};return process;}(function(css,opts){if(opts===void 0){opts={};}if(this.plugins.length===0&&opts.parser===opts.stringifier){if(process.env.NODE_ENV!=='production'){if(typeof console!=='undefined'&&console.warn){console.warn('You did not set any plugins, parser, or stringifier. '+'Right now, PostCSS does nothing. Pick plugins for your case '+'on https://www.postcss.parts/ and use them in postcss.config.js.');}}}return new _lazyResult["default"](this,css,opts);});_proto.normalize=function normalize(plugins){var normalized=[];for(var _iterator=plugins,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var i=_ref;if(i.postcss)i=i.postcss;if(_typeof(i)==='object'&&Array.isArray(i.plugins)){normalized=normalized.concat(i.plugins);}else if(typeof i==='function'){normalized.push(i);}else if(_typeof(i)==='object'&&(i.parse||i.stringify)){if(process.env.NODE_ENV!=='production'){throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use '+'one of the syntax/parser/stringifier options as outlined '+'in your PostCSS runner documentation.');}}else{throw new Error(i+' is not a PostCSS plugin');}}return normalized;};return Processor;}();var _default=Processor;/**
 * @callback builder
 * @param {string} part          Part of generated CSS connected to this node.
 * @param {Node}   node          AST node.
 * @param {"start"|"end"} [type] Node’s part type.
 */ /**
 * @callback parser
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer.
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST
 */ /**
 * @callback stringifier
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from node’s parts
 *                          or generate string and source map.
 *
 * @return {void}
 */ /**
 * @typedef {object} syntax
 * @property {parser} parse          Function to generate AST by string.
 * @property {stringifier} stringify Function to generate string by AST.
 */ /**
 * @typedef {object} toString
 * @property {function} toString
 */ /**
 * @callback pluginFunction
 * @param {Root} root     Parsed input CSS.
 * @param {Result} result Result to set warnings or check other plugins.
 */ /**
 * @typedef {object} Plugin
 * @property {function} postcss PostCSS plugin function.
 */ /**
 * @typedef {object} processOptions
 * @property {string} from             The path of the CSS source file.
 *                                     You should always set `from`,
 *                                     because it is used in source map
 *                                     generation and syntax error messages.
 * @property {string} to               The path where you’ll put the output
 *                                     CSS file. You should always set `to`
 *                                     to generate correct source maps.
 * @property {parser} parser           Function to generate AST by string.
 * @property {stringifier} stringifier Class to generate string by AST.
 * @property {syntax} syntax           Object with `parse` and `stringify`.
 * @property {object} map              Source map options.
 * @property {boolean} map.inline                    Does source map should
 *                                                   be embedded in the output
 *                                                   CSS as a base64-encoded
 *                                                   comment.
 * @property {string|object|false|function} map.prev Source map content
 *                                                   from a previous
 *                                                   processing step
 *                                                   (for example, Sass).
 *                                                   PostCSS will try to find
 *                                                   previous map automatically,
 *                                                   so you could disable it by
 *                                                   `false` value.
 * @property {boolean} map.sourcesContent            Does PostCSS should set
 *                                                   the origin content to map.
 * @property {string|false} map.annotation           Does PostCSS should set
 *                                                   annotation comment to map.
 * @property {string} map.from                       Override `from` in map’s
 *                                                   sources`.
 */exports["default"]=_default;module.exports=exports["default"];}).call(this,require('_process'));},{"./lazy-result":54,"_process":72}],63:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _warning=_interopRequireDefault(require("./warning"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}/**
 * Provides the result of the PostCSS transformations.
 *
 * A Result instance is returned by {@link LazyResult#then}
 * or {@link Root#toResult} methods.
 *
 * @example
 * postcss([autoprefixer]).process(css).then(result => {
 *  console.log(result.css)
 * })
 *
 * @example
 * const result2 = postcss.parse(css).toResult()
 */var Result=/*#__PURE__*/function(){/**
   * @param {Processor} processor Processor used for this transformation.
   * @param {Root}      root      Root node after all transformations.
   * @param {processOptions} opts Options from the {@link Processor#process}
   *                              or {@link Root#toResult}.
   */function Result(processor,root,opts){/**
     * The Processor instance used for this transformation.
     *
     * @type {Processor}
     *
     * @example
     * for (const plugin of result.processor.plugins) {
     *   if (plugin.postcssPlugin === 'postcss-bad') {
     *     throw 'postcss-good is incompatible with postcss-bad'
     *   }
     * })
     */this.processor=processor;/**
     * Contains messages from plugins (e.g., warnings or custom messages).
     * Each message should have type and plugin properties.
     *
     * @type {Message[]}
     *
     * @example
     * postcss.plugin('postcss-min-browser', () => {
     *   return (root, result) => {
     *     const browsers = detectMinBrowsersByCanIUse(root)
     *     result.messages.push({
     *       type: 'min-browser',
     *       plugin: 'postcss-min-browser',
     *       browsers
     *     })
     *   }
     * })
     */this.messages=[];/**
     * Root node after all transformations.
     *
     * @type {Root}
     *
     * @example
     * root.toResult().root === root
     */this.root=root;/**
     * Options from the {@link Processor#process} or {@link Root#toResult} call
     * that produced this Result instance.
     *
     * @type {processOptions}
     *
     * @example
     * root.toResult(opts).opts === opts
     */this.opts=opts;/**
     * A CSS string representing of {@link Result#root}.
     *
     * @type {string}
     *
     * @example
     * postcss.parse('a{}').toResult().css //=> "a{}"
     */this.css=undefined;/**
     * An instance of `SourceMapGenerator` class from the `source-map` library,
     * representing changes to the {@link Result#root} instance.
     *
     * @type {SourceMapGenerator}
     *
     * @example
     * result.map.toJSON() //=> { version: 3, file: 'a.css', … }
     *
     * @example
     * if (result.map) {
     *   fs.writeFileSync(result.opts.to + '.map', result.map.toString())
     * }
     */this.map=undefined;}/**
   * Returns for @{link Result#css} content.
   *
   * @example
   * result + '' === result.css
   *
   * @return {string} String representing of {@link Result#root}.
   */var _proto=Result.prototype;_proto.toString=function toString(){return this.css;}/**
   * Creates an instance of {@link Warning} and adds it
   * to {@link Result#messages}.
   *
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   *
   * @return {Warning} Created warning.
   */;_proto.warn=function warn(text,opts){if(opts===void 0){opts={};}if(!opts.plugin){if(this.lastPlugin&&this.lastPlugin.postcssPlugin){opts.plugin=this.lastPlugin.postcssPlugin;}}var warning=new _warning["default"](text,opts);this.messages.push(warning);return warning;}/**
     * Returns warnings from plugins. Filters {@link Warning} instances
     * from {@link Result#messages}.
     *
     * @example
     * result.warnings().forEach(warn => {
     *   console.warn(warn.toString())
     * })
     *
     * @return {Warning[]} Warnings from plugins.
     */;_proto.warnings=function warnings(){return this.messages.filter(function(i){return i.type==='warning';});}/**
   * An alias for the {@link Result#css} property.
   * Use it with syntaxes that generate non-CSS output.
   *
   * @type {string}
   *
   * @example
   * result.css === result.content
   */;_createClass(Result,[{key:"content",get:function get(){return this.css;}}]);return Result;}();var _default=Result;/**
 * @typedef  {object} Message
 * @property {string} type   Message type.
 * @property {string} plugin Source PostCSS plugin name.
 */exports["default"]=_default;module.exports=exports["default"];},{"./warning":71}],64:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _container=_interopRequireDefault(require("./container"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents a CSS file and contains all its parsed nodes.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{color:black} b{z-index:2}')
 * root.type         //=> 'root'
 * root.nodes.length //=> 2
 */var Root=/*#__PURE__*/function(_Container){_inheritsLoose(Root,_Container);function Root(defaults){var _this;_this=_Container.call(this,defaults)||this;_this.type='root';if(!_this.nodes)_this.nodes=[];return _this;}var _proto=Root.prototype;_proto.removeChild=function removeChild(child,ignore){var index=this.index(child);if(!ignore&&index===0&&this.nodes.length>1){this.nodes[1].raws.before=this.nodes[index].raws.before;}return _Container.prototype.removeChild.call(this,child);};_proto.normalize=function normalize(child,sample,type){var nodes=_Container.prototype.normalize.call(this,child);if(sample){if(type==='prepend'){if(this.nodes.length>1){sample.raws.before=this.nodes[1].raws.before;}else{delete sample.raws.before;}}else if(this.first!==sample){for(var _iterator=nodes,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var node=_ref;node.raws.before=sample.raws.before;}}}return nodes;}/**
   * Returns a {@link Result} instance representing the root’s CSS.
   *
   * @param {processOptions} [opts] Options with only `to` and `map` keys.
   *
   * @return {Result} Result with current root’s CSS.
   *
   * @example
   * const root1 = postcss.parse(css1, { from: 'a.css' })
   * const root2 = postcss.parse(css2, { from: 'b.css' })
   * root1.append(root2)
   * const result = root1.toResult({ to: 'all.css', map: true })
   */;_proto.toResult=function toResult(opts){if(opts===void 0){opts={};}var LazyResult=require('./lazy-result');var Processor=require('./processor');var lazy=new LazyResult(new Processor(),this,opts);return lazy.stringify();}/**
   * @memberof Root#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `after`: the space symbols after the last child to the end of file.
   * * `semicolon`: is the last child has an (optional) semicolon.
   *
   * @example
   * postcss.parse('a {}\n').raws //=> { after: '\n' }
   * postcss.parse('a {}').raws   //=> { after: '' }
   */;return Root;}(_container["default"]);var _default=Root;exports["default"]=_default;module.exports=exports["default"];},{"./container":50,"./lazy-result":54,"./processor":62}],65:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _container=_interopRequireDefault(require("./container"));var _list=_interopRequireDefault(require("./list"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents a CSS rule: a selector followed by a declaration block.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{}')
 * const rule = root.first
 * rule.type       //=> 'rule'
 * rule.toString() //=> 'a{}'
 */var Rule=/*#__PURE__*/function(_Container){_inheritsLoose(Rule,_Container);function Rule(defaults){var _this;_this=_Container.call(this,defaults)||this;_this.type='rule';if(!_this.nodes)_this.nodes=[];return _this;}/**
   * An array containing the rule’s individual selectors.
   * Groups of selectors are split at commas.
   *
   * @type {string[]}
   *
   * @example
   * const root = postcss.parse('a, b { }')
   * const rule = root.first
   *
   * rule.selector  //=> 'a, b'
   * rule.selectors //=> ['a', 'b']
   *
   * rule.selectors = ['a', 'strong']
   * rule.selector //=> 'a, strong'
   */_createClass(Rule,[{key:"selectors",get:function get(){return _list["default"].comma(this.selector);},set:function set(values){var match=this.selector?this.selector.match(/,\s*/):null;var sep=match?match[0]:','+this.raw('between','beforeOpen');this.selector=values.join(sep);}/**
     * @memberof Rule#
     * @member {string} selector The rule’s full selector represented
     *                           as a string.
     *
     * @example
     * const root = postcss.parse('a, b { }')
     * const rule = root.first
     * rule.selector //=> 'a, b'
     */ /**
     * @memberof Rule#
     * @member {object} raws Information to generate byte-to-byte equal
     *                       node string as it was in the origin input.
     *
     * Every parser saves its own properties,
     * but the default CSS parser uses:
     *
     * * `before`: the space symbols before the node. It also stores `*`
     *   and `_` symbols before the declaration (IE hack).
     * * `after`: the space symbols after the last child of the node
     *   to the end of the node.
     * * `between`: the symbols between the property and value
     *   for declarations, selector and `{` for rules, or last parameter
     *   and `{` for at-rules.
     * * `semicolon`: contains `true` if the last child has
     *   an (optional) semicolon.
     * * `ownSemicolon`: contains `true` if there is semicolon after rule.
     *
     * PostCSS cleans selectors from comments and extra spaces,
     * but it stores origin content in raws properties.
     * As such, if you don’t change a declaration’s value,
     * PostCSS will use the raw value with comments.
     *
     * @example
     * const root = postcss.parse('a {\n  color:black\n}')
     * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
     */}]);return Rule;}(_container["default"]);var _default=Rule;exports["default"]=_default;module.exports=exports["default"];},{"./container":50,"./list":55}],66:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var DEFAULT_RAW={colon:': ',indent:'    ',beforeDecl:'\n',beforeRule:'\n',beforeOpen:' ',beforeClose:'\n',beforeComment:'\n',after:'\n',emptyBody:'',commentLeft:' ',commentRight:' ',semicolon:false};function capitalize(str){return str[0].toUpperCase()+str.slice(1);}var Stringifier=/*#__PURE__*/function(){function Stringifier(builder){this.builder=builder;}var _proto=Stringifier.prototype;_proto.stringify=function stringify(node,semicolon){this[node.type](node,semicolon);};_proto.root=function root(node){this.body(node);if(node.raws.after)this.builder(node.raws.after);};_proto.comment=function comment(node){var left=this.raw(node,'left','commentLeft');var right=this.raw(node,'right','commentRight');this.builder('/*'+left+node.text+right+'*/',node);};_proto.decl=function decl(node,semicolon){var between=this.raw(node,'between','colon');var string=node.prop+between+this.rawValue(node,'value');if(node.important){string+=node.raws.important||' !important';}if(semicolon)string+=';';this.builder(string,node);};_proto.rule=function rule(node){this.block(node,this.rawValue(node,'selector'));if(node.raws.ownSemicolon){this.builder(node.raws.ownSemicolon,node,'end');}};_proto.atrule=function atrule(node,semicolon){var name='@'+node.name;var params=node.params?this.rawValue(node,'params'):'';if(typeof node.raws.afterName!=='undefined'){name+=node.raws.afterName;}else if(params){name+=' ';}if(node.nodes){this.block(node,name+params);}else{var end=(node.raws.between||'')+(semicolon?';':'');this.builder(name+params+end,node);}};_proto.body=function body(node){var last=node.nodes.length-1;while(last>0){if(node.nodes[last].type!=='comment')break;last-=1;}var semicolon=this.raw(node,'semicolon');for(var i=0;i<node.nodes.length;i++){var child=node.nodes[i];var before=this.raw(child,'before');if(before)this.builder(before);this.stringify(child,last!==i||semicolon);}};_proto.block=function block(node,start){var between=this.raw(node,'between','beforeOpen');this.builder(start+between+'{',node,'start');var after;if(node.nodes&&node.nodes.length){this.body(node);after=this.raw(node,'after');}else{after=this.raw(node,'after','emptyBody');}if(after)this.builder(after);this.builder('}',node,'end');};_proto.raw=function raw(node,own,detect){var value;if(!detect)detect=own;// Already had
if(own){value=node.raws[own];if(typeof value!=='undefined')return value;}var parent=node.parent;// Hack for first rule in CSS
if(detect==='before'){if(!parent||parent.type==='root'&&parent.first===node){return'';}}// Floating child without parent
if(!parent)return DEFAULT_RAW[detect];// Detect style by other nodes
var root=node.root();if(!root.rawCache)root.rawCache={};if(typeof root.rawCache[detect]!=='undefined'){return root.rawCache[detect];}if(detect==='before'||detect==='after'){return this.beforeAfter(node,detect);}else{var method='raw'+capitalize(detect);if(this[method]){value=this[method](root,node);}else{root.walk(function(i){value=i.raws[own];if(typeof value!=='undefined')return false;});}}if(typeof value==='undefined')value=DEFAULT_RAW[detect];root.rawCache[detect]=value;return value;};_proto.rawSemicolon=function rawSemicolon(root){var value;root.walk(function(i){if(i.nodes&&i.nodes.length&&i.last.type==='decl'){value=i.raws.semicolon;if(typeof value!=='undefined')return false;}});return value;};_proto.rawEmptyBody=function rawEmptyBody(root){var value;root.walk(function(i){if(i.nodes&&i.nodes.length===0){value=i.raws.after;if(typeof value!=='undefined')return false;}});return value;};_proto.rawIndent=function rawIndent(root){if(root.raws.indent)return root.raws.indent;var value;root.walk(function(i){var p=i.parent;if(p&&p!==root&&p.parent&&p.parent===root){if(typeof i.raws.before!=='undefined'){var parts=i.raws.before.split('\n');value=parts[parts.length-1];value=value.replace(/[^\s]/g,'');return false;}}});return value;};_proto.rawBeforeComment=function rawBeforeComment(root,node){var value;root.walkComments(function(i){if(typeof i.raws.before!=='undefined'){value=i.raws.before;if(value.indexOf('\n')!==-1){value=value.replace(/[^\n]+$/,'');}return false;}});if(typeof value==='undefined'){value=this.raw(node,null,'beforeDecl');}else if(value){value=value.replace(/[^\s]/g,'');}return value;};_proto.rawBeforeDecl=function rawBeforeDecl(root,node){var value;root.walkDecls(function(i){if(typeof i.raws.before!=='undefined'){value=i.raws.before;if(value.indexOf('\n')!==-1){value=value.replace(/[^\n]+$/,'');}return false;}});if(typeof value==='undefined'){value=this.raw(node,null,'beforeRule');}else if(value){value=value.replace(/[^\s]/g,'');}return value;};_proto.rawBeforeRule=function rawBeforeRule(root){var value;root.walk(function(i){if(i.nodes&&(i.parent!==root||root.first!==i)){if(typeof i.raws.before!=='undefined'){value=i.raws.before;if(value.indexOf('\n')!==-1){value=value.replace(/[^\n]+$/,'');}return false;}}});if(value)value=value.replace(/[^\s]/g,'');return value;};_proto.rawBeforeClose=function rawBeforeClose(root){var value;root.walk(function(i){if(i.nodes&&i.nodes.length>0){if(typeof i.raws.after!=='undefined'){value=i.raws.after;if(value.indexOf('\n')!==-1){value=value.replace(/[^\n]+$/,'');}return false;}}});if(value)value=value.replace(/[^\s]/g,'');return value;};_proto.rawBeforeOpen=function rawBeforeOpen(root){var value;root.walk(function(i){if(i.type!=='decl'){value=i.raws.between;if(typeof value!=='undefined')return false;}});return value;};_proto.rawColon=function rawColon(root){var value;root.walkDecls(function(i){if(typeof i.raws.between!=='undefined'){value=i.raws.between.replace(/[^\s:]/g,'');return false;}});return value;};_proto.beforeAfter=function beforeAfter(node,detect){var value;if(node.type==='decl'){value=this.raw(node,null,'beforeDecl');}else if(node.type==='comment'){value=this.raw(node,null,'beforeComment');}else if(detect==='before'){value=this.raw(node,null,'beforeRule');}else{value=this.raw(node,null,'beforeClose');}var buf=node.parent;var depth=0;while(buf&&buf.type!=='root'){depth+=1;buf=buf.parent;}if(value.indexOf('\n')!==-1){var indent=this.raw(node,null,'indent');if(indent.length){for(var step=0;step<depth;step++){value+=indent;}}}return value;};_proto.rawValue=function rawValue(node,prop){var value=node[prop];var raw=node.raws[prop];if(raw&&raw.value===value){return raw.raw;}return value;};return Stringifier;}();var _default=Stringifier;exports["default"]=_default;module.exports=exports["default"];},{}],67:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _stringifier=_interopRequireDefault(require("./stringifier"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function stringify(node,builder){var str=new _stringifier["default"](builder);str.stringify(node);}var _default=stringify;exports["default"]=_default;module.exports=exports["default"];},{"./stringifier":66}],68:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=tokenizer;var SINGLE_QUOTE='\''.charCodeAt(0);var DOUBLE_QUOTE='"'.charCodeAt(0);var BACKSLASH='\\'.charCodeAt(0);var SLASH='/'.charCodeAt(0);var NEWLINE='\n'.charCodeAt(0);var SPACE=' '.charCodeAt(0);var FEED='\f'.charCodeAt(0);var TAB='\t'.charCodeAt(0);var CR='\r'.charCodeAt(0);var OPEN_SQUARE='['.charCodeAt(0);var CLOSE_SQUARE=']'.charCodeAt(0);var OPEN_PARENTHESES='('.charCodeAt(0);var CLOSE_PARENTHESES=')'.charCodeAt(0);var OPEN_CURLY='{'.charCodeAt(0);var CLOSE_CURLY='}'.charCodeAt(0);var SEMICOLON=';'.charCodeAt(0);var ASTERISK='*'.charCodeAt(0);var COLON=':'.charCodeAt(0);var AT='@'.charCodeAt(0);var RE_AT_END=/[ \n\t\r\f{}()'"\\;/[\]#]/g;var RE_WORD_END=/[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g;var RE_BAD_BRACKET=/.[\\/("'\n]/;var RE_HEX_ESCAPE=/[a-f0-9]/i;function tokenizer(input,options){if(options===void 0){options={};}var css=input.css.valueOf();var ignore=options.ignoreErrors;var code,next,quote,lines,last,content,escape;var nextLine,nextOffset,escaped,escapePos,prev,n,currentToken;var length=css.length;var offset=-1;var line=1;var pos=0;var buffer=[];var returned=[];function position(){return pos;}function unclosed(what){throw input.error('Unclosed '+what,line,pos-offset);}function endOfFile(){return returned.length===0&&pos>=length;}function nextToken(opts){if(returned.length)return returned.pop();if(pos>=length)return;var ignoreUnclosed=opts?opts.ignoreUnclosed:false;code=css.charCodeAt(pos);if(code===NEWLINE||code===FEED||code===CR&&css.charCodeAt(pos+1)!==NEWLINE){offset=pos;line+=1;}switch(code){case NEWLINE:case SPACE:case TAB:case CR:case FEED:next=pos;do{next+=1;code=css.charCodeAt(next);if(code===NEWLINE){offset=next;line+=1;}}while(code===SPACE||code===NEWLINE||code===TAB||code===CR||code===FEED);currentToken=['space',css.slice(pos,next)];pos=next-1;break;case OPEN_SQUARE:case CLOSE_SQUARE:case OPEN_CURLY:case CLOSE_CURLY:case COLON:case SEMICOLON:case CLOSE_PARENTHESES:var controlChar=String.fromCharCode(code);currentToken=[controlChar,controlChar,line,pos-offset];break;case OPEN_PARENTHESES:prev=buffer.length?buffer.pop()[1]:'';n=css.charCodeAt(pos+1);if(prev==='url'&&n!==SINGLE_QUOTE&&n!==DOUBLE_QUOTE&&n!==SPACE&&n!==NEWLINE&&n!==TAB&&n!==FEED&&n!==CR){next=pos;do{escaped=false;next=css.indexOf(')',next+1);if(next===-1){if(ignore||ignoreUnclosed){next=pos;break;}else{unclosed('bracket');}}escapePos=next;while(css.charCodeAt(escapePos-1)===BACKSLASH){escapePos-=1;escaped=!escaped;}}while(escaped);currentToken=['brackets',css.slice(pos,next+1),line,pos-offset,line,next-offset];pos=next;}else{next=css.indexOf(')',pos+1);content=css.slice(pos,next+1);if(next===-1||RE_BAD_BRACKET.test(content)){currentToken=['(','(',line,pos-offset];}else{currentToken=['brackets',content,line,pos-offset,line,next-offset];pos=next;}}break;case SINGLE_QUOTE:case DOUBLE_QUOTE:quote=code===SINGLE_QUOTE?'\'':'"';next=pos;do{escaped=false;next=css.indexOf(quote,next+1);if(next===-1){if(ignore||ignoreUnclosed){next=pos+1;break;}else{unclosed('string');}}escapePos=next;while(css.charCodeAt(escapePos-1)===BACKSLASH){escapePos-=1;escaped=!escaped;}}while(escaped);content=css.slice(pos,next+1);lines=content.split('\n');last=lines.length-1;if(last>0){nextLine=line+last;nextOffset=next-lines[last].length;}else{nextLine=line;nextOffset=offset;}currentToken=['string',css.slice(pos,next+1),line,pos-offset,nextLine,next-nextOffset];offset=nextOffset;line=nextLine;pos=next;break;case AT:RE_AT_END.lastIndex=pos+1;RE_AT_END.test(css);if(RE_AT_END.lastIndex===0){next=css.length-1;}else{next=RE_AT_END.lastIndex-2;}currentToken=['at-word',css.slice(pos,next+1),line,pos-offset,line,next-offset];pos=next;break;case BACKSLASH:next=pos;escape=true;while(css.charCodeAt(next+1)===BACKSLASH){next+=1;escape=!escape;}code=css.charCodeAt(next+1);if(escape&&code!==SLASH&&code!==SPACE&&code!==NEWLINE&&code!==TAB&&code!==CR&&code!==FEED){next+=1;if(RE_HEX_ESCAPE.test(css.charAt(next))){while(RE_HEX_ESCAPE.test(css.charAt(next+1))){next+=1;}if(css.charCodeAt(next+1)===SPACE){next+=1;}}}currentToken=['word',css.slice(pos,next+1),line,pos-offset,line,next-offset];pos=next;break;default:if(code===SLASH&&css.charCodeAt(pos+1)===ASTERISK){next=css.indexOf('*/',pos+2)+1;if(next===0){if(ignore||ignoreUnclosed){next=css.length;}else{unclosed('comment');}}content=css.slice(pos,next+1);lines=content.split('\n');last=lines.length-1;if(last>0){nextLine=line+last;nextOffset=next-lines[last].length;}else{nextLine=line;nextOffset=offset;}currentToken=['comment',content,line,pos-offset,nextLine,next-nextOffset];offset=nextOffset;line=nextLine;pos=next;}else{RE_WORD_END.lastIndex=pos+1;RE_WORD_END.test(css);if(RE_WORD_END.lastIndex===0){next=css.length-1;}else{next=RE_WORD_END.lastIndex-2;}currentToken=['word',css.slice(pos,next+1),line,pos-offset,line,next-offset];buffer.push(currentToken);pos=next;}break;}pos++;return currentToken;}function back(token){returned.push(token);}return{back:back,nextToken:nextToken,endOfFile:endOfFile,position:position};}module.exports=exports["default"];},{}],69:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;/**
 * Contains helpers for working with vendor prefixes.
 *
 * @example
 * const vendor = postcss.vendor
 *
 * @namespace vendor
 */var vendor={/**
   * Returns the vendor prefix extracted from an input string.
   *
   * @param {string} prop String with or without vendor prefix.
   *
   * @return {string} vendor prefix or empty string
   *
   * @example
   * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
   * postcss.vendor.prefix('tab-size')      //=> ''
   */prefix:function prefix(prop){var match=prop.match(/^(-\w+-)/);if(match){return match[0];}return'';},/**
     * Returns the input string stripped of its vendor prefix.
     *
     * @param {string} prop String with or without vendor prefix.
     *
     * @return {string} String name without vendor prefixes.
     *
     * @example
     * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
     */unprefixed:function unprefixed(prop){return prop.replace(/^-\w+-/,'');}};var _default=vendor;exports["default"]=_default;module.exports=exports["default"];},{}],70:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=warnOnce;var printed={};function warnOnce(message){if(printed[message])return;printed[message]=true;if(typeof console!=='undefined'&&console.warn){console.warn(message);}}module.exports=exports["default"];},{}],71:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;/**
 * Represents a plugin’s warning. It can be created using {@link Node#warn}.
 *
 * @example
 * if (decl.important) {
 *   decl.warn(result, 'Avoid !important', { word: '!important' })
 * }
 */var Warning=/*#__PURE__*/function(){/**
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   */function Warning(text,opts){if(opts===void 0){opts={};}/**
     * Type to filter warnings from {@link Result#messages}.
     * Always equal to `"warning"`.
     *
     * @type {string}
     *
     * @example
     * const nonWarning = result.messages.filter(i => i.type !== 'warning')
     */this.type='warning';/**
     * The warning message.
     *
     * @type {string}
     *
     * @example
     * warning.text //=> 'Try to avoid !important'
     */this.text=text;if(opts.node&&opts.node.source){var pos=opts.node.positionBy(opts);/**
       * Line in the input file with this warning’s source.
       * @type {number}
       *
       * @example
       * warning.line //=> 5
       */this.line=pos.line;/**
       * Column in the input file with this warning’s source.
       *
       * @type {number}
       *
       * @example
       * warning.column //=> 6
       */this.column=pos.column;}for(var opt in opts){this[opt]=opts[opt];}}/**
   * Returns a warning position and message.
   *
   * @example
   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
   *
   * @return {string} Warning position and message.
   */var _proto=Warning.prototype;_proto.toString=function toString(){if(this.node){return this.node.error(this.text,{plugin:this.plugin,index:this.index,word:this.word}).message;}if(this.plugin){return this.plugin+': '+this.text;}return this.text;}/**
   * @memberof Warning#
   * @member {string} plugin The name of the plugin that created
   *                         it will fill this property automatically.
   *                         this warning. When you call {@link Node#warn}
   *
   * @example
   * warning.plugin //=> 'postcss-important'
   */ /**
   * @memberof Warning#
   * @member {Node} node Contains the CSS node that caused the warning.
   *
   * @example
   * warning.node.toString() //=> 'color: white !important'
   */;return Warning;}();var _default=Warning;exports["default"]=_default;module.exports=exports["default"];},{}],72:[function(require,module,exports){// shim for using process in browser
var process=module.exports={};// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error('setTimeout has not been defined');}function defaultClearTimeout(){throw new Error('clearTimeout has not been defined');}(function(){try{if(typeof setTimeout==='function'){cachedSetTimeout=setTimeout;}else{cachedSetTimeout=defaultSetTimout;}}catch(e){cachedSetTimeout=defaultSetTimout;}try{if(typeof clearTimeout==='function'){cachedClearTimeout=clearTimeout;}else{cachedClearTimeout=defaultClearTimeout;}}catch(e){cachedClearTimeout=defaultClearTimeout;}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){//normal enviroments in sane situations
return setTimeout(fun,0);}// if setTimeout wasn't available but was latter defined
if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedSetTimeout(fun,0);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
return cachedSetTimeout.call(null,fun,0);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
return cachedSetTimeout.call(this,fun,0);}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){//normal enviroments in sane situations
return clearTimeout(marker);}// if clearTimeout wasn't available but was latter defined
if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedClearTimeout(marker);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
return cachedClearTimeout.call(null,marker);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
// Some versions of I.E. have different rules for clearTimeout vs setTimeout
return cachedClearTimeout.call(this,marker);}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return;}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue);}else{queueIndex=-1;}if(queue.length){drainQueue();}}function drainQueue(){if(draining){return;}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run();}}queueIndex=-1;len=queue.length;}currentQueue=null;draining=false;runClearTimeout(timeout);}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue);}};// v8 likes predictible objects
function Item(fun,array){this.fun=fun;this.array=array;}Item.prototype.run=function(){this.fun.apply(null,this.array);};process.title='browser';process.browser=true;process.env={};process.argv=[];process.version='';// empty string to avoid regexp issues
process.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(name){return[];};process.binding=function(name){throw new Error('process.binding is not supported');};process.cwd=function(){return'/';};process.chdir=function(dir){throw new Error('process.chdir is not supported');};process.umask=function(){return 0;};},{}],73:[function(require,module,exports){(function(global){/*! https://mths.be/punycode v1.4.1 by @mathias */;(function(root){/** Detect free variables */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;var freeModule=_typeof(module)=='object'&&module&&!module.nodeType&&module;var freeGlobal=_typeof(global)=='object'&&global;if(freeGlobal.global===freeGlobal||freeGlobal.window===freeGlobal||freeGlobal.self===freeGlobal){root=freeGlobal;}/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */var punycode,/** Highest positive signed 32-bit float value */maxInt=2147483647,// aka. 0x7FFFFFFF or 2^31-1
/** Bootstring parameters */base=36,tMin=1,tMax=26,skew=38,damp=700,initialBias=72,initialN=128,// 0x80
delimiter='-',// '\x2D'
/** Regular expressions */regexPunycode=/^xn--/,regexNonASCII=/[^\x20-\x7E]/,// unprintable ASCII chars + non-ASCII chars
regexSeparators=/[\x2E\u3002\uFF0E\uFF61]/g,// RFC 3490 separators
/** Error messages */errors={'overflow':'Overflow: input needs wider integers to process','not-basic':'Illegal input >= 0x80 (not a basic code point)','invalid-input':'Invalid input'},/** Convenience shortcuts */baseMinusTMin=base-tMin,floor=Math.floor,stringFromCharCode=String.fromCharCode,/** Temporary variable */key;/*--------------------------------------------------------------------------*/ /**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */function error(type){throw new RangeError(errors[type]);}/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */function map(array,fn){var length=array.length;var result=[];while(length--){result[length]=fn(array[length]);}return result;}/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */function mapDomain(string,fn){var parts=string.split('@');var result='';if(parts.length>1){// In email addresses, only the domain name should be punycoded. Leave
// the local part (i.e. everything up to `@`) intact.
result=parts[0]+'@';string=parts[1];}// Avoid `split(regex)` for IE8 compatibility. See #17.
string=string.replace(regexSeparators,'\x2E');var labels=string.split('.');var encoded=map(labels,fn).join('.');return result+encoded;}/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */function ucs2decode(string){var output=[],counter=0,length=string.length,value,extra;while(counter<length){value=string.charCodeAt(counter++);if(value>=0xD800&&value<=0xDBFF&&counter<length){// high surrogate, and there is a next character
extra=string.charCodeAt(counter++);if((extra&0xFC00)==0xDC00){// low surrogate
output.push(((value&0x3FF)<<10)+(extra&0x3FF)+0x10000);}else{// unmatched surrogate; only append this code unit, in case the next
// code unit is the high surrogate of a surrogate pair
output.push(value);counter--;}}else{output.push(value);}}return output;}/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */function ucs2encode(array){return map(array,function(value){var output='';if(value>0xFFFF){value-=0x10000;output+=stringFromCharCode(value>>>10&0x3FF|0xD800);value=0xDC00|value&0x3FF;}output+=stringFromCharCode(value);return output;}).join('');}/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */function basicToDigit(codePoint){if(codePoint-48<10){return codePoint-22;}if(codePoint-65<26){return codePoint-65;}if(codePoint-97<26){return codePoint-97;}return base;}/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */function digitToBasic(digit,flag){//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return digit+22+75*(digit<26)-((flag!=0)<<5);}/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */function adapt(delta,numPoints,firstTime){var k=0;delta=firstTime?floor(delta/damp):delta>>1;delta+=floor(delta/numPoints);for(;/* no initialization */delta>baseMinusTMin*tMax>>1;k+=base){delta=floor(delta/baseMinusTMin);}return floor(k+(baseMinusTMin+1)*delta/(delta+skew));}/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */function decode(input){// Don't use UCS-2
var output=[],inputLength=input.length,out,i=0,n=initialN,bias=initialBias,basic,j,index,oldi,w,k,digit,t,/** Cached calculation results */baseMinusT;// Handle the basic code points: let `basic` be the number of input code
// points before the last delimiter, or `0` if there is none, then copy
// the first basic code points to the output.
basic=input.lastIndexOf(delimiter);if(basic<0){basic=0;}for(j=0;j<basic;++j){// if it's not a basic code point
if(input.charCodeAt(j)>=0x80){error('not-basic');}output.push(input.charCodeAt(j));}// Main decoding loop: start just after the last delimiter if any basic code
// points were copied; start at the beginning otherwise.
for(index=basic>0?basic+1:0;index<inputLength;)/* no final expression */{// `index` is the index of the next character to be consumed.
// Decode a generalized variable-length integer into `delta`,
// which gets added to `i`. The overflow checking is easier
// if we increase `i` as we go, then subtract off its starting
// value at the end to obtain `delta`.
for(oldi=i,w=1,k=base;;/* no condition */k+=base){if(index>=inputLength){error('invalid-input');}digit=basicToDigit(input.charCodeAt(index++));if(digit>=base||digit>floor((maxInt-i)/w)){error('overflow');}i+=digit*w;t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(digit<t){break;}baseMinusT=base-t;if(w>floor(maxInt/baseMinusT)){error('overflow');}w*=baseMinusT;}out=output.length+1;bias=adapt(i-oldi,out,oldi==0);// `i` was supposed to wrap around from `out` to `0`,
// incrementing `n` each time, so we'll fix that now:
if(floor(i/out)>maxInt-n){error('overflow');}n+=floor(i/out);i%=out;// Insert `n` at position `i` of the output
output.splice(i++,0,n);}return ucs2encode(output);}/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */function encode(input){var n,delta,handledCPCount,basicLength,bias,j,m,q,k,t,currentValue,output=[],/** `inputLength` will hold the number of code points in `input`. */inputLength,/** Cached calculation results */handledCPCountPlusOne,baseMinusT,qMinusT;// Convert the input in UCS-2 to Unicode
input=ucs2decode(input);// Cache the length
inputLength=input.length;// Initialize the state
n=initialN;delta=0;bias=initialBias;// Handle the basic code points
for(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<0x80){output.push(stringFromCharCode(currentValue));}}handledCPCount=basicLength=output.length;// `handledCPCount` is the number of code points that have been handled;
// `basicLength` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
if(basicLength){output.push(delimiter);}// Main encoding loop:
while(handledCPCount<inputLength){// All non-basic code points < n have been handled already. Find the next
// larger one:
for(m=maxInt,j=0;j<inputLength;++j){currentValue=input[j];if(currentValue>=n&&currentValue<m){m=currentValue;}}// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
// but guard against overflow
handledCPCountPlusOne=handledCPCount+1;if(m-n>floor((maxInt-delta)/handledCPCountPlusOne)){error('overflow');}delta+=(m-n)*handledCPCountPlusOne;n=m;for(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<n&&++delta>maxInt){error('overflow');}if(currentValue==n){// Represent delta as a generalized variable-length integer
for(q=delta,k=base;;/* no condition */k+=base){t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(q<t){break;}qMinusT=q-t;baseMinusT=base-t;output.push(stringFromCharCode(digitToBasic(t+qMinusT%baseMinusT,0)));q=floor(qMinusT/baseMinusT);}output.push(stringFromCharCode(digitToBasic(q,0)));bias=adapt(delta,handledCPCountPlusOne,handledCPCount==basicLength);delta=0;++handledCPCount;}}++delta;++n;}return output.join('');}/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */function toUnicode(input){return mapDomain(input,function(string){return regexPunycode.test(string)?decode(string.slice(4).toLowerCase()):string;});}/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */function toASCII(input){return mapDomain(input,function(string){return regexNonASCII.test(string)?'xn--'+encode(string):string;});}/*--------------------------------------------------------------------------*/ /** Define the public API */punycode={/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */'version':'1.4.1',/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */'ucs2':{'decode':ucs2decode,'encode':ucs2encode},'decode':decode,'encode':encode,'toASCII':toASCII,'toUnicode':toUnicode};/** Expose `punycode` */ // Some AMD build optimizers, like r.js, check for specific condition patterns
// like the following:
if(typeof define=='function'&&_typeof(define.amd)=='object'&&define.amd){define('punycode',function(){return punycode;});}else if(freeExports&&freeModule){if(module.exports==freeExports){// in Node.js, io.js, or RingoJS v0.8.0+
freeModule.exports=punycode;}else{// in Narwhal or RingoJS v0.7.0-
for(key in punycode){punycode.hasOwnProperty(key)&&(freeExports[key]=punycode[key]);}}}else{// in Rhino or a web browser
root.punycode=punycode;}})(this);}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],74:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop);}module.exports=function(qs,sep,eq,options){sep=sep||'&';eq=eq||'=';var obj={};if(typeof qs!=='string'||qs.length===0){return obj;}var regexp=/\+/g;qs=qs.split(sep);var maxKeys=1000;if(options&&typeof options.maxKeys==='number'){maxKeys=options.maxKeys;}var len=qs.length;// maxKeys <= 0 means that we should not limit keys count
if(maxKeys>0&&len>maxKeys){len=maxKeys;}for(var i=0;i<len;++i){var x=qs[i].replace(regexp,'%20'),idx=x.indexOf(eq),kstr,vstr,k,v;if(idx>=0){kstr=x.substr(0,idx);vstr=x.substr(idx+1);}else{kstr=x;vstr='';}k=decodeURIComponent(kstr);v=decodeURIComponent(vstr);if(!hasOwnProperty(obj,k)){obj[k]=v;}else if(isArray(obj[k])){obj[k].push(v);}else{obj[k]=[obj[k],v];}}return obj;};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};},{}],75:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';var stringifyPrimitive=function stringifyPrimitive(v){switch(_typeof(v)){case'string':return v;case'boolean':return v?'true':'false';case'number':return isFinite(v)?v:'';default:return'';}};module.exports=function(obj,sep,eq,name){sep=sep||'&';eq=eq||'=';if(obj===null){obj=undefined;}if(_typeof(obj)==='object'){return map(objectKeys(obj),function(k){var ks=encodeURIComponent(stringifyPrimitive(k))+eq;if(isArray(obj[k])){return map(obj[k],function(v){return ks+encodeURIComponent(stringifyPrimitive(v));}).join(sep);}else{return ks+encodeURIComponent(stringifyPrimitive(obj[k]));}}).join(sep);}if(!name)return'';return encodeURIComponent(stringifyPrimitive(name))+eq+encodeURIComponent(stringifyPrimitive(obj));};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};function map(xs,f){if(xs.map)return xs.map(f);var res=[];for(var i=0;i<xs.length;i++){res.push(f(xs[i],i));}return res;}var objectKeys=Object.keys||function(obj){var res=[];for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))res.push(key);}return res;};},{}],76:[function(require,module,exports){'use strict';exports.decode=exports.parse=require('./decode');exports.encode=exports.stringify=require('./encode');},{"./decode":74,"./encode":75}],77:[function(require,module,exports){/* eslint-disable node/no-deprecated-api */var buffer=require('buffer');var Buffer=buffer.Buffer;// alternative to using Object.keys for old browsers
function copyProps(src,dst){for(var key in src){dst[key]=src[key];}}if(Buffer.from&&Buffer.alloc&&Buffer.allocUnsafe&&Buffer.allocUnsafeSlow){module.exports=buffer;}else{// Copy properties from require('buffer')
copyProps(buffer,exports);exports.Buffer=SafeBuffer;}function SafeBuffer(arg,encodingOrOffset,length){return Buffer(arg,encodingOrOffset,length);}SafeBuffer.prototype=Object.create(Buffer.prototype);// Copy static methods from Buffer
copyProps(Buffer,SafeBuffer);SafeBuffer.from=function(arg,encodingOrOffset,length){if(typeof arg==='number'){throw new TypeError('Argument must not be a number');}return Buffer(arg,encodingOrOffset,length);};SafeBuffer.alloc=function(size,fill,encoding){if(typeof size!=='number'){throw new TypeError('Argument must be a number');}var buf=Buffer(size);if(fill!==undefined){if(typeof encoding==='string'){buf.fill(fill,encoding);}else{buf.fill(fill);}}else{buf.fill(0);}return buf;};SafeBuffer.allocUnsafe=function(size){if(typeof size!=='number'){throw new TypeError('Argument must be a number');}return Buffer(size);};SafeBuffer.allocUnsafeSlow=function(size){if(typeof size!=='number'){throw new TypeError('Argument must be a number');}return buffer.SlowBuffer(size);};},{"buffer":3}],78:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var util=require('./util');var has=Object.prototype.hasOwnProperty;var hasNativeMap=typeof Map!=="undefined";/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */function ArraySet(){this._array=[];this._set=hasNativeMap?new Map():Object.create(null);}/**
 * Static method for creating ArraySet instances from an existing array.
 */ArraySet.fromArray=function ArraySet_fromArray(aArray,aAllowDuplicates){var set=new ArraySet();for(var i=0,len=aArray.length;i<len;i++){set.add(aArray[i],aAllowDuplicates);}return set;};/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */ArraySet.prototype.size=function ArraySet_size(){return hasNativeMap?this._set.size:Object.getOwnPropertyNames(this._set).length;};/**
 * Add the given string to this set.
 *
 * @param String aStr
 */ArraySet.prototype.add=function ArraySet_add(aStr,aAllowDuplicates){var sStr=hasNativeMap?aStr:util.toSetString(aStr);var isDuplicate=hasNativeMap?this.has(aStr):has.call(this._set,sStr);var idx=this._array.length;if(!isDuplicate||aAllowDuplicates){this._array.push(aStr);}if(!isDuplicate){if(hasNativeMap){this._set.set(aStr,idx);}else{this._set[sStr]=idx;}}};/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */ArraySet.prototype.has=function ArraySet_has(aStr){if(hasNativeMap){return this._set.has(aStr);}else{var sStr=util.toSetString(aStr);return has.call(this._set,sStr);}};/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */ArraySet.prototype.indexOf=function ArraySet_indexOf(aStr){if(hasNativeMap){var idx=this._set.get(aStr);if(idx>=0){return idx;}}else{var sStr=util.toSetString(aStr);if(has.call(this._set,sStr)){return this._set[sStr];}}throw new Error('"'+aStr+'" is not in the set.');};/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */ArraySet.prototype.at=function ArraySet_at(aIdx){if(aIdx>=0&&aIdx<this._array.length){return this._array[aIdx];}throw new Error('No element indexed by '+aIdx);};/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */ArraySet.prototype.toArray=function ArraySet_toArray(){return this._array.slice();};exports.ArraySet=ArraySet;},{"./util":87}],79:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */var base64=require('./base64');// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011
var VLQ_BASE_SHIFT=5;// binary: 100000
var VLQ_BASE=1<<VLQ_BASE_SHIFT;// binary: 011111
var VLQ_BASE_MASK=VLQ_BASE-1;// binary: 100000
var VLQ_CONTINUATION_BIT=VLQ_BASE;/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */function toVLQSigned(aValue){return aValue<0?(-aValue<<1)+1:(aValue<<1)+0;}/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */function fromVLQSigned(aValue){var isNegative=(aValue&1)===1;var shifted=aValue>>1;return isNegative?-shifted:shifted;}/**
 * Returns the base 64 VLQ encoded value.
 */exports.encode=function base64VLQ_encode(aValue){var encoded="";var digit;var vlq=toVLQSigned(aValue);do{digit=vlq&VLQ_BASE_MASK;vlq>>>=VLQ_BASE_SHIFT;if(vlq>0){// There are still more digits in this value, so we must make sure the
// continuation bit is marked.
digit|=VLQ_CONTINUATION_BIT;}encoded+=base64.encode(digit);}while(vlq>0);return encoded;};/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */exports.decode=function base64VLQ_decode(aStr,aIndex,aOutParam){var strLen=aStr.length;var result=0;var shift=0;var continuation,digit;do{if(aIndex>=strLen){throw new Error("Expected more digits in base 64 VLQ value.");}digit=base64.decode(aStr.charCodeAt(aIndex++));if(digit===-1){throw new Error("Invalid base64 digit: "+aStr.charAt(aIndex-1));}continuation=!!(digit&VLQ_CONTINUATION_BIT);digit&=VLQ_BASE_MASK;result=result+(digit<<shift);shift+=VLQ_BASE_SHIFT;}while(continuation);aOutParam.value=fromVLQSigned(result);aOutParam.rest=aIndex;};},{"./base64":80}],80:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var intToCharMap='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */exports.encode=function(number){if(0<=number&&number<intToCharMap.length){return intToCharMap[number];}throw new TypeError("Must be between 0 and 63: "+number);};/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */exports.decode=function(charCode){var bigA=65;// 'A'
var bigZ=90;// 'Z'
var littleA=97;// 'a'
var littleZ=122;// 'z'
var zero=48;// '0'
var nine=57;// '9'
var plus=43;// '+'
var slash=47;// '/'
var littleOffset=26;var numberOffset=52;// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
if(bigA<=charCode&&charCode<=bigZ){return charCode-bigA;}// 26 - 51: abcdefghijklmnopqrstuvwxyz
if(littleA<=charCode&&charCode<=littleZ){return charCode-littleA+littleOffset;}// 52 - 61: 0123456789
if(zero<=charCode&&charCode<=nine){return charCode-zero+numberOffset;}// 62: +
if(charCode==plus){return 62;}// 63: /
if(charCode==slash){return 63;}// Invalid base64 digit.
return-1;};},{}],81:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */exports.GREATEST_LOWER_BOUND=1;exports.LEAST_UPPER_BOUND=2;/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */function recursiveSearch(aLow,aHigh,aNeedle,aHaystack,aCompare,aBias){// This function terminates when one of the following is true:
//
//   1. We find the exact element we are looking for.
//
//   2. We did not find the exact element, but we can return the index of
//      the next-closest element.
//
//   3. We did not find the exact element, and there is no next-closest
//      element than the one we are searching for, so we return -1.
var mid=Math.floor((aHigh-aLow)/2)+aLow;var cmp=aCompare(aNeedle,aHaystack[mid],true);if(cmp===0){// Found the element we are looking for.
return mid;}else if(cmp>0){// Our needle is greater than aHaystack[mid].
if(aHigh-mid>1){// The element is in the upper half.
return recursiveSearch(mid,aHigh,aNeedle,aHaystack,aCompare,aBias);}// The exact needle element was not found in this haystack. Determine if
// we are in termination case (3) or (2) and return the appropriate thing.
if(aBias==exports.LEAST_UPPER_BOUND){return aHigh<aHaystack.length?aHigh:-1;}else{return mid;}}else{// Our needle is less than aHaystack[mid].
if(mid-aLow>1){// The element is in the lower half.
return recursiveSearch(aLow,mid,aNeedle,aHaystack,aCompare,aBias);}// we are in termination case (3) or (2) and return the appropriate thing.
if(aBias==exports.LEAST_UPPER_BOUND){return mid;}else{return aLow<0?-1:aLow;}}}/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */exports.search=function search(aNeedle,aHaystack,aCompare,aBias){if(aHaystack.length===0){return-1;}var index=recursiveSearch(-1,aHaystack.length,aNeedle,aHaystack,aCompare,aBias||exports.GREATEST_LOWER_BOUND);if(index<0){return-1;}// We have found either the exact element, or the next-closest element than
// the one we are searching for. However, there may be more than one such
// element. Make sure we always return the smallest of these.
while(index-1>=0){if(aCompare(aHaystack[index],aHaystack[index-1],true)!==0){break;}--index;}return index;};},{}],82:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var util=require('./util');/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */function generatedPositionAfter(mappingA,mappingB){// Optimized for most common case
var lineA=mappingA.generatedLine;var lineB=mappingB.generatedLine;var columnA=mappingA.generatedColumn;var columnB=mappingB.generatedColumn;return lineB>lineA||lineB==lineA&&columnB>=columnA||util.compareByGeneratedPositionsInflated(mappingA,mappingB)<=0;}/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */function MappingList(){this._array=[];this._sorted=true;// Serves as infimum
this._last={generatedLine:-1,generatedColumn:0};}/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */MappingList.prototype.unsortedForEach=function MappingList_forEach(aCallback,aThisArg){this._array.forEach(aCallback,aThisArg);};/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */MappingList.prototype.add=function MappingList_add(aMapping){if(generatedPositionAfter(this._last,aMapping)){this._last=aMapping;this._array.push(aMapping);}else{this._sorted=false;this._array.push(aMapping);}};/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */MappingList.prototype.toArray=function MappingList_toArray(){if(!this._sorted){this._array.sort(util.compareByGeneratedPositionsInflated);this._sorted=true;}return this._array;};exports.MappingList=MappingList;},{"./util":87}],83:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ // It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.
/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */function swap(ary,x,y){var temp=ary[x];ary[x]=ary[y];ary[y]=temp;}/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */function randomIntInRange(low,high){return Math.round(low+Math.random()*(high-low));}/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */function doQuickSort(ary,comparator,p,r){// If our lower bound is less than our upper bound, we (1) partition the
// array into two pieces and (2) recurse on each half. If it is not, this is
// the empty array and our base case.
if(p<r){// (1) Partitioning.
//
// The partitioning chooses a pivot between `p` and `r` and moves all
// elements that are less than or equal to the pivot to the before it, and
// all the elements that are greater than it after it. The effect is that
// once partition is done, the pivot is in the exact place it will be when
// the array is put in sorted order, and it will not need to be moved
// again. This runs in O(n) time.
// Always choose a random pivot so that an input array which is reverse
// sorted does not cause O(n^2) running time.
var pivotIndex=randomIntInRange(p,r);var i=p-1;swap(ary,pivotIndex,r);var pivot=ary[r];// Immediately after `j` is incremented in this loop, the following hold
// true:
//
//   * Every element in `ary[p .. i]` is less than or equal to the pivot.
//
//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
for(var j=p;j<r;j++){if(comparator(ary[j],pivot)<=0){i+=1;swap(ary,i,j);}}swap(ary,i+1,j);var q=i+1;// (2) Recurse on each half.
doQuickSort(ary,comparator,p,q-1);doQuickSort(ary,comparator,q+1,r);}}/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */exports.quickSort=function(ary,comparator){doQuickSort(ary,comparator,0,ary.length-1);};},{}],84:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var util=require('./util');var binarySearch=require('./binary-search');var ArraySet=require('./array-set').ArraySet;var base64VLQ=require('./base64-vlq');var quickSort=require('./quick-sort').quickSort;function SourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=util.parseSourceMapInput(aSourceMap);}return sourceMap.sections!=null?new IndexedSourceMapConsumer(sourceMap,aSourceMapURL):new BasicSourceMapConsumer(sourceMap,aSourceMapURL);}SourceMapConsumer.fromSourceMap=function(aSourceMap,aSourceMapURL){return BasicSourceMapConsumer.fromSourceMap(aSourceMap,aSourceMapURL);};/**
 * The version of the source mapping spec that we are consuming.
 */SourceMapConsumer.prototype._version=3;// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.
SourceMapConsumer.prototype.__generatedMappings=null;Object.defineProperty(SourceMapConsumer.prototype,'_generatedMappings',{configurable:true,enumerable:true,get:function get(){if(!this.__generatedMappings){this._parseMappings(this._mappings,this.sourceRoot);}return this.__generatedMappings;}});SourceMapConsumer.prototype.__originalMappings=null;Object.defineProperty(SourceMapConsumer.prototype,'_originalMappings',{configurable:true,enumerable:true,get:function get(){if(!this.__originalMappings){this._parseMappings(this._mappings,this.sourceRoot);}return this.__originalMappings;}});SourceMapConsumer.prototype._charIsMappingSeparator=function SourceMapConsumer_charIsMappingSeparator(aStr,index){var c=aStr.charAt(index);return c===";"||c===",";};/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */SourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(aStr,aSourceRoot){throw new Error("Subclasses must implement _parseMappings");};SourceMapConsumer.GENERATED_ORDER=1;SourceMapConsumer.ORIGINAL_ORDER=2;SourceMapConsumer.GREATEST_LOWER_BOUND=1;SourceMapConsumer.LEAST_UPPER_BOUND=2;/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */SourceMapConsumer.prototype.eachMapping=function SourceMapConsumer_eachMapping(aCallback,aContext,aOrder){var context=aContext||null;var order=aOrder||SourceMapConsumer.GENERATED_ORDER;var mappings;switch(order){case SourceMapConsumer.GENERATED_ORDER:mappings=this._generatedMappings;break;case SourceMapConsumer.ORIGINAL_ORDER:mappings=this._originalMappings;break;default:throw new Error("Unknown order of iteration.");}var sourceRoot=this.sourceRoot;mappings.map(function(mapping){var source=mapping.source===null?null:this._sources.at(mapping.source);source=util.computeSourceURL(sourceRoot,source,this._sourceMapURL);return{source:source,generatedLine:mapping.generatedLine,generatedColumn:mapping.generatedColumn,originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:mapping.name===null?null:this._names.at(mapping.name)};},this).forEach(aCallback,context);};/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */SourceMapConsumer.prototype.allGeneratedPositionsFor=function SourceMapConsumer_allGeneratedPositionsFor(aArgs){var line=util.getArg(aArgs,'line');// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
// returns the index of the closest mapping less than the needle. By
// setting needle.originalColumn to 0, we thus find the last mapping for
// the given line, provided such a mapping exists.
var needle={source:util.getArg(aArgs,'source'),originalLine:line,originalColumn:util.getArg(aArgs,'column',0)};needle.source=this._findSourceIndex(needle.source);if(needle.source<0){return[];}var mappings=[];var index=this._findMapping(needle,this._originalMappings,"originalLine","originalColumn",util.compareByOriginalPositions,binarySearch.LEAST_UPPER_BOUND);if(index>=0){var mapping=this._originalMappings[index];if(aArgs.column===undefined){var originalLine=mapping.originalLine;// Iterate until either we run out of mappings, or we run into
// a mapping for a different line than the one we found. Since
// mappings are sorted, this is guaranteed to find all mappings for
// the line we found.
while(mapping&&mapping.originalLine===originalLine){mappings.push({line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)});mapping=this._originalMappings[++index];}}else{var originalColumn=mapping.originalColumn;// Iterate until either we run out of mappings, or we run into
// a mapping for a different line than the one we were searching for.
// Since mappings are sorted, this is guaranteed to find all mappings for
// the line we are searching for.
while(mapping&&mapping.originalLine===line&&mapping.originalColumn==originalColumn){mappings.push({line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)});mapping=this._originalMappings[++index];}}}return mappings;};exports.SourceMapConsumer=SourceMapConsumer;/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */function BasicSourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=util.parseSourceMapInput(aSourceMap);}var version=util.getArg(sourceMap,'version');var sources=util.getArg(sourceMap,'sources');// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
// requires the array) to play nice here.
var names=util.getArg(sourceMap,'names',[]);var sourceRoot=util.getArg(sourceMap,'sourceRoot',null);var sourcesContent=util.getArg(sourceMap,'sourcesContent',null);var mappings=util.getArg(sourceMap,'mappings');var file=util.getArg(sourceMap,'file',null);// Once again, Sass deviates from the spec and supplies the version as a
// string rather than a number, so we use loose equality checking here.
if(version!=this._version){throw new Error('Unsupported version: '+version);}if(sourceRoot){sourceRoot=util.normalize(sourceRoot);}sources=sources.map(String)// Some source maps produce relative source paths like "./foo.js" instead of
// "foo.js".  Normalize these first so that future comparisons will succeed.
// See bugzil.la/1090768.
.map(util.normalize)// Always ensure that absolute sources are internally stored relative to
// the source root, if the source root is absolute. Not doing this would
// be particularly problematic when the source root is a prefix of the
// source (valid, but why??). See github issue #199 and bugzil.la/1188982.
.map(function(source){return sourceRoot&&util.isAbsolute(sourceRoot)&&util.isAbsolute(source)?util.relative(sourceRoot,source):source;});// Pass `true` below to allow duplicate names and sources. While source maps
// are intended to be compressed and deduplicated, the TypeScript compiler
// sometimes generates source maps with duplicates in them. See Github issue
// #72 and bugzil.la/889492.
this._names=ArraySet.fromArray(names.map(String),true);this._sources=ArraySet.fromArray(sources,true);this._absoluteSources=this._sources.toArray().map(function(s){return util.computeSourceURL(sourceRoot,s,aSourceMapURL);});this.sourceRoot=sourceRoot;this.sourcesContent=sourcesContent;this._mappings=mappings;this._sourceMapURL=aSourceMapURL;this.file=file;}BasicSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);BasicSourceMapConsumer.prototype.consumer=SourceMapConsumer;/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */BasicSourceMapConsumer.prototype._findSourceIndex=function(aSource){var relativeSource=aSource;if(this.sourceRoot!=null){relativeSource=util.relative(this.sourceRoot,relativeSource);}if(this._sources.has(relativeSource)){return this._sources.indexOf(relativeSource);}// Maybe aSource is an absolute URL as returned by |sources|.  In
// this case we can't simply undo the transform.
var i;for(i=0;i<this._absoluteSources.length;++i){if(this._absoluteSources[i]==aSource){return i;}}return-1;};/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */BasicSourceMapConsumer.fromSourceMap=function SourceMapConsumer_fromSourceMap(aSourceMap,aSourceMapURL){var smc=Object.create(BasicSourceMapConsumer.prototype);var names=smc._names=ArraySet.fromArray(aSourceMap._names.toArray(),true);var sources=smc._sources=ArraySet.fromArray(aSourceMap._sources.toArray(),true);smc.sourceRoot=aSourceMap._sourceRoot;smc.sourcesContent=aSourceMap._generateSourcesContent(smc._sources.toArray(),smc.sourceRoot);smc.file=aSourceMap._file;smc._sourceMapURL=aSourceMapURL;smc._absoluteSources=smc._sources.toArray().map(function(s){return util.computeSourceURL(smc.sourceRoot,s,aSourceMapURL);});// Because we are modifying the entries (by converting string sources and
// names to indices into the sources and names ArraySets), we have to make
// a copy of the entry or else bad things happen. Shared mutable state
// strikes again! See github issue #191.
var generatedMappings=aSourceMap._mappings.toArray().slice();var destGeneratedMappings=smc.__generatedMappings=[];var destOriginalMappings=smc.__originalMappings=[];for(var i=0,length=generatedMappings.length;i<length;i++){var srcMapping=generatedMappings[i];var destMapping=new Mapping();destMapping.generatedLine=srcMapping.generatedLine;destMapping.generatedColumn=srcMapping.generatedColumn;if(srcMapping.source){destMapping.source=sources.indexOf(srcMapping.source);destMapping.originalLine=srcMapping.originalLine;destMapping.originalColumn=srcMapping.originalColumn;if(srcMapping.name){destMapping.name=names.indexOf(srcMapping.name);}destOriginalMappings.push(destMapping);}destGeneratedMappings.push(destMapping);}quickSort(smc.__originalMappings,util.compareByOriginalPositions);return smc;};/**
 * The version of the source mapping spec that we are consuming.
 */BasicSourceMapConsumer.prototype._version=3;/**
 * The list of original sources.
 */Object.defineProperty(BasicSourceMapConsumer.prototype,'sources',{get:function get(){return this._absoluteSources.slice();}});/**
 * Provide the JIT with a nice shape / hidden class.
 */function Mapping(){this.generatedLine=0;this.generatedColumn=0;this.source=null;this.originalLine=null;this.originalColumn=null;this.name=null;}/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */BasicSourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(aStr,aSourceRoot){var generatedLine=1;var previousGeneratedColumn=0;var previousOriginalLine=0;var previousOriginalColumn=0;var previousSource=0;var previousName=0;var length=aStr.length;var index=0;var cachedSegments={};var temp={};var originalMappings=[];var generatedMappings=[];var mapping,str,segment,end,value;while(index<length){if(aStr.charAt(index)===';'){generatedLine++;index++;previousGeneratedColumn=0;}else if(aStr.charAt(index)===','){index++;}else{mapping=new Mapping();mapping.generatedLine=generatedLine;// Because each offset is encoded relative to the previous one,
// many segments often have the same encoding. We can exploit this
// fact by caching the parsed variable length fields of each segment,
// allowing us to avoid a second parse if we encounter the same
// segment again.
for(end=index;end<length;end++){if(this._charIsMappingSeparator(aStr,end)){break;}}str=aStr.slice(index,end);segment=cachedSegments[str];if(segment){index+=str.length;}else{segment=[];while(index<end){base64VLQ.decode(aStr,index,temp);value=temp.value;index=temp.rest;segment.push(value);}if(segment.length===2){throw new Error('Found a source, but no line and column');}if(segment.length===3){throw new Error('Found a source and line, but no column');}cachedSegments[str]=segment;}// Generated column.
mapping.generatedColumn=previousGeneratedColumn+segment[0];previousGeneratedColumn=mapping.generatedColumn;if(segment.length>1){// Original source.
mapping.source=previousSource+segment[1];previousSource+=segment[1];// Original line.
mapping.originalLine=previousOriginalLine+segment[2];previousOriginalLine=mapping.originalLine;// Lines are stored 0-based
mapping.originalLine+=1;// Original column.
mapping.originalColumn=previousOriginalColumn+segment[3];previousOriginalColumn=mapping.originalColumn;if(segment.length>4){// Original name.
mapping.name=previousName+segment[4];previousName+=segment[4];}}generatedMappings.push(mapping);if(typeof mapping.originalLine==='number'){originalMappings.push(mapping);}}}quickSort(generatedMappings,util.compareByGeneratedPositionsDeflated);this.__generatedMappings=generatedMappings;quickSort(originalMappings,util.compareByOriginalPositions);this.__originalMappings=originalMappings;};/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */BasicSourceMapConsumer.prototype._findMapping=function SourceMapConsumer_findMapping(aNeedle,aMappings,aLineName,aColumnName,aComparator,aBias){// To return the position we are searching for, we must first find the
// mapping for the given position and then return the opposite position it
// points to. Because the mappings are sorted, we can use binary search to
// find the best mapping.
if(aNeedle[aLineName]<=0){throw new TypeError('Line must be greater than or equal to 1, got '+aNeedle[aLineName]);}if(aNeedle[aColumnName]<0){throw new TypeError('Column must be greater than or equal to 0, got '+aNeedle[aColumnName]);}return binarySearch.search(aNeedle,aMappings,aComparator,aBias);};/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */BasicSourceMapConsumer.prototype.computeColumnSpans=function SourceMapConsumer_computeColumnSpans(){for(var index=0;index<this._generatedMappings.length;++index){var mapping=this._generatedMappings[index];// Mappings do not contain a field for the last generated columnt. We
// can come up with an optimistic estimate, however, by assuming that
// mappings are contiguous (i.e. given two consecutive mappings, the
// first mapping ends where the second one starts).
if(index+1<this._generatedMappings.length){var nextMapping=this._generatedMappings[index+1];if(mapping.generatedLine===nextMapping.generatedLine){mapping.lastGeneratedColumn=nextMapping.generatedColumn-1;continue;}}// The last mapping for each line spans the entire line.
mapping.lastGeneratedColumn=Infinity;}};/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */BasicSourceMapConsumer.prototype.originalPositionFor=function SourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,'line'),generatedColumn:util.getArg(aArgs,'column')};var index=this._findMapping(needle,this._generatedMappings,"generatedLine","generatedColumn",util.compareByGeneratedPositionsDeflated,util.getArg(aArgs,'bias',SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._generatedMappings[index];if(mapping.generatedLine===needle.generatedLine){var source=util.getArg(mapping,'source',null);if(source!==null){source=this._sources.at(source);source=util.computeSourceURL(this.sourceRoot,source,this._sourceMapURL);}var name=util.getArg(mapping,'name',null);if(name!==null){name=this._names.at(name);}return{source:source,line:util.getArg(mapping,'originalLine',null),column:util.getArg(mapping,'originalColumn',null),name:name};}}return{source:null,line:null,column:null,name:null};};/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */BasicSourceMapConsumer.prototype.hasContentsOfAllSources=function BasicSourceMapConsumer_hasContentsOfAllSources(){if(!this.sourcesContent){return false;}return this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(sc){return sc==null;});};/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */BasicSourceMapConsumer.prototype.sourceContentFor=function SourceMapConsumer_sourceContentFor(aSource,nullOnMissing){if(!this.sourcesContent){return null;}var index=this._findSourceIndex(aSource);if(index>=0){return this.sourcesContent[index];}var relativeSource=aSource;if(this.sourceRoot!=null){relativeSource=util.relative(this.sourceRoot,relativeSource);}var url;if(this.sourceRoot!=null&&(url=util.urlParse(this.sourceRoot))){// XXX: file:// URIs and absolute paths lead to unexpected behavior for
// many users. We can help them out when they expect file:// URIs to
// behave like it would if they were running a local HTTP server. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
var fileUriAbsPath=relativeSource.replace(/^file:\/\//,"");if(url.scheme=="file"&&this._sources.has(fileUriAbsPath)){return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];}if((!url.path||url.path=="/")&&this._sources.has("/"+relativeSource)){return this.sourcesContent[this._sources.indexOf("/"+relativeSource)];}}// This function is used recursively from
// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
// don't want to throw if we can't find the source - we just want to
// return null, so we provide a flag to exit gracefully.
if(nullOnMissing){return null;}else{throw new Error('"'+relativeSource+'" is not in the SourceMap.');}};/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */BasicSourceMapConsumer.prototype.generatedPositionFor=function SourceMapConsumer_generatedPositionFor(aArgs){var source=util.getArg(aArgs,'source');source=this._findSourceIndex(source);if(source<0){return{line:null,column:null,lastColumn:null};}var needle={source:source,originalLine:util.getArg(aArgs,'line'),originalColumn:util.getArg(aArgs,'column')};var index=this._findMapping(needle,this._originalMappings,"originalLine","originalColumn",util.compareByOriginalPositions,util.getArg(aArgs,'bias',SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._originalMappings[index];if(mapping.source===needle.source){return{line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)};}}return{line:null,column:null,lastColumn:null};};exports.BasicSourceMapConsumer=BasicSourceMapConsumer;/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */function IndexedSourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=util.parseSourceMapInput(aSourceMap);}var version=util.getArg(sourceMap,'version');var sections=util.getArg(sourceMap,'sections');if(version!=this._version){throw new Error('Unsupported version: '+version);}this._sources=new ArraySet();this._names=new ArraySet();var lastOffset={line:-1,column:0};this._sections=sections.map(function(s){if(s.url){// The url field will require support for asynchronicity.
// See https://github.com/mozilla/source-map/issues/16
throw new Error('Support for url field in sections not implemented.');}var offset=util.getArg(s,'offset');var offsetLine=util.getArg(offset,'line');var offsetColumn=util.getArg(offset,'column');if(offsetLine<lastOffset.line||offsetLine===lastOffset.line&&offsetColumn<lastOffset.column){throw new Error('Section offsets must be ordered and non-overlapping.');}lastOffset=offset;return{generatedOffset:{// The offset fields are 0-based, but we use 1-based indices when
// encoding/decoding from VLQ.
generatedLine:offsetLine+1,generatedColumn:offsetColumn+1},consumer:new SourceMapConsumer(util.getArg(s,'map'),aSourceMapURL)};});}IndexedSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);IndexedSourceMapConsumer.prototype.constructor=SourceMapConsumer;/**
 * The version of the source mapping spec that we are consuming.
 */IndexedSourceMapConsumer.prototype._version=3;/**
 * The list of original sources.
 */Object.defineProperty(IndexedSourceMapConsumer.prototype,'sources',{get:function get(){var sources=[];for(var i=0;i<this._sections.length;i++){for(var j=0;j<this._sections[i].consumer.sources.length;j++){sources.push(this._sections[i].consumer.sources[j]);}}return sources;}});/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */IndexedSourceMapConsumer.prototype.originalPositionFor=function IndexedSourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,'line'),generatedColumn:util.getArg(aArgs,'column')};// Find the section containing the generated position we're trying to map
// to an original position.
var sectionIndex=binarySearch.search(needle,this._sections,function(needle,section){var cmp=needle.generatedLine-section.generatedOffset.generatedLine;if(cmp){return cmp;}return needle.generatedColumn-section.generatedOffset.generatedColumn;});var section=this._sections[sectionIndex];if(!section){return{source:null,line:null,column:null,name:null};}return section.consumer.originalPositionFor({line:needle.generatedLine-(section.generatedOffset.generatedLine-1),column:needle.generatedColumn-(section.generatedOffset.generatedLine===needle.generatedLine?section.generatedOffset.generatedColumn-1:0),bias:aArgs.bias});};/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */IndexedSourceMapConsumer.prototype.hasContentsOfAllSources=function IndexedSourceMapConsumer_hasContentsOfAllSources(){return this._sections.every(function(s){return s.consumer.hasContentsOfAllSources();});};/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */IndexedSourceMapConsumer.prototype.sourceContentFor=function IndexedSourceMapConsumer_sourceContentFor(aSource,nullOnMissing){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var content=section.consumer.sourceContentFor(aSource,true);if(content){return content;}}if(nullOnMissing){return null;}else{throw new Error('"'+aSource+'" is not in the SourceMap.');}};/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */IndexedSourceMapConsumer.prototype.generatedPositionFor=function IndexedSourceMapConsumer_generatedPositionFor(aArgs){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];// Only consider this section if the requested source is in the list of
// sources of the consumer.
if(section.consumer._findSourceIndex(util.getArg(aArgs,'source'))===-1){continue;}var generatedPosition=section.consumer.generatedPositionFor(aArgs);if(generatedPosition){var ret={line:generatedPosition.line+(section.generatedOffset.generatedLine-1),column:generatedPosition.column+(section.generatedOffset.generatedLine===generatedPosition.line?section.generatedOffset.generatedColumn-1:0)};return ret;}}return{line:null,column:null};};/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */IndexedSourceMapConsumer.prototype._parseMappings=function IndexedSourceMapConsumer_parseMappings(aStr,aSourceRoot){this.__generatedMappings=[];this.__originalMappings=[];for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var sectionMappings=section.consumer._generatedMappings;for(var j=0;j<sectionMappings.length;j++){var mapping=sectionMappings[j];var source=section.consumer._sources.at(mapping.source);source=util.computeSourceURL(section.consumer.sourceRoot,source,this._sourceMapURL);this._sources.add(source);source=this._sources.indexOf(source);var name=null;if(mapping.name){name=section.consumer._names.at(mapping.name);this._names.add(name);name=this._names.indexOf(name);}// The mappings coming from the consumer for the section have
// generated positions relative to the start of the section, so we
// need to offset them to be relative to the start of the concatenated
// generated file.
var adjustedMapping={source:source,generatedLine:mapping.generatedLine+(section.generatedOffset.generatedLine-1),generatedColumn:mapping.generatedColumn+(section.generatedOffset.generatedLine===mapping.generatedLine?section.generatedOffset.generatedColumn-1:0),originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:name};this.__generatedMappings.push(adjustedMapping);if(typeof adjustedMapping.originalLine==='number'){this.__originalMappings.push(adjustedMapping);}}}quickSort(this.__generatedMappings,util.compareByGeneratedPositionsDeflated);quickSort(this.__originalMappings,util.compareByOriginalPositions);};exports.IndexedSourceMapConsumer=IndexedSourceMapConsumer;},{"./array-set":78,"./base64-vlq":79,"./binary-search":81,"./quick-sort":83,"./util":87}],85:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var base64VLQ=require('./base64-vlq');var util=require('./util');var ArraySet=require('./array-set').ArraySet;var MappingList=require('./mapping-list').MappingList;/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */function SourceMapGenerator(aArgs){if(!aArgs){aArgs={};}this._file=util.getArg(aArgs,'file',null);this._sourceRoot=util.getArg(aArgs,'sourceRoot',null);this._skipValidation=util.getArg(aArgs,'skipValidation',false);this._sources=new ArraySet();this._names=new ArraySet();this._mappings=new MappingList();this._sourcesContents=null;}SourceMapGenerator.prototype._version=3;/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */SourceMapGenerator.fromSourceMap=function SourceMapGenerator_fromSourceMap(aSourceMapConsumer){var sourceRoot=aSourceMapConsumer.sourceRoot;var generator=new SourceMapGenerator({file:aSourceMapConsumer.file,sourceRoot:sourceRoot});aSourceMapConsumer.eachMapping(function(mapping){var newMapping={generated:{line:mapping.generatedLine,column:mapping.generatedColumn}};if(mapping.source!=null){newMapping.source=mapping.source;if(sourceRoot!=null){newMapping.source=util.relative(sourceRoot,newMapping.source);}newMapping.original={line:mapping.originalLine,column:mapping.originalColumn};if(mapping.name!=null){newMapping.name=mapping.name;}}generator.addMapping(newMapping);});aSourceMapConsumer.sources.forEach(function(sourceFile){var sourceRelative=sourceFile;if(sourceRoot!==null){sourceRelative=util.relative(sourceRoot,sourceFile);}if(!generator._sources.has(sourceRelative)){generator._sources.add(sourceRelative);}var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){generator.setSourceContent(sourceFile,content);}});return generator;};/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */SourceMapGenerator.prototype.addMapping=function SourceMapGenerator_addMapping(aArgs){var generated=util.getArg(aArgs,'generated');var original=util.getArg(aArgs,'original',null);var source=util.getArg(aArgs,'source',null);var name=util.getArg(aArgs,'name',null);if(!this._skipValidation){this._validateMapping(generated,original,source,name);}if(source!=null){source=String(source);if(!this._sources.has(source)){this._sources.add(source);}}if(name!=null){name=String(name);if(!this._names.has(name)){this._names.add(name);}}this._mappings.add({generatedLine:generated.line,generatedColumn:generated.column,originalLine:original!=null&&original.line,originalColumn:original!=null&&original.column,source:source,name:name});};/**
 * Set the source content for a source file.
 */SourceMapGenerator.prototype.setSourceContent=function SourceMapGenerator_setSourceContent(aSourceFile,aSourceContent){var source=aSourceFile;if(this._sourceRoot!=null){source=util.relative(this._sourceRoot,source);}if(aSourceContent!=null){// Add the source content to the _sourcesContents map.
// Create a new _sourcesContents map if the property is null.
if(!this._sourcesContents){this._sourcesContents=Object.create(null);}this._sourcesContents[util.toSetString(source)]=aSourceContent;}else if(this._sourcesContents){// Remove the source file from the _sourcesContents map.
// If the _sourcesContents map is empty, set the property to null.
delete this._sourcesContents[util.toSetString(source)];if(Object.keys(this._sourcesContents).length===0){this._sourcesContents=null;}}};/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */SourceMapGenerator.prototype.applySourceMap=function SourceMapGenerator_applySourceMap(aSourceMapConsumer,aSourceFile,aSourceMapPath){var sourceFile=aSourceFile;// If aSourceFile is omitted, we will use the file property of the SourceMap
if(aSourceFile==null){if(aSourceMapConsumer.file==null){throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, '+'or the source map\'s "file" property. Both were omitted.');}sourceFile=aSourceMapConsumer.file;}var sourceRoot=this._sourceRoot;// Make "sourceFile" relative if an absolute Url is passed.
if(sourceRoot!=null){sourceFile=util.relative(sourceRoot,sourceFile);}// Applying the SourceMap can add and remove items from the sources and
// the names array.
var newSources=new ArraySet();var newNames=new ArraySet();// Find mappings for the "sourceFile"
this._mappings.unsortedForEach(function(mapping){if(mapping.source===sourceFile&&mapping.originalLine!=null){// Check if it can be mapped by the source map, then update the mapping.
var original=aSourceMapConsumer.originalPositionFor({line:mapping.originalLine,column:mapping.originalColumn});if(original.source!=null){// Copy mapping
mapping.source=original.source;if(aSourceMapPath!=null){mapping.source=util.join(aSourceMapPath,mapping.source);}if(sourceRoot!=null){mapping.source=util.relative(sourceRoot,mapping.source);}mapping.originalLine=original.line;mapping.originalColumn=original.column;if(original.name!=null){mapping.name=original.name;}}}var source=mapping.source;if(source!=null&&!newSources.has(source)){newSources.add(source);}var name=mapping.name;if(name!=null&&!newNames.has(name)){newNames.add(name);}},this);this._sources=newSources;this._names=newNames;// Copy sourcesContents of applied map.
aSourceMapConsumer.sources.forEach(function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){if(aSourceMapPath!=null){sourceFile=util.join(aSourceMapPath,sourceFile);}if(sourceRoot!=null){sourceFile=util.relative(sourceRoot,sourceFile);}this.setSourceContent(sourceFile,content);}},this);};/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */SourceMapGenerator.prototype._validateMapping=function SourceMapGenerator_validateMapping(aGenerated,aOriginal,aSource,aName){// When aOriginal is truthy but has empty values for .line and .column,
// it is most likely a programmer error. In this case we throw a very
// specific error message to try to guide them the right way.
// For example: https://github.com/Polymer/polymer-bundler/pull/519
if(aOriginal&&typeof aOriginal.line!=='number'&&typeof aOriginal.column!=='number'){throw new Error('original.line and original.column are not numbers -- you probably meant to omit '+'the original mapping entirely and only map the generated position. If so, pass '+'null for the original mapping instead of an object with empty or null values.');}if(aGenerated&&'line'in aGenerated&&'column'in aGenerated&&aGenerated.line>0&&aGenerated.column>=0&&!aOriginal&&!aSource&&!aName){// Case 1.
return;}else if(aGenerated&&'line'in aGenerated&&'column'in aGenerated&&aOriginal&&'line'in aOriginal&&'column'in aOriginal&&aGenerated.line>0&&aGenerated.column>=0&&aOriginal.line>0&&aOriginal.column>=0&&aSource){// Cases 2 and 3.
return;}else{throw new Error('Invalid mapping: '+JSON.stringify({generated:aGenerated,source:aSource,original:aOriginal,name:aName}));}};/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */SourceMapGenerator.prototype._serializeMappings=function SourceMapGenerator_serializeMappings(){var previousGeneratedColumn=0;var previousGeneratedLine=1;var previousOriginalColumn=0;var previousOriginalLine=0;var previousName=0;var previousSource=0;var result='';var next;var mapping;var nameIdx;var sourceIdx;var mappings=this._mappings.toArray();for(var i=0,len=mappings.length;i<len;i++){mapping=mappings[i];next='';if(mapping.generatedLine!==previousGeneratedLine){previousGeneratedColumn=0;while(mapping.generatedLine!==previousGeneratedLine){next+=';';previousGeneratedLine++;}}else{if(i>0){if(!util.compareByGeneratedPositionsInflated(mapping,mappings[i-1])){continue;}next+=',';}}next+=base64VLQ.encode(mapping.generatedColumn-previousGeneratedColumn);previousGeneratedColumn=mapping.generatedColumn;if(mapping.source!=null){sourceIdx=this._sources.indexOf(mapping.source);next+=base64VLQ.encode(sourceIdx-previousSource);previousSource=sourceIdx;// lines are stored 0-based in SourceMap spec version 3
next+=base64VLQ.encode(mapping.originalLine-1-previousOriginalLine);previousOriginalLine=mapping.originalLine-1;next+=base64VLQ.encode(mapping.originalColumn-previousOriginalColumn);previousOriginalColumn=mapping.originalColumn;if(mapping.name!=null){nameIdx=this._names.indexOf(mapping.name);next+=base64VLQ.encode(nameIdx-previousName);previousName=nameIdx;}}result+=next;}return result;};SourceMapGenerator.prototype._generateSourcesContent=function SourceMapGenerator_generateSourcesContent(aSources,aSourceRoot){return aSources.map(function(source){if(!this._sourcesContents){return null;}if(aSourceRoot!=null){source=util.relative(aSourceRoot,source);}var key=util.toSetString(source);return Object.prototype.hasOwnProperty.call(this._sourcesContents,key)?this._sourcesContents[key]:null;},this);};/**
 * Externalize the source map.
 */SourceMapGenerator.prototype.toJSON=function SourceMapGenerator_toJSON(){var map={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};if(this._file!=null){map.file=this._file;}if(this._sourceRoot!=null){map.sourceRoot=this._sourceRoot;}if(this._sourcesContents){map.sourcesContent=this._generateSourcesContent(map.sources,map.sourceRoot);}return map;};/**
 * Render the source map being generated to a string.
 */SourceMapGenerator.prototype.toString=function SourceMapGenerator_toString(){return JSON.stringify(this.toJSON());};exports.SourceMapGenerator=SourceMapGenerator;},{"./array-set":78,"./base64-vlq":79,"./mapping-list":82,"./util":87}],86:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var SourceMapGenerator=require('./source-map-generator').SourceMapGenerator;var util=require('./util');// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE=/(\r?\n)/;// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE=10;// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode="$$$isSourceNode$$$";/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */function SourceNode(aLine,aColumn,aSource,aChunks,aName){this.children=[];this.sourceContents={};this.line=aLine==null?null:aLine;this.column=aColumn==null?null:aColumn;this.source=aSource==null?null:aSource;this.name=aName==null?null:aName;this[isSourceNode]=true;if(aChunks!=null)this.add(aChunks);}/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */SourceNode.fromStringWithSourceMap=function SourceNode_fromStringWithSourceMap(aGeneratedCode,aSourceMapConsumer,aRelativePath){// The SourceNode we want to fill with the generated code
// and the SourceMap
var node=new SourceNode();// All even indices of this array are one line of the generated code,
// while all odd indices are the newlines between two adjacent lines
// (since `REGEX_NEWLINE` captures its match).
// Processed fragments are accessed by calling `shiftNextLine`.
var remainingLines=aGeneratedCode.split(REGEX_NEWLINE);var remainingLinesIndex=0;var shiftNextLine=function shiftNextLine(){var lineContents=getNextLine();// The last line of a file might not have a newline.
var newLine=getNextLine()||"";return lineContents+newLine;function getNextLine(){return remainingLinesIndex<remainingLines.length?remainingLines[remainingLinesIndex++]:undefined;}};// We need to remember the position of "remainingLines"
var lastGeneratedLine=1,lastGeneratedColumn=0;// The generate SourceNodes we need a code range.
// To extract it current and last mapping is used.
// Here we store the last mapping.
var lastMapping=null;aSourceMapConsumer.eachMapping(function(mapping){if(lastMapping!==null){// We add the code from "lastMapping" to "mapping":
// First check if there is a new line in between.
if(lastGeneratedLine<mapping.generatedLine){// Associate first line with "lastMapping"
addMappingWithCode(lastMapping,shiftNextLine());lastGeneratedLine++;lastGeneratedColumn=0;// The remaining code is added without mapping
}else{// There is no new line in between.
// Associate the code between "lastGeneratedColumn" and
// "mapping.generatedColumn" with "lastMapping"
var nextLine=remainingLines[remainingLinesIndex]||'';var code=nextLine.substr(0,mapping.generatedColumn-lastGeneratedColumn);remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn-lastGeneratedColumn);lastGeneratedColumn=mapping.generatedColumn;addMappingWithCode(lastMapping,code);// No more remaining code, continue
lastMapping=mapping;return;}}// We add the generated code until the first mapping
// to the SourceNode without any mapping.
// Each line is added as separate string.
while(lastGeneratedLine<mapping.generatedLine){node.add(shiftNextLine());lastGeneratedLine++;}if(lastGeneratedColumn<mapping.generatedColumn){var nextLine=remainingLines[remainingLinesIndex]||'';node.add(nextLine.substr(0,mapping.generatedColumn));remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn);lastGeneratedColumn=mapping.generatedColumn;}lastMapping=mapping;},this);// We have processed all mappings.
if(remainingLinesIndex<remainingLines.length){if(lastMapping){// Associate the remaining code in the current line with "lastMapping"
addMappingWithCode(lastMapping,shiftNextLine());}// and add the remaining lines without any mapping
node.add(remainingLines.splice(remainingLinesIndex).join(""));}// Copy sourcesContent into SourceNode
aSourceMapConsumer.sources.forEach(function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){if(aRelativePath!=null){sourceFile=util.join(aRelativePath,sourceFile);}node.setSourceContent(sourceFile,content);}});return node;function addMappingWithCode(mapping,code){if(mapping===null||mapping.source===undefined){node.add(code);}else{var source=aRelativePath?util.join(aRelativePath,mapping.source):mapping.source;node.add(new SourceNode(mapping.originalLine,mapping.originalColumn,source,code,mapping.name));}}};/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */SourceNode.prototype.add=function SourceNode_add(aChunk){if(Array.isArray(aChunk)){aChunk.forEach(function(chunk){this.add(chunk);},this);}else if(aChunk[isSourceNode]||typeof aChunk==="string"){if(aChunk){this.children.push(aChunk);}}else{throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+aChunk);}return this;};/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */SourceNode.prototype.prepend=function SourceNode_prepend(aChunk){if(Array.isArray(aChunk)){for(var i=aChunk.length-1;i>=0;i--){this.prepend(aChunk[i]);}}else if(aChunk[isSourceNode]||typeof aChunk==="string"){this.children.unshift(aChunk);}else{throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+aChunk);}return this;};/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */SourceNode.prototype.walk=function SourceNode_walk(aFn){var chunk;for(var i=0,len=this.children.length;i<len;i++){chunk=this.children[i];if(chunk[isSourceNode]){chunk.walk(aFn);}else{if(chunk!==''){aFn(chunk,{source:this.source,line:this.line,column:this.column,name:this.name});}}}};/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */SourceNode.prototype.join=function SourceNode_join(aSep){var newChildren;var i;var len=this.children.length;if(len>0){newChildren=[];for(i=0;i<len-1;i++){newChildren.push(this.children[i]);newChildren.push(aSep);}newChildren.push(this.children[i]);this.children=newChildren;}return this;};/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */SourceNode.prototype.replaceRight=function SourceNode_replaceRight(aPattern,aReplacement){var lastChild=this.children[this.children.length-1];if(lastChild[isSourceNode]){lastChild.replaceRight(aPattern,aReplacement);}else if(typeof lastChild==='string'){this.children[this.children.length-1]=lastChild.replace(aPattern,aReplacement);}else{this.children.push(''.replace(aPattern,aReplacement));}return this;};/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */SourceNode.prototype.setSourceContent=function SourceNode_setSourceContent(aSourceFile,aSourceContent){this.sourceContents[util.toSetString(aSourceFile)]=aSourceContent;};/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */SourceNode.prototype.walkSourceContents=function SourceNode_walkSourceContents(aFn){for(var i=0,len=this.children.length;i<len;i++){if(this.children[i][isSourceNode]){this.children[i].walkSourceContents(aFn);}}var sources=Object.keys(this.sourceContents);for(var i=0,len=sources.length;i<len;i++){aFn(util.fromSetString(sources[i]),this.sourceContents[sources[i]]);}};/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */SourceNode.prototype.toString=function SourceNode_toString(){var str="";this.walk(function(chunk){str+=chunk;});return str;};/**
 * Returns the string representation of this source node along with a source
 * map.
 */SourceNode.prototype.toStringWithSourceMap=function SourceNode_toStringWithSourceMap(aArgs){var generated={code:"",line:1,column:0};var map=new SourceMapGenerator(aArgs);var sourceMappingActive=false;var lastOriginalSource=null;var lastOriginalLine=null;var lastOriginalColumn=null;var lastOriginalName=null;this.walk(function(chunk,original){generated.code+=chunk;if(original.source!==null&&original.line!==null&&original.column!==null){if(lastOriginalSource!==original.source||lastOriginalLine!==original.line||lastOriginalColumn!==original.column||lastOriginalName!==original.name){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name});}lastOriginalSource=original.source;lastOriginalLine=original.line;lastOriginalColumn=original.column;lastOriginalName=original.name;sourceMappingActive=true;}else if(sourceMappingActive){map.addMapping({generated:{line:generated.line,column:generated.column}});lastOriginalSource=null;sourceMappingActive=false;}for(var idx=0,length=chunk.length;idx<length;idx++){if(chunk.charCodeAt(idx)===NEWLINE_CODE){generated.line++;generated.column=0;// Mappings end at eol
if(idx+1===length){lastOriginalSource=null;sourceMappingActive=false;}else if(sourceMappingActive){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name});}}else{generated.column++;}}});this.walkSourceContents(function(sourceFile,sourceContent){map.setSourceContent(sourceFile,sourceContent);});return{code:generated.code,map:map};};exports.SourceNode=SourceNode;},{"./source-map-generator":85,"./util":87}],87:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ /**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */function getArg(aArgs,aName,aDefaultValue){if(aName in aArgs){return aArgs[aName];}else if(arguments.length===3){return aDefaultValue;}else{throw new Error('"'+aName+'" is a required argument.');}}exports.getArg=getArg;var urlRegexp=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;var dataUrlRegexp=/^data:.+\,.+$/;function urlParse(aUrl){var match=aUrl.match(urlRegexp);if(!match){return null;}return{scheme:match[1],auth:match[2],host:match[3],port:match[4],path:match[5]};}exports.urlParse=urlParse;function urlGenerate(aParsedUrl){var url='';if(aParsedUrl.scheme){url+=aParsedUrl.scheme+':';}url+='//';if(aParsedUrl.auth){url+=aParsedUrl.auth+'@';}if(aParsedUrl.host){url+=aParsedUrl.host;}if(aParsedUrl.port){url+=":"+aParsedUrl.port;}if(aParsedUrl.path){url+=aParsedUrl.path;}return url;}exports.urlGenerate=urlGenerate;/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */function normalize(aPath){var path=aPath;var url=urlParse(aPath);if(url){if(!url.path){return aPath;}path=url.path;}var isAbsolute=exports.isAbsolute(path);var parts=path.split(/\/+/);for(var part,up=0,i=parts.length-1;i>=0;i--){part=parts[i];if(part==='.'){parts.splice(i,1);}else if(part==='..'){up++;}else if(up>0){if(part===''){// The first part is blank if the path is absolute. Trying to go
// above the root is a no-op. Therefore we can remove all '..' parts
// directly after the root.
parts.splice(i+1,up);up=0;}else{parts.splice(i,2);up--;}}}path=parts.join('/');if(path===''){path=isAbsolute?'/':'.';}if(url){url.path=path;return urlGenerate(url);}return path;}exports.normalize=normalize;/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */function join(aRoot,aPath){if(aRoot===""){aRoot=".";}if(aPath===""){aPath=".";}var aPathUrl=urlParse(aPath);var aRootUrl=urlParse(aRoot);if(aRootUrl){aRoot=aRootUrl.path||'/';}// `join(foo, '//www.example.org')`
if(aPathUrl&&!aPathUrl.scheme){if(aRootUrl){aPathUrl.scheme=aRootUrl.scheme;}return urlGenerate(aPathUrl);}if(aPathUrl||aPath.match(dataUrlRegexp)){return aPath;}// `join('http://', 'www.example.com')`
if(aRootUrl&&!aRootUrl.host&&!aRootUrl.path){aRootUrl.host=aPath;return urlGenerate(aRootUrl);}var joined=aPath.charAt(0)==='/'?aPath:normalize(aRoot.replace(/\/+$/,'')+'/'+aPath);if(aRootUrl){aRootUrl.path=joined;return urlGenerate(aRootUrl);}return joined;}exports.join=join;exports.isAbsolute=function(aPath){return aPath.charAt(0)==='/'||urlRegexp.test(aPath);};/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */function relative(aRoot,aPath){if(aRoot===""){aRoot=".";}aRoot=aRoot.replace(/\/$/,'');// It is possible for the path to be above the root. In this case, simply
// checking whether the root is a prefix of the path won't work. Instead, we
// need to remove components from the root one by one, until either we find
// a prefix that fits, or we run out of components to remove.
var level=0;while(aPath.indexOf(aRoot+'/')!==0){var index=aRoot.lastIndexOf("/");if(index<0){return aPath;}// If the only part of the root that is left is the scheme (i.e. http://,
// file:///, etc.), one or more slashes (/), or simply nothing at all, we
// have exhausted all components, so the path is not relative to the root.
aRoot=aRoot.slice(0,index);if(aRoot.match(/^([^\/]+:\/)?\/*$/)){return aPath;}++level;}// Make sure we add a "../" for each component we removed from the root.
return Array(level+1).join("../")+aPath.substr(aRoot.length+1);}exports.relative=relative;var supportsNullProto=function(){var obj=Object.create(null);return!('__proto__'in obj);}();function identity(s){return s;}/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */function toSetString(aStr){if(isProtoString(aStr)){return'$'+aStr;}return aStr;}exports.toSetString=supportsNullProto?identity:toSetString;function fromSetString(aStr){if(isProtoString(aStr)){return aStr.slice(1);}return aStr;}exports.fromSetString=supportsNullProto?identity:fromSetString;function isProtoString(s){if(!s){return false;}var length=s.length;if(length<9/* "__proto__".length */){return false;}if(s.charCodeAt(length-1)!==95/* '_' */||s.charCodeAt(length-2)!==95/* '_' */||s.charCodeAt(length-3)!==111/* 'o' */||s.charCodeAt(length-4)!==116/* 't' */||s.charCodeAt(length-5)!==111/* 'o' */||s.charCodeAt(length-6)!==114/* 'r' */||s.charCodeAt(length-7)!==112/* 'p' */||s.charCodeAt(length-8)!==95/* '_' */||s.charCodeAt(length-9)!==95/* '_' */){return false;}for(var i=length-10;i>=0;i--){if(s.charCodeAt(i)!==36/* '$' */){return false;}}return true;}/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */function compareByOriginalPositions(mappingA,mappingB,onlyCompareOriginal){var cmp=strcmp(mappingA.source,mappingB.source);if(cmp!==0){return cmp;}cmp=mappingA.originalLine-mappingB.originalLine;if(cmp!==0){return cmp;}cmp=mappingA.originalColumn-mappingB.originalColumn;if(cmp!==0||onlyCompareOriginal){return cmp;}cmp=mappingA.generatedColumn-mappingB.generatedColumn;if(cmp!==0){return cmp;}cmp=mappingA.generatedLine-mappingB.generatedLine;if(cmp!==0){return cmp;}return strcmp(mappingA.name,mappingB.name);}exports.compareByOriginalPositions=compareByOriginalPositions;/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */function compareByGeneratedPositionsDeflated(mappingA,mappingB,onlyCompareGenerated){var cmp=mappingA.generatedLine-mappingB.generatedLine;if(cmp!==0){return cmp;}cmp=mappingA.generatedColumn-mappingB.generatedColumn;if(cmp!==0||onlyCompareGenerated){return cmp;}cmp=strcmp(mappingA.source,mappingB.source);if(cmp!==0){return cmp;}cmp=mappingA.originalLine-mappingB.originalLine;if(cmp!==0){return cmp;}cmp=mappingA.originalColumn-mappingB.originalColumn;if(cmp!==0){return cmp;}return strcmp(mappingA.name,mappingB.name);}exports.compareByGeneratedPositionsDeflated=compareByGeneratedPositionsDeflated;function strcmp(aStr1,aStr2){if(aStr1===aStr2){return 0;}if(aStr1===null){return 1;// aStr2 !== null
}if(aStr2===null){return-1;// aStr1 !== null
}if(aStr1>aStr2){return 1;}return-1;}/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */function compareByGeneratedPositionsInflated(mappingA,mappingB){var cmp=mappingA.generatedLine-mappingB.generatedLine;if(cmp!==0){return cmp;}cmp=mappingA.generatedColumn-mappingB.generatedColumn;if(cmp!==0){return cmp;}cmp=strcmp(mappingA.source,mappingB.source);if(cmp!==0){return cmp;}cmp=mappingA.originalLine-mappingB.originalLine;if(cmp!==0){return cmp;}cmp=mappingA.originalColumn-mappingB.originalColumn;if(cmp!==0){return cmp;}return strcmp(mappingA.name,mappingB.name);}exports.compareByGeneratedPositionsInflated=compareByGeneratedPositionsInflated;/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */function parseSourceMapInput(str){return JSON.parse(str.replace(/^\)]}'[^\n]*\n/,''));}exports.parseSourceMapInput=parseSourceMapInput;/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */function computeSourceURL(sourceRoot,sourceURL,sourceMapURL){sourceURL=sourceURL||'';if(sourceRoot){// This follows what Chrome does.
if(sourceRoot[sourceRoot.length-1]!=='/'&&sourceURL[0]!=='/'){sourceRoot+='/';}// The spec says:
//   Line 4: An optional source root, useful for relocating source
//   files on a server or removing repeated values in the
//   “sources” entry.  This value is prepended to the individual
//   entries in the “source” field.
sourceURL=sourceRoot+sourceURL;}// Historically, SourceMapConsumer did not take the sourceMapURL as
// a parameter.  This mode is still somewhat supported, which is why
// this code block is conditional.  However, it's preferable to pass
// the source map URL to SourceMapConsumer, so that this function
// can implement the source URL resolution algorithm as outlined in
// the spec.  This block is basically the equivalent of:
//    new URL(sourceURL, sourceMapURL).toString()
// ... except it avoids using URL, which wasn't available in the
// older releases of node still supported by this library.
//
// The spec says:
//   If the sources are not absolute URLs after prepending of the
//   “sourceRoot”, the sources are resolved relative to the
//   SourceMap (like resolving script src in a html document).
if(sourceMapURL){var parsed=urlParse(sourceMapURL);if(!parsed){throw new Error("sourceMapURL could not be parsed");}if(parsed.path){// Strip the last path component, but keep the "/".
var index=parsed.path.lastIndexOf('/');if(index>=0){parsed.path=parsed.path.substring(0,index+1);}}sourceURL=join(urlGenerate(parsed),sourceURL);}return normalize(sourceURL);}exports.computeSourceURL=computeSourceURL;},{}],88:[function(require,module,exports){/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */exports.SourceMapGenerator=require('./lib/source-map-generator').SourceMapGenerator;exports.SourceMapConsumer=require('./lib/source-map-consumer').SourceMapConsumer;exports.SourceNode=require('./lib/source-node').SourceNode;},{"./lib/source-map-consumer":84,"./lib/source-map-generator":85,"./lib/source-node":86}],89:[function(require,module,exports){'use strict';var integerRegex=/^\d+$/;function deepUnique(array){return array.sort().filter(function(element,index){return JSON.stringify(element)!==JSON.stringify(array[index-1]);});}exports.parse=function(string){return deepUnique(string.split(',').map(function(part){var result={};part.trim().split(/\s+/).forEach(function(element,index){if(index===0){result.url=element;return;}var value=element.slice(0,element.length-1);var postfix=element[element.length-1];var integerValue=parseInt(value,10);var floatValue=parseFloat(value);if(postfix==='w'&&integerRegex.test(value)){result.width=integerValue;}else if(postfix==='h'&&integerRegex.test(value)){result.height=integerValue;}else if(postfix==='x'&&!Number.isNaN(floatValue)){result.density=floatValue;}else{throw new Error("Invalid srcset descriptor: ".concat(element));}});return result;}));};exports.stringify=function(array){return _toConsumableArray(new Set(array.map(function(element){if(!element.url){throw new Error('URL is required');}var result=[element.url];if(element.width){result.push("".concat(element.width,"w"));}if(element.height){result.push("".concat(element.height,"h"));}if(element.density){result.push("".concat(element.density,"x"));}return result.join(' ');}))).join(', ');};},{}],90:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';/*<replacement>*/var Buffer=require('safe-buffer').Buffer;/*</replacement>*/var isEncoding=Buffer.isEncoding||function(encoding){encoding=''+encoding;switch(encoding&&encoding.toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':case'raw':return true;default:return false;}};function _normalizeEncoding(enc){if(!enc)return'utf8';var retried;while(true){switch(enc){case'utf8':case'utf-8':return'utf8';case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return'utf16le';case'latin1':case'binary':return'latin1';case'base64':case'ascii':case'hex':return enc;default:if(retried)return;// undefined
enc=(''+enc).toLowerCase();retried=true;}}};// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc){var nenc=_normalizeEncoding(enc);if(typeof nenc!=='string'&&(Buffer.isEncoding===isEncoding||!isEncoding(enc)))throw new Error('Unknown encoding: '+enc);return nenc||enc;}// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder=StringDecoder;function StringDecoder(encoding){this.encoding=normalizeEncoding(encoding);var nb;switch(this.encoding){case'utf16le':this.text=utf16Text;this.end=utf16End;nb=4;break;case'utf8':this.fillLast=utf8FillLast;nb=4;break;case'base64':this.text=base64Text;this.end=base64End;nb=3;break;default:this.write=simpleWrite;this.end=simpleEnd;return;}this.lastNeed=0;this.lastTotal=0;this.lastChar=Buffer.allocUnsafe(nb);}StringDecoder.prototype.write=function(buf){if(buf.length===0)return'';var r;var i;if(this.lastNeed){r=this.fillLast(buf);if(r===undefined)return'';i=this.lastNeed;this.lastNeed=0;}else{i=0;}if(i<buf.length)return r?r+this.text(buf,i):this.text(buf,i);return r||'';};StringDecoder.prototype.end=utf8End;// Returns only complete characters in a Buffer
StringDecoder.prototype.text=utf8Text;// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast=function(buf){if(this.lastNeed<=buf.length){buf.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal);}buf.copy(this.lastChar,this.lastTotal-this.lastNeed,0,buf.length);this.lastNeed-=buf.length;};// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(_byte){if(_byte<=0x7F)return 0;else if(_byte>>5===0x06)return 2;else if(_byte>>4===0x0E)return 3;else if(_byte>>3===0x1E)return 4;return _byte>>6===0x02?-1:-2;}// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self,buf,i){var j=buf.length-1;if(j<i)return 0;var nb=utf8CheckByte(buf[j]);if(nb>=0){if(nb>0)self.lastNeed=nb-1;return nb;}if(--j<i||nb===-2)return 0;nb=utf8CheckByte(buf[j]);if(nb>=0){if(nb>0)self.lastNeed=nb-2;return nb;}if(--j<i||nb===-2)return 0;nb=utf8CheckByte(buf[j]);if(nb>=0){if(nb>0){if(nb===2)nb=0;else self.lastNeed=nb-3;}return nb;}return 0;}// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self,buf,p){if((buf[0]&0xC0)!==0x80){self.lastNeed=0;return"\uFFFD";}if(self.lastNeed>1&&buf.length>1){if((buf[1]&0xC0)!==0x80){self.lastNeed=1;return"\uFFFD";}if(self.lastNeed>2&&buf.length>2){if((buf[2]&0xC0)!==0x80){self.lastNeed=2;return"\uFFFD";}}}}// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf){var p=this.lastTotal-this.lastNeed;var r=utf8CheckExtraBytes(this,buf,p);if(r!==undefined)return r;if(this.lastNeed<=buf.length){buf.copy(this.lastChar,p,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal);}buf.copy(this.lastChar,p,0,buf.length);this.lastNeed-=buf.length;}// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf,i){var total=utf8CheckIncomplete(this,buf,i);if(!this.lastNeed)return buf.toString('utf8',i);this.lastTotal=total;var end=buf.length-(total-this.lastNeed);buf.copy(this.lastChar,0,end);return buf.toString('utf8',i,end);}// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf){var r=buf&&buf.length?this.write(buf):'';if(this.lastNeed)return r+"\uFFFD";return r;}// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf,i){if((buf.length-i)%2===0){var r=buf.toString('utf16le',i);if(r){var c=r.charCodeAt(r.length-1);if(c>=0xD800&&c<=0xDBFF){this.lastNeed=2;this.lastTotal=4;this.lastChar[0]=buf[buf.length-2];this.lastChar[1]=buf[buf.length-1];return r.slice(0,-1);}}return r;}this.lastNeed=1;this.lastTotal=2;this.lastChar[0]=buf[buf.length-1];return buf.toString('utf16le',i,buf.length-1);}// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf){var r=buf&&buf.length?this.write(buf):'';if(this.lastNeed){var end=this.lastTotal-this.lastNeed;return r+this.lastChar.toString('utf16le',0,end);}return r;}function base64Text(buf,i){var n=(buf.length-i)%3;if(n===0)return buf.toString('base64',i);this.lastNeed=3-n;this.lastTotal=3;if(n===1){this.lastChar[0]=buf[buf.length-1];}else{this.lastChar[0]=buf[buf.length-2];this.lastChar[1]=buf[buf.length-1];}return buf.toString('base64',i,buf.length-n);}function base64End(buf){var r=buf&&buf.length?this.write(buf):'';if(this.lastNeed)return r+this.lastChar.toString('base64',0,3-this.lastNeed);return r;}// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf){return buf.toString(this.encoding);}function simpleEnd(buf){return buf&&buf.length?this.write(buf):'';}},{"safe-buffer":77}],91:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';var punycode=require('punycode');var util=require('./util');exports.parse=urlParse;exports.resolve=urlResolve;exports.resolveObject=urlResolveObject;exports.format=urlFormat;exports.Url=Url;function Url(){this.protocol=null;this.slashes=null;this.auth=null;this.host=null;this.port=null;this.hostname=null;this.hash=null;this.search=null;this.query=null;this.pathname=null;this.path=null;this.href=null;}// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern=/^([a-z0-9.+-]+:)/i,portPattern=/:[0-9]*$/,// Special case for a simple path URL
simplePathPattern=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims=['<','>','"','`',' ','\r','\n','\t'],// RFC 2396: characters not allowed for various reasons.
unwise=['{','}','|','\\','^','`'].concat(delims),// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape=['\''].concat(unwise),// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars=['%','/','?',';','#'].concat(autoEscape),hostEndingChars=['/','?','#'],hostnameMaxLen=255,hostnamePartPattern=/^[+a-z0-9A-Z_-]{0,63}$/,hostnamePartStart=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol={'javascript':true,'javascript:':true},// protocols that never have a hostname.
hostlessProtocol={'javascript':true,'javascript:':true},// protocols that always contain a // bit.
slashedProtocol={'http':true,'https':true,'ftp':true,'gopher':true,'file':true,'http:':true,'https:':true,'ftp:':true,'gopher:':true,'file:':true},querystring=require('querystring');function urlParse(url,parseQueryString,slashesDenoteHost){if(url&&util.isObject(url)&&url instanceof Url)return url;var u=new Url();u.parse(url,parseQueryString,slashesDenoteHost);return u;}Url.prototype.parse=function(url,parseQueryString,slashesDenoteHost){if(!util.isString(url)){throw new TypeError("Parameter 'url' must be a string, not "+_typeof(url));}// Copy chrome, IE, opera backslash-handling behavior.
// Back slashes before the query string get converted to forward slashes
// See: https://code.google.com/p/chromium/issues/detail?id=25916
var queryIndex=url.indexOf('?'),splitter=queryIndex!==-1&&queryIndex<url.indexOf('#')?'?':'#',uSplit=url.split(splitter),slashRegex=/\\/g;uSplit[0]=uSplit[0].replace(slashRegex,'/');url=uSplit.join(splitter);var rest=url;// trim before proceeding.
// This is to support parse stuff like "  http://foo.com  \n"
rest=rest.trim();if(!slashesDenoteHost&&url.split('#').length===1){// Try fast path regexp
var simplePath=simplePathPattern.exec(rest);if(simplePath){this.path=rest;this.href=rest;this.pathname=simplePath[1];if(simplePath[2]){this.search=simplePath[2];if(parseQueryString){this.query=querystring.parse(this.search.substr(1));}else{this.query=this.search.substr(1);}}else if(parseQueryString){this.search='';this.query={};}return this;}}var proto=protocolPattern.exec(rest);if(proto){proto=proto[0];var lowerProto=proto.toLowerCase();this.protocol=lowerProto;rest=rest.substr(proto.length);}// figure out if it's got a host
// user@server is *always* interpreted as a hostname, and url
// resolution will treat //foo/bar as host=foo,path=bar because that's
// how the browser resolves relative URLs.
if(slashesDenoteHost||proto||rest.match(/^\/\/[^@\/]+@[^@\/]+/)){var slashes=rest.substr(0,2)==='//';if(slashes&&!(proto&&hostlessProtocol[proto])){rest=rest.substr(2);this.slashes=true;}}if(!hostlessProtocol[proto]&&(slashes||proto&&!slashedProtocol[proto])){// there's a hostname.
// the first instance of /, ?, ;, or # ends the host.
//
// If there is an @ in the hostname, then non-host chars *are* allowed
// to the left of the last @ sign, unless some host-ending character
// comes *before* the @-sign.
// URLs are obnoxious.
//
// ex:
// http://a@b@c/ => user:a@b host:c
// http://a@b?@c => user:a host:c path:/?@c
// v0.12 TODO(isaacs): This is not quite how Chrome does things.
// Review our test case against browsers more comprehensively.
// find the first instance of any hostEndingChars
var hostEnd=-1;for(var i=0;i<hostEndingChars.length;i++){var hec=rest.indexOf(hostEndingChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd))hostEnd=hec;}// at this point, either we have an explicit point where the
// auth portion cannot go past, or the last @ char is the decider.
var auth,atSign;if(hostEnd===-1){// atSign can be anywhere.
atSign=rest.lastIndexOf('@');}else{// atSign must be in auth portion.
// http://a@b/c@d => host:b auth:a path:/c@d
atSign=rest.lastIndexOf('@',hostEnd);}// Now we have a portion which is definitely the auth.
// Pull that off.
if(atSign!==-1){auth=rest.slice(0,atSign);rest=rest.slice(atSign+1);this.auth=decodeURIComponent(auth);}// the host is the remaining to the left of the first non-host char
hostEnd=-1;for(var i=0;i<nonHostChars.length;i++){var hec=rest.indexOf(nonHostChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd))hostEnd=hec;}// if we still have not hit it, then the entire thing is a host.
if(hostEnd===-1)hostEnd=rest.length;this.host=rest.slice(0,hostEnd);rest=rest.slice(hostEnd);// pull out port.
this.parseHost();// we've indicated that there is a hostname,
// so even if it's empty, it has to be present.
this.hostname=this.hostname||'';// if hostname begins with [ and ends with ]
// assume that it's an IPv6 address.
var ipv6Hostname=this.hostname[0]==='['&&this.hostname[this.hostname.length-1]===']';// validate a little.
if(!ipv6Hostname){var hostparts=this.hostname.split(/\./);for(var i=0,l=hostparts.length;i<l;i++){var part=hostparts[i];if(!part)continue;if(!part.match(hostnamePartPattern)){var newpart='';for(var j=0,k=part.length;j<k;j++){if(part.charCodeAt(j)>127){// we replace non-ASCII char with a temporary placeholder
// we need this to make sure size of hostname is not
// broken by replacing non-ASCII by nothing
newpart+='x';}else{newpart+=part[j];}}// we test again with ASCII char only
if(!newpart.match(hostnamePartPattern)){var validParts=hostparts.slice(0,i);var notHost=hostparts.slice(i+1);var bit=part.match(hostnamePartStart);if(bit){validParts.push(bit[1]);notHost.unshift(bit[2]);}if(notHost.length){rest='/'+notHost.join('.')+rest;}this.hostname=validParts.join('.');break;}}}}if(this.hostname.length>hostnameMaxLen){this.hostname='';}else{// hostnames are always lower case.
this.hostname=this.hostname.toLowerCase();}if(!ipv6Hostname){// IDNA Support: Returns a punycoded representation of "domain".
// It only converts parts of the domain name that
// have non-ASCII characters, i.e. it doesn't matter if
// you call it with a domain that already is ASCII-only.
this.hostname=punycode.toASCII(this.hostname);}var p=this.port?':'+this.port:'';var h=this.hostname||'';this.host=h+p;this.href+=this.host;// strip [ and ] from the hostname
// the host field still retains them, though
if(ipv6Hostname){this.hostname=this.hostname.substr(1,this.hostname.length-2);if(rest[0]!=='/'){rest='/'+rest;}}}// now rest is set to the post-host stuff.
// chop off any delim chars.
if(!unsafeProtocol[lowerProto]){// First, make 100% sure that any "autoEscape" chars get
// escaped, even if encodeURIComponent doesn't think they
// need to be.
for(var i=0,l=autoEscape.length;i<l;i++){var ae=autoEscape[i];if(rest.indexOf(ae)===-1)continue;var esc=encodeURIComponent(ae);if(esc===ae){esc=escape(ae);}rest=rest.split(ae).join(esc);}}// chop off from the tail first.
var hash=rest.indexOf('#');if(hash!==-1){// got a fragment string.
this.hash=rest.substr(hash);rest=rest.slice(0,hash);}var qm=rest.indexOf('?');if(qm!==-1){this.search=rest.substr(qm);this.query=rest.substr(qm+1);if(parseQueryString){this.query=querystring.parse(this.query);}rest=rest.slice(0,qm);}else if(parseQueryString){// no query string, but parseQueryString still requested
this.search='';this.query={};}if(rest)this.pathname=rest;if(slashedProtocol[lowerProto]&&this.hostname&&!this.pathname){this.pathname='/';}//to support http.request
if(this.pathname||this.search){var p=this.pathname||'';var s=this.search||'';this.path=p+s;}// finally, reconstruct the href based on what has been validated.
this.href=this.format();return this;};// format a parsed object into a url string
function urlFormat(obj){// ensure it's an object, and not a string url.
// If it's an obj, this is a no-op.
// this way, you can call url_format() on strings
// to clean up potentially wonky urls.
if(util.isString(obj))obj=urlParse(obj);if(!(obj instanceof Url))return Url.prototype.format.call(obj);return obj.format();}Url.prototype.format=function(){var auth=this.auth||'';if(auth){auth=encodeURIComponent(auth);auth=auth.replace(/%3A/i,':');auth+='@';}var protocol=this.protocol||'',pathname=this.pathname||'',hash=this.hash||'',host=false,query='';if(this.host){host=auth+this.host;}else if(this.hostname){host=auth+(this.hostname.indexOf(':')===-1?this.hostname:'['+this.hostname+']');if(this.port){host+=':'+this.port;}}if(this.query&&util.isObject(this.query)&&Object.keys(this.query).length){query=querystring.stringify(this.query);}var search=this.search||query&&'?'+query||'';if(protocol&&protocol.substr(-1)!==':')protocol+=':';// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
// unless they had them to begin with.
if(this.slashes||(!protocol||slashedProtocol[protocol])&&host!==false){host='//'+(host||'');if(pathname&&pathname.charAt(0)!=='/')pathname='/'+pathname;}else if(!host){host='';}if(hash&&hash.charAt(0)!=='#')hash='#'+hash;if(search&&search.charAt(0)!=='?')search='?'+search;pathname=pathname.replace(/[?#]/g,function(match){return encodeURIComponent(match);});search=search.replace('#','%23');return protocol+host+pathname+search+hash;};function urlResolve(source,relative){return urlParse(source,false,true).resolve(relative);}Url.prototype.resolve=function(relative){return this.resolveObject(urlParse(relative,false,true)).format();};function urlResolveObject(source,relative){if(!source)return relative;return urlParse(source,false,true).resolveObject(relative);}Url.prototype.resolveObject=function(relative){if(util.isString(relative)){var rel=new Url();rel.parse(relative,false,true);relative=rel;}var result=new Url();var tkeys=Object.keys(this);for(var tk=0;tk<tkeys.length;tk++){var tkey=tkeys[tk];result[tkey]=this[tkey];}// hash is always overridden, no matter what.
// even href="" will remove it.
result.hash=relative.hash;// if the relative url is empty, then there's nothing left to do here.
if(relative.href===''){result.href=result.format();return result;}// hrefs like //foo/bar always cut to the protocol.
if(relative.slashes&&!relative.protocol){// take everything except the protocol from relative
var rkeys=Object.keys(relative);for(var rk=0;rk<rkeys.length;rk++){var rkey=rkeys[rk];if(rkey!=='protocol')result[rkey]=relative[rkey];}//urlParse appends trailing / to urls like http://www.example.com
if(slashedProtocol[result.protocol]&&result.hostname&&!result.pathname){result.path=result.pathname='/';}result.href=result.format();return result;}if(relative.protocol&&relative.protocol!==result.protocol){// if it's a known url protocol, then changing
// the protocol does weird things
// first, if it's not file:, then we MUST have a host,
// and if there was a path
// to begin with, then we MUST have a path.
// if it is file:, then the host is dropped,
// because that's known to be hostless.
// anything else is assumed to be absolute.
if(!slashedProtocol[relative.protocol]){var keys=Object.keys(relative);for(var v=0;v<keys.length;v++){var k=keys[v];result[k]=relative[k];}result.href=result.format();return result;}result.protocol=relative.protocol;if(!relative.host&&!hostlessProtocol[relative.protocol]){var relPath=(relative.pathname||'').split('/');while(relPath.length&&!(relative.host=relPath.shift())){;}if(!relative.host)relative.host='';if(!relative.hostname)relative.hostname='';if(relPath[0]!=='')relPath.unshift('');if(relPath.length<2)relPath.unshift('');result.pathname=relPath.join('/');}else{result.pathname=relative.pathname;}result.search=relative.search;result.query=relative.query;result.host=relative.host||'';result.auth=relative.auth;result.hostname=relative.hostname||relative.host;result.port=relative.port;// to support http.request
if(result.pathname||result.search){var p=result.pathname||'';var s=result.search||'';result.path=p+s;}result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;}var isSourceAbs=result.pathname&&result.pathname.charAt(0)==='/',isRelAbs=relative.host||relative.pathname&&relative.pathname.charAt(0)==='/',mustEndAbs=isRelAbs||isSourceAbs||result.host&&relative.pathname,removeAllDots=mustEndAbs,srcPath=result.pathname&&result.pathname.split('/')||[],relPath=relative.pathname&&relative.pathname.split('/')||[],psychotic=result.protocol&&!slashedProtocol[result.protocol];// if the url is a non-slashed url, then relative
// links like ../.. should be able
// to crawl up to the hostname, as well.  This is strange.
// result.protocol has already been set by now.
// Later on, put the first path part into the host field.
if(psychotic){result.hostname='';result.port=null;if(result.host){if(srcPath[0]==='')srcPath[0]=result.host;else srcPath.unshift(result.host);}result.host='';if(relative.protocol){relative.hostname=null;relative.port=null;if(relative.host){if(relPath[0]==='')relPath[0]=relative.host;else relPath.unshift(relative.host);}relative.host=null;}mustEndAbs=mustEndAbs&&(relPath[0]===''||srcPath[0]==='');}if(isRelAbs){// it's absolute.
result.host=relative.host||relative.host===''?relative.host:result.host;result.hostname=relative.hostname||relative.hostname===''?relative.hostname:result.hostname;result.search=relative.search;result.query=relative.query;srcPath=relPath;// fall through to the dot-handling below.
}else if(relPath.length){// it's relative
// throw away the existing file, and take the new path instead.
if(!srcPath)srcPath=[];srcPath.pop();srcPath=srcPath.concat(relPath);result.search=relative.search;result.query=relative.query;}else if(!util.isNullOrUndefined(relative.search)){// just pull out the search.
// like href='?foo'.
// Put this after the other two cases because it simplifies the booleans
if(psychotic){result.hostname=result.host=srcPath.shift();//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
var authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.host=result.hostname=authInHost.shift();}}result.search=relative.search;result.query=relative.query;//to support http.request
if(!util.isNull(result.pathname)||!util.isNull(result.search)){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.href=result.format();return result;}if(!srcPath.length){// no path at all.  easy.
// we've already handled the other stuff above.
result.pathname=null;//to support http.request
if(result.search){result.path='/'+result.search;}else{result.path=null;}result.href=result.format();return result;}// if a url ENDs in . or .., then it must get a trailing slash.
// however, if it ends in anything else non-slashy,
// then it must NOT get a trailing slash.
var last=srcPath.slice(-1)[0];var hasTrailingSlash=(result.host||relative.host||srcPath.length>1)&&(last==='.'||last==='..')||last==='';// strip single dots, resolve double dots to parent dir
// if the path tries to go above the root, `up` ends up > 0
var up=0;for(var i=srcPath.length;i>=0;i--){last=srcPath[i];if(last==='.'){srcPath.splice(i,1);}else if(last==='..'){srcPath.splice(i,1);up++;}else if(up){srcPath.splice(i,1);up--;}}// if the path is allowed to go above the root, restore leading ..s
if(!mustEndAbs&&!removeAllDots){for(;up--;up){srcPath.unshift('..');}}if(mustEndAbs&&srcPath[0]!==''&&(!srcPath[0]||srcPath[0].charAt(0)!=='/')){srcPath.unshift('');}if(hasTrailingSlash&&srcPath.join('/').substr(-1)!=='/'){srcPath.push('');}var isAbsolute=srcPath[0]===''||srcPath[0]&&srcPath[0].charAt(0)==='/';// put the host back
if(psychotic){result.hostname=result.host=isAbsolute?'':srcPath.length?srcPath.shift():'';//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
var authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.host=result.hostname=authInHost.shift();}}mustEndAbs=mustEndAbs||result.host&&srcPath.length;if(mustEndAbs&&!isAbsolute){srcPath.unshift('');}if(!srcPath.length){result.pathname=null;result.path=null;}else{result.pathname=srcPath.join('/');}//to support request.http
if(!util.isNull(result.pathname)||!util.isNull(result.search)){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.auth=relative.auth||result.auth;result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;};Url.prototype.parseHost=function(){var host=this.host;var port=portPattern.exec(host);if(port){port=port[0];if(port!==':'){this.port=port.substr(1);}host=host.substr(0,host.length-port.length);}if(host)this.hostname=host;};},{"./util":92,"punycode":73,"querystring":76}],92:[function(require,module,exports){'use strict';module.exports={isString:function isString(arg){return typeof arg==='string';},isObject:function isObject(arg){return _typeof(arg)==='object'&&arg!==null;},isNull:function isNull(arg){return arg===null;},isNullOrUndefined:function isNullOrUndefined(arg){return arg==null;}};},{}],93:[function(require,module,exports){module.exports=extend;var hasOwnProperty=Object.prototype.hasOwnProperty;function extend(){var target={};for(var i=0;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;}},{}],94:[function(require,module,exports){var htmlparser=require('htmlparser2');var extend=require('xtend');var quoteRegexp=require('lodash.escaperegexp');var cloneDeep=require('lodash.clonedeep');var mergeWith=require('lodash.mergewith');var isString=require('lodash.isstring');var isPlainObject=require('lodash.isplainobject');var srcset=require('srcset');var postcss=require('postcss');var url=require('url');function each(obj,cb){if(obj)Object.keys(obj).forEach(function(key){cb(obj[key],key);});}// Avoid false positives with .__proto__, .hasOwnProperty, etc.
function has(obj,key){return{}.hasOwnProperty.call(obj,key);}// Returns those elements of `a` for which `cb(a)` returns truthy
function filter(a,cb){var n=[];each(a,function(v){if(cb(v)){n.push(v);}});return n;}function isEmptyObject(obj){for(var key in obj){if(has(obj,key)){return false;}}return true;}module.exports=sanitizeHtml;// A valid attribute name.
// We use a tolerant definition based on the set of strings defined by
// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state
// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .
// The characters accepted are ones which can be appended to the attribute
// name buffer without triggering a parse error:
//   * unexpected-equals-sign-before-attribute-name
//   * unexpected-null-character
//   * unexpected-character-in-attribute-name
// We exclude the empty string because it's impossible to get to the after
// attribute name state with an empty attribute name buffer.
var VALID_HTML_ATTRIBUTE_NAME=/^[^\0\t\n\f\r /<=>]+$/;// Ignore the _recursing flag; it's there for recursive
// invocation as a guard against this exploit:
// https://github.com/fb55/htmlparser2/issues/105
function sanitizeHtml(html,options,_recursing){var result='';// Used for hot swapping the result variable with an empty string in order to "capture" the text written to it.
var tempResult='';function Frame(tag,attribs){var that=this;this.tag=tag;this.attribs=attribs||{};this.tagPosition=result.length;this.text='';// Node inner text
this.updateParentNodeText=function(){if(stack.length){var parentFrame=stack[stack.length-1];parentFrame.text+=that.text;}};}if(!options){options=sanitizeHtml.defaults;options.parser=htmlParserDefaults;}else{options=extend(sanitizeHtml.defaults,options);if(options.parser){options.parser=extend(htmlParserDefaults,options.parser);}else{options.parser=htmlParserDefaults;}}// Tags that contain something other than HTML, or where discarding
// the text when the tag is disallowed makes sense for other reasons.
// If we are not allowing these tags, we should drop their content too.
// For other tags you would drop the tag but keep its content.
var nonTextTagsArray=options.nonTextTags||['script','style','textarea'];var allowedAttributesMap;var allowedAttributesGlobMap;if(options.allowedAttributes){allowedAttributesMap={};allowedAttributesGlobMap={};each(options.allowedAttributes,function(attributes,tag){allowedAttributesMap[tag]=[];var globRegex=[];attributes.forEach(function(obj){if(isString(obj)&&obj.indexOf('*')>=0){globRegex.push(quoteRegexp(obj).replace(/\\\*/g,'.*'));}else{allowedAttributesMap[tag].push(obj);}});allowedAttributesGlobMap[tag]=new RegExp('^('+globRegex.join('|')+')$');});}var allowedClassesMap={};each(options.allowedClasses,function(classes,tag){// Implicitly allows the class attribute
if(allowedAttributesMap){if(!has(allowedAttributesMap,tag)){allowedAttributesMap[tag]=[];}allowedAttributesMap[tag].push('class');}allowedClassesMap[tag]=classes;});var transformTagsMap={};var transformTagsAll;each(options.transformTags,function(transform,tag){var transFun;if(typeof transform==='function'){transFun=transform;}else if(typeof transform==="string"){transFun=sanitizeHtml.simpleTransform(transform);}if(tag==='*'){transformTagsAll=transFun;}else{transformTagsMap[tag]=transFun;}});var depth=0;var stack=[];var skipMap={};var transformMap={};var skipText=false;var skipTextDepth=0;var parser=new htmlparser.Parser({onopentag:function onopentag(name,attribs){if(skipText){skipTextDepth++;return;}var frame=new Frame(name,attribs);stack.push(frame);var skip=false;var hasText=frame.text?true:false;var transformedTag;if(has(transformTagsMap,name)){transformedTag=transformTagsMap[name](name,attribs);frame.attribs=attribs=transformedTag.attribs;if(transformedTag.text!==undefined){frame.innerText=transformedTag.text;}if(name!==transformedTag.tagName){frame.name=name=transformedTag.tagName;transformMap[depth]=transformedTag.tagName;}}if(transformTagsAll){transformedTag=transformTagsAll(name,attribs);frame.attribs=attribs=transformedTag.attribs;if(name!==transformedTag.tagName){frame.name=name=transformedTag.tagName;transformMap[depth]=transformedTag.tagName;}}if(options.allowedTags&&options.allowedTags.indexOf(name)===-1||options.disallowedTagsMode==='recursiveEscape'&&!isEmptyObject(skipMap)){skip=true;skipMap[depth]=true;if(options.disallowedTagsMode==='discard'){if(nonTextTagsArray.indexOf(name)!==-1){skipText=true;skipTextDepth=1;}}skipMap[depth]=true;}depth++;if(skip){if(options.disallowedTagsMode==='discard'){// We want the contents but not this tag
return;}tempResult=result;result='';}result+='<'+name;if(!allowedAttributesMap||has(allowedAttributesMap,name)||allowedAttributesMap['*']){each(attribs,function(value,a){if(!VALID_HTML_ATTRIBUTE_NAME.test(a)){// This prevents part of an attribute name in the output from being
// interpreted as the end of an attribute, or end of a tag.
delete frame.attribs[a];return;}var parsed;// check allowedAttributesMap for the element and attribute and modify the value
// as necessary if there are specific values defined.
var passedAllowedAttributesMapCheck=false;if(!allowedAttributesMap||has(allowedAttributesMap,name)&&allowedAttributesMap[name].indexOf(a)!==-1||allowedAttributesMap['*']&&allowedAttributesMap['*'].indexOf(a)!==-1||has(allowedAttributesGlobMap,name)&&allowedAttributesGlobMap[name].test(a)||allowedAttributesGlobMap['*']&&allowedAttributesGlobMap['*'].test(a)){passedAllowedAttributesMapCheck=true;}else if(allowedAttributesMap&&allowedAttributesMap[name]){var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator10=allowedAttributesMap[name][Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator10.next()).done);_iteratorNormalCompletion=true){var o=_step.value;if(isPlainObject(o)&&o.name&&o.name===a){passedAllowedAttributesMapCheck=true;var newValue='';if(o.multiple===true){// verify the values that are allowed
var splitStrArray=value.split(' ');var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator11=splitStrArray[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator11.next()).done);_iteratorNormalCompletion2=true){var s=_step2.value;if(o.values.indexOf(s)!==-1){if(newValue===''){newValue=s;}else{newValue+=' '+s;}}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally{try{if(!_iteratorNormalCompletion2&&_iterator11["return"]!=null){_iterator11["return"]();}}finally{if(_didIteratorError2){throw _iteratorError2;}}}}else if(o.values.indexOf(value)>=0){// verified an allowed value matches the entire attribute value
newValue=value;}value=newValue;}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator10["return"]!=null){_iterator10["return"]();}}finally{if(_didIteratorError){throw _iteratorError;}}}}if(passedAllowedAttributesMapCheck){if(options.allowedSchemesAppliedToAttributes.indexOf(a)!==-1){if(naughtyHref(name,value)){delete frame.attribs[a];return;}}if(name==='iframe'&&a==='src'){var allowed=true;try{// naughtyHref is in charge of whether protocol relative URLs
// are cool. We should just accept them
parsed=url.parse(value,false,true);var isRelativeUrl=parsed&&parsed.host===null&&parsed.protocol===null;if(isRelativeUrl){// default value of allowIframeRelativeUrls is true unless allowIframeHostnames specified
allowed=has(options,"allowIframeRelativeUrls")?options.allowIframeRelativeUrls:!options.allowedIframeHostnames;}else if(options.allowedIframeHostnames){allowed=options.allowedIframeHostnames.find(function(hostname){return hostname===parsed.hostname;});}}catch(e){// Unparseable iframe src
allowed=false;}if(!allowed){delete frame.attribs[a];return;}}if(a==='srcset'){try{parsed=srcset.parse(value);each(parsed,function(value){if(naughtyHref('srcset',value.url)){value.evil=true;}});parsed=filter(parsed,function(v){return!v.evil;});if(!parsed.length){delete frame.attribs[a];return;}else{value=srcset.stringify(filter(parsed,function(v){return!v.evil;}));frame.attribs[a]=value;}}catch(e){// Unparseable srcset
delete frame.attribs[a];return;}}if(a==='class'){value=filterClasses(value,allowedClassesMap[name]);if(!value.length){delete frame.attribs[a];return;}}if(a==='style'){try{var abstractSyntaxTree=postcss.parse(name+" {"+value+"}");var filteredAST=filterCss(abstractSyntaxTree,options.allowedStyles);value=stringifyStyleAttributes(filteredAST);if(value.length===0){delete frame.attribs[a];return;}}catch(e){delete frame.attribs[a];return;}}result+=' '+a;if(value&&value.length){result+='="'+escapeHtml(value,true)+'"';}}else{delete frame.attribs[a];}});}if(options.selfClosing.indexOf(name)!==-1){result+=" />";}else{result+=">";if(frame.innerText&&!hasText&&!options.textFilter){result+=frame.innerText;}}if(skip){result=tempResult+escapeHtml(result);tempResult='';}},ontext:function ontext(text){if(skipText){return;}var lastFrame=stack[stack.length-1];var tag;if(lastFrame){tag=lastFrame.tag;// If inner text was set by transform function then let's use it
text=lastFrame.innerText!==undefined?lastFrame.innerText:text;}if(options.disallowedTagsMode==='discard'&&(tag==='script'||tag==='style')){// htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing
// script tags is, by definition, game over for XSS protection, so if that's
// your concern, don't allow them. The same is essentially true for style tags
// which have their own collection of XSS vectors.
result+=text;}else{var escaped=escapeHtml(text,false);if(options.textFilter){result+=options.textFilter(escaped);}else{result+=escaped;}}if(stack.length){var frame=stack[stack.length-1];frame.text+=text;}},onclosetag:function onclosetag(name){if(skipText){skipTextDepth--;if(!skipTextDepth){skipText=false;}else{return;}}var frame=stack.pop();if(!frame){// Do not crash on bad markup
return;}skipText=false;depth--;var skip=skipMap[depth];if(skip){delete skipMap[depth];if(options.disallowedTagsMode==='discard'){frame.updateParentNodeText();return;}tempResult=result;result='';}if(transformMap[depth]){name=transformMap[depth];delete transformMap[depth];}if(options.exclusiveFilter&&options.exclusiveFilter(frame)){result=result.substr(0,frame.tagPosition);return;}frame.updateParentNodeText();if(options.selfClosing.indexOf(name)!==-1){// Already output />
return;}result+="</"+name+">";if(skip){result=tempResult+escapeHtml(result);tempResult='';}}},options.parser);parser.write(html);parser.end();return result;function escapeHtml(s,quote){if(typeof s!=='string'){s=s+'';}if(options.parser.decodeEntities){s=s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/\>/g,'&gt;');if(quote){s=s.replace(/\"/g,'&quot;');}}// TODO: this is inadequate because it will pass `&0;`. This approach
// will not work, each & must be considered with regard to whether it
// is followed by a 100% syntactically valid entity or not, and escaped
// if it is not. If this bothers you, don't set parser.decodeEntities
// to false. (The default is true.)
s=s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g,'&amp;')// Match ampersands not part of existing HTML entity
.replace(/</g,'&lt;').replace(/\>/g,'&gt;');if(quote){s=s.replace(/\"/g,'&quot;');}return s;}function naughtyHref(name,href){// Browsers ignore character codes of 32 (space) and below in a surprising
// number of situations. Start reading here:
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab
href=href.replace(/[\x00-\x20]+/g,'');// Clobber any comments in URLs, which the browser might
// interpret inside an XML data island, allowing
// a javascript: URL to be snuck through
href=href.replace(/<\!\-\-.*?\-\-\>/g,'');// Case insensitive so we don't get faked out by JAVASCRIPT #1
var matches=href.match(/^([a-zA-Z]+)\:/);if(!matches){// Protocol-relative URL starting with any combination of '/' and '\'
if(href.match(/^[\/\\]{2}/)){return!options.allowProtocolRelative;}// No scheme
return false;}var scheme=matches[1].toLowerCase();if(has(options.allowedSchemesByTag,name)){return options.allowedSchemesByTag[name].indexOf(scheme)===-1;}return!options.allowedSchemes||options.allowedSchemes.indexOf(scheme)===-1;}/**
   * Filters user input css properties by whitelisted regex attributes.
   *
   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.
   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.
   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).
   * @return {object}                    - Abstract Syntax Tree with filtered style attributes.
   */function filterCss(abstractSyntaxTree,allowedStyles){if(!allowedStyles){return abstractSyntaxTree;}var filteredAST=cloneDeep(abstractSyntaxTree);var astRules=abstractSyntaxTree.nodes[0];var selectedRule;// Merge global and tag-specific styles into new AST.
if(allowedStyles[astRules.selector]&&allowedStyles['*']){selectedRule=mergeWith(cloneDeep(allowedStyles[astRules.selector]),allowedStyles['*'],function(objValue,srcValue){if(Array.isArray(objValue)){return objValue.concat(srcValue);}});}else{selectedRule=allowedStyles[astRules.selector]||allowedStyles['*'];}if(selectedRule){filteredAST.nodes[0].nodes=astRules.nodes.reduce(filterDeclarations(selectedRule),[]);}return filteredAST;}/**
   * Extracts the style attribues from an AbstractSyntaxTree and formats those
   * values in the inline style attribute format.
   *
   * @param  {AbstractSyntaxTree} filteredAST
   * @return {string}             - Example: "color:yellow;text-align:center;font-family:helvetica;"
   */function stringifyStyleAttributes(filteredAST){return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes,attributeObject){extractedAttributes.push(attributeObject.prop+':'+attributeObject.value);return extractedAttributes;},[]).join(';');}/**
    * Filters the existing attributes for the given property. Discards any attributes
    * which don't match the whitelist.
    *
    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }
    * @param  {array} allowedDeclarationsList   - List of declarations which pass whitelisting.
    * @param  {object} attributeObject          - Object representing the current css property.
    * @property {string} attributeObject.type   - Typically 'declaration'.
    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.
    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.
    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects
    */function filterDeclarations(selectedRule){return function(allowedDeclarationsList,attributeObject){// If this property is whitelisted...
if(selectedRule.hasOwnProperty(attributeObject.prop)){var matchesRegex=selectedRule[attributeObject.prop].some(function(regularExpression){return regularExpression.test(attributeObject.value);});if(matchesRegex){allowedDeclarationsList.push(attributeObject);}}return allowedDeclarationsList;};}function filterClasses(classes,allowed){if(!allowed){// The class attribute is allowed without filtering on this tag
return classes;}classes=classes.split(/\s+/);return classes.filter(function(clss){return allowed.indexOf(clss)!==-1;}).join(' ');}}// Defaults are accessible to you so that you can use them as a starting point
// programmatically if you wish
var htmlParserDefaults={decodeEntities:true};sanitizeHtml.defaults={allowedTags:['h3','h4','h5','h6','blockquote','p','a','ul','ol','nl','li','b','i','strong','em','strike','code','hr','br','div','table','thead','caption','tbody','tr','th','td','pre','iframe'],disallowedTagsMode:'discard',allowedAttributes:{a:['href','name','target'],// We don't currently allow img itself by default, but this
// would make sense if we did. You could add srcset here,
// and if you do the URL is checked for safety
img:['src']},// Lots of these won't come up by default because we don't allow them
selfClosing:['img','br','hr','area','base','basefont','input','link','meta'],// URL schemes we permit
allowedSchemes:['http','https','ftp','mailto'],allowedSchemesByTag:{},allowedSchemesAppliedToAttributes:['href','src','cite'],allowProtocolRelative:true};sanitizeHtml.simpleTransform=function(newTagName,newAttribs,merge){merge=merge===undefined?true:merge;newAttribs=newAttribs||{};return function(tagName,attribs){var attrib;if(merge){for(attrib in newAttribs){attribs[attrib]=newAttribs[attrib];}}else{attribs=newAttribs;}return{tagName:newTagName,attribs:attribs};};};},{"htmlparser2":39,"lodash.clonedeep":42,"lodash.escaperegexp":43,"lodash.isplainobject":44,"lodash.isstring":45,"lodash.mergewith":46,"postcss":60,"srcset":89,"url":91,"xtend":93}]},{},[94])(94);});
//static-content-hash-trigger-GCC
if (!pega)
	var pega = {};

if (!pega.chat)
  	pega.chat = {};

pega.CSPubSub = function() {
   this.subscribers = {};
};
pega.CSPubSub.prototype = {
  publish: function(id,event, data){
    if(!this.subscribers[id][event]) return;
    this.subscribers[id][event](data);
  },
  subscribe: function(id,event,callback){
    if(!this.subscribers[id]){
      this.subscribers[id] = {};
    }
    this.subscribers[id][event] = callback;   
    
  },
  unsubscribe: function(id,event){
    if(this.subscribers[id]){
      if(event){
        delete this.subscribers[id][event];
      }else{
        delete this.subscribers[id];
      }      
    }
  }
}


window.CSPubSub = new pega.CSPubSub();
//static-content-hash-trigger-GCC
//static-content-hash-trigger-GCC

if (!pega)
	var pega = {};

if (!pega.knowledge)
  	pega.knowledge = {};

/**
Object to handle 
**/
pega.knowledge.KnowledgeComponentEventHandler = function(){
  this.subscribers = [];
  
}
pega.knowledge.KnowledgeComponentEventHandler.prototype = {
   subscribeEvents: function(interactionId){
       pega.desktop.support.getDesktopWindow().CSPubSub.subscribe(interactionId, "RELOAD", this.sendMessage);
       pega.desktop.support.getDesktopWindow().CSPubSub.subscribe(interactionId, "PUSH ARTICLE LINK", this.pushKMArticleLink);
       pega.desktop.support.getDesktopWindow().CSPubSub.subscribe(interactionId, "PUSH ARTICLE CONTENT", this.pushKMArticleContent);
   },
   unsubscribeEvents: function(interactionId){
       pega.desktop.support.getDesktopWindow().CSPubSub.unsubscribe(interactionId, "RELOAD");
       pega.desktop.support.getDesktopWindow().CSPubSub.subscribe(interactionId, "PUSH ARTICLE LINK");
       pega.desktop.support.getDesktopWindow().CSPubSub.subscribe(interactionId, "PUSH ARTICLE CONTENT");
   },
  pushKMArticleLink: function(data) {
    if(data.channelType == "email"){      
      //pega.cs.textchannel.handleArtilclePushKMReact(data.event, data.leadInText,"D_SelectedArticle", data.setLeadInText, data.setShareAbstract,data.pushArticleContentLabel,data.pushArticleLinkLabel);
    }
    else{
        data.articleAbstract = data.articleAbstract.replace(/(?:\\[rn])+/g, "");
	      var LeadInText = (data.setLeadInText === 'true') ? data.leadInText: "";
        var Abstract = (data.setShareAbstract === 'true') ? data.articleAbstract : "";
        if(data.articleTitle.length>36){
          data.articleTitle=data.articleTitle.substr(0,33);
          data.articleTitle=data.articleTitle + "..."
        }
        var finalurl = "<a class=\"articlelink\" data-articleid=\"" + data.articleID + "\" href=\"" + data.shareableURL + "\">" + data.articleTitle + "</a>";
        var KMArticleLink = (Abstract !== "") ? (LeadInText + Abstract + finalurl) : (LeadInText + finalurl);
	      var linkData = { "KMArticleLink" : KMArticleLink,
                          "isLinkAttached" : true,
                          "linkTitle":data.articleTitle,
                          "linkHref":data.shareableURL,
                          "linkText":LeadInText==""?data.articleTitle:LeadInText
                       }
	      pega.desktop.support.getDesktopWindow().CSPubSub.publish(data.interactionID, "PUSH KM ARTICLE LINK",linkData);
    }
   },
  pushKMArticleContent: function(data) {
       	pega.desktop.support.getDesktopWindow().CSPubSub.publish(data.interactionID, "PUSH KM ARTICLE CONTENT",data);

  },
   publishKMEvent:function(id,event,data){
     switch(event){
       case "SHOW ARTICLE":
         pega.desktop.support.getDesktopWindow().CSPubSub.publish(id,"SHOW ARTICLE",data);
         break;
       case "CHANGE CONTEXT":
         pega.desktop.support.getDesktopWindow().CSPubSub.publish(id,"CHANGE CONTEXT",data);
         break;
       case "PUSH ARTICLE":
         pega.desktop.support.getDesktopWindow().CSPubSub.publish(id,"PUSH ARTICLE",data);
         break;
     }
     
   }
}

window.knowledge = new pega.knowledge.KnowledgeComponentEventHandler();
//static-content-hash-trigger-GCC
/**
 * Fuse.js v6.4.6 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2021 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
      (global = global || self, global.Fuse = factory());
}(this, (function() {
  'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function isArray(value) {
    return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);
  } // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js

  var INFINITY = 1 / 0;

  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  function isString(value) {
    return typeof value === 'string';
  }

  function isNumber(value) {
    return typeof value === 'number';
  } // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js

  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';
  }

  function isObject(value) {
    return _typeof(value) === 'object';
  } // Checks if `value` is object-like.

  function isObjectLike(value) {
    return isObject(value) && value !== null;
  }

  function isDefined(value) {
    return value !== undefined && value !== null;
  }

  function isBlank(value) {
    return !value.trim().length;
  } // Gets the `toStringTag` of `value`.
  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js

  function getTag(value) {
    return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);
  }

  var EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';
  var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
  var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key) {
    return "Invalid value for key ".concat(key);
  };
  var PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE(max) {
    return "Pattern length exceeds max of ".concat(max, ".");
  };
  var MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY(name) {
    return "Missing ".concat(name, " property in key");
  };
  var INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE(key) {
    return "Property 'weight' in key '".concat(key, "' must be a positive integer");
  };

  var hasOwn = Object.prototype.hasOwnProperty;

  var KeyStore = /*#__PURE__*/ function() {
    function KeyStore(keys) {
      var _this = this;

      _classCallCheck(this, KeyStore);

      this._keys = [];
      this._keyMap = {};
      var totalWeight = 0;
      keys.forEach(function(key) {
        var obj = createKey(key);
        totalWeight += obj.weight;

        _this._keys.push(obj);

        _this._keyMap[obj.id] = obj;
        totalWeight += obj.weight;
      }); // Normalize weights so that their sum is equal to 1

      this._keys.forEach(function(key) {
        key.weight /= totalWeight;
      });
    }

    _createClass(KeyStore, [{
      key: "get",
      value: function get(keyId) {
        return this._keyMap[keyId];
      }
    }, {
      key: "keys",
      value: function keys() {
        return this._keys;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return JSON.stringify(this._keys);
      }
    }]);

    return KeyStore;
  }();

  function createKey(key) {
    var path = null;
    var id = null;
    var src = null;
    var weight = 1;

    if (isString(key) || isArray(key)) {
      src = key;
      path = createKeyPath(key);
      id = createKeyId(key);
    } else {
      if (!hasOwn.call(key, 'name')) {
        throw new Error(MISSING_KEY_PROPERTY('name'));
      }

      var name = key.name;
      src = name;

      if (hasOwn.call(key, 'weight')) {
        weight = key.weight;

        if (weight <= 0) {
          throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
        }
      }

      path = createKeyPath(name);
      id = createKeyId(name);
    }

    return {
      path: path,
      id: id,
      weight: weight,
      src: src
    };
  }

  function createKeyPath(key) {
    return isArray(key) ? key : key.split('.');
  }

  function createKeyId(key) {
    return isArray(key) ? key.join('.') : key;
  }

  function get(obj, path) {
    var list = [];
    var arr = false;

    var deepGet = function deepGet(obj, path, index) {
      if (!isDefined(obj)) {
        return;
      }

      if (!path[index]) {
        // If there's no path left, we've arrived at the object we care about.
        list.push(obj);
      } else {
        var key = path[index];
        var value = obj[key];

        if (!isDefined(value)) {
          return;
        } // If we're at the last value in the path, and if it's a string/number/bool,
        // add it to the list


        if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
          list.push(toString(value));
        } else if (isArray(value)) {
          arr = true; // Search each item in the array.

          for (var i = 0, len = value.length; i < len; i += 1) {
            deepGet(value[i], path, index + 1);
          }
        } else if (path.length) {
          // An object. Recurse further.
          deepGet(value, path, index + 1);
        }
      }
    }; // Backwards compatibility (since path used to be a string)


    deepGet(obj, isString(path) ? path.split('.') : path, 0);
    return arr ? list : list[0];
  }

  var MatchOptions = {
    // Whether the matches should be included in the result set. When `true`, each record in the result
    // set will include the indices of the matched characters.
    // These can consequently be used for highlighting purposes.
    includeMatches: false,
    // When `true`, the matching function will continue to the end of a search pattern even if
    // a perfect match has already been located in the string.
    findAllMatches: false,
    // Minimum number of characters that must be matched before a result is considered a match
    minMatchCharLength: 1
  };
  var BasicOptions = {
    // When `true`, the algorithm continues searching to the end of the input even if a perfect
    // match is found before the end of the same input.
    isCaseSensitive: false,
    // When true, the matching function will continue to the end of a search pattern even if
    includeScore: false,
    // List of properties that will be searched. This also supports nested properties.
    keys: [],
    // Whether to sort the result list, by score
    shouldSort: true,
    // Default sort function: sort by ascending score, ascending index
    sortFn: function sortFn(a, b) {
      return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;
    }
  };
  var FuzzyOptions = {
    // Approximately where in the text is the pattern expected to be found?
    location: 0,
    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    // (of both letters and location), a threshold of '1.0' would match anything.
    threshold: 0.6,
    // Determines how close the match must be to the fuzzy location (specified above).
    // An exact letter match which is 'distance' characters away from the fuzzy location
    // would score as a complete mismatch. A distance of '0' requires the match be at
    // the exact location specified, a threshold of '1000' would require a perfect match
    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    distance: 100
  };
  var AdvancedOptions = {
    // When `true`, it enables the use of unix-like search commands
    useExtendedSearch: false,
    // The get function to use when fetching an object's properties.
    // The default will search nested paths *ie foo.bar.baz*
    getFn: get,
    // When `true`, search will ignore `location` and `distance`, so it won't matter
    // where in the string the pattern appears.
    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
    ignoreLocation: false,
    // When `true`, the calculation for the relevance score (used for sorting) will
    // ignore the field-length norm.
    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
    ignoreFieldNorm: false
  };
  var Config = _objectSpread2({}, BasicOptions, {}, MatchOptions, {}, FuzzyOptions, {}, AdvancedOptions);

  var SPACE = /[^ ]+/g; // Field-length norm: the shorter the field, the higher the weight.
  // Set to 3 decimals to reduce index size.

  function norm() {
    var mantissa = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
    var cache = new Map();
    var m = Math.pow(10, mantissa);
    return {
      get: function get(value) {
        var numTokens = value.match(SPACE).length;

        if (cache.has(numTokens)) {
          return cache.get(numTokens);
        }

        var norm = 1 / Math.sqrt(numTokens); // In place of `toFixed(mantissa)`, for faster computation

        var n = parseFloat(Math.round(norm * m) / m);
        cache.set(numTokens, n);
        return n;
      },
      clear: function clear() {
        cache.clear();
      }
    };
  }

  var FuseIndex = /*#__PURE__*/ function() {
    function FuseIndex() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$getFn = _ref.getFn,
        getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn;

      _classCallCheck(this, FuseIndex);

      this.norm = norm(3);
      this.getFn = getFn;
      this.isCreated = false;
      this.setIndexRecords();
    }

    _createClass(FuseIndex, [{
      key: "setSources",
      value: function setSources() {
        var docs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.docs = docs;
      }
    }, {
      key: "setIndexRecords",
      value: function setIndexRecords() {
        var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.records = records;
      }
    }, {
      key: "setKeys",
      value: function setKeys() {
        var _this = this;

        var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.keys = keys;
        this._keysMap = {};
        keys.forEach(function(key, idx) {
          _this._keysMap[key.id] = idx;
        });
      }
    }, {
      key: "create",
      value: function create() {
        var _this2 = this;

        if (this.isCreated || !this.docs.length) {
          return;
        }

        this.isCreated = true; // List is Array<String>

        if (isString(this.docs[0])) {
          this.docs.forEach(function(doc, docIndex) {
            _this2._addString(doc, docIndex);
          });
        } else {
          // List is Array<Object>
          this.docs.forEach(function(doc, docIndex) {
            _this2._addObject(doc, docIndex);
          });
        }

        this.norm.clear();
      } // Adds a doc to the end of the index

    }, {
      key: "add",
      value: function add(doc) {
        var idx = this.size();

        if (isString(doc)) {
          this._addString(doc, idx);
        } else {
          this._addObject(doc, idx);
        }
      } // Removes the doc at the specified index of the index

    }, {
      key: "removeAt",
      value: function removeAt(idx) {
        this.records.splice(idx, 1); // Change ref index of every subsquent doc

        for (var i = idx, len = this.size(); i < len; i += 1) {
          this.records[i].i -= 1;
        }
      }
    }, {
      key: "getValueForItemAtKeyId",
      value: function getValueForItemAtKeyId(item, keyId) {
        return item[this._keysMap[keyId]];
      }
    }, {
      key: "size",
      value: function size() {
        return this.records.length;
      }
    }, {
      key: "_addString",
      value: function _addString(doc, docIndex) {
        if (!isDefined(doc) || isBlank(doc)) {
          return;
        }

        var record = {
          v: doc,
          i: docIndex,
          n: this.norm.get(doc)
        };
        this.records.push(record);
      }
    }, {
      key: "_addObject",
      value: function _addObject(doc, docIndex) {
        var _this3 = this;

        var record = {
          i: docIndex,
          $: {}
        }; // Iterate over every key (i.e, path), and fetch the value at that key

        this.keys.forEach(function(key, keyIndex) {
          // console.log(key)
          var value = _this3.getFn(doc, key.path);

          if (!isDefined(value)) {
            return;
          }

          if (isArray(value)) {
            (function() {
              var subRecords = [];
              var stack = [{
                nestedArrIndex: -1,
                value: value
              }];

              while (stack.length) {
                var _stack$pop = stack.pop(),
                  nestedArrIndex = _stack$pop.nestedArrIndex,
                  _value = _stack$pop.value;

                if (!isDefined(_value)) {
                  continue;
                }

                if (isString(_value) && !isBlank(_value)) {
                  var subRecord = {
                    v: _value,
                    i: nestedArrIndex,
                    n: _this3.norm.get(_value)
                  };
                  subRecords.push(subRecord);
                } else if (isArray(_value)) {
                  _value.forEach(function(item, k) {
                    stack.push({
                      nestedArrIndex: k,
                      value: item
                    });
                  });
                }
              }

              record.$[keyIndex] = subRecords;
            })();
          } else if (!isBlank(value)) {
            var subRecord = {
              v: value,
              n: _this3.norm.get(value)
            };
            record.$[keyIndex] = subRecord;
          }
        });
        this.records.push(record);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          keys: this.keys,
          records: this.records
        };
      }
    }]);

    return FuseIndex;
  }();

  function createIndex(keys, docs) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$getFn = _ref2.getFn,
      getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn;

    var myIndex = new FuseIndex({
      getFn: getFn
    });
    myIndex.setKeys(keys.map(createKey));
    myIndex.setSources(docs);
    myIndex.create();
    return myIndex;
  }

  function parseIndex(data) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$getFn = _ref3.getFn,
      getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn;

    var keys = data.keys,
      records = data.records;
    var myIndex = new FuseIndex({
      getFn: getFn
    });
    myIndex.setKeys(keys);
    myIndex.setIndexRecords(records);
    return myIndex;
  }

  function computeScore(pattern) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$errors = _ref.errors,
      errors = _ref$errors === void 0 ? 0 : _ref$errors,
      _ref$currentLocation = _ref.currentLocation,
      currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,
      _ref$expectedLocation = _ref.expectedLocation,
      expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
      _ref$ignoreLocation = _ref.ignoreLocation,
      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;

    var accuracy = errors / pattern.length;

    if (ignoreLocation) {
      return accuracy;
    }

    var proximity = Math.abs(expectedLocation - currentLocation);

    if (!distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }

    return accuracy + proximity / distance;
  }

  function convertMaskToIndices() {
    var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Config.minMatchCharLength;
    var indices = [];
    var start = -1;
    var end = -1;
    var i = 0;

    for (var len = matchmask.length; i < len; i += 1) {
      var match = matchmask[i];

      if (match && start === -1) {
        start = i;
      } else if (!match && start !== -1) {
        end = i - 1;

        if (end - start + 1 >= minMatchCharLength) {
          indices.push([start, end]);
        }

        start = -1;
      }
    } // (i-1 - start) + 1 => i - start


    if (matchmask[i - 1] && i - start >= minMatchCharLength) {
      indices.push([start, i - 1]);
    }

    return indices;
  }

  // Machine word size
  var MAX_BITS = 32;

  function search(text, pattern, patternAlphabet) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref$location = _ref.location,
      location = _ref$location === void 0 ? Config.location : _ref$location,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
      _ref$threshold = _ref.threshold,
      threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
      _ref$findAllMatches = _ref.findAllMatches,
      findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
      _ref$minMatchCharLeng = _ref.minMatchCharLength,
      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
      _ref$includeMatches = _ref.includeMatches,
      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
      _ref$ignoreLocation = _ref.ignoreLocation,
      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;

    if (pattern.length > MAX_BITS) {
      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
    }

    var patternLen = pattern.length; // Set starting location at beginning text and initialize the alphabet.

    var textLen = text.length; // Handle the case when location > text.length

    var expectedLocation = Math.max(0, Math.min(location, textLen)); // Highest score beyond which we give up.

    var currentThreshold = threshold; // Is there a nearby exact match? (speedup)

    var bestLocation = expectedLocation; // Performance: only computer matches when the minMatchCharLength > 1
    // OR if `includeMatches` is true.

    var computeMatches = minMatchCharLength > 1 || includeMatches; // A mask of the matches, used for building the indices

    var matchMask = computeMatches ? Array(textLen) : [];
    var index; // Get all exact matches, here for speed up

    while ((index = text.indexOf(pattern, bestLocation)) > -1) {
      var score = computeScore(pattern, {
        currentLocation: index,
        expectedLocation: expectedLocation,
        distance: distance,
        ignoreLocation: ignoreLocation
      });
      currentThreshold = Math.min(score, currentThreshold);
      bestLocation = index + patternLen;

      if (computeMatches) {
        var i = 0;

        while (i < patternLen) {
          matchMask[index + i] = 1;
          i += 1;
        }
      }
    } // Reset the best location


    bestLocation = -1;
    var lastBitArr = [];
    var finalScore = 1;
    var binMax = patternLen + textLen;
    var mask = 1 << patternLen - 1;

    for (var _i = 0; _i < patternLen; _i += 1) {
      // Scan for the best match; each iteration allows for one more error.
      // Run a binary search to determine how far from the match location we can stray
      // at this error level.
      var binMin = 0;
      var binMid = binMax;

      while (binMin < binMid) {
        var _score2 = computeScore(pattern, {
          errors: _i,
          currentLocation: expectedLocation + binMid,
          expectedLocation: expectedLocation,
          distance: distance,
          ignoreLocation: ignoreLocation
        });

        if (_score2 <= currentThreshold) {
          binMin = binMid;
        } else {
          binMax = binMid;
        }

        binMid = Math.floor((binMax - binMin) / 2 + binMin);
      } // Use the result from this iteration as the maximum for the next.


      binMax = binMid;
      var start = Math.max(1, expectedLocation - binMid + 1);
      var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen; // Initialize the bit array

      var bitArr = Array(finish + 2);
      bitArr[finish + 1] = (1 << _i) - 1;

      for (var j = finish; j >= start; j -= 1) {
        var currentLocation = j - 1;
        var charMatch = patternAlphabet[text.charAt(currentLocation)];

        if (computeMatches) {
          // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
          matchMask[currentLocation] = +!!charMatch;
        } // First pass: exact match


        bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch; // Subsequent passes: fuzzy match

        if (_i) {
          bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
        }

        if (bitArr[j] & mask) {
          finalScore = computeScore(pattern, {
            errors: _i,
            currentLocation: currentLocation,
            expectedLocation: expectedLocation,
            distance: distance,
            ignoreLocation: ignoreLocation
          }); // This match will almost certainly be better than any existing match.
          // But check anyway.

          if (finalScore <= currentThreshold) {
            // Indeed it is
            currentThreshold = finalScore;
            bestLocation = currentLocation; // Already passed `loc`, downhill from here on in.

            if (bestLocation <= expectedLocation) {
              break;
            } // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.


            start = Math.max(1, 2 * expectedLocation - bestLocation);
          }
        }
      } // No hope for a (better) match at greater error levels.


      var _score = computeScore(pattern, {
        errors: _i + 1,
        currentLocation: expectedLocation,
        expectedLocation: expectedLocation,
        distance: distance,
        ignoreLocation: ignoreLocation
      });

      if (_score > currentThreshold) {
        break;
      }

      lastBitArr = bitArr;
    }

    var result = {
      isMatch: bestLocation >= 0,
      // Count exact matches (those with a score of 0) to be "almost" exact
      score: Math.max(0.001, finalScore)
    };

    if (computeMatches) {
      var indices = convertMaskToIndices(matchMask, minMatchCharLength);

      if (!indices.length) {
        result.isMatch = false;
      } else if (includeMatches) {
        result.indices = indices;
      }
    }

    return result;
  }

  function createPatternAlphabet(pattern) {
    var mask = {};

    for (var i = 0, len = pattern.length; i < len; i += 1) {
      var char = pattern.charAt(i);
      mask[char] = (mask[char] || 0) | 1 << len - i - 1;
    }

    return mask;
  }

  var BitapSearch = /*#__PURE__*/ function() {
    function BitapSearch(pattern) {
      var _this = this;

      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;

      _classCallCheck(this, BitapSearch);

      this.options = {
        location: location,
        threshold: threshold,
        distance: distance,
        includeMatches: includeMatches,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength,
        isCaseSensitive: isCaseSensitive,
        ignoreLocation: ignoreLocation
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.chunks = [];

      if (!this.pattern.length) {
        return;
      }

      var addChunk = function addChunk(pattern, startIndex) {
        _this.chunks.push({
          pattern: pattern,
          alphabet: createPatternAlphabet(pattern),
          startIndex: startIndex
        });
      };

      var len = this.pattern.length;

      if (len > MAX_BITS) {
        var i = 0;
        var remainder = len % MAX_BITS;
        var end = len - remainder;

        while (i < end) {
          addChunk(this.pattern.substr(i, MAX_BITS), i);
          i += MAX_BITS;
        }

        if (remainder) {
          var startIndex = len - MAX_BITS;
          addChunk(this.pattern.substr(startIndex), startIndex);
        }
      } else {
        addChunk(this.pattern, 0);
      }
    }

    _createClass(BitapSearch, [{
      key: "searchIn",
      value: function searchIn(text) {
        var _this$options = this.options,
          isCaseSensitive = _this$options.isCaseSensitive,
          includeMatches = _this$options.includeMatches;

        if (!isCaseSensitive) {
          text = text.toLowerCase();
        } // Exact match


        if (this.pattern === text) {
          var _result = {
            isMatch: true,
            score: 0
          };

          if (includeMatches) {
            _result.indices = [
              [0, text.length - 1]
            ];
          }

          return _result;
        } // Otherwise, use Bitap algorithm


        var _this$options2 = this.options,
          location = _this$options2.location,
          distance = _this$options2.distance,
          threshold = _this$options2.threshold,
          findAllMatches = _this$options2.findAllMatches,
          minMatchCharLength = _this$options2.minMatchCharLength,
          ignoreLocation = _this$options2.ignoreLocation;
        var allIndices = [];
        var totalScore = 0;
        var hasMatches = false;
        this.chunks.forEach(function(_ref2) {
          var pattern = _ref2.pattern,
            alphabet = _ref2.alphabet,
            startIndex = _ref2.startIndex;

          var _search = search(text, pattern, alphabet, {
              location: location + startIndex,
              distance: distance,
              threshold: threshold,
              findAllMatches: findAllMatches,
              minMatchCharLength: minMatchCharLength,
              includeMatches: includeMatches,
              ignoreLocation: ignoreLocation
            }),
            isMatch = _search.isMatch,
            score = _search.score,
            indices = _search.indices;

          if (isMatch) {
            hasMatches = true;
          }

          totalScore += score;

          if (isMatch && indices) {
            allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
          }
        });
        var result = {
          isMatch: hasMatches,
          score: hasMatches ? totalScore / this.chunks.length : 1
        };

        if (hasMatches && includeMatches) {
          result.indices = allIndices;
        }

        return result;
      }
    }]);

    return BitapSearch;
  }();

  var BaseMatch = /*#__PURE__*/ function() {
    function BaseMatch(pattern) {
      _classCallCheck(this, BaseMatch);

      this.pattern = pattern;
    }

    _createClass(BaseMatch, [{
      key: "search",
      value: function search()
      /*text*/
      {}
    }], [{
      key: "isMultiMatch",
      value: function isMultiMatch(pattern) {
        return getMatch(pattern, this.multiRegex);
      }
    }, {
      key: "isSingleMatch",
      value: function isSingleMatch(pattern) {
        return getMatch(pattern, this.singleRegex);
      }
    }]);

    return BaseMatch;
  }();

  function getMatch(pattern, exp) {
    var matches = pattern.match(exp);
    return matches ? matches[1] : null;
  }

  var ExactMatch = /*#__PURE__*/ function(_BaseMatch) {
    _inherits(ExactMatch, _BaseMatch);

    var _super = _createSuper(ExactMatch);

    function ExactMatch(pattern) {
      _classCallCheck(this, ExactMatch);

      return _super.call(this, pattern);
    }

    _createClass(ExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text === this.pattern;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^="(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^=(.*)$/;
      }
    }]);

    return ExactMatch;
  }(BaseMatch);

  var InverseExactMatch = /*#__PURE__*/ function(_BaseMatch) {
    _inherits(InverseExactMatch, _BaseMatch);

    var _super = _createSuper(InverseExactMatch);

    function InverseExactMatch(pattern) {
      _classCallCheck(this, InverseExactMatch);

      return _super.call(this, pattern);
    }

    _createClass(InverseExactMatch, [{
      key: "search",
      value: function search(text) {
        var index = text.indexOf(this.pattern);
        var isMatch = index === -1;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!(.*)$/;
      }
    }]);

    return InverseExactMatch;
  }(BaseMatch);

  var PrefixExactMatch = /*#__PURE__*/ function(_BaseMatch) {
    _inherits(PrefixExactMatch, _BaseMatch);

    var _super = _createSuper(PrefixExactMatch);

    function PrefixExactMatch(pattern) {
      _classCallCheck(this, PrefixExactMatch);

      return _super.call(this, pattern);
    }

    _createClass(PrefixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text.startsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'prefix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^\^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^\^(.*)$/;
      }
    }]);

    return PrefixExactMatch;
  }(BaseMatch);

  var InversePrefixExactMatch = /*#__PURE__*/ function(_BaseMatch) {
    _inherits(InversePrefixExactMatch, _BaseMatch);

    var _super = _createSuper(InversePrefixExactMatch);

    function InversePrefixExactMatch(pattern) {
      _classCallCheck(this, InversePrefixExactMatch);

      return _super.call(this, pattern);
    }

    _createClass(InversePrefixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = !text.startsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-prefix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!\^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!\^(.*)$/;
      }
    }]);

    return InversePrefixExactMatch;
  }(BaseMatch);

  var SuffixExactMatch = /*#__PURE__*/ function(_BaseMatch) {
    _inherits(SuffixExactMatch, _BaseMatch);

    var _super = _createSuper(SuffixExactMatch);

    function SuffixExactMatch(pattern) {
      _classCallCheck(this, SuffixExactMatch);

      return _super.call(this, pattern);
    }

    _createClass(SuffixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text.endsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [text.length - this.pattern.length, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'suffix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^"(.*)"\$$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^(.*)\$$/;
      }
    }]);

    return SuffixExactMatch;
  }(BaseMatch);

  var InverseSuffixExactMatch = /*#__PURE__*/ function(_BaseMatch) {
    _inherits(InverseSuffixExactMatch, _BaseMatch);

    var _super = _createSuper(InverseSuffixExactMatch);

    function InverseSuffixExactMatch(pattern) {
      _classCallCheck(this, InverseSuffixExactMatch);

      return _super.call(this, pattern);
    }

    _createClass(InverseSuffixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = !text.endsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-suffix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!"(.*)"\$$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!(.*)\$$/;
      }
    }]);

    return InverseSuffixExactMatch;
  }(BaseMatch);

  var FuzzyMatch = /*#__PURE__*/ function(_BaseMatch) {
    _inherits(FuzzyMatch, _BaseMatch);

    var _super = _createSuper(FuzzyMatch);

    function FuzzyMatch(pattern) {
      var _this;

      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;

      _classCallCheck(this, FuzzyMatch);

      _this = _super.call(this, pattern);
      _this._bitapSearch = new BitapSearch(pattern, {
        location: location,
        threshold: threshold,
        distance: distance,
        includeMatches: includeMatches,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength,
        isCaseSensitive: isCaseSensitive,
        ignoreLocation: ignoreLocation
      });
      return _this;
    }

    _createClass(FuzzyMatch, [{
      key: "search",
      value: function search(text) {
        return this._bitapSearch.searchIn(text);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'fuzzy';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^(.*)$/;
      }
    }]);

    return FuzzyMatch;
  }(BaseMatch);

  var IncludeMatch = /*#__PURE__*/ function(_BaseMatch) {
    _inherits(IncludeMatch, _BaseMatch);

    var _super = _createSuper(IncludeMatch);

    function IncludeMatch(pattern) {
      _classCallCheck(this, IncludeMatch);

      return _super.call(this, pattern);
    }

    _createClass(IncludeMatch, [{
      key: "search",
      value: function search(text) {
        var location = 0;
        var index;
        var indices = [];
        var patternLen = this.pattern.length; // Get all exact matches

        while ((index = text.indexOf(this.pattern, location)) > -1) {
          location = index + patternLen;
          indices.push([index, location - 1]);
        }

        var isMatch = !!indices.length;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: indices
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'include';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^'"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^'(.*)$/;
      }
    }]);

    return IncludeMatch;
  }(BaseMatch);

  var searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
  var searchersLen = searchers.length; // Regex to split by spaces, but keep anything in quotes together

  var SPACE_RE = / +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/;
  var OR_TOKEN = '|'; // Return a 2D array representation of the query, for simpler parsing.
  // Example:
  // "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]

  function parseQuery(pattern) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return pattern.split(OR_TOKEN).map(function(item) {
      var query = item.trim().split(SPACE_RE).filter(function(item) {
        return item && !!item.trim();
      });
      var results = [];

      for (var i = 0, len = query.length; i < len; i += 1) {
        var queryItem = query[i]; // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)

        var found = false;
        var idx = -1;

        while (!found && ++idx < searchersLen) {
          var searcher = searchers[idx];
          var token = searcher.isMultiMatch(queryItem);

          if (token) {
            results.push(new searcher(token, options));
            found = true;
          }
        }

        if (found) {
          continue;
        } // 2. Handle single query matches (i.e, once that are *not* quoted)


        idx = -1;

        while (++idx < searchersLen) {
          var _searcher = searchers[idx];

          var _token = _searcher.isSingleMatch(queryItem);

          if (_token) {
            results.push(new _searcher(_token, options));
            break;
          }
        }
      }

      return results;
    });
  }

  // to a singl match

  var MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);
  /**
   * Command-like searching
   * ======================
   *
   * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
   * search in a given text.
   *
   * Search syntax:
   *
   * | Token       | Match type                 | Description                            |
   * | ----------- | -------------------------- | -------------------------------------- |
   * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
   * | `=scheme`   | exact-match                | Items that are `scheme`                |
   * | `'python`   | include-match              | Items that include `python`            |
   * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
   * | `^java`     | prefix-exact-match         | Items that start with `java`           |
   * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
   * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
   * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
   *
   * A single pipe character acts as an OR operator. For example, the following
   * query matches entries that start with `core` and end with either`go`, `rb`,
   * or`py`.
   *
   * ```
   * ^core go$ | rb$ | py$
   * ```
   */

  var ExtendedSearch = /*#__PURE__*/ function() {
    function ExtendedSearch(pattern) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance;

      _classCallCheck(this, ExtendedSearch);

      this.query = null;
      this.options = {
        isCaseSensitive: isCaseSensitive,
        includeMatches: includeMatches,
        minMatchCharLength: minMatchCharLength,
        findAllMatches: findAllMatches,
        ignoreLocation: ignoreLocation,
        location: location,
        threshold: threshold,
        distance: distance
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.query = parseQuery(this.pattern, this.options);
    }

    _createClass(ExtendedSearch, [{
      key: "searchIn",
      value: function searchIn(text) {
        var query = this.query;

        if (!query) {
          return {
            isMatch: false,
            score: 1
          };
        }

        var _this$options = this.options,
          includeMatches = _this$options.includeMatches,
          isCaseSensitive = _this$options.isCaseSensitive;
        text = isCaseSensitive ? text : text.toLowerCase();
        var numMatches = 0;
        var allIndices = [];
        var totalScore = 0; // ORs

        for (var i = 0, qLen = query.length; i < qLen; i += 1) {
          var searchers = query[i]; // Reset indices

          allIndices.length = 0;
          numMatches = 0; // ANDs

          for (var j = 0, pLen = searchers.length; j < pLen; j += 1) {
            var searcher = searchers[j];

            var _searcher$search = searcher.search(text),
              isMatch = _searcher$search.isMatch,
              indices = _searcher$search.indices,
              score = _searcher$search.score;

            if (isMatch) {
              numMatches += 1;
              totalScore += score;

              if (includeMatches) {
                var type = searcher.constructor.type;

                if (MultiMatchSet.has(type)) {
                  allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
                } else {
                  allIndices.push(indices);
                }
              }
            } else {
              totalScore = 0;
              numMatches = 0;
              allIndices.length = 0;
              break;
            }
          } // OR condition, so if TRUE, return


          if (numMatches) {
            var result = {
              isMatch: true,
              score: totalScore / numMatches
            };

            if (includeMatches) {
              result.indices = allIndices;
            }

            return result;
          }
        } // Nothing was matched


        return {
          isMatch: false,
          score: 1
        };
      }
    }], [{
      key: "condition",
      value: function condition(_, options) {
        return options.useExtendedSearch;
      }
    }]);

    return ExtendedSearch;
  }();

  var registeredSearchers = [];

  function register() {
    registeredSearchers.push.apply(registeredSearchers, arguments);
  }

  function createSearcher(pattern, options) {
    for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {
      var searcherClass = registeredSearchers[i];

      if (searcherClass.condition(pattern, options)) {
        return new searcherClass(pattern, options);
      }
    }

    return new BitapSearch(pattern, options);
  }

  var LogicalOperator = {
    AND: '$and',
    OR: '$or'
  };
  var KeyType = {
    PATH: '$path',
    PATTERN: '$val'
  };

  var isExpression = function isExpression(query) {
    return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
  };

  var isPath = function isPath(query) {
    return !!query[KeyType.PATH];
  };

  var isLeaf = function isLeaf(query) {
    return !isArray(query) && isObject(query) && !isExpression(query);
  };

  var convertToExplicit = function convertToExplicit(query) {
    return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function(key) {
      return _defineProperty({}, key, query[key]);
    }));
  }; // When `auto` is `true`, the parse function will infer and initialize and add
  // the appropriate `Searcher` instance


  function parse(query, options) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref3$auto = _ref3.auto,
      auto = _ref3$auto === void 0 ? true : _ref3$auto;

    var next = function next(query) {
      var keys = Object.keys(query);
      var isQueryPath = isPath(query);

      if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
        return next(convertToExplicit(query));
      }

      if (isLeaf(query)) {
        var key = isQueryPath ? query[KeyType.PATH] : keys[0];
        var pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];

        if (!isString(pattern)) {
          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
        }

        var obj = {
          keyId: createKeyId(key),
          pattern: pattern
        };

        if (auto) {
          obj.searcher = createSearcher(pattern, options);
        }

        return obj;
      }

      var node = {
        children: [],
        operator: keys[0]
      };
      keys.forEach(function(key) {
        var value = query[key];

        if (isArray(value)) {
          value.forEach(function(item) {
            node.children.push(next(item));
          });
        }
      });
      return node;
    };

    if (!isExpression(query)) {
      query = convertToExplicit(query);
    }

    return next(query);
  }

  function computeScore$1(results, _ref) {
    var _ref$ignoreFieldNorm = _ref.ignoreFieldNorm,
      ignoreFieldNorm = _ref$ignoreFieldNorm === void 0 ? Config.ignoreFieldNorm : _ref$ignoreFieldNorm;
    results.forEach(function(result) {
      var totalScore = 1;
      result.matches.forEach(function(_ref2) {
        var key = _ref2.key,
          norm = _ref2.norm,
          score = _ref2.score;
        var weight = key ? key.weight : null;
        totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));
      });
      result.score = totalScore;
    });
  }

  function transformMatches(result, data) {
    var matches = result.matches;
    data.matches = [];

    if (!isDefined(matches)) {
      return;
    }

    matches.forEach(function(match) {
      if (!isDefined(match.indices) || !match.indices.length) {
        return;
      }

      var indices = match.indices,
        value = match.value;
      var obj = {
        indices: indices,
        value: value
      };

      if (match.key) {
        obj.key = match.key.src;
      }

      if (match.idx > -1) {
        obj.refIndex = match.idx;
      }

      data.matches.push(obj);
    });
  }

  function transformScore(result, data) {
    data.score = result.score;
  }

  function format(results, docs) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$includeMatches = _ref.includeMatches,
      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
      _ref$includeScore = _ref.includeScore,
      includeScore = _ref$includeScore === void 0 ? Config.includeScore : _ref$includeScore;

    var transformers = [];
    if (includeMatches) transformers.push(transformMatches);
    if (includeScore) transformers.push(transformScore);
    return results.map(function(result) {
      var idx = result.idx;
      var data = {
        item: docs[idx],
        refIndex: idx
      };

      if (transformers.length) {
        transformers.forEach(function(transformer) {
          transformer(result, data);
        });
      }

      return data;
    });
  }

  var Fuse = /*#__PURE__*/ function() {
    function Fuse(docs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var index = arguments.length > 2 ? arguments[2] : undefined;

      _classCallCheck(this, Fuse);

      this.options = _objectSpread2({}, Config, {}, options);

      if (this.options.useExtendedSearch && !true) {
        throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
      }

      this._keyStore = new KeyStore(this.options.keys);
      this.setCollection(docs, index);
    }

    _createClass(Fuse, [{
      key: "setCollection",
      value: function setCollection(docs, index) {
        this._docs = docs;

        if (index && !(index instanceof FuseIndex)) {
          throw new Error(INCORRECT_INDEX_TYPE);
        }

        this._myIndex = index || createIndex(this.options.keys, this._docs, {
          getFn: this.options.getFn
        });
      }
    }, {
      key: "add",
      value: function add(doc) {
        if (!isDefined(doc)) {
          return;
        }

        this._docs.push(doc);

        this._myIndex.add(doc);
      }
    }, {
      key: "remove",
      value: function remove() {
        var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function() {
          return (
            /* doc, idx */
            false
          );
        };
        var results = [];

        for (var i = 0, len = this._docs.length; i < len; i += 1) {
          var doc = this._docs[i];

          if (predicate(doc, i)) {
            this.removeAt(i);
            i -= 1;
            len -= 1;
            results.push(doc);
          }
        }

        return results;
      }
    }, {
      key: "removeAt",
      value: function removeAt(idx) {
        this._docs.splice(idx, 1);

        this._myIndex.removeAt(idx);
      }
    }, {
      key: "getIndex",
      value: function getIndex() {
        return this._myIndex;
      }
    }, {
      key: "search",
      value: function search(query) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$limit = _ref.limit,
          limit = _ref$limit === void 0 ? -1 : _ref$limit;

        var _this$options = this.options,
          includeMatches = _this$options.includeMatches,
          includeScore = _this$options.includeScore,
          shouldSort = _this$options.shouldSort,
          sortFn = _this$options.sortFn,
          ignoreFieldNorm = _this$options.ignoreFieldNorm;
        var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
        computeScore$1(results, {
          ignoreFieldNorm: ignoreFieldNorm
        });

        if (shouldSort) {
          results.sort(sortFn);
        }

        if (isNumber(limit) && limit > -1) {
          results = results.slice(0, limit);
        }

        return format(results, this._docs, {
          includeMatches: includeMatches,
          includeScore: includeScore
        });
      }
    }, {
      key: "_searchStringList",
      value: function _searchStringList(query) {
        var searcher = createSearcher(query, this.options);
        var records = this._myIndex.records;
        var results = []; // Iterate over every string in the index

        records.forEach(function(_ref2) {
          var text = _ref2.v,
            idx = _ref2.i,
            norm = _ref2.n;

          if (!isDefined(text)) {
            return;
          }

          var _searcher$searchIn = searcher.searchIn(text),
            isMatch = _searcher$searchIn.isMatch,
            score = _searcher$searchIn.score,
            indices = _searcher$searchIn.indices;

          if (isMatch) {
            results.push({
              item: text,
              idx: idx,
              matches: [{
                score: score,
                value: text,
                norm: norm,
                indices: indices
              }]
            });
          }
        });
        return results;
      }
    }, {
      key: "_searchLogical",
      value: function _searchLogical(query) {
        var _this = this;

        var expression = parse(query, this.options);

        var evaluate = function evaluate(node, item, idx) {
          if (!node.children) {
            var keyId = node.keyId,
              searcher = node.searcher;

            var matches = _this._findMatches({
              key: _this._keyStore.get(keyId),
              value: _this._myIndex.getValueForItemAtKeyId(item, keyId),
              searcher: searcher
            });

            if (matches && matches.length) {
              return [{
                idx: idx,
                item: item,
                matches: matches
              }];
            }

            return [];
          }
          /*eslint indent: [2, 2, {"SwitchCase": 1}]*/


          switch (node.operator) {
            case LogicalOperator.AND: {
              var res = [];

              for (var i = 0, len = node.children.length; i < len; i += 1) {
                var child = node.children[i];
                var result = evaluate(child, item, idx);

                if (result.length) {
                  res.push.apply(res, _toConsumableArray(result));
                } else {
                  return [];
                }
              }

              return res;
            }

            case LogicalOperator.OR: {
              var _res = [];

              for (var _i = 0, _len = node.children.length; _i < _len; _i += 1) {
                var _child = node.children[_i];

                var _result = evaluate(_child, item, idx);

                if (_result.length) {
                  _res.push.apply(_res, _toConsumableArray(_result));

                  break;
                }
              }

              return _res;
            }
          }
        };

        var records = this._myIndex.records;
        var resultMap = {};
        var results = [];
        records.forEach(function(_ref3) {
          var item = _ref3.$,
            idx = _ref3.i;

          if (isDefined(item)) {
            var expResults = evaluate(expression, item, idx);

            if (expResults.length) {
              // Dedupe when adding
              if (!resultMap[idx]) {
                resultMap[idx] = {
                  idx: idx,
                  item: item,
                  matches: []
                };
                results.push(resultMap[idx]);
              }

              expResults.forEach(function(_ref4) {
                var _resultMap$idx$matche;

                var matches = _ref4.matches;

                (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));
              });
            }
          }
        });
        return results;
      }
    }, {
      key: "_searchObjectList",
      value: function _searchObjectList(query) {
        var _this2 = this;

        var searcher = createSearcher(query, this.options);
        var _this$_myIndex = this._myIndex,
          keys = _this$_myIndex.keys,
          records = _this$_myIndex.records;
        var results = []; // List is Array<Object>

        records.forEach(function(_ref5) {
          var item = _ref5.$,
            idx = _ref5.i;

          if (!isDefined(item)) {
            return;
          }

          var matches = []; // Iterate over every key (i.e, path), and fetch the value at that key

          keys.forEach(function(key, keyIndex) {
            matches.push.apply(matches, _toConsumableArray(_this2._findMatches({
              key: key,
              value: item[keyIndex],
              searcher: searcher
            })));
          });

          if (matches.length) {
            results.push({
              idx: idx,
              item: item,
              matches: matches
            });
          }
        });
        return results;
      }
    }, {
      key: "_findMatches",
      value: function _findMatches(_ref6) {
        var key = _ref6.key,
          value = _ref6.value,
          searcher = _ref6.searcher;

        if (!isDefined(value)) {
          return [];
        }

        var matches = [];

        if (isArray(value)) {
          value.forEach(function(_ref7) {
            var text = _ref7.v,
              idx = _ref7.i,
              norm = _ref7.n;

            if (!isDefined(text)) {
              return;
            }

            var _searcher$searchIn2 = searcher.searchIn(text),
              isMatch = _searcher$searchIn2.isMatch,
              score = _searcher$searchIn2.score,
              indices = _searcher$searchIn2.indices;

            if (isMatch) {
              matches.push({
                score: score,
                key: key,
                value: text,
                idx: idx,
                norm: norm,
                indices: indices
              });
            }
          });
        } else {
          var text = value.v,
            norm = value.n;

          var _searcher$searchIn3 = searcher.searchIn(text),
            isMatch = _searcher$searchIn3.isMatch,
            score = _searcher$searchIn3.score,
            indices = _searcher$searchIn3.indices;

          if (isMatch) {
            matches.push({
              score: score,
              key: key,
              value: text,
              norm: norm,
              indices: indices
            });
          }
        }

        return matches;
      }
    }]);

    return Fuse;
  }();

  Fuse.version = '6.4.6';
  Fuse.createIndex = createIndex;
  Fuse.parseIndex = parseIndex;
  Fuse.config = Config;

  {
    Fuse.parseQuery = parse;
  }

  {
    register(ExtendedSearch);
  }

  return Fuse;

})));
//static-content-hash-trigger-GCC
if (!pega)
	var pega = {};

if (!pega.cs)
  	pega.cs = {};

if (!pega.cs.voiceai)
  	pega.cs.voiceai = {};

/* pega.ui.debug = true; */

$(document).ready(function() {
  if (isVoiceAIAvailable()) {
    registerEventListener("PublicPhoneCallStateEvent", HandlePublicPhoneCallStateEvent, null, null);
  }
});

pega.cs.voiceai.gVAIWebSocket = null;
/********************* pega.cs.voiceai namespaced functions *******************/
pega.namespace("pega.cs.voiceai");
pega.cs.voiceai = (function() {
  
    function startCall(sessionId, channelId, accessToken, isolationId, languageModel, speechModel, operatorId, recordOnlyMode, callTransfer, routerURL,eligibleForNLP) {
      if (sessionId == null || sessionId == "" || accessToken == null || accessToken == "") {
        console.log("Could not start call -- session ID and/or access token not set");
        return false;
      }

      var result = false;
      var wsURL = "ws://localhost:7707/control";
      var payload = "";
      if (pega.cs.voiceai.gVAIWebSocket == null) {
            pega.cs.voiceai.gVAIWebSocket = new WebSocket(wsURL);
            payload = JSON.stringify({
                eventType: 'call-start',
                payload: {
                    AudioRouterAuthToken: accessToken,
                    CallId: sessionId,
                    ChannelId: channelId,
                    IsolationId: isolationId,
                    OperatorId: operatorId,
                    LanguageModel: languageModel,
                    SpeechModel: speechModel,
                    RecordOnlyMode: recordOnlyMode,
                    AudioRouterBaseURL: routerURL,
                    EligibleForNLP:eligibleForNLP
                },
            });
            pega.cs.voiceai.gVAIWebSocket.addEventListener('open', () => {
                /* console.log("Web socket connection is now open");*/
                pega.cs.voiceai.gVAIWebSocket.send(payload);
            });
            result = true;
      }
      return result;
  }

  function endCall(sessionId, callTransfer) { 
      var result = false;
      if (pega.cs.voiceai.gVAIWebSocket !== undefined && pega.cs.voiceai.gVAIWebSocket !== null) {
           pega.cs.voiceai.gVAIWebSocket.send(JSON.stringify({
               eventType: 'call-end'
           }));
           pega.cs.voiceai.gVAIWebSocket.close();
           pega.cs.voiceai.gVAIWebSocket = null;
           result = true;
      }
      pega.cs.voiceai.clearAgentTranscript();
      pega.cs.voiceai.clearUnReviewedEntityList(sessionId);
      return result;  /* whether we sent call-end */
  }
  function initiateTransfer() { 
  
  }

  function completeTransfer() { 
  
  }
  
  /* keep track of agent utterances, and highlight dialog if it matches one */
  
  function clearAgentTranscript() { 
     sessionStorage.setItem("agentTranscript", "");
     sessionStorage.setItem("dialogVerificationResults", "");
  }
  
  function clearUnReviewedEntityList(contextID) { 
    var caseStr = sessionStorage.getItem(contextID + ":serviceCases");
    if (caseStr !== null) {
      var caseArray = caseStr.split(":")
      for (var i = 0; i < caseArray.length; i++) {
        var caseID = caseArray[i];
        if (caseID != "") {
          sessionStorage.removeItem(caseID);
        }
      }
      sessionStorage.removeItem(contextID + ":serviceCases");
    }
  }
  
  function clearCaseEntities(contextID, caseID) { 
    sessionStorage.removeItem(caseID);
    var caseStr = sessionStorage.getItem(contextID + ":serviceCases");
    if (caseStr !== null) {
      caseStr = caseStr.replace(caseID + ":", "");
      sessionStorage.setItem(contextID + ":serviceCases", caseStr);
    }
  }
  
  function appendToAgentTranscript(utterance) { 
     var normalized = utterance.replace(/\s+/g, " ").replace(/[^\w\s]|_/g, "").trim().toLowerCase();
     var transcript = sessionStorage.getItem("agentTranscript");
     if (transcript === null) {
        transcript = [];
     } else if (transcript === "") {
        transcript = [];
     } else {
       transcript = JSON.parse(transcript);
     }
     if (transcript.length > 0) {
       var lastEntry = transcript[transcript.length - 1];
       if (normalized.startsWith(lastEntry)) {
         transcript.pop();
       }
     }
     transcript.push(normalized);
     sessionStorage.setItem("agentTranscript", JSON.stringify(transcript));
  }

  function verifyDialog(shell, verbatimThreshold) {
        var dialogText, text;
        var dialog = shell.find('#DialogContent:visible');
        if (dialog.length === 0) {
          dialog = shell.find('#DialogContent');
        }
        dialog = dialog[0];
        if (dialog && dialog.getElementsByTagName("verbatim").length > 0) {
          text = dialog.innerText;

          var transcript = sessionStorage.getItem("agentTranscript");
          var JSONTranscript = "";
          if (transcript !== null && transcript.length > 0 && text.length > 0) {
            /* Fuse fuzzy search */
            JSONTranscript = JSON.parse(transcript);
          	const options = {
          	  isCaseSensitive: false,
          	  includeScore: true,
          	  includeMatches: false,
	            findAllMatches: false,
              ignoreFieldNorm: true,
              ignoreLocation: true
	          };
            text = text.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " ").toLowerCase().trim();
	        	const fuse = new Fuse(JSONTranscript, options);
           	var fuseResult = fuse.search(text);
            var threshold = (100 - verbatimThreshold) / 100;
            var score, assessment, item, displayScore;
            var recorded = false;
          	if (fuseResult.length == 0 || fuseResult[0].score >= 1) {
              score = "-";
              displayScore = 0;
              assessment = "No match";
              item = "";
            } else {
              /* the first item is the best match */
              score = fuseResult[0].score;
              item = fuseResult[0].item;
              score = Math.round(score * 100) / 100;

              if (score <= threshold) {
                if (score == 0) {
                  assessment = "Exact match";
                } else {
		              assessment = "Match";
                }
                if (dialog) {
                  dialogText = dialog.innerText;
                  text = dialogText.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " ").toLowerCase().trim();
                  var mustSay = $(".verbatim-dialog.must-say");
                  if (mustSay.length == 0) {
                    mustSay = shell.find(".verbatim-dialog.must-say");
                  }
                  var delivered = $(".verbatim-dialog.delivered-verbatim.hidden");
                  if (delivered.length == 0) {
                    delivered = shell.find(".verbatim-dialog.delivered-verbatim.hidden");
                  }
                  mustSay.addClass("fade-out");
                  window.setTimeout(function(){
                    mustSay.addClass("hidden");
                    delivered.removeClass("hidden");
                    delivered.addClass("fade-in");
                    shell.find(".dialog-icon.dialog-icon-mustsay").removeClass("dialog-icon-mustsay");
                  }, 500);
                  
                  /* update the voiceAI stats in the database */
                  var oSafeURL = new SafeURL("czRecordVerbatimDialog");
                  oSafeURL.put("Utterance", dialogText);
                  oSafeURL.put("IsMatch", true);
                  pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
                  var transaction = pega.u.d.asyncRequest('POST', oSafeURL, {
                      success: function() {
                      },
                      failure: function() {
                        console.log("WARNING: Unable to register dialog match in the database.");
                      },
                      scope: this
                  }, null);
                  recorded = true;
                }
              } else {
                assessment = "No match";
              }
              displayScore = Math.round((1 - score) * 100);  /* the rounding should not be necessary, but it is */
            }

            if (!recorded) {
              /* initialize this dialog to unmatched if it hasn't been already */
              dialogText = dialog.innerText;
              var oSafeURL = new SafeURL("czRecordVerbatimDialog");
              oSafeURL.put("Utterance", dialogText);
              oSafeURL.put("IsMatch", false);
              pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
              var transaction = pega.u.d.asyncRequest('POST', oSafeURL, {
                  success: function() {
                  },
                  failure: function() {
                    console.log("WARNING: Unable to register dialog non-match in the database.");
                  },
                  scope: this
              }, null);
            }

            /* keep track of dialog verification results */
            var statsObject;
            var statsString = sessionStorage.getItem("dialogVerificationResults");
            if (statsString == null || statsString == "") {
              statsObject = [];
            } else {
              statsObject = JSON.parse(statsString);
              if (statsObject == null) {
                statsObject = [];
              }
            }
            for (var i = 0; i < statsObject.length; i++) {
              var result = statsObject[i];
              if (result.Dialog == text) {
                statsObject.splice(i, 1);
                break;
              }
            }
            statsObject.push({"Dialog": text, "Score": displayScore, "BestMatch": item, "Assessment": assessment});
            statsString = JSON.stringify(statsObject);
            sessionStorage.setItem("dialogVerificationResults", statsString);
            return statsString;
          }
       }
  }
  
  function getDialogVerificationResults() {
    return sessionStorage.getItem("dialogVerificationResults");
  }

  return {
    startCall: startCall,
    endCall: endCall,
    initiateTransfer: initiateTransfer,
    completeTransfer: completeTransfer,
    clearAgentTranscript: clearAgentTranscript,
    appendToAgentTranscript: appendToAgentTranscript,
    verifyDialog: verifyDialog,
    getDialogVerificationResults: getDialogVerificationResults,
    clearUnReviewedEntityList: clearUnReviewedEntityList,
    clearCaseEntities: clearCaseEntities
  }
})();


function HandlePublicPhoneCallStateEvent(eventJSON) {
  var event = JSON.parse(eventJSON);
  /* console.log("HandlePublicPhoneCallStateEvent:"+event.pyEventName);  */
  switch (event.pyEventName) {
    case "Offering":
      /* Do nothing */
      break;
    case "Retrieved":
    case "Connected":
      /* Need to get the VAD data from the server */
      
      var oSafeURL = new SafeURL("PegaCA-Work-Interaction-Call.czRetrieveVADParameters");
      oSafeURL.put("Event", eventJSON);
      pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
      var transaction = pega.u.d.asyncRequest('POST', oSafeURL, {
        success: function(respObject) {
          var response = respObject.responseText;
          var responseObj = JSON.parse(response);
          
          if (responseObj.AISessionID != "" && responseObj.AIAccessToken != null && responseObj.AIAccessToken != "") { 
            /* Call the VAD Start event here */
            pega.cs.voiceai.startCall(responseObj.AISessionID, responseObj.AIChannelID, responseObj.AIAccessToken, responseObj.AIIsolationID, responseObj.AILanguageModel, 
                                    responseObj.AISpeechModel, responseObj.pyOperatorID, responseObj.AIRecordOnlyMode, false, responseObj.VoiceAITranscriptURL,responseObj.AIEligibleForNLP);
          } else { 
            console.log("Error: Cannot send the call-start event for incoming call to VAD as required parameters are empty");
          }
        },
        failure: function() {},
        scope: this
      }, null);
      break;
    case "Disconnected":
      var oSafeURL = new SafeURL("PegaCA-Work-Interaction-Call.czRetrieveAISessionId");
      oSafeURL.put("Event", eventJSON);
      pega.util.Connect.initHeader('Content-Type', "application/x-www-form-urlencoded");
      var transaction = pega.u.d.asyncRequest('POST', oSafeURL, {
        success: function(respObject) {
          var response = respObject.responseText;
          var responseObj = JSON.parse(response);
          
          if (responseObj.AISessionID != "") { 
            /* Call the VAD End event here */
            pega.cs.voiceai.endCall(responseObj.AISessionID);
           
          } else { 
            console.log("Error: Cannot send the call-end event for incoming call to VAD as required parameters are empty");
          }
        },
        failure: function() {},
        scope: this
      }, null);

      
      break;
  }
}

function isVoiceAIAvailable() {
  var isAvail = false;
  var availField = document.querySelectorAll("[name$=VoiceAIAvailable]");
  if (availField.length > 0) {
    isAvail = "true" == availField[0].value;
  }
  return isAvail;
}

//static-content-hash-trigger-GCC