<!DOCTYPE html>
<!-- saved from url=(0043)https://ricmars.github.io/democs/Test7.html -->
<html lang="en-US" class="wk chrome yui-skin-sam"><script type="text/javascript" src="chrome-extension://mdnleldcmiljblolnjhpnblkcekpdkpa/libs/customElements.js" class="__REQUESTLY__SCRIPT"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  

  <meta name="viewport" content="initial-scale=1, width=device-width">
  <title>Test Name</title>
  <link rel="icon" type="image/png" sizes="32x32" href="https://bpmsteddev.aci.is.cl.ssa.gov/prweb/PRAuth/app/TEDDevR8/LPuB4vZ9OMeB9DNoFEtNn5xJWNSK0dN6*/images/pzpegaicon32_13852824416.png!!.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://bpmsteddev.aci.is.cl.ssa.gov/prweb/PRAuth/app/TEDDevR8/LPuB4vZ9OMeB9DNoFEtNn5xJWNSK0dN6*/images/pzpegaicon16_12739199918.png!!.png">
  <link rel="shortcut icon" href="https://bpmsteddev.aci.is.cl.ssa.gov/prweb/PRAuth/app/TEDDevR8/LPuB4vZ9OMeB9DNoFEtNn5xJWNSK0dN6*/images/pzPegaIcon.ico">
<script type="text/javascript" class="__REQUESTLY__SCRIPT">((namespace) => {
  const RuleSourceKey = {
    URL: "Url",
    HOST: "host",
    PATH: "path",
  };

  const RuleSourceOperator = {
    EQUALS: "Equals",
    CONTAINS: "Contains",
    MATCHES: "Matches",
    WILDCARD_MATCHES: "Wildcard_Matches",
  };

  const toRegex = (regexStr) => {
    const matchRegExp = regexStr.match(new RegExp("^/(.+)/(|i|g|ig|gi)$"));

    if (!matchRegExp) {
      return null;
    }

    try {
      return new RegExp(matchRegExp[1], matchRegExp[2]);
    } catch {
      return null;
    }
  };

  const checkRegexMatch = (regexString, inputString) => {
    if (!regexString.startsWith("/")) {
      regexString = `/${regexString}/`; // Keeping enclosing slashes for regex as optional
    }

    const regex = toRegex(regexString);
    return regex?.test(inputString);
  };

  const checkWildCardMatch = (wildCardString, inputString) => {
    const regexString = "/^" + wildCardString.replaceAll("*", ".*") + "$/";
    return checkRegexMatch(regexString, inputString);
  };

  const extractUrlComponent = (url, key) => {
    const urlObj = new URL(url);

    switch (key) {
      case RuleSourceKey.URL:
        return url;
      case RuleSourceKey.HOST:
        return urlObj.host;
      case RuleSourceKey.PATH:
        return urlObj.pathname;
    }
  };

  window[namespace] = window[namespace] || {};
  window[namespace].matchSourceUrl = (sourceObject, url) => {
    const urlComponent = extractUrlComponent(url, sourceObject.key);
    const value = sourceObject.value;

    if (!urlComponent) {
      return false;
    }

    switch (sourceObject.operator) {
      case RuleSourceOperator.EQUALS:
        if (value === urlComponent) {
          return true;
        }
        break;

      case RuleSourceOperator.CONTAINS:
        if (urlComponent.indexOf(value) !== -1) {
          return true;
        }
        break;

      case RuleSourceOperator.MATCHES: {
        return checkRegexMatch(value, urlComponent);
      }

      case RuleSourceOperator.WILDCARD_MATCHES: {
        return checkWildCardMatch(value, urlComponent);
      }
    }

    return false;
  };
})('__REQUESTLY__')</script><script type="text/javascript" class="__REQUESTLY__SCRIPT">(function (namespace) {
  window[namespace] = window[namespace] || {};
  window[namespace].requestRules = [];
  window[namespace].responseRules = [];
  let isDebugMode = false;

  // Some frames are sandboxes and throw DOMException when accessing localStorage
  try {
    isDebugMode = window && window.localStorage && localStorage.isDebugMode;
  } catch (e) {}

  const isExtensionEnabled = () => {
    return window[namespace].isExtensionEnabled ?? true;
  };

  const getAbsoluteUrl = (url) => {
    const dummyLink = document.createElement("a");
    dummyLink.href = url;
    return dummyLink.href;
  };

  const isNonJsonObject = (obj) => {
    return [
      Blob,
      ArrayBuffer,
      Object.getPrototypeOf(Uint8Array), // TypedArray instance type
      DataView,
      FormData,
      URLSearchParams,
    ].some((nonJsonType) => obj instanceof nonJsonType);
  };

  /**
   * @param {Object} json
   * @param {String} path -> "a", "a.b", "a.0.b (If a is an array containing list of objects"
   * Also copied in shared/utils.js for the sake of testing
   */
  const traverseJsonByPath = (jsonObject, path) => {
    if (!path) return;

    const pathParts = path.split(".");

    try {
      // Reach the last node but not the leaf node.
      for (i = 0; i < pathParts.length - 1; i++) {
        jsonObject = jsonObject[pathParts[i]];
      }

      return jsonObject[pathParts[pathParts.length - 1]];
    } catch (e) {
      /* Do nothing */
    }
  };

  const matchesSourceFilters = ({ requestData, method }, sourceFilters) => {
    const sourceFiltersArray = Array.isArray(sourceFilters) ? sourceFilters : [sourceFilters];

    return (
      !sourceFiltersArray.length ||
      sourceFiltersArray.some((sourceFilter) => {
        if (sourceFilter?.requestMethod?.length && !sourceFilter.requestMethod.includes(method)) {
          return false;
        }

        let requestPayloadFilter = sourceFilter?.requestPayload;

        if (!requestPayloadFilter) return true;
        if (typeof requestPayloadFilter === "object" && Object.keys(requestPayloadFilter).length === 0) return true;

        // We only allow request payload targeting when requestData is JSON
        if (!requestData || typeof requestData !== "object") return false;
        if (Object.keys(requestData).length === 0) return false;

        requestPayloadFilter = requestPayloadFilter || {};
        const targetedKey = requestPayloadFilter?.key;
        const targetedValue = requestPayloadFilter?.value;

        // tagetedKey is the json path e.g. a.b.0.c
        if (targetedKey && typeof targetedValue !== undefined) {
          const valueInRequestData = traverseJsonByPath(requestData, targetedKey);
          const operator = requestPayloadFilter?.operator;

          if (!operator || operator === "Equals") {
            return valueInRequestData === targetedValue;
          }

          if (operator === "Contains") {
            return valueInRequestData.includes(targetedValue);
          }
        }

        return false;
      })
    );
  };

  const matchRuleSource = ({ url, requestData, method }, rule) => {
    const modification = rule.pairs[0];
    const ruleSource = modification.source;

    return (
      window[namespace].matchSourceUrl(ruleSource, url) &&
      matchesSourceFilters({ requestData, method }, ruleSource?.filters)
    );
  };

  const getRequestRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].requestRules.findLast((rule) =>
      window[namespace].matchSourceUrl(rule.pairs[0].source, url)
    );
  };

  const getResponseRule = ({ url, requestData, method }) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].responseRules.findLast((rule) => {
      return matchRuleSource({ url, requestData, method }, rule);
    });
  };

  const shouldServeResponseWithoutRequest = (responseRule) => {
    const responseModification = responseRule.pairs[0].response;
    return responseModification.type === "static" && responseModification.serveWithoutRequest;
  };

  const getFunctionFromCode = (code) => {
    return new Function("args", `return (${code})(args);`);
  };

  const getCustomRequestBody = (requestRule, args) => {
    const modification = requestRule.pairs[0].request;
    if (modification.type === "static") {
      requestBody = modification.value;
    } else {
      requestBody = getFunctionFromCode(modification.value)(args);
    }

    if (typeof requestBody !== "object" || isNonJsonObject(requestBody)) {
      return requestBody;
    }

    return JSON.stringify(requestBody);
  };

  /**
   * @param mightBeJSONString string which might be JSON String or normal String
   * @param doStrictCheck should return empty JSON if invalid JSON string
   */
  const jsonifyValidJSONString = (mightBeJSONString, doStrictCheck) => {
    const defaultValue = doStrictCheck ? {} : mightBeJSONString;

    if (typeof mightBeJSONString !== "string") {
      return defaultValue;
    }

    try {
      return JSON.parse(mightBeJSONString);
    } catch (e) {
      /* Do Nothing. Unable to parse the param value */
    }

    return defaultValue;
  };

  const isJSON = (data) => {
    const parsedJson = jsonifyValidJSONString(data);
    return parsedJson !== data; // if data is not a JSON, jsonifyValidJSONString() returns same value
  };

  const notifyRequestRuleApplied = (message) => {
    window.postMessage(
      {
        from: "requestly",
        type: "request_rule_applied",
        id: message.ruleDetails.id,
        requestDetails: message["requestDetails"],
      },
      window.location.href
    );
  };

  const notifyResponseRuleApplied = (message) => {
    window.postMessage(
      {
        from: "requestly",
        type: "response_rule_applied",
        id: message.rule.id,
        requestDetails: message["requestDetails"],
      },
      window.location.href
    );
  };

  const isPromise = (obj) =>
    !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";

  const isContentTypeJSON = (contentType) => !!contentType?.includes("application/json");

  // Intercept XMLHttpRequest
  const onReadyStateChange = async function () {
    if (this.readyState === this.HEADERS_RECEIVED || this.readyState === this.DONE) {
      if (!this.responseRule) {
        return;
      }

      const responseModification = this.responseRule.pairs[0].response;
      const responseType = this.responseType;
      const contentType = this.getResponseHeader("content-type");

      isDebugMode &&
        console.log("RQ", "Inside the XHR onReadyStateChange block for url", {
          url: this.requestURL,
          xhr: this,
        });

      if (this.readyState === this.HEADERS_RECEIVED) {
        // For network failures, responseStatus=0 but we still return customResponse with status=200
        const responseStatus = parseInt(responseModification.statusCode || this.status) || 200;
        const responseStatusText = responseModification.statusText || this.statusText;

        Object.defineProperty(this, "status", {
          get: () => responseStatus,
        });

        Object.defineProperty(this, "statusText", {
          get: () => responseStatusText,
        });
      }

      if (this.readyState === this.DONE) {
        let customResponse =
          responseModification.type === "code"
            ? getFunctionFromCode(responseModification.value)({
                method: this.method,
                url: this.requestURL,
                requestHeaders: this.requestHeaders,
                requestData: jsonifyValidJSONString(this.requestData),
                responseType: contentType,
                response: this.response,
                responseJSON: jsonifyValidJSONString(this.response, true),
              })
            : responseModification.value;

        // Convert customResponse back to rawText
        // response.value is String and evaluator method might return string/object
        if (isPromise(customResponse)) {
          customResponse = await customResponse;
        }

        const isUnsupportedResponseType = responseType && !["json", "text"].includes(responseType);

        // We do not support statically modifying responses of type - blob, arraybuffer, document etc.
        if (responseModification.type === "static" && isUnsupportedResponseType) {
          customResponse = this.response;
        }

        if (
          !isUnsupportedResponseType &&
          typeof customResponse === "object" &&
          !(customResponse instanceof Blob) &&
          (responseType === "json" || isContentTypeJSON(contentType))
        ) {
          customResponse = JSON.stringify(customResponse);
        }

        Object.defineProperty(this, "response", {
          get: function () {
            if (responseModification.type === "static" && responseType === "json") {
              if (typeof customResponse === "object") {
                return customResponse;
              }

              return jsonifyValidJSONString(customResponse);
            }

            return customResponse;
          },
        });

        if (responseType === "" || responseType === "text") {
          Object.defineProperty(this, "responseText", {
            get: function () {
              return customResponse;
            },
          });
        }

        const requestDetails = {
          url: this.requestURL,
          method: this.method,
          type: "xmlhttprequest",
          timeStamp: Date.now(),
        };

        notifyResponseRuleApplied({
          rule: this.responseRule,
          requestDetails,
        });
      }
    }
  };

  const resolveXHR = (xhr, responseData) => {
    Object.defineProperty(xhr, "readyState", { writable: true });
    const updateReadyState = (readyState) => {
      xhr.readyState = readyState;
      xhr.dispatchEvent(new CustomEvent("readystatechange"));
    };
    const dispatchProgressEvent = (type) => {
      xhr.dispatchEvent(new ProgressEvent(type));
    };

    dispatchProgressEvent("loadstart");

    // update response headers
    const contentType = isJSON(responseData) ? "application/json" : "text/plain";
    xhr.getResponseHeader = (key) => {
      if (key.toLowerCase() === "content-type") {
        return contentType;
      }
      return null;
    };
    updateReadyState(xhr.HEADERS_RECEIVED);

    // mark resolved
    updateReadyState(xhr.DONE);
    dispatchProgressEvent("load");
    dispatchProgressEvent("loadend");
  };

  const XHR = XMLHttpRequest;
  XMLHttpRequest = function () {
    const xhr = new XHR();
    xhr.addEventListener("readystatechange", onReadyStateChange.bind(xhr), false);
    return xhr;
  };
  XMLHttpRequest.prototype = XHR.prototype;
  Object.entries(XHR).map(([key, val]) => {
    XMLHttpRequest[key] = val;
  });

  const open = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function (method, url) {
    this.method = method;
    this.requestURL = getAbsoluteUrl(url);
    open.apply(this, arguments);
  };

  const send = XMLHttpRequest.prototype.send;
  XMLHttpRequest.prototype.send = function (data) {
    this.requestData = data;

    const requestRule = getRequestRule(this.requestURL);
    if (requestRule) {
      this.requestData = getCustomRequestBody(requestRule, {
        method: this.method,
        url: this.requestURL,
        body: data,
        bodyAsJson: jsonifyValidJSONString(data, true),
      });

      notifyRequestRuleApplied({
        ruleDetails: requestRule,
        requestDetails: {
          url: this.requestURL,
          method: this.method,
          type: "xmlhttprequest",
          timeStamp: Date.now(),
        },
      });
    }

    this.responseRule = getResponseRule({
      url: this.requestURL,
      requestData: jsonifyValidJSONString(this.requestData),
      method: this.method,
    });

    if (this.responseRule && shouldServeResponseWithoutRequest(this.responseRule)) {
      resolveXHR(this, this.responseRule.pairs[0].response.value);
    } else {
      send.call(this, this.requestData);
    }
  };

  let setRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
  XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
    this.requestHeaders = this.requestHeaders || {};
    this.requestHeaders[header] = value;
    setRequestHeader.apply(this, arguments);
  };

  // Intercept fetch API
  const _fetch = fetch;
  fetch = async (...args) => {
    const [resource, initOptions = {}] = args;
    const getOriginalResponse = () => _fetch(...args);

    let request;

    if (resource instanceof Request) {
      request = resource.clone();
    } else {
      request = new Request(resource.toString(), initOptions);
    }

    const url = getAbsoluteUrl(request.url);
    const method = request.method;
    // Request body can be sent only for request methods other than GET and HEAD.
    const canRequestBodyBeSent = !["GET", "HEAD"].includes(method);

    const requestRule = canRequestBodyBeSent && getRequestRule(url);
    if (requestRule) {
      const originalRequestBody = await request.text();
      const requestBody =
        getCustomRequestBody(requestRule, {
          method: request.method,
          url,
          body: originalRequestBody,
          bodyAsJson: jsonifyValidJSONString(originalRequestBody, true),
        }) || {};

      request = new Request(request.url, {
        method,
        body: requestBody,
        headers: request.headers,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
      });

      notifyRequestRuleApplied({
        ruleDetails: requestRule,
        requestDetails: {
          url,
          method: request.method,
          type: "fetch",
          timeStamp: Date.now(),
        },
      });
    }

    let requestData;
    if (canRequestBodyBeSent) {
      requestData = jsonifyValidJSONString(await request.clone().text()); // cloning because the request will be used to make API call
    }

    const responseRule = getResponseRule({ url, requestData, method });
    let responseHeaders;
    let fetchedResponse;

    if (responseRule && shouldServeResponseWithoutRequest(responseRule)) {
      const contentType = isJSON(responseRule.pairs[0].response.value) ? "application/json" : "text/plain";
      responseHeaders = new Headers({ "content-type": contentType });
    } else {
      try {
        if (requestRule) {
          // use modified request to fetch response
          fetchedResponse = await _fetch(request);
        } else {
          fetchedResponse = await getOriginalResponse();
        }

        if (!responseRule) {
          return fetchedResponse;
        }

        responseHeaders = fetchedResponse?.headers;
      } catch (error) {
        if (!responseRule) {
          return Promise.reject(error);
        }
      }
    }

    isDebugMode &&
      console.log("RQ", "Inside the fetch block for url", {
        url,
        resource,
        initOptions,
        fetchedResponse,
      });

    let customResponse;
    const responseModification = responseRule.pairs[0].response;

    if (responseModification.type === "code") {
      const requestHeaders =
        request.headers &&
        Array.from(request.headers).reduce((obj, [key, val]) => {
          obj[key] = val;
          return obj;
        }, {});

      let evaluatorArgs = {
        method,
        url,
        requestHeaders,
        requestData,
      };

      if (fetchedResponse) {
        const fetchedResponseData = await fetchedResponse.text();
        const responseType = fetchedResponse.headers.get("content-type");
        const fetchedResponseDataAsJson = jsonifyValidJSONString(fetchedResponseData, true);

        evaluatorArgs = {
          ...evaluatorArgs,
          responseType,
          response: fetchedResponseData,
          responseJSON: fetchedResponseDataAsJson,
        };
      }

      customResponse = getFunctionFromCode(responseModification.value)(evaluatorArgs);

      // evaluator might return us Object but response.value is string
      // So make the response consistent by converting to JSON String and then create the Response object
      if (isPromise(customResponse)) {
        customResponse = await customResponse;
      }

      if (typeof customResponse === "object" && isContentTypeJSON(evaluatorArgs?.responseType)) {
        customResponse = JSON.stringify(customResponse);
      }
    } else {
      customResponse = responseModification.value;
    }

    const requestDetails = {
      url,
      method,
      type: "fetch",
      timeStamp: Date.now(),
    };

    notifyResponseRuleApplied({
      rule: responseRule,
      requestDetails,
    });

    // For network failures, fetchedResponse is undefined but we still return customResponse with status=200
    const finalStatusCode = parseInt(responseModification.statusCode || fetchedResponse?.status) || 200;
    const requiresNullResponseBody = [204, 205, 304].includes(finalStatusCode);

    return new Response(requiresNullResponseBody ? null : new Blob([customResponse]), {
      status: finalStatusCode,
      statusText: responseModification.statusText || fetchedResponse?.statusText,
      headers: responseHeaders,
    });
  };
})('__REQUESTLY__')</script><script type="text/javascript" src="chrome-extension://mdnleldcmiljblolnjhpnblkcekpdkpa/libs/requestly-web-sdk.js" class="__REQUESTLY__SCRIPT"></script><script type="text/javascript" class="__REQUESTLY__SCRIPT">((namespace) => {
  window[namespace] = window[namespace] || {};

  const sendMessageToExtension = (action, payload) => {
    window.postMessage({ source: "requestly:client", action, payload }, window.location.href);
  };

  const sendResponseToExtension = (action, payload) => {
    window.postMessage({ source: "requestly:client", response: true, action, payload }, window.location.href);
  };

  window.addEventListener("message", function (event) {
    // We only accept messages from ourselves
    if (event.source !== window || event.data.source !== "requestly:extension") {
      return;
    }

    if (event.data.action === "startRecording") {
      window[namespace]?.sessionRecorder?.stop?.();
      window[namespace].sessionRecorder = new Requestly.SessionRecorder(event.data.payload);
      window[namespace].sessionRecorder.start();
      sendMessageToExtension("sessionRecordingStarted");
    } else if (event.data.action === "stopRecording") {
      window[namespace].sessionRecorder.stop();
      sendMessageToExtension("sessionRecordingStopped");
    } else if (event.data.action === "getSessionData") {
      try {
        sendResponseToExtension(event.data.action, window[namespace].sessionRecorder.getSession());
      } catch (err) {
        const error = err instanceof Error ? err.message : String(err);
        sendResponseToExtension(event.data.action, error);
        throw err;
      }
    }
  });
})('__REQUESTLY__')</script></head>

<body class="screen-layout-body with-fixed-header HIDD406F95FCD9384AFA8E4A1EA60CEBF54" onload="screenLayoutResize" data-harness-id="HIDD406F95FCD9384AFA8E4A1EA60CEBF54">















  <div data-ui-meta="{&#39;type&#39;:&#39;Harness&#39;,&#39;ruleName&#39;:&#39;CPMInteractionPortal&#39;,&#39;insKey&#39;:&#39;RULE-HTML-HARNESS CPM-PORTAL CPMINTERACTIONPORTAL #20230207T005137.420 GMT&#39;}" data-portalharnessinsname="CPM-Portal!CPMInteractionPortal" class="screen-layout screen-layout-modern screen-layout-header " style="">
    <main data-skip-target="main" data-ui-meta="{&#39;type&#39;:&#39;Panel&#39;,&#39;subType&#39;:&#39;CENTER&#39;}" id="l2" class="screen-layout-region screen-layout-region-main screen-layout-region-main-middle not-nav dc-screen-layout-region-main-middle-tab dc-standard-tabs" aria-label="Center Panel" role="main">
      <div class="screen-layout-region-content">

        <div data-ui-meta="{&#39;type&#39;:&#39;Section&#39;,&#39;ruleName&#39;:&#39;CSPortalBodyWrapper&#39;,&#39;insKey&#39;:&#39;RULE-HTML-SECTION CPM-PORTAL CSPORTALBODYWRAPPER #20231011T110954.734 GMT&#39;,&#39;sectionType&#39;:&#39;standard&#39;}" data-template="" node_name="CSPortalBodyWrapper" node_type="MAIN_RULE" name="BASE_REF" id="RULE_KEY" class="sectionDivStyle  " style="" base_ref="" data-node-id="CSPortalBodyWrapper" version="1" objclass="Rule-HTML-Section" pyclassname="CPM-Portal" readonly="false" expandrl="" index="" uniqueid="SID1698333988681">
          <span class="inspector-span" data-template="" data-ui-meta="{&#39;type&#39;:&#39;Layout&#39;,&#39;subType&#39;:&#39;SECTIONINCLUDE&#39;,&#39;pgRef&#39;:&#39;.pySections(1)&#39;,&#39;clipboardPath&#39;:&#39;CPMInteractionPortalWorkAreaWrapper&#39;}">

            <div data-ui-meta="{&#39;type&#39;:&#39;Section&#39;,&#39;ruleName&#39;:&#39;CPMInteractionPortalWorkAreaWrapper&#39;,&#39;insKey&#39;:&#39;RULE-HTML-SECTION CPM-PORTAL CPMINTERACTIONPORTALWORKAREAWRAPPER #20231011T110953.731 GMT&#39;,&#39;sectionType&#39;:&#39;standard&#39;}" data-template="" node_name="CPMInteractionPortalWorkAreaWrapper" node_type="MAIN_RULE" name="BASE_REF" id="RULE_KEY" class="sectionDivStyle  " style="" base_ref="" data-node-id="CPMInteractionPortalWorkAreaWrapper" version="1" objclass="Rule-HTML-Section" pyclassname="CPM-Portal" readonly="false" expandrl="" index="" uniqueid="SID1698333988682">
              <div bsimplelayout="true" data-template="" class=" flex content layout-content-inline  content-inline " data-test-id="2018041821025701091000" data-ui-meta="{&#39;type&#39;:&#39;Layout&#39;,&#39;subType&#39;:&#39;DYNAMICLAYOUT&#39;,&#39;pgRef&#39;:&#39;.pySections(1)&#39;}" role="main" tabindex="-1" data-skip-target="main" data-methodname="">
                <div class="content-item content-sub_section item-1 remove-bottom-spacing remove-left-spacing remove-right-spacing flex flex-row dc-wrapper" string_type="sub_section" reserve_space="false" data-ui-meta="{&#39;type&#39;:&#39;Cell&#39;,&#39;subType&#39;:&#39;SUB_SECTION&#39;,&#39;clipboardPath&#39;:&#39;CPMInteractionPortalWorkArea&#39;,&#39;className&#39;:&#39;CPM-Portal&#39;,&#39;pgRef&#39;:&#39;.pySections(1).pySectionBody(1).pyTable.pyRows(1).pyCells(1)&#39;}" data-template="">

                  <div data-ui-meta="{&#39;type&#39;:&#39;Section&#39;,&#39;ruleName&#39;:&#39;CPMInteractionPortalWorkArea&#39;,&#39;insKey&#39;:&#39;RULE-HTML-SECTION CPM-PORTAL CPMINTERACTIONPORTALWORKAREA #20230615T134404.901 GMT&#39;,&#39;sectionType&#39;:&#39;standard&#39;}" data-template="" node_name="CPMInteractionPortalWorkArea" node_type="MAIN_RULE" name="BASE_REF" id="RULE_KEY" class="sectionDivStyle  " style="" base_ref="" data-node-id="CPMInteractionPortalWorkArea" version="1" objclass="Rule-HTML-Section" pyclassname="CPM-Portal" readonly="false" expandrl="" index="" uniqueid="SID1698333988683">
                    <div id="workarea" data-mode="Tabbed" data-multiview="1" data-responsivedc="false" data-tabformat="STANDARD" class="dc-wrapper with-fixed-header " style="height: 778px;" data-nsr="false"><span id="WAMaxtabs" value="8" data-ml="You have reached the maximum limit of open tabs"></span><input type="hidden" id="pzWAStrings" data-s1="Work Item Already Open" data-s2="Work Object Already Open" data-s3="Application" data-s4="is already open." data-s5="Would you like to reopen the item and lose any unsaved changes?" data-s6="Close All" data-s7="Remaining open tabs have unsaved work." data-s8="Please close them manually." data-s9="Assignment" data-s10="Work item" data-s11="New" data-s12="Opening..." data-s13="Document associated with this recent item is dirty. 

Please close the document manually." data-s14="Remaining open documents have unsaved work or not tracking in recents.

Please close them manually." data-s15="Next">




                      <div class="dc-main">
                        <div data-ui-meta="{&#39;type&#39;:&#39;Layout&#39;,&#39;subType&#39;:&#39;TABGROUP&#39;,&#39;pgRef&#39;:&#39;.pySections(1)&#39;}" id="PEGA_TABBED0" tabgroupid="TGCPMInteractionPortalWorkAreaA" tabgroupname="c66230a4-dae4-4346-afb0-c6c544079c8e" activewhentab="" defaulttab="1" class="yui-navset pegaTabGrp yui-navset-top contents-wrapper with-fixed-header headerTabbed headerTabbed-t" data-taberror="Correct all fields containing errors. " data-pos="Top">
                          <div data-stcd="1" class="yui-content contents tabContent">
                            <div style="display: none;" role="tabpanel" class="tabpanelnofocus" tabindex="-1" aria-hidden="true">
                            </div>
                            <div class="dynamicContainer iframe-wrapper tabbed_expandInnerDivStyle tabpanelnofocus" role="tabpanel" id="PegaWebGadget0" style="display: none;" section_index="" pegathread="PS2__TABTHREAD0" pegagadget="PegaGadget0" pegae_ondomready="pega.ui.WorkAreaGadget.onGadgetDomReady" pegae_onerror="pega.ui.WorkAreaGadget.onGadgetDomReady" pegae_onload="pega.ui.WorkAreaGadget.onGadgetDomLoad" pegae_onclose="pega.ui.WorkAreaGadget.onGadgetClose" aria-labelledby="Tab2" tabindex="-1" aria-hidden="true">
                              <iframe name="PegaGadget0Ifr" allow="geolocation *;" id="PegaGadget0Ifr" border="0" frameborder="0" src="./Test9_files/saved_resource.html" style="" title="Home"></iframe>
                            </div>
                            <div class="dynamicContainer iframe-wrapper tabbed_expandInnerDivStyle tabpanelnofocus" role="tabpanel" id="PegaWebGadget1" style="display: block;" section_index="" pegathread="PS2__TABTHREAD1" pegagadget="PegaGadget1" pegae_ondomready="pega.ui.WorkAreaGadget.onGadgetDomReady" pegae_onerror="pega.ui.WorkAreaGadget.onGadgetDomReady" pegae_onload="pega.ui.WorkAreaGadget.onGadgetDomLoad" pegae_onclose="pega.ui.WorkAreaGadget.onGadgetClose" aria-labelledby="Tab3" tabindex="-1" aria-hidden="false">
                              <iframe name="PegaGadget1Ifr" allow="geolocation *;" id="PegaGadget1Ifr" border="0" frameborder="0" src="./Test9_files/!PS2__TABTHREAD1.html" style="height:1900px;width:100%" title="New"></iframe>
                            </div>
                          </div><input type="hidden" name="EXPANDEDTGCPMInteractionPortalWorkAreaA" value="3">
                          <div id="" style="display:none">
                            <ul id="HeaderTemplateList" class="yui-nav tab-ul tab-ul-t tab-ul-t-ns ">
                              <!--<li role = "tab" aria-selected="false" aria-label="{LBL}" tabindex="-1" section_index="{IND}" id="Tab{IND}" sel_prefix='tab-li-t-ns' class="tab-li tab-li-t tab-li-t-ns " ><span  id="TABANCHOR"><span id="TABSPAN" class="textOut tab-span tab-span-t tab-span-t-ns " style="white-space: nowrap;"><table role="presentation" id='RULE_KEY' width='auto' cellSpacing=0 cellPadding=0 ><tbody><tr><td noWrap=''><img data-wi='1' style='display:none' /></td><td noWrap=''><span data-stl= "1" id="" inAnchor="" >{LBL}</span><td noWrap='' class='reset-line-height'><span role="button" id="close" aria-label="Close Tab" title="Close Tab" tabindex="-1" class="iconCloseSmall" data-stc="1" style="margin-left:3px;vertical-align:top"></span></td></tr></tbody></table></span></span></li>-->
                            </ul>
                            <div class="dynamicContainer iframe-wrapper tabbed_expandInnerDivStyle" role="tabpanel" id="BodyTemplate" style="display:none;" section_index=""></div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="content-item content-sub_section item-2 remove-bottom-spacing remove-left-spacing remove-right-spacing flex flex-row inbound-wrapper" string_type="sub_section" reserve_space="false" data-ui-meta="{&#39;type&#39;:&#39;Cell&#39;,&#39;subType&#39;:&#39;SUB_SECTION&#39;,&#39;clipboardPath&#39;:&#39;CPMInboundEmailArea&#39;,&#39;className&#39;:&#39;CPM-Portal&#39;,&#39;pgRef&#39;:&#39;.pySections(1).pySectionBody(1).pyTable.pyRows(1).pyCells(2)&#39;}" data-template="">

                  <div data-ui-meta="{&#39;type&#39;:&#39;Section&#39;,&#39;ruleName&#39;:&#39;CPMInboundEmailArea&#39;,&#39;insKey&#39;:&#39;RULE-HTML-SECTION CPM-PORTAL CPMINBOUNDEMAILAREA #20200817T053735.759 GMT&#39;,&#39;sectionType&#39;:&#39;standard&#39;}" data-template="" node_name="CPMInboundEmailArea" node_type="MAIN_RULE" name="BASE_REF" id="RULE_KEY" class="sectionDivStyle  " style="" base_ref="" data-node-id="CPMInboundEmailArea" version="1" objclass="Rule-HTML-Section" pyclassname="CPM-Portal" readonly="false" expandrl="" index="" uniqueid="SID1698333988684">
                    <div bsimplelayout="true" data-template="" class=" flex content layout-content-default  content-default " data-test-id="201801101655380295961" style="display:none" data-ui-meta="{&#39;type&#39;:&#39;Layout&#39;,&#39;subType&#39;:&#39;DYNAMICLAYOUT&#39;,&#39;pgRef&#39;:&#39;.pySections(1)&#39;}" data-expr-id="9906777b9a1cdcb8b5193e20b0cdaf841a4b723c_3" data-context="pyDisplayHarness" data-methodname="">
                      <div class="content-item content-sub_section item-1 flex flex-row" string_type="sub_section" reserve_space="false" data-ui-meta="{&#39;type&#39;:&#39;Cell&#39;,&#39;subType&#39;:&#39;SUB_SECTION&#39;,&#39;clipboardPath&#39;:&#39;CPMInboundEmailWrapperForm&#39;,&#39;className&#39;:&#39;CPM-Portal&#39;,&#39;pgRef&#39;:&#39;.pySections(1).pySectionBody(1).pyTable.pyRows(1).pyCells(1)&#39;}" data-template="">
                        <div data-expr-id="9906777b9a1cdcb8b5193e20b0cdaf841a4b723c_9" data-context="D_Interaction_pa38226014852671pz">
                          <div data-ui-meta="{&#39;type&#39;:&#39;Section&#39;,&#39;ruleName&#39;:&#39;CPMInboundEmailWrapperForm&#39;,&#39;insKey&#39;:&#39;RULE-HTML-SECTION PEGACA-WORK-INTERACTION CPMINBOUNDEMAILWRAPPERFORM #20200817T054041.428 GMT&#39;,&#39;sectionType&#39;:&#39;standard&#39;}" data-template="" node_name="CPMInboundEmailWrapperForm" node_type="MAIN_RULE" name="BASE_REF" id="RULE_KEY" class="sectionDivStyle  " style="" base_ref="D_Interaction_pa38226014852671pz" data-node-id="CPMInboundEmailWrapperForm" version="1" objclass="Rule-HTML-Section" pyclassname="PegaCA-Work-Interaction" readonly="false" expandrl="" index="" uniqueid="SID1698333988685" data-declare-params="{&#39;InteractionId&#39;:&#39;#~D_CPMPortalContext.ParentID~#&#39;}" data-declarepage="D_Interaction">
                            <div bsimplelayout="true" data-template="" class=" flex content layout-content-default  content-default " data-test-id="201801091426430788394" data-ui-meta="{&#39;type&#39;:&#39;Layout&#39;,&#39;subType&#39;:&#39;DYNAMICLAYOUT&#39;,&#39;pgRef&#39;:&#39;.pySections(1)&#39;}" data-methodname=""></div>
                          </div>
                        </div>
                      </div>
                    </div>
                    <div bsimplelayout="true" data-template="" class=" flex content layout-content-default  content-default " data-test-id="201801101655380295961" style="" data-ui-meta="{&#39;type&#39;:&#39;Layout&#39;,&#39;subType&#39;:&#39;DYNAMICLAYOUT&#39;,&#39;pgRef&#39;:&#39;.pySections(2)&#39;}" data-expr-id="9906777b9a1cdcb8b5193e20b0cdaf841a4b723c_12" data-context="pyDisplayHarness" data-methodname="">
                      <div class="content-item content-sub_section item-1 flex flex-row" string_type="sub_section" reserve_space="false" data-ui-meta="{&#39;type&#39;:&#39;Cell&#39;,&#39;subType&#39;:&#39;SUB_SECTION&#39;,&#39;clipboardPath&#39;:&#39;CPMInboundEmailWrapperForm&#39;,&#39;className&#39;:&#39;CPM-Portal&#39;,&#39;pgRef&#39;:&#39;.pySections(2).pySectionBody(1).pyTable.pyRows(1).pyCells(1)&#39;}" data-template="">
                        <div data-expr-id="9906777b9a1cdcb8b5193e20b0cdaf841a4b723c_9" data-context="D_Interaction_pa38226014852671pz">
                          <div data-ui-meta="{&#39;type&#39;:&#39;Section&#39;,&#39;ruleName&#39;:&#39;CPMInboundEmailWrapperForm&#39;,&#39;insKey&#39;:&#39;RULE-HTML-SECTION PEGACA-WORK-INTERACTION CPMINBOUNDEMAILWRAPPERFORM #20200817T054041.428 GMT&#39;,&#39;sectionType&#39;:&#39;standard&#39;}" data-template="" node_name="CPMInboundEmailWrapperForm" node_type="MAIN_RULE" name="BASE_REF" id="RULE_KEY" class="sectionDivStyle  " style="" base_ref="D_Interaction_pa38226014852671pz" data-node-id="CPMInboundEmailWrapperForm" version="1" objclass="Rule-HTML-Section" pyclassname="PegaCA-Work-Interaction" readonly="false" expandrl="" index="" uniqueid="SID1698333988686" data-declare-params="{&#39;InteractionId&#39;:&#39;#~D_CPMPortalContext.pyID~#&#39;}" data-declarepage="D_Interaction">
                            <div bsimplelayout="true" data-template="" class=" flex content layout-content-default  content-default " data-test-id="201801091426430788394" data-ui-meta="{&#39;type&#39;:&#39;Layout&#39;,&#39;subType&#39;:&#39;DYNAMICLAYOUT&#39;,&#39;pgRef&#39;:&#39;.pySections(1)&#39;}" data-methodname=""></div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="content-item content-sub_section item-3 remove-bottom-spacing remove-left-spacing remove-right-spacing flex flex-row" string_type="sub_section" reserve_space="false" data-ui-meta="{&#39;type&#39;:&#39;Cell&#39;,&#39;subType&#39;:&#39;SUB_SECTION&#39;,&#39;clipboardPath&#39;:&#39;ToasterPop&#39;,&#39;className&#39;:&#39;CPM-Portal&#39;,&#39;pgRef&#39;:&#39;.pySections(1).pySectionBody(1).pyTable.pyRows(1).pyCells(3)&#39;}" data-template="">

                  <div aria-live="polite" aria-atomic="true" id="toasterpop">
                  </div>
                </div>
              </div>
              <span class="inspector-span" data-template="" data-ui-meta="{&#39;type&#39;:&#39;Layout&#39;,&#39;subType&#39;:&#39;SECTIONINCLUDE&#39;,&#39;pgRef&#39;:&#39;.pySections(2)&#39;,&#39;clipboardPath&#39;:&#39;CSBodyHeightResizer&#39;}">
              </span>
            </div>

          </span>
        </div>
      </div>
    </main>
  </div>





</body></html>